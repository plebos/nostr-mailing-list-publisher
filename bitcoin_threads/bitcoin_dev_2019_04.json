[
    {
        "title": "[bitcoin-dev] Softfork proposal for minimum price of $50k USD/BTC",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2019-04-01T00:30:34",
                "message_text_only": "Certain parts of the community have been selling bitcoins for unreasonably\nlow prices. This has halted Bitcoin's valuation at $20k and even driven the\nprice down below $15k! However, clearly Bitcoin is worth much more than\nthat, and there is widespread support for higher prices.\n\nIn light of this, I have written and implemented two BIPs: one to add a\nsigned price field to Bitcoin transactions, and the other to softfork a\nminimum price of $50k USD/BTC a year from today.\n\nThe BIPs are here, as well as included at the bottom of this email for \nconvenience:\n  https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\nhttps://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n\nA reference implementation is here:\n  https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n\nPlease review ASAP so we can get these deployed in Bitcoin Core v0.18.\n\nLuke\n\n\n<pre>\n  BIP: ?\n  Layer: Applications\n  Title: Signed USD Price Indicator\n  Author: Luke Dashjr <luke+bip at dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-04-01\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP proposes a method to explicitly specify and sign the USD/BTC price \nfor transactions.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nCertain parts of the community have been selling bitcoins for unreasonably low \nprices. This has halted Bitcoin's valuation at $20k and even driven the price \ndown below $15k! However, clearly Bitcoin is worth much more than that, and \nthere is widespread support for higher prices.\n\nThis problem can be fixed by setting a global minimum price for bitcoins. \nUnfortunately, today, the consensus protocol is completely oblivious to the \nprice bitcoins are traded at. Therefore, we must first add a field to Bitcoin \ntransactions to indicate their price.\n\n==Specification==\n\n===New field and legal implication===\n\nA new field is added to Bitcoin transactions. This field, if present, must \nrepresent the honest and true USD/BTC rate used for the transaction. By \nsigning the transaction, the sender legally affirms this is the valuation of \nbitcoins used for the transaction.\n\nFor the avoidance of doubt: when the transaction is valued in a currency other \nthan USD, any reasonable exchange rate may be used to come up with the USD \nvaluation.\n\n===Serialisation===\n\nWhen serialising the transaction for any purpose, including signing, weight \ncalculation, and so on, the output count must be incremented by one. Prior to \nthe first real output, the following bytes must be inserted:\n\n* Constant: 00 00 00 00 00 00 00 00\n* A single byte, the size in bytes of the remainder of the inserted data\n* Constant: 6a 04 55 53 44 24\n* A single byte, the size in bytes of the remainder of the inserted data\n* The USD/BTC rate used for the transaction, in standard signed integer \nserialisation, with all leading zeros removed (except as necessary to \npreserve the sign bit).\n\n==Backwards compatibility==\n\n===Consensus===\n\nThe new price field is serialised as a dummy output, with a value of zero, and \na scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore \nthis dummy output, and the leading OP_RETURN in the scriptPubKey ensures it \nis never considered spendable.\n\nTherefore, current nodes will ignore the new field entirely, and accept \ntransactions using it.\n\n===Wallets===\n\nExisting wallets do not typically generate price indicators as specified. \nUnder this BIP, this absence of the field is perfectly acceptable.\n\n==Reference implementation==\n\nhttps://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n\n<pre>\n  BIP: ?\n  Layer: Consensus (soft fork)\n  Title: $50k USD/BTC Minimum Price\n  Author: Luke Dashjr <luke+bip at dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-04-01\n  License: BSD-2-Clause\n  Requires: usdprice\n</pre>\n\n==Abstract==\n\nThis BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nCertain parts of the community have been selling bitcoins for unreasonably low \nprices. This has halted Bitcoin's valuation at $20k and even driven the price \ndown below $15k! However, clearly Bitcoin is worth much more than that, and \nthere is widespread support for higher prices.\n\nbip-usdprice defines a new field to indicate the price of transactions. Using \nthis, we can softfork to require a minimum transaction price.\n\n==Specification==\n\nBeginning with block height 622370 (expected approximately 2020 April 1), a \nblock is reject as invalid unless all transactions it contains both declare a \nUSD/BTC price (as defined in bip-usdprice) and specify a price that is at a \nminimum $50k USD/BTC.\n\n==Backwards compatibility==\n\nAs a soft fork, older nodes will continue to accept the blockchain without \nmodification. Non-upgraded nodes, however, will not validate the minimum \nprice requirement, and may accept invalid blocks if miners choose to make \nthem. Since transactions not declaring a price are at this time still \ncommon-place, the softfork activation has been set a full year into the \nfuture to ensure time to upgrade both nodes and wallet software.\n\n==Reference implementation==\n\nhttps://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k"
            },
            {
                "author": "Ricardo Filipe",
                "date": "2019-04-01T01:04:10",
                "message_text_only": "one year seems too long. i think with the BIP-148 experience you have\nwe could easily get there in 6 months at most.\n\nLuke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nescreveu no dia segunda, 1/04/2019 \u00e0(s) 01:33:\n>\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price down below $15k! However, clearly Bitcoin is worth much more than\n> that, and there is widespread support for higher prices.\n>\n> In light of this, I have written and implemented two BIPs: one to add a\n> signed price field to Bitcoin transactions, and the other to softfork a\n> minimum price of $50k USD/BTC a year from today.\n>\n> The BIPs are here, as well as included at the bottom of this email for\n> convenience:\n>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n>\n> A reference implementation is here:\n>   https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n>\n> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n>\n> Luke\n>\n>\n> <pre>\n>   BIP: ?\n>   Layer: Applications\n>   Title: Signed USD Price Indicator\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP proposes a method to explicitly specify and sign the USD/BTC price\n> for transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the price\n> down below $15k! However, clearly Bitcoin is worth much more than that, and\n> there is widespread support for higher prices.\n>\n> This problem can be fixed by setting a global minimum price for bitcoins.\n> Unfortunately, today, the consensus protocol is completely oblivious to the\n> price bitcoins are traded at. Therefore, we must first add a field to Bitcoin\n> transactions to indicate their price.\n>\n> ==Specification==\n>\n> ===New field and legal implication===\n>\n> A new field is added to Bitcoin transactions. This field, if present, must\n> represent the honest and true USD/BTC rate used for the transaction. By\n> signing the transaction, the sender legally affirms this is the valuation of\n> bitcoins used for the transaction.\n>\n> For the avoidance of doubt: when the transaction is valued in a currency other\n> than USD, any reasonable exchange rate may be used to come up with the USD\n> valuation.\n>\n> ===Serialisation===\n>\n> When serialising the transaction for any purpose, including signing, weight\n> calculation, and so on, the output count must be incremented by one. Prior to\n> the first real output, the following bytes must be inserted:\n>\n> * Constant: 00 00 00 00 00 00 00 00\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * Constant: 6a 04 55 53 44 24\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * The USD/BTC rate used for the transaction, in standard signed integer\n> serialisation, with all leading zeros removed (except as necessary to\n> preserve the sign bit).\n>\n> ==Backwards compatibility==\n>\n> ===Consensus===\n>\n> The new price field is serialised as a dummy output, with a value of zero, and\n> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore\n> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it\n> is never considered spendable.\n>\n> Therefore, current nodes will ignore the new field entirely, and accept\n> transactions using it.\n>\n> ===Wallets===\n>\n> Existing wallets do not typically generate price indicators as specified.\n> Under this BIP, this absence of the field is perfectly acceptable.\n>\n> ==Reference implementation==\n>\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n>\n> <pre>\n>   BIP: ?\n>   Layer: Consensus (soft fork)\n>   Title: $50k USD/BTC Minimum Price\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n>   Requires: usdprice\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the price\n> down below $15k! However, clearly Bitcoin is worth much more than that, and\n> there is widespread support for higher prices.\n>\n> bip-usdprice defines a new field to indicate the price of transactions. Using\n> this, we can softfork to require a minimum transaction price.\n>\n> ==Specification==\n>\n> Beginning with block height 622370 (expected approximately 2020 April 1), a\n> block is reject as invalid unless all transactions it contains both declare a\n> USD/BTC price (as defined in bip-usdprice) and specify a price that is at a\n> minimum $50k USD/BTC.\n>\n> ==Backwards compatibility==\n>\n> As a soft fork, older nodes will continue to accept the blockchain without\n> modification. Non-upgraded nodes, however, will not validate the minimum\n> price requirement, and may accept invalid blocks if miners choose to make\n> them. Since transactions not declaring a price are at this time still\n> common-place, the softfork activation has been set a full year into the\n> future to ensure time to upgrade both nodes and wallet software.\n>\n> ==Reference implementation==\n>\n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Thomas France",
                "date": "2019-04-01T02:57:57",
                "message_text_only": "Once again, Core shows how conservative they are. I am in favor of 2X with\na 100kUSD minimum price, all Bitcoin businesses are with me !\n\nOn Sun, Mar 31, 2019 at 7:48 PM Ricardo Filipe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> one year seems too long. i think with the BIP-148 experience you have\n> we could easily get there in 6 months at most.\n>\n> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> escreveu no dia segunda, 1/04/2019 \u00e0(s) 01:33:\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably\n> > low prices. This has halted Bitcoin's valuation at $20k and even driven\n> the\n> > price down below $15k! However, clearly Bitcoin is worth much more than\n> > that, and there is widespread support for higher prices.\n> >\n> > In light of this, I have written and implemented two BIPs: one to add a\n> > signed price field to Bitcoin transactions, and the other to softfork a\n> > minimum price of $50k USD/BTC a year from today.\n> >\n> > The BIPs are here, as well as included at the bottom of this email for\n> > convenience:\n> >\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n> >\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n> >\n> > A reference implementation is here:\n> >\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n> >\n> > Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n> >\n> > Luke\n> >\n> >\n> > <pre>\n> >   BIP: ?\n> >   Layer: Applications\n> >   Title: Signed USD Price Indicator\n> >   Author: Luke Dashjr <luke+bip at dashjr.org>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n> >   Status: Draft\n> >   Type: Standards Track\n> >   Created: 2019-04-01\n> >   License: BSD-2-Clause\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This BIP proposes a method to explicitly specify and sign the USD/BTC\n> price\n> > for transactions.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably low\n> > prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> > down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> > there is widespread support for higher prices.\n> >\n> > This problem can be fixed by setting a global minimum price for bitcoins.\n> > Unfortunately, today, the consensus protocol is completely oblivious to\n> the\n> > price bitcoins are traded at. Therefore, we must first add a field to\n> Bitcoin\n> > transactions to indicate their price.\n> >\n> > ==Specification==\n> >\n> > ===New field and legal implication===\n> >\n> > A new field is added to Bitcoin transactions. This field, if present,\n> must\n> > represent the honest and true USD/BTC rate used for the transaction. By\n> > signing the transaction, the sender legally affirms this is the\n> valuation of\n> > bitcoins used for the transaction.\n> >\n> > For the avoidance of doubt: when the transaction is valued in a currency\n> other\n> > than USD, any reasonable exchange rate may be used to come up with the\n> USD\n> > valuation.\n> >\n> > ===Serialisation===\n> >\n> > When serialising the transaction for any purpose, including signing,\n> weight\n> > calculation, and so on, the output count must be incremented by one.\n> Prior to\n> > the first real output, the following bytes must be inserted:\n> >\n> > * Constant: 00 00 00 00 00 00 00 00\n> > * A single byte, the size in bytes of the remainder of the inserted data\n> > * Constant: 6a 04 55 53 44 24\n> > * A single byte, the size in bytes of the remainder of the inserted data\n> > * The USD/BTC rate used for the transaction, in standard signed integer\n> > serialisation, with all leading zeros removed (except as necessary to\n> > preserve the sign bit).\n> >\n> > ==Backwards compatibility==\n> >\n> > ===Consensus===\n> >\n> > The new price field is serialised as a dummy output, with a value of\n> zero, and\n> > a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will\n> ignore\n> > this dummy output, and the leading OP_RETURN in the scriptPubKey ensures\n> it\n> > is never considered spendable.\n> >\n> > Therefore, current nodes will ignore the new field entirely, and accept\n> > transactions using it.\n> >\n> > ===Wallets===\n> >\n> > Existing wallets do not typically generate price indicators as specified.\n> > Under this BIP, this absence of the field is perfectly acceptable.\n> >\n> > ==Reference implementation==\n> >\n> >\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n> >\n> > <pre>\n> >   BIP: ?\n> >   Layer: Consensus (soft fork)\n> >   Title: $50k USD/BTC Minimum Price\n> >   Author: Luke Dashjr <luke+bip at dashjr.org>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n> >   Status: Draft\n> >   Type: Standards Track\n> >   Created: 2019-04-01\n> >   License: BSD-2-Clause\n> >   Requires: usdprice\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This BIP defines a minimum price of $50k USD/BTC for Bitcoin\n> transactions.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably low\n> > prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> > down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> > there is widespread support for higher prices.\n> >\n> > bip-usdprice defines a new field to indicate the price of transactions.\n> Using\n> > this, we can softfork to require a minimum transaction price.\n> >\n> > ==Specification==\n> >\n> > Beginning with block height 622370 (expected approximately 2020 April\n> 1), a\n> > block is reject as invalid unless all transactions it contains both\n> declare a\n> > USD/BTC price (as defined in bip-usdprice) and specify a price that is\n> at a\n> > minimum $50k USD/BTC.\n> >\n> > ==Backwards compatibility==\n> >\n> > As a soft fork, older nodes will continue to accept the blockchain\n> without\n> > modification. Non-upgraded nodes, however, will not validate the minimum\n> > price requirement, and may accept invalid blocks if miners choose to make\n> > them. Since transactions not declaring a price are at this time still\n> > common-place, the softfork activation has been set a full year into the\n> > future to ensure time to upgrade both nodes and wallet software.\n> >\n> > ==Reference implementation==\n> >\n> >\n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/7ee15f90/attachment.html>"
            },
            {
                "author": "Dave Scotese",
                "date": "2019-04-01T03:04:18",
                "message_text_only": "I think EXACTLY ONE YEAR is the perfect time.  Well, a year and a day for\nme because I'm on the wrong side of the date line, apparently.\n\nOn Sun, Mar 31, 2019 at 6:04 PM Ricardo Filipe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> one year seems too long. i think with the BIP-148 experience you have\n> we could easily get there in 6 months at most.\n>\n> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> escreveu no dia segunda, 1/04/2019 \u00e0(s) 01:33:\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably\n> > low prices. This has halted Bitcoin's valuation at $20k and even driven\n> the\n> > price down below $15k! However, clearly Bitcoin is worth much more than\n> > that, and there is widespread support for higher prices.\n> >\n> > In light of this, I have written and implemented two BIPs: one to add a\n> > signed price field to Bitcoin transactions, and the other to softfork a\n> > minimum price of $50k USD/BTC a year from today.\n> >\n> > The BIPs are here, as well as included at the bottom of this email for\n> > convenience:\n> >\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n> >\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n> >\n> > A reference implementation is here:\n> >\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n> >\n> > Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n> >\n> > Luke\n> >\n> >\n> > <pre>\n> >   BIP: ?\n> >   Layer: Applications\n> >   Title: Signed USD Price Indicator\n> >   Author: Luke Dashjr <luke+bip at dashjr.org>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n> >   Status: Draft\n> >   Type: Standards Track\n> >   Created: 2019-04-01\n> >   License: BSD-2-Clause\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This BIP proposes a method to explicitly specify and sign the USD/BTC\n> price\n> > for transactions.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably low\n> > prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> > down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> > there is widespread support for higher prices.\n> >\n> > This problem can be fixed by setting a global minimum price for bitcoins.\n> > Unfortunately, today, the consensus protocol is completely oblivious to\n> the\n> > price bitcoins are traded at. Therefore, we must first add a field to\n> Bitcoin\n> > transactions to indicate their price.\n> >\n> > ==Specification==\n> >\n> > ===New field and legal implication===\n> >\n> > A new field is added to Bitcoin transactions. This field, if present,\n> must\n> > represent the honest and true USD/BTC rate used for the transaction. By\n> > signing the transaction, the sender legally affirms this is the\n> valuation of\n> > bitcoins used for the transaction.\n> >\n> > For the avoidance of doubt: when the transaction is valued in a currency\n> other\n> > than USD, any reasonable exchange rate may be used to come up with the\n> USD\n> > valuation.\n> >\n> > ===Serialisation===\n> >\n> > When serialising the transaction for any purpose, including signing,\n> weight\n> > calculation, and so on, the output count must be incremented by one.\n> Prior to\n> > the first real output, the following bytes must be inserted:\n> >\n> > * Constant: 00 00 00 00 00 00 00 00\n> > * A single byte, the size in bytes of the remainder of the inserted data\n> > * Constant: 6a 04 55 53 44 24\n> > * A single byte, the size in bytes of the remainder of the inserted data\n> > * The USD/BTC rate used for the transaction, in standard signed integer\n> > serialisation, with all leading zeros removed (except as necessary to\n> > preserve the sign bit).\n> >\n> > ==Backwards compatibility==\n> >\n> > ===Consensus===\n> >\n> > The new price field is serialised as a dummy output, with a value of\n> zero, and\n> > a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will\n> ignore\n> > this dummy output, and the leading OP_RETURN in the scriptPubKey ensures\n> it\n> > is never considered spendable.\n> >\n> > Therefore, current nodes will ignore the new field entirely, and accept\n> > transactions using it.\n> >\n> > ===Wallets===\n> >\n> > Existing wallets do not typically generate price indicators as specified.\n> > Under this BIP, this absence of the field is perfectly acceptable.\n> >\n> > ==Reference implementation==\n> >\n> >\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n> >\n> > <pre>\n> >   BIP: ?\n> >   Layer: Consensus (soft fork)\n> >   Title: $50k USD/BTC Minimum Price\n> >   Author: Luke Dashjr <luke+bip at dashjr.org>\n> >   Comments-Summary: No comments yet.\n> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n> >   Status: Draft\n> >   Type: Standards Track\n> >   Created: 2019-04-01\n> >   License: BSD-2-Clause\n> >   Requires: usdprice\n> > </pre>\n> >\n> > ==Abstract==\n> >\n> > This BIP defines a minimum price of $50k USD/BTC for Bitcoin\n> transactions.\n> >\n> > ==Copyright==\n> >\n> > This BIP is licensed under the BSD 2-clause license.\n> >\n> > ==Motivation==\n> >\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably low\n> > prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> > down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> > there is widespread support for higher prices.\n> >\n> > bip-usdprice defines a new field to indicate the price of transactions.\n> Using\n> > this, we can softfork to require a minimum transaction price.\n> >\n> > ==Specification==\n> >\n> > Beginning with block height 622370 (expected approximately 2020 April\n> 1), a\n> > block is reject as invalid unless all transactions it contains both\n> declare a\n> > USD/BTC price (as defined in bip-usdprice) and specify a price that is\n> at a\n> > minimum $50k USD/BTC.\n> >\n> > ==Backwards compatibility==\n> >\n> > As a soft fork, older nodes will continue to accept the blockchain\n> without\n> > modification. Non-upgraded nodes, however, will not validate the minimum\n> > price requirement, and may accept invalid blocks if miners choose to make\n> > them. Since transactions not declaring a price are at this time still\n> > common-place, the softfork activation has been set a full year into the\n> > future to ensure time to upgrade both nodes and wallet software.\n> >\n> > ==Reference implementation==\n> >\n> >\n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/6f6bb0ce/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-04-01T01:11:12",
                "message_text_only": "On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price down below $15k! However, clearly Bitcoin is worth much more than\n> that, and there is widespread support for higher prices.\n> \n> In light of this, I have written and implemented two BIPs: one to add a\n> signed price field to Bitcoin transactions, and the other to softfork a\n> minimum price of $50k USD/BTC a year from today.\n\nI believe I've found a serious vulnerability in your proposal: there's no limit\non the maximum supply of USD.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/22f5e18a/attachment.sig>"
            },
            {
                "author": "Omar Shibli",
                "date": "2019-04-01T02:55:41",
                "message_text_only": "Shit, so we are vulnerable today? is this zero day vulnerability? so we\ncould be f***** big?\n\nOn Mon, Apr 1, 2019 at 5:47 AM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev\n> wrote:\n> > Certain parts of the community have been selling bitcoins for\n> unreasonably\n> > low prices. This has halted Bitcoin's valuation at $20k and even driven\n> the\n> > price down below $15k! However, clearly Bitcoin is worth much more than\n> > that, and there is widespread support for higher prices.\n> >\n> > In light of this, I have written and implemented two BIPs: one to add a\n> > signed price field to Bitcoin transactions, and the other to softfork a\n> > minimum price of $50k USD/BTC a year from today.\n>\n> I believe I've found a serious vulnerability in your proposal: there's no\n> limit\n> on the maximum supply of USD.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/73e3c005/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-01T03:02:28",
                "message_text_only": "Hard NAK.\n\nA minimum 50000 USD : 1 BTC exchange rate implies that the value of 1 USD = 0.00002 BTC at maximum.\n\nHowever, such a USD value in BTC value maximum makes no sense since the true value of 1 USD = 0.00000000 BTC.\n(on Lightning, 1 USD = 0.00000000000 BTC)\n\nIn particular, the encoding proposed in the BIP does not support a representation of infinity USD per BTC, such that it is impossible to express the true value of USD under this BIP.\n\n> * The USD/BTC rate used for the transaction, in standard signed integer serialisation, with all leading zeros removed (except as necessary to preserve the sign bit).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Satoshin",
                "date": "2019-04-01T03:07:41",
                "message_text_only": "Hi Everyone,\n     First portion of your First BIP is excellent- with this field the protocol can actually attain HFT- by  pinning of value at time of trade for later unblock scaling as a mark to market tool which is used in HFT.\n\nThe Second BIP of a minimum price would never allow Bitcoin to pass the SEC test of a viable asset. - I hope that portion was actually a Joke since it makes no sense economically. \nIf one has ever seen a stock drop 90% in one day then you would understand the volatile nature of future valuation.\n\nPrices have to be able to go higher and lower based on market demand and not tethering to perceived norms. If the US dollar was crashed and it went down to Venezuelan currency levels [hypothetically then where would your 50k limit lead the currency} Never say never- \n\nBest Regards\nXX\n \n> On Mar 31, 2019, at 9:11 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:\n>> Certain parts of the community have been selling bitcoins for unreasonably\n>> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n>> price down below $15k! However, clearly Bitcoin is worth much more than\n>> that, and there is widespread support for higher prices.\n>> \n>> In light of this, I have written and implemented two BIPs: one to add a\n>> signed price field to Bitcoin transactions, and the other to softfork a\n>> minimum price of $50k USD/BTC a year from today.\n> \n> I believe I've found a serious vulnerability in your proposal: there's no limit\n> on the maximum supply of USD.\n> \n> -- \n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-04-01T08:55:00",
                "message_text_only": "It is April 1st. Nonetheless, I am agreed that the first part to track the exchange rate in USD (why not use Gold $/oz?) has merit if properly implemented. Voluntary data is notoriously difficult to enforce for accuracy.\n\nRegards,\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Satoshin via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Monday, 1 April 2019 2:07 PM\nTo: Peter Todd; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] Softfork proposal for minimum price of $50k USD/BTC\n\nHi Everyone,\n     First portion of your First BIP is excellent- with this field the protocol can actually attain HFT- by  pinning of value at time of trade for later unblock scaling as a mark to market tool which is used in HFT.\n\nThe Second BIP of a minimum price would never allow Bitcoin to pass the SEC test of a viable asset. - I hope that portion was actually a Joke since it makes no sense economically.\nIf one has ever seen a stock drop 90% in one day then you would understand the volatile nature of future valuation.\n\nPrices have to be able to go higher and lower based on market demand and not tethering to perceived norms. If the US dollar was crashed and it went down to Venezuelan currency levels [hypothetically then where would your 50k limit lead the currency} Never say never-\n\nBest Regards\nXX\n\n> On Mar 31, 2019, at 9:11 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:\n>> Certain parts of the community have been selling bitcoins for unreasonably\n>> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n>> price down below $15k! However, clearly Bitcoin is worth much more than\n>> that, and there is widespread support for higher prices.\n>>\n>> In light of this, I have written and implemented two BIPs: one to add a\n>> signed price field to Bitcoin transactions, and the other to softfork a\n>> minimum price of $50k USD/BTC a year from today.\n>\n> I believe I've found a serious vulnerability in your proposal: there's no limit\n> on the maximum supply of USD.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/82a31c09/attachment-0001.html>"
            },
            {
                "author": "Omar Shibli",
                "date": "2019-04-01T02:54:16",
                "message_text_only": "Reasonable, I think also first timer should be forbidden form transacting\nfor at least 3 years from the first purchase, after going in '3 years' into\nthe rabbit hole, you can consider selling bitcoins. that's fair for low\ntime hard money folks, imho.\n\nOn Mon, Apr 1, 2019 at 3:33 AM Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price down below $15k! However, clearly Bitcoin is worth much more than\n> that, and there is widespread support for higher prices.\n>\n> In light of this, I have written and implemented two BIPs: one to add a\n> signed price field to Bitcoin transactions, and the other to softfork a\n> minimum price of $50k USD/BTC a year from today.\n>\n> The BIPs are here, as well as included at the bottom of this email for\n> convenience:\n>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n>\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n>\n> A reference implementation is here:\n>\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n>\n> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n>\n> Luke\n>\n>\n> <pre>\n>   BIP: ?\n>   Layer: Applications\n>   Title: Signed USD Price Indicator\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP proposes a method to explicitly specify and sign the USD/BTC\n> price\n> for transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> there is widespread support for higher prices.\n>\n> This problem can be fixed by setting a global minimum price for bitcoins.\n> Unfortunately, today, the consensus protocol is completely oblivious to\n> the\n> price bitcoins are traded at. Therefore, we must first add a field to\n> Bitcoin\n> transactions to indicate their price.\n>\n> ==Specification==\n>\n> ===New field and legal implication===\n>\n> A new field is added to Bitcoin transactions. This field, if present, must\n> represent the honest and true USD/BTC rate used for the transaction. By\n> signing the transaction, the sender legally affirms this is the valuation\n> of\n> bitcoins used for the transaction.\n>\n> For the avoidance of doubt: when the transaction is valued in a currency\n> other\n> than USD, any reasonable exchange rate may be used to come up with the USD\n> valuation.\n>\n> ===Serialisation===\n>\n> When serialising the transaction for any purpose, including signing,\n> weight\n> calculation, and so on, the output count must be incremented by one. Prior\n> to\n> the first real output, the following bytes must be inserted:\n>\n> * Constant: 00 00 00 00 00 00 00 00\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * Constant: 6a 04 55 53 44 24\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * The USD/BTC rate used for the transaction, in standard signed integer\n> serialisation, with all leading zeros removed (except as necessary to\n> preserve the sign bit).\n>\n> ==Backwards compatibility==\n>\n> ===Consensus===\n>\n> The new price field is serialised as a dummy output, with a value of zero,\n> and\n> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore\n> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures\n> it\n> is never considered spendable.\n>\n> Therefore, current nodes will ignore the new field entirely, and accept\n> transactions using it.\n>\n> ===Wallets===\n>\n> Existing wallets do not typically generate price indicators as specified.\n> Under this BIP, this absence of the field is perfectly acceptable.\n>\n> ==Reference implementation==\n>\n>\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n>\n> <pre>\n>   BIP: ?\n>   Layer: Consensus (soft fork)\n>   Title: $50k USD/BTC Minimum Price\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n>   Requires: usdprice\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> there is widespread support for higher prices.\n>\n> bip-usdprice defines a new field to indicate the price of transactions.\n> Using\n> this, we can softfork to require a minimum transaction price.\n>\n> ==Specification==\n>\n> Beginning with block height 622370 (expected approximately 2020 April 1),\n> a\n> block is reject as invalid unless all transactions it contains both\n> declare a\n> USD/BTC price (as defined in bip-usdprice) and specify a price that is at\n> a\n> minimum $50k USD/BTC.\n>\n> ==Backwards compatibility==\n>\n> As a soft fork, older nodes will continue to accept the blockchain without\n> modification. Non-upgraded nodes, however, will not validate the minimum\n> price requirement, and may accept invalid blocks if miners choose to make\n> them. Since transactions not declaring a price are at this time still\n> common-place, the softfork activation has been set a full year into the\n> future to ensure time to upgrade both nodes and wallet software.\n>\n> ==Reference implementation==\n>\n>\n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/30e360be/attachment-0001.html>"
            },
            {
                "author": "Melvin Carvalho",
                "date": "2019-04-01T11:22:28",
                "message_text_only": "On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price down below $15k! However, clearly Bitcoin is worth much more than\n> that, and there is widespread support for higher prices.\n>\n> In light of this, I have written and implemented two BIPs: one to add a\n> signed price field to Bitcoin transactions, and the other to softfork a\n> minimum price of $50k USD/BTC a year from today.\n>\n> The BIPs are here, as well as included at the bottom of this email for\n> convenience:\n>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n>\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n>\n> A reference implementation is here:\n>\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n>\n> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n>\n\nThis seems a little arbitrary.  Ask yourself, \"Why the USD?\".  Yes, it is\nthe dominant currency now, but in 2, 6, 10, 14 years?  Who knows.\n\nYou could make equally an argument to denominate in euros.  Or a basket of\ncurrencies, or even the Bancor.\n\nHowever the wider question is why even denominate in fiat at all?\n\nI suggest denominating the minimum value in satoshsis themselves, which\nwould be a negligable upgrade to the network.\n\n\n>\n> Luke\n>\n>\n> <pre>\n>   BIP: ?\n>   Layer: Applications\n>   Title: Signed USD Price Indicator\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP proposes a method to explicitly specify and sign the USD/BTC\n> price\n> for transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> there is widespread support for higher prices.\n>\n> This problem can be fixed by setting a global minimum price for bitcoins.\n> Unfortunately, today, the consensus protocol is completely oblivious to\n> the\n> price bitcoins are traded at. Therefore, we must first add a field to\n> Bitcoin\n> transactions to indicate their price.\n>\n> ==Specification==\n>\n> ===New field and legal implication===\n>\n> A new field is added to Bitcoin transactions. This field, if present, must\n> represent the honest and true USD/BTC rate used for the transaction. By\n> signing the transaction, the sender legally affirms this is the valuation\n> of\n> bitcoins used for the transaction.\n>\n> For the avoidance of doubt: when the transaction is valued in a currency\n> other\n> than USD, any reasonable exchange rate may be used to come up with the USD\n> valuation.\n>\n> ===Serialisation===\n>\n> When serialising the transaction for any purpose, including signing,\n> weight\n> calculation, and so on, the output count must be incremented by one. Prior\n> to\n> the first real output, the following bytes must be inserted:\n>\n> * Constant: 00 00 00 00 00 00 00 00\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * Constant: 6a 04 55 53 44 24\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * The USD/BTC rate used for the transaction, in standard signed integer\n> serialisation, with all leading zeros removed (except as necessary to\n> preserve the sign bit).\n>\n> ==Backwards compatibility==\n>\n> ===Consensus===\n>\n> The new price field is serialised as a dummy output, with a value of zero,\n> and\n> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore\n> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures\n> it\n> is never considered spendable.\n>\n> Therefore, current nodes will ignore the new field entirely, and accept\n> transactions using it.\n>\n> ===Wallets===\n>\n> Existing wallets do not typically generate price indicators as specified.\n> Under this BIP, this absence of the field is perfectly acceptable.\n>\n> ==Reference implementation==\n>\n>\n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n>\n> <pre>\n>   BIP: ?\n>   Layer: Consensus (soft fork)\n>   Title: $50k USD/BTC Minimum Price\n>   Author: Luke Dashjr <luke+bip at dashjr.org>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n>   Requires: usdprice\n> </pre>\n>\n> ==Abstract==\n>\n> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Motivation==\n>\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low\n> prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price\n> down below $15k! However, clearly Bitcoin is worth much more than that,\n> and\n> there is widespread support for higher prices.\n>\n> bip-usdprice defines a new field to indicate the price of transactions.\n> Using\n> this, we can softfork to require a minimum transaction price.\n>\n> ==Specification==\n>\n> Beginning with block height 622370 (expected approximately 2020 April 1),\n> a\n> block is reject as invalid unless all transactions it contains both\n> declare a\n> USD/BTC price (as defined in bip-usdprice) and specify a price that is at\n> a\n> minimum $50k USD/BTC.\n>\n> ==Backwards compatibility==\n>\n> As a soft fork, older nodes will continue to accept the blockchain without\n> modification. Non-upgraded nodes, however, will not validate the minimum\n> price requirement, and may accept invalid blocks if miners choose to make\n> them. Since transactions not declaring a price are at this time still\n> common-place, the softfork activation has been set a full year into the\n> future to ensure time to upgrade both nodes and wallet software.\n>\n> ==Reference implementation==\n>\n>\n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/a7d3675c/attachment.html>"
            },
            {
                "author": "Dana L. Coe",
                "date": "2019-04-01T11:50:24",
                "message_text_only": "I suggest in the spirit of the times that we not use USD as the reference, but USDT.\n\nEveryone knows Tethers are much more flexible in tracking the true value of the US dollar.\n\nDana\n\n> On Apr 1, 2019, at 7:22 PM, Melvin Carvalho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> \n> On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> Certain parts of the community have been selling bitcoins for unreasonably\n> low prices. This has halted Bitcoin's valuation at $20k and even driven the\n> price down below $15k! However, clearly Bitcoin is worth much more than\n> that, and there is widespread support for higher prices.\n> \n> In light of this, I have written and implemented two BIPs: one to add a\n> signed price field to Bitcoin transactions, and the other to softfork a\n> minimum price of $50k USD/BTC a year from today.\n> \n> The BIPs are here, as well as included at the bottom of this email for \n> convenience:\n>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki <https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki>\n> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki <https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki>\n> \n> A reference implementation is here:\n>   https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k <https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k>\n> \n> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.\n> \n> This seems a little arbitrary.  Ask yourself, \"Why the USD?\".  Yes, it is the dominant currency now, but in 2, 6, 10, 14 years?  Who knows.\n> \n> You could make equally an argument to denominate in euros.  Or a basket of currencies, or even the Bancor.\n> \n> However the wider question is why even denominate in fiat at all?  \n> \n> I suggest denominating the minimum value in satoshsis themselves, which would be a negligable upgrade to the network.\n>  \n> \n> Luke\n> \n> \n> <pre>\n>   BIP: ?\n>   Layer: Applications\n>   Title: Signed USD Price Indicator\n>   Author: Luke Dashjr <luke+bip at dashjr.org <mailto:luke%2Bbip at dashjr.org>>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-?? <https://github.com/bitcoin/bips/wiki/Comments:BIP-??>??\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n> </pre>\n> \n> ==Abstract==\n> \n> This BIP proposes a method to explicitly specify and sign the USD/BTC price \n> for transactions.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Certain parts of the community have been selling bitcoins for unreasonably low \n> prices. This has halted Bitcoin's valuation at $20k and even driven the price \n> down below $15k! However, clearly Bitcoin is worth much more than that, and \n> there is widespread support for higher prices.\n> \n> This problem can be fixed by setting a global minimum price for bitcoins. \n> Unfortunately, today, the consensus protocol is completely oblivious to the \n> price bitcoins are traded at. Therefore, we must first add a field to Bitcoin \n> transactions to indicate their price.\n> \n> ==Specification==\n> \n> ===New field and legal implication===\n> \n> A new field is added to Bitcoin transactions. This field, if present, must \n> represent the honest and true USD/BTC rate used for the transaction. By \n> signing the transaction, the sender legally affirms this is the valuation of \n> bitcoins used for the transaction.\n> \n> For the avoidance of doubt: when the transaction is valued in a currency other \n> than USD, any reasonable exchange rate may be used to come up with the USD \n> valuation.\n> \n> ===Serialisation===\n> \n> When serialising the transaction for any purpose, including signing, weight \n> calculation, and so on, the output count must be incremented by one. Prior to \n> the first real output, the following bytes must be inserted:\n> \n> * Constant: 00 00 00 00 00 00 00 00\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * Constant: 6a 04 55 53 44 24\n> * A single byte, the size in bytes of the remainder of the inserted data\n> * The USD/BTC rate used for the transaction, in standard signed integer \n> serialisation, with all leading zeros removed (except as necessary to \n> preserve the sign bit).\n> \n> ==Backwards compatibility==\n> \n> ===Consensus===\n> \n> The new price field is serialised as a dummy output, with a value of zero, and \n> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore \n> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it \n> is never considered spendable.\n> \n> Therefore, current nodes will ignore the new field entirely, and accept \n> transactions using it.\n> \n> ===Wallets===\n> \n> Existing wallets do not typically generate price indicators as specified. \n> Under this BIP, this absence of the field is perfectly acceptable.\n> \n> ==Reference implementation==\n> \n> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field <https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field>\n> \n> <pre>\n>   BIP: ?\n>   Layer: Consensus (soft fork)\n>   Title: $50k USD/BTC Minimum Price\n>   Author: Luke Dashjr <luke+bip at dashjr.org <mailto:luke%2Bbip at dashjr.org>>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-?? <https://github.com/bitcoin/bips/wiki/Comments:BIP-??>??\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2019-04-01\n>   License: BSD-2-Clause\n>   Requires: usdprice\n> </pre>\n> \n> ==Abstract==\n> \n> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.\n> \n> ==Copyright==\n> \n> This BIP is licensed under the BSD 2-clause license.\n> \n> ==Motivation==\n> \n> Certain parts of the community have been selling bitcoins for unreasonably low \n> prices. This has halted Bitcoin's valuation at $20k and even driven the price \n> down below $15k! However, clearly Bitcoin is worth much more than that, and \n> there is widespread support for higher prices.\n> \n> bip-usdprice defines a new field to indicate the price of transactions. Using \n> this, we can softfork to require a minimum transaction price.\n> \n> ==Specification==\n> \n> Beginning with block height 622370 (expected approximately 2020 April 1), a \n> block is reject as invalid unless all transactions it contains both declare a \n> USD/BTC price (as defined in bip-usdprice) and specify a price that is at a \n> minimum $50k USD/BTC.\n> \n> ==Backwards compatibility==\n> \n> As a soft fork, older nodes will continue to accept the blockchain without \n> modification. Non-upgraded nodes, however, will not validate the minimum \n> price requirement, and may accept invalid blocks if miners choose to make \n> them. Since transactions not declaring a price are at this time still \n> common-place, the softfork activation has been set a full year into the \n> future to ensure time to upgrade both nodes and wallet software.\n> \n> ==Reference implementation==\n> \n> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k <https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/c9f2e2e4/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-02T16:48:55",
                "message_text_only": "Right and everybody knows that Tether is the most clever sidechain ever \ninvented far more sophisticated than lightning, which makes me think \nthat a punishment should be added in the proposal for the cheater \nadvertising a price < 50 k (or 100) and/or selling before 1-3 years \n(tbd) so all his coins go to the Bitcoin Mediator, a new notion here to \nsustain the community (I modestly apply for the position)\n\n\nLe 01/04/2019 \u00e0 13:50, Dana L. Coe via bitcoin-dev a \u00e9crit :\n> I suggest in the spirit of the times that we not use USD as the \n> reference, but USDT.\n>\n> Everyone knows Tethers are much more flexible in tracking the true \n> value of the US dollar.\n>\n> Dana\n>\n>> On Apr 1, 2019, at 7:22 PM, Melvin Carvalho via bitcoin-dev \n>> <bitcoin-dev at lists.linuxfoundation.org \n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>\n>>\n>> On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev \n>> <bitcoin-dev at lists.linuxfoundation.org \n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>     Certain parts of the community have been selling bitcoins for\n>>     unreasonably\n>>     low prices. This has halted Bitcoin's valuation at $20k and even\n>>     driven the\n>>     price down below $15k! However, clearly Bitcoin is worth much\n>>     more than\n>>     that, and there is widespread support for higher prices.\n>>\n>>     In light of this, I have written and implemented two BIPs: one to\n>>     add a\n>>     signed price field to Bitcoin transactions, and the other to\n>>     softfork a\n>>     minimum price of $50k USD/BTC a year from today.\n>>\n>>     The BIPs are here, as well as included at the bottom of this\n>>     email for\n>>     convenience:\n>>     https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki\n>>     https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki\n>>\n>>     A reference implementation is here:\n>>     https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k\n>>\n>>     Please review ASAP so we can get these deployed in Bitcoin Core\n>>     v0.18.\n>>\n>>\n>> This seems a little arbitrary.  Ask yourself, \"Why the USD?\".  Yes, \n>> it is the dominant currency now, but in 2, 6, 10, 14 years?  Who knows.\n>>\n>> You could make equally an argument to denominate in euros.  Or a \n>> basket of currencies, or even the Bancor.\n>>\n>> However the wider question is why even denominate in fiat at all?\n>>\n>> I suggest denominating the minimum value in satoshsis themselves, \n>> which would be a negligable upgrade to the network.\n>>\n>>\n>>     Luke\n>>\n>>\n>>     <pre>\n>>       BIP: ?\n>>       Layer: Applications\n>>       Title: Signed USD Price Indicator\n>>       Author: Luke Dashjr <luke+bip at dashjr.org\n>>     <mailto:luke%2Bbip at dashjr.org>>\n>>       Comments-Summary: No comments yet.\n>>       Comments-URI:\n>>     https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>>       Status: Draft\n>>       Type: Standards Track\n>>       Created: 2019-04-01\n>>       License: BSD-2-Clause\n>>     </pre>\n>>\n>>     ==Abstract==\n>>\n>>     This BIP proposes a method to explicitly specify and sign the\n>>     USD/BTC price\n>>     for transactions.\n>>\n>>     ==Copyright==\n>>\n>>     This BIP is licensed under the BSD 2-clause license.\n>>\n>>     ==Motivation==\n>>\n>>     Certain parts of the community have been selling bitcoins for\n>>     unreasonably low\n>>     prices. This has halted Bitcoin's valuation at $20k and even\n>>     driven the price\n>>     down below $15k! However, clearly Bitcoin is worth much more than\n>>     that, and\n>>     there is widespread support for higher prices.\n>>\n>>     This problem can be fixed by setting a global minimum price for\n>>     bitcoins.\n>>     Unfortunately, today, the consensus protocol is completely\n>>     oblivious to the\n>>     price bitcoins are traded at. Therefore, we must first add a\n>>     field to Bitcoin\n>>     transactions to indicate their price.\n>>\n>>     ==Specification==\n>>\n>>     ===New field and legal implication===\n>>\n>>     A new field is added to Bitcoin transactions. This field, if\n>>     present, must\n>>     represent the honest and true USD/BTC rate used for the\n>>     transaction. By\n>>     signing the transaction, the sender legally affirms this is the\n>>     valuation of\n>>     bitcoins used for the transaction.\n>>\n>>     For the avoidance of doubt: when the transaction is valued in a\n>>     currency other\n>>     than USD, any reasonable exchange rate may be used to come up\n>>     with the USD\n>>     valuation.\n>>\n>>     ===Serialisation===\n>>\n>>     When serialising the transaction for any purpose, including\n>>     signing, weight\n>>     calculation, and so on, the output count must be incremented by\n>>     one. Prior to\n>>     the first real output, the following bytes must be inserted:\n>>\n>>     * Constant: 00 00 00 00 00 00 00 00\n>>     * A single byte, the size in bytes of the remainder of the\n>>     inserted data\n>>     * Constant: 6a 04 55 53 44 24\n>>     * A single byte, the size in bytes of the remainder of the\n>>     inserted data\n>>     * The USD/BTC rate used for the transaction, in standard signed\n>>     integer\n>>     serialisation, with all leading zeros removed (except as\n>>     necessary to\n>>     preserve the sign bit).\n>>\n>>     ==Backwards compatibility==\n>>\n>>     ===Consensus===\n>>\n>>     The new price field is serialised as a dummy output, with a value\n>>     of zero, and\n>>     a scriptPubKey that begins with OP_RETURN (6a). Existing nodes\n>>     will ignore\n>>     this dummy output, and the leading OP_RETURN in the scriptPubKey\n>>     ensures it\n>>     is never considered spendable.\n>>\n>>     Therefore, current nodes will ignore the new field entirely, and\n>>     accept\n>>     transactions using it.\n>>\n>>     ===Wallets===\n>>\n>>     Existing wallets do not typically generate price indicators as\n>>     specified.\n>>     Under this BIP, this absence of the field is perfectly acceptable.\n>>\n>>     ==Reference implementation==\n>>\n>>     https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field\n>>\n>>     <pre>\n>>       BIP: ?\n>>       Layer: Consensus (soft fork)\n>>       Title: $50k USD/BTC Minimum Price\n>>       Author: Luke Dashjr <luke+bip at dashjr.org\n>>     <mailto:luke%2Bbip at dashjr.org>>\n>>       Comments-Summary: No comments yet.\n>>       Comments-URI:\n>>     https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>>       Status: Draft\n>>       Type: Standards Track\n>>       Created: 2019-04-01\n>>       License: BSD-2-Clause\n>>       Requires: usdprice\n>>     </pre>\n>>\n>>     ==Abstract==\n>>\n>>     This BIP defines a minimum price of $50k USD/BTC for Bitcoin\n>>     transactions.\n>>\n>>     ==Copyright==\n>>\n>>     This BIP is licensed under the BSD 2-clause license.\n>>\n>>     ==Motivation==\n>>\n>>     Certain parts of the community have been selling bitcoins for\n>>     unreasonably low\n>>     prices. This has halted Bitcoin's valuation at $20k and even\n>>     driven the price\n>>     down below $15k! However, clearly Bitcoin is worth much more than\n>>     that, and\n>>     there is widespread support for higher prices.\n>>\n>>     bip-usdprice defines a new field to indicate the price of\n>>     transactions. Using\n>>     this, we can softfork to require a minimum transaction price.\n>>\n>>     ==Specification==\n>>\n>>     Beginning with block height 622370 (expected approximately 2020\n>>     April 1), a\n>>     block is reject as invalid unless all transactions it contains\n>>     both declare a\n>>     USD/BTC price (as defined in bip-usdprice) and specify a price\n>>     that is at a\n>>     minimum $50k USD/BTC.\n>>\n>>     ==Backwards compatibility==\n>>\n>>     As a soft fork, older nodes will continue to accept the\n>>     blockchain without\n>>     modification. Non-upgraded nodes, however, will not validate the\n>>     minimum\n>>     price requirement, and may accept invalid blocks if miners choose\n>>     to make\n>>     them. Since transactions not declaring a price are at this time\n>>     still\n>>     common-place, the softfork activation has been set a full year\n>>     into the\n>>     future to ensure time to upgrade both nodes and wallet software.\n>>\n>>     ==Reference implementation==\n>>\n>>     https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org \n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nPeersm : http://www.peersm.com\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/8ef5619c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Softfork proposal for minimum price of $50k USD/BTC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Thomas France",
                "Satoshin",
                "Peter Todd",
                "Dana L. Coe",
                "Dave Scotese",
                "ZmnSCPxj",
                "Aymeric Vitte",
                "Luke Dashjr",
                "Ricardo Filipe",
                "Omar Shibli",
                "Melvin Carvalho"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 65040
        }
    },
    {
        "title": "[bitcoin-dev] BIP: Bitcoin Integrated Address Feature?",
        "thread_messages": [
            {
                "author": "nathanw at tutanota.com",
                "date": "2019-04-02T16:53:11",
                "message_text_only": "To whom it may concern,\n\nI believe a missing feature in Bitcoin is the ability to have an \"integrated address\", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.\n\nBy having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the \"sweeping\" step required to move multiple customer deposits from a hot address into a single cold address.\n\nAlthough it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n\nThus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being \"swept\" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.\n\nThere are several other more minor advantages such a feature would have, including:\n- Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.\n- Less need for large rescans after loading huge amounts of customer addresses into client software.\n- Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.\n- By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.\nThe integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.\n\nI'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.\n\nThanks for your time.\nRegards,\n\nNathan Worsley\nCTO - LocalCoinSwap.Com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment.html>"
            },
            {
                "author": "htimSxelA",
                "date": "2019-04-02T20:01:34",
                "message_text_only": "Hello,\n\nI see two immediate issues with this:\n1. Increased resource requirements per transaction\n2. Embedding identifying information into the blockchain is generally bad for privacy\n\nIt may help your case to provide some technical details of how you'd like to see this implemented, but without overcoming the issues mentioned above I think this proposal will be a very tough sell.\n\n> ...this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n\nI am not sure if I see how this issue is solved by your proposal. Assumedly, a human will still need to manually approve cold-wallet withdrawals in order to maintain security. So it seems to me that removing the 'hot-wallet' component of the backend would only amplify the need for human interaction.\n\nI assume you are familiar with hierarchical deterministic wallets? They can allow an exchange to assign/identify user deposits based on address derivation path. Keys for deposit addresses can be kept offline if wanted, and a proper implementation of an HD wallet system should also remove the need for rescans of user deposit addresses.\n\nThere is also a functionality built into Bitcoin that allows a user to prove that they own the private keys to some address: signing an agreed upon message using the private key that controls that address. Unfortunately I don't think this is a workable solution for you, since the majority of modern wallet software does not include this feature-- but perhaps worth mentioning nonetheless.\n\nBest,\nAlex\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> To whom it may concern,\n>\n> I believe a missing feature in Bitcoin is the ability to have an \"integrated address\", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.\n>\n> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the \"sweeping\" step required to move multiple customer deposits from a hot address into a single cold address.\n>\n> Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n>\n> Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being \"swept\" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.\n>\n> There are several other more minor advantages such a feature would have, including:\n> - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.\n> - Less need for large rescans after loading huge amounts of customer addresses into client software.\n> - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.\n> - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.\n>\n> The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.\n>\n> I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.\n>\n> Thanks for your time.\n>\n> Regards,\n>\n> Nathan Worsley\n> CTO - LocalCoinSwap.Com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment.html>"
            },
            {
                "author": "Ricardo Filipe",
                "date": "2019-04-02T23:52:16",
                "message_text_only": "I believe you are looking for HD wallets.\n\nNathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nescreveu no dia ter\u00e7a, 2/04/2019 \u00e0(s) 18:06:\n>\n> To whom it may concern,\n>\n> I believe a missing feature in Bitcoin is the ability to have an \"integrated address\", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.\n>\n> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the \"sweeping\" step required to move multiple customer deposits from a hot address into a single cold address.\n>"
            }
        ],
        "thread_summary": {
            "title": "BIP: Bitcoin Integrated Address Feature?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "htimSxelA",
                "Ricardo Filipe",
                "nathanw at tutanota.com"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9880
        }
    },
    {
        "title": "[bitcoin-dev] assumeutxo and UTXO snapshots",
        "thread_messages": [
            {
                "author": "James O'Beirne",
                "date": "2019-04-02T20:43:11",
                "message_text_only": "Hi,\n\nI'd like to discuss assumeutxo, which is an appealing and simple\noptimization in the spirit of assumevalid[0].\n\n# Motivation\n\nTo start a fully validating bitcoin client from scratch, that client\ncurrently\nneeds to perform an initial block download. To the surprise of no one, IBD\ntakes a linear amount time based on the length of the chain's history. For\nclients running on modest hardware under limited bandwidth constraints,\nsay a mobile device, completing IBD takes a considerable amount of time\nand thus poses serious usability challenges.\n\nAs a result, having fully validating clients run on such hardware is rare\nand\nbasically unrealistic. Clients with even moderate resource constraints\nare encouraged to rely on the SPV trust model. Though we have promising\nimprovements to existing SPV modes pending deployment[1], it's worth\nthinking about a mechanism that would allow such clients to use trust\nmodels closer to full validation.\n\nThe subject of this mail is a proposal for a complementary alternative to\nSPV\nmodes, and which is in the spirit of an existing default, `assumevalid`. It\nmay\nhelp modest clients transact under a security model that closely resembles\nfull validation within minutes instead of hours or days.\n\n# assumeutxo\n\nThe basic idea is to allow nodes to initialize using a serialized version\nof the\nUTXO set rendered by another node at some predetermined height. The\ninitializing node syncs the headers chain from the network, then obtains and\nloads one of these UTXO snapshots (i.e. a serialized version of the UTXO set\nbundled with the block header indicating its \"base\" and some other\nmetadata).\n\nBased upon the snapshot, the node is able to quickly reconstruct its\nchainstate,\nand compares a hash of the resulting UTXO set to a preordained hash\nhard-coded\nin the software a la assumevalid. This all takes ~23 minutes, not\naccounting for\ndownload of the 3.2GB snapshot[2].\n\nThe node then syncs to the network tip and afterwards begins a simultaneous\nbackground validation (i.e., a conventional IBD) up to the base height of\nthe\nsnapshot in order to achieve full validation. Crucially, even while the\nbackground validation is happening the node can validate incoming blocks and\ntransact with the benefit of the full (assumed-valid) UTXO set.\n\nSnapshots could be obtained from multiple separate peers in the same manner\nas\nblock download, but I haven't put much thought into this. In concept it\ndoesn't\nmatter too much where the snapshots come from since their validity is\ndetermined via content hash.\n\n# Security\n\nObviously there are some security implications due consideration. While this\nproposal is in the spirit of assumevalid, practical attacks may become\neasier.\nUnder assumevalid, a user can be tricked into transacting under a false\nhistory\nif an attacker convinces them to start bitcoind with a malicious\n`-assumevalid`\nparameter, sybils their node, and then feeds them a bogus chain encompassing\nall of the hard-coded checkpoints[3].\n\nThe same attack is made easier in assumeutxo because, unlike in assumevalid,\nthe attacker need not construct a valid PoW chain to get the victim's node\ninto\na false state; they simply need to get the user to accept a bad\n`-assumeutxo`\nparameter and then supply them an easily made UTXO snapshot containing,\nsay, a\nfalse coin assignment.\n\nFor this reason, I recommend that if we were to implement assumeutxo, we not\nallow its specification via commandline argument[4].\n\nBeyond this risk, I can't think of material differences in security\nrelative to\nassumevalid, though I appeal to the list for help with this.\n\n# More fully validating clients\n\nA particularly exciting use-case for assumeutxo is the possibility of mobile\ndevices functioning as fully validating nodes with access to the complete\nUTXO\nset (as an alternative to SPV models). The total resource burden needed to\nstart a node\nfrom scratch based on a snapshot is, at time of writing, a ~(3.2GB\n+ blocks_to_tip * 4MB) download and a few minutes of processing time, which\nsounds\nmanageable for many mobile devices currently in use.\n\nA mobile user could initialize an assumed-valid bitcoin node within an hour,\ntransact immediately, and complete a pruned full validation of their\nassumed-valid chain over the next few days, perhaps only doing the\nbackground\nIBD when their device has access to suitable high-bandwidth connections.\n\nIf we end up implementing an accumulator-based UTXO scaling design[5][6]\ndown\nthe road, it's easy to imagine an analogous process that would allow very\nfast\nstartup using an accumulator of a few kilobytes in lieu of a multi-GB\nsnapshot.\n\n---\n\nI've created a related issue at our Github repository here:\n  https://github.com/bitcoin/bitcoin/issues/15605\n\nand have submitted a draft implementation of snapshot usage via RPC here:\n  https://github.com/bitcoin/bitcoin/pull/15606\n\nI'd like to discuss here whether this is a good fit for Bitcoin\nconceptually. Concrete\nplans for deployment steps should be discussed in the Github issue, and\nafter all\nthat my implementation may be reviewed as a sketch of the specific software\nchanges necessary.\n\nRegards,\nJames\n\n\n[0]:\nhttps://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n[1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n[2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n2.10GHz\n[3]:\nhttps://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n[4]: Marco Falke is due credit for this point\n[5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n[6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment-0001.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2019-04-03T06:37:31",
                "message_text_only": "Thanks James for the post.\n\nI proposed a similar idea [1] back in 2016 with the difference of signing the UTXO-set hash in a gitian-ish way.\n\nWhile the idea of UTXO-set-syncs are attractive, there are probably still significant downsides in usability (compared to models with less security), mainly:\n* Assume the UTXO set is 6 weeks old (which seems a reasonable age for providing enough security) a peer using that snapshot would still require to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,\u2026 probably CPU-days on a phone)\n* Do we semi-trust the peer that servers the UTXO set (compared to a block or tx which we can validate)? What channel to we use to serve the snapshot?\n\nIf the goal is to run a full node on a consumer device that is also been used for other CPU intense operations (like a phone, etc.), I\u2019m not sure if this proposal will lead to a satisfactory user experience.\n\nThe longer I think around this problem, the more I lean towards accepting the fact that one need to use dedicated hardware in his own environment to perform a painless full validation.\n\n/jonas\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html\n\n> Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:\n> \n> Hi,\n> \n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n> \n> # Motivation\n> \n> To start a fully validating bitcoin client from scratch, that client currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n> \n> As a result, having fully validating clients run on such hardware is rare and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n> \n> The subject of this mail is a proposal for a complementary alternative to SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`. It may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n> \n> # assumeutxo\n> \n> The basic idea is to allow nodes to initialize using a serialized version of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains and\n> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set\n> bundled with the block header indicating its \"base\" and some other metadata).\n> \n> Based upon the snapshot, the node is able to quickly reconstruct its chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not accounting for\n> download of the 3.2GB snapshot[2].\n> \n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks and\n> transact with the benefit of the full (assumed-valid) UTXO set.\n> \n> Snapshots could be obtained from multiple separate peers in the same manner as\n> block download, but I haven't put much thought into this. In concept it doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n> \n> # Security\n> \n> Obviously there are some security implications due consideration. While this\n> proposal is in the spirit of assumevalid, practical attacks may become easier.\n> Under assumevalid, a user can be tricked into transacting under a false history\n> if an attacker convinces them to start bitcoind with a malicious `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain encompassing\n> all of the hard-coded checkpoints[3].\n> \n> The same attack is made easier in assumeutxo because, unlike in assumevalid,\n> the attacker need not construct a valid PoW chain to get the victim's node into\n> a false state; they simply need to get the user to accept a bad `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing, say, a\n> false coin assignment.\n> \n> For this reason, I recommend that if we were to implement assumeutxo, we not\n> allow its specification via commandline argument[4].\n> \n> Beyond this risk, I can't think of material differences in security relative to\n> assumevalid, though I appeal to the list for help with this.\n> \n> # More fully validating clients\n> \n> A particularly exciting use-case for assumeutxo is the possibility of mobile\n> devices functioning as fully validating nodes with access to the complete UTXO\n> set (as an alternative to SPV models). The total resource burden needed to start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time, which sounds\n> manageable for many mobile devices currently in use.\n> \n> A mobile user could initialize an assumed-valid bitcoin node within an hour,\n> transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the background\n> IBD when their device has access to suitable high-bandwidth connections.\n> \n> If we end up implementing an accumulator-based UTXO scaling design[5][6] down\n> the road, it's easy to imagine an analogous process that would allow very fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB snapshot.\n> \n> ---\n> \n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n> \n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n> \n> I'd like to discuss here whether this is a good fit for Bitcoin conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n> \n> Regards,\n> James\n> \n> \n> [0]: https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @ 2.10GHz\n> [3]: https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/0005961e/attachment.sig>"
            },
            {
                "author": "Ethan Scruples",
                "date": "2019-04-03T15:39:29",
                "message_text_only": "Jonas,\n\nIf we can get mandatory UTXO commitments soft forked into Bitcoin, we get\nthe advantage of a non-growing IBD, which I think everyone would agree is a\nbenefit that, uh, grows over time. The thing I do not see people noticing\nis that we actually pay little to no security price for this benefit.\n\nTo see this, consider Alice, who starts from a UTXO snapshot made at\ncurrent height - 50,000 and Bob who validates from genesis.\n\nAfter her partial validation, Alice is satisfied that she is in possession\nof the UTXO set-- she is in consensus with the rest of the network peers.\n\nHowever, Bob realizes that there is actually an invalid block at current\nheight - 50,001.\n\nThree things to notice:\n\n1. This scenario essentially cannot happen. There is no way that the miners\nare going to stack 50,000 blocks on top of an invalid block without the\neconomic majority abandoning the invalid chain.\n\n2. If this scenario DOES happen, Bob has learned about it too late for it\nto matter to Bob. The blockchain Bob wants to be on is the one that\neveryone has been using for the last year, whether or not it is besmirched\nby an invalid block.\n\n3. If this scenario DOES happen, and Bob DOES want to reject the last\n50,000 mined blocks as invalid, he may discover to his dismay that in the 1\nyear since the invalid block, mischievous entities have enough time to mine\nequally weighted alternative histories from the Genesis block forward to\nthe invalid block, meaning that Bob has no way to use POW to come to\nconsensus with other Bobs out there.\n\nOn Wed, Apr 3, 2019 at 3:33 AM Jonas Schnelli via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks James for the post.\n>\n> I proposed a similar idea [1] back in 2016 with the difference of signing\n> the UTXO-set hash in a gitian-ish way.\n>\n> While the idea of UTXO-set-syncs are attractive, there are probably still\n> significant downsides in usability (compared to models with less security),\n> mainly:\n> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for\n> providing enough security) a peer using that snapshot would still require\n> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,\u2026 probably\n> CPU-days on a phone)\n> * Do we semi-trust the peer that servers the UTXO set (compared to a block\n> or tx which we can validate)? What channel to we use to serve the snapshot?\n>\n> If the goal is to run a full node on a consumer device that is also been\n> used for other CPU intense operations (like a phone, etc.), I\u2019m not sure if\n> this proposal will lead to a satisfactory user experience.\n>\n> The longer I think around this problem, the more I lean towards accepting\n> the fact that one need to use dedicated hardware in his own environment to\n> perform a painless full validation.\n>\n> /jonas\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html\n>\n> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n> >\n> > Hi,\n> >\n> > I'd like to discuss assumeutxo, which is an appealing and simple\n> > optimization in the spirit of assumevalid[0].\n> >\n> > # Motivation\n> >\n> > To start a fully validating bitcoin client from scratch, that client\n> currently\n> > needs to perform an initial block download. To the surprise of no one,\n> IBD\n> > takes a linear amount time based on the length of the chain's history.\n> For\n> > clients running on modest hardware under limited bandwidth constraints,\n> > say a mobile device, completing IBD takes a considerable amount of time\n> > and thus poses serious usability challenges.\n> >\n> > As a result, having fully validating clients run on such hardware is\n> rare and\n> > basically unrealistic. Clients with even moderate resource constraints\n> > are encouraged to rely on the SPV trust model. Though we have promising\n> > improvements to existing SPV modes pending deployment[1], it's worth\n> > thinking about a mechanism that would allow such clients to use trust\n> > models closer to full validation.\n> >\n> > The subject of this mail is a proposal for a complementary alternative\n> to SPV\n> > modes, and which is in the spirit of an existing default, `assumevalid`.\n> It may\n> > help modest clients transact under a security model that closely\n> resembles\n> > full validation within minutes instead of hours or days.\n> >\n> > # assumeutxo\n> >\n> > The basic idea is to allow nodes to initialize using a serialized\n> version of the\n> > UTXO set rendered by another node at some predetermined height. The\n> > initializing node syncs the headers chain from the network, then obtains\n> and\n> > loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> > bundled with the block header indicating its \"base\" and some other\n> metadata).\n> >\n> > Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> > and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> > in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> > download of the 3.2GB snapshot[2].\n> >\n> > The node then syncs to the network tip and afterwards begins a\n> simultaneous\n> > background validation (i.e., a conventional IBD) up to the base height\n> of the\n> > snapshot in order to achieve full validation. Crucially, even while the\n> > background validation is happening the node can validate incoming blocks\n> and\n> > transact with the benefit of the full (assumed-valid) UTXO set.\n> >\n> > Snapshots could be obtained from multiple separate peers in the same\n> manner as\n> > block download, but I haven't put much thought into this. In concept it\n> doesn't\n> > matter too much where the snapshots come from since their validity is\n> > determined via content hash.\n> >\n> > # Security\n> >\n> > Obviously there are some security implications due consideration. While\n> this\n> > proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> > Under assumevalid, a user can be tricked into transacting under a false\n> history\n> > if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> > parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> > all of the hard-coded checkpoints[3].\n> >\n> > The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> > the attacker need not construct a valid PoW chain to get the victim's\n> node into\n> > a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> > parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> > false coin assignment.\n> >\n> > For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> > allow its specification via commandline argument[4].\n> >\n> > Beyond this risk, I can't think of material differences in security\n> relative to\n> > assumevalid, though I appeal to the list for help with this.\n> >\n> > # More fully validating clients\n> >\n> > A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> > devices functioning as fully validating nodes with access to the\n> complete UTXO\n> > set (as an alternative to SPV models). The total resource burden needed\n> to start a node\n> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> > + blocks_to_tip * 4MB) download and a few minutes of processing time,\n> which sounds\n> > manageable for many mobile devices currently in use.\n> >\n> > A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> > transact immediately, and complete a pruned full validation of their\n> > assumed-valid chain over the next few days, perhaps only doing the\n> background\n> > IBD when their device has access to suitable high-bandwidth connections.\n> >\n> > If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> > the road, it's easy to imagine an analogous process that would allow\n> very fast\n> > startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n> >\n> > ---\n> >\n> > I've created a related issue at our Github repository here:\n> >   https://github.com/bitcoin/bitcoin/issues/15605\n> >\n> > and have submitted a draft implementation of snapshot usage via RPC here:\n> >   https://github.com/bitcoin/bitcoin/pull/15606\n> >\n> > I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> > plans for deployment steps should be discussed in the Github issue, and\n> after all\n> > that my implementation may be reviewed as a sketch of the specific\n> software\n> > changes necessary.\n> >\n> > Regards,\n> > James\n> >\n> >\n> > [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU\n> @ 2.10GHz\n> > [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> > [4]: Marco Falke is due credit for this point\n> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> > [6]: Boneh, Bunz, Fisch on accumulators:\n> https://eprint.iacr.org/2018/1188\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/69a9a9bf/attachment-0001.html>"
            },
            {
                "author": "Dave Scotese",
                "date": "2019-04-03T21:39:32",
                "message_text_only": "Every block's hash is smaller than the difficulty at that time.  Block\n569927's hash was VERY small (started with 21 zeros).  The ratio of block\nhash to difficulty requirement (0xffffffff - difficulty, I think) could be\nused to identify blocks as \"special,\" thus providing the opportunity to\npopularize unimportant but memorable-and-therefore-useful details.  How can\nthey be useful if they are unimportant?  They are useful for sanity\nchecking.  For example, if the drunken bishop walk (or some other popular\nrandomart) produced by block 569927's hash looked like a face, that would\nbe memorable: \"The block with the smallest hash in 2019 (maybe ever?) looks\nlike a face after the drunken bishop walk.\"\n\nIf a few of these showed up each year, then Bob and/or Alice would have a\ngood chance of seeing that something was wrong if and when they checked.\nIt would not be surprising, given Ethan's assumption that the invalid block\nBob found contributed to Alice's UTXOs, that at some point, the history one\nof them has would be missing the memorable things beginning at some block\nheight because, clearly, one of them has been forked.\n\nLuke's comment that it could \"lead to users trusting third parties (like\ndevelopers) way too much\" is pertinent too, but I think an honest abatement\nof that concern is impossible without teaching everyone C++.  \"Developers\"\nas an open group (anyone can fork the github repo, find a problem, and make\nan issue) deserve the trust we put in them, and that's because they're\naccountable (any such error found in the repo will have been put there by\nsomeone).  The same thing goes for making it possible to download (*not\njust the compiled software*, but) the entire UTXO Set if a commitment of it\nis hardcoded into the software, as James suggests.  We all trust\n\"developers\" like that, and it's okay.  No one holds the \"ring of power.\"\n\nOn Wed, Apr 3, 2019 at 8:39 AM Ethan Scruples via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Jonas,\n>\n> If we can get mandatory UTXO commitments soft forked into Bitcoin, we get\n> the advantage of a non-growing IBD, which I think everyone would agree is a\n> benefit that, uh, grows over time. The thing I do not see people noticing\n> is that we actually pay little to no security price for this benefit.\n>\n> To see this, consider Alice, who starts from a UTXO snapshot made at\n> current height - 50,000 and Bob who validates from genesis.\n>\n> After her partial validation, Alice is satisfied that she is in possession\n> of the UTXO set-- she is in consensus with the rest of the network peers.\n>\n> However, Bob realizes that there is actually an invalid block at current\n> height - 50,001.\n>\n> Three things to notice:\n>\n> 1. This scenario essentially cannot happen. There is no way that the\n> miners are going to stack 50,000 blocks on top of an invalid block without\n> the economic majority abandoning the invalid chain.\n>\n> 2. If this scenario DOES happen, Bob has learned about it too late for it\n> to matter to Bob. The blockchain Bob wants to be on is the one that\n> everyone has been using for the last year, whether or not it is besmirched\n> by an invalid block.\n>\n> 3. If this scenario DOES happen, and Bob DOES want to reject the last\n> 50,000 mined blocks as invalid, he may discover to his dismay that in the 1\n> year since the invalid block, mischievous entities have enough time to mine\n> equally weighted alternative histories from the Genesis block forward to\n> the invalid block, meaning that Bob has no way to use POW to come to\n> consensus with other Bobs out there.\n>\n> On Wed, Apr 3, 2019 at 3:33 AM Jonas Schnelli via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Thanks James for the post.\n>>\n>> I proposed a similar idea [1] back in 2016 with the difference of signing\n>> the UTXO-set hash in a gitian-ish way.\n>>\n>> While the idea of UTXO-set-syncs are attractive, there are probably still\n>> significant downsides in usability (compared to models with less security),\n>> mainly:\n>> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for\n>> providing enough security) a peer using that snapshot would still require\n>> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,\u2026 probably\n>> CPU-days on a phone)\n>> * Do we semi-trust the peer that servers the UTXO set (compared to a\n>> block or tx which we can validate)? What channel to we use to serve the\n>> snapshot?\n>>\n>> If the goal is to run a full node on a consumer device that is also been\n>> used for other CPU intense operations (like a phone, etc.), I\u2019m not sure if\n>> this proposal will lead to a satisfactory user experience.\n>>\n>> The longer I think around this problem, the more I lean towards accepting\n>> the fact that one need to use dedicated hardware in his own environment to\n>> perform a painless full validation.\n>>\n>> /jonas\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html\n>>\n>> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org>:\n>> >\n>> > Hi,\n>> >\n>> > I'd like to discuss assumeutxo, which is an appealing and simple\n>> > optimization in the spirit of assumevalid[0].\n>> >\n>> > # Motivation\n>> >\n>> > To start a fully validating bitcoin client from scratch, that client\n>> currently\n>> > needs to perform an initial block download. To the surprise of no one,\n>> IBD\n>> > takes a linear amount time based on the length of the chain's history.\n>> For\n>> > clients running on modest hardware under limited bandwidth constraints,\n>> > say a mobile device, completing IBD takes a considerable amount of time\n>> > and thus poses serious usability challenges.\n>> >\n>> > As a result, having fully validating clients run on such hardware is\n>> rare and\n>> > basically unrealistic. Clients with even moderate resource constraints\n>> > are encouraged to rely on the SPV trust model. Though we have promising\n>> > improvements to existing SPV modes pending deployment[1], it's worth\n>> > thinking about a mechanism that would allow such clients to use trust\n>> > models closer to full validation.\n>> >\n>> > The subject of this mail is a proposal for a complementary alternative\n>> to SPV\n>> > modes, and which is in the spirit of an existing default,\n>> `assumevalid`. It may\n>> > help modest clients transact under a security model that closely\n>> resembles\n>> > full validation within minutes instead of hours or days.\n>> >\n>> > # assumeutxo\n>> >\n>> > The basic idea is to allow nodes to initialize using a serialized\n>> version of the\n>> > UTXO set rendered by another node at some predetermined height. The\n>> > initializing node syncs the headers chain from the network, then\n>> obtains and\n>> > loads one of these UTXO snapshots (i.e. a serialized version of the\n>> UTXO set\n>> > bundled with the block header indicating its \"base\" and some other\n>> metadata).\n>> >\n>> > Based upon the snapshot, the node is able to quickly reconstruct its\n>> chainstate,\n>> > and compares a hash of the resulting UTXO set to a preordained hash\n>> hard-coded\n>> > in the software a la assumevalid. This all takes ~23 minutes, not\n>> accounting for\n>> > download of the 3.2GB snapshot[2].\n>> >\n>> > The node then syncs to the network tip and afterwards begins a\n>> simultaneous\n>> > background validation (i.e., a conventional IBD) up to the base height\n>> of the\n>> > snapshot in order to achieve full validation. Crucially, even while the\n>> > background validation is happening the node can validate incoming\n>> blocks and\n>> > transact with the benefit of the full (assumed-valid) UTXO set.\n>> >\n>> > Snapshots could be obtained from multiple separate peers in the same\n>> manner as\n>> > block download, but I haven't put much thought into this. In concept it\n>> doesn't\n>> > matter too much where the snapshots come from since their validity is\n>> > determined via content hash.\n>> >\n>> > # Security\n>> >\n>> > Obviously there are some security implications due consideration. While\n>> this\n>> > proposal is in the spirit of assumevalid, practical attacks may become\n>> easier.\n>> > Under assumevalid, a user can be tricked into transacting under a false\n>> history\n>> > if an attacker convinces them to start bitcoind with a malicious\n>> `-assumevalid`\n>> > parameter, sybils their node, and then feeds them a bogus chain\n>> encompassing\n>> > all of the hard-coded checkpoints[3].\n>> >\n>> > The same attack is made easier in assumeutxo because, unlike in\n>> assumevalid,\n>> > the attacker need not construct a valid PoW chain to get the victim's\n>> node into\n>> > a false state; they simply need to get the user to accept a bad\n>> `-assumeutxo`\n>> > parameter and then supply them an easily made UTXO snapshot containing,\n>> say, a\n>> > false coin assignment.\n>> >\n>> > For this reason, I recommend that if we were to implement assumeutxo,\n>> we not\n>> > allow its specification via commandline argument[4].\n>> >\n>> > Beyond this risk, I can't think of material differences in security\n>> relative to\n>> > assumevalid, though I appeal to the list for help with this.\n>> >\n>> > # More fully validating clients\n>> >\n>> > A particularly exciting use-case for assumeutxo is the possibility of\n>> mobile\n>> > devices functioning as fully validating nodes with access to the\n>> complete UTXO\n>> > set (as an alternative to SPV models). The total resource burden needed\n>> to start a node\n>> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n>> > + blocks_to_tip * 4MB) download and a few minutes of processing time,\n>> which sounds\n>> > manageable for many mobile devices currently in use.\n>> >\n>> > A mobile user could initialize an assumed-valid bitcoin node within an\n>> hour,\n>> > transact immediately, and complete a pruned full validation of their\n>> > assumed-valid chain over the next few days, perhaps only doing the\n>> background\n>> > IBD when their device has access to suitable high-bandwidth connections.\n>> >\n>> > If we end up implementing an accumulator-based UTXO scaling\n>> design[5][6] down\n>> > the road, it's easy to imagine an analogous process that would allow\n>> very fast\n>> > startup using an accumulator of a few kilobytes in lieu of a multi-GB\n>> snapshot.\n>> >\n>> > ---\n>> >\n>> > I've created a related issue at our Github repository here:\n>> >   https://github.com/bitcoin/bitcoin/issues/15605\n>> >\n>> > and have submitted a draft implementation of snapshot usage via RPC\n>> here:\n>> >   https://github.com/bitcoin/bitcoin/pull/15606\n>> >\n>> > I'd like to discuss here whether this is a good fit for Bitcoin\n>> conceptually. Concrete\n>> > plans for deployment steps should be discussed in the Github issue, and\n>> after all\n>> > that my implementation may be reviewed as a sketch of the specific\n>> software\n>> > changes necessary.\n>> >\n>> > Regards,\n>> > James\n>> >\n>> >\n>> > [0]:\n>> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n>> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n>> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116\n>> CPU @ 2.10GHz\n>> > [3]:\n>> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n>> > [4]: Marco Falke is due credit for this point\n>> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n>> > [6]: Boneh, Bunz, Fisch on accumulators:\n>> https://eprint.iacr.org/2018/1188\n>> >\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nI like to provide some work at no charge to prove my value. Do you need a\ntechie?\nI own Litmocracy <http://www.litmocracy.com> and Meme Racing\n<http://www.memeracing.net> (in alpha).\nI'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which\nnow accepts Bitcoin.\nI also code for The Dollar Vigilante <http://dollarvigilante.com/>.\n\"He ought to find it more profitable to play by the rules\" - Satoshi\nNakamoto\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/d942b813/attachment-0001.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-04-04T03:01:00",
                "message_text_only": "On Wednesday 03 April 2019 21:39:32 Dave Scotese via bitcoin-dev wrote:\n> Luke's comment that it could \"lead to users trusting third parties (like\n> developers) way too much\" is pertinent too, but I think an honest abatement\n> of that concern is impossible without teaching everyone C++.\n\nLearning C++ is something within everyone's capability. Even people who do not \nwish to learn it can hire someone to perform review for them.\n\n> \"Developers\" \n> as an open group (anyone can fork the github repo, find a problem, and make\n> an issue) deserve the trust we put in them, and that's because they're\n> accountable (any such error found in the repo will have been put there by\n> someone). \n\nNo, we are not. We explicitly disclaim any warranty, and do not want your \ntrust.\n\n> The same thing goes for making it possible to download (*not \n> just the compiled software*, but) the entire UTXO Set if a commitment of it\n> is hardcoded into the software, as James suggests. \n\nVerifying a UTXO set commitment is impossible short of a real IBD. It's not \neven comparable.\n\n> We all trust \n> \"developers\" like that, and it's okay.\n\nNo, it isn't okay. There are plenty of fiat options if you want a trust-based \ncurrency. Bitcoin is supposed to be something more than that.\n\nLuke"
            },
            {
                "author": "Jim Posen",
                "date": "2019-04-04T05:59:32",
                "message_text_only": ">\n> Learning C++ is something within everyone's capability. Even people who do\n> not\n> wish to learn it can hire someone to perform review for them.\n>\n\nAnyone with enough knowledge of C++ to audit the entire the Bitcoin Core\ncodebase is more than capable of running it with assumeutxo disabled and\nchecking the hard-coded vale themself.\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/fa2a9a58/attachment.html>"
            },
            {
                "author": "James O'Beirne",
                "date": "2019-04-04T14:36:53",
                "message_text_only": "I recommend that anyone following this thread read through the recent IRC\nexchange between Greg Maxwell and Luke Dashjr:\n http://www.erisian.com.au/bitcoin-core-dev/log-2019-04-04.html\n<http://www.erisian.com.au/bitcoin-core-dev/log-2019-04-04.html>\n\nThe conversation starts on line 205 at 2019-04-04T02:54:50.\n\nOn Thu, Apr 4, 2019 at 2:38 AM Jim Posen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Learning C++ is something within everyone's capability. Even people who do\n>> not\n>> wish to learn it can hire someone to perform review for them.\n>>\n>\n> Anyone with enough knowledge of C++ to audit the entire the Bitcoin Core\n> codebase is more than capable of running it with assumeutxo disabled and\n> checking the hard-coded vale themself.\n>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190404/91235d28/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-04-13T19:09:25",
                "message_text_only": "On Wed, Apr 03, 2019 at 02:39:32PM -0700, Dave Scotese via bitcoin-dev wrote:\n> Every block's hash is smaller than the difficulty at that time.  Block\n> 569927's hash was VERY small (started with 21 zeros).  The ratio of block\n> hash to difficulty requirement (0xffffffff - difficulty, I think) could be\n> used to identify blocks as \"special,\" thus providing the opportunity to\n> popularize unimportant but memorable-and-therefore-useful details.  How can\n> they be useful if they are unimportant?  They are useful for sanity\n> checking.  For example, if the drunken bishop walk (or some other popular\n> randomart) produced by block 569927's hash looked like a face, that would\n> be memorable: \"The block with the smallest hash in 2019 (maybe ever?) looks\n> like a face after the drunken bishop walk.\"\n\nAs hashest smaller than the target have no significance to the Bitcoin\nconsensus I'd suggest not basing any features on that property. It's just as\narbitrary as picking whole decimal number block heights, yet has the additional\ndownsides of being harder to compute, and being likely to confuse people as to\nhow the Bitcoin consensus works.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190413/3b7d1bdd/attachment.sig>"
            },
            {
                "author": "Dave Scotese",
                "date": "2019-04-15T00:44:51",
                "message_text_only": "No piece of data that does have significance to the Bitcoin consensus can\nbe memorable because it occurs (about) every ten minutes. In order to get\nsomething memorable to provide sanity (let's say, anti-sybil-attack)\nchecking, it has to be rare, but recurrent.  The opportunity is actually\nalready there, but it usually goes by without providing the benefits.\n\nFor example, I found this blog post\n<http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html>\nby Ken Shirriff who describes artifacts that can be found in the\nblockchain. These artifacts are not intimately tied to their location in\nthe blockchain, so anyone building an alternative blockchain can relatively\neasily add the artifacts with the same timestamp and at the same height,\nmasking the counterfeit.  In order to prevent that, the memorable thing has\nto be intimately tied to work-intensive results, like the ratio of the hash\nto the target.  Nelson Mandela's image appearing in the blockchain does NOT\nprove to me it's the blockchain I can see at blockchain.com right now, but\nif the smallest block hash in that blockchain, on 12/13/13, after all the\nzeroes, starts with 3da1 (144 * 65536 times as much work) and is one of the\nthree block hashes from that day that have two occurrences of a double-e\n(about 256 times more work), then it will.  The problem is that I'll\nprobably forget most of those details - but not that Mandela's image went\nin the blockchain near the end of 2013.\n\nOn Sat, Apr 13, 2019 at 12:09 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Wed, Apr 03, 2019 at 02:39:32PM -0700, Dave Scotese via bitcoin-dev\n> wrote:\n> > Every block's hash is smaller than the difficulty at that time.  Block\n> > 569927's hash was VERY small (started with 21 zeros).  The ratio of block\n> > hash to difficulty requirement (0xffffffff - difficulty, I think) could\n> be\n> > used to identify blocks as \"special,\" thus providing the opportunity to\n> > popularize unimportant but memorable-and-therefore-useful details.  How\n> can\n> > they be useful if they are unimportant?  They are useful for sanity\n> > checking.  For example, if the drunken bishop walk (or some other popular\n> > randomart) produced by block 569927's hash looked like a face, that would\n> > be memorable: \"The block with the smallest hash in 2019 (maybe ever?)\n> looks\n> > like a face after the drunken bishop walk.\"\n>\n> As hashest smaller than the target have no significance to the Bitcoin\n> consensus I'd suggest not basing any features on that property. It's just\n> as\n> arbitrary as picking whole decimal number block heights, yet has the\n> additional\n> downsides of being harder to compute, and being likely to confuse people\n> as to\n> how the Bitcoin consensus works.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/36a84972/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-04-04T02:48:33",
                "message_text_only": "On Wednesday 03 April 2019 15:39:29 Ethan Scruples via bitcoin-dev wrote:\n> If we can get mandatory UTXO commitments soft forked into Bitcoin, we get\n> the advantage of a non-growing IBD,\n\nNo, we don't. This is exactly the danger. UTXO snapshots are NOT an \nalternative to a real IBD. There are HUGE security implications for this. \nFrankly, the danger that someone would do such a thing is itself a good \nreason not to ever add UTXO commitments.\n\nLuke"
            },
            {
                "author": "Ethan Scruples",
                "date": "2019-04-04T03:04:58",
                "message_text_only": "> This is exactly the danger. UTXO snapshots are NOT an alternative to a\nreal IBD. There are HUGE security implications for this.\n\nThis is a perfect example of what I am talking about when I say that people\ndo not appear to notice that there is no important security implication to\nbe found here.\n\nIf there are huge security implications for this, then I am keen to hear\nthem. In the scenario I have described, what advantage does Bob have over\nAlice? What actionable information has Bob gained, and what is the action\nhe can take with it in hand? What value does Bob receive in return for the\nelectricity he has spent validating the previous blocks? I cannot find any,\nbut I am open to hearing the answer, and I think others would benefit from\nknowing it as well.\n\nOn Wed, Apr 3, 2019 at 10:49 PM Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Wednesday 03 April 2019 15:39:29 Ethan Scruples via bitcoin-dev wrote:\n> > If we can get mandatory UTXO commitments soft forked into Bitcoin, we get\n> > the advantage of a non-growing IBD,\n>\n> No, we don't. This is exactly the danger. UTXO snapshots are NOT an\n> alternative to a real IBD. There are HUGE security implications for this.\n> Frankly, the danger that someone would do such a thing is itself a good\n> reason not to ever add UTXO commitments.\n>\n> Luke\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/a03cbf04/attachment.html>"
            },
            {
                "author": "James O'Beirne",
                "date": "2019-04-03T19:51:32",
                "message_text_only": "Thanks for the reply, Jonas. I should've figured someone had hit the\nmailing list with this one before!\n\nIn hindsight, I may have overemphasized the use of this for low-powered\nmobile devices. Indeed I think this may also be a worthwhile optimization\nfor common hardware too.\n\nOn the margin, if a user wants to interact with Bitcoin they will download\nsoftware that allows them to do it immediately - this results in many\npeople defaulting to a light client. If Bitcoin were able to initialize\nfrom scratch in a comparable amount of time and then populate the full\nchain in the background, we may have many more people *incidentally*\nrunning full nodes.\n\nRegardless of whether or not we use UTXO snapshots per se, I'd argue that\nthe pattern of doing some kind of quick initialization (whether it's with\nassumed-valid data, or headers-contingent data like BIP157) and then\nperforming full validation in the background is a good way to ensure that\nwe have a healthier population of full nodes than we would otherwise.\n\nFor this reason, and (as Ethan points out) because IBD's linear setup time\nis infeasible in the long-term, I think this pattern is an obvious\ndirection for the bitcoin client to go.\n\n> * Do we semi-trust the peer that servers the UTXO set (compared to a\nblock or tx which we can validate)? What channel to we use to serve the\nsnapshot?\n\nAs you note in your post from 2016, where and how we retrieve the snapshot\nis more or less immaterial because we compare a hash of its contents to a\npreviously specified value that the code ships with (the `assumeutxo`\nhash). We don't need to trust the source serving it to us, although\nbandwidth DoS prevention via some kind chunked delivery from peers would be\nworth thinking about.\n\nRegards,\nJames\n\nOn Wed, Apr 3, 2019 at 2:37 AM Jonas Schnelli <dev at jonasschnelli.ch> wrote:\n\n> Thanks James for the post.\n>\n> I proposed a similar idea [1] back in 2016 with the difference of signing\n> the UTXO-set hash in a gitian-ish way.\n>\n> While the idea of UTXO-set-syncs are attractive, there are probably still\n> significant downsides in usability (compared to models with less security),\n> mainly:\n> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for\n> providing enough security) a peer using that snapshot would still require\n> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,\u2026 probably\n> CPU-days on a phone)\n> * Do we semi-trust the peer that servers the UTXO set (compared to a block\n> or tx which we can validate)? What channel to we use to serve the snapshot?\n>\n> If the goal is to run a full node on a consumer device that is also been\n> used for other CPU intense operations (like a phone, etc.), I\u2019m not sure if\n> this proposal will lead to a satisfactory user experience.\n>\n> The longer I think around this problem, the more I lean towards accepting\n> the fact that one need to use dedicated hardware in his own environment to\n> perform a painless full validation.\n>\n> /jonas\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html\n>\n> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n> >\n> > Hi,\n> >\n> > I'd like to discuss assumeutxo, which is an appealing and simple\n> > optimization in the spirit of assumevalid[0].\n> >\n> > # Motivation\n> >\n> > To start a fully validating bitcoin client from scratch, that client\n> currently\n> > needs to perform an initial block download. To the surprise of no one,\n> IBD\n> > takes a linear amount time based on the length of the chain's history.\n> For\n> > clients running on modest hardware under limited bandwidth constraints,\n> > say a mobile device, completing IBD takes a considerable amount of time\n> > and thus poses serious usability challenges.\n> >\n> > As a result, having fully validating clients run on such hardware is\n> rare and\n> > basically unrealistic. Clients with even moderate resource constraints\n> > are encouraged to rely on the SPV trust model. Though we have promising\n> > improvements to existing SPV modes pending deployment[1], it's worth\n> > thinking about a mechanism that would allow such clients to use trust\n> > models closer to full validation.\n> >\n> > The subject of this mail is a proposal for a complementary alternative\n> to SPV\n> > modes, and which is in the spirit of an existing default, `assumevalid`.\n> It may\n> > help modest clients transact under a security model that closely\n> resembles\n> > full validation within minutes instead of hours or days.\n> >\n> > # assumeutxo\n> >\n> > The basic idea is to allow nodes to initialize using a serialized\n> version of the\n> > UTXO set rendered by another node at some predetermined height. The\n> > initializing node syncs the headers chain from the network, then obtains\n> and\n> > loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> > bundled with the block header indicating its \"base\" and some other\n> metadata).\n> >\n> > Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> > and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> > in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> > download of the 3.2GB snapshot[2].\n> >\n> > The node then syncs to the network tip and afterwards begins a\n> simultaneous\n> > background validation (i.e., a conventional IBD) up to the base height\n> of the\n> > snapshot in order to achieve full validation. Crucially, even while the\n> > background validation is happening the node can validate incoming blocks\n> and\n> > transact with the benefit of the full (assumed-valid) UTXO set.\n> >\n> > Snapshots could be obtained from multiple separate peers in the same\n> manner as\n> > block download, but I haven't put much thought into this. In concept it\n> doesn't\n> > matter too much where the snapshots come from since their validity is\n> > determined via content hash.\n> >\n> > # Security\n> >\n> > Obviously there are some security implications due consideration. While\n> this\n> > proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> > Under assumevalid, a user can be tricked into transacting under a false\n> history\n> > if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> > parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> > all of the hard-coded checkpoints[3].\n> >\n> > The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> > the attacker need not construct a valid PoW chain to get the victim's\n> node into\n> > a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> > parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> > false coin assignment.\n> >\n> > For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> > allow its specification via commandline argument[4].\n> >\n> > Beyond this risk, I can't think of material differences in security\n> relative to\n> > assumevalid, though I appeal to the list for help with this.\n> >\n> > # More fully validating clients\n> >\n> > A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> > devices functioning as fully validating nodes with access to the\n> complete UTXO\n> > set (as an alternative to SPV models). The total resource burden needed\n> to start a node\n> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> > + blocks_to_tip * 4MB) download and a few minutes of processing time,\n> which sounds\n> > manageable for many mobile devices currently in use.\n> >\n> > A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> > transact immediately, and complete a pruned full validation of their\n> > assumed-valid chain over the next few days, perhaps only doing the\n> background\n> > IBD when their device has access to suitable high-bandwidth connections.\n> >\n> > If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> > the road, it's easy to imagine an analogous process that would allow\n> very fast\n> > startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n> >\n> > ---\n> >\n> > I've created a related issue at our Github repository here:\n> >   https://github.com/bitcoin/bitcoin/issues/15605\n> >\n> > and have submitted a draft implementation of snapshot usage via RPC here:\n> >   https://github.com/bitcoin/bitcoin/pull/15606\n> >\n> > I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> > plans for deployment steps should be discussed in the Github issue, and\n> after all\n> > that my implementation may be reviewed as a sketch of the specific\n> software\n> > changes necessary.\n> >\n> > Regards,\n> > James\n> >\n> >\n> > [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU\n> @ 2.10GHz\n> > [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> > [4]: Marco Falke is due credit for this point\n> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> > [6]: Boneh, Bunz, Fisch on accumulators:\n> https://eprint.iacr.org/2018/1188\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/e631ec0b/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-04-03T09:55:26",
                "message_text_only": "This would lead to users trusting third parties (like developers) way too \nmuch.\n\nFurthermore, removing the ability for users to easily set it removes the one \nreasonable use case: where the user has already verified the state at some \npoint previously, and saved the hash (ie, as backup of the UTXO set).\n\nLuke\n\n\nOn Tuesday 02 April 2019 20:43:11 James O'Beirne via bitcoin-dev wrote:\n> Hi,\n>\n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n>\n> # Motivation\n>\n> To start a fully validating bitcoin client from scratch, that client\n> currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n>\n> As a result, having fully validating clients run on such hardware is rare\n> and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n>\n> The subject of this mail is a proposal for a complementary alternative to\n> SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`. It\n> may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n>\n> # assumeutxo\n>\n> The basic idea is to allow nodes to initialize using a serialized version\n> of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains\n> and loads one of these UTXO snapshots (i.e. a serialized version of the\n> UTXO set bundled with the block header indicating its \"base\" and some other\n> metadata).\n>\n> Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> download of the 3.2GB snapshot[2].\n>\n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of\n> the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks\n> and transact with the benefit of the full (assumed-valid) UTXO set.\n>\n> Snapshots could be obtained from multiple separate peers in the same manner\n> as\n> block download, but I haven't put much thought into this. In concept it\n> doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n>\n> # Security\n>\n> Obviously there are some security implications due consideration. While\n> this proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> Under assumevalid, a user can be tricked into transacting under a false\n> history\n> if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain\n> encompassing all of the hard-coded checkpoints[3].\n>\n> The same attack is made easier in assumeutxo because, unlike in\n> assumevalid, the attacker need not construct a valid PoW chain to get the\n> victim's node into\n> a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> false coin assignment.\n>\n> For this reason, I recommend that if we were to implement assumeutxo, we\n> not allow its specification via commandline argument[4].\n>\n> Beyond this risk, I can't think of material differences in security\n> relative to\n> assumevalid, though I appeal to the list for help with this.\n>\n> # More fully validating clients\n>\n> A particularly exciting use-case for assumeutxo is the possibility of\n> mobile devices functioning as fully validating nodes with access to the\n> complete UTXO\n> set (as an alternative to SPV models). The total resource burden needed to\n> start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time, which\n> sounds\n> manageable for many mobile devices currently in use.\n>\n> A mobile user could initialize an assumed-valid bitcoin node within an\n> hour, transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the\n> background\n> IBD when their device has access to suitable high-bandwidth connections.\n>\n> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> the road, it's easy to imagine an analogous process that would allow very\n> fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n>\n> ---\n>\n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n>\n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n>\n> I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and\n> after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n>\n> Regards,\n> James\n>\n>\n> [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n> 2.10GHz\n> [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L1\n>61 [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188"
            },
            {
                "author": "Jim Posen",
                "date": "2019-04-03T23:03:12",
                "message_text_only": "Big Concept ACK. I think this would be one of the biggest usability\nimprovements for Bitcoin and I see no security issues with the assumevalid\napproach. I also agree that it's important to start work on this even\nbefore the ultimate, perfect accumulator has been designed/tested and the\ncommitment scheme can always be upgraded later on. assumeutxo syncing\nactually seems pretty orthogonal to the accumulator research.\n\nI have a few questions\n\n- So any nodes that do an initial sync will stop at the assumeutxo height,\nserialize a snapshot of the chain state and store it? How many nodes are\nexpected to do this? Any idea how long this takes? Should it be enabled by\ndefault?\n- Would pruned nodes still download all historic blocks to double-check the\nsnapshot or only full nodes that intend to serve block data?\n- How long are old snapshots retained? Presumably during a new release\nnodes should keep at least a version back. Without P2P signalling of which\nsnapshots are available, they maybe have to keep all old snapshots or even\ndownload old ones.\n\nand comments\n\n- The snapshot should probably be chunked up to minimize the amount of\nbandwidth/IO/memory a malicious node could waste before you realize. Also,\nit would make parallel downloading easier.\n\nOn Tue, Apr 2, 2019 at 4:43 PM James O'Beirne via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n>\n> # Motivation\n>\n> To start a fully validating bitcoin client from scratch, that client\n> currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n>\n> As a result, having fully validating clients run on such hardware is rare\n> and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n>\n> The subject of this mail is a proposal for a complementary alternative to\n> SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`.\n> It may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n>\n> # assumeutxo\n>\n> The basic idea is to allow nodes to initialize using a serialized version\n> of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains\n> and\n> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> bundled with the block header indicating its \"base\" and some other\n> metadata).\n>\n> Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> download of the 3.2GB snapshot[2].\n>\n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of\n> the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks\n> and\n> transact with the benefit of the full (assumed-valid) UTXO set.\n>\n> Snapshots could be obtained from multiple separate peers in the same\n> manner as\n> block download, but I haven't put much thought into this. In concept it\n> doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n>\n> # Security\n>\n> Obviously there are some security implications due consideration. While\n> this\n> proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> Under assumevalid, a user can be tricked into transacting under a false\n> history\n> if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> all of the hard-coded checkpoints[3].\n>\n> The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> the attacker need not construct a valid PoW chain to get the victim's node\n> into\n> a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> false coin assignment.\n>\n> For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> allow its specification via commandline argument[4].\n>\n> Beyond this risk, I can't think of material differences in security\n> relative to\n> assumevalid, though I appeal to the list for help with this.\n>\n> # More fully validating clients\n>\n> A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> devices functioning as fully validating nodes with access to the complete\n> UTXO\n> set (as an alternative to SPV models). The total resource burden needed to\n> start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time,\n> which sounds\n> manageable for many mobile devices currently in use.\n>\n> A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the\n> background\n> IBD when their device has access to suitable high-bandwidth connections.\n>\n> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> the road, it's easy to imagine an analogous process that would allow very\n> fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n>\n> ---\n>\n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n>\n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n>\n> I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and\n> after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n>\n> Regards,\n> James\n>\n>\n> [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n> 2.10GHz\n> [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/49377fdf/attachment.html>"
            },
            {
                "author": "Omar Shibli",
                "date": "2019-04-14T13:16:53",
                "message_text_only": "This sounds really promising to me, I think it could seriously improve the\ncurrent SPV trust model.\n\nIn abstract these are the possible setups today:\n\nFull node: All history, 100% monetary sovereignty.\n\nSPV: fancy term to Electrum trust model, random selection of nodes, with\nfull delegation of monetary responsibility.\n\nI think in that spirit a hybrid approach of full node + spv.\n\nAs follows:\nHardware spv with only genesis hash block seeded, as a safe bootstrap, from\nthere only headers is needed for validation, and ongoing new fresh blocks\nand associated historic blocks for conducting transactions.\n\nOn Wed, Apr 3, 2019 at 2:43 AM James O'Beirne via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n>\n> # Motivation\n>\n> To start a fully validating bitcoin client from scratch, that client\n> currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n>\n> As a result, having fully validating clients run on such hardware is rare\n> and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n>\n> The subject of this mail is a proposal for a complementary alternative to\n> SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`.\n> It may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n>\n> # assumeutxo\n>\n> The basic idea is to allow nodes to initialize using a serialized version\n> of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains\n> and\n> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> bundled with the block header indicating its \"base\" and some other\n> metadata).\n>\n> Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> download of the 3.2GB snapshot[2].\n>\n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of\n> the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks\n> and\n> transact with the benefit of the full (assumed-valid) UTXO set.\n>\n> Snapshots could be obtained from multiple separate peers in the same\n> manner as\n> block download, but I haven't put much thought into this. In concept it\n> doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n>\n> # Security\n>\n> Obviously there are some security implications due consideration. While\n> this\n> proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> Under assumevalid, a user can be tricked into transacting under a false\n> history\n> if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> all of the hard-coded checkpoints[3].\n>\n> The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> the attacker need not construct a valid PoW chain to get the victim's node\n> into\n> a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> false coin assignment.\n>\n> For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> allow its specification via commandline argument[4].\n>\n> Beyond this risk, I can't think of material differences in security\n> relative to\n> assumevalid, though I appeal to the list for help with this.\n>\n> # More fully validating clients\n>\n> A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> devices functioning as fully validating nodes with access to the complete\n> UTXO\n> set (as an alternative to SPV models). The total resource burden needed to\n> start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time,\n> which sounds\n> manageable for many mobile devices currently in use.\n>\n> A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the\n> background\n> IBD when their device has access to suitable high-bandwidth connections.\n>\n> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> the road, it's easy to imagine an analogous process that would allow very\n> fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n>\n> ---\n>\n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n>\n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n>\n> I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and\n> after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n>\n> Regards,\n> James\n>\n>\n> [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n> 2.10GHz\n> [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nSent from Gmail Mobile\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/49e2ee67/attachment-0001.html>"
            },
            {
                "author": "James O'Beirne",
                "date": "2019-04-23T14:17:06",
                "message_text_only": "Good morning all,\n\nOver the past weeks I've had a number of conversations with a few frequent\ncontributors about this idea. I've condensed these discussions into a\nproposal document which you can view here:\nhttps://github.com/jamesob/assumeutxo-docs/tree/2019-04-proposal/proposal\n\nThe document is structured as an FAQ, and so hopefully it addresses some of\nthe common questions that would come up in this thread. If you'd like to\ncomment, there's an associated pull request here:\nhttps://github.com/jamesob/assumeutxo-docs/pull/1\n\nRegards,\nJames\n\n\nOn Tue, Apr 2, 2019 at 4:43 PM James O'Beirne <james.obeirne at gmail.com>\nwrote:\n\n> Hi,\n>\n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n>\n> # Motivation\n>\n> To start a fully validating bitcoin client from scratch, that client\n> currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n>\n> As a result, having fully validating clients run on such hardware is rare\n> and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n>\n> The subject of this mail is a proposal for a complementary alternative to\n> SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`.\n> It may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n>\n> # assumeutxo\n>\n> The basic idea is to allow nodes to initialize using a serialized version\n> of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains\n> and\n> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> bundled with the block header indicating its \"base\" and some other\n> metadata).\n>\n> Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> download of the 3.2GB snapshot[2].\n>\n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of\n> the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks\n> and\n> transact with the benefit of the full (assumed-valid) UTXO set.\n>\n> Snapshots could be obtained from multiple separate peers in the same\n> manner as\n> block download, but I haven't put much thought into this. In concept it\n> doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n>\n> # Security\n>\n> Obviously there are some security implications due consideration. While\n> this\n> proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> Under assumevalid, a user can be tricked into transacting under a false\n> history\n> if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> all of the hard-coded checkpoints[3].\n>\n> The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> the attacker need not construct a valid PoW chain to get the victim's node\n> into\n> a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> false coin assignment.\n>\n> For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> allow its specification via commandline argument[4].\n>\n> Beyond this risk, I can't think of material differences in security\n> relative to\n> assumevalid, though I appeal to the list for help with this.\n>\n> # More fully validating clients\n>\n> A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> devices functioning as fully validating nodes with access to the complete\n> UTXO\n> set (as an alternative to SPV models). The total resource burden needed to\n> start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time,\n> which sounds\n> manageable for many mobile devices currently in use.\n>\n> A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the\n> background\n> IBD when their device has access to suitable high-bandwidth connections.\n>\n> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> the road, it's easy to imagine an analogous process that would allow very\n> fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n>\n> ---\n>\n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n>\n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n>\n> I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and\n> after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n>\n> Regards,\n> James\n>\n>\n> [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n> 2.10GHz\n> [3]:\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/44dcd1c9/attachment.html>"
            },
            {
                "author": "Kulpreet Singh",
                "date": "2019-04-04T10:27:02",
                "message_text_only": "Hi Nicolas,\n\nI have a small question about FastSync.\n\nWould it make sense to validate all blocks once FastSync is complete\nand BTCPayServer has started accepting payments?\n\nI am aware this will require changes to bitcoind. So this is just an\nacademic question to figure if there are problems with such an\napproach, especially for merchants accepting payments who want to get\nstarted immediately and still want to stay on a Raspberry PI.\n\nPhase 1: FastSync from trusted UTXO set and start accepting payments.\nPhase 2: Validate the entire blockchain - this will take X days on\nRaspberry PI - but at least in in the end you can fully trust your own\nnode. In this phase, you'd do IBD, but instead of writing to db, just\nverify that the validated block matches the on the the db and move on.\n\nIt is a pity leveldb doesn't allow multiple processes to open the db.\nIf so, phase 2 could have been a different process altogether as well.\n\nRegards\nKulpreet\n\n\n\nOn Wed, 3 Apr 2019 at 21:23, Nicolas Dorier via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> James,\n>\n> You might be interested by my work which is currently used in production, without any change to bitcoin core.\n>\n> I properly explain how to verify the utxoset independently.\n>\n> https://github.com/btcpayserver/btcpayserver-docker/blob/master/contrib/FastSync/README.md\n>\n> People are using it, since I get around 10 download a day.\n> What can be done to help at Bitcoin Core level is actually very minimal.\n>\n> First, instead of asking signers of by UTXOSet to sign the utxoset hash from gettxoutsetinfo, I ask them to sign the hash of the tarball of my UTXO Set.\n>\n> The reason is that it is currently impossible to stop BitcoinD on a specific block then asking the serialized hash of the UTXO Set.\n>\n> So instead, a verifier download the tarball (300 blocks + utxoset at specific height), sync to the latest block, then compare the gettxoutsetinfo of the newly synched node with another trusted node. If it match, the verifier sign the tarball.\n>\n> I create a new utxoset snapshot every 6 months, so people have time to verify it and add their signatures. (Approximately once every bitcoin core release)\n>\n> The easiest thing that could be done at Bitcoin Core level does not require any code change, but a change in the release process.\n>\n> The new process would be to ask to the gitian signers to not only build the source themselves, but also verify a tarball following the procedure I explain in the link above.\n>\n> More complicated solution like signing the serialized utxoset itself, while possible, would require bothersome code changes.\n>\n> Nicolas,\n>\n> On Wed, Apr 3, 2019 at 9:25 AM <bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n>>\n>> Send bitcoin-dev mailing list submissions to\n>>         bitcoin-dev at lists.linuxfoundation.org\n>>\n>> To subscribe or unsubscribe via the World Wide Web, visit\n>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> or, via email, send a message with subject or body 'help' to\n>>         bitcoin-dev-request at lists.linuxfoundation.org\n>>\n>> You can reach the person managing the list at\n>>         bitcoin-dev-owner at lists.linuxfoundation.org\n>>\n>> When replying, please edit your Subject line so it is more specific\n>> than \"Re: Contents of bitcoin-dev digest...\"\n>>\n>>\n>> Today's Topics:\n>>\n>>    1. BIP: Bitcoin Integrated Address Feature? (nathanw at tutanota.com)\n>>    2. Re: BIP: Bitcoin Integrated Address Feature? (htimSxelA)\n>>    3. assumeutxo and UTXO snapshots (James O'Beirne)\n>>\n>>\n>> ----------------------------------------------------------------------\n>>\n>> Message: 1\n>> Date: Tue, 2 Apr 2019 18:53:11 +0200 (CEST)\n>> From: <nathanw at tutanota.com>\n>> To: <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?\n>> Message-ID: <LbTxyE4--3-1 at tutanota.com>\n>> Content-Type: text/plain; charset=\"utf-8\"\n>>\n>> To whom it may concern,\n>>\n>> I believe a missing feature in Bitcoin is the ability to have an \"integrated address\", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.\n>>\n>> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the \"sweeping\" step required to move multiple customer deposits from a hot address into a single cold address.\n>>\n>> Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n>>\n>> Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being \"swept\" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.\n>>\n>> There are several other more minor advantages such a feature would have, including:\n>> - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.\n>> - Less need for large rescans after loading huge amounts of customer addresses into client software.\n>> - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.\n>> - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.\n>> The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.\n>>\n>> I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.\n>>\n>> Thanks for your time.\n>> Regards,\n>>\n>> Nathan Worsley\n>> CTO - LocalCoinSwap.Com\n>> -------------- next part --------------\n>> An HTML attachment was scrubbed...\n>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment-0001.html>\n>>\n>> ------------------------------\n>>\n>> Message: 2\n>> Date: Tue, 02 Apr 2019 20:01:34 +0000\n>> From: htimSxelA <htimsxela at protonmail.com>\n>> To: \"nathanw at tutanota.com\" <nathanw at tutanota.com>,      Bitcoin Protocol\n>>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: Re: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?\n>> Message-ID:\n>>         <wtbAF1FAGePDAkY3xkqANuFJtAhEXvz0JeGWnc_OZcGEyFQb-1B590I3IbwtW2FBivur0yONbSQtxaWqiQTJeoDdadivtbGkWwJnLnnzQQE=@protonmail.com>\n>>\n>> Content-Type: text/plain; charset=\"utf-8\"\n>>\n>> Hello,\n>>\n>> I see two immediate issues with this:\n>> 1. Increased resource requirements per transaction\n>> 2. Embedding identifying information into the blockchain is generally bad for privacy\n>>\n>> It may help your case to provide some technical details of how you'd like to see this implemented, but without overcoming the issues mentioned above I think this proposal will be a very tough sell.\n>>\n>> > ...this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n>>\n>> I am not sure if I see how this issue is solved by your proposal. Assumedly, a human will still need to manually approve cold-wallet withdrawals in order to maintain security. So it seems to me that removing the 'hot-wallet' component of the backend would only amplify the need for human interaction.\n>>\n>> I assume you are familiar with hierarchical deterministic wallets? They can allow an exchange to assign/identify user deposits based on address derivation path. Keys for deposit addresses can be kept offline if wanted, and a proper implementation of an HD wallet system should also remove the need for rescans of user deposit addresses.\n>>\n>> There is also a functionality built into Bitcoin that allows a user to prove that they own the private keys to some address: signing an agreed upon message using the private key that controls that address. Unfortunately I don't think this is a workable solution for you, since the majority of modern wallet software does not include this feature-- but perhaps worth mentioning nonetheless.\n>>\n>> Best,\n>> Alex\n>>\n>> ??????? Original Message ???????\n>> On Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> > To whom it may concern,\n>> >\n>> > I believe a missing feature in Bitcoin is the ability to have an \"integrated address\", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.\n>> >\n>> > By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the \"sweeping\" step required to move multiple customer deposits from a hot address into a single cold address.\n>> >\n>> > Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.\n>> >\n>> > Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being \"swept\" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.\n>> >\n>> > There are several other more minor advantages such a feature would have, including:\n>> > - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.\n>> > - Less need for large rescans after loading huge amounts of customer addresses into client software.\n>> > - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.\n>> > - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.\n>> >\n>> > The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.\n>> >\n>> > I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.\n>> >\n>> > Thanks for your time.\n>> >\n>> > Regards,\n>> >\n>> > Nathan Worsley\n>> > CTO - LocalCoinSwap.Com\n>> -------------- next part --------------\n>> An HTML attachment was scrubbed...\n>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment-0001.html>\n>>\n>> ------------------------------\n>>\n>> Message: 3\n>> Date: Tue, 2 Apr 2019 16:43:11 -0400\n>> From: \"James O'Beirne\" <james.obeirne at gmail.com>\n>> To: bitcoin-dev at lists.linuxfoundation.org\n>> Subject: [bitcoin-dev] assumeutxo and UTXO snapshots\n>> Message-ID:\n>>         <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA at mail.gmail.com>\n>> Content-Type: text/plain; charset=\"utf-8\"\n>>\n>> Hi,\n>>\n>> I'd like to discuss assumeutxo, which is an appealing and simple\n>> optimization in the spirit of assumevalid[0].\n>>\n>> # Motivation\n>>\n>> To start a fully validating bitcoin client from scratch, that client\n>> currently\n>> needs to perform an initial block download. To the surprise of no one, IBD\n>> takes a linear amount time based on the length of the chain's history. For\n>> clients running on modest hardware under limited bandwidth constraints,\n>> say a mobile device, completing IBD takes a considerable amount of time\n>> and thus poses serious usability challenges.\n>>\n>> As a result, having fully validating clients run on such hardware is rare\n>> and\n>> basically unrealistic. Clients with even moderate resource constraints\n>> are encouraged to rely on the SPV trust model. Though we have promising\n>> improvements to existing SPV modes pending deployment[1], it's worth\n>> thinking about a mechanism that would allow such clients to use trust\n>> models closer to full validation.\n>>\n>> The subject of this mail is a proposal for a complementary alternative to\n>> SPV\n>> modes, and which is in the spirit of an existing default, `assumevalid`. It\n>> may\n>> help modest clients transact under a security model that closely resembles\n>> full validation within minutes instead of hours or days.\n>>\n>> # assumeutxo\n>>\n>> The basic idea is to allow nodes to initialize using a serialized version\n>> of the\n>> UTXO set rendered by another node at some predetermined height. The\n>> initializing node syncs the headers chain from the network, then obtains and\n>> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set\n>> bundled with the block header indicating its \"base\" and some other\n>> metadata).\n>>\n>> Based upon the snapshot, the node is able to quickly reconstruct its\n>> chainstate,\n>> and compares a hash of the resulting UTXO set to a preordained hash\n>> hard-coded\n>> in the software a la assumevalid. This all takes ~23 minutes, not\n>> accounting for\n>> download of the 3.2GB snapshot[2].\n>>\n>> The node then syncs to the network tip and afterwards begins a simultaneous\n>> background validation (i.e., a conventional IBD) up to the base height of\n>> the\n>> snapshot in order to achieve full validation. Crucially, even while the\n>> background validation is happening the node can validate incoming blocks and\n>> transact with the benefit of the full (assumed-valid) UTXO set.\n>>\n>> Snapshots could be obtained from multiple separate peers in the same manner\n>> as\n>> block download, but I haven't put much thought into this. In concept it\n>> doesn't\n>> matter too much where the snapshots come from since their validity is\n>> determined via content hash.\n>>\n>> # Security\n>>\n>> Obviously there are some security implications due consideration. While this\n>> proposal is in the spirit of assumevalid, practical attacks may become\n>> easier.\n>> Under assumevalid, a user can be tricked into transacting under a false\n>> history\n>> if an attacker convinces them to start bitcoind with a malicious\n>> `-assumevalid`\n>> parameter, sybils their node, and then feeds them a bogus chain encompassing\n>> all of the hard-coded checkpoints[3].\n>>\n>> The same attack is made easier in assumeutxo because, unlike in assumevalid,\n>> the attacker need not construct a valid PoW chain to get the victim's node\n>> into\n>> a false state; they simply need to get the user to accept a bad\n>> `-assumeutxo`\n>> parameter and then supply them an easily made UTXO snapshot containing,\n>> say, a\n>> false coin assignment.\n>>\n>> For this reason, I recommend that if we were to implement assumeutxo, we not\n>> allow its specification via commandline argument[4].\n>>\n>> Beyond this risk, I can't think of material differences in security\n>> relative to\n>> assumevalid, though I appeal to the list for help with this.\n>>\n>> # More fully validating clients\n>>\n>> A particularly exciting use-case for assumeutxo is the possibility of mobile\n>> devices functioning as fully validating nodes with access to the complete\n>> UTXO\n>> set (as an alternative to SPV models). The total resource burden needed to\n>> start a node\n>> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n>> + blocks_to_tip * 4MB) download and a few minutes of processing time, which\n>> sounds\n>> manageable for many mobile devices currently in use.\n>>\n>> A mobile user could initialize an assumed-valid bitcoin node within an hour,\n>> transact immediately, and complete a pruned full validation of their\n>> assumed-valid chain over the next few days, perhaps only doing the\n>> background\n>> IBD when their device has access to suitable high-bandwidth connections.\n>>\n>> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n>> down\n>> the road, it's easy to imagine an analogous process that would allow very\n>> fast\n>> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n>> snapshot.\n>>\n>> ---\n>>\n>> I've created a related issue at our Github repository here:\n>>   https://github.com/bitcoin/bitcoin/issues/15605\n>>\n>> and have submitted a draft implementation of snapshot usage via RPC here:\n>>   https://github.com/bitcoin/bitcoin/pull/15606\n>>\n>> I'd like to discuss here whether this is a good fit for Bitcoin\n>> conceptually. Concrete\n>> plans for deployment steps should be discussed in the Github issue, and\n>> after all\n>> that my implementation may be reviewed as a sketch of the specific software\n>> changes necessary.\n>>\n>> Regards,\n>> James\n>>\n>>\n>> [0]:\n>> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n>> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n>> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n>> 2.10GHz\n>> [3]:\n>> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n>> [4]: Marco Falke is due credit for this point\n>> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n>> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n>> -------------- next part --------------\n>> An HTML attachment was scrubbed...\n>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment.html>\n>>\n>> ------------------------------\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> End of bitcoin-dev Digest, Vol 47, Issue 6\n>> ******************************************\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "assumeutxo and UTXO snapshots",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Ethan Scruples",
                "Dave Scotese",
                "Kulpreet Singh",
                "Luke Dashjr",
                "Omar Shibli",
                "Jim Posen",
                "James O'Beirne",
                "Jonas Schnelli"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 103308
        }
    },
    {
        "title": "[bitcoin-dev] License for BIP39 word lists",
        "thread_messages": [
            {
                "author": "Elia",
                "date": "2019-04-03T05:53:25",
                "message_text_only": "I would like to use the BIP39 word lists posted in the Github BIP repo\nfor my own project.\n\n\nUnfortunately there is no license associated with the lists provided on\nGithub so I am not sure whether usage for other projects is permitted. I\nam not able to file issues on the repo either to suggest adding a license.\n\nDoes anybody know under which license these lists are published?\n\n\nBest regards,\n\nElia"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2019-04-03T09:19:40",
                "message_text_only": "I am the author of the wordlist. Feel free to use it without any\nrestrictions.\n\nHowever, we are finalizing SLIP39 standard for splitting shares which uses\na different wordlist with better properties. It might be more suitable for\nyour project.\n\nSee https://github.com/satoshilabs/slips/blob/master/slip-0039.md and\nhttps://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt\n\n\n\nOn Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I would like to use the BIP39 word lists posted in the Github BIP repo\n> for my own project.\n>\n>\n> Unfortunately there is no license associated with the lists provided on\n> Github so I am not sure whether usage for other projects is permitted. I\n> am not able to file issues on the repo either to suggest adding a license.\n>\n> Does anybody know under which license these lists are published?\n>\n>\n> Best regards,\n>\n> Elia\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/79fcf295/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-09T09:46:37",
                "message_text_only": "Is it final now and live in Trezor? Do you know who else will adopt it?\n\nRegards\n\nAymeric\n\nLe 03/04/2019 \u00e0 11:19, Pavol Rusnak via bitcoin-dev a \u00e9crit\u00a0:\n> I am the author of the wordlist. Feel free to use it without any\n> restrictions.\n>\n> However, we are finalizing SLIP39 standard for splitting shares which\n> uses a different wordlist with better properties. It might be more\n> suitable for your project.\n>\n> See\u00a0https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n> and\u00a0https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt\n>\n>\n>\n> On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     I would like to use the BIP39 word lists posted in the Github BIP repo\n>     for my own project.\n>\n>\n>     Unfortunately there is no license associated with the lists\n>     provided on\n>     Github so I am not sure whether usage for other projects is\n>     permitted. I\n>     am not able to file issues on the repo either to suggest adding a\n>     license.\n>\n>     Does anybody know under which license these lists are published?\n>\n>\n>     Best regards,\n>\n>     Elia\n>\n>\n>\n>\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/4236b446/attachment-0001.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2019-04-09T09:49:53",
                "message_text_only": "We are in process of finalizing it, so it is not live in Trezor yet. It\nwill be soon, though. I suppose every wallet that uses BIP39 will adopt\nthis one as well.\n\nOn Tue, Apr 9, 2019, 11:46 Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n\n> Is it final now and live in Trezor? Do you know who else will adopt it?\n>\n> Regards\n>\n> Aymeric\n> Le 03/04/2019 \u00e0 11:19, Pavol Rusnak via bitcoin-dev a \u00e9crit :\n>\n> I am the author of the wordlist. Feel free to use it without any\n> restrictions.\n>\n> However, we are finalizing SLIP39 standard for splitting shares which uses\n> a different wordlist with better properties. It might be more suitable for\n> your project.\n>\n> See https://github.com/satoshilabs/slips/blob/master/slip-0039.md and\n> https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt\n>\n>\n>\n> On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I would like to use the BIP39 word lists posted in the Github BIP repo\n>> for my own project.\n>>\n>>\n>> Unfortunately there is no license associated with the lists provided on\n>> Github so I am not sure whether usage for other projects is permitted. I\n>> am not able to file issues on the repo either to suggest adding a license.\n>>\n>> Does anybody know under which license these lists are published?\n>>\n>>\n>> Best regards,\n>>\n>> Elia\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> --\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/45c69dcd/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-09T16:19:40",
                "message_text_only": "What is not final finally and when do you expect it to be?\n\nLe 09/04/2019 \u00e0 11:49, Pavol Rusnak a \u00e9crit\u00a0:\n> We are in process of finalizing it, so it is not live in Trezor yet.\n> It will be soon, though. I suppose every wallet that uses BIP39 will\n> adopt this one as well.\n>\n> On Tue, Apr 9, 2019, 11:46 Aymeric Vitte <vitteaymeric at gmail.com\n> <mailto:vitteaymeric at gmail.com>> wrote:\n>\n>     Is it final now and live in Trezor? Do you know who else will\n>     adopt it?\n>\n>     Regards\n>\n>     Aymeric\n>\n>     Le 03/04/2019 \u00e0 11:19, Pavol Rusnak via bitcoin-dev a \u00e9crit\u00a0:\n>>     I am the author of the wordlist. Feel free to use it without any\n>>     restrictions.\n>>\n>>     However, we are finalizing SLIP39 standard for splitting shares\n>>     which uses a different wordlist with better properties. It might\n>>     be more suitable for your project.\n>>\n>>     See\u00a0https://github.com/satoshilabs/slips/blob/master/slip-0039.md\n>>     and\u00a0https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt\n>>\n>>\n>>\n>>     On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev\n>>     <bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>         I would like to use the BIP39 word lists posted in the Github\n>>         BIP repo\n>>         for my own project.\n>>\n>>\n>>         Unfortunately there is no license associated with the lists\n>>         provided on\n>>         Github so I am not sure whether usage for other projects is\n>>         permitted. I\n>>         am not able to file issues on the repo either to suggest\n>>         adding a license.\n>>\n>>         Does anybody know under which license these lists are published?\n>>\n>>\n>>         Best regards,\n>>\n>>         Elia\n>>\n>>\n>>\n>>\n>>\n>>         _______________________________________________\n>>         bitcoin-dev mailing list\n>>         bitcoin-dev at lists.linuxfoundation.org\n>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/2089a69e/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "License for BIP39 word lists",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Elia",
                "Pavol Rusnak",
                "Aymeric Vitte"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 9301
        }
    },
    {
        "title": "[bitcoin-dev]  assumeutxo and UTXO snapshots",
        "thread_messages": [
            {
                "author": "Nicolas Dorier",
                "date": "2019-04-03T07:51:04",
                "message_text_only": "James,\n\nYou might be interested by my work which is currently used in production,\nwithout any change to bitcoin core.\n\nI properly explain how to verify the utxoset independently.\n\nhttps://github.com/btcpayserver/btcpayserver-docker/blob/master/contrib/FastSync/README.md\n\n\nPeople are using it, since I get around 10 download a day.\nWhat can be done to help at Bitcoin Core level is actually very minimal.\n\nFirst, instead of asking signers of by UTXOSet to sign the utxoset hash\nfrom gettxoutsetinfo, I ask them to sign the hash of the tarball of my UTXO\nSet.\n\nThe reason is that it is currently impossible to stop BitcoinD on a\nspecific block then asking the serialized hash of the UTXO Set.\n\nSo instead, a verifier download the tarball (300 blocks + utxoset at\nspecific height), sync to the latest block, then compare the\ngettxoutsetinfo of the newly synched node with another trusted node. If it\nmatch, the verifier sign the tarball.\n\nI create a new utxoset snapshot every 6 months, so people have time to\nverify it and add their signatures. (Approximately once every bitcoin core\nrelease)\n\nThe easiest thing that could be done at Bitcoin Core level does not require\nany code change, but a change in the release process.\n\nThe new process would be to ask to the gitian signers to not only build the\nsource themselves, but also verify a tarball following the procedure I\nexplain in the link above.\n\nMore complicated solution like signing the serialized utxoset itself, while\npossible, would require bothersome code changes.\n\nNicolas,\n\nOn Wed, Apr 3, 2019 at 9:25 AM <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. BIP: Bitcoin Integrated Address Feature? (nathanw at tutanota.com)\n>    2. Re: BIP: Bitcoin Integrated Address Feature? (htimSxelA)\n>    3. assumeutxo and UTXO snapshots (James O'Beirne)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Tue, 2 Apr 2019 18:53:11 +0200 (CEST)\n> From: <nathanw at tutanota.com>\n> To: <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?\n> Message-ID: <LbTxyE4--3-1 at tutanota.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> To whom it may concern,\n>\n> I believe a missing feature in Bitcoin is the ability to have an\n> \"integrated address\", where the address resolves into a Bitcoin address,\n> and also a transaction message or some other kind of identifier.\n>\n> By having this feature we could enhance the security of exchange\n> cold-wallet systems, by allowing them to easily receive all payments to a\n> single address from an infinite number of customers. We would also greatly\n> simplify the process of setting up and managing exchange cold-wallet\n> systems, because we would eliminate the \"sweeping\" step required to move\n> multiple customer deposits from a hot address into a single cold address.\n>\n> Although it would be nice to have all customers deposit directly into cold\n> addresses, this quickly becomes impractical when large amounts of customers\n> begin to use exchange wallets as their personal web-wallet, frequently\n> depositing and withdrawing without trading action. You end up needing to\n> have a staff member moving funds away from cold deposit addresses as a full\n> time job - if you wish to handle customer funds in a completely secure\n> manner.\n>\n> Thus we see that most exchanges now use the hot-deposit system, where\n> customers deposit into a hot address that is then automatically swept into\n> a singular cold address, by a service which holds customers private keys\n> online. You can observe this service at work simply by making a deposit to\n> most major exchanges (including the largest exchange Binance), as you will\n> see the funds quickly being \"swept\" to their cold wallet address in a\n> manner which heavily suggests automation by a program which possesses\n> private keys to the address you are sending funds to. This means there is\n> always the danger of a sophisticated hacker being able to capture private\n> keys to customer deposit addresses (as they are clearly being held online).\n> An integrated address would allow all exchanges using this automated\n> hot-deposit service to easily switch to a far more secure alternative of\n> having all customers depositing directly into their singular cold wallet\n> address.\n>\n> There are several other more minor advantages such a feature would have,\n> including:\n> - Lower fees for exchanges (which could be passed onto customers), by\n> reducing a transaction step out of the deposit-to-withdrawal flow.\n> - Less need for large rescans after loading huge amounts of customer\n> addresses into client software.\n> - Exchanges can more easily provision deposit addresses to new customers\n> in a secure manner, by simply generating a hex or other value, creating an\n> integrated address from the cold wallet address, and then providing this to\n> the customer.\n> - By providing a singular cold address for exchanges publicly, customers\n> can more easily verify that no man-in-the-middle has given them an\n> incorrect address to deposit to.\n> The integrated address could work by combining the Bitcoin address\n> together with some kind of hex or other value, allowing users to choose the\n> amount they wish to deposit themselves, but ensuring their deposits are\n> uniquely trackable.\n>\n> I'm not sure if some kind of functionality already exists in BTC, as I\n> haven't been able to find it. If not, can I submit a proposal to implement\n> this? This feature would be a godsend to all exchange developers if it was\n> widely accepted.\n>\n> Thanks for your time.\n> Regards,\n>\n> Nathan Worsley\n> CTO - LocalCoinSwap.Com\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment-0001.html\n> >\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Tue, 02 Apr 2019 20:01:34 +0000\n> From: htimSxelA <htimsxela at protonmail.com>\n> To: \"nathanw at tutanota.com\" <nathanw at tutanota.com>,      Bitcoin Protocol\n>         Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?\n> Message-ID:\n>\n> <wtbAF1FAGePDAkY3xkqANuFJtAhEXvz0JeGWnc_OZcGEyFQb-1B590I3IbwtW2FBivur0yONbSQtxaWqiQTJeoDdadivtbGkWwJnLnnzQQE=@\n> protonmail.com>\n>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Hello,\n>\n> I see two immediate issues with this:\n> 1. Increased resource requirements per transaction\n> 2. Embedding identifying information into the blockchain is generally bad\n> for privacy\n>\n> It may help your case to provide some technical details of how you'd like\n> to see this implemented, but without overcoming the issues mentioned above\n> I think this proposal will be a very tough sell.\n>\n> > ...this quickly becomes impractical when large amounts of customers\n> begin to use exchange wallets as their personal web-wallet, frequently\n> depositing and withdrawing without trading action. You end up needing to\n> have a staff member moving funds away from cold deposit addresses as a full\n> time job - if you wish to handle customer funds in a completely secure\n> manner.\n>\n> I am not sure if I see how this issue is solved by your proposal.\n> Assumedly, a human will still need to manually approve cold-wallet\n> withdrawals in order to maintain security. So it seems to me that removing\n> the 'hot-wallet' component of the backend would only amplify the need for\n> human interaction.\n>\n> I assume you are familiar with hierarchical deterministic wallets? They\n> can allow an exchange to assign/identify user deposits based on address\n> derivation path. Keys for deposit addresses can be kept offline if wanted,\n> and a proper implementation of an HD wallet system should also remove the\n> need for rescans of user deposit addresses.\n>\n> There is also a functionality built into Bitcoin that allows a user to\n> prove that they own the private keys to some address: signing an agreed\n> upon message using the private key that controls that address.\n> Unfortunately I don't think this is a workable solution for you, since the\n> majority of modern wallet software does not include this feature-- but\n> perhaps worth mentioning nonetheless.\n>\n> Best,\n> Alex\n>\n> ??????? Original Message ???????\n> On Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > To whom it may concern,\n> >\n> > I believe a missing feature in Bitcoin is the ability to have an\n> \"integrated address\", where the address resolves into a Bitcoin address,\n> and also a transaction message or some other kind of identifier.\n> >\n> > By having this feature we could enhance the security of exchange\n> cold-wallet systems, by allowing them to easily receive all payments to a\n> single address from an infinite number of customers. We would also greatly\n> simplify the process of setting up and managing exchange cold-wallet\n> systems, because we would eliminate the \"sweeping\" step required to move\n> multiple customer deposits from a hot address into a single cold address.\n> >\n> > Although it would be nice to have all customers deposit directly into\n> cold addresses, this quickly becomes impractical when large amounts of\n> customers begin to use exchange wallets as their personal web-wallet,\n> frequently depositing and withdrawing without trading action. You end up\n> needing to have a staff member moving funds away from cold deposit\n> addresses as a full time job - if you wish to handle customer funds in a\n> completely secure manner.\n> >\n> > Thus we see that most exchanges now use the hot-deposit system, where\n> customers deposit into a hot address that is then automatically swept into\n> a singular cold address, by a service which holds customers private keys\n> online. You can observe this service at work simply by making a deposit to\n> most major exchanges (including the largest exchange Binance), as you will\n> see the funds quickly being \"swept\" to their cold wallet address in a\n> manner which heavily suggests automation by a program which possesses\n> private keys to the address you are sending funds to. This means there is\n> always the danger of a sophisticated hacker being able to capture private\n> keys to customer deposit addresses (as they are clearly being held online).\n> An integrated address would allow all exchanges using this automated\n> hot-deposit service to easily switch to a far more secure alternative of\n> having all customers depositing directly into their singular cold wallet\n> address.\n> >\n> > There are several other more minor advantages such a feature would have,\n> including:\n> > - Lower fees for exchanges (which could be passed onto customers), by\n> reducing a transaction step out of the deposit-to-withdrawal flow.\n> > - Less need for large rescans after loading huge amounts of customer\n> addresses into client software.\n> > - Exchanges can more easily provision deposit addresses to new customers\n> in a secure manner, by simply generating a hex or other value, creating an\n> integrated address from the cold wallet address, and then providing this to\n> the customer.\n> > - By providing a singular cold address for exchanges publicly, customers\n> can more easily verify that no man-in-the-middle has given them an\n> incorrect address to deposit to.\n> >\n> > The integrated address could work by combining the Bitcoin address\n> together with some kind of hex or other value, allowing users to choose the\n> amount they wish to deposit themselves, but ensuring their deposits are\n> uniquely trackable.\n> >\n> > I'm not sure if some kind of functionality already exists in BTC, as I\n> haven't been able to find it. If not, can I submit a proposal to implement\n> this? This feature would be a godsend to all exchange developers if it was\n> widely accepted.\n> >\n> > Thanks for your time.\n> >\n> > Regards,\n> >\n> > Nathan Worsley\n> > CTO - LocalCoinSwap.Com\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment-0001.html\n> >\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Tue, 2 Apr 2019 16:43:11 -0400\n> From: \"James O'Beirne\" <james.obeirne at gmail.com>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: [bitcoin-dev] assumeutxo and UTXO snapshots\n> Message-ID:\n>         <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=\n> XwngA at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Hi,\n>\n> I'd like to discuss assumeutxo, which is an appealing and simple\n> optimization in the spirit of assumevalid[0].\n>\n> # Motivation\n>\n> To start a fully validating bitcoin client from scratch, that client\n> currently\n> needs to perform an initial block download. To the surprise of no one, IBD\n> takes a linear amount time based on the length of the chain's history. For\n> clients running on modest hardware under limited bandwidth constraints,\n> say a mobile device, completing IBD takes a considerable amount of time\n> and thus poses serious usability challenges.\n>\n> As a result, having fully validating clients run on such hardware is rare\n> and\n> basically unrealistic. Clients with even moderate resource constraints\n> are encouraged to rely on the SPV trust model. Though we have promising\n> improvements to existing SPV modes pending deployment[1], it's worth\n> thinking about a mechanism that would allow such clients to use trust\n> models closer to full validation.\n>\n> The subject of this mail is a proposal for a complementary alternative to\n> SPV\n> modes, and which is in the spirit of an existing default, `assumevalid`. It\n> may\n> help modest clients transact under a security model that closely resembles\n> full validation within minutes instead of hours or days.\n>\n> # assumeutxo\n>\n> The basic idea is to allow nodes to initialize using a serialized version\n> of the\n> UTXO set rendered by another node at some predetermined height. The\n> initializing node syncs the headers chain from the network, then obtains\n> and\n> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO\n> set\n> bundled with the block header indicating its \"base\" and some other\n> metadata).\n>\n> Based upon the snapshot, the node is able to quickly reconstruct its\n> chainstate,\n> and compares a hash of the resulting UTXO set to a preordained hash\n> hard-coded\n> in the software a la assumevalid. This all takes ~23 minutes, not\n> accounting for\n> download of the 3.2GB snapshot[2].\n>\n> The node then syncs to the network tip and afterwards begins a simultaneous\n> background validation (i.e., a conventional IBD) up to the base height of\n> the\n> snapshot in order to achieve full validation. Crucially, even while the\n> background validation is happening the node can validate incoming blocks\n> and\n> transact with the benefit of the full (assumed-valid) UTXO set.\n>\n> Snapshots could be obtained from multiple separate peers in the same manner\n> as\n> block download, but I haven't put much thought into this. In concept it\n> doesn't\n> matter too much where the snapshots come from since their validity is\n> determined via content hash.\n>\n> # Security\n>\n> Obviously there are some security implications due consideration. While\n> this\n> proposal is in the spirit of assumevalid, practical attacks may become\n> easier.\n> Under assumevalid, a user can be tricked into transacting under a false\n> history\n> if an attacker convinces them to start bitcoind with a malicious\n> `-assumevalid`\n> parameter, sybils their node, and then feeds them a bogus chain\n> encompassing\n> all of the hard-coded checkpoints[3].\n>\n> The same attack is made easier in assumeutxo because, unlike in\n> assumevalid,\n> the attacker need not construct a valid PoW chain to get the victim's node\n> into\n> a false state; they simply need to get the user to accept a bad\n> `-assumeutxo`\n> parameter and then supply them an easily made UTXO snapshot containing,\n> say, a\n> false coin assignment.\n>\n> For this reason, I recommend that if we were to implement assumeutxo, we\n> not\n> allow its specification via commandline argument[4].\n>\n> Beyond this risk, I can't think of material differences in security\n> relative to\n> assumevalid, though I appeal to the list for help with this.\n>\n> # More fully validating clients\n>\n> A particularly exciting use-case for assumeutxo is the possibility of\n> mobile\n> devices functioning as fully validating nodes with access to the complete\n> UTXO\n> set (as an alternative to SPV models). The total resource burden needed to\n> start a node\n> from scratch based on a snapshot is, at time of writing, a ~(3.2GB\n> + blocks_to_tip * 4MB) download and a few minutes of processing time, which\n> sounds\n> manageable for many mobile devices currently in use.\n>\n> A mobile user could initialize an assumed-valid bitcoin node within an\n> hour,\n> transact immediately, and complete a pruned full validation of their\n> assumed-valid chain over the next few days, perhaps only doing the\n> background\n> IBD when their device has access to suitable high-bandwidth connections.\n>\n> If we end up implementing an accumulator-based UTXO scaling design[5][6]\n> down\n> the road, it's easy to imagine an analogous process that would allow very\n> fast\n> startup using an accumulator of a few kilobytes in lieu of a multi-GB\n> snapshot.\n>\n> ---\n>\n> I've created a related issue at our Github repository here:\n>   https://github.com/bitcoin/bitcoin/issues/15605\n>\n> and have submitted a draft implementation of snapshot usage via RPC here:\n>   https://github.com/bitcoin/bitcoin/pull/15606\n>\n> I'd like to discuss here whether this is a good fit for Bitcoin\n> conceptually. Concrete\n> plans for deployment steps should be discussed in the Github issue, and\n> after all\n> that my implementation may be reviewed as a sketch of the specific software\n> changes necessary.\n>\n> Regards,\n> James\n>\n>\n> [0]:\n> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks\n> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @\n> 2.10GHz\n> [3]:\n>\n> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161\n> [4]: Marco Falke is due credit for this point\n> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc\n> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment.html\n> >\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 47, Issue 6\n> ******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/7a1cb47c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "assumeutxo and UTXO snapshots",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nicolas Dorier"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 19762
        }
    },
    {
        "title": "[bitcoin-dev] Add OpenRPC Service Discovery To JSON-RPC Services",
        "thread_messages": [
            {
                "author": "Shane Jonas",
                "date": "2019-04-03T20:48:24",
                "message_text_only": "Similar to how Bitcion has BIPs to normalize bitcoin wallets, this is a\nproposal to normalize the Bitcoin RPC Interface.\n\nJust one example of the problems that arise: If a client doesn't provide\ngetblock or doesn't work in the same way it will have\nunintended consequences .\n\nHaving a standard described interfaces lets you generate documentation,\ngenerate RPC clients, test interfaces, across implementations.\n\n\nHere is the proposal:\n\nhttps://github.com/bitcoin/bips/pull/776\n\nHere is just an example of what something like that would look like for\nBitcoin:\nhttps://github.com/bitcoin/bips/pull/776#issuecomment-479649785\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/8d7a9bc2/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Add OpenRPC Service Discovery To JSON-RPC Services",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Shane Jonas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 810
        }
    },
    {
        "title": "[bitcoin-dev] Smart Contracts Unchained",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-04T01:55:06",
                "message_text_only": "https://zmnscpxj.github.io/bitcoin/unchained.html\n\nSmart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching."
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-04-04T02:35:03",
                "message_text_only": "Hi ZmnSCPxj,\n\nThought provoking, thank you!\n\nSomething I dislike in the scheme, that one could not tell which party colluded with the escrow agent.\n\nTamas Blummer\n\n> On Apr 4, 2019, at 03:55, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> https://zmnscpxj.github.io/bitcoin/unchained.html\n> \n> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Ariel Lorenzo-Luaces",
                "date": "2019-04-04T03:37:47",
                "message_text_only": "Hello ZmnSCPxj\n\nI like the proposal because it generalizes escrow type mechanisms and I think it's a useful train of thought for distributed exchanges.\n\nHowever, consider the situation where a group of participants are playing poker. One participant loses all their funds and decides to present to the escrow the contract+an old contract state+a signed message following the contract rules (eg. an independently signed cashing out message). How would the escrow know that the contract state is old and the operation is disallowed, without using a consensus mechanism like a blockchain?\n\nCheers\nAriel Lorenzo-Luaces\n\nOn Apr 3, 2019, 7:14 PM, at 7:14 PM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n>Smart contracts have traditionally been implemented as part of the\n>consensus rules of some blokchain.  Often this means creating a new\n>blockchain, or at least a sidechain to an existing blockchain.  This\n>writeup proposes an alternative method without launching a separate\n>blockchain or sidechain, while achieving security similar to federated\n>sidechains and additional benefits to privacy and\n>smart-contract-patching.\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/0125e3d2/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-04T07:07:10",
                "message_text_only": "Good morning Ariel,\n\n> However, consider the situation where a group of participants are playing poker. One participant loses all their funds and decides to present to the escrow the contract+an old contract state+a signed message following the contract rules (eg. an independently signed cashing out message). How would the escrow know that the contract state is old and the operation is disallowed, without using a consensus mechanism like a blockchain?\n\nOne might point to the various channel mechanisms (Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun) as counterarguments.\nThough they require a blockchain as backing, old states are invalidated (Poon-Dryja) or replaceable (Decker-*), without necessarily requiring a blockchain to keep track of all the states.\n\nSuppose our purported smart contract platform supports some kind of covenant system.\nThis means, that it is possible to make a branch of the contract require that the fund go to a specific address template in the transaction that spends it.\nSuppose we use this mechanism to require that the Bitcoin-level transaction pay again to a contract in the same contract platform.\nIt then becomes possible to make a covenant that requires spending the transaction to the same covenant.\n\nThis can allow us to enforce creating an offchain sequence of transactions T1...Tn, such that T2 spends T1, T3 spends T2, etc.\nThen the final transaction Tn completes the sequence and pays out according to the rules of Poker, or whatever.\nThis sequence is anchored on an onchain transaction T0 which enters the funds into the smart contract.\n\nThe smart contract platform just signs \"blindly\" without particularly caring whether the signature went onchain, or even whether the UTXO being spent exists onchain --- all it cares, is that the smart contract can be given witnesses correctly.\n\nNow upon reaching Tn, the winner(s) can just publish the sequence of transactions T1...Tn.\nAlternately, they can present the sequence of transactions T1...Tn to all participants, and offer to give back part of the money allocated to fees for all the transactions T1...Tn in exchange for a single transaction that shortcuts all of that and spends to however Tn splits out.\n\nBasically, consider that the Decker-Russell-Osuntokun mechanism starts with a mechanism very much like the above (a sequence of update transactions) and then does some optimizations to allow the final transaction Tn to spend any transaction Ti where i < n.\nBut the basic concept that the sequence is at all possible, and can be kept offchain, implies this state does not require to be stored onchain at all.\n\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-04T15:03:39",
                "message_text_only": "Somebody pointed out this to me:\n\nhttps://gavintech.blogspot.com/2014/06/bit-thereum.html\n\nI have updated the page accordingly.\n\nOne thing that seems not mentioned in bit-thereum is the \"as long as everybody agrees\" escape hatch, i.e. one branch which allows spending to anything (including a transaction that violates the letter of the contract) as long as all participants agree.\nThis is gives my newer mechanism the ability to \"fix\" buggy contracts if everybody involved can agree to the terms of a new contract, by simply abandoning the existing contract and spending to the new contract.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, April 4, 2019 9:55 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain. Often this means creating a new blockchain, or at least a sidechain to an existing blockchain. This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-04T17:18:30",
                "message_text_only": "What if the smart contract platform(s) disappear?\n\nThe proposal induces a very centralized system, to my knowledge all of \nexisting sidechains whether on bitcoin or ethereum are centralized, \nexcept lightning (if we forget that someone must watch what others are \ndoing when you are on a trek in Nepal)\n\nNow I don't get why a sidechain should be a blockchain on top on another \none (given also that we can't consider bitcoin or ethereum as \ndecentralized today, so the path might be long for the sidechains...), \nthe latest is used to store the final state, the former does not have to \nstore forever the intermediate states, then it could just use a \ndecentralized system (not necessarilly blockchain-like) to store the \nintermediate states and maybe be a distributed escrow\n\nI know, easy to say, please do it (why not), now the fact that \nsidechains claim to be decentralized or that they will be is just \nmisleading people (that's not the case of your proposal but it does not \nsay what happens if the platforms go down)\n\n\nLe 04/04/2019 \u00e0 03:55, ZmnSCPxj via bitcoin-dev a \u00e9crit :\n> https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nPeersm : http://www.peersm.com\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-04T23:52:20",
                "message_text_only": "Good morning Aymeric,\n\n\n> What if the smart contract platform(s) disappear?\n>\n\nIt is still possible to recover the funds, *if* you can convince all participants of some \"fair\" distribution of the funds.\nYou do this by all participants simply signing with their participant keys and taking the first branch of the script.\nThis branch does not require the participation of the smart contract platform, at all.\nIf all participants can agree to the result of the smart contract without dispute, then they can exit the platform even after the platform disappears.\n\nNow of course there will be participants who will not cooperate in such a case, for example if they were doing some betting game and \"lost\".\nBut at least it gives the possibility of doing so, and it will not be as massive a loss.\n\nIndeed, if the smart contract platform code is open source, it may be possible to set up another implementation of the smart contract platform.\nAnd it would be possible to at least try to convince all participants to switch to that new platform (again, via the \"as long as everybody agrees\" escape hatch).\nAgain, this is not possible with current federated sidechains, or Ethereum (if Ethereum fails, all ETH becomes valueless).\n\n> The proposal induces a very centralized system, to my knowledge all of\n> existing sidechains whether on bitcoin or ethereum are centralized,\n> except lightning (if we forget that someone must watch what others are\n> doing when you are on a trek in Nepal)\n\nI would not lump together Lightning with sidechains.\nIndeed, this design moves things closer to true offchain techniques (as in Lightning) than to sidechain techniques.\n\nSo while centralized, it is less centralized than a federated sidechains.\n\n> Now I don't get why a sidechain should be a blockchain on top on another\n> one (given also that we can't consider bitcoin or ethereum as\n> decentralized today, so the path might be long for the sidechains...),\n> the latest is used to store the final state, the former does not have to\n> store forever the intermediate states, then it could just use a\n> decentralized system (not necessarilly blockchain-like) to store the\n> intermediate states and maybe be a distributed escrow\n>\n> I know, easy to say, please do it (why not), now the fact that\n> sidechains claim to be decentralized or that they will be is just\n> misleading people (that's not the case of your proposal but it does not\n> say what happens if the platforms go down)\n\nPerhaps it can be a next step.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-05T17:46:35",
                "message_text_only": "Hi,\n\nApparently you are not a fan of ethereum, as far as I can tell ethereum \nsidechains look like a mess with stupid tokens/transactions flooding the \nnetwork while they are completely centralized, but some bitcoin \nsidechains can easily compete with this too, like Tether, don't even \nunderstand how anyone can give some credit to that stuff the way it is \nimplemented, and if bitcoin fails that would be the same as for ethereum\n\nMost likely everyone would agree if the escrow disappears, but not sure \nat all, let's imagine 1 to N put 10K on the table for a game, they \nupdate the states and at the end N wins everything, N is rich and don't \ncare finally if the others cheaters have their coins locked (and to lose \n10K), same with setting up a new escrow to resolve the conflict\n\nI think that you should highlight this (and what private key corresponds \nto E + h(E | s) * G, not sure it's trivial for everybody), probably a \nway to get this more decentralized is to reward the escrows (what is the \ninterest here for people to run a smart contract platform?)\n\nFor lightning, maybe it's a question of wording, I consider it as a \nsidechain AND methods that can be used by other sidechains, as well as \nthe others you quoted, even if only two people in the world use \nlightning, it is still decentralized, because it sustains itself alone\n\nRegards\n\nAymeric\n\nLe 05/04/2019 \u00e0 01:52, ZmnSCPxj a \u00e9crit :\n> Good morning Aymeric,\n>\n>\n>> What if the smart contract platform(s) disappear?\n>>\n> It is still possible to recover the funds, *if* you can convince all participants of some \"fair\" distribution of the funds.\n> You do this by all participants simply signing with their participant keys and taking the first branch of the script.\n> This branch does not require the participation of the smart contract platform, at all.\n> If all participants can agree to the result of the smart contract without dispute, then they can exit the platform even after the platform disappears.\n>\n> Now of course there will be participants who will not cooperate in such a case, for example if they were doing some betting game and \"lost\".\n> But at least it gives the possibility of doing so, and it will not be as massive a loss.\n>\n> Indeed, if the smart contract platform code is open source, it may be possible to set up another implementation of the smart contract platform.\n> And it would be possible to at least try to convince all participants to switch to that new platform (again, via the \"as long as everybody agrees\" escape hatch).\n> Again, this is not possible with current federated sidechains, or Ethereum (if Ethereum fails, all ETH becomes valueless).\n>\n>> The proposal induces a very centralized system, to my knowledge all of\n>> existing sidechains whether on bitcoin or ethereum are centralized,\n>> except lightning (if we forget that someone must watch what others are\n>> doing when you are on a trek in Nepal)\n> I would not lump together Lightning with sidechains.\n> Indeed, this design moves things closer to true offchain techniques (as in Lightning) than to sidechain techniques.\n>\n> So while centralized, it is less centralized than a federated sidechains.\n>\n>> Now I don't get why a sidechain should be a blockchain on top on another\n>> one (given also that we can't consider bitcoin or ethereum as\n>> decentralized today, so the path might be long for the sidechains...),\n>> the latest is used to store the final state, the former does not have to\n>> store forever the intermediate states, then it could just use a\n>> decentralized system (not necessarilly blockchain-like) to store the\n>> intermediate states and maybe be a distributed escrow\n>>\n>> I know, easy to say, please do it (why not), now the fact that\n>> sidechains claim to be decentralized or that they will be is just\n>> misleading people (that's not the case of your proposal but it does not\n>> say what happens if the platforms go down)\n> Perhaps it can be a next step.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-08T10:45:29",
                "message_text_only": "Good morning Aymeric,\n\n> Hi,\n>\n> Apparently you are not a fan of ethereum, as far as I can tell ethereum\n> sidechains look like a mess with stupid tokens/transactions flooding the\n> network while they are completely centralized, but some bitcoin\n> sidechains can easily compete with this too, like Tether, don't even\n> understand how anyone can give some credit to that stuff the way it is\n> implemented, and if bitcoin fails that would be the same as for ethereum\n\nI prefer to be more precise in my terminology.\nColored coins are not the same as sidechains, and there are colored coins and then there are colored coins.\nThis mechanism does not propose some change in colored coins.\nAn important aspect of colored coins is that one can foist them on somebody else to extract things of real value from them, but this mechanism is more strongly for a fixed set of participants.\n\nI strongly suspect that Bitcoin will outlast Ethereum, but that is rather not very related to this topic.\n\n> Most likely everyone would agree if the escrow disappears, but not sure\n> at all, let's imagine 1 to N put 10K on the table for a game, they\n> update the states and at the end N wins everything, N is rich and don't\n> care finally if the others cheaters have their coins locked (and to lose\n> 10K), same with setting up a new escrow to resolve the conflict\n>\n\nIndeed.\nStill, the option to do so exists, and sometimes all that is needed for humans to do the right thing, is to be given the option to do so.\n\n> I think that you should highlight this (and what private key corresponds\n> to E + h(E | s) * G, not sure it's trivial for everybody), probably a\n> way to get this more decentralized is to reward the escrows (what is the\n> interest here for people to run a smart contract platform?)\n\nI assumed both were obvious, but I suppose a few more words about those would not be amiss.\n\n>\n> For lightning, maybe it's a question of wording, I consider it as a\n> sidechain AND methods that can be used by other sidechains, as well as\n> the others you quoted, even if only two people in the world use\n> lightning, it is still decentralized, because it sustains itself alone\n\nAgain, I prefer precision in my terminology.\nFor me, a sidechain is a blockchain of some sort.\nIn particular, a kind of Merklized singly-linked list containing representations of transformations of state, is how I define blockchain to be.\n\nNo such Merklized singly-linked list exists in Lightning Network, thus I do not consider it, \"blockchain\".\nAnd thus I do not consider it \"sidechain\", as a sidechain is a blockchain.\nCurrent LN does use \"shachains\" by Rusty, but shachains are not Merklized singly-linked lists, but are instead a kind of inverse mountain range structure.\n\nStill, one might consider both federated sidechains and Lightning Network to have a \"federated\" offchain structure.\nThis is because the coins on the Bitcoin blockchain are locked to a multisignature and activity is not recorded on the Bitcoin blockchain.\nHowever, in LN, each channel is a 2-member federation (you and a counterparty) and the mechanism in LN requires consensus (2-of-2) rather than a quorum (m-of-n).\nThis greatly increases the security of LN: the owner of funding on an LN channel can always refuse to sign an update if the other member of the federation is taken over.\nCompare this to the quorum that typical federations have, where takeover of a sufficient quorum is enough to steal funds from the remaining federation.\nhttps://zmnscpxj.github.io/offchain/safety.html\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-08T16:28:27",
                "message_text_only": "Hi,\n\nI took the example of colored coins because you quoted ethereum and like\nmost of ethereum tokens most of them reflect something coming from\nnowhere, worse I can send you 10K Tethers if you like that of course\nwill not be validated by the central system but will be recorded in\nbitcoin blockchain\n\nBitcoin oulasting ethereum, maybe, but the bitcoin community must make\nmore efforts to explain things, like \"both were obvious\" below is not in\nfact for an usual reader, so a few more words would be good indeed\n\nFor me a sidechain does not have to be a blockchain but a decentralized\nsystem allowing to secure off chain transactions until the final state\nis stored into the blockchain, I don't see the use of storing forever\nthe intermediate states neither why the sidechain should be a\nblockchain, if not then the sidechain would just be another\nbitcoin/ethereum, no? What would be the purpose of building a blockchain\non top of another one? Just do your own, and this would eliminate the\ndrawback of needing to have bitcoins or ethers to smart contract things\nthat have nothing to do with them, as well as mixing addresses between\nthe blockchain and the sidechains\n\nRegards\n\nAymeric\n\nLe 08/04/2019 \u00e0 12:45, ZmnSCPxj a \u00e9crit\u00a0:\n> Good morning Aymeric,\n>\n>> Hi,\n>>\n>> Apparently you are not a fan of ethereum, as far as I can tell ethereum\n>> sidechains look like a mess with stupid tokens/transactions flooding the\n>> network while they are completely centralized, but some bitcoin\n>> sidechains can easily compete with this too, like Tether, don't even\n>> understand how anyone can give some credit to that stuff the way it is\n>> implemented, and if bitcoin fails that would be the same as for ethereum\n> I prefer to be more precise in my terminology.\n> Colored coins are not the same as sidechains, and there are colored coins and then there are colored coins.\n> This mechanism does not propose some change in colored coins.\n> An important aspect of colored coins is that one can foist them on somebody else to extract things of real value from them, but this mechanism is more strongly for a fixed set of participants.\n>\n> I strongly suspect that Bitcoin will outlast Ethereum, but that is rather not very related to this topic.\n>\n>> Most likely everyone would agree if the escrow disappears, but not sure\n>> at all, let's imagine 1 to N put 10K on the table for a game, they\n>> update the states and at the end N wins everything, N is rich and don't\n>> care finally if the others cheaters have their coins locked (and to lose\n>> 10K), same with setting up a new escrow to resolve the conflict\n>>\n> Indeed.\n> Still, the option to do so exists, and sometimes all that is needed for humans to do the right thing, is to be given the option to do so.\n>\n>> I think that you should highlight this (and what private key corresponds\n>> to E + h(E | s) * G, not sure it's trivial for everybody), probably a\n>> way to get this more decentralized is to reward the escrows (what is the\n>> interest here for people to run a smart contract platform?)\n> I assumed both were obvious, but I suppose a few more words about those would not be amiss.\n>\n>> For lightning, maybe it's a question of wording, I consider it as a\n>> sidechain AND methods that can be used by other sidechains, as well as\n>> the others you quoted, even if only two people in the world use\n>> lightning, it is still decentralized, because it sustains itself alone\n> Again, I prefer precision in my terminology.\n> For me, a sidechain is a blockchain of some sort.\n> In particular, a kind of Merklized singly-linked list containing representations of transformations of state, is how I define blockchain to be.\n>\n> No such Merklized singly-linked list exists in Lightning Network, thus I do not consider it, \"blockchain\".\n> And thus I do not consider it \"sidechain\", as a sidechain is a blockchain.\n> Current LN does use \"shachains\" by Rusty, but shachains are not Merklized singly-linked lists, but are instead a kind of inverse mountain range structure.\n>\n> Still, one might consider both federated sidechains and Lightning Network to have a \"federated\" offchain structure.\n> This is because the coins on the Bitcoin blockchain are locked to a multisignature and activity is not recorded on the Bitcoin blockchain.\n> However, in LN, each channel is a 2-member federation (you and a counterparty) and the mechanism in LN requires consensus (2-of-2) rather than a quorum (m-of-n).\n> This greatly increases the security of LN: the owner of funding on an LN channel can always refuse to sign an update if the other member of the federation is taken over.\n> Compare this to the quorum that typical federations have, where takeover of a sufficient quorum is enough to steal funds from the remaining federation.\n> https://zmnscpxj.github.io/offchain/safety.html\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-05T06:00:20",
                "message_text_only": "Building from this ---\n\nIt is possible via this mechanism for the federation to be selected by the participants, rather than the federation being defined as a fixed set by the smart contract platform.\n\nPerhaps anyone can advertise themselves (by e.g. locking some bonded amount on the blockchain with a `OP_CHECKSEQUENCEVERIFY`) as being willing to act as trusted executors of smart contracts.\n\nParticipants then select such executors they believe to be trustworthy, and what voting quorum of the selected executors is sufficient to convince the participants of the correct execution of the smart contract.\n\nOf course, more choices, more cognitive effort for you mere humans, so probably not a good idea in general.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, April 4, 2019 9:55 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain. Often this means creating a new blockchain, or at least a sidechain to an existing blockchain. This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-04-17T16:17:11",
                "message_text_only": "Hi all!\n\nI've been thinking a lot about how to add the benefits that lightning\nprovides in terms of privacy and speed to the smart contracts unchained\nsetup. The high-level idea is to utilize the fact that a lightning channel\nalready has on-chain funds locked up, and if parties cooperate, some of\nthese funds can be moved into the 2/3 MultiSig output needed for the escrow\nscheme by cooperating off-chain (and then moved back to their channel\nbalances off-chain as well). The following is an admittedly pretty rough\noutline of how this might be accomplished.\n\nA - B : Smart Contracts in a Lightning Channel\n\n1) Parties both commit to a 2/3 MultiSig output on their next commitment\ntransaction\n2) Parties then both revoke_and_ack\n3) When the contract yields a result, the to_local and to_remote balances\ncan be updated and the 2/3 MultiSig output can be removed\n4) If either party is uncooperative, their counter-party can force close\nthe channel and funds can be resolved on-chain using the escrow\n\nIf either party does not revoke_and_ack well before any potential for them\nto discover if they have an advantage in the contract (or after some small\nbut reasonable time), their counter-party should go on chain with the\ncommitment transaction containing the 2/3 MultiSig\n\nA - B - C : Single Hop Smart Contracts (Useful if someone, B in this case,\nwants to provide a hub that matches users wanting to enter smart contracts)\n\n1) A irrevocably commits to a 2/3 MultiSig output on their commitment\ntransaction with B (which B also commits to but does not yet revoke their\nold state)\n2) C irrevocably commits to the same 2/3 MultiSig output on their\ncommitment transaction with B (which B also commits to)\n3) B irrevocably commits to both outputs\n4) When the contract yields a result, say A should win some money from C,\nthen A can ask B to remove that output (and update balances) by revealing\nto B how to claim funds from C\n5) B can then ask C to remove the output and add to B's balance\n\nIf B does not revoke_and_ack on either channel, then the affected\ncounter-party should close the channel and go on chain with the 2/3\nMultiSig transaction\nIf B refuses to remove the output, A can claim their funds on-chain where B\ncan learn how to claim funds from C\nIf C refuses to remove the output, B can claim their funds on-chain using\nthe information revealed by A\n\nProblems: How do we ensure that only B can claim the 2/3 MultiSig from C,\nand not anyone who sees A's on-chain spend of their 2/3 MultiSig? I'm\npretty sure this is possible to do but I don't know Script well enough\n\nA - B - C - D : Fully Routed Smart Contracts\n\n1) Given the n possible outcomes in which A gets money from the contract\nbetween A and D, a_1 < a_2 < ... < a_n, and the m possible outcomes in\nwhich D gets money, d_1 < d_2 < ... < d_m, D must send n HTLCs to A with\nthe amounts a_1, a_2 - a_1, a_3 - a_2, ..., a_n - a_(n-1) and A must send m\nHTLCs to D with amounts d_1, d_2 - d_1, d_3 - d_2, ..., d_m - d_(m-1)\n2) These HTLCs must be special and have two hashes, where either preimage\nunlocks the funds\n3) In the payments from A to D, A knows one preimage and the smart\ncontracting platform knows the other (and similarly for D to A)\n4) Should a_i be the outcome of the contract, D should tell A what the\npreimages are to payments 1 through i\n5) D should fail all m payments\n6) A should fail all payments i+1 through n\n(It is possible and in fact likely that there can be ways to use fewer\ntransactions and thus less collateral than this, perhaps by using\nsubtraction and not just addition as in a_i - d_j, what I've presented is\nsimply a lower bound that works in all cases)\n\nIf D does not reveal their preimages, A can get the relevant preimages from\nthe smart contracting platform\n\nProblems: The smart contracting platform is given more information about\nthe contract in the happy path in this scheme. Also, all routers need to\nsupport special double-hash HTLCs\n\nAn alternative way to possibly do multi-hop routing that would require less\nbe told to the escrow service, is to have each routing node add an output\non either side where it takes one position in one channel and the other\nposition in the other channel (essentially allowing them to break event\nwhen the contract is completed). This has the same problems as the Single\nHop case as well as the additional problem (that I couldn't imagine a\nsolution for) of making the commitments to the 2/3 MultiSig output on\ncommitment transactions atomic; in the single hop case incentives seem to\nwork out but I don't know how \"failed routing\" would be detected or handled\nin the multi-hop case.\n\nFeedback welcome!\n\nBest,\nNadav\n\nOn Wed, Apr 3, 2019 at 9:14 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> https://zmnscpxj.github.io/bitcoin/unchained.html\n>\n> Smart contracts have traditionally been implemented as part of the\n> consensus rules of some blokchain.  Often this means creating a new\n> blockchain, or at least a sidechain to an existing blockchain.  This\n> writeup proposes an alternative method without launching a separate\n> blockchain or sidechain, while achieving security similar to federated\n> sidechains and additional benefits to privacy and smart-contract-patching.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190417/e30ba24f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-18T05:33:42",
                "message_text_only": "Good morning Nadav,\n\nYes, transporting contracts over a single direct channel is always possible.\n\nWhen Lightning switches to Decker-Russell-Osuntokun (\"eltoo\"), do note that contracts with an absolute timelock must be forced onchain earlier than the absolute timelock by the CSV requirement of the channel (unilateral close time).\n\nWith current Poon-Dryja channels, transported contracts must be augmented by a 2-of-2 on all branches, which can be done by adding a 2-of-2 multisig on the escrow branch, using temporary keys.\nThe purpose of the 2-of-2 is to enforce that the only valid claims to the contract have an `nSequence` representing the unilateral close time of the channel.\nxref. HTLC-timeout and HTLC-success transactions in BOLT#3.\n\nTransporting over multiple hops requires that compliance to a contract makes one side reveal information that the other side does not know, together with some kind of timeout/backoff.\nPractically speaking, only HTLC-type contracts can be transported.\nFor example, DLCs will have many possible branches where the Oracle provides a signature for one branch, and this signature is what is learned by the other party in the contract.\nIn addition, DLCs for practical use require a timeout (in case the Oracle fails to reveal the signature on the appointed time).\nThus, far fewer contracts can be transported over the network.\n\n(Of note is that a Lightning channel is itself a contract (that is transportable only within a direct channel); this is the basis of channel factories, where the factory level is effectively a \"channel\" with more than two participants, and transporting Lightning channels instead of HTLCs)\n(You may be interested in looking at the \"Fulgurite\" effort)\n\nOF note is that DLCs have an Oracle.\nI observe that escrow services (which are specializations of the Smart Contracts Unchained technique) are basically oracles also.\nIf DLCs can transport their oracle signatures over multiple hops, then it should be possible for Smart Contracts Unchained to transport the federation/escrow signatures over multiple hops also.\nI do not know the math behind DLCs enough to be certain, however, and leave it to better mathematicians than I.\n\nRegards,\nZmnSCPxj\n\nRegards,\nZmnSCPxj\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, April 18, 2019 12:17 AM, Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi all!\n>\n> I've been thinking a lot about how to add the benefits that lightning provides in terms of privacy and speed to the smart contracts unchained setup. The high-level idea is to utilize the fact that a lightning channel already has on-chain funds locked up, and if parties cooperate, some of these funds can be moved into the 2/3 MultiSig output needed for the escrow scheme by cooperating off-chain (and then moved back to their channel balances off-chain as well). The following is an admittedly pretty rough outline of how this might be accomplished.\n>\n> A - B : Smart Contracts in a Lightning Channel\n>\n> 1) Parties both commit to a 2/3 MultiSig output on their next commitment transaction\n> 2) Parties then both revoke_and_ack\n> 3) When the contract yields a result, the to_local and to_remote balances can be updated and the 2/3 MultiSig output can be removed\n> 4) If either party is uncooperative, their counter-party can force close the channel and funds can be resolved on-chain using the escrow\n>\n> If either party does not revoke_and_ack well before any potential for them to discover if they have an advantage in the contract (or after some small but reasonable time), their counter-party should go on chain with the commitment transaction containing the 2/3 MultiSig\n>\n> A - B - C : Single Hop Smart Contracts (Useful if someone, B in this case, wants to provide a hub that matches users wanting to enter smart contracts)\n>\n> 1) A irrevocably commits to a 2/3 MultiSig output on their commitment transaction with B (which B also commits to but does not yet revoke their old state)\n> 2) C irrevocably commits to the same 2/3 MultiSig output on their commitment transaction with B (which B also commits to)\n> 3) B irrevocably commits to both outputs\n> 4) When the contract yields a result, say A should win some money from C, then A can ask B to remove that output (and update balances) by revealing to B how to claim funds from C\n> 5) B can then ask C to remove the output and add to B's balance\n>\n> If B does not revoke_and_ack on either channel, then the affected counter-party should close the channel and go on chain with the 2/3 MultiSig transaction\n> If B refuses to remove the output, A can claim their funds on-chain where B can learn how to claim funds from C\n> If C refuses to remove the output, B can claim their funds on-chain using the information revealed by A\n>\n> Problems: How do we ensure that only B can claim the 2/3 MultiSig from C, and not anyone who sees A's on-chain spend of their 2/3 MultiSig? I'm pretty sure this is possible to do but I don't know Script well enough\n>\n> A - B - C - D : Fully Routed Smart Contracts\n>\n> 1) Given the n possible outcomes in which A gets money from the contract between A and D, a_1 < a_2 < ... < a_n, and the m possible outcomes in which D gets money, d_1 < d_2 < ... < d_m, D must send n HTLCs to A with the amounts a_1, a_2 - a_1, a_3 - a_2, ..., a_n - a_(n-1) and A must send m HTLCs to D with amounts d_1, d_2 - d_1, d_3 - d_2, ..., d_m - d_(m-1)\n> 2) These HTLCs must be special and have two hashes, where either preimage unlocks the funds\n> 3) In the payments from A to D, A knows one preimage and the smart contracting platform knows the other (and similarly for D to A)\n> 4) Should a_i be the outcome of the contract, D should tell A what the preimages are to payments 1 through i\n> 5) D should fail all m payments\n> 6) A should fail all payments i+1 through n\n> (It is possible and in fact likely that there can be ways to use fewer transactions and thus less collateral than this, perhaps by using subtraction and not just addition as in a_i - d_j, what I've presented is simply a lower bound that works in all cases)\n>\n> If D does not reveal their preimages, A can get the relevant preimages from the smart contracting platform\n>\n> Problems: The smart contracting platform is given more information about the contract in the happy path in this scheme. Also, all routers need to support special double-hash HTLCs\n>\n> An alternative way to possibly do multi-hop routing that would require less be told to the escrow service, is to have each routing node add an output on either side where it takes one position in one channel and the other position in the other channel (essentially allowing them to break event when the contract is completed). This has the same problems as the Single Hop case as well as the additional problem (that I couldn't imagine a solution for) of making the commitments to the 2/3 MultiSig output on commitment transactions atomic; in the single hop case incentives seem to work out but I don't know how \"failed routing\" would be detected or handled in the multi-hop case.\n>\n> Feedback welcome!\n>\n> Best,\n> Nadav\n>\n> On Wed, Apr 3, 2019 at 9:14 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > https://zmnscpxj.github.io/bitcoin/unchained.html\n> >\n> > Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.\u00a0 Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.\u00a0 This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Smart Contracts Unchained",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tamas Blummer",
                "Ariel Lorenzo-Luaces",
                "Nadav Kohen",
                "Aymeric Vitte",
                "ZmnSCPxj"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 38727
        }
    },
    {
        "title": "[bitcoin-dev] new BIP: Self balancing between excessively low/high fees and block size",
        "thread_messages": [
            {
                "author": "simondev1",
                "date": "2019-04-07T08:50:46",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190407/67671d75/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2019-04-07T18:52:30",
                "message_text_only": "Related ideas previously submitted by me;\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013885.html\n\nTitle: Block size adjustment idea - expedience fees + difficulty scaling\nproportional to block size (+ fee pool)\n\nDen s\u00f6n 7 apr. 2019 17:45simondev1 via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> skrev:\n\n> Dear bitcoin developers,\n>\n> New BIP: https://github.com/bitcoin/bips/pull/774\n>\n> ==Abstract==\n> Logarithm of transaction fee limits block size.\n>\n> ==Motivation==\n> Keep block space small.\n> Waste less with spam transactions.\n> Auto balance Fees: Increase very low fees, Descrease very high fees.\n> Allow larger size when sender pays a lot.\n> Allow wallets to calculate/display how much average free block space there\n> is for each fee price.\n> Allow senders to have more control about how the fee/priority of their\n> transaction will behave, especially in the case of increased adoption in\n> the future.\n>\n> ==Specification==\n> Every transaction has to fit into the following block space:\n> Input variable 'FeeInSatoshiPerByte': Must be positive or 0\n> type: double\n> unit: Satishi per byte\n> Output:\n> type: uint\n> unit: bytes\n> Formula:\n> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )\n>\n> ==Implementation==\n> Sort transactions by FeeInSatoshiPerByte (lowest first)\n> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the\n> bytes of space used so far. Check if summed up bytes of space used so far\n> is smaller or equal than the formula result.\n> If this is valid for each transaction then the blocksize is valid.\n>\n> ==Backward compatibility==\n> Soft fork: If applied AND old hardcoded block size limit is kept.\n> Hard fork: If applied AND old hardcoded block size limit is removed.\n>\n> Regards, simondev1\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190407/0f09ef59/attachment.html>"
            },
            {
                "author": "Bernd Jendrissek",
                "date": "2019-04-07T22:11:55",
                "message_text_only": "On Sun, 7 Apr 2019 at 17:45, simondev1 via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> ==Implementation==\n> Sort transactions by FeeInSatoshiPerByte (lowest first)\n> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the bytes of space used so far. Check if summed up bytes of space used so far is smaller or equal than the formula result.\n> If this is valid for each transaction then the blocksize is valid.\n\nDoesn't this break CPFP? I think to avoid that you'll need to rework\nyour proposed algorithm to treat chains of transactions as a group.\n(And note that you could have multiple transactions in one block that\ndepend on the same \"parent\" transaction, also in the same block.)"
            },
            {
                "author": "simondev1",
                "date": "2019-04-12T15:45:25",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190412/58213037/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-08T00:55:18",
                "message_text_only": "Good morning simondev1,\n\nIt seems the algorithm would greatly increase validation time.\nIn particular, if the current limit is removed (as in hardforked proposal) then a 1Tb block can be used to attack the network, since sorting would require looking through the entire block.\nThus, validation time would still limit the practical block sizes that can be deployed with this.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, April 7, 2019 4:50 PM, simondev1 via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Dear bitcoin developers,\n> \u00a0\n> New BIP: https://github.com/bitcoin/bips/pull/774\n> \u00a0\n> ==Abstract==\n> Logarithm of transaction fee limits block size.\n> \u00a0\n> ==Motivation==\n> Keep block space small.\n> Waste less with spam transactions.\n> Auto balance Fees: Increase very low fees, Descrease very high fees.\n> Allow larger size when sender pays a lot.\n> Allow wallets to calculate/display how much average free block space there is for each fee price.\n> Allow senders to have more control about how the fee/priority of their transaction will behave, especially in the case of increased adoption in the future.\n> \u00a0\n> ==Specification==\n> Every transaction has to fit into the following block space:\n> Input variable 'FeeInSatoshiPerByte': Must be positive or 0\n> type: double\n> unit: Satishi per byte\n> Output:\n> type: uint\n> unit: bytes\n> Formula:\n> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )\n> \u00a0\n> ==Implementation==\n> Sort transactions by FeeInSatoshiPerByte (lowest first)\n> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the bytes of space used so far. Check if summed up bytes of space used so far is smaller or equal than the formula result.\n> If this is valid for each transaction then the blocksize is valid.\n> \u00a0\n> ==Backward compatibility==\n> Soft fork: If applied AND old hardcoded block size limit is kept.\n> Hard fork: If applied AND old hardcoded block size limit is removed.\n>\n> Regards, simondev1\n>"
            },
            {
                "author": "simondev1",
                "date": "2019-04-12T15:49:57",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190412/1b9efcaf/attachment.html>"
            },
            {
                "author": "Omar Shibli",
                "date": "2019-04-09T00:13:21",
                "message_text_only": "Mining strategy is like HFT profitable strategy, you keep it close if it\u2019s\ninteresting, and you talk about it with the whole world if it\u2019s void. gl.\n\nOn Sun, Apr 7, 2019 at 6:45 PM simondev1 via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Dear bitcoin developers,\n>\n> New BIP: https://github.com/bitcoin/bips/pull/774\n>\n> ==Abstract==\n> Logarithm of transaction fee limits block size.\n>\n> ==Motivation==\n> Keep block space small.\n> Waste less with spam transactions.\n> Auto balance Fees: Increase very low fees, Descrease very high fees.\n> Allow larger size when sender pays a lot.\n> Allow wallets to calculate/display how much average free block space there\n> is for each fee price.\n> Allow senders to have more control about how the fee/priority of their\n> transaction will behave, especially in the case of increased adoption in\n> the future.\n>\n> ==Specification==\n> Every transaction has to fit into the following block space:\n> Input variable 'FeeInSatoshiPerByte': Must be positive or 0\n> type: double\n> unit: Satishi per byte\n> Output:\n> type: uint\n> unit: bytes\n> Formula:\n> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )\n>\n> ==Implementation==\n> Sort transactions by FeeInSatoshiPerByte (lowest first)\n> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the\n> bytes of space used so far. Check if summed up bytes of space used so far\n> is smaller or equal than the formula result.\n> If this is valid for each transaction then the blocksize is valid.\n>\n> ==Backward compatibility==\n> Soft fork: If applied AND old hardcoded block size limit is kept.\n> Hard fork: If applied AND old hardcoded block size limit is removed.\n>\n> Regards, simondev1\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/8753e479/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "new BIP: Self balancing between excessively low/high fees and block size",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Natanael",
                "Bernd Jendrissek",
                "ZmnSCPxj",
                "Omar Shibli",
                "simondev1"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 7404
        }
    },
    {
        "title": "[bitcoin-dev] List of proposals for hard fork/soft fork",
        "thread_messages": [
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-04-14T14:44:53",
                "message_text_only": "Is anybody keeping a list of the solid proposals > BIP's to be included in any actual future consensus-driven fork? Perhaps pre-consensus voting of what to include in the fork packages?\n\nSurely not every or each proposal ever scouted is on for consideration.\n\nThis may actually help to build momentum for useful and valuable implementations that may otherwise languish.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/ec57cd84/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-15T02:59:44",
                "message_text_only": "Good morning LORD YOUR EXCELLENCY,\n\nMay it please you to be informed the below are likely to be included in some kind of upcoming softfork for SegWit v1:\n\n1.  Schnorr signatures.\n2.  MuSig.\n3.  Taproot.\n4.  `SIGHASH_NOINPUT`.\n5.  Signature aggregation.  May it please you to be informed, that \"Schnorr\" enables signature aggregation, but is not signature aggregation itself.\n6.  MAST.\n\nThe above may or may not be an exhaustive list, your excellency.\n\nOf these, I believe only `SIGHASH_NOINPUT` has a BIP, may it please your excellency to learn that it is BIP 118.\nHowever, I am sorry to inform your excellency, as I understand the `SIGHASH_NOINPUT` that will eventually reach Bitcoin Core will not match the current version of BIP118.\nTo improve on the possibility of incorrect use of `SIGHASH_NOINPUT`, it is proposed that every input that is signed with a `SIGHASH_NOINPUT` signature additionally require a signature without `SIGHASH_NOINPUT`.\nFor other details, I am sorry to inform your excellency, I have no reliable knowledge.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, April 14, 2019 10:44 PM, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Is anybody keeping a list of the solid proposals > BIP's to be included in any actual future consensus-driven fork? Perhaps pre-consensus voting of what to include in the fork packages?\n>\n> Surely not every or each proposal ever scouted is on for consideration.\n>\n> This may actually help to build momentum for useful and valuable implementations that may otherwise languish.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH"
            }
        ],
        "thread_summary": {
            "title": "List of proposals for hard fork/soft fork",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "LORD HIS EXCELLENCY JAMES HRMH"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2274
        }
    },
    {
        "title": "[bitcoin-dev] Improving SPV security with PoW fraud proofs",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2019-04-15T06:37:43",
                "message_text_only": "Simplified-Payment-Verification (SPV) is secure under the assumption\nthat the chain with the most Proof-of-Work (PoW) is valid. As many\nhave pointed out before, and attacks like Segwit2x have shown, this is\nnot a safe assumption. What I propose below improves this assumption\n-- invalid blocks will be rejected as long as there are enough honest\nminers to create a block within a reasonable time frame. This still\ndoesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\nclear improvement over regular SPV (and compatible with the privacy\nimprovements of BIP157[0]).\n\nThe idea is that a fork is an indication of potential misbehavior --\nits block header can serve as a PoW fraud proof. Conversely, the lack\nof a fork is an indication that a block is valid. If a fork is created\nfrom a block at height N, this means a subset of miners may disagree\non the validity of block N+1. If SPV clients download and verify this\nblock, they can judge for themselves whether or not the chain should\nbe rejected. Of course it could simply be a natural fork, in which\ncase we continue following the chain with the most PoW.\n\nThe way Bitcoin currently works, it is impossible to verify the\nvalidity of block N+1 without knowing the UTXO set at block N, even if\nyou are willing to assume that block N (and everything before it) is\nvalid. This would change with the introduction of UTXO set\ncommitments, allowing block N+1 to be validated by verifying whether\nits inputs are present in the UTXO set that was committed to in block\nN. An open question is whether a similar result can be achieved\nwithout a soft fork that commits to the UTXO set[0][1].\n\nIf an invalid block is created and only 10% of the miners are honest,\non average it would take 100 minutes for a valid block to appear.\nDuring this time, the SPV client will be following the invalid chain\nand see roughly 9 confirmations before the chain gets rejected. It may\ntherefore be prudent to wait for a number of confirmations that\ncorresponds to the time it may take for the conservative percentage of\nminers that you think may behave honestly to create a block (including\nvariance).\n\nIf users do not wait and happen to accept payments from an invalid\nchain during this time, these payments could get reverted. This is a\nweakness, but still seems preferably to continually following an\ninvalid chain. As long as a reasonable number of miners remains\nhonest, a dishonest majority can only temporarily control the network,\nand their blocks (and all coins gained from it) will eventually be\nrejected.\n\n-- Ruben Somsen\n\n\n[0] Olaoluwa Osuntokun, BIP 157: Client Side Block Filtering,\nhttps://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki\n\n[1] Peter Todd, TXO commitments do not need a soft-fork to be useful,\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-18T16:55:10",
                "message_text_only": "Good morning Ruben,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Simplified-Payment-Verification (SPV) is secure under the assumption\n> that the chain with the most Proof-of-Work (PoW) is valid. As many\n> have pointed out before, and attacks like Segwit2x have shown, this is\n> not a safe assumption. What I propose below improves this assumption\n> -- invalid blocks will be rejected as long as there are enough honest\n> miners to create a block within a reasonable time frame. This still\n> doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> clear improvement over regular SPV (and compatible with the privacy\n> improvements of BIP157[0]).\n>\n> The idea is that a fork is an indication of potential misbehavior --\n> its block header can serve as a PoW fraud proof. Conversely, the lack\n> of a fork is an indication that a block is valid. If a fork is created\n> from a block at height N, this means a subset of miners may disagree\n> on the validity of block N+1. If SPV clients download and verify this\n> block, they can judge for themselves whether or not the chain should\n> be rejected. Of course it could simply be a natural fork, in which\n> case we continue following the chain with the most PoW.\n\nI presume you mean a chain split?\n\n>\n> The way Bitcoin currently works, it is impossible to verify the\n> validity of block N+1 without knowing the UTXO set at block N, even if\n> you are willing to assume that block N (and everything before it) is\n> valid. This would change with the introduction of UTXO set\n> commitments, allowing block N+1 to be validated by verifying whether\n> its inputs are present in the UTXO set that was committed to in block\n> N. An open question is whether a similar result can be achieved\n> without a soft fork that commits to the UTXO set[0][1].\n>\n> If an invalid block is created and only 10% of the miners are honest,\n> on average it would take 100 minutes for a valid block to appear.\n> During this time, the SPV client will be following the invalid chain\n> and see roughly 9 confirmations before the chain gets rejected. It may\n> therefore be prudent to wait for a number of confirmations that\n> corresponds to the time it may take for the conservative percentage of\n> miners that you think may behave honestly to create a block (including\n> variance).\n\nI suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\nIf this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n\n>10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\nConsider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n\nIt is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-04-18T20:12:20",
                "message_text_only": "I'm probably repeating a point which has been said before.\n\n>I suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\nIf this minority miner has > 10% of network hashrate, then the rule of\nthumb above would, on average, give it the ability to disrupt the\nSPV-using network.\n\nProposed rule:\nWhenever a chainsplit occurs SPV clients should download and validate\nthe \"longest chain\" up to more than one block greater than the height\nof the losing chain.\n\nLets say a block split causes chain A and chain B: Chain A is N blocks\nlong, chain B is M blocks long, and N < M. Then the SPV client should\ndownload all the block data of N+1 blocks from Chain B to verify\navailability of chain B. Once the SPV client has verified that chain B\nis available they can use fraud proofs determine if chain B is valid.\n\nAn attacker could use this to force SPV clients to download 1 block\nper block the attacker mines. This is strictly weaker security than\nprovided by a full-node because chain B will only be validated if the\nclient knows chain A exists. If the SPV client's view of the\nblockchain is eclipsed then the client will never learn that chain A\nexists and thus never validate chain B's availability nor will the\nclient be able to learn fraud proofs about chain B. A full node in\nthis circumstance would notice that the chain B is invalid and reject\nit because a full node would not depend on fraud proofs. That being\nsaid this rule would provide strictly more security than current SPV\nclients.\n\nOn Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Good morning Ruben,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Simplified-Payment-Verification (SPV) is secure under the assumption\n> > that the chain with the most Proof-of-Work (PoW) is valid. As many\n> > have pointed out before, and attacks like Segwit2x have shown, this is\n> > not a safe assumption. What I propose below improves this assumption\n> > -- invalid blocks will be rejected as long as there are enough honest\n> > miners to create a block within a reasonable time frame. This still\n> > doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> > clear improvement over regular SPV (and compatible with the privacy\n> > improvements of BIP157[0]).\n> >\n> > The idea is that a fork is an indication of potential misbehavior --\n> > its block header can serve as a PoW fraud proof. Conversely, the lack\n> > of a fork is an indication that a block is valid. If a fork is created\n> > from a block at height N, this means a subset of miners may disagree\n> > on the validity of block N+1. If SPV clients download and verify this\n> > block, they can judge for themselves whether or not the chain should\n> > be rejected. Of course it could simply be a natural fork, in which\n> > case we continue following the chain with the most PoW.\n>\n> I presume you mean a chain split?\n>\n> >\n> > The way Bitcoin currently works, it is impossible to verify the\n> > validity of block N+1 without knowing the UTXO set at block N, even if\n> > you are willing to assume that block N (and everything before it) is\n> > valid. This would change with the introduction of UTXO set\n> > commitments, allowing block N+1 to be validated by verifying whether\n> > its inputs are present in the UTXO set that was committed to in block\n> > N. An open question is whether a similar result can be achieved\n> > without a soft fork that commits to the UTXO set[0][1].\n> >\n> > If an invalid block is created and only 10% of the miners are honest,\n> > on average it would take 100 minutes for a valid block to appear.\n> > During this time, the SPV client will be following the invalid chain\n> > and see roughly 9 confirmations before the chain gets rejected. It may\n> > therefore be prudent to wait for a number of confirmations that\n> > corresponds to the time it may take for the conservative percentage of\n> > miners that you think may behave honestly to create a block (including\n> > variance).\n>\n> I suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n>\n> >10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\n> Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n>\n> It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-19T00:25:25",
                "message_text_only": "Good morning Ethan,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, April 19, 2019 4:12 AM, Ethan Heilman <eth3rs at gmail.com> wrote:\n\n> I'm probably repeating a point which has been said before.\n>\n> > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n>\n> If this minority miner has > 10% of network hashrate, then the rule of\n> thumb above would, on average, give it the ability to disrupt the\n> SPV-using network.\n>\n> Proposed rule:\n> Whenever a chainsplit occurs SPV clients should download and validate\n> the \"longest chain\" up to more than one block greater than the height\n> of the losing chain.\n>\n> Lets say a block split causes chain A and chain B: Chain A is N blocks\n> long, chain B is M blocks long, and N < M. Then the SPV client should\n> download all the block data of N+1 blocks from Chain B to verify\n> availability of chain B. Once the SPV client has verified that chain B\n> is available they can use fraud proofs determine if chain B is valid.\n\nLet us then revert to the original scenario.\nSuppose a supermajority (90%) of miners decide to increase inflation of the currency.\n\nThey do this by imposing the rule:\n\n1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.\n2.  For 9 blocks, the coinbase is the pre-fork value.\n3.  Repeat this pattern every 10 blocks.\n\nThe above is a hardfork.\nHowever, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.\n\nAt height S+1, they begin the above rule.\nThis implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.\n\nAt around height S+9, the minority miners generate an alternate block at height S+1.\nSo SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n\nAt around height S+18, the minority miners generate an alternate block at height S+2.\nSo SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.\n\nThis can go on for a good amount of time.\nWith a \"rare enough\" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.\n\nAgain: every rule is an opportunity to loophole.\n\nRegards,\nZmnSCPxj\n\n> An attacker could use this to force SPV clients to download 1 block\n> per block the attacker mines. This is strictly weaker security than\n> provided by a full-node because chain B will only be validated if the\n> client knows chain A exists. If the SPV client's view of the\n> blockchain is eclipsed then the client will never learn that chain A\n> exists and thus never validate chain B's availability nor will the\n> client be able to learn fraud proofs about chain B. A full node in\n> this circumstance would notice that the chain B is invalid and reject\n> it because a full node would not depend on fraud proofs. That being\n> said this rule would provide strictly more security than current SPV\n> clients.\n>\n> On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev\n> bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > Good morning Ruben,\n> > Sent with ProtonMail Secure Email.\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> >\n> > > Simplified-Payment-Verification (SPV) is secure under the assumption\n> > > that the chain with the most Proof-of-Work (PoW) is valid. As many\n> > > have pointed out before, and attacks like Segwit2x have shown, this is\n> > > not a safe assumption. What I propose below improves this assumption\n> > > -- invalid blocks will be rejected as long as there are enough honest\n> > > miners to create a block within a reasonable time frame. This still\n> > > doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> > > clear improvement over regular SPV (and compatible with the privacy\n> > > improvements of BIP157[0]).\n> > > The idea is that a fork is an indication of potential misbehavior --\n> > > its block header can serve as a PoW fraud proof. Conversely, the lack\n> > > of a fork is an indication that a block is valid. If a fork is created\n> > > from a block at height N, this means a subset of miners may disagree\n> > > on the validity of block N+1. If SPV clients download and verify this\n> > > block, they can judge for themselves whether or not the chain should\n> > > be rejected. Of course it could simply be a natural fork, in which\n> > > case we continue following the chain with the most PoW.\n> >\n> > I presume you mean a chain split?\n> >\n> > > The way Bitcoin currently works, it is impossible to verify the\n> > > validity of block N+1 without knowing the UTXO set at block N, even if\n> > > you are willing to assume that block N (and everything before it) is\n> > > valid. This would change with the introduction of UTXO set\n> > > commitments, allowing block N+1 to be validated by verifying whether\n> > > its inputs are present in the UTXO set that was committed to in block\n> > > N. An open question is whether a similar result can be achieved\n> > > without a soft fork that commits to the UTXO set[0][1].\n> > > If an invalid block is created and only 10% of the miners are honest,\n> > > on average it would take 100 minutes for a valid block to appear.\n> > > During this time, the SPV client will be following the invalid chain\n> > > and see roughly 9 confirmations before the chain gets rejected. It may\n> > > therefore be prudent to wait for a number of confirmations that\n> > > corresponds to the time it may take for the conservative percentage of\n> > > miners that you think may behave honestly to create a block (including\n> > > variance).\n> >\n> > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n> >\n> > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\n> > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n> >\n> > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n> > Regards,\n> > ZmnSCPxj\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-04-19T01:13:07",
                "message_text_only": "Hi ZmnSCPxj,\n\nLet's see if I understand what you are saying. In your scenario chain\nA consists of honest miners (10% of the hash rate) and chain B  (90%\nof the hash rate) consists of dishonest miners who are inflating the\ncoin supply.\n\nChain A: S, S+1\nChain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9\n\nChain B S+1 has a invalid coinbase\n\n>At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n\nWhat I am suggesting is that when the minority miners generate an\nalternate block at S+1 (chain A) the SPV node would download blocks\nS+1 and S+2 from chain B (the dishonest chain). Since S+1 has the\ninvalid coinbase the SPV node would learn that chain B is invalid and\nabandon it.\n\nBitcoin is in big trouble if a malicious party controls 90% of the\nmining power. The malicious miners can spend +11% of their mining\npower ensuring that the honest chain never reaches consensus by\ncontinuously forking it. The malicious miners can then extend their\nfavored chain using the other 79% of the mining power. This would\nproduce a scenario in which users are forced to choose between a\nstable chain that violates a consensus rule and an unstable honest\nchain that is completely unusable and which never pays out mining\nrewards. I agree that SPV nodes and many wallets would make this even\nworse especially in their current condition where they just trust the\nhash rate/wallet provider and there are no fraud proofs.\n\nOn Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ethan,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Friday, April 19, 2019 4:12 AM, Ethan Heilman <eth3rs at gmail.com> wrote:\n>\n> > I'm probably repeating a point which has been said before.\n> >\n> > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> >\n> > If this minority miner has > 10% of network hashrate, then the rule of\n> > thumb above would, on average, give it the ability to disrupt the\n> > SPV-using network.\n> >\n> > Proposed rule:\n> > Whenever a chainsplit occurs SPV clients should download and validate\n> > the \"longest chain\" up to more than one block greater than the height\n> > of the losing chain.\n> >\n> > Lets say a block split causes chain A and chain B: Chain A is N blocks\n> > long, chain B is M blocks long, and N < M. Then the SPV client should\n> > download all the block data of N+1 blocks from Chain B to verify\n> > availability of chain B. Once the SPV client has verified that chain B\n> > is available they can use fraud proofs determine if chain B is valid.\n>\n> Let us then revert to the original scenario.\n> Suppose a supermajority (90%) of miners decide to increase inflation of the currency.\n>\n> They do this by imposing the rule:\n>\n> 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.\n> 2.  For 9 blocks, the coinbase is the pre-fork value.\n> 3.  Repeat this pattern every 10 blocks.\n>\n> The above is a hardfork.\n> However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.\n>\n> At height S+1, they begin the above rule.\n> This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.\n>\n> At around height S+9, the minority miners generate an alternate block at height S+1.\n> So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n>\n> At around height S+18, the minority miners generate an alternate block at height S+2.\n> So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.\n>\n> This can go on for a good amount of time.\n> With a \"rare enough\" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.\n>\n> Again: every rule is an opportunity to loophole.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > An attacker could use this to force SPV clients to download 1 block\n> > per block the attacker mines. This is strictly weaker security than\n> > provided by a full-node because chain B will only be validated if the\n> > client knows chain A exists. If the SPV client's view of the\n> > blockchain is eclipsed then the client will never learn that chain A\n> > exists and thus never validate chain B's availability nor will the\n> > client be able to learn fraud proofs about chain B. A full node in\n> > this circumstance would notice that the chain B is invalid and reject\n> > it because a full node would not depend on fraud proofs. That being\n> > said this rule would provide strictly more security than current SPV\n> > clients.\n> >\n> > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev\n> > bitcoin-dev at lists.linuxfoundation.org wrote:\n> >\n> > > Good morning Ruben,\n> > > Sent with ProtonMail Secure Email.\n> > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > >\n> > > > Simplified-Payment-Verification (SPV) is secure under the assumption\n> > > > that the chain with the most Proof-of-Work (PoW) is valid. As many\n> > > > have pointed out before, and attacks like Segwit2x have shown, this is\n> > > > not a safe assumption. What I propose below improves this assumption\n> > > > -- invalid blocks will be rejected as long as there are enough honest\n> > > > miners to create a block within a reasonable time frame. This still\n> > > > doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> > > > clear improvement over regular SPV (and compatible with the privacy\n> > > > improvements of BIP157[0]).\n> > > > The idea is that a fork is an indication of potential misbehavior --\n> > > > its block header can serve as a PoW fraud proof. Conversely, the lack\n> > > > of a fork is an indication that a block is valid. If a fork is created\n> > > > from a block at height N, this means a subset of miners may disagree\n> > > > on the validity of block N+1. If SPV clients download and verify this\n> > > > block, they can judge for themselves whether or not the chain should\n> > > > be rejected. Of course it could simply be a natural fork, in which\n> > > > case we continue following the chain with the most PoW.\n> > >\n> > > I presume you mean a chain split?\n> > >\n> > > > The way Bitcoin currently works, it is impossible to verify the\n> > > > validity of block N+1 without knowing the UTXO set at block N, even if\n> > > > you are willing to assume that block N (and everything before it) is\n> > > > valid. This would change with the introduction of UTXO set\n> > > > commitments, allowing block N+1 to be validated by verifying whether\n> > > > its inputs are present in the UTXO set that was committed to in block\n> > > > N. An open question is whether a similar result can be achieved\n> > > > without a soft fork that commits to the UTXO set[0][1].\n> > > > If an invalid block is created and only 10% of the miners are honest,\n> > > > on average it would take 100 minutes for a valid block to appear.\n> > > > During this time, the SPV client will be following the invalid chain\n> > > > and see roughly 9 confirmations before the chain gets rejected. It may\n> > > > therefore be prudent to wait for a number of confirmations that\n> > > > corresponds to the time it may take for the conservative percentage of\n> > > > miners that you think may behave honestly to create a block (including\n> > > > variance).\n> > >\n> > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n> > >\n> > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\n> > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n> > >\n> > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-19T02:53:49",
                "message_text_only": "Good morning Ethan,\n\nThank you for clarifying, I understand better now.\n\nIt seems that minority miners can disrupt SPV clients such that SPV clients will download 2 blocks for every block the minority miner can find, not 1.\n\nThis can be done by simply making multiple 1-block chainsplits, rather than a single persistent chainsplit, and alternating split-off and non-split-off.\n\nFor instance, such a minority miner might split at S+1, forcing SPV clients to download S+1 and S+2.\nThen the minority miner splits at S+3, forcing SPV clients to download S+3 and S+4.\nWith a mere 33% hashrate, this can force SPV clients to download every block, i.e. become a fullnode anyway.\n\nSince there exist pools with >33% hashrate, the above attack is possible so the only solution is to become a fullnode anyway.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, April 19, 2019 9:13 AM, Ethan Heilman <eth3rs at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Let's see if I understand what you are saying. In your scenario chain\n> A consists of honest miners (10% of the hash rate) and chain B (90%\n> of the hash rate) consists of dishonest miners who are inflating the\n> coin supply.\n>\n> Chain A: S, S+1\n> Chain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9\n>\n> Chain B S+1 has a invalid coinbase\n>\n> > At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n>\n> What I am suggesting is that when the minority miners generate an\n> alternate block at S+1 (chain A) the SPV node would download blocks\n> S+1 and S+2 from chain B (the dishonest chain). Since S+1 has the\n> invalid coinbase the SPV node would learn that chain B is invalid and\n> abandon it.\n>\n> Bitcoin is in big trouble if a malicious party controls 90% of the\n> mining power. The malicious miners can spend +11% of their mining\n> power ensuring that the honest chain never reaches consensus by\n> continuously forking it. The malicious miners can then extend their\n> favored chain using the other 79% of the mining power. This would\n> produce a scenario in which users are forced to choose between a\n> stable chain that violates a consensus rule and an unstable honest\n> chain that is completely unusable and which never pays out mining\n> rewards. I agree that SPV nodes and many wallets would make this even\n> worse especially in their current condition where they just trust the\n> hash rate/wallet provider and there are no fraud proofs.\n>\n> On Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n>\n> > Good morning Ethan,\n> > Sent with ProtonMail Secure Email.\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Friday, April 19, 2019 4:12 AM, Ethan Heilman eth3rs at gmail.com wrote:\n> >\n> > > I'm probably repeating a point which has been said before.\n> > >\n> > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > >\n> > > If this minority miner has > 10% of network hashrate, then the rule of\n> > > thumb above would, on average, give it the ability to disrupt the\n> > > SPV-using network.\n> > > Proposed rule:\n> > > Whenever a chainsplit occurs SPV clients should download and validate\n> > > the \"longest chain\" up to more than one block greater than the height\n> > > of the losing chain.\n> > > Lets say a block split causes chain A and chain B: Chain A is N blocks\n> > > long, chain B is M blocks long, and N < M. Then the SPV client should\n> > > download all the block data of N+1 blocks from Chain B to verify\n> > > availability of chain B. Once the SPV client has verified that chain B\n> > > is available they can use fraud proofs determine if chain B is valid.\n> >\n> > Let us then revert to the original scenario.\n> > Suppose a supermajority (90%) of miners decide to increase inflation of the currency.\n> > They do this by imposing the rule:\n> >\n> > 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.\n> > 2.  For 9 blocks, the coinbase is the pre-fork value.\n> > 3.  Repeat this pattern every 10 blocks.\n> >\n> > The above is a hardfork.\n> > However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.\n> > At height S+1, they begin the above rule.\n> > This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.\n> > At around height S+9, the minority miners generate an alternate block at height S+1.\n> > So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n> > At around height S+18, the minority miners generate an alternate block at height S+2.\n> > So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.\n> > This can go on for a good amount of time.\n> > With a \"rare enough\" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.\n> > Again: every rule is an opportunity to loophole.\n> > Regards,\n> > ZmnSCPxj\n> >\n> > > An attacker could use this to force SPV clients to download 1 block\n> > > per block the attacker mines. This is strictly weaker security than\n> > > provided by a full-node because chain B will only be validated if the\n> > > client knows chain A exists. If the SPV client's view of the\n> > > blockchain is eclipsed then the client will never learn that chain A\n> > > exists and thus never validate chain B's availability nor will the\n> > > client be able to learn fraud proofs about chain B. A full node in\n> > > this circumstance would notice that the chain B is invalid and reject\n> > > it because a full node would not depend on fraud proofs. That being\n> > > said this rule would provide strictly more security than current SPV\n> > > clients.\n> > > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev\n> > > bitcoin-dev at lists.linuxfoundation.org wrote:\n> > >\n> > > > Good morning Ruben,\n> > > > Sent with ProtonMail Secure Email.\n> > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > > >\n> > > > > Simplified-Payment-Verification (SPV) is secure under the assumption\n> > > > > that the chain with the most Proof-of-Work (PoW) is valid. As many\n> > > > > have pointed out before, and attacks like Segwit2x have shown, this is\n> > > > > not a safe assumption. What I propose below improves this assumption\n> > > > > -- invalid blocks will be rejected as long as there are enough honest\n> > > > > miners to create a block within a reasonable time frame. This still\n> > > > > doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> > > > > clear improvement over regular SPV (and compatible with the privacy\n> > > > > improvements of BIP157[0]).\n> > > > > The idea is that a fork is an indication of potential misbehavior --\n> > > > > its block header can serve as a PoW fraud proof. Conversely, the lack\n> > > > > of a fork is an indication that a block is valid. If a fork is created\n> > > > > from a block at height N, this means a subset of miners may disagree\n> > > > > on the validity of block N+1. If SPV clients download and verify this\n> > > > > block, they can judge for themselves whether or not the chain should\n> > > > > be rejected. Of course it could simply be a natural fork, in which\n> > > > > case we continue following the chain with the most PoW.\n> > > >\n> > > > I presume you mean a chain split?\n> > > >\n> > > > > The way Bitcoin currently works, it is impossible to verify the\n> > > > > validity of block N+1 without knowing the UTXO set at block N, even if\n> > > > > you are willing to assume that block N (and everything before it) is\n> > > > > valid. This would change with the introduction of UTXO set\n> > > > > commitments, allowing block N+1 to be validated by verifying whether\n> > > > > its inputs are present in the UTXO set that was committed to in block\n> > > > > N. An open question is whether a similar result can be achieved\n> > > > > without a soft fork that commits to the UTXO set[0][1].\n> > > > > If an invalid block is created and only 10% of the miners are honest,\n> > > > > on average it would take 100 minutes for a valid block to appear.\n> > > > > During this time, the SPV client will be following the invalid chain\n> > > > > and see roughly 9 confirmations before the chain gets rejected. It may\n> > > > > therefore be prudent to wait for a number of confirmations that\n> > > > > corresponds to the time it may take for the conservative percentage of\n> > > > > miners that you think may behave honestly to create a block (including\n> > > > > variance).\n> > > >\n> > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n> > > >\n> > > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\n> > > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n> > > >\n> > > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n> > > > Regards,\n> > > > ZmnSCPxj\n> > > > bitcoin-dev mailing list\n> > > > bitcoin-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-04-19T03:21:53",
                "message_text_only": "Good morning to you as well ZmnSCPxj,\n\nMy above email contains an error. The SPV client needs to only\ndownload S+1, not S+1 and S+2.\n\nI agree with you that a weakness of this approach is a miner can make\nSPV clients do substantially more work. However:\n\n1. Mining a block which will never be accepted is an expensive way to\nmake SPV clients download, validate and discard ~2-4 megabytes of\ndata. There are far less expensive ways of wasting the resources of\nSPV clients. Its unclear why someone would want to do this instead of\njust packeting full nodes or SPV servers like we saw with the recent\nDDoS attacks against electrum servers.\n\n2. SPV clients may not even learn about these splits because it\nrequires that someone relay the split to them. Honest full nodes\nshould not relay such splits. To their bitcoin's worth the attacker\nmust also connect to lots of SPV clients.\n\n3. Having SPV clients slow down or become full nodes when a malicious\nminer with significant mining power is attempting to disrupt the\nnetwork is probably a best case outcome. I would prefer this failure\nmode to the current SPV behavior which is to just go with the\n\"longest\" chain.\n\nThanks,\nEthan\n\nOn Thu, Apr 18, 2019 at 10:53 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ethan,\n>\n> Thank you for clarifying, I understand better now.\n>\n> It seems that minority miners can disrupt SPV clients such that SPV clients will download 2 blocks for every block the minority miner can find, not 1.\n>\n> This can be done by simply making multiple 1-block chainsplits, rather than a single persistent chainsplit, and alternating split-off and non-split-off.\n>\n> For instance, such a minority miner might split at S+1, forcing SPV clients to download S+1 and S+2.\n> Then the minority miner splits at S+3, forcing SPV clients to download S+3 and S+4.\n> With a mere 33% hashrate, this can force SPV clients to download every block, i.e. become a fullnode anyway.\n>\n> Since there exist pools with >33% hashrate, the above attack is possible so the only solution is to become a fullnode anyway.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Friday, April 19, 2019 9:13 AM, Ethan Heilman <eth3rs at gmail.com> wrote:\n>\n> > Hi ZmnSCPxj,\n> >\n> > Let's see if I understand what you are saying. In your scenario chain\n> > A consists of honest miners (10% of the hash rate) and chain B (90%\n> > of the hash rate) consists of dishonest miners who are inflating the\n> > coin supply.\n> >\n> > Chain A: S, S+1\n> > Chain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9\n> >\n> > Chain B S+1 has a invalid coinbase\n> >\n> > > At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n> >\n> > What I am suggesting is that when the minority miners generate an\n> > alternate block at S+1 (chain A) the SPV node would download blocks\n> > S+1 and S+2 from chain B (the dishonest chain). Since S+1 has the\n> > invalid coinbase the SPV node would learn that chain B is invalid and\n> > abandon it.\n> >\n> > Bitcoin is in big trouble if a malicious party controls 90% of the\n> > mining power. The malicious miners can spend +11% of their mining\n> > power ensuring that the honest chain never reaches consensus by\n> > continuously forking it. The malicious miners can then extend their\n> > favored chain using the other 79% of the mining power. This would\n> > produce a scenario in which users are forced to choose between a\n> > stable chain that violates a consensus rule and an unstable honest\n> > chain that is completely unusable and which never pays out mining\n> > rewards. I agree that SPV nodes and many wallets would make this even\n> > worse especially in their current condition where they just trust the\n> > hash rate/wallet provider and there are no fraud proofs.\n> >\n> > On Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> >\n> > > Good morning Ethan,\n> > > Sent with ProtonMail Secure Email.\n> > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > On Friday, April 19, 2019 4:12 AM, Ethan Heilman eth3rs at gmail.com wrote:\n> > >\n> > > > I'm probably repeating a point which has been said before.\n> > > >\n> > > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > > >\n> > > > If this minority miner has > 10% of network hashrate, then the rule of\n> > > > thumb above would, on average, give it the ability to disrupt the\n> > > > SPV-using network.\n> > > > Proposed rule:\n> > > > Whenever a chainsplit occurs SPV clients should download and validate\n> > > > the \"longest chain\" up to more than one block greater than the height\n> > > > of the losing chain.\n> > > > Lets say a block split causes chain A and chain B: Chain A is N blocks\n> > > > long, chain B is M blocks long, and N < M. Then the SPV client should\n> > > > download all the block data of N+1 blocks from Chain B to verify\n> > > > availability of chain B. Once the SPV client has verified that chain B\n> > > > is available they can use fraud proofs determine if chain B is valid.\n> > >\n> > > Let us then revert to the original scenario.\n> > > Suppose a supermajority (90%) of miners decide to increase inflation of the currency.\n> > > They do this by imposing the rule:\n> > >\n> > > 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.\n> > > 2.  For 9 blocks, the coinbase is the pre-fork value.\n> > > 3.  Repeat this pattern every 10 blocks.\n> > >\n> > > The above is a hardfork.\n> > > However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.\n> > > At height S+1, they begin the above rule.\n> > > This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.\n> > > At around height S+9, the minority miners generate an alternate block at height S+1.\n> > > So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.\n> > > At around height S+18, the minority miners generate an alternate block at height S+2.\n> > > So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.\n> > > This can go on for a good amount of time.\n> > > With a \"rare enough\" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.\n> > > Again: every rule is an opportunity to loophole.\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > > An attacker could use this to force SPV clients to download 1 block\n> > > > per block the attacker mines. This is strictly weaker security than\n> > > > provided by a full-node because chain B will only be validated if the\n> > > > client knows chain A exists. If the SPV client's view of the\n> > > > blockchain is eclipsed then the client will never learn that chain A\n> > > > exists and thus never validate chain B's availability nor will the\n> > > > client be able to learn fraud proofs about chain B. A full node in\n> > > > this circumstance would notice that the chain B is invalid and reject\n> > > > it because a full node would not depend on fraud proofs. That being\n> > > > said this rule would provide strictly more security than current SPV\n> > > > clients.\n> > > > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev\n> > > > bitcoin-dev at lists.linuxfoundation.org wrote:\n> > > >\n> > > > > Good morning Ruben,\n> > > > > Sent with ProtonMail Secure Email.\n> > > > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > > > >\n> > > > > > Simplified-Payment-Verification (SPV) is secure under the assumption\n> > > > > > that the chain with the most Proof-of-Work (PoW) is valid. As many\n> > > > > > have pointed out before, and attacks like Segwit2x have shown, this is\n> > > > > > not a safe assumption. What I propose below improves this assumption\n> > > > > > -- invalid blocks will be rejected as long as there are enough honest\n> > > > > > miners to create a block within a reasonable time frame. This still\n> > > > > > doesn\u2019t fully inoculate SPV clients against dishonest miners, but is a\n> > > > > > clear improvement over regular SPV (and compatible with the privacy\n> > > > > > improvements of BIP157[0]).\n> > > > > > The idea is that a fork is an indication of potential misbehavior --\n> > > > > > its block header can serve as a PoW fraud proof. Conversely, the lack\n> > > > > > of a fork is an indication that a block is valid. If a fork is created\n> > > > > > from a block at height N, this means a subset of miners may disagree\n> > > > > > on the validity of block N+1. If SPV clients download and verify this\n> > > > > > block, they can judge for themselves whether or not the chain should\n> > > > > > be rejected. Of course it could simply be a natural fork, in which\n> > > > > > case we continue following the chain with the most PoW.\n> > > > >\n> > > > > I presume you mean a chain split?\n> > > > >\n> > > > > > The way Bitcoin currently works, it is impossible to verify the\n> > > > > > validity of block N+1 without knowing the UTXO set at block N, even if\n> > > > > > you are willing to assume that block N (and everything before it) is\n> > > > > > valid. This would change with the introduction of UTXO set\n> > > > > > commitments, allowing block N+1 to be validated by verifying whether\n> > > > > > its inputs are present in the UTXO set that was committed to in block\n> > > > > > N. An open question is whether a similar result can be achieved\n> > > > > > without a soft fork that commits to the UTXO set[0][1].\n> > > > > > If an invalid block is created and only 10% of the miners are honest,\n> > > > > > on average it would take 100 minutes for a valid block to appear.\n> > > > > > During this time, the SPV client will be following the invalid chain\n> > > > > > and see roughly 9 confirmations before the chain gets rejected. It may\n> > > > > > therefore be prudent to wait for a number of confirmations that\n> > > > > > corresponds to the time it may take for the conservative percentage of\n> > > > > > miners that you think may behave honestly to create a block (including\n> > > > > > variance).\n> > > > >\n> > > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.\n> > > > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.\n> > > > >\n> > > > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.\n> > > > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.\n> > > > >\n> > > > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.\n> > > > > Regards,\n> > > > > ZmnSCPxj\n> > > > > bitcoin-dev mailing list\n> > > > > bitcoin-dev at lists.linuxfoundation.org\n> > > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-19T04:48:23",
                "message_text_only": "Good morning Ethan,\n\n> My above email contains an error. The SPV client needs to only\n> download S+1, not S+1 and S+2.\n>\n> I agree with you that a weakness of this approach is a miner can make\n> SPV clients do substantially more work. However:\n>\n> 1.  Mining a block which will never be accepted is an expensive way to\n>     make SPV clients download, validate and discard ~2-4 megabytes of\n>     data. There are far less expensive ways of wasting the resources of\n>     SPV clients. Its unclear why someone would want to do this instead of\n>     just packeting full nodes or SPV servers like we saw with the recent\n>     DDoS attacks against electrum servers.\n>\n> 2.  SPV clients may not even learn about these splits because it\n>     requires that someone relay the split to them. Honest full nodes\n>     should not relay such splits. To their bitcoin's worth the attacker\n>     must also connect to lots of SPV clients.\n>\n> 3.  Having SPV clients slow down or become full nodes when a malicious\n>     miner with significant mining power is attempting to disrupt the\n>     network is probably a best case outcome. I would prefer this failure\n>     mode to the current SPV behavior which is to just go with the\n>     \"longest\" chain.\n\n\nI understand.\nIt seems a reasonable point to do so.\n\nAs I understand it, this requires that UTXO commitments be mandatory.\nIn particular, if UTXO commitments were not mandatory, it would be trivial to force chainsplits at heights where a UTXO commitment was not made, and force an SPV node to download more blocks backwards until a block with a UTXO commitment is found.\n\nMore difficult is: how can an SPV node acquire the UTXO set at a particular block?\nFullnodes automatically update their UTXO set at each block they accept as tip.\nReversing the blocks to update the UTXO set at a particular past time would require a good amount of CPU and memory.\nThus any service that can provide the actual UTXO set at each block would potentially be attackable by simply requesting enough past blocks.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-04-19T13:23:50",
                "message_text_only": "Hi ZmnSCPxj and Ethan,\n\nI apologize if my initial explanation was confusing, but it looks like\nyou figured it out. For every fork, SPV clients only have to download\none block. If there is a fork after block N, this means there are two\nblocks at N+1. You only download and verify N+1 from the longer chain.\n\n>Mining a block which will never be accepted is an expensive way to make SPV clients download validate and discard ~2-4 megabytes of data\n\nAbsolutely, hence the name \"PoW fraud proof\". It gets naturally\ncreated by honest miners and is prohibitively expensive to forge.\n\n>SPV clients may not even learn about these splits because it requires that someone relay the split to them. Honest full nodes should not relay such splits.\n\nYou could perform a fully valid repeated 1-block reorg from the top of\nthe chain. So at least theoretically you could get an honest network\nto relay every split.\n\n>Having SPV clients slow down or become full nodes when a malicious miner with significant mining power is attempting to disrupt the network is probably a best case outcome.\n\nThat is an excellent point.\n\n>As I understand it, this requires that UTXO commitments be mandatory.\n\nPerhaps UTXO sets can be made useful without committing them. I have\nsome very loose thoughts on the subject, I consider it an open\nquestion.\n\n> More difficult is: how can an SPV node acquire the UTXO set at a particular block?\n\nI think you are asking fair questions about how the UTXO set\ncommitments would work in practice, and how viable that makes it. I'm\nnot sure. The most comprehensive work I have seen on this topic has\nbeen the utreexo proposal by Tadge Dryja:\nhttps://www.youtube.com/watch?v=edRun-6ubCc\n\nActually, now that I think about it... As an alternative to UTXO set\ncommitments, the old fraud proofs idea for segwit can be applied here.\n\nWe get miners to commit to the location of the UTXOs that are being\nspent (e.g. transaction 5 in block 12). This allows full nodes to\nsuccinctly prove invalidity to SPV clients in the following ways:\n\n- a committed location does not contain the stated UTXO\n- the UTXO has already been spent in a prior block\n\nIf no fraud proofs are given, then the inputs can be assumed to be valid.\n\nAs you may recall, these kinds of fraud proofs were abandoned mainly\nbecause the data unavailability claim could only be verified by\ndownloading the data, resulting in a DoS vector where all blocks had\nto be downloaded. This problem does not seem to apply here, because we\nare only interested in blocks which have forks, so it's more doable to\ndownload them.\n\n-- Ruben Somsen\n\nOn Fri, Apr 19, 2019 at 6:48 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ethan,\n>\n> > My above email contains an error. The SPV client needs to only\n> > download S+1, not S+1 and S+2.\n> >\n> > I agree with you that a weakness of this approach is a miner can make\n> > SPV clients do substantially more work. However:\n> >\n> > 1.  Mining a block which will never be accepted is an expensive way to\n> >     make SPV clients download, validate and discard ~2-4 megabytes of\n> >     data. There are far less expensive ways of wasting the resources of\n> >     SPV clients. Its unclear why someone would want to do this instead of\n> >     just packeting full nodes or SPV servers like we saw with the recent\n> >     DDoS attacks against electrum servers.\n> >\n> > 2.  SPV clients may not even learn about these splits because it\n> >     requires that someone relay the split to them. Honest full nodes\n> >     should not relay such splits. To their bitcoin's worth the attacker\n> >     must also connect to lots of SPV clients.\n> >\n> > 3.  Having SPV clients slow down or become full nodes when a malicious\n> >     miner with significant mining power is attempting to disrupt the\n> >     network is probably a best case outcome. I would prefer this failure\n> >     mode to the current SPV behavior which is to just go with the\n> >     \"longest\" chain.\n>\n>\n> I understand.\n> It seems a reasonable point to do so.\n>\n> As I understand it, this requires that UTXO commitments be mandatory.\n> In particular, if UTXO commitments were not mandatory, it would be trivial to force chainsplits at heights where a UTXO commitment was not made, and force an SPV node to download more blocks backwards until a block with a UTXO commitment is found.\n>\n> More difficult is: how can an SPV node acquire the UTXO set at a particular block?\n> Fullnodes automatically update their UTXO set at each block they accept as tip.\n> Reversing the blocks to update the UTXO set at a particular past time would require a good amount of CPU and memory.\n> Thus any service that can provide the actual UTXO set at each block would potentially be attackable by simply requesting enough past blocks.\n>\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-20T01:59:25",
                "message_text_only": "Good morning,\n\n\n> > As I understand it, this requires that UTXO commitments be mandatory.\n>\n> Perhaps UTXO sets can be made useful without committing them. I have\n> some very loose thoughts on the subject, I consider it an open\n> question.\n\nThere is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie.\nThe first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work (and probably best to fold it into the Bitcoin blockchain if so).\n\nYou would get the UTXO commitment from the previous block (if the UTXO commitment is in the coinbase, then all you need is the Merkle proof of the coinbase).\n\n\n>\n> > More difficult is: how can an SPV node acquire the UTXO set at a particular block?\n>\n> I think you are asking fair questions about how the UTXO set\n> commitments would work in practice, and how viable that makes it. I'm\n> not sure. The most comprehensive work I have seen on this topic has\n> been the utreexo proposal by Tadge Dryja:\n> https://www.youtube.com/watch?v=edRun-6ubCc\n>\n> Actually, now that I think about it... As an alternative to UTXO set\n> commitments, the old fraud proofs idea for segwit can be applied here.\n>\n> We get miners to commit to the location of the UTXOs that are being\n> spent (e.g. transaction 5 in block 12). This allows full nodes to\n> succinctly prove invalidity to SPV clients in the following ways:\n>\n> -   a committed location does not contain the stated UTXO\n> -   the UTXO has already been spent in a prior block\n>\n>     If no fraud proofs are given, then the inputs can be assumed to be valid.\n>\n>     As you may recall, these kinds of fraud proofs were abandoned mainly\n>     because the data unavailability claim could only be verified by\n>     downloading the data, resulting in a DoS vector where all blocks had\n>     to be downloaded. This problem does not seem to apply here, because we\n>     are only interested in blocks which have forks, so it's more doable to\n>     download them.\n\nThis makes no sense.\nIn order to validate block N, you need to know that every UTXO spent by a transaction in block N is valid.\nThe UTXO you want to validate is located in some other block, not on the single block you are verifying.\n\nThus the non-existent fraud proof can only be validated by loading the block of the UTXO purported to be spent, and every block between that and the current block you are verifying, i.e. fullnode.\nEither that or you trust that every peer you have is not omitting the proof.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-04-20T03:26:03",
                "message_text_only": "Hi ZmnSCPxj,\n\n>There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie\n>The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work\n\nOlaoluwa Osuntokun's BIP157 manages to function without a commitment:\n\"If the client receives conflicting filter headers from different\npeers for any block and filter type, it SHOULD interrogate them to\ndetermine which is faulty.\"\n\nI am wondering if the same logic can be applied to UTXO sets or the\nfraud proofs I just described.\n\n>This makes no sense\n>or you trust that every peer you have is not omitting the proof.\n\nIt's the latter, you trust every peer you have is not omitting the\nproof. It requires one honest peer. The reason this is acceptable is\nbecause you're already making that assumption. If none of your peers\nare honest, you have no guarantee of hearing about the chain with the\nmost PoW.\n\nAgain, this is not a new observation. I am just recalling the fraud\nproof debate from when it was being considered for segwit (though of\ncourse it's possible I got some details wrong).\n\n-- Ruben Somsen\n\nOn Sat, Apr 20, 2019 at 3:59 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning,\n>\n>\n> > > As I understand it, this requires that UTXO commitments be mandatory.\n> >\n> > Perhaps UTXO sets can be made useful without committing them. I have\n> > some very loose thoughts on the subject, I consider it an open\n> > question.\n>\n> There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie.\n> The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work (and probably best to fold it into the Bitcoin blockchain if so).\n>\n> You would get the UTXO commitment from the previous block (if the UTXO commitment is in the coinbase, then all you need is the Merkle proof of the coinbase).\n>\n>\n> >\n> > > More difficult is: how can an SPV node acquire the UTXO set at a particular block?\n> >\n> > I think you are asking fair questions about how the UTXO set\n> > commitments would work in practice, and how viable that makes it. I'm\n> > not sure. The most comprehensive work I have seen on this topic has\n> > been the utreexo proposal by Tadge Dryja:\n> > https://www.youtube.com/watch?v=edRun-6ubCc\n> >\n> > Actually, now that I think about it... As an alternative to UTXO set\n> > commitments, the old fraud proofs idea for segwit can be applied here.\n> >\n> > We get miners to commit to the location of the UTXOs that are being\n> > spent (e.g. transaction 5 in block 12). This allows full nodes to\n> > succinctly prove invalidity to SPV clients in the following ways:\n> >\n> > -   a committed location does not contain the stated UTXO\n> > -   the UTXO has already been spent in a prior block\n> >\n> >     If no fraud proofs are given, then the inputs can be assumed to be valid.\n> >\n> >     As you may recall, these kinds of fraud proofs were abandoned mainly\n> >     because the data unavailability claim could only be verified by\n> >     downloading the data, resulting in a DoS vector where all blocks had\n> >     to be downloaded. This problem does not seem to apply here, because we\n> >     are only interested in blocks which have forks, so it's more doable to\n> >     download them.\n>\n> This makes no sense.\n> In order to validate block N, you need to know that every UTXO spent by a transaction in block N is valid.\n> The UTXO you want to validate is located in some other block, not on the single block you are verifying.\n>\n> Thus the non-existent fraud proof can only be validated by loading the block of the UTXO purported to be spent, and every block between that and the current block you are verifying, i.e. fullnode.\n> Either that or you trust that every peer you have is not omitting the proof.\n>\n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-20T04:45:19",
                "message_text_only": "Good morning Ruben,\n\n> Hi ZmnSCPxj,\n>\n> > There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie\n> > The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work\n>\n> Olaoluwa Osuntokun's BIP157 manages to function without a commitment:\n> \"If the client receives conflicting filter headers from different\n> peers for any block and filter type, it SHOULD interrogate them to\n> determine which is faulty.\"\n>\n> I am wondering if the same logic can be applied to UTXO sets or the\n> fraud proofs I just described.\n\nUTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.\n\nWhat BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.\n\nUTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.\nThus it cannot be a comparison point.\n\n\n> > This makes no sense\n> > or you trust that every peer you have is not omitting the proof.\n>\n> It's the latter, you trust every peer you have is not omitting the\n> proof. It requires one honest peer. The reason this is acceptable is\n> because you're already making that assumption. If none of your peers\n> are honest, you have no guarantee of hearing about the chain with the\n> most PoW.\n\nBut peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.\nThis is precisely the \"data unavailability claim\" that shot down the previous fraud proofs (i.e. absence of proof is not proof of absence, and proof of UTXO validity was defined by proof of absence of any intervening spend of the UTXO).\n\nPerhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain.\nThen a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.\n\n--\n\nTangentially, we cannot just magically commit to anything on the blockchain.\nHeader blocks commit to block data and commit to some other header block.\nAll those header blocks and the block data need to be stored and transmitted over the network somehow, even though they are \"only\" being committed to.\nThus, if you are adding new information to be committed, that may increase the resource usage of fullnodes.\n\nSo if UTXO set commitments, or utreexo commitments, or BIP158 filter digests, etc. are committed to in the coinbase, they have to be stored somehow in fullnodes the entire UUTXO set, or the actual utreexo structure, or the actual BIP158 filter, etc. at each block.\nOtherwise it would be pointless to store those commitments since it would not be possible to somehow acquire the data being committed to after-the-fact.\n\nThis is probably still better than BIP37 but we should still be aware the additional load on fullnodes.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ruben Somsen",
                "date": "2019-04-21T09:13:00",
                "message_text_only": "Hi ZmnSCPxj,\n\n\nAllow me to reply to your post in mixed order (fraud proofs first):\n\n\n>But peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.\n\nI don't believe this is fundamentally different. In either scenario\nyou end up on the wrong chain if all your peers are lying to you. One\nhappens by omission of a fraud proof, while the other happens by\nomission of a valid longest chain.\n\n\n>This is precisely the \"data unavailability claim\" that shot down the previous fraud proofs\n\nThe \"data unavailability\" issue I was referring to, and which I\nbelieve is the reason why fraud proofs were abandoned, is the\nfollowing:\n\n- Alice downloads a block with her full node, but the block is\nincomplete (e.g. a transaction is missing).\n- Alice reports this to Bob's SPV fraud proof client, who verifies\nthis by requesting the transaction from the network.\n- If Bob can't download it, he rejects the block.\n- If Bob can download it, either Alice was malicious, or a miner was\ntemporarily withholding the data.\n- Since Bob can't be certain Alice was being malicious, Bob can't ban\nher, which results in a DoS vector where SPV fraud proof clients can\nbe forced to download all blocks.\n\nWe circumvent the data unavailability problem here completely, since\nwe are only questioning the validity of blocks which are involved in a\nfork (expensive and/or rare), and we are simply always downloading\nthem in full.\n\nIf my arguments above hold up, we can use fraud proof commitments as\ndescribed in segwit BIP141 [0] instead of UTXO set commitments, which\nseems like the more elegant way to achieve the desired outcome.\n\n\n>Perhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain. Then a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.\n\nYes, I mentioned something similar to Laolu, but it does seem\ncomputationally expensive to run every input in a block through the\nfilter of every past block. The fact that BIP157/158 can function\nwithout commitments is also why I suspected we may not necessarily\nneed UTXO set commitments.\n\n\n>UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.\n\nIt seems to me you can validate uncommitted UTXO sets by comparing\nthem. Download and compare UTXO set hashes from multiple peers. If\nthey disagree on a certain block, download that block and the relevant\nmerkle path(s) from the previous block's UTXO set, and then verify who\nis right. Ban the peer who lied. Note that unlike fraud proofs, it is\nnot possible to lie by omission, but it does assume one of your peers\nis honest. Of course this does nothing to dispute your earlier point\nthat this may not be all that efficient (e.g. full nodes keeping\nmerkle paths of all prior states).\n\n\n>What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.\n>UTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.\nThus it cannot be a comparison point.\n\nIt's still possible to lie by omission. Let's say a miner spends some\ncoins in block N, and spends the exact same coins again in block N+1,\nmaking block N+1 invalid. If the filter for block N is maliciously\nconstructed, you won't notice the spend in block N, causing you to\nthink block N+1 is valid. In short, you're still relying on one of\nyour peers to give you a correct filter. If all your peers lie, you\ncan always be deceived.\n\n\n>Tangentially, we cannot just magically commit to anything on the blockchain. [...] if you are adding new information to be committed, that may increase the resource usage of fullnodes. [...] This is probably still better than BIP37 but we should still be aware the additional load on fullnodes.\n\nI agree with all this.\n\n\nTo summarize, this is my current understanding of our options for\nenabling light clients to verify a single block in isolation:\n1. UTXO set commitments (complex, more resource usage to full nodes)\n2. BIP157/158 commitments (expensive for clients to check all filters\nto get exclusion proofs)\n3. BIP141 fraud proof commitments (assumes fraud proofs will be passed\non to the SPV client)\n\nThe debate is still open on whether the options above can be done\nwithout actually committing them into blocks via a soft fork. My\ncurrent hunch is \"yes\" for 1 and 2, and \"no\" for 3, which would be\nunfortunate, because 3 currently seems to me like the more elegant\nsolution.\n\n\n-- Ruben Somsen\n\n\n[0] https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#Compact_fraud_proof_for_SPV_nodes\n\n\n>UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.\n>What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.\n\nUTXO sets summarize data in the entire blockchain, hence proper\nvalidation requires downloading the entire blockchain.\nThus it cannot be a comparison point.\n\n\n> > This makes no sense\n> > or you trust that every peer you have is not omitting the proof.\n>\n> It's the latter, you trust every peer you have is not omitting the\n> proof. It requires one honest peer. The reason this is acceptable is\n> because you're already making that assumption. If none of your peers\n> are honest, you have no guarantee of hearing about the chain with the\n> most PoW.\n\nBut peers can be set up to allow you to hear of all chains while\ndenying you proof of the invalidity of some UTXO.\nThis is precisely the \"data unavailability claim\" that shot down the\nprevious fraud proofs (i.e. absence of proof is not proof of absence,\nand proof of UTXO validity was defined by proof of absence of any\nintervening spend of the UTXO).\n\nPerhaps in combination with BIP157/158 it may be possible, if the\nfilters contain UTXO spends and a BIP158 filter was committed to\non-chain.\nThen a proof of absence could be done by revealing all the BIP158\nfilters from the UTXO creation to the block being validated, as well\nas the blocks whose BIP158 filters matched the UTXO and revealing that\nno, they actually do not spend the UTXO.\n\n--\n\nTangentially, we cannot just magically commit to anything on the blockchain.\nHeader blocks commit to block data and commit to some other header block.\nAll those header blocks and the block data need to be stored and\ntransmitted over the network somehow, even though they are \"only\"\nbeing committed to.\nThus, if you are adding new information to be committed, that may\nincrease the resource usage of fullnodes.\n\nSo if UTXO set commitments, or utreexo commitments, or BIP158 filter\ndigests, etc. are committed to in the coinbase, they have to be stored\nsomehow in fullnodes the entire UUTXO set, or the actual utreexo\nstructure, or the actual BIP158 filter, etc. at each block.\nOtherwise it would be pointless to store those commitments since it\nwould not be possible to somehow acquire the data being committed to\nafter-the-fact.\n\nThis is probably still better than BIP37 but we should still be aware\nthe additional load on fullnodes.\n\nRegards,\nZmnSCPxj\n\nOn Sat, Apr 20, 2019 at 6:45 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> Good morning Ruben,\n>\n> > Hi ZmnSCPxj,\n> >\n> > > There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie\n> > > The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work\n> >\n> > Olaoluwa Osuntokun's BIP157 manages to function without a commitment:\n> > \"If the client receives conflicting filter headers from different\n> > peers for any block and filter type, it SHOULD interrogate them to\n> > determine which is faulty.\"\n> >\n> > I am wondering if the same logic can be applied to UTXO sets or the\n> > fraud proofs I just described.\n>\n> UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.\n>\n> What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.\n>\n> UTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.\n> Thus it cannot be a comparison point.\n>\n>\n> > > This makes no sense\n> > > or you trust that every peer you have is not omitting the proof.\n> >\n> > It's the latter, you trust every peer you have is not omitting the\n> > proof. It requires one honest peer. The reason this is acceptable is\n> > because you're already making that assumption. If none of your peers\n> > are honest, you have no guarantee of hearing about the chain with the\n> > most PoW.\n>\n> But peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.\n> This is precisely the \"data unavailability claim\" that shot down the previous fraud proofs (i.e. absence of proof is not proof of absence, and proof of UTXO validity was defined by proof of absence of any intervening spend of the UTXO).\n>\n> Perhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain.\n> Then a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.\n>\n> --\n>\n> Tangentially, we cannot just magically commit to anything on the blockchain.\n> Header blocks commit to block data and commit to some other header block.\n> All those header blocks and the block data need to be stored and transmitted over the network somehow, even though they are \"only\" being committed to.\n> Thus, if you are adding new information to be committed, that may increase the resource usage of fullnodes.\n>\n> So if UTXO set commitments, or utreexo commitments, or BIP158 filter digests, etc. are committed to in the coinbase, they have to be stored somehow in fullnodes the entire UUTXO set, or the actual utreexo structure, or the actual BIP158 filter, etc. at each block.\n> Otherwise it would be pointless to store those commitments since it would not be possible to somehow acquire the data being committed to after-the-fact.\n>\n> This is probably still better than BIP37 but we should still be aware the additional load on fullnodes.\n>\n> Regards,\n> ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Improving SPV security with PoW fraud proofs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Ethan Heilman",
                "Ruben Somsen"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 75200
        }
    },
    {
        "title": "[bitcoin-dev] BIPS (re:LORD HIS EXCELLENCY JAMES HRMH)",
        "thread_messages": [
            {
                "author": "Bill Miller",
                "date": "2019-04-17T13:57:25",
                "message_text_only": "Here is where I keep track, in general (don't know if that helps, but\nthought I'd send it)\n\nhttps://github.com/bitcoin/bips/blob/master/README.mediawiki\nRegards,\nBill\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190417/87c126a9/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIPS (re:LORD HIS EXCELLENCY JAMES HRMH)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bill Miller"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 354
        }
    },
    {
        "title": "[bitcoin-dev] Using the same public keys, the p2sh returned by `addmultisigaddress` differs from the one returned by `createmultisigaddress`",
        "thread_messages": [
            {
                "author": "Michele Federici",
                "date": "2019-04-19T11:53:51",
                "message_text_only": "Hi everyone,\n\nI'm writing here because I didn't find any resources in the docs or\nsomewhere else online explaining this, I don't get if this is a bug or\nI'm missing something.\n\nI was working on a function to derive the pay-to-script-hash from a\nmultisig script and I was checking the results against the bitcoin\ncore's `addmultisigaddress` output, although I was quite sure that my\nimplementation was correct, my output address was different.\nBy chance, I then tried the `createmultisigaddress` method, using the\nsame public keys, and this time the output was matching with mine.\n\nI thought the outputs of `addmultisigaddress` and\n`createmultisigaddress` were supposed to be the same, but instead are\ninconsistent from each other:\n\n```\nbitcoin-cli addmultisigaddress 1\n'[\"045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c\ne382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\",\"02ac46\nc6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\",\"0224a4dc\n5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07\"]'\n{\n\"address\": \"36ULucjWUTrDvaJzCyhFoVbDoNS6Zum2Du\",\n\"redeemScript\":\n\"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n}\n```\n\n```\nbitcoin-cli createmultisig 1\n'[\"045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c\ne382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\",\"02ac46\nc6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\",\"0224a4dc\n5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07\"]'\n{\n\"address\": \"3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1\",\n\"redeemScript\":\n\"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n}\n```\n\nI was also pretty confused by the fact that the `redeemScript` is the\nsame, only the addresses are different, and calling `decodescript` with\nit I get the same address as `createmultisig`:\n\n```\nbitcoin-cli decodescript\n\"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n{\n\"asm\": \"1\n045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0ce38\n2458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\n02ac46c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\n0224a4dc5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07 3\nOP_CHECKMULTISIG\",\n\"reqSigs\": 1,\n\"type\": \"multisig\",\n\"addresses\": [\n\"12PfkcWheYsfFddWfHhaXpFDVx78gnKQ9k\",\n\"1AYLXzXd6N2avqW4j8Gyhb8jb2jXvNPyuV\",\n\"1PWsxtcBMRHTSX2L7wrXgwnFigHD3KhbFT\"\n],\n\"p2sh\": \"3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1\"\n}\n```\n\nI don't understand, how can this be possible?\n\nThank you,\nMichele\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: This is a digitally signed message part\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190419/58848b69/attachment.sig>"
            },
            {
                "author": "Andrew Chow",
                "date": "2019-04-19T14:30:03",
                "message_text_only": "Hi Michele,\n\nYou are seeing this discrepancy due to the address types in use. addmultisigaddress uses the default address type of the wallet, which is p2sh-segwit. createmultisig uses a default address type of legacy. To have createmultisig get addmultisigaddress's result, you need to add the string \"p2sh-segwit\" to the end of your command. To have addmultisigaddress get createmultisig's result, you need to add the string \"legacy\" to the end of your command.\n\nOn 4/19/19 7:53 AM, Michele Federici via bitcoin-dev wrote:\n\n> Hi everyone,\n>\n> I'm writing here because I didn't find any resources in the docs or\n> somewhere else online explaining this, I don't get if this is a bug or\n> I'm missing something.\n>\n> I was working on a function to derive the pay-to-script-hash from a\n> multisig script and I was checking the results against the bitcoin\n> core's `addmultisigaddress` output, although I was quite sure that my\n> implementation was correct, my output address was different.\n> By chance, I then tried the `createmultisigaddress` method, using the\n> same public keys, and this time the output was matching with mine.\n>\n> I thought the outputs of `addmultisigaddress` and\n> `createmultisigaddress` were supposed to be the same, but instead are\n> inconsistent from each other:\n>\n> ```\n> bitcoin-cli addmultisigaddress 1\n> '[\"045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c\n> e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\",\"02ac46\n> c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\",\"0224a4dc\n> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07\"]'\n> {\n> \"address\": \"36ULucjWUTrDvaJzCyhFoVbDoNS6Zum2Du\",\n> \"redeemScript\":\n> \"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n> }\n> ```\n>\n> ```\n> bitcoin-cli createmultisig 1\n> '[\"045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c\n> e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\",\"02ac46\n> c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\",\"0224a4dc\n> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07\"]'\n> {\n> \"address\": \"3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1\",\n> \"redeemScript\":\n> \"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n> }\n> ```\n>\n> I was also pretty confused by the fact that the `redeemScript` is the\n> same, only the addresses are different, and calling `decodescript` with\n> it I get the same address as `createmultisig`:\n>\n> ```\n> bitcoin-cli decodescript\n> \"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c\n> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4\n> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc\n> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae\"\n> {\n> \"asm\": \"1\n> 045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0ce38\n> 2458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d\n> 02ac46c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831\n> 0224a4dc5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07 3\n> OP_CHECKMULTISIG\",\n> \"reqSigs\": 1,\n> \"type\": \"multisig\",\n> \"addresses\": [\n> \"12PfkcWheYsfFddWfHhaXpFDVx78gnKQ9k\",\n> \"1AYLXzXd6N2avqW4j8Gyhb8jb2jXvNPyuV\",\n> \"1PWsxtcBMRHTSX2L7wrXgwnFigHD3KhbFT\"\n> ],\n> \"p2sh\": \"3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1\"\n> }\n> ```\n>\n> I don't understand, how can this be possible?\n>\n> Thank you,\n> Michele\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190419/e3db3ec9/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Using the same public keys, the p2sh returned by `addmultisigaddress` differs from the one returned by `createmultisigaddress`",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Chow",
                "Michele Federici"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7644
        }
    },
    {
        "title": "[bitcoin-dev] Payjoin2swap: Enabling Payjoin Without Merchant Purchases",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-22T00:07:20",
                "message_text_only": "Introduction\n============\n\nPayjoin vs. Existing Equal-Valued CoinJoins\n-------------------------------------------\n\nAny non-equal-value coinjoin is easily solvable via [value sudoku](https://www.coinjoinsudoku.com/advisory/).\nThus, common deployments of coinjoin use equal-value coinjoins.\n\nEqual-valued coinjoins are very obvious onchain: it has many outputs that are of equal value, or have multiples of some base value.\nAlthough it is in practice difficult to correlate the inputs to outputs, it is still an open indication to blockchain analysis that a break occurs in their analysis.\nHowever, equal-valued coinjoins are needed to break value sudoku.\n\nThe exception to value sudoku for non-equal value coinjoins is if value is transferred between participants in the coinjoin, i.e. the Payjoin proposal.\n\nPayjoin transactions are difficult to differentiate from non-payjoin transactions, which greatly increases the effort required for blockchain analysis.\nIn particular, it breaks the common-input heuristic (UTXOs that are spent together stay together).\nThey may cause blockchain analysis to go astray without blockchain analysis being able to pinpoint which transaction broke the analysis.\n\nPayjoin For Hodlers?\n--------------------\n\nAs payjoin transfers Bitcoin value, it is planned to be used for payments (i.e. spending) rather than hodling.\nThe issue is that it appears that payjoin cannot be used by hodlers, since hodlers are not interested in paying, but in saving.\n\nYet hodlers want to retain their privacy also.\nThey do not want their exchange snooping on them and finding out that they have not moved their coins from cold storage.\nFor long enough timeframes, a KYC-demanding exchange might eventually get hacked or hostilely taken over, with the identifying information of the hodler in the logs of the exchange.\nThe hodler would prefer to have those who have gotten this identifying information to believe that the value has been spent elsewhere, rather than in UTXOs that have not been moved.\n\nAt the same time, they are not interested in purchasing items and therefore cannot utilize payjoin as-is.\nAfter all, payjoin requires a transfer of value from one participant to another.\n(they can continue to utilize existing equal-value coinjoins, if those are acceptable to the hodler)\n\nThe key insight here is that hodlers \"buy Bitcoin\".\nThus there is still the possibility of hodlers using payjoin, by using bitcoins in a payjoin to buy bitcoins of similar value.\n\nThe same insight underlies the observation that, as long as LN-to-onchain swap services exist, it is possible to gain incoming capacity on Lightning channels immediately if one has bitcoins already.\nOne can observe that one gains capacity to receive on Lightning if one spends on Lightning: the technique, then, is to spend BTC on Lightning to buy BTC off Lightning (i.e. onchain).\nWe shall see later that Lightning has some parallels to payjoin2swap.\n\nUsing payjoin for purchases of bitcoins using bitcoins has the massive advantage that we can build software that interacts solely with the Bitcoin blockchain.\nThis simplifies the deployment of payjoin for bitcoin-to-bitcoin swaps, as payjoin for merchant deployment requires interaction of the Bitcoin blockchain, and the infrastructure of the merchant.\nAs most merchants are more interested in their product rather than in Bitcoin technology, we can expect that deployment of payjoin will be slower compared to a payjoin2swap deployment made by Bitcoin tech weenies.\n\nReferences\n----------\n\n* This idea is not original to me: a [feature request on AdamISZ/CoinSwapCS](https://github.com/AdamISZ/CoinSwapCS/issues/52) by Chris Belcher proposes P2EP for CoinSwapCS.\n  However, I have not found any follow up on this idea and the fleshed-out protocol and thoughts below are my own.\n\nPayjoin2swap On the Blockchain\n==============================\n\nIn a payjoin2swap, what is visible on the blockchain is two transactions that occur at about the same time.\nThey appear to pay two different addresses, and each has a change output.\nThe payment addresses are then spent almost immediately, as a self-to-self transfer (one input, one output), while the change output may or may not get spent any time soon.\nIf the wallet used follows [ZeroLink](https://github.com/nopara73/ZeroLink) strictly, then the four addresses (two payment addresses, two change addresses) do not seem to be related, and there would be no reason to think that the two transactions are related.\n\nIn reality, one payout and one change address each are actually owned by the two participants in a payjoin2swap.\n\nThese two transactions all pay out to P2WPKH addresses, and (if the payjoin2swap protocol is followed correctly) we do not see anything special: no 2-of-2, no HTLCs, nothing.\nThis is possible even without Schnorr-based signature schemes, by use of [2p-ECDSA](https://eprint.iacr.org/2017/552.pdf) to create a 2-of-2 multisig in ECDSA among the participants that operates the protocol.\nAny special contracts are hosted inside a temporary offchain cryptocurrency system (slightly like a Lightning channel), and are not exposed if the protocol runs to completion.\nThe transactions have an `nLockTime` near the time they are confirmed onchain, looking like Bitcoin Core behavior.\n\nParticipants in a payjoin2swap need to own two UTXOs onchain; the values need not be equal.\n\nExample 1\n---------\n\nSuppose Alice owns a 900 mBTC and a 10 mBTC UTXO.\nAnd suppose Bob owns a 15 mBTC and 4 mBTC UTXO.\nBoth of the above users would have difficulty with current Wasabi coinjoins which use equal values of around 100mBTC: Alice would have to run several rounds, while Bob cannot participate at all.\n\nWhat would be seen onchain would be:\n\n1.  Alice 900mBTC, Bob 4mBTC -> Alice&Bob 903mBTC, Bob 1mBTC\n2.  Alice 10mBTC, Bob 15mBTC -> Alice 7mBTC, Alice&Bob 18mBTC\n\nFollowed quickly by:\n\n1.  Alice&Bob 903mBTC -> Alice 903mBTC\n2.  Alice&Bob 10mBTC -> Bob 10mBTC\n\nBy use of 2p-ECDSA, the Alice&Bob addresses are P2WPKH addresses and do not reveal that they are actually 2-of-2 multisig.\nObviously, all the public keys would be different.\n\nThe above would lead blockchain analysts to believe that Alice is being paid 903mBTC from some confusing combination of Alice and Bob, and that Bob is being paid 10mBTC from some confusing combination of Alice and Bob.\n\nExample 2\n---------\n\nUnder ZeroLink, post-mix coins cannot be joined, even with other post-mix coins, except as part of a mix operation.\n\nSuppose Alice has a 90mBTC UTXO and a 80mBTC UTXO that are both post-mix coins.\nNow suppose Alice needs to pay Carol 120 mBTC.\nAlice cannot simply join the post-mix coins and pay 120mBTC and get 50mBTC change, as it can reduce the privacy of the mix participants.\nUnder ZeroLink, Alice needs to re-mix the post-mix coins and get at least 120mBTC from the mix before paying.\nThis can be problematic if the only available mix is an equal-value coinjoin where the equal value is less than 120mBTC.\n\nWith payjoin2swap, Alice simply needs to find a Bob who has at two UTXOs that are at least 30mBTC each.\n\nSuppose Alice finds a Bob with 37mBTC UTXO and 66mBTC UTXO.\n\nThey make:\n\n1.  Alice 90mBTC, Bob 37mBTC -> Alice&Bob 120mBTC, Bob 7mBTC\n2.  Alice 80mBTC, Bob 66mBTC -> Alice 50mBTC, Alice&Bob 96mBTC\n\nThen:\n\n1.  Alice&Bob 120mBTC -> Carol 120mBTC\n2.  Alice&Bob 96mBTC -> Bob 96mBTC\n\n\nThere is no transaction directly tying the two post-mix UTXOs of Alice together, but we have effectively \"consolidated\" the inputs of Alice.\n\nThis is in fact quite similar to \"rebalancing\" channels on Lightning.\nPost-mix UTXOs under ZeroLink and with payjoin2swap function similarly to channels on Lightning: you can transfer from one UTXO to another in order to make a large payment, just as you might transfer funds from one channel to another in order to make or forward a large payment on Lightning.\n\nPayjoin2swap Swap Protocol\n==========================\n\n1.  Alice and Bob agree on various details.\n    a.  Who Alice and Bob is.\n        Alice is the one who knows the secret x and pays to an HTLC with higher time L1.\n        Alice gives h(x) to Bob.\n    b.  The start time (a blockheight) of the protocol, Ls.\n    c.  An amount to swap.\n        This should be smaller than the smallest UTXO that will be involved in the swap.\n    d.  A \"safe\" confirmation depth for anchoring, D.\n        This could be D = 6 as per the Bitcoin whitepaper.\n    e.  Twp future blockheights, L0 and L1, such that Ls + D < L0 < L1.\n    f.  Various public keys whose private keys are known by Alice, and various public keys whose private keys are known by Bob.\n        This can be done by using a \"base point\" and deriving the keys from tweaking this base point.\n        Let us call this the (Alice|Bob) \"$name\" basepoint-derived (public|private) key.\n        Give a basepoint B (private key b such that B = bG), we can use something like B + h(B | \"$name\") as the basepoint-derived public key (private key is left as a trivial exercise to the reader).\n    g.  A public key whose private key is known by Alice, and a public key whose private key is known by Bob.\n        If we use the \"base point\" technique above, these keys cannot be derived from the same base point as other keys since the last step of this protocol involves sharing this private key to the other participant.\n        Let us call this the (Alice|Bob) non-basepoint (public|private) key.\n    h.  The feerate.\n\n2.  Alice and Bob generate two 2p-ECDSA federation public keys.\n    a.  The \"Alice-to-Bob federation key\" involves the Alice non-basepoint key, and the Bob \"federation\" basepoint-derived key.\n        As per 2p-ECDSA, Alice can compute this public key by multiplying Alice non-basepoint private key with Bob \"federation\" basepoint-derived public key.\n        Bob can compute this public key by multiplying his private key with the Alice public key.\n    b.  The \"Bob-to-Alice federation key\" involves the Bob non-basepoint key, and the Alice \"federation\" basepoint-derived key.\n        Similar to above as per 2p-ECDSA.\n\n3.  Alice and Bob select from their UTXOs:\n    a.  A set of UTXOs whose sum is greater than the swap value.\n        Call these the \"swap UTXOs\", i.e. Alice swap UTXOs, Bob swap UTXOs.\n    b.  A UTXO to use for a payjoin receive.\n        Call this the \"payjoin UTXO\", i.e. Alice payjoin UTXO, Bob payjoin UTXO.\n\n4.  Generate (but not sign) the \"pre-swap transactions\".\n    Alice and Bob exchange the txids of these transactions and which output is the swap output.\n    Their `nLockTime` is Ls.\n    a.  The \"Alice pre-swap transaction\" spends the Alice swap UTXOs and pays to the \"Alice-to-Bob federation public key\" the agreed swap amount (the swap output).\n        Any extra value is put into a change output that Alice controls.\n    b.  The \"Bob pre-swap transaction\" spends the Bob swap UTXOs and pays to the \"Bob-to-Alice federation public key\" the agreed swap amount, and extra value into a Bob-only change output.\n\n5.  Generate and sign the \"pre-swap backout transactions\", then exchange signatures.\n    This spends the swap output of the \"pre-swap transactions\" and return it to the original payer.\n    Both Alice and Bob can generate these themselves with information already exchanged before.\n    a.  The \"Alice pre-swap backout transaction\" spends the \"Alice pre-swap transaction\" output and pays the entire value to the Alice \"backout\" basepoint-derived public key.\n        Its `nLockTime` is L1.\n    b.  The \"Bob pre-swap backout transaction\" spends the \"Bob pre-swap transaction\" output and pays the entire value to the Bob \"backout\" basepoint-derived public key.\n        Its `nLockTime` is L0.\n\n6.  Validate the signatures for \"pre-swap backout transaction\" of the counterparty.\n\n7.  Sign the \"pre-swap transactions\" and exchange the actual transactions with witness.\n\n8.  Validate the pre-swap transaction from the counterparty:\n    a.  All inputs are signed correctly and are SegWit.\n        All inputs are unspent.\n    b.  The indicated \"swap\" output does pay the correct amount to the correct federation public key.\n        e.g. Bob validates that the Alice pre-swap transaction pays the agreed swap amount to the Alice-to-Bob federation key.\n\n9.  From this point onward, if either of the pre-swap transactions appears in the mempool or confirmed, abort.\n    Attempt to spend all your own swap UTXOs, and if the pre-swap transaction is confirmed, wait for L2 and use the pre-swap backout transaction.\n\n10.  Check if the pre-swap transaction from your counterparty spends a UTXOs in your blacklist.\n     If there are, attempt to spend all your own swap UTXOs and abort.\n\n11.  Add the UTXOs spent by the counterparty pre-swap transaction to your blacklist.\n\n12.  Create the \"payjoined swap transaction\" for your counterparty and exchange their txids and the value of the swap outputs.\n     i.e. Bob creates the Alice payjoined swap transaction and vice versa.\n     Start with the counterparty pre-swap transaction.\n     Insert your own payjoin UTXO at a random index of the inputs.\n     Then increase the swap output according to the value of the payjoin UTXO, minus the feerate times the size of the additional input (including any witness needed).\n\n13.  Generate and sign the \"payjoined swap backout transactions\" and exchange signatures, and whether the added output was before or after the existing output.\n     Start with the counterparty pre-swap backout transaction.\n     Change the input to spend the payjoined swap transaction swap output instead.\n     Then add a new output that pays to the counterparty \"payjoined backout\" basepoint-derived public key, the difference of the input minus the other output, minus the feerate times the size of the additional output.\n\n14.  Exchange the payjoined swap transactions and sign them completely.\n\n15.  Validate that the payjoined swap transactions are signed correctly, and that the additional payjoin UTXO from the counterparty is an unspent SegWit output.\n\n16.  Broadcast both payjoined swap transactions and wait for them to be confirmed to height D.\n     If L0 is too near and both of the payjoined swap transactions are still unconfirmed, abort and attempt to respend all UTXOs you control that are involved.\n     If L0 is too near and one of the payjoined swap transactions is still unconfirmed, abort, and if it is your payjoined swap transaction that is unconfirmed attempt to respend all UTXOs, or if not, just wait for L2 and broadcast the corresponding payjoined swap backout transaction.\n\n17.  Generate the \"HTLC offer transactions\".\n     Each can generate these transactions without communicating with the other.\n     The `nLockTime` is the block height at which the payjoined swap transactions were confirmed at depth D.\n     a.  The Alice HTLC offer:\n         i. Spend the Alice payjoined swap transaction output.\n         ii. Compute backout address N as the 2p-ECDSA of (1) Alice \"alice-htlc-fail\" basepoint-derived key (2) Bob \"alice-htlc-fail\" basepoint-derived key.\n             Pay to `OP_IF OP_HASH160 <h(x)> OP_EQUALVERIFY <Bob \"alice-htlc-claim\" basepoint-derived key> OP_ELSE L1 OP_CHECKLOCKTIMEVERIFY OP_DROP <N> OP_ENDIF OP_CHECKSIG`\n     b.  The Bob HTLC offer:\n         i. Spend the Bob payjoined swap transaction output.\n         ii. Compute backout address O as the 2p-ECDSA of (1) Alice \"bob-htlc-fail\" basepoint-derived key (2) Bob \"bob-htlc-fail\" basepoint-derived key.\n             Pay to `OP_IF OP_HASH160 <h(x)> OP_EQUALVERIFY <Alice \"bob-htlc-claim\" basepoint-derived key> OP_ELSE L0 OP_CHECKLOCKTIMEVERIFY <N> OP_ENDIF OP_CHECKSIG`\n\n18.  Alice generates the \"Alice HTLC offer failure transaction\".\n     This spends the Alice HTLC offer via the timelock path.\n     It thus has an `nLockTime` equal to L1.\n     It gives the agreed swap value to Alice \"backout\" basepoint-derived public key, and the remaining value to Bob \"payjoined backout\" basepoint-derived public key.\n     Alice and Bob generate a signature for this via 2p-ECDSA.\n     Then they generate a signature for the Alice HTLC offer.\n\n19.  From this point if the Alice HTLC offer appears on mempool or is confirmed, Alice must wait for L1 and broadcast the Alice HTLC offer failure transaction.\n\n20.  Bob generates the \"Bob HTLC offer failure transaction\".\n     This spends the Bob HTLC offer via the timelock path, with an `nLockTime` equal to L0.\n     It gives the agreed swap value to Bob \"backout\" basepoint-derived public key, and the remaining value to Alice \"payjoined backout\" basepoint-derived public key.\n     Alice and Bob generate a signature for this.\n     Then they generate a signature for the Bob HTLC offer.\n\n21.  From this point if the Bob HTLC offer appears on mempool or is confirmed, Bob must wait for L1 and broadcast the Bob HTLC offer failure tranasction, or for Alice to claim it by revealing x (and Bob must then broadcast and claim the Alice HTLC offer).\n\n22.  Alice gives Bob x.\n\n23.  Bob gives the Bob non-basepoint private key.\n\n24.  Alice gives the Alice non-basepoint private key.\n\n25.  Alice must now spend the Bob payjoined swap transaction swap output on or before L0.\n     Bob must now spend the Alice payjoined swap transaction swap output on or before L1.\n     They can send it to themselves, send it to any pending payments they might need to give, or find another partner to swap with and make sure to complete up to step 16 in the new cycle before their respective timeouts.\n     a. Alice must spend from the Bob-to-Alice federation pubkey address.\n        This is a combination of the Bob non-basepoint key and the Alice \"federation\" basepoint-derived key.\n        Since Bob has given the Bob non-basepoint key and Alice knows the private keys in all the Alice basepoint-derived keys, Alice can now spend it without Bob authorization.\n     b. Bob must spend from the Alice-to-Bob federation puobkey address.\n        Again, Alice has given enough information to Bob for Bob to completely know the private key wihtout authorization from Alice.\n\nCreating Plausible Transactions\n===============================\n\nFor simplicity, let us consider the case where Alice and Bob each own two UTXOs each.\nThis means that the payjoined transactions have two inputs, and are likely to have two outputs.\nFortunately, a good number of transactions onchain are two-input two-output affairs.\nHowever, we should attempt to build plausible transactions.\n\nFor example, suppose we have:\n\n* Alice has 70mBTC and 800mBTC UTXOs.\n* Bob has 100mBTC and 7 mBTC UTXOs.\n\nThey could propose to swap 85mBTC.\nThen Alice would give the Alice pre-swap transaction as:\n\n* Alice 800mBTC -> Alice 715mBTC, Alice&Bob 85mBTC\n\nAnd Bob would make the Bob pre-swap transaction:\n\n* Bob 100mBTC -> Alice&Bob 85mBTC, Bob 15mBTC\n\nAfter payjoining:\n\n* Alice 800mBTC, Bob 7mBTC -> Alice 715mBTC, Alice&Bob 92mBTC\n* Alice 70mBTC, Bob 100mBTC -> Ailce&Bob 155mBTC, Bob 15mBTC\n\nThe first transaction above is implausible: if the payment amount were 715mBTC, then a fee-reducing coin selector would have just chosen the 800mBTC.\nThus, we should ensure that there exists one output which is larger than the sum of all inputs except the smallest input.\nOtherwise, a fee-reducing coin selection algorithm would have eliminated the smaller coins from the transaction.\n\nFor the case where both Alice and Bob each have two inputs to mix, we could impose the below rules:\n\n1.  Alice and Bob generate pre-swap transactions using the smaller UTXO they have.\n    This implies that the swap amount must be less than or equal to the smallest UTXO.\n2.  Alice and Bob check if their other coin (the one they will propose of payjoining) plus the swap amount is greater than the UTXO consumed in the pre-swap transaction from the other side.\n    i.e. Alice checks the Bob pre-swap input is smaller than the Alice larger UTXO plus the swap amount.\n    If thise fails, they may propose to the counterparty to split their smaller UTXO.\n\nThus, in the above, Alice and Bob should have started their pre-swap transactions as:\n\n* Alice 70mBTC -> Alice 64mBTC, Alie&Bob 6mBTC\n* Bob 7mBTC -> Alice&Bob 6mBTC, Bob 1mBTC\n\nThen the payjoined versions would be:\n\n* Alice 70mBTC, Bob 100mBTC -> Alice 64mBTC, Alice&Bob 106mBTC\n* Alice 800mBTC, Bob 7mBTC -> Alice&Bob 806mBTC, Bob 1mBTC\n\nLinking (and Overlinking) Payjoin2swap\n--------------------------------------\n\nUsing the heuristic above leads to the strong tendency that the difference of an input to the smaller output will be the swap value.\n(or if the transaction is 1 output, then one of the inputs will be exactly the swap value)\nAlso, the main transactions will usually be in the same block and will usually be 2-input transactions.\nThere are fewer possibilities, thus it is a possible avenue for blockchain analysis to attempt linking.\n\nIt is useful to remember that generating this transaction is two steps: first create the pre-swap transaction with the UTXO of one side, before adding a new UTXO for the other side.\n\nSuppose our agreed swap value is S.\nThen one side creates a pre-swap transaction from a UTXO V:\n\n* V -> V - S, S\n\nThe other side can then monitor the mempool for two-input two-output/one-output transactions and compute an \"apparent swap value\" from the difference of an input and the lower input (or 0 if one-output).\nSuppose it finds S'.\nThen the other side can simply synthesize a UTXO of value V - S + S'.\nThe other side can do this by spending a larger UTXO and splitting out that value.\nThis leads to a swap transaction of:\n\n* V, V - S + S' -> V - S, V + S'\n\nThe above still leads to plausible transaction as defined above; the V + S' output will always be larger than the inputs, thus having to combine both inputs is plausible.\nIn doing so, the existing mempool transaction with apparent swap value S' becomes potentially linked to this transaction, even though it is completely unrelated.\n\nFurther, while the swap output is identifiable as V + S', it is not possible to be sure whether S or S' is the swap value.\nThe difference between V + S' and V is S', while the difference between V + S' and V - S + S' is S, so either could be the swap value.\n\nThis operation to mislead blockchain analysis can be called \"overlinking\", as it can lead blockchain analysis to believe that an unrelated transaction is linked to one of the swap transactions.\nParticipants should refuse to swap unlesss they can overlink at least one (and preferably both) of the payjoined swap transactions.\nIf the swap is not possible, both sides can agree to lower the V value of one side (provided V >= S) until the V - S + S' is achievable by the other side."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-22T17:06:43",
                "message_text_only": "Good morning list,\n\nI observe that if the Lightning Network supports:\n\n1.  Wumbo channels (>167.772215mBTC channels)\n2.  Dual-funded channels\n\nThen payjoin2swap is implementable using LN operations.\nGiven two UTXOs V and W you want to transfer some value S from V to W.\n\n1.  Connect to an LN node on Tor and listen to gossip, then disconnect.\n2.  Create two fake node addresses (A and B) and assign a unique Tor hidden service to each.\n3.  Select two actual LN nodes with long uptime (use the lifetime of the channels they have as a rough estimate) and a short distance between them with good capacity and many alternate routes between them.\n4.  Connect A to one node and create a channel using V.\n    Indicate that the channel should be unpublished (the LN protocol has a flag existing for this already).\n    Publishing channels is good for privacy if you intend to stay long on LN (it invites \"normal\" traffic to hide your own payments in), but we do not intend to stay long on LN here, so keep the channels unpublished.\n5.  Connect B to the other node and create a channel with dual-funding, requesting at least S from the other node to put in the channel, using W as your own UTXO.\n    Again indicate the channel should be unpublished.\n6.  Transfer S satoshi over LN from the channel of A to the channel of B.\n7.  Cooperatively close both channels.\n    It is possible to time the closes to be some blocks apart to make them harder for blockchain analysis to link.\n\nThis rides payjoin2swap on top of existing infrastructure.\nThe drawback is that it is unlikely that existing LN implementations will apply ZeroLink for onchain funds, since much of the privacy on LN is with paying over the long-lived offchain channels.\nThis can erode privacy if either of the nodes you connect to uses the result of the cooperative closes to later fund a published channel, possibly mixing it with other coins of their own.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Payjoin2swap: Enabling Payjoin Without Merchant Purchases",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 24525
        }
    },
    {
        "title": "[bitcoin-dev] CoinJoin Jigsaw",
        "thread_messages": [
            {
                "author": "Ryan Perkins",
                "date": "2019-04-22T19:22:52",
                "message_text_only": "Earlier today ZmnSCPxj posted to the mailing list with an interesting post about payjoin. In it he mentioned:\n\n> Any non-equal-value coinjoin is easily solvable via [value sudoku](https://www.coinjoinsudoku.com/advisory/).\n\nWhich doesn't seem right to me.\n\nI came up with something I call a \"CoinJoin Jigsaw\". A \"CoinJoin Jigsaw\" is send-to-self coinjoin transaction in which every input is ambiguously associated with an output (i.e. every transaction input must belong to at least one subset of every output amount).\n\n\nFor simplicity I've used minizinc to model this. To make it clean, I decided to model as two users (affectionately called 'A' and 'B') who trust a common party to orchestrate the CoinJoin Jigsaw for them. A and B don't trust each other, so they want to get all their money atomically in this one transaction. We also want the \"CoinJoin Jigsaw\" to have exactly 2 outputs. One for A, and one for B. That way at first approximation it looks like a pretty standard bitcoin payment. (Of course the problem is substantially easier to solve if we allow A and B to have N outputs, but that creates an ugly transaction).\n\nWe also need to make sure that both A and B are paying a fee proportional to the amount of inputs they added, and the total transaction fee is satisfactory.\n\nSo I've modelled it as A and B provide their utxo to the orchestrater. The orchestrater will pick the largest subset of A's and B's utxo and such that satisfies our CoinJoin Jigsaw properties. I ended up copy-and-pasting a lot more than I'd like:\n\nhttps://gist.github.com/riperk/7be6698f291e865ad5c930d0edb0cd5a\n\nI'm not sure it has much practical utility, but it's kind of cool. Maybe."
            }
        ],
        "thread_summary": {
            "title": "CoinJoin Jigsaw",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Perkins"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1678
        }
    },
    {
        "title": "[bitcoin-dev] Improving Pre and Post Merging Abilities With Rewriting Core In Python",
        "thread_messages": [
            {
                "author": "Ahmer Regos",
                "date": "2019-04-23T08:16:28",
                "message_text_only": "I'm proposing re-writing bitcoin codebase in Python for improving pre and\npost merging abilities, faster operations and better understandability.\nPython is a fast language with C support, it is good with hashing things,\nit has a good syntax and everyone can read /  understand it unlike C++.\n\nI am willing the coordinate the transformation operation and i believe it\nwould be really good the get rid of C++.\n\n- Ahmer Regos from Regain Beaches.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/8cbd825a/attachment.html>"
            },
            {
                "author": "Achow101",
                "date": "2019-04-23T15:23:27",
                "message_text_only": "Feel free to re-implement Bitcoin Core in Python. It's open source software and you can do whatever you want.\n\nHowever Bitcoin Core is not going move to Python and rewrite everything in Python. Besides the fact that Python is far less efficient than C/C++, rewriting Bitcoin Core in any other language would be a huge undertaking and introduce many bugs for almost no benefit whatsoever. Bitcoin Core won't be changing languages for the entire codebase, but you are welcome to port it to Python yourself.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, April 23, 2019 4:16 AM, Ahmer Regos via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm proposing re-writing bitcoin codebase in Python for improving pre and post merging abilities, faster operations and better understandability. Python is a fast language with C support, it is good with hashing things, it has a good syntax and everyone can read /  understand it unlike C++.\n>\n> I am willing the coordinate the transformation operation and i believe it would be really good the get rid of C++.\n>\n> - Ahmer Regos from Regain Beaches.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/961583db/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-04-27T03:32:27",
                "message_text_only": "On Tue, Apr 23, 2019 at 03:23:27PM +0000, Achow101 via bitcoin-dev wrote:\n> Feel free to re-implement Bitcoin Core in Python. It's open source software and you can do whatever you want.\n> \n> However Bitcoin Core is not going move to Python and rewrite everything in Python. Besides the fact that Python is far less efficient than C/C++, rewriting Bitcoin Core in any other language would be a huge undertaking and introduce many bugs for almost no benefit whatsoever. Bitcoin Core won't be changing languages for the entire codebase, but you are welcome to port it to Python yourself.\n\nSpeaking as maintainer of the Python library python-bitcoinlib, I don't think\nusing Python for security critical codebases is a good idea. It's just too easy\nto make mistakes; I wouldn't recommend new projects use python-bitcoinlib.\n\nCurrently I'm doing 100% of my new projects on Rust. That's not to say Rust is\nthe only language usable for this kind of work. But it fits my style of\nprogramming well and the type system - esp good handling of immutability -\nappears to offer significant benefits.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/8c35d5c4/attachment.sig>"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2019-04-26T09:38:03",
                "message_text_only": "Bitcoin is a consensus critical system.\nWe have already had consensus problems between Bitcoin Core-versions,\nrewriting everything in another language would expose us to even greater\nrisks, and moving to a language like Python I see no benefit whatsoever.\n\nBest\nHampus\n\nDen tis 23 apr. 2019 kl 16:47 skrev Ahmer Regos via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> I'm proposing re-writing bitcoin codebase in Python for improving pre and\n> post merging abilities, faster operations and better understandability.\n> Python is a fast language with C support, it is good with hashing things,\n> it has a good syntax and everyone can read /  understand it unlike C++.\n>\n> I am willing the coordinate the transformation operation and i believe it\n> would be really good the get rid of C++.\n>\n> - Ahmer Regos from Regain Beaches.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/e356187c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Improving Pre and Post Merging Abilities With Rewriting Core In Python",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ahmer Regos",
                "Achow101",
                "Hampus Sj\u00f6berg",
                "Peter Todd"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 4539
        }
    },
    {
        "title": "[bitcoin-dev] Adding xpub field to PSBT to make multisig more secure",
        "thread_messages": [
            {
                "author": "Stepan Snigirev",
                "date": "2019-04-26T15:21:06",
                "message_text_only": "Hi list,\n\nI was looking at the bip174 PSBT specs, in particular for multisignature\nsetup, and I think with current spec there is a way to steal user funds in\nM of N setup with M \u2264 N/2.\n\nI made a small write-up on this:\nhttps://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md\n\nTo compress:\n\nCurrently in PSBT there is no way to reliably say if the output uses the\nkeys derived from the same root keys as the inputs aside from the key owned\nby the signer => there is no way to verify that the output is a change\noutput in multisig setup.\n\nTherefore an attacker can replace half of the keys in the change address by\nhis own keys and still get the transaction signed.\n\nI suggest to add an xpub field to the inputs and outputs metadata, then\nsigners can verify that the same xpubs are used for public keys in inputs\nand outputs => output is indeed a change.\n\nNormally change and receiving addresses are derived from the same xpub with\nnon-hardened derivation pathes, so providing xpub after the last hardened\nindex should be enough to see that public keys of inputs and change output\nare derived from the same xpub.\n\nI suggest to add the following key-value pairs to PSBT:\n\nType: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`\n- Key: derivation path for xpub\n  `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n- Value: 78-byte xpub value\n  `{xpub}`\n\nType: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`\n- Key: derivation path for xpub\n  `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n- Value: 78-byte xpub value\n  `{xpub}`\n\nDerivation paths are in the key of the key-value pair as they are used for\nlookup, and xpub itself is the actual value being looked up.\n\nI also want to mention that Trezor for example doesn't suffer from this\nproblem as they use xpubs to verify change outputs. So it may make sense to\ngo through the communication protocols of existing hardware /\nmultisignature wallets and see if there is something else we are missing.\n\nIf everyone is happy about the proposal I would prepare a pull request to\nthe bip.\n\nBest regards,\nStepan Snigirev.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/5201b537/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Adding xpub field to PSBT to make multisig more secure",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Stepan Snigirev"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2289
        }
    },
    {
        "title": "[bitcoin-dev] IsStandard",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-27T10:37:29",
                "message_text_only": "Maybe trivial question but asking here because I can't find anything\nclear (or updated) about it: is somewhere explained in details what txs\nare considered standard and non standard today without having to read\nthe core code?\n\nFor example, modification of multisig 2 of 3:\n\nscriptSig:\n\u00a0\u00a0\u00a0 OP_0\n\u00a0\u00a0\u00a0 OP_PUSHDATA sign1\n\u00a0\u00a0\u00a0 OP_PUSHDATA sign2\n\u00a0\u00a0\u00a0 OP_2\n\u00a0\u00a0\u00a0 OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG\n\u00a0\u00a0\u00a0\nscriptPubKey:\n\u00a0\u00a0\u00a0 OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3\nOP_CHECKMULTISIG) OP_EQUAL\n\nIs this standard? Are lightning txs standards ? etc"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-29T01:46:35",
                "message_text_only": "Good morning Aymeric,\n\nDifferent versions may consider different output scripts standard.\n\nYour rule of thumb, post-SegWit, should be:\n\n* If not P2PKH or P2WPKH, then wrap it in a P2SH or P2WSH.\n\nThere are more standard outputs accepted, but you can be reasonably sure that P2PKH, P2WPKH, P2SH, and P2WSH are the only standard output scripts that are likely to remain supported in the mid-future (5->10 years from 2019).\n\nLightning uses P2WSH for its scripts.\n\nAny m-of-n signing scheme in Bitcoin is P2SH (usually) or P2WSH (if you are cool).\n\n\nRegards,\nZmnSCPxj\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, April 27, 2019 6:37 PM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Maybe trivial question but asking here because I can't find anything\n> clear (or updated) about it: is somewhere explained in details what txs\n> are considered standard and non standard today without having to read\n> the core code?\n>\n> For example, modification of multisig 2 of 3:\n>\n> scriptSig:\n> \u00a0\u00a0\u00a0 OP_0\n> \u00a0\u00a0\u00a0 OP_PUSHDATA sign1\n> \u00a0\u00a0\u00a0 OP_PUSHDATA sign2\n> \u00a0\u00a0\u00a0 OP_2\n> \u00a0\u00a0\u00a0 OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG\n> \u00a0\u00a0\u00a0\n> scriptPubKey:\n> \u00a0\u00a0\u00a0 OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3\n> OP_CHECKMULTISIG) OP_EQUAL\n>\n> Is this standard? Are lightning txs standards ? etc\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-04-29T03:01:41",
                "message_text_only": "On Saturday 27 April 2019 10:37:29 Aymeric Vitte via bitcoin-dev wrote:\n> Maybe trivial question but asking here because I can't find anything\n> clear (or updated) about it: is somewhere explained in details what txs\n> are considered standard and non standard today without having to read\n> the core code?\n>\n> For example, modification of multisig 2 of 3:\n>\n> scriptSig:\n> \u00a0\u00a0\u00a0 OP_0\n> \u00a0\u00a0\u00a0 OP_PUSHDATA sign1\n> \u00a0\u00a0\u00a0 OP_PUSHDATA sign2\n> \u00a0\u00a0\u00a0 OP_2\n> \u00a0\u00a0\u00a0 OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG\n> \u00a0\u00a0\u00a0\n> scriptPubKey:\n> \u00a0\u00a0\u00a0 OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3\n> OP_CHECKMULTISIG) OP_EQUAL\n>\n> Is this standard? Are lightning txs standards ? etc\n\nThe name is confusing. It has little to do with standards, really.\nIsStandard is just one of the functions which implement the node's policy.\nIt allows many things for which there is no standard (eg, data carrier / \nOP_RETURN outputs), and can vary freely from node to node (either by \nconfigurable parameters, or by different/modified software) without breaking \nconsensus.\n\nAs it is a node-specific criteria, it is not itself even a possible *subject* \nfor standards.\n\nAdditionally, it should not be given much (if any) attention when defining new \nstandards. Just do what makes sense for the standard, and node policies can \nbe adapted around that.\n\nSo, overall, there's limited use case for documenting this beyond the code.\nIt makes far more sense to document actual standards instead.\n\nLuke"
            },
            {
                "author": "Marco Falke",
                "date": "2019-04-29T17:27:29",
                "message_text_only": "There is not a single document that describes what is standard and\nwhat is not. Transaction relay policy (including minimum relay fees)\nmay change over time, across different implementations or different\nversions of the same implementation.\n\nGenerally you can assume that commonly used scripts that are standard\ntoday remain standard. To test if a script is standard and accepted by\ncurrent relay policy of a Bitcoin Core node, you can create a tx that\nspends from it on mainnet or on testnet and see if it is accepted to\nthe mempool of your local node. Make sure to disable\n-acceptnonstdtxn=0 on testnet.\n\nShould the standardness-rules of a script type ever change, it will be\nannounced and discussed on this mailing list.\n\nAnd of course, lightning transactions are standard as they otherwise\nwouldn't propagate.\n\nBest,\nMarco\n\nOn Sun, Apr 28, 2019 at 9:06 PM Aymeric Vitte via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Maybe trivial question but asking here because I can't find anything\n> clear (or updated) about it: is somewhere explained in details what txs\n> are considered standard and non standard today without having to read\n> the core code?\n>\n> For example, modification of multisig 2 of 3:\n>\n> scriptSig:\n>     OP_0\n>     OP_PUSHDATA sign1\n>     OP_PUSHDATA sign2\n>     OP_2\n>     OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG\n>\n> scriptPubKey:\n>     OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3\n> OP_CHECKMULTISIG) OP_EQUAL\n>\n> Is this standard? Are lightning txs standards ? etc\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-29T09:30:39",
                "message_text_only": "ZmnSCPxj, OK, but you can put whatever you like in the different\nstandard output script you mention (my example below whether legacy or\nsegwit)\n\nLuke, I am still confused or missing something, from your answer I\nunderstand that everything is accepted, so if we take the past example\nof bch coins wrongly sent to a segwit address, why was the recovery\nsolution where scriptsig included the matching segwit address/program\nnot a standard transaction?\n\nLe 29/04/2019 \u00e0 05:01, Luke Dashjr a \u00e9crit\u00a0:\n> On Saturday 27 April 2019 10:37:29 Aymeric Vitte via bitcoin-dev wrote:\n>> Maybe trivial question but asking here because I can't find anything\n>> clear (or updated) about it: is somewhere explained in details what txs\n>> are considered standard and non standard today without having to read\n>> the core code?\n>>\n>> For example, modification of multisig 2 of 3:\n>>\n>> scriptSig:\n>> \u00a0\u00a0\u00a0 OP_0\n>> \u00a0\u00a0\u00a0 OP_PUSHDATA sign1\n>> \u00a0\u00a0\u00a0 OP_PUSHDATA sign2\n>> \u00a0\u00a0\u00a0 OP_2\n>> \u00a0\u00a0\u00a0 OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG\n>> \u00a0\u00a0\u00a0\n>> scriptPubKey:\n>> \u00a0\u00a0\u00a0 OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3\n>> OP_CHECKMULTISIG) OP_EQUAL\n>>\n>> Is this standard? Are lightning txs standards ? etc\n> The name is confusing. It has little to do with standards, really.\n> IsStandard is just one of the functions which implement the node's policy.\n> It allows many things for which there is no standard (eg, data carrier / \n> OP_RETURN outputs), and can vary freely from node to node (either by \n> configurable parameters, or by different/modified software) without breaking \n> consensus.\n>\n> As it is a node-specific criteria, it is not itself even a possible *subject* \n> for standards.\n>\n> Additionally, it should not be given much (if any) attention when defining new \n> standards. Just do what makes sense for the standard, and node policies can \n> be adapted around that.\n>\n> So, overall, there's limited use case for documenting this beyond the code.\n> It makes far more sense to document actual standards instead.\n>\n> Luke\n\ns"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-04-30T04:29:18",
                "message_text_only": "Good morning Aymeric,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, April 29, 2019 5:30 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n\n> ZmnSCPxj, OK, but you can put whatever you like in the different\n> standard output script you mention (my example below whether legacy or\n> segwit)\n>\n\nI am uncertain what you mean by this.\n\nFor P2PKH and P2WPKH, you must present a hash of a public key.\nYou cannot present a hash of anything else.\n\nThe P2PKH template can be interpreted as a script, but is actually recognized as a template by most current nodes (in a way that is consistent with interpreting it as a script).\n\nFor P2SH and P2WSH, you must present a hash of a script.\n\nIt is more helpful to consider that *today* nodes recognize particular patterns (P2PKH, P2WPKH, P2SH, P2WSH) as templates and not as scripts to be executed.\n\nIn any case, if you want to make anything more complicated than \"single signer\" you should use P2SH or P2WSH regardless, and give your script.\nIf you want to assure somebody that a particular P2SH or P2WSH commits to a particular policy, just expose the policy script to them and have them (i.e. their client software) verify that the policy is what the user wants and that when hashed it matches the P2SH/P2WSH.\n\nAs Luke said, nodes can have any policy for propagating transactions.\nHowever it is generally expected that P2PKH, P2WPKH, P2SH, and P2WSH will be propagated by a majority of nodes, if only because those are reliably \"passed\" by `isStandard` in the default latest Bitcoin Core and most people will not modify the Core code.\n\nGenerally, anything that isn't P2PKH, P2WPKH, P2SH, or P2WSH will not likely be propagated by the network.\nYou *could* still coordinate with one or more miners to get it mined: you can put anything in the block, it is simply that most nodes will not inform miners about transactions that do not pay out to P2PKH, P2WPKH, P2SH, or P2WSH.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-04-30T09:43:27",
                "message_text_only": "I must badly explain my point (or just wondering things that do not\nexist finally), the question is indeed whether nodes will relay non\nusual transactions or not and how to know what they will accept or not:\n\n- my modified multisig 2 of 3: I did put OP_2 out of the usual redeem\nscript, the redeem script still matches scriptpubkey and scriptsig will\nexecute succesfully, that's a normal legacy P2SH or segwit P2WSH\n\n- bch segwit recovery: it's a p2sh transaction without any signature\nverification, as far as I remember there was a story that it could not\npropagate in the network (even taking the risk to be stolen) and that\npeople had to contact a (honest) miner\n\n- sha bounties: same as above, p2sh transactions without signatures\n\netc\n\nWill all of those transactions propagate normally? And then the rule is\njust that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates\nwhatever scripts you put inside?\n\nLe 30/04/2019 \u00e0 06:29, ZmnSCPxj a \u00e9crit\u00a0:\n> Good morning Aymeric,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, April 29, 2019 5:30 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>\n>> ZmnSCPxj, OK, but you can put whatever you like in the different\n>> standard output script you mention (my example below whether legacy or\n>> segwit)\n>>\n> I am uncertain what you mean by this.\n>\n> For P2PKH and P2WPKH, you must present a hash of a public key.\n> You cannot present a hash of anything else.\n>\n> The P2PKH template can be interpreted as a script, but is actually recognized as a template by most current nodes (in a way that is consistent with interpreting it as a script).\n>\n> For P2SH and P2WSH, you must present a hash of a script.\n>\n> It is more helpful to consider that *today* nodes recognize particular patterns (P2PKH, P2WPKH, P2SH, P2WSH) as templates and not as scripts to be executed.\n>\n> In any case, if you want to make anything more complicated than \"single signer\" you should use P2SH or P2WSH regardless, and give your script.\n> If you want to assure somebody that a particular P2SH or P2WSH commits to a particular policy, just expose the policy script to them and have them (i.e. their client software) verify that the policy is what the user wants and that when hashed it matches the P2SH/P2WSH.\n>\n> As Luke said, nodes can have any policy for propagating transactions.\n> However it is generally expected that P2PKH, P2WPKH, P2SH, and P2WSH will be propagated by a majority of nodes, if only because those are reliably \"passed\" by `isStandard` in the default latest Bitcoin Core and most people will not modify the Core code.\n>\n> Generally, anything that isn't P2PKH, P2WPKH, P2SH, or P2WSH will not likely be propagated by the network.\n> You *could* still coordinate with one or more miners to get it mined: you can put anything in the block, it is simply that most nodes will not inform miners about transactions that do not pay out to P2PKH, P2WPKH, P2SH, or P2WSH.\n>\n> Regards,\n> ZmnSCPxj\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            }
        ],
        "thread_summary": {
            "title": "IsStandard",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Luke Dashjr",
                "Aymeric Vitte",
                "Marco Falke"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 12877
        }
    }
]