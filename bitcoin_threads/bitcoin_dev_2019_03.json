[
    {
        "title": "[bitcoin-dev] Mailing list downtime, archive, and its future",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2019-03-06T00:34:05",
                "message_text_only": "Hi all,\n\nJust fyi, but this bitcoin-dev mailing list has been down for a few weeks.\nIt's currently hosted by Linux Foundation, and they are slowly deprecating\ntheir support for email. We will have to find an alternative service\nprovider for the mailing list moving forward. I have received a variety of\nrecommendations for how to move forward.\n\nMy one reservation in this process is that I am concerned about the\nsubscriber list and I am not sure how we want to treat this. I view this as\na possible privacy issue. For example, if we were to migrate to a new\nmailing list, it's important that list subscribers are not disclosed. At\nthe same time, some people rely on this mailing list for important\nannouncements maybe even security announcements in some situations. I'd\nappreciate feedback on what people think about this particular issue. Since\nthe mailing list is not reliable anymore, please remember to cc the\nfeedback to me directly.\n\nIn the mean time, here is an archive of the mailing list content including\nsome old timestamps in the opentimestamps format for some of the older\ncontent:\nhttp://diyhpl.us/~bryan/irc/bitcoin/bitcoin-dev/bitcoin-dev-mailing-list-archive-2019-03-05.zip\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190305/e1668bb5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mailing list downtime, archive, and its future",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1419
        }
    },
    {
        "title": "[bitcoin-dev] Removal of reject network messages from Bitcoin Core (BIP61)",
        "thread_messages": [
            {
                "author": "Marco Falke",
                "date": "2019-03-06T00:53:18",
                "message_text_only": "Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n\"version\" messages from a network peer when the message could not be accepted.\n\nThis feature is toggled by the `-enablebip61` command line option and has been\ndisabled by default since Bitcoin Core version 0.18.0 (not yet released as of\ntime of writing). Nodes on the network can not generally be trusted to send\nvalid (\"reject\") messages, so this should only ever be used when connected to a\ntrusted node. At this time, I am not aware of any software that requires this\nfeature, and I would like to remove if from Bitcoin Core to make the codebase\nslimmer, easier to understand and maintain. Let us know if your application\nrelies on this feature and you can not use any of the recommended alternatives:\n\n* Testing or debugging of implementations of the Bitcoin P2P network protocol\n  should be done by inspecting the log messages that are produced by a recent\n  version of Bitcoin Core. Bitcoin Core logs debug messages\n  (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n  (`-debuglogfile=<debug.log>`).\n\n* Testing the validity of a block can be achieved by specific RPCs:\n  - `submitblock`\n  - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n    potentially invalid POW\n\n* Testing the validity of a transaction can be achieved by specific RPCs:\n  - `sendrawtransaction`\n  - `testmempoolaccept`\n\n* Wallets should not use the absence of \"reject\" messages to indicate a\n  transaction has propagated the network, nor should wallets use \"reject\"\n  messages to set transaction fees. Wallets should rather use fee estimation\n  to determine transaction fees and set replace-by-fee if desired. Thus, they\n  could wait until the transaction has confirmed (taking into account the fee\n  target they set (compare the RPC `estimatesmartfee`)) or listen for the\n  transaction announcement by other network peers to check for propagation.\n\nI propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless there are\nvalid concerns about its removal.\n\nMarco"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-03-06T04:00:35",
                "message_text_only": "The reject message is helpful for figuring out why a tx was rejected.\n\nIt\u2019s not useful for determining success, yes. Particularly when doing\nsegwit / newer types of tx\u2019s as there\u2019s always one or more pesky nodes who\nstill don\u2019t support it and send a reject message for perfectly good tx\u2019s.\n\nBut after a delay where you haven\u2019t seen your tx propagated on the network,\nit\u2019s useful to know *why* it failed.\n\nWhat would be nice is actually expanding this error message. Currently with\nRBF tx\u2019s \u201cfee too small\u201d is sent for both original transactions as well as\nreplacement transactions. So a bug accidentally sending spent txos\n(currently in mempool) says \u201cfee too small\u201d instead of something more\nappropriate like \u201cfee too small to supersede existing unconfirmed\ntransaction.\u201d\n\nOn Tue, Mar 5, 2019 at 7:26 PM Marco Falke via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n> \"version\" messages from a network peer when the message could not be\n> accepted.\n>\n> This feature is toggled by the `-enablebip61` command line option and has\n> been\n> disabled by default since Bitcoin Core version 0.18.0 (not yet released as\n> of\n> time of writing). Nodes on the network can not generally be trusted to send\n> valid (\"reject\") messages, so this should only ever be used when connected\n> to a\n> trusted node. At this time, I am not aware of any software that requires\n> this\n> feature, and I would like to remove if from Bitcoin Core to make the\n> codebase\n> slimmer, easier to understand and maintain. Let us know if your application\n> relies on this feature and you can not use any of the recommended\n> alternatives:\n>\n> * Testing or debugging of implementations of the Bitcoin P2P network\n> protocol\n>   should be done by inspecting the log messages that are produced by a\n> recent\n>   version of Bitcoin Core. Bitcoin Core logs debug messages\n>   (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n>   (`-debuglogfile=<debug.log>`).\n>\n> * Testing the validity of a block can be achieved by specific RPCs:\n>   - `submitblock`\n>   - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n>     potentially invalid POW\n>\n> * Testing the validity of a transaction can be achieved by specific RPCs:\n>   - `sendrawtransaction`\n>   - `testmempoolaccept`\n>\n> * Wallets should not use the absence of \"reject\" messages to indicate a\n>   transaction has propagated the network, nor should wallets use \"reject\"\n>   messages to set transaction fees. Wallets should rather use fee\n> estimation\n>   to determine transaction fees and set replace-by-fee if desired. Thus,\n> they\n>   could wait until the transaction has confirmed (taking into account the\n> fee\n>   target they set (compare the RPC `estimatesmartfee`)) or listen for the\n>   transaction announcement by other network peers to check for propagation.\n>\n> I propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless\n> there are\n> valid concerns about its removal.\n>\n> Marco\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190305/bf105368/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2019-03-06T16:49:20",
                "message_text_only": "Reject messages cannot be replaced for debugging user problems. At least\nunless you plan to make RPC or bitcoind logfiles available via the P2P\nprotocol (both probably not a good idea).\n\nThe typical case is, I get mailed a wallet logfile with reject messages\nand that's all I have. I cannot access the bitcoind logfile(s) of the\nnode(s) that generated the reject message in the first place. Nor can I\naccess their RPC interface.\n\nI strongly suggest re-enabling reject messages by default before 0.18.\n\n\nOn 06/03/2019 01.53, Marco Falke via bitcoin-dev wrote:\n> Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n> \"version\" messages from a network peer when the message could not be accepted.\n> \n> This feature is toggled by the `-enablebip61` command line option and has been\n> disabled by default since Bitcoin Core version 0.18.0 (not yet released as of\n> time of writing). Nodes on the network can not generally be trusted to send\n> valid (\"reject\") messages, so this should only ever be used when connected to a\n> trusted node. At this time, I am not aware of any software that requires this\n> feature, and I would like to remove if from Bitcoin Core to make the codebase\n> slimmer, easier to understand and maintain. Let us know if your application\n> relies on this feature and you can not use any of the recommended alternatives:\n> \n> * Testing or debugging of implementations of the Bitcoin P2P network protocol\n>   should be done by inspecting the log messages that are produced by a recent\n>   version of Bitcoin Core. Bitcoin Core logs debug messages\n>   (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n>   (`-debuglogfile=<debug.log>`).\n> \n> * Testing the validity of a block can be achieved by specific RPCs:\n>   - `submitblock`\n>   - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n>     potentially invalid POW\n> \n> * Testing the validity of a transaction can be achieved by specific RPCs:\n>   - `sendrawtransaction`\n>   - `testmempoolaccept`\n> \n> * Wallets should not use the absence of \"reject\" messages to indicate a\n>   transaction has propagated the network, nor should wallets use \"reject\"\n>   messages to set transaction fees. Wallets should rather use fee estimation\n>   to determine transaction fees and set replace-by-fee if desired. Thus, they\n>   could wait until the transaction has confirmed (taking into account the fee\n>   target they set (compare the RPC `estimatesmartfee`)) or listen for the\n>   transaction announcement by other network peers to check for propagation.\n> \n> I propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless there are\n> valid concerns about its removal.\n> \n> Marco\n>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2019-03-07T13:59:47",
                "message_text_only": "Can you elaborate a bit on what kind of reject messages your users are getting? I assume the users wallet connects directly to the Bitcoin p2p network?\n\nWhat does the wallet do when a transaction is rejected? Does it forget about it (that seems unsafe) or compose another one (with overlapping inputs)?\n\nSjors\n\n> Op 6 mrt. 2019, om 17:49 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> Reject messages cannot be replaced for debugging user problems. At least\n> unless you plan to make RPC or bitcoind logfiles available via the P2P\n> protocol (both probably not a good idea).\n> \n> The typical case is, I get mailed a wallet logfile with reject messages\n> and that's all I have. I cannot access the bitcoind logfile(s) of the\n> node(s) that generated the reject message in the first place. Nor can I\n> access their RPC interface.\n> \n> I strongly suggest re-enabling reject messages by default before 0.18.\n> \n> \n> On 06/03/2019 01.53, Marco Falke via bitcoin-dev wrote:\n>> Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n>> \"version\" messages from a network peer when the message could not be accepted.\n>> \n>> This feature is toggled by the `-enablebip61` command line option and has been\n>> disabled by default since Bitcoin Core version 0.18.0 (not yet released as of\n>> time of writing). Nodes on the network can not generally be trusted to send\n>> valid (\"reject\") messages, so this should only ever be used when connected to a\n>> trusted node. At this time, I am not aware of any software that requires this\n>> feature, and I would like to remove if from Bitcoin Core to make the codebase\n>> slimmer, easier to understand and maintain. Let us know if your application\n>> relies on this feature and you can not use any of the recommended alternatives:\n>> \n>> * Testing or debugging of implementations of the Bitcoin P2P network protocol\n>>  should be done by inspecting the log messages that are produced by a recent\n>>  version of Bitcoin Core. Bitcoin Core logs debug messages\n>>  (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n>>  (`-debuglogfile=<debug.log>`).\n>> \n>> * Testing the validity of a block can be achieved by specific RPCs:\n>>  - `submitblock`\n>>  - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n>>    potentially invalid POW\n>> \n>> * Testing the validity of a transaction can be achieved by specific RPCs:\n>>  - `sendrawtransaction`\n>>  - `testmempoolaccept`\n>> \n>> * Wallets should not use the absence of \"reject\" messages to indicate a\n>>  transaction has propagated the network, nor should wallets use \"reject\"\n>>  messages to set transaction fees. Wallets should rather use fee estimation\n>>  to determine transaction fees and set replace-by-fee if desired. Thus, they\n>>  could wait until the transaction has confirmed (taking into account the fee\n>>  target they set (compare the RPC `estimatesmartfee`)) or listen for the\n>>  transaction announcement by other network peers to check for propagation.\n>> \n>> I propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless there are\n>> valid concerns about its removal.\n>> \n>> Marco\n>> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2019-03-07T17:58:01",
                "message_text_only": "Yes, I'm talking about P2P connections.\n\nFirst and foremost, reject messages are an indication that the\ntransaction isn't going to confirm. Without these messages, we'd need to\nrevert to pre-BIP61 behaviour of using a timeout for reception of\nnetwork confirmations.\n\nRegarding the content, these cases are useful to distinguish:\n\n- Not enough fee\n- UTXO already spent\n- Tx validity/standardness (e.g. invalid signature)\n\nWhile the last one in theority wouldn't be necessary if you produced\nyour software bug-free to begin with, this just isn't how software\ndevelopment works. Developers need any indication they can get.\n\nThe first two happen even in the ideal case. Fees are impossible to\npredict, and unintentional double spends happen because users clone\ntheir wallet state.\n\n\nOn 07/03/2019 14.59, Sjors Provoost via bitcoin-dev wrote:\n> Can you elaborate a bit on what kind of reject messages your users are getting? I assume the users wallet connects directly to the Bitcoin p2p network?\n> \n> What does the wallet do when a transaction is rejected? Does it forget about it (that seems unsafe) or compose another one (with overlapping inputs)?\n> \n> Sjors\n> \n>> Op 6 mrt. 2019, om 17:49 heeft Andreas Schildbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n>>\n>> Reject messages cannot be replaced for debugging user problems. At least\n>> unless you plan to make RPC or bitcoind logfiles available via the P2P\n>> protocol (both probably not a good idea).\n>>\n>> The typical case is, I get mailed a wallet logfile with reject messages\n>> and that's all I have. I cannot access the bitcoind logfile(s) of the\n>> node(s) that generated the reject message in the first place. Nor can I\n>> access their RPC interface.\n>>\n>> I strongly suggest re-enabling reject messages by default before 0.18.\n>>\n>>\n>> On 06/03/2019 01.53, Marco Falke via bitcoin-dev wrote:\n>>> Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n>>> \"version\" messages from a network peer when the message could not be accepted.\n>>>\n>>> This feature is toggled by the `-enablebip61` command line option and has been\n>>> disabled by default since Bitcoin Core version 0.18.0 (not yet released as of\n>>> time of writing). Nodes on the network can not generally be trusted to send\n>>> valid (\"reject\") messages, so this should only ever be used when connected to a\n>>> trusted node. At this time, I am not aware of any software that requires this\n>>> feature, and I would like to remove if from Bitcoin Core to make the codebase\n>>> slimmer, easier to understand and maintain. Let us know if your application\n>>> relies on this feature and you can not use any of the recommended alternatives:\n>>>\n>>> * Testing or debugging of implementations of the Bitcoin P2P network protocol\n>>>  should be done by inspecting the log messages that are produced by a recent\n>>>  version of Bitcoin Core. Bitcoin Core logs debug messages\n>>>  (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n>>>  (`-debuglogfile=<debug.log>`).\n>>>\n>>> * Testing the validity of a block can be achieved by specific RPCs:\n>>>  - `submitblock`\n>>>  - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n>>>    potentially invalid POW\n>>>\n>>> * Testing the validity of a transaction can be achieved by specific RPCs:\n>>>  - `sendrawtransaction`\n>>>  - `testmempoolaccept`\n>>>\n>>> * Wallets should not use the absence of \"reject\" messages to indicate a\n>>>  transaction has propagated the network, nor should wallets use \"reject\"\n>>>  messages to set transaction fees. Wallets should rather use fee estimation\n>>>  to determine transaction fees and set replace-by-fee if desired. Thus, they\n>>>  could wait until the transaction has confirmed (taking into account the fee\n>>>  target they set (compare the RPC `estimatesmartfee`)) or listen for the\n>>>  transaction announcement by other network peers to check for propagation.\n>>>\n>>> I propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless there are\n>>> valid concerns about its removal.\n>>>\n>>> Marco\n>>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-08T00:52:56",
                "message_text_only": "On Thu, Mar 7, 2019 at 11:46 PM Andreas Schildbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> First and foremost, reject messages are an indication that the\n> transaction isn't going to confirm. Without these messages, we'd need to\n> revert to pre-BIP61 behaviour of using a timeout for reception of\n> network confirmations.\n\nThat is already required because even in the presence of perfectly\nhonest and cooperative hosts reject messages at most can only tell you\nabout first-hop behaviour. It won't even tell you if the transaction\nwas ever even attempted to be sent to a next hop.  So alternative\nhandling must be provided and must be reliable for the software to\nwork at all regardless of reject messages.\n\n> - Not enough fee\n\nRejection on low fee (over the static minimum feerate) only happens at\nthe point where the nodes mempool is full, which is already at a point\nwhere you might be waiting weeks for confirmation.\n\nRejection causes were also not stable or reliable because the validity\ncriteria cannot generally be tested independently. For example, if a\ntransaction is queued due to missing a parent it isn't rejected\nbecause missing the parent is often a temporary issue, but its feerate\ncannot be measured without the parent. Later, when the parent is\nobtained, the transaction can then be rejected due to feerate-- but no\nreject is sent then.\n\nOutput already spend is often completely indistinguishable from a\nmissing parent and can't get rejects generated for it generally.\n\nSimilarly, the error state detected for things like invalid signatures\nare often not very useful. The software knows that script execution\nreturned false, but in the general case _why_ it returned false is not\nclear, and a straightforward high performance validation\nimplementation doesn't necessarily yield a good way of figuring out\nand propagating up that information.  (I think invalid signatures end\nup returning a stack-nonempty state from validation currently, as an\nexample of that)."
            },
            {
                "author": "Andreas Schildbach",
                "date": "2019-03-12T17:08:52",
                "message_text_only": "(Posting again, since my previous reply didn't appear)\n\n\nOn 08/03/2019 01.52, Gregory Maxwell via bitcoin-dev wrote:\n\n> That is already required because even in the presence of perfectly\n> honest and cooperative hosts reject messages at most can only tell you\n> about first-hop behaviour. It won't even tell you if the transaction\n> was ever even attempted to be sent to a next hop.  So alternative\n> handling must be provided and must be reliable for the software to\n> work at all regardless of reject messages.\n>\n> Rejection causes were also not stable or reliable because the validity\n> criteria cannot generally be tested independently. For example, if a\n> transaction is queued due to missing a parent it isn't rejected\n> because missing the parent is often a temporary issue, but its feerate\n> cannot be measured without the parent. Later, when the parent is\n> obtained, the transaction can then be rejected due to feerate-- but no\n> reject is sent then.\n\nThese two cases are understood and handled by current code. Generally\nthe idea is take reject messages serious, but don't overrate the lack\nof. Luckily, network confirmations fill the gap. (Yes, a timeout is\nstill useful. But at least it almost never happens.)\n\n> Similarly, the error state detected for things like invalid signatures\n> are often not very useful. The software knows that script execution\n> returned false, but in the general case _why_ it returned false is not\n> clear, and a straightforward high performance validation\n> implementation doesn't necessarily yield a good way of figuring out\n> and propagating up that information.  (I think invalid signatures end\n> up returning a stack-nonempty state from validation currently, as an\n> example of that).\n\nNevertheless, it has been proven as useful in debugging (just recently\nwhen I implemented the witness signature hash in bitcoinj). I think\nWilmer Paulino summed up this point quite nicely in his reply to this\nthread."
            },
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-12T22:14:10",
                "message_text_only": "On Tue, Mar 12, 2019 at 7:45 PM Andreas Schildbach via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> These two cases are understood and handled by current code. Generally\n> the idea is take reject messages serious, but don't overrate the lack\n> of. Luckily, network confirmations fill the gap. (Yes, a timeout is\n\nI'd like to better understand this, but it would be easier to just\nread the code than ask a bunch of questions. I tried looking for the\nhandling of reject messages in Android  Bitcoin Wallet and BitcoinJ\nand didn't really find and handling other than logging exceptions.\nWould you mind giving me a couple pointers to where in the code\nthey're handled?"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2019-03-13T14:29:43",
                "message_text_only": "On 12/03/2019 23.14, Gregory Maxwell via bitcoin-dev wrote:\n> On Tue, Mar 12, 2019 at 7:45 PM Andreas Schildbach via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> These two cases are understood and handled by current code. Generally\n>> the idea is take reject messages serious, but don't overrate the lack\n>> of. Luckily, network confirmations fill the gap. (Yes, a timeout is\n> \n> I'd like to better understand this, but it would be easier to just\n> read the code than ask a bunch of questions. I tried looking for the\n> handling of reject messages in Android  Bitcoin Wallet and BitcoinJ\n> and didn't really find and handling other than logging exceptions.\n> Would you mind giving me a couple pointers to where in the code\n> they're handled?\n\nIt's implemented in bitcoinj's TransactionBroadcast class. Received\nreject messages are collected and -- if a certain consensus (currently:\nhalf of connected peers) is reached -- a RejectedTransactionException is\nraised.\n\nThe handling of that exception in Bitcoin Wallet is extremely\nrudimentary. I think it still only shows the exception message. But\ncertainly I was hoping to improve on this soon."
            },
            {
                "author": "Oscar Guindzberg",
                "date": "2019-03-13T14:41:50",
                "message_text_only": "> I'd like to better understand this, but it would be easier to just\n> read the code than ask a bunch of questions. I tried looking for the\n> handling of reject messages in Android  Bitcoin Wallet and BitcoinJ\n> and didn't really find and handling other than logging exceptions.\n> Would you mind giving me a couple pointers to where in the code\n> they're handled?\n\nhttps://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java#L93-L108"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-03-13T22:30:44",
                "message_text_only": "I\u2019ve solved the same problem in a different way.\n\n1) Submit a transaction\n2) Collect all reject messages (that have matching txid in the reject data)\n3) Wait 16 seconds after first error message received (chosen semirandomly\nfrom trial and error) before processing errors\n4) Wait for our txid to be submitted back to us through the mempool, if we\nget it notify success and delete all pending error events\n5) Signal failure with the given reject code if present (after the 16\nseconds have elapsed)\n6) If no error or success after 20 seconds, signal timeout failure\n\nThis works fairly well in testing. Newer transaction types seem to generate\nreject codes 100% of the time (from at least one node when sending to 4\nnodes) so this culling / time delay approach is essentially required.\n\nOn a related note: One issue is that RBF attempts with too small a fee and\naccidental double spends (with enough fee for 1 tx but not a RBF) both\ngenerate the same reject code: not enough fee.\n\nA new reject code for RBF based too small of fee would definitely make for\na better user experience as I\u2019ve seen this exact problem create confusion\nfor users.\n\nRemoving reject codes would make for a much worse user experience. \u201cYour tx\nfailed and we have no idea why\u201d would be the only message and it would\nrequire waiting for a full timeout.\n\nOn Wed, Mar 13, 2019 at 3:16 PM Oscar Guindzberg via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > I'd like to better understand this, but it would be easier to just\n> > read the code than ask a bunch of questions. I tried looking for the\n> > handling of reject messages in Android  Bitcoin Wallet and BitcoinJ\n> > and didn't really find and handling other than logging exceptions.\n> > Would you mind giving me a couple pointers to where in the code\n> > they're handled?\n>\n>\n> https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java#L93-L108\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190313/29d5abf3/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-03-14T09:46:28",
                "message_text_only": "Apparently I don't have the same experience than others here, what I\nencountered is no reject message received for wrong txs, but from what I\nunderstand here it's not unusual to receive reject message for valid\ntxs, then I don't see how it can be really helpful/relied, given also\nthat the reject messages are unclear and even can be misleading\n\nAs it was written already I found it useful only for debugging purposes,\nat least it can give some kind of ideas about what happened,\nbitcoin-transactions is implementing the bitcoin protocol but does not\nact as a node and does not pretend to fake a node behavior waiting for\nexample to get the tx back, is the method of sending a getdata for a\ngiven tx to see if it was accepted by a node wrong ? It can't guarantee\n100% that it was successful and will propagate but I see that you are\ndoing completely different things\n\nLe 13/03/2019 \u00e0 23:30, Dustin Dettmer via bitcoin-dev a \u00e9crit\u00a0:\n> I\u2019ve solved the same problem in a different way.\n>\n> 1) Submit a transaction\n> 2) Collect all reject messages (that have matching txid in the reject\n> data)\n> 3) Wait 16 seconds after first error message received (chosen\n> semirandomly from trial and error) before processing errors\n> 4) Wait for our txid to be submitted back to us through the mempool,\n> if we get it notify success and delete all pending error events\n> 5) Signal failure with the given reject code if present (after the 16\n> seconds have elapsed)\n> 6) If no error or success after 20 seconds, signal timeout failure\n>\n> This works fairly well in testing. Newer transaction types seem to\n> generate reject codes 100% of the time (from at least one node when\n> sending to 4 nodes) so this culling / time delay approach is\n> essentially required.\n>\n> On a related note: One issue is that RBF attempts with too small a fee\n> and accidental double spends (with enough fee for 1 tx but not a RBF)\n> both generate the same reject code: not enough fee.\n>\n> A new reject code for RBF based too small of fee would definitely make\n> for a better user experience as I\u2019ve seen this exact problem create\n> confusion for users.\n>\n> Removing reject codes would make for a much worse user experience.\n> \u201cYour tx failed and we have no idea why\u201d would be the only message and\n> it would require waiting for a full timeout.\n>\n> On Wed, Mar 13, 2019 at 3:16 PM Oscar Guindzberg via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     > I'd like to better understand this, but it would be easier to just\n>     > read the code than ask a bunch of questions. I tried looking for the\n>     > handling of reject messages in Android\u00a0 Bitcoin Wallet and BitcoinJ\n>     > and didn't really find and handling other than logging exceptions.\n>     > Would you mind giving me a couple pointers to where in the code\n>     > they're handled?\n>\n>     https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/TransactionBroadcast.java#L93-L108\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190314/49975469/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-03-07T20:52:33",
                "message_text_only": "Bitcoin-transactions did use this \"feature\", but does not rely on it any\nlonger since I observed some strange behavior sometimes (no reject\nmessage for bad tx, with suprnova for example as far as I remember),\nthen it doublechecks using getdata to see if the tx is in mempool\n\nIndeed you can't trust what a node tells you with or without reject\n(idem for getdata but more difficult to fake and better than nothing)\n\nThen I don't see any problem to remove it, taking into account also that\nthe error message is too vague to be really helpful\nhttps://github.com/bitcoin/bitcoin/issues/11891\n\nLe 06/03/2019 \u00e0 01:53, Marco Falke via bitcoin-dev a \u00e9crit\u00a0:\n> Bitcoin Core may send \"reject\" messages as response to \"tx\", \"block\" or\n> \"version\" messages from a network peer when the message could not be accepted.\n>\n> This feature is toggled by the `-enablebip61` command line option and has been\n> disabled by default since Bitcoin Core version 0.18.0 (not yet released as of\n> time of writing). Nodes on the network can not generally be trusted to send\n> valid (\"reject\") messages, so this should only ever be used when connected to a\n> trusted node. At this time, I am not aware of any software that requires this\n> feature, and I would like to remove if from Bitcoin Core to make the codebase\n> slimmer, easier to understand and maintain. Let us know if your application\n> relies on this feature and you can not use any of the recommended alternatives:\n>\n> * Testing or debugging of implementations of the Bitcoin P2P network protocol\n>   should be done by inspecting the log messages that are produced by a recent\n>   version of Bitcoin Core. Bitcoin Core logs debug messages\n>   (`-debug=<category>`) to a stream (`-printtoconsole`) or to a file\n>   (`-debuglogfile=<debug.log>`).\n>\n> * Testing the validity of a block can be achieved by specific RPCs:\n>   - `submitblock`\n>   - `getblocktemplate` with `'mode'` set to `'proposal'` for blocks with\n>     potentially invalid POW\n>\n> * Testing the validity of a transaction can be achieved by specific RPCs:\n>   - `sendrawtransaction`\n>   - `testmempoolaccept`\n>\n> * Wallets should not use the absence of \"reject\" messages to indicate a\n>   transaction has propagated the network, nor should wallets use \"reject\"\n>   messages to set transaction fees. Wallets should rather use fee estimation\n>   to determine transaction fees and set replace-by-fee if desired. Thus, they\n>   could wait until the transaction has confirmed (taking into account the fee\n>   target they set (compare the RPC `estimatesmartfee`)) or listen for the\n>   transaction announcement by other network peers to check for propagation.\n>\n> I propose to remove \"reject\" messages from Bitcoin Core 0.19.0 unless there are\n> valid concerns about its removal.\n>\n> Marco\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Wilmer Paulino",
                "date": "2019-03-08T00:09:01",
                "message_text_only": "Hi Marco,\n\n> At this time, I am not aware of any software that requires this feature, and I\n> would like to remove if from Bitcoin Core to make the codebase slimmer, easier\n> to understand and maintain.\n\nNeutrino[1], a light client implementation that uses BIPs 157 and 158,\ncurrently relies on receiving reject messages from its peers when broadcasting\na transaction to the network. I've personally gone through the relevant parts\nof the Bitcoin Core codebase involving reject messages and respectfully\ndisagree that removing it would help much in terms of comprehension and\nmaintainability. IMO, the benefits outweigh this small cost.\n\n> Nodes on the network can not generally be trusted to send valid (\"reject\")\n> messages, so this should only ever be used when connected to a trusted node.\n\nNodes in the network generally rely on the assumption that they are connected\nto at least one honest peer, so we can actually converge on the set of honest\npeers and ban/disconnect any who send an invalid reject message for a valid\ntransaction.\n\n> Let us know if your application relies on this feature and you can not use any\n> of the recommended alternatives:\n\nUnfortunately, none of the recommended alternatives work for our use case. The\nmain thing we want to identify when broadcasting a transaction is whether is\nit invalid or not. As long as it is valid, reject messages aren't required as\nthe light client can just rebroadcast the transaction upon every new block to\nensure it is eventually included in the chain. It can then stop rebroadcasting\nit once it detects it has confirmed on-chain through its filters. However, if\nit is invalid, some of the validity checks required cannot be performed by\nlight clients as they do not have a mempool and/or UTXO set.\n\nReject messages also useful when developing new light clients, as we can get\nsome feedback from the network on why a transaction was rejected, which helps\nidentify potential bugs in their transaction crafting logic. I understand that\nthis can be done by setting up test nodes with the flag enabled, but this\njustifies that the feature should at least exist and not be completely\nremoved.\n\n> * Testing the validity of a transaction can be achieved by specific RPCs:\n>  - `sendrawtransaction`\n>  - `testmempoolaccept`\n\nThese RPCs are not helpful for light clients. Even for full nodes, in the case\nof `testmempoolaccept`, mempool conditions can quickly change and cause a\ntransaction to be rejected after the fact. One alternative would be for a\nthird-party to set up an endpoint where users can submit their transactions\nto, but now you're placing your trust solely on them, rather than the network,\nwhich doesn't seem like a reasonable or comparable compromise.\n\nWith that said, I believe the feature should remain enabled by default in\norder to aid the light clients of the network. If we disable them by default,\nno one will bother to enable them manually, and light clients won't be able to\nrealize they are broadcasting invalid transactions.\n\n[1] https://github.com/lightninglabs/neutrino\n\n- Wilmer"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-03-08T00:30:51",
                "message_text_only": ">> On Mar 7, 2019, at 19:09, Wilmer Paulino via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> ...\n>> Nodes on the network can not generally be trusted to send valid (\"reject\") messages, so this should only ever be used when connected to a trusted node.\n> \n> Nodes in the network generally rely on the assumption that they are connected to at least one honest peer, so we can actually converge on the set of honest peers and ban/disconnect any who send an invalid reject message for a valid transaction.\n\nThis implies the reject message is valid only when it is expected (i.e. the sender is knowingly sending invalid transactions), which is presumably useful only in a local development environment.\n\ne"
            }
        ],
        "thread_summary": {
            "title": "Removal of reject network messages from Bitcoin Core (BIP61)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Oscar Guindzberg",
                "Eric Voskuil",
                "Andreas Schildbach",
                "Wilmer Paulino",
                "Aymeric Vitte",
                "Sjors Provoost",
                "Gregory Maxwell",
                "Dustin Dettmer",
                "Marco Falke"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 36165
        }
    },
    {
        "title": "[bitcoin-dev] Fortune Cookies to Bitcoin Seed",
        "thread_messages": [
            {
                "author": "James MacWhyte",
                "date": "2019-03-06T01:05:54",
                "message_text_only": "On Tue, Mar 5, 2019 at 4:39 PM Trey Del Bonis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Keeping 20 around is a little excessive but it gives 390700800 possible\n> wallets. So security can be trivially parameterized based on how secure you\n> want your wallet to be if someone finds your stash.\n>\n\nMid-level hardware can check 50k addresses per second, which means it would\nonly take around 2 hours to check all possibilities. So please don't think\nthis presents any kind of challenge to someone who finds your 20 pieces of\npaper and assumes you would only keep them if they are hiding your wallet ;)\n\nEntropy-wise, simply using a strong RNG would provide a better result than\nrelying on the printing company. Maybe they only print 35 different\ncombinations and assume people don't eat Chinese food enough to notice?\n\nIf it's poor entropy and doesn't really provide any protection against\nbeing brute forced if found, I'm not sure why you would want to go\nthis route :)\n\nJames\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190305/e39b7baf/attachment.html>"
            },
            {
                "author": "Trey Del Bonis",
                "date": "2019-03-06T01:37:35",
                "message_text_only": ">Mid-level hardware can check 50k addresses per second, which means it would only take around 2 hours to check all possibilities.\n\nYes that's a problem that I'm now realizing exists.  Whoops!  Changing\nthe parameters to a 25-of-50 setup gets us ~129 bits in that case,\nwhich is better but still somewhat crappy as 25 is a lot of words to\nremember.  You'd be *far* better off just memorizing a BIP-39\nseedphrase.  Maybe it would make sense to include in the hash some\nextra secret phrase as extra entropy?  Probably not worth it.\n\n>Maybe they only print 35 different combinations and assume people don't eat Chinese food enough to notice?\n\nUpon some later research I found that this is actually the case from\ncertain vendors, which is unfortunate.\n\n>I'm not sure why you would want to go this route :)\n\nBecause it was a fun idea I had while eating Chinese take-out the other day. :)\n\nOn Tue, Mar 5, 2019 at 8:06 PM James MacWhyte <macwhyte at gmail.com> wrote:\n>\n> On Tue, Mar 5, 2019 at 4:39 PM Trey Del Bonis via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Keeping 20 around is a little excessive but it gives 390700800 possible wallets. So security can be trivially parameterized based on how secure you want your wallet to be if someone finds your stash.\n>\n>\n> Mid-level hardware can check 50k addresses per second, which means it would only take around 2 hours to check all possibilities. So please don't think this presents any kind of challenge to someone who finds your 20 pieces of paper and assumes you would only keep them if they are hiding your wallet ;)\n>\n> Entropy-wise, simply using a strong RNG would provide a better result than relying on the printing company. Maybe they only print 35 different combinations and assume people don't eat Chinese food enough to notice?\n>\n> If it's poor entropy and doesn't really provide any protection against being brute forced if found, I'm not sure why you would want to go this route :)\n>\n> James"
            }
        ],
        "thread_summary": {
            "title": "Fortune Cookies to Bitcoin Seed",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Trey Del Bonis",
                "James MacWhyte"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3159
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal - addrv2 message",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-06T03:02:51",
                "message_text_only": "On Wed, Mar 6, 2019 at 12:22 AM Wladimir J. van der Laan via\nbitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Field <code>addr</code> has a variable length, with a maximum of 32 bytes (256 bits). Clients SHOULD reject\n> longer addresses.\n\nIs 32 bytes long enough for I2P?  It seems like there are two formats,\nis there a reason we might want to use the longer one?\nhttps://geti2p.net/en/docs/naming\n\nProbably the spec should define the limit per address type (e.g.\nsending a 32 byte IPv4 makes no sense).   And either a maximum for ANY\ntype (so that 1000*largest size is reasonable), or a maximum size for\nthe message (e.g. regardless of the included size, an add message\nshould never be over, say 100k).\n\n\n> * ''Client MAY store and gossip address formats that they do not know about'': does it ever make sense to gossip addresses outside a certain overlay network? Say, I2P addresses to Tor? I'm not sure. Especially for networks that have no exit nodes as there is no overlap with the globally routed internet at all.\n\nI think clients should be discouraged from gossiping stuff they cannot\ntest but not forbidden from doing so. Separately, they should be\nstrongly discouraged from gossiping types they don't understand at\nall. We don't really want to see people doing file xfer over invalid\naddr types. :)"
            },
            {
                "author": "Sjors Provoost",
                "date": "2019-03-06T09:05:09",
                "message_text_only": "Concept ACK.\n\n> ==Considerations==\n> \n> (to be discussed)\n> \n> * ''Client MAY store and gossip address formats that they do not know about'': does it ever make sense to gossip addresses outside a certain overlay network? Say, I2P addresses to Tor? I'm not sure. Especially for networks that have no exit nodes as there is no overlap with the globally routed internet at all.\n\nWhat exactly do you mean by \"do not know about\"? It could mean:\n\n1. A new Network ID was recently introduced which an older node doesn't about.\n\nIn that case the node won't even know the address length, so it can't parse the entry.\n\nIn fact it can't parse the entire address message if a single address has an unknown format. Maybe require a single address type per ADDR2 message?\n\n2. The Network ID doesn't match the network the node received this message on\n\nThe node should probably be agnostic about where it received this information from.\n\n3. The node currently doesn't support a Network ID\n\nBut what does that mean? No connection? An explicitly disabled setting? A missing dependency? The operating system doesn't support it?\n\nI think \"MAY\" is the correct choice for storing for (2).\n\nFor (3) I think it makes sense for nodes to store information even if they're disconnected, but not if they have a setting disabled or no driver. Though that implementation detail doesn't seem relevant to the standard.\n\n\nI don't think it's a good idea to gossip information you can't at least in theory verify, but we already do that with Tor V2. It's useful to gossip information about other networks to help e.g. IPv4 nodes bootstrap Tor connections. On the other hand, that could also help an attacker link them. We could recommend that with addrv2 the node should make sure gossip messages were received on the correct interface, but that may not be practical.\n\n> * Lower precision of <code>time</code> field? seconds precision seems overkill, and can even be harmful, there have been attacks that exploited high precision timestamps for mapping the current network topology.\n> \n> ** (gmaxwell) If you care about space time field could be reduced to 16 bits easily.  Turn it into a \"time ago seen\" quantized to 1 hour precision. (IIRC we quantize times to 2hrs regardless).\n\nThat seems like a good idea.\n\n> * (gmaxwell) Optional (per-service) data could be useful for various things:\n> [...]\n> ** If we want optional flags. I guess the best thing would just be a byte to include the count of them, then a byte \"type\" for each one where the type also encodes if the payload is 0/8/16/32 bits. (using the two MSB of the type to encode the length).  And then bound the count of them so that the total is  still reasonably sized.\n\nAdding more information seems useful, though also creates more topology mapping opportunities.\n\n- Sjors"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal - addrv2 message",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell",
                "Sjors Provoost"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4125
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: BIP proposal - Signatures of Messages using Bitcoin Private Keys",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2019-03-06T10:37:59",
                "message_text_only": "Re-sending to the list since it never made it\n\nBIP or not, at least this process desserves to be documented precisely\n\n\n-------- Message transf\u00e9r\u00e9 --------\nSujet\u00a0: \tRe: [bitcoin-dev] BIP proposal - Signatures of Messages using\nBitcoin Private Keys\nDate\u00a0: \tMon, 18 Feb 2019 16:29:34 -0800\nDe\u00a0: \tChristopher Gilliard <christopher.gilliard at gmail.com>\nPour\u00a0: \tAymeric Vitte <vitteaymeric at gmail.com>\nCopie \u00e0\u00a0: \tBitcoin Protocol Discussion\n<bitcoin-dev at lists.linuxfoundation.org>\n\n\n\nTrying the four possible options (p2pkh compressed, p2pkh uncompressed,\nseg3, and bech32) is certainly a possibility and in fact, that's what I\nended up doing because not every wallet implements something like this,\nbut if there is a header field currently in use, it seemed reasonable to\nme to use it specify which type of key is being used. If the header\nincludes whether the key is compressed or not compressed it seems\nlogical to include all data about what type of key it is and not just\nthis one type of information. That's why I thought the solution made\nsense and I wrote it up.\n\nOn Mon, Feb 18, 2019 at 3:50 PM Aymeric Vitte <vitteaymeric at gmail.com\n<mailto:vitteaymeric at gmail.com>> wrote:\n\n    Ah, OK, that's of course a good thing to document this undocumented\n    (and strange) stuff, as a matter of fact I implemented it after\n    reading your post (because this was on my todo list since some time)\n    and got annoyed quickly, mainly by what is doing\n    formatMessageForSigning (which is quite trivial when you know it but\n    would be good to document precisely)\n\n    So, yes, it's a good idea to write this, regarding the header I\n    still don't see the use, testing the different possibilities is not\n    a big deal, why the signature format is not the same as transactions\n    one is mysterious too\n\n    Le 19/02/2019 \u00e0 00:24, Christopher Gilliard a \u00e9crit\u00a0:\n>     The proposal includes actual code that does verification, but I\n>     didn't include code for signing. I thought it could be inferred,\n>     but I could at least include a description of how to sign. I am\n>     not sure exactly what part you are referring to by \"keys speech\",\n>     but the signatures are done by ECDSA keys so it's hard to not\n>     include anything about keys even though that's not the main topic.\n>     The \"Background on ECDSA keys\" section was mainly meant to give\n>     background about what kind of keys Bitcoin uses, for people who\n>     already know that they can easily skip this section so I would\n>     probably think it's best just to leave in.\u00a0 Maybe it should be at\n>     the end as an addendum though. Yes, I did not invent any of this,\n>     I'm just documenting what people actually seem to do because I had\n>     to verify signatures as part of a project I'm working on. I would\n>     have liked to have had this document when I started the project so\n>     I thought it might be useful to others since as far as I can tell\n>     this was not specified anywhere. The reason for including this\n>     data in the header is the same that compressed/uncompressed is\n>     included in the header so that you know which type of key the\n>     signature is from and you don't have to try all options to see if\n>     any matches. This is why Trezor did that way and why I documented\n>     it. I'm sure there are other ways to do this, but since this is\n>     out there in the field being used and is a reasonable solution, I\n>     thought I'd write it up.\n>\n>     On Mon, Feb 18, 2019 at 2:59 PM Aymeric Vitte\n>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:\n>\n>         Then, since you wrote this proposal, maybe you should add the\n>         very precise description of the signing/verification process\n>         since it is documented nowhere\n>\n>         I don't get the use of the speech regarding keys while it\n>         should focus on signatures which are summarized in a vague\n>         sentence inspired by your ref [2] with a not very logical link\n>         to the next paragraph stating that r,s should be 32B and the\n>         whole thing 65B with a header of 1B, you did not invent it,\n>         that's probably the rule, not sure where it is specified again\n>         and for what purpose, the header seems completely of no use\n>         especially when you extend to segwit/bech32 since you just\n>         have to check that related compressed key matches\n>\n>         Le 17/02/2019 \u00e0 15:14, Christopher Gilliard via bitcoin-dev a\n>         \u00e9crit\u00a0:\n>>         I have written up a proposed BIP. It has to do with Signature\n>>         formats when using Bitcoin Private keys. It is\n>>         here:\u00a0https://github.com/cgilliard/BIP/blob/master/README.md\n>>\n>>         This BIP was written up as suggested in this github\n>>         issue:\u00a0https://github.com/bitcoin/bitcoin/issues/10542\n>>\n>>         Note that the proposal is inline with the implementation that\n>>         Trezor implemented in the above issue.\n>>\n>>         Any feedback would be\u00a0appreciated. Please let me know what\n>>         the steps are with regards to getting a BIP number assigned\n>>         or any other process steps required.\n>>\n>>         Regards,\n>>         Chris\n>>\n>>         _______________________________________________\n>>         bitcoin-dev mailing list\n>>         bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>         -- \n>         Move your coins by yourself (browser version): https://peersm.com/wallet\n>         Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n>         Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n>         Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n>         Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n>         Check the 10 M passwords list: http://peersm.com/findmyass\n>         Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n>         Peersm : http://www.peersm.com\n>         torrent-live: https://github.com/Ayms/torrent-live\n>         node-Tor : https://www.github.com/Ayms/node-Tor\n>         GitHub : https://www.github.com/Ayms\n>\n    -- \n    Move your coins by yourself (browser version): https://peersm.com/wallet\n    Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n    Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n    Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n    Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n    Check the 10 M passwords list: http://peersm.com/findmyass\n    Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n    Peersm : http://www.peersm.com\n    torrent-live: https://github.com/Ayms/torrent-live\n    node-Tor : https://www.github.com/Ayms/node-Tor\n    GitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190306/3814a315/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: BIP proposal - Signatures of Messages using Bitcoin Private Keys",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Aymeric Vitte"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7136
        }
    },
    {
        "title": "[bitcoin-dev] Privacy literature review",
        "thread_messages": [
            {
                "author": "Adam Ficsor",
                "date": "2019-03-06T14:28:02",
                "message_text_only": "I would like to grab the opportunity to point out that I am doing the same,\nbut in the form of presentations. I started with a two part presentation,\nbut I decided to make it into a 6 part presentation series in the future.\nPart 1: Concentrating on network level privacy -\nhttps://vimeo.com/album/5765075/video/316635787\nPart 2: Concentrating on blockchain level privacy -\nhttps://www.youtube.com/watch?v=AmFC9dhtemo&t=358m0s\n\nI think this work is very important and nothing comparable has been done\nbefore, so thank you for taking the time for this Belcher!\n\nOn Wed, Mar 6, 2019 at 1:38 AM Chris Belcher via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello list,\n>\n> For the last few weeks I've been working on a literature review for\n> bitcoin privacy:\n>\n> https://en.bitcoin.it/wiki/Privacy\n>\n> It aims to cover about all privacy issues in bitcoin, including\n> Lightning network, and has a bunch of examples to help demonstrate how\n> the concepts work in practice.\n>\n> There is also a new wiki category with smaller related articles:\n>\n> https://en.bitcoin.it/wiki/Category:Privacy\n>\n> Regards\n> CB\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nBest,\n\u00c1d\u00e1m\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190306/8b2abaf8/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Privacy literature review",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Ficsor"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1516
        }
    },
    {
        "title": "[bitcoin-dev] bitcoinj 0.15 (segwit)",
        "thread_messages": [
            {
                "author": "Andreas Schildbach",
                "date": "2019-03-06T17:14:52",
                "message_text_only": "In case anyone missed the announcement: bitcoinj 0.15, with support for\nnative segregated witness, has recently been released.\n\nhttps://groups.google.com/d/msg/bitcoinj-announce/X6Zv1NSFxOk/KJACzHZMAQAJ\n\nFor operability testing, I just released new versions 7.0 of Bitcoin\nWallet. For now, they still create a keychain of legacy addresses but\nthey can send to native segwit addresses via Bech32.\n\nTestnet:\nhttps://play.google.com/store/apps/details?id=de.schildbach.wallet_test\n\nMainnet:\nhttps://play.google.com/store/apps/details?id=de.schildbach.wallet\n(At the time of this writing, you need to opt into beta in order to\nreceive 7.x: https://play.google.com/apps/testing/de.schildbach.wallet)\n\nReceiving to native segwit addresses and spending from them will follow\nin the coming days and weeks."
            }
        ],
        "thread_summary": {
            "title": "bitcoinj 0.15 (segwit)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andreas Schildbach"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 797
        }
    },
    {
        "title": "[bitcoin-dev] BIP174 / PSBT extensions",
        "thread_messages": [
            {
                "author": "Andrew Poelstra",
                "date": "2019-03-06T18:08:00",
                "message_text_only": "Hi all,\n\n\nI'd like to start initial discussion about an extension to BIP174 [1] to add\nsome fields that I've found myself wanting when using PSBT in practice. For\nnow I'll just list the things that I'd like to see, and if we can come up\nwith a stable list then I'll try to write up a more formal draft.\n\nBasically I'd just like to add some more fixed data fields.\n\n1. Add an field to PSBT_GLOBAL_UNSIGNED_TX to the global table which contains\n   just a txid of the unsigned transaction, for bandwidth savings in case\n   signers have already seen the tx or can construct it themselves.\n\n   This field would be fixed 32 bytes.\n\n   (This would actually be a breaking change since the current PSBT rules require\n   PSBT_GLOBAL_UNSIGNED_TX to always be present. Maybe this is a no-go for that\n   reason alone.)\n\n2. Add a version field to the global table.\n\n3. Add fields to the per-input tables for\n   (a) confirmed depth of the referenced txout; this is useful for finalizers\n       trying to create optimized witnesses, for e.g. cases when CSV timeouts\n       expire and some signatures become unnecessary.\n\n       This field must be a varint.\n\n   (b) a map from SHA2 hashes to their 32-byte preimages; this field must be\n       fixed 32 bytes. This, plus the CSV thing, would allow writing finalizers\n       that work with all of Miniscript [2].\n\n   (c) a map from public keys to 32-byte \"tweaks\" that are used in the pay-to-contract\n       construction. Selfishly I'd like this to be a variable-length bytestring\n       with the semantics that (a) the first 33 bytes represent an untweaked\n       pubkey; (b) the HMAC-SHA256 of the whole thing, when multiplied by G and\n       added to the untweaked pubkey, result in the target key. This matches the\n       algorithm in [3] which is deployed in Blockstream's Liquid, but I'd be\n       happy with a more efficient scheme which e.g. used SHA256 rather than\n       HMAC-SHA256.\n\n   (d) maps from public keys to partial nonce commitments, partial nonces, and\n       partial signatures, for MuSig [4] support.\n\n   (e) a map from signatures (or signature nonces?) to sign-to-contract tweaks.\n       Same semantics as (c) above.\n\n   The last two suggestions are probably premature and need further development\n   and standardization of the related protocols. But I'm throwing them in to see\n   if other people have strong feelings about this.\n\n4. Add fields to the per-output tables for pay-to-contract, like in (c) above.\n\n5. Add a field (or rather, family of fields) to every table which is \"proprietary\n   use\" and guaranteed not to be defined by any future PSBT extension. Specifically\n   every field with key-type 0xFF could be considered \"proprietary\".\n\n5a. The special field in the global table whose key is only 0xFF should be a\n    \"proprietary version field\" with unspecified semantics but an understanding\n    that specific users might stick a GUID or something in there as a way to\n    recognize their own PSBTs.\n\n[1] https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Encoding\n[2] http://bitcoin.sipa.be/miniscript/miniscript.html\n[3] https://github.com/ElementsProject/elements/blob/elements-0.14.1/src/validation.cpp\n[4] https://eprint.iacr.org/2018/068\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"There are some mornings when the sky looks like a road\n There are some dragons who were built to have and hold\n And some machines are dropped from great heights lovingly\n And some great bellies ache with many bumblebees\n And they sting so terribly\"\n       --Joanna Newsom"
            },
            {
                "author": "Andrew Chow",
                "date": "2019-03-07T15:34:26",
                "message_text_only": "Hi Andrew,\n\nI think having some of these extensions would be great.\n\nOn 3/6/19 1:08 PM, Andrew Poelstra via bitcoin-dev wrote:\n\n> 1. Add an field to PSBT_GLOBAL_UNSIGNED_TX to the global table which contains\n>    just a txid of the unsigned transaction, for bandwidth savings in case\n>    signers have already seen the tx or can construct it themselves.\n>\n>    This field would be fixed 32 bytes.\n>\n>    (This would actually be a breaking change since the current PSBT rules require\n>    PSBT_GLOBAL_UNSIGNED_TX to always be present. Maybe this is a no-go for that\n>    reason alone.)\n\nI feel like this breaks the central idea of PSBT that a PSBT contains everything you need to construct a transaction.\nThis would rely on parties in the transaction having state and remembering things which I don't think is something\nthat we can assume.\n\n> 2. Add a version field to the global table.\n\nFor what purpose?\n\nThe rest of the proposed extensions I think are fine.\n\nRegards,\n\nAndrew Chow\n\n> 3. Add fields to the per-input tables for\n>    (a) confirmed depth of the referenced txout; this is useful for finalizers\n>        trying to create optimized witnesses, for e.g. cases when CSV timeouts\n>        expire and some signatures become unnecessary.\n>\n>        This field must be a varint.\n>\n>    (b) a map from SHA2 hashes to their 32-byte preimages; this field must be\n>        fixed 32 bytes. This, plus the CSV thing, would allow writing finalizers\n>        that work with all of Miniscript [2].\n>\n>    (c) a map from public keys to 32-byte \"tweaks\" that are used in the pay-to-contract\n>        construction. Selfishly I'd like this to be a variable-length bytestring\n>        with the semantics that (a) the first 33 bytes represent an untweaked\n>        pubkey; (b) the HMAC-SHA256 of the whole thing, when multiplied by G and\n>        added to the untweaked pubkey, result in the target key. This matches the\n>        algorithm in [3] which is deployed in Blockstream's Liquid, but I'd be\n>        happy with a more efficient scheme which e.g. used SHA256 rather than\n>        HMAC-SHA256.\n>\n>    (d) maps from public keys to partial nonce commitments, partial nonces, and\n>        partial signatures, for MuSig [4] support.\n>\n>    (e) a map from signatures (or signature nonces?) to sign-to-contract tweaks.\n>        Same semantics as (c) above.\n>\n>    The last two suggestions are probably premature and need further development\n>    and standardization of the related protocols. But I'm throwing them in to see\n>    if other people have strong feelings about this.\n>\n> 4. Add fields to the per-output tables for pay-to-contract, like in (c) above.\n>\n> 5. Add a field (or rather, family of fields) to every table which is \"proprietary\n>    use\" and guaranteed not to be defined by any future PSBT extension. Specifically\n>    every field with key-type 0xFF could be considered \"proprietary\".\n>\n> 5a. The special field in the global table whose key is only 0xFF should be a\n>     \"proprietary version field\" with unspecified semantics but an understanding\n>     that specific users might stick a GUID or something in there as a way to\n>     recognize their own PSBTs.\n>\n> [1]\n> https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#Encoding\n> [2]\n> http://bitcoin.sipa.be/miniscript/miniscript.html\n> [3]\n> https://github.com/ElementsProject/elements/blob/elements-0.14.1/src/validation.cpp\n> [4]\n> https://eprint.iacr.org/2018/068\n> --\n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:\n> https://www.wpsoftware.net/andrew\n> \"There are some mornings when the sky looks like a road\n>  There are some dragons who were built to have and hold\n>  And some machines are dropped from great heights lovingly\n>  And some great bellies ache with many bumblebees\n>  And they sting so terribly\"\n>        --Joanna Newsom\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190307/2ac6f69d/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-08T00:40:00",
                "message_text_only": "On Thu, Mar 7, 2019 at 11:49 PM Andrew Chow via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I feel like this breaks the central idea of PSBT that a PSBT contains everything you need to construct a transaction.\n> This would rely on parties in the transaction having state and remembering things which I don't think is something\n> that we can assume.\n\nI think it's perfectly fine for someone to have a propritary extension\nto PSBT that isn't going to work right unless used only between their\nown stuff or need a translator to talk to ordinary PSBT stuff.\n\nFor that purpose, having some kind of versioning field that you can\nuse to indicate what weird PSBT dialect you're speaking might be\nhelpful, if only to allow for more reasonable error messages."
            }
        ],
        "thread_summary": {
            "title": "BIP174 / PSBT extensions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Poelstra",
                "Andrew Chow",
                "Gregory Maxwell"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8640
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal: The Great Consensus Cleanup",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2019-03-06T21:39:15",
                "message_text_only": "The following is a proposed BIP to soft-fork out some oddities in the \ncurrent Bitcoin consensus rules, resolving several vulnerabilities, in \naddition to fixing the timewarp vulnerability. I'd like to ask the BIP \neditor to assign a BIP number.\n\nThe latest version of the BIP can be found at \nhttps://github.com/TheBlueMatt/bips/blob/cleanup-softfork/bip-XXXX.mediawiki \n(a text copy is included below).\n\nSome things that may be worth discussing:\n\n  * Note that the activation times in this BIP may result in the \nactivation of the new soft-fork rules on the same block as the scheduled \nblock-subsidy halving. Sadly, avoiding this either requires a \nsignificantly compressed BIP activation time (which may result in the \nrules not activating for benign reasons) or beginning the activation \nprocess significantly into the future.\n\n  * The BIP proposes allowing timestamps on the difficulty-adjustment \nblock to go backwards by 600 seconds which has the nice property of \nmaking the difficulty-adjustment algorithm target almost exactly one \nblock per 600 seconds in the worst-case (where miners are attempting to \nexploit the timewarp attack), while avoiding any potential hardware \nbricking (assuming upgrades on the part of mining pools). Alternatively, \nsome have proposed allowing the time to go backwards 7200 seconds, which \nintroduces some small level of inflation in the case of a miner attack \n(though much less than we've had historically simply due to the rapidly \ngrowing hashrate) but avoids any requirements for upgrades as the \nexisting 7200-second-in-the-future check implies miners will only ever \nbuild on blocks for which they can set the next timestamp to their \ncurrent time.\n\n  * The 4th change (making non-standard signature hash types invalid) \nmay be worth discussing. In order to limit the number of potential \nsignature hashes which could be used per-input (allowing us to cache \nthem to avoid re-calculation), we can disable non-standard sighash \ntypes. Alternatively, however, most of the same effect could be achieved \nby caching the just-before-the-last-byte sighash midstate and hashing \nonly the last byte when a checking signatures. Still, them having been \nnon-standard for many years makes me doubt there is much risk involved \nin disabling them, and I don't see much potential use-case for keeping \nthem around so I'd like to just remove them.\n\nAs for why the timewarp vulnerability should (IMO rather obviously) be \nfixed, it seems rather clear that the only potential use for exploiting \nit would be either to inflate the currency supply maliciously by miners \nor to fork in what amounts to extension blocks. As for why extension \nblocks are almost certainly not the right approach to such changes, its \nlikely worth reading this old post: \nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013510.html\n\n\n<pre>\nBIP: XXXX\nLayer: Consensus (soft fork)\nTitle: The Great Consensus Cleanup\nAuthor: Matt Corallo\nStatus: Draft\nType: Standards Track\nCreated: 2019-01-28\nLicense: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines a set of consensus changes which reduce the complexity \nof Bitcoin implementations and improve worst-case validation times, \nfixing a number of long-standing vulnerabilities.\n\n==Motivation==\n\nBIP 143 significantly improved certain aspects of Bitcoin's consensus \nrules, key to this being changes to the format of the data which is \nhashed and signed in CHECKSIG operations during script execution. \nHowever, several improvements were left for later forks to avoid \nbloating the original activation with unrelated changes. This BIP seeks \nto make some of these changes as well as a few other simplifications. \nSpecifically, this BIP proposes the following changes:\n\n* Worst-case validation time for non-BIP 143 transactions has long been \nconsidered a significant vulnerability. To address this, both \nOP_CODESEPARATOR in non-BIP 143 scripts and FindAndDelete fail script \nvalidation, among other cleanups. This drastically reduces worst-case \nvalidation time for non-BIP 143 transactions by enabling Signature Hash \ncaching on a per-input basis. While validation time of large, simple \nnon-BIP 143 transactions can still be excessively high on their own, \nremoving these multipliers goes a long way towards resolving the issue.\n\n* By further restricting nTime fields on difficulty adjustment blocks, \nwe propose fixing the long-standing \"timewarp\" inflation vulnerability \nin Bitcoin's difficulty adjustment without risking existing mining \nhardware becoming unusable. This limits the worst-case difficulty \nadjustment target in case of attack from the current exponential growth, \nto once every roughly 600 seconds. Note that no change in default \nbehavior is proposed, keeping the existing target of one block every \n~600.6 seconds[1] in the common case (ie we limit the attack scenario to \nabout a 0.1% inflation rate, much smaller than the historical inflation \nrate due to rapid hashrate growth).\n\n* Several vulnerabilities where Bitcoin clients needed to check for \nspecific cases of malleation in the merkle tree construction are \nresolved by making certain transaction sizes invalid.\n\n==Specification==\n\nUpon activation, the following rules will be enforced on all new blocks:\n\n* scriptSigs which contain non-push opcodes fail the script validation. \nPush opcodes are OP_0 - OP_1NEGATE and OP_1 - OP_16. Note that this \nimplies any opcodes in scriptSigs greater than 0x60 will fail script \nvalidation, in addition to OP_RESERVED (0x50, which already fails script \nexecution in executed branches, though all branches are now guaranteed \nto execute).\n\n* OP_CODESEPARATOR in non-BIP 143 scripts fails the script validation. \nThis includes OP_CODESEPARATORs in unexecuted branches of if statements, \nsimilar to other disabled opcodes, but unlike OP_RETURN.\n\n* When validating signatures in non-BIP 143 scripts, if the scriptPubKey \nbeing executed contains, pushed as a single element using minimal \nPUSHDATA, a signature stack element being validated, the script fails \nvalidation. For the avoidance of doubt, any FindAndDelete matches result \nin script execution failure.\n\n* If the sighash type byte (ie last byte in a signature being evaluated \nduring the execution of OP_CHECKSIG[VERIFY] or OP_CHECKMULTISIG[VERIFY]) \nis anything other than 1, 2, 3, 0x81, 0x82, or 0x83, the script \nexecution fails. This does not apply to 0-length signature stack elements.\n\n* Transactions smaller than 65 bytes when serialized without witness \ndata are invalid.\n\n* The nTime field of each block whose height, mod 2016, is 0 must be \ngreater than or equal to the nTime field of the immediately prior block \nminus 600. For the avoidance of doubt, such blocks must still comply \nwith existing Median-Time-Past nTime restrictions.\n\n==Deployment==\n\nThis BIP will be deployed by \"version bits\" BIP9 with the name \n\"cleanups\" and using bit (0-indexed) 3.\n\nFor Bitcoin mainnet, the BIP9 starttime will be midnight August 1st, \n2019 UTC (Epoch timestamp 1564617600) and BIP9 timeout will be midnight \nAugust 1st, 2020 UTC (Epoch timestamp 1596240000).\n\nFor Bitcoin testnet, the BIP9 starttime will be midnight June 1st, 2019 \nUTC (Epoch timestamp 1559347200) and BIP9 timeout will be midnight June \n1st, 2020 UTC (Epoch timestamp 1590969600).\n\n==Discussion==\n\n* There are very few known uses for OP_CODESEPARATOR and none for \nFindAndDelete. None of these uses enable new functionality, and any \nefficiency gains are better made by switching to BIP 141. Further, there \nis no known use of either on the chain today, and both have been \nnon-standard in Bitcoin Core since version 0.16.1, making them much more \ndifficult to have mined. Both changes, together, allow for signature \nhash caching within each input script in a non-BIP 143 transaction \ntoday. Note that due to their non-standardness, miners using Bitcoin \nCore version 0.16.1 or later will not mine blocks which violate these \nrules today.\n* Reducing valid scriptSigs to the minimal set of operations which can \ngenerate any stack state removes the requirement that scriptCodes need \nto be generated for scriptSig execution, reducing the possible set of \nscriptCodes which must be cached per input by 2x. Because any stack \nstate can be created using only push opcodes, this does not reduce \nspendability except for pessimal scriptPubKeys which require a \nsignificant number of identical stack elements (ie created using \nOP_DUP). Note that such transactions have been non-standard in Bitcoin \nCore since before git history (SVN 197) and thus miners running Bitcoin \nCore will not mine such transactions today.\n* Further, disabling non-canonical sighash types allows caching of the \nsighash themselves instead of midstates (as the sighash type byte is \nincluded in the sighash itself). Avoiding applying this rule to 0-length \nsignatures avoids breaking deliberate OP_CHECKSIG failures while still \navoiding having to ever calculate such sighashes. Such sighashes have \nbeen non-standard and thus miners using Bitcoin Core version 0.8 or \nhigher will not mine blocks containing such transactions today.\n<br/>\n* While there are no known attempts to exploit the \"timewarp\" \nvulnerability on Bitcoin's mainnet today, and the authors do not believe \nit is likely to occur in the immediate future, removing the possibility \nhas long been on various wishlists and greatly simplifies potential \nattack analysis.\n** Sadly, some deployed mining hardware relies on the ability to roll \nnTime forward by up to 600 seconds[3]. Thus, only requiring that the \nnTime field move forward during difficulty adjustment would allow a \nmalicious miner to prevent some competitors from mining the next block \nby setting their timestamp to two hours in the future. Thus, we allow \nnTime to go backwards by 600 seconds, ensuring that even a block with a \ntimestamp two hours in the future allows for 600 seconds of nTime \nrolling on the next block.\n** Note that miners today only enforce increasing timestamps against the \nmedian-timestamp-of-last-11-blocks, so miners who do not upgrade may \nmine a block which violates this rule at the beginning of a difficulty \nwindow if the last block in a difficulty window has a timestamp in the \nfuture. Thus, it is strongly recommended that SPV clients enforce the \nnew nTime rules to avoid following any potential forks which occur.\n<br/>\n* The issues involved in having leaf nodes in the transaction merkle \ntree which can be confused for inner nodes are well documented. \n[4][5][6] While there are workarounds for the pitfalls, there are many \nSPV-proof-validators which do not implement them. Further, the limited \nuse-cases for very small transactions does not suffice as reason to \nforce the added complexity onto clients. Note that any transactions \nsmaller than 83 bytes have been considered non-standard since Bitcoin \nCore version 0.17.0, so miners will not mine blocks which validate this \nrule by default.\n<br/>\n* There are several early-stage proposals which may affect the execution \nof scripts, including proposals such as Schnorr signatures, Taproot, \nGraftroot, and MAST. These proposals are not expected to have any \ninteraction with the changes in this BIP, as they are likely to only \napply to SegWit scripts, which are not covered by any of the new rules \nexcept for the sighash type byte rule. Thus, the sighash type byte rule \ndefined above only applies to *current* signature-checking opcodes, as \nany new signature-checking is likely to be implemented via the \nintroduction of new opcodes.\n<br/>\n* In spite of some suggestion that other activation methods be used, BIP \n9 is proposed as ensuring miners have upgraded to enforce new rules is \nan important part of minimizing disruption. While previous BIP 9 \nsoft-forks have resulted in political contention, this \ncomparatively-unimportant soft-fork provides a good opportunity to \nattempt to return to utilizing BIP 9 to ensure miner upgrade prior to \nactivation, which the authors believe is a critical goal. However, if \nthere is broad agreement to activate these rules when the BIP 9 expiry \ntime is reached, and miners have not yet signaled sufficient level of \nreadiness, a later flag-day activation may be merited. For this reason, \nimplementations may wish to provide a compatibility option which allows \nflag-day enforcement of these rules without an update.\n\n==Reference Implementation==\n\n[https://github.com/bitcoin/bitcoin/pull/15482 Bitcoin Core Pull #15482]\n\n==References==\n\n[1] The difficulty adjustment algorithm in Bitcoin multiplies the \nprevious difficulty by (2016 / time taken to mine the last 2015 blocks). \nIntuitively[2], this implies the actual Inter-Block-Time (IBT) target is \n2016/2015*600, or about 600.3 seconds. However, the expected value of \nthe inverse of an Erlang distribution (which the above is effectively \nsampling from) is actually 1/(N-1), not 1/N. Thus, the above expression \nactually targets an IBT of 2016/2014*600, or about 600.6 seconds, ie \nE(2016*600/X) = 1 where X~ErlangDistribution(k=2015, \u03bb=1/IBT) when IBT \nis 2016/2014*600. This is equivalent to 600*E(2016*600/X) where \nX~ErlangDistribution(k=2015, \u03bb=1/600). In the case of a miner \ndeliberately reducing timestamps by 600 seconds on the \ndifficulty-retargeting block, we are effectively changing the difficulty \nmultiplier to (2016 / (time taken to mine the last 2016 blocks + 600)), \nor 600*E(2016*600/(X + 600)) where X~Erlang Distribution(k=2016, \n\u03bb=1/600), which is effectively targeting an inter-block time of \n~599.9999 seconds.\n\n[2] See [https://twitter.com/pwuille/status/1098288749098795008] for \nmost peoples' intuition. For more info see Pieter's writeup at \n[https://gist.github.com/sipa/1a70884abe6d0a7cddc340c99f741a41]\n\n[3] While no official stratum specification exists, the btc.com pool \nserver (one of the most popular pool servers today) rejects shares with \ntimestamps more than 600 seconds in the future at \n[https://github.com/btccom/btcpool/blob/e7c536834fd6785af7d7d68ff29111ed81209cdf/src/bitcoin/StratumServerBitcoin.cc#L384]. \nWhile there are few resources describing hardware operation today, \ntimestamp rolling can be observed on the chain (in some rare cases) as \nblock timestamps go backwards when a miner rolled one block nTime \nforward and the next does not, but only incredibly rarely more than 600 \nseconds.\n\n[4] \n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html]\n\n[5] \n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180609/9f4f5b1f/attachment-0001.pdf]\n\n[6] \n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016697.html]\n\n==Acknowledgments==\n\nThanks (in alphabetical order) to Suhas Daftuar, James Hilliard, Johnson \nLau, Steve Lee, Greg Maxwell, John Newberry, and Pieter Wuille for their \nhelpful feedback at various stages as well as the entire Bitcoin \nProtocol Development Community."
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-03-07T10:44:34",
                "message_text_only": "On Wednesday 06 March 2019 21:39:15 Matt Corallo wrote:\n> I'd like to ask the BIP editor to assign a BIP number.\n\nNeeds a Backward Compatibility section, and should have a bips repo PR opened \nafter discussion on the ML.\n\n>   * The 4th change (making non-standard signature hash types invalid)\n> may be worth discussing. In order to limit the number of potential\n> signature hashes which could be used per-input (allowing us to cache\n> them to avoid re-calculation), we can disable non-standard sighash\n> types. Alternatively, however, most of the same effect could be achieved\n> by caching the just-before-the-last-byte sighash midstate and hashing\n> only the last byte when a checking signatures. Still, them having been\n> non-standard for many years makes me doubt there is much risk involved\n> in disabling them, and I don't see much potential use-case for keeping\n> them around so I'd like to just remove them.\n\nI don't understand what is being removed here.\n\n> As for why the timewarp vulnerability should (IMO rather obviously) be\n> fixed, it seems rather clear that the only potential use for exploiting\n> it would be either to inflate the currency supply maliciously by miners\n> or to fork in what amounts to extension blocks. As for why extension\n> blocks are almost certainly not the right approach to such changes, its\n> likely worth reading this old post:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013510\n>.html\n\nWhile I agree that extension blocks are typically a bad choice, I'm not sure \nthe argument really applies to forward blocks. (That being said, I find \nforward blocks overcomplicated and probably not a reason to avoid this.)\n\n> * Transactions smaller than 65 bytes when serialized without witness\n> data are invalid.\n\nRationale should include the reason(s) why the size doesn't count the witness \nhere.\n\n> ** Note that miners today only enforce increasing timestamps against the\n> median-timestamp-of-last-11-blocks, so miners who do not upgrade may\n> mine a block which violates this rule at the beginning of a difficulty\n> window if the last block in a difficulty window has a timestamp in the\n> future. Thus, it is strongly recommended that SPV clients enforce the\n> new nTime rules to avoid following any potential forks which occur.\n\nThis should probably be moved outside Discussion. (Perhaps to the missing \nBackward Compatibility section?)\n\n> * There are several early-stage proposals which may affect the execution\n> of scripts, including proposals such as Schnorr signatures, Taproot,\n> Graftroot, and MAST. These proposals are not expected to have any\n> interaction with the changes in this BIP, as they are likely to only\n> apply to SegWit scripts, which are not covered by any of the new rules\n> except for the sighash type byte rule. Thus, the sighash type byte rule\n> defined above only applies to *current* signature-checking opcodes, as\n> any new signature-checking is likely to be implemented via the\n> introduction of new opcodes.\n\nIt's not clear that new opcodes will necessarily always be used. Probably \nwould be good to clarify the \"non-Segwit or witness v0 only\" rule in the \nSpecification section.\n\nLuke"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-07T19:44:23",
                "message_text_only": "Replies inline.\n\nOn 3/7/19 10:44 AM, Luke Dashjr wrote:\n> On Wednesday 06 March 2019 21:39:15 Matt Corallo wrote:\n>> I'd like to ask the BIP editor to assign a BIP number.\n> \n> Needs a Backward Compatibility section, and should have a bips repo PR opened\n> after discussion on the ML.\n\nOops, I guess most of the \"Discussion\" section can just be moved into a \n\"Backwards Compatibility\" section. Will do before PR'ing.\n\n>>    * The 4th change (making non-standard signature hash types invalid)\n>> may be worth discussing. In order to limit the number of potential\n>> signature hashes which could be used per-input (allowing us to cache\n>> them to avoid re-calculation), we can disable non-standard sighash\n>> types. Alternatively, however, most of the same effect could be achieved\n>> by caching the just-before-the-last-byte sighash midstate and hashing\n>> only the last byte when a checking signatures. Still, them having been\n>> non-standard for many years makes me doubt there is much risk involved\n>> in disabling them, and I don't see much potential use-case for keeping\n>> them around so I'd like to just remove them.\n> \n> I don't understand what is being removed here.\n\nThis refers to the following spec change:\n\nIf the sighash type byte (ie last byte in a signature being evaluated \nduring the execution of OP_CHECKSIG[VERIFY] or OP_CHECKMULTISIG[VERIFY]) \nis anything other than 1, 2, 3, 0x81, 0x82, or 0x83, the script \nexecution fails. This does not apply to 0-length signature stack elements.\n\n>> As for why the timewarp vulnerability should (IMO rather obviously) be\n>> fixed, it seems rather clear that the only potential use for exploiting\n>> it would be either to inflate the currency supply maliciously by miners\n>> or to fork in what amounts to extension blocks. As for why extension\n>> blocks are almost certainly not the right approach to such changes, its\n>> likely worth reading this old post:\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013510\n>> .html\n> \n> While I agree that extension blocks are typically a bad choice, I'm not sure\n> the argument really applies to forward blocks. (That being said, I find\n> forward blocks overcomplicated and probably not a reason to avoid this.)\n\nI agree they are somewhat separate ideas, but the arguments in that \nthread apply equally to timewarp-based inter-block-time reductions. If \nyou want to discuss it further, I'd suggest a new thread.\n\n>> * Transactions smaller than 65 bytes when serialized without witness\n>> data are invalid.\n> \n> Rationale should include the reason(s) why the size doesn't count the witness\n> here.\n\nWill add.\n\n>> ** Note that miners today only enforce increasing timestamps against the\n>> median-timestamp-of-last-11-blocks, so miners who do not upgrade may\n>> mine a block which violates this rule at the beginning of a difficulty\n>> window if the last block in a difficulty window has a timestamp in the\n>> future. Thus, it is strongly recommended that SPV clients enforce the\n>> new nTime rules to avoid following any potential forks which occur.\n> \n> This should probably be moved outside Discussion. (Perhaps to the missing\n> Backward Compatibility section?)\n> \n>> * There are several early-stage proposals which may affect the execution\n>> of scripts, including proposals such as Schnorr signatures, Taproot,\n>> Graftroot, and MAST. These proposals are not expected to have any\n>> interaction with the changes in this BIP, as they are likely to only\n>> apply to SegWit scripts, which are not covered by any of the new rules\n>> except for the sighash type byte rule. Thus, the sighash type byte rule\n>> defined above only applies to *current* signature-checking opcodes, as\n>> any new signature-checking is likely to be implemented via the\n>> introduction of new opcodes.\n> \n> It's not clear that new opcodes will necessarily always be used. Probably\n> would be good to clarify the \"non-Segwit or witness v0 only\" rule in the\n> Specification section.\n\nNote that you inherently have to use a new opcode for such things - the \nnon-standard type bytes *are* defined and define a sighash/signature, \nthey can't be simply redefined to a new sighash/signature type in a soft \nfork."
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal: The Great Consensus Cleanup",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Matt Corallo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 22300
        }
    },
    {
        "title": "[bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great Consensus Cleanup",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2019-03-07T15:03:17",
                "message_text_only": "> * OP_CODESEPARATOR in non-BIP 143 scripts fails the script validation.\n> This includes OP_CODESEPARATORs in unexecuted branches of if statements,\n> similar to other disabled opcodes, but unlike OP_RETURN.\n>\n\nOP_CODESEPARATOR is the only mechanism available that allows users to sign\nwhich particular branch they are authorizing for within scripts that have\nmultiple possible conditions that reuse the same public key.  Because of\nP2SH you cannot know that no one is currently using this feature.\nActivating a soft-fork as describe above means these sorts of funds would\nbe permanently lost.  It is not acceptable to risk people's money like this.\n\nI suggest an alternative whereby the execution of OP_CODESEPARATOR\nincreases the transactions weight suitably as to temper the vulnerability\ncaused by it.  Alternatively there could be some sort of limit (maybe 1) on\nthe maximum number of OP_CODESEPARATORs allowed to be executed per script,\nbut that would require an argument as to why exceeding that limit isn't\nreasonable.\n\n-- \nRussell O'Connor\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190307/0f0ed246/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-07T19:50:52",
                "message_text_only": "Replies inline.\n\nMatt\n\nOn 3/7/19 3:03 PM, Russell O'Connor wrote:\n> \n>     * OP_CODESEPARATOR in non-BIP 143 scripts fails the script validation.\n>     This includes OP_CODESEPARATORs in unexecuted branches of if\n>     statements,\n>     similar to other disabled opcodes, but unlike OP_RETURN.\n> \n> \n> OP_CODESEPARATOR is the only mechanism available that allows users to \n> sign which particular branch they are authorizing for within scripts \n> that have multiple possible conditions that reuse the same public key.\n\nThis is true, and yet it does not appear to actually be practically \nusable. Thus far, despite a ton of effort, I have not yet seen a \npractical use-case for OP_CODESEPARATOR (except for one example of it \nbeing used to make SegWit scripts ever-so-slightly more effecient in \nTumbleBit, hence why this BIP does not propose disabling it for SegWit).\n\n> Because of P2SH you cannot know that no one is currently using this \n> feature.\u00a0 Activating a soft-fork as describe above means these sorts of \n> funds would be permanently lost.\u00a0 It is not acceptable to risk people's \n> money like this.\n\n(1) It has been well documented again and again that there is desire to \nremove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in \nnon-segwit scripts represents a rather significant vulnerability in \nBitcoin today, and (3) lots of effort has gone into attempting to find \npractical use-cases for OP_CODESEPARATOR's specific construction, with \nno successes as of yet. I strongly, strongly disagree that the \nhighly-unlikely remote possibility that someone created something before \nwhich could be rendered unspendable is sufficient reason to not fix a \nvulnerability in Bitcoin today.\n\n> I suggest an alternative whereby the execution of OP_CODESEPARATOR \n> increases the transactions weight suitably as to temper the \n> vulnerability caused by it.\u00a0 Alternatively there could be some sort of \n> limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be \n> executed per script, but that would require an argument as to why \n> exceeding that limit isn't reasonable.\n\nYou could equally argue, however, that any such limit could render some \nmoderately-large transaction unspendable, so I'm somewhat skeptical of \nthis argument. Note that OP_CODESEPARATOR is non-standard, so getting \nthem mined is rather difficult in any case."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-08T15:57:25",
                "message_text_only": "On Thu, Mar 7, 2019 at 2:50 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> Replies inline.\n>\n> Matt\n>\n> On 3/7/19 3:03 PM, Russell O'Connor wrote:\n> >\n> >     * OP_CODESEPARATOR in non-BIP 143 scripts fails the script\n> validation.\n> >     This includes OP_CODESEPARATORs in unexecuted branches of if\n> >     statements,\n> >     similar to other disabled opcodes, but unlike OP_RETURN.\n> >\n> >\n> > OP_CODESEPARATOR is the only mechanism available that allows users to\n> > sign which particular branch they are authorizing for within scripts\n> > that have multiple possible conditions that reuse the same public key.\n>\n> This is true, and yet it does not appear to actually be practically\n> usable. Thus far, despite a ton of effort, I have not yet seen a\n> practical use-case for OP_CODESEPARATOR (except for one example of it\n> being used to make SegWit scripts ever-so-slightly more effecient in\n> TumbleBit, hence why this BIP does not propose disabling it for SegWit).\n>\n\nIt's very easy to construct a practical script using OP_CODESEPARATOR.\n\nIF <2> <ALICEPUBKEY> <BOBPUBKEY> <2> CHECKMULTISIGVERIFY ELSE CODESEPARATOR\n<ALICEPUBKEY> CHECKSIGVERFY ENDIF\n\nNow when someone hands Alice, the CFO of XYZ corp., some transaction, she\nhas the option of either signing it unilaterally herself, or creating a\npartial signature such that the transaction additionally needs Bob, the\nCEOs signature as well, and Alice's choice is committed to the blockchain\nfor auditing purposes later.\n\nNow, there are many things you might object about this scheme, but my point\nis that (A) regardless of what you think about this scheme, it, or similar\nschemes, may have been devised by users, and (B) users may have already\ncommitted funds to such schemes, and due to P2SH you cannot know that this\nis not the case.\n\n\n> > Because of P2SH you cannot know that no one is currently using this\n> > feature.  Activating a soft-fork as describe above means these sorts of\n> > funds would be permanently lost.  It is not acceptable to risk people's\n> > money like this.\n>\n> (1) It has been well documented again and again that there is desire to\n> remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in\n> non-segwit scripts represents a rather significant vulnerability in\n> Bitcoin today, and (3) lots of effort has gone into attempting to find\n> practical use-cases for OP_CODESEPARATOR's specific construction, with\n> no successes as of yet. I strongly, strongly disagree that the\n> highly-unlikely remote possibility that someone created something before\n> which could be rendered unspendable is sufficient reason to not fix a\n> vulnerability in Bitcoin today.\n>\n\nPlease don't strawman my position.  I am not suggesting we don't fix a\nvulnerability in Bitcoin.  I am suggesting we find another way.  One that\nlimits the of risk destroying other people's money.\n\nHere is a more concrete proposal:  No matter how bad OP_CODESEPARATOR is,\nit cannot be worse than instead including another input that spends another\nidentically sized UTXO.  So how about we soft-fork in a rule that says that\nan input's weight is increased by an amount equal to the number of\nOP_CODESEPARATORs executed times the sum of weight of the UTXO being spent\nand 40 bytes, the weight of a stripped input. The risk of destroying other\npeople's money is limited and AFAIU it would completely address the\nvulnerabilities caused by OP_CODESEPARATOR.\n\nEven soft forking a rule like, \"it is illegal to execute an\nOP_CODESEPARATOR after any CHECKSIG/CHECKMULTISIG operation\", would be\nvastly better than the current proposal, even though I would still object\nto it.\n\n\n> > I suggest an alternative whereby the execution of OP_CODESEPARATOR\n> > increases the transactions weight suitably as to temper the\n> > vulnerability caused by it.  Alternatively there could be some sort of\n> > limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be\n> > executed per script, but that would require an argument as to why\n> > exceeding that limit isn't reasonable.\n>\n> You could equally argue, however, that any such limit could render some\n> moderately-large transaction unspendable, so I'm somewhat skeptical of\n> this argument. Note that OP_CODESEPARATOR is non-standard, so getting\n> them mined is rather difficult in any case.\n>\n\nI already know of people who's funds are tied up due to in other changes to\nBitcoin Core's default relay policy.  Non-standardness is not an excuse to\ntake other people's tied up funds and destroy them permanently.\n\nThere is some sort of crisis in the Bitcoin protocol stemming from the\npossible excessive usage of OP_CODESEPARTOR otherwise we wouldn't even be\nconsidering this soft fork.  Fine.  But presumably it is impossible for a\ntransaction to both be produced in good faith for legitimate use and at the\nsame time are expensive enough to be used as an attack vector, and\nhopefully there is a wide gap between these two cases.  So let's draw a\nline between the two cases to rule out attacks while allowing legitimate\nuses by simply suitably pricing the OP_CODESEPARATOR opcode by weight.  At\nworst case this moderately-large transaction is very expensive, reflecting\nits true cost, or is was so expensive that it couldn't possibly have been\nlegitimate to begin with since the resources to validate it exceed the\namount that are reasonable to validate an entire block of regular\ntransactions.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190308/b6349b97/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-08T18:35:42",
                "message_text_only": "Replies inline.\n\nOn 3/8/19 3:57 PM, Russell O'Connor wrote:\n> On Thu, Mar 7, 2019 at 2:50 PM Matt Corallo <lf-lists at mattcorallo.com \n> <mailto:lf-lists at mattcorallo.com>> wrote:\n> It's very easy to construct a practical script using OP_CODESEPARATOR.\n> \n> IF <2> <ALICEPUBKEY> <BOBPUBKEY> <2> CHECKMULTISIGVERIFY ELSE \n> CODESEPARATOR <ALICEPUBKEY> CHECKSIGVERFY ENDIF\n> \n> Now when someone hands Alice, the CFO of XYZ corp., some transaction, \n> she has the option of either signing it unilaterally herself, or \n> creating a partial signature such that the transaction additionally \n> needs Bob, the CEOs signature as well, and Alice's choice is committed \n> to the blockchain for auditing purposes later.\n> \n> Now, there are many things you might object about this scheme, but my \n> point is that (A) regardless of what you think about this scheme, it, or \n> similar schemes, may have been devised by users, and (B) users may have \n> already committed funds to such schemes, and due to P2SH you cannot know \n> that this is not the case.\n\nThe common way to set that up is to have a separate key, but, ok, fair \nenough. That said, the argument that \"it may be hidden by P2SH!\" isn't \nsufficient here. It has to *both* be hidden by P2SH and have never been \nspent from (either on mainnet or testnet) or be lock-timed a year in the \nfuture. I'm seriously skeptical that someone is using a highly esoteric \nscheme and has just been pouring money into it without ever having \ntested it or having withdrawn any money from it whatsoever. This is just \na weird argument.\n\n\n> Please don't strawman my position.\u00a0 I am not suggesting we don't fix a \n> vulnerability in Bitcoin.\u00a0 I am suggesting we find another way.\u00a0 One \n> that limits the of risk destroying other people's money.\n> \n> Here is a more concrete proposal:\u00a0 No matter how bad OP_CODESEPARATOR \n> is, it cannot be worse than instead including another input that spends \n> another identically sized UTXO.\u00a0 So how about we soft-fork in a rule \n> that says that an input's weight is increased by an amount equal to the \n> number of OP_CODESEPARATORs executed times the sum of weight of the UTXO \n> being spent and 40 bytes, the weight of a stripped input. The risk of \n> destroying other people's money is limited and AFAIU it would completely \n> address the vulnerabilities caused by OP_CODESEPARATOR.\n\nYou're already arguing that someone has such an esoteric use of script, \nsuggesting they aren't *also* creating pre-signed, long-locktimed \ntransactions with many inputs isn't much of a further stretch \n(especially since this may result in the fee being non-standardly low if \nyou artificially increase its weight).\n\nNote that \"just limit number of OP_CODESEPARATOR calls\" results in a ton \nof complexity and reduces the simple analysis that fees (almost) have \ntoday vs just removing it allows us to also remove a ton of code.\n\nFurther note that if you don't remove it getting the efficiency wins \nright is even harder because instead of being able to cache sighashes \nyou now have to (at a minimum) wipe the cache between each \nOP_CODESEPARATOR call, which results in a ton of additional \nimplementation complexity.\n\n> \n>      > I suggest an alternative whereby the execution of OP_CODESEPARATOR\n>      > increases the transactions weight suitably as to temper the\n>      > vulnerability caused by it.\u00a0 Alternatively there could be some\n>     sort of\n>      > limit (maybe 1) on the maximum number of OP_CODESEPARATORs\n>     allowed to be\n>      > executed per script, but that would require an argument as to why\n>      > exceeding that limit isn't reasonable.\n> \n>     You could equally argue, however, that any such limit could render some\n>     moderately-large transaction unspendable, so I'm somewhat skeptical of\n>     this argument. Note that OP_CODESEPARATOR is non-standard, so getting\n>     them mined is rather difficult in any case.\n> \n> \n> I already know of people who's funds are tied up due to in other changes \n> to Bitcoin Core's default relay policy.\u00a0 Non-standardness is not an \n> excuse to take other people's tied up funds and destroy them permanently.\n\nHuh?! The whole point of non-standardness in this context is to (a) make \nsoft-forking something out safer by derisking miners not upgrading right \naway and (b) signal something that may be a candidate for soft-forking \nout so that we get feedback. Who is getting things disabled who isn't \nbothering to *tell* people that their use-case is being hurt?!"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-09T18:29:24",
                "message_text_only": "Hi Matt,\n\nOn Fri, Mar 8, 2019 at 1:35 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> Replies inline.\n>\n> On 3/8/19 3:57 PM, Russell O'Connor wrote:\n> > On Thu, Mar 7, 2019 at 2:50 PM Matt Corallo <lf-lists at mattcorallo.com\n> > <mailto:lf-lists at mattcorallo.com>> wrote:\n> > It's very easy to construct a practical script using OP_CODESEPARATOR.\n> >\n> > IF <2> <ALICEPUBKEY> <BOBPUBKEY> <2> CHECKMULTISIGVERIFY ELSE\n> > CODESEPARATOR <ALICEPUBKEY> CHECKSIGVERFY ENDIF\n> >\n> > Now when someone hands Alice, the CFO of XYZ corp., some transaction,\n> > she has the option of either signing it unilaterally herself, or\n> > creating a partial signature such that the transaction additionally\n> > needs Bob, the CEOs signature as well, and Alice's choice is committed\n> > to the blockchain for auditing purposes later.\n> >\n> > Now, there are many things you might object about this scheme, but my\n> > point is that (A) regardless of what you think about this scheme, it, or\n> > similar schemes, may have been devised by users, and (B) users may have\n> > already committed funds to such schemes, and due to P2SH you cannot know\n> > that this is not the case.\n>\n> The common way to set that up is to have a separate key, but, ok, fair\n> enough. That said, the argument that \"it may be hidden by P2SH!\" isn't\n> sufficient here. It has to *both* be hidden by P2SH and have never been\n> spent from (either on mainnet or testnet) or be lock-timed a year in the\n> future. I'm seriously skeptical that someone is using a highly esoteric\n> scheme and has just been pouring money into it without ever having\n> tested it or having withdrawn any money from it whatsoever. This is just\n> a weird argument.\n>\n\nNo one is required to test their Scripts on a public testnet; they can use\nregtest. Because these transactions are non-standard on mainnet, it could\ntake years to arrange for these funds to be recovered by having their\ntransactions mined directly, or take years to become valuable enough to be\nworth bothering having them directly mined.  As I have noted elsewhere, you\ncannot first make transactions non-standard and then use the fact that you\ndon't see them being used on mainnet to justify a soft-fork.\n\nMy argument isn't weird; it is principled.  You are skeptical that any uses\nof OP_CODESEPARATOR have P2SH commitments.  I am also skeptical, and so is\neveryone reading this mailing list.  But none of us know this with\ncertainty, and it is /wrong/ for any of us to gamble with other people's\nmoney that our assumptions are true.\n\nInstead, it is this soft-fork proposal that is unprecedented. Let me\nreiterate what I posted in another thread:\n\nBitcoin has *never* made a soft-fork, since the time of Satoishi, that\ninvalidated transactions that send secured inputs to secured outputs\n(excluding uses of OP_NOP1-OP_NOP10).\n\nThe fact that Bitcoin has stuck to this principle gives me and everyone\nelse confidence in the protocol; that anyone can secure their funds by\nwhatever scheme they dream up, and deploy it without needing permission or\nanyone else to vet their Scripts. So long as they are not impairing the\nBitcoin protocol itself, the most that Bitcoin Core will do is stop\nrelaying their transactions by default.\n\nUndermining this principle means undermining what provides Bitcoin's value\nin the first place.\n\nThe problem in this particular case is that there exist valid secure\ntransactions that make use OP_CODESEPARATOR such that these transactions\nthemselves impair the Bitcoin protocol (through excessive validation costs)\nin a way that, AFAIU, is fundamental to the nature of such transactions (in\nparticular, it isn't just due to an implementation detail of Bitcoin\nCore).  Thus to fix this vulnerability we must necessarily violate the\nprinciple of not invalidating, secure transactions.  However, this fact\nisn't license to freely invalidate any transactions we want.  We ought to\nstrive to minimize the scope of violation of this principle.  Alice and Bob\nfrom XYZ. corp should be able to keep their benign transaction illustrated\nabove, and we only eliminate those transactions that actually impair the\nBitcoin protocol.\n\nThis is the perfect opportunity to show the world that Bitcoin Core simply\ndoesn't take chances when it comes to other people money.\n\n> Please don't strawman my position.  I am not suggesting we don't fix a\n> > vulnerability in Bitcoin.  I am suggesting we find another way.  One\n> > that limits the of risk destroying other people's money.\n> >\n> > Here is a more concrete proposal:  No matter how bad OP_CODESEPARATOR\n> > is, it cannot be worse than instead including another input that spends\n> > another identically sized UTXO.  So how about we soft-fork in a rule\n> > that says that an input's weight is increased by an amount equal to the\n> > number of OP_CODESEPARATORs executed times the sum of weight of the UTXO\n> > being spent and 40 bytes, the weight of a stripped input. The risk of\n> > destroying other people's money is limited and AFAIU it would completely\n> > address the vulnerabilities caused by OP_CODESEPARATOR.\n>\n> You're already arguing that someone has such an esoteric use of script,\n> suggesting they aren't *also* creating pre-signed, long-locktimed\n> transactions with many inputs isn't much of a further stretch\n> (especially since this may result in the fee being non-standardly low if\n> you artificially increase its weight).\n>\n\nThere is no consensus rule about minimum fees, and CPFP could add the more\nfees. But yes, I am saying that Alice and Bob could be building on their\ntransaction illustrated above, but not creating a many input tx that\nwouldn't fit into a block with my proposed added weight, because if their\ntransaction won't fit into a block with the added weight then it was a\nmalicious transaction to begin with.\n\nDo you not recognize the material difference between a soft-fork that\ndoubles the cost of a transaction like Alice and Bob's versus making their\ntransaction entirely illegal?\n\n\n> Note that \"just limit number of OP_CODESEPARATOR calls\" results in a ton\n> of complexity and reduces the simple analysis that fees (almost) have\n> today vs just removing it allows us to also remove a ton of code.\n\n\nFurther note that if you don't remove it getting the efficiency wins\n> right is even harder because instead of being able to cache sighashes\n> you now have to (at a minimum) wipe the cache between each\n> OP_CODESEPARATOR call, which results in a ton of additional\n> implementation complexity.\n>\n\nHow can this be \"additional\" complexity when this is how the protocol works\ntoday?  All you have to do is not change the semantics of\nOP_CODESEPARATOR.  It is literally no work.\nRegarding the efficiency wins, let me repeat myself: The performance costs\nof wiping the cached sighashs is not worse than what the performance costs\nwould be if the transaction had an additional input spending an equally\nsized UTXO.\n\n\n> >      > I suggest an alternative whereby the execution of OP_CODESEPARATOR\n> >      > increases the transactions weight suitably as to temper the\n> >      > vulnerability caused by it.  Alternatively there could be some\n> >     sort of\n> >      > limit (maybe 1) on the maximum number of OP_CODESEPARATORs\n> >     allowed to be\n> >      > executed per script, but that would require an argument as to why\n> >      > exceeding that limit isn't reasonable.\n> >\n> >     You could equally argue, however, that any such limit could render\n> some\n> >     moderately-large transaction unspendable, so I'm somewhat skeptical\n> of\n> >     this argument. Note that OP_CODESEPARATOR is non-standard, so getting\n> >     them mined is rather difficult in any case.\n> >\n> >\n> > I already know of people who's funds are tied up due to in other changes\n> > to Bitcoin Core's default relay policy.  Non-standardness is not an\n> > excuse to take other people's tied up funds and destroy them permanently.\n>\n> Huh?! The whole point of non-standardness in this context is to (a) make\n> soft-forking something out safer by derisking miners not upgrading right\n> away and (b) signal something that may be a candidate for soft-forking\n> out so that we get feedback. Who is getting things disabled who isn't\n> bothering to *tell* people that their use-case is being hurt?!\n>\n\nPeople have told me that they are hurt by some other non-standardness\nchanges and I understand that they have been sitting on those funds for\nyears.  Maybe they don't realize their is some place to complain or maybe\nthey think there must be a good reason why they are not allowed to do what\nthey were previously allowed to do.  Perhaps others don't want to risk\nblowing their pseudonymity.  Perhaps they think that attempting to undo\nsome of these non-standardness changes is futile.  I can bring up the\nspecific cases I've encountered in a new thread if you think it is\nworthwhile.\n\nRegarding OP_CODESEAPRATOR specifically, disabling the rely of such\ntransactions partially mitigates the vulnerability.  Once the vulnerability\nis properly patched, for example by suitably increasing the weight of the\noperation or opcode, we could drop the prohibition on relaying such\ntransactions.  Non-standardness is not necessarily a path to a new\nconsensus rule. We have several non-standardness rules in place that are\nnever intended to become new consensus rules.  Sometimes non-standardness\nis a temporary mitigation.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190309/9a5108cc/attachment.html>"
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2019-03-10T03:25:36",
                "message_text_only": ">\n> Instead, it is this soft-fork proposal that is unprecedented. Let me\n> reiterate what I posted in another thread:\n>\n> Bitcoin has *never* made a soft-fork, since the time of Satoishi, that\n> invalidated transactions that send secured inputs to secured outputs\n> (excluding uses of OP_NOP1-OP_NOP10).\n>\n\nThis principle was only ever a rule of thumb to protect users, not a\ncommandment from God.  It shouldn't be violated lightly, but that's why\nMatt did the legwork to show that the tradeoffs around OP_CODESEPARATOR\njustify removing it.\n\nHuh?! The whole point of non-standardness in this context is to (a) make\n>> soft-forking something out safer by derisking miners not upgrading right\n>> away and (b) signal something that may be a candidate for soft-forking\n>> out so that we get feedback. Who is getting things disabled who isn't\n>> bothering to *tell* people that their use-case is being hurt?!\n>>\n>\n> People have told me that they are hurt by some other non-standardness\n> changes and I understand that they have been sitting on those funds for\n> years.  Maybe they don't realize their is some place to complain or maybe\n> they think there must be a good reason why they are not allowed to do what\n> they were previously allowed to do.  Perhaps others don't want to risk\n> blowing their pseudonymity.  Perhaps they think that attempting to undo\n> some of these non-standardness changes is futile.  I can bring up the\n> specific cases I've encountered in a new thread if you think it is\n> worthwhile.\n>\n\nLike Matt, I understand non-standardness to be specifically for making a\ntransaction type more difficult to set the stage for a future disabling.\n\nIf anyone is actually harmed by this change, let them at least speak up\npseudonymously as others have before.  Backwards compatibility shouldn't\nmean letting imaginary implausible cases veto net-beneficial changes.\n\n\nOn Sat, Mar 9, 2019 at 5:21 PM Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Matt,\n>\n> On Fri, Mar 8, 2019 at 1:35 PM Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n>\n>> Replies inline.\n>>\n>> On 3/8/19 3:57 PM, Russell O'Connor wrote:\n>> > On Thu, Mar 7, 2019 at 2:50 PM Matt Corallo <lf-lists at mattcorallo.com\n>> > <mailto:lf-lists at mattcorallo.com>> wrote:\n>> > It's very easy to construct a practical script using OP_CODESEPARATOR.\n>> >\n>> > IF <2> <ALICEPUBKEY> <BOBPUBKEY> <2> CHECKMULTISIGVERIFY ELSE\n>> > CODESEPARATOR <ALICEPUBKEY> CHECKSIGVERFY ENDIF\n>> >\n>> > Now when someone hands Alice, the CFO of XYZ corp., some transaction,\n>> > she has the option of either signing it unilaterally herself, or\n>> > creating a partial signature such that the transaction additionally\n>> > needs Bob, the CEOs signature as well, and Alice's choice is committed\n>> > to the blockchain for auditing purposes later.\n>> >\n>> > Now, there are many things you might object about this scheme, but my\n>> > point is that (A) regardless of what you think about this scheme, it,\n>> or\n>> > similar schemes, may have been devised by users, and (B) users may have\n>> > already committed funds to such schemes, and due to P2SH you cannot\n>> know\n>> > that this is not the case.\n>>\n>> The common way to set that up is to have a separate key, but, ok, fair\n>> enough. That said, the argument that \"it may be hidden by P2SH!\" isn't\n>> sufficient here. It has to *both* be hidden by P2SH and have never been\n>> spent from (either on mainnet or testnet) or be lock-timed a year in the\n>> future. I'm seriously skeptical that someone is using a highly esoteric\n>> scheme and has just been pouring money into it without ever having\n>> tested it or having withdrawn any money from it whatsoever. This is just\n>> a weird argument.\n>>\n>\n> No one is required to test their Scripts on a public testnet; they can use\n> regtest. Because these transactions are non-standard on mainnet, it could\n> take years to arrange for these funds to be recovered by having their\n> transactions mined directly, or take years to become valuable enough to be\n> worth bothering having them directly mined.  As I have noted elsewhere, you\n> cannot first make transactions non-standard and then use the fact that you\n> don't see them being used on mainnet to justify a soft-fork.\n>\n> My argument isn't weird; it is principled.  You are skeptical that any\n> uses of OP_CODESEPARATOR have P2SH commitments.  I am also skeptical, and\n> so is everyone reading this mailing list.  But none of us know this with\n> certainty, and it is /wrong/ for any of us to gamble with other people's\n> money that our assumptions are true.\n>\n> Instead, it is this soft-fork proposal that is unprecedented. Let me\n> reiterate what I posted in another thread:\n>\n> Bitcoin has *never* made a soft-fork, since the time of Satoishi, that\n> invalidated transactions that send secured inputs to secured outputs\n> (excluding uses of OP_NOP1-OP_NOP10).\n>\n> The fact that Bitcoin has stuck to this principle gives me and everyone\n> else confidence in the protocol; that anyone can secure their funds by\n> whatever scheme they dream up, and deploy it without needing permission or\n> anyone else to vet their Scripts. So long as they are not impairing the\n> Bitcoin protocol itself, the most that Bitcoin Core will do is stop\n> relaying their transactions by default.\n>\n> Undermining this principle means undermining what provides Bitcoin's value\n> in the first place.\n>\n> The problem in this particular case is that there exist valid secure\n> transactions that make use OP_CODESEPARATOR such that these transactions\n> themselves impair the Bitcoin protocol (through excessive validation costs)\n> in a way that, AFAIU, is fundamental to the nature of such transactions (in\n> particular, it isn't just due to an implementation detail of Bitcoin\n> Core).  Thus to fix this vulnerability we must necessarily violate the\n> principle of not invalidating, secure transactions.  However, this fact\n> isn't license to freely invalidate any transactions we want.  We ought to\n> strive to minimize the scope of violation of this principle.  Alice and Bob\n> from XYZ. corp should be able to keep their benign transaction illustrated\n> above, and we only eliminate those transactions that actually impair the\n> Bitcoin protocol.\n>\n> This is the perfect opportunity to show the world that Bitcoin Core simply\n> doesn't take chances when it comes to other people money.\n>\n> > Please don't strawman my position.  I am not suggesting we don't fix a\n>> > vulnerability in Bitcoin.  I am suggesting we find another way.  One\n>> > that limits the of risk destroying other people's money.\n>> >\n>> > Here is a more concrete proposal:  No matter how bad OP_CODESEPARATOR\n>> > is, it cannot be worse than instead including another input that spends\n>> > another identically sized UTXO.  So how about we soft-fork in a rule\n>> > that says that an input's weight is increased by an amount equal to the\n>> > number of OP_CODESEPARATORs executed times the sum of weight of the\n>> UTXO\n>> > being spent and 40 bytes, the weight of a stripped input. The risk of\n>> > destroying other people's money is limited and AFAIU it would\n>> completely\n>> > address the vulnerabilities caused by OP_CODESEPARATOR.\n>>\n>> You're already arguing that someone has such an esoteric use of script,\n>> suggesting they aren't *also* creating pre-signed, long-locktimed\n>> transactions with many inputs isn't much of a further stretch\n>> (especially since this may result in the fee being non-standardly low if\n>> you artificially increase its weight).\n>>\n>\n> There is no consensus rule about minimum fees, and CPFP could add the more\n> fees. But yes, I am saying that Alice and Bob could be building on their\n> transaction illustrated above, but not creating a many input tx that\n> wouldn't fit into a block with my proposed added weight, because if their\n> transaction won't fit into a block with the added weight then it was a\n> malicious transaction to begin with.\n>\n> Do you not recognize the material difference between a soft-fork that\n> doubles the cost of a transaction like Alice and Bob's versus making their\n> transaction entirely illegal?\n>\n>\n>> Note that \"just limit number of OP_CODESEPARATOR calls\" results in a ton\n>> of complexity and reduces the simple analysis that fees (almost) have\n>> today vs just removing it allows us to also remove a ton of code.\n>\n>\n> Further note that if you don't remove it getting the efficiency wins\n>> right is even harder because instead of being able to cache sighashes\n>> you now have to (at a minimum) wipe the cache between each\n>> OP_CODESEPARATOR call, which results in a ton of additional\n>> implementation complexity.\n>>\n>\n> How can this be \"additional\" complexity when this is how the protocol\n> works today?  All you have to do is not change the semantics of\n> OP_CODESEPARATOR.  It is literally no work.\n> Regarding the efficiency wins, let me repeat myself: The performance costs\n> of wiping the cached sighashs is not worse than what the performance costs\n> would be if the transaction had an additional input spending an equally\n> sized UTXO.\n>\n>\n>> >      > I suggest an alternative whereby the execution of\n>> OP_CODESEPARATOR\n>> >      > increases the transactions weight suitably as to temper the\n>> >      > vulnerability caused by it.  Alternatively there could be some\n>> >     sort of\n>> >      > limit (maybe 1) on the maximum number of OP_CODESEPARATORs\n>> >     allowed to be\n>> >      > executed per script, but that would require an argument as to why\n>> >      > exceeding that limit isn't reasonable.\n>> >\n>> >     You could equally argue, however, that any such limit could render\n>> some\n>> >     moderately-large transaction unspendable, so I'm somewhat skeptical\n>> of\n>> >     this argument. Note that OP_CODESEPARATOR is non-standard, so\n>> getting\n>> >     them mined is rather difficult in any case.\n>> >\n>> >\n>> > I already know of people who's funds are tied up due to in other\n>> changes\n>> > to Bitcoin Core's default relay policy.  Non-standardness is not an\n>> > excuse to take other people's tied up funds and destroy them\n>> permanently.\n>>\n>> Huh?! The whole point of non-standardness in this context is to (a) make\n>> soft-forking something out safer by derisking miners not upgrading right\n>> away and (b) signal something that may be a candidate for soft-forking\n>> out so that we get feedback. Who is getting things disabled who isn't\n>> bothering to *tell* people that their use-case is being hurt?!\n>>\n>\n> People have told me that they are hurt by some other non-standardness\n> changes and I understand that they have been sitting on those funds for\n> years.  Maybe they don't realize their is some place to complain or maybe\n> they think there must be a good reason why they are not allowed to do what\n> they were previously allowed to do.  Perhaps others don't want to risk\n> blowing their pseudonymity.  Perhaps they think that attempting to undo\n> some of these non-standardness changes is futile.  I can bring up the\n> specific cases I've encountered in a new thread if you think it is\n> worthwhile.\n>\n> Regarding OP_CODESEAPRATOR specifically, disabling the rely of such\n> transactions partially mitigates the vulnerability.  Once the vulnerability\n> is properly patched, for example by suitably increasing the weight of the\n> operation or opcode, we could drop the prohibition on relaying such\n> transactions.  Non-standardness is not necessarily a path to a new\n> consensus rule. We have several non-standardness rules in place that are\n> never intended to become new consensus rules.  Sometimes non-standardness\n> is a temporary mitigation.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190309/900b7770/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-11T17:49:33",
                "message_text_only": "Hi Jacob,\n\n\n> Huh?! The whole point of non-standardness in this context is to (a) make\n>>> soft-forking something out safer by derisking miners not upgrading right\n>>> away and (b) signal something that may be a candidate for soft-forking\n>>> out so that we get feedback. Who is getting things disabled who isn't\n>>> bothering to *tell* people that their use-case is being hurt?!\n>>>\n>>\n>> People have told me that they are hurt by some other non-standardness\n>> changes and I understand that they have been sitting on those funds for\n>> years.  Maybe they don't realize their is some place to complain or maybe\n>> they think there must be a good reason why they are not allowed to do what\n>> they were previously allowed to do.  Perhaps others don't want to risk\n>> blowing their pseudonymity.  Perhaps they think that attempting to undo\n>> some of these non-standardness changes is futile.  I can bring up the\n>> specific cases I've encountered in a new thread if you think it is\n>> worthwhile.\n>>\n>\n> Like Matt, I understand non-standardness to be specifically for making a\n> transaction type more difficult to set the stage for a future disabling.\n>\n> If anyone is actually harmed by this change, let them at least speak up\n> pseudonymously as others have before.  Backwards compatibility shouldn't\n> mean letting imaginary implausible cases veto net-beneficial changes.\n>\n\nIt is so easy to say stuff like this when one's own money isn't what is at\nrisk.\n\nWhile I encourage users who would be harmed to chime in if they can,\nunfortunately, I think it is mostly wishful thinking on our part that they\nnecessarily would.  In fact, there is evidence that in practice people\ndon't.\n\nTo illustrate this, consider the example of the people affected by PR #5247\n<https://github.com/bitcoin/bitcoin/pull/5247>, which makes unparsable\npublic keys non-standard.  As far as I am aware none have commented on this\nmailing list about it yet even though I happen to know such people do exist\nbecause I've talked with them on Slack.  I believe the person I spoke with\nto took over a year (and probably more than two years) to even notice that\nthe transactions they want to redeem with are no longer standard.  To be\nfair, their money that is stuck due to PR #5247 isn't lost yet, but I'm\nskeptical they would think or know to speak up here even if their money was\non the chopping block.  The fact that they haven't been able to move their\nmoney in the last *4 years* doesn't mean they wouldn't like it back one day.\n\nWhile non-standardness is a helpful in dissuading users from committing new\nfunds to OP_CODESEPARATOR scripts, it doesn't do anything to help users\nthat may have been caught unaware by the non-standardness change.\nFurthermore, because these transactions are non-standard, anyone caught off\nguard by the change is going to have a very hard time redeeming their\nfunds, as we have already seen with PR #5247, a non-standardness change\nthat is far older than the OP_CODESERPATOR change in PR #11423\n<https://github.com/bitcoin/bitcoin/pull/11423>.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190311/4722d88f/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-12T21:08:39",
                "message_text_only": "Note that even your carve-outs for OP_NOP is not sufficient here - if you were using nSequence to tag different pre-signed transactions into categories (roughly as you suggest people may want to do with extra sighash bits) then their transactions could very easily have become un-realistically-spendable. The whole point of soft forks is that we invalidate otherwise-unused bits of the protocol. This does not seem inconsistent with the proposal here.\n\n> On Mar 9, 2019, at 13:29, Russell O'Connor <roconnor at blockstream.io> wrote:\n> Bitcoin has *never* made a soft-fork, since the time of Satoishi, that invalidated transactions that send secured inputs to secured outputs (excluding uses of OP_NOP1-OP_NOP10)."
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2019-03-12T22:39:28",
                "message_text_only": "Also, if future disabling isn't the point of making a tx type like\nOP_CODESEPARATOR non-standard - what is?  If we're committed to indefinite\nsupport of these oddball features, what do we gain by making them hard to\nuse/mine?\n\nI see questions like \"Is it possible someone's existing tx relies on this?\"\nas overly black-and-white.  We all agree it's possible: the question is how\nlikely, vs the harms of continued support - including not just security\nrisks but friction on other useful changes, safety/correctness analyses,\netc.\n\nIt is so easy to say stuff like this when one's own money isn't what is at\nrisk.\n\n\nStepping back for a second here:  I dispute this framing.  My money *is* at\nrisk, because the value of my bitcoins depends on adoption and feature\ngrowth.  And I've long viewed an absolutist, actual-known-user-indifferent\napproach to backwards compatibility as the #1 impediment to Bitcoin's\nadoption and growth.\n\nAgain, the point being not to throw caution to the wind, but that a case\nlike this where extensive research unearthed zero users, is taking caution\ntoo far.\n\n\nOn Tue, Mar 12, 2019, 5:48 PM Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Note that even your carve-outs for OP_NOP is not sufficient here - if you\n> were using nSequence to tag different pre-signed transactions into\n> categories (roughly as you suggest people may want to do with extra sighash\n> bits) then their transactions could very easily have become\n> un-realistically-spendable. The whole point of soft forks is that we\n> invalidate otherwise-unused bits of the protocol. This does not seem\n> inconsistent with the proposal here.\n>\n> > On Mar 9, 2019, at 13:29, Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n> > Bitcoin has *never* made a soft-fork, since the time of Satoishi, that\n> invalidated transactions that send secured inputs to secured outputs\n> (excluding uses of OP_NOP1-OP_NOP10).\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/a6624dfa/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-13T00:54:23",
                "message_text_only": "On Wed, Mar 13, 2019 at 12:42 AM Jacob Eliosoff via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Also, if future disabling isn't the point of making a tx type like OP_CODESEPARATOR non-standard - what is?  If we're committed to indefinite support of these oddball features, what do we gain by making them hard to use/mine?\n\nIt makes them infeasible to abuse without miner assistance... which\ndoesn't fix them, but in practice greatly reduces the risk they create\nand allows efforts improving the system to be allocated to other more\npressing issues.\n\n> I see questions like \"Is it possible someone's existing tx relies on this?\" as overly black-and-white.  We all agree it's possible: the question is how likely, vs the harms of continued support - including not just security risks but friction on other useful changes, safety/correctness analyses, etc.\n\nDon't underestimate the value of taking a principled position that\n*strongly* avoids confiscating user funds.  Among many other benefits\nbeing cautious about this avoids creating a situation where people are\ndemanding human intervention to restore improperly lost funds and the\nassociated loss of effort that would come from the effort wasted\ndebating that.\n\nIt's true that most other cryptocurrencies proceed without any such\ncaution or care-- e.g. bcash recently confiscating all funds\naccidentally sent to segwit using Bitcoin addresses because of their\nreckless address aliasing as a result of promoting the standardness\nrule that made those txn non-standard before segwit without\nconsidering the implications--, but they're not the standard we should\nhold Bitcoin to...\n\n> Again, the point being not to throw caution to the wind, but that a case like this where extensive research unearthed zero users, is taking caution too far.\n\nAll things in balance: Codeseperator and its related costs are not an\nespecially severe problem. The arguments on both side of this point\nhave enough merit to be worth discussing, at least."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-13T01:34:50",
                "message_text_only": "On Tue, Mar 12, 2019 at 6:39 PM Jacob Eliosoff <jacob.eliosoff at gmail.com>\nwrote:\n\n> Also, if future disabling isn't the point of making a tx type like\n> OP_CODESEPARATOR non-standard - what is?  If we're committed to indefinite\n> support of these oddball features, what do we gain by making them hard to\n> use/mine?\n>\n\nThe purpose of making OP_CODESEPARATOR non-standard was to partly mitigate\nthe risk of the vulnerability that OP_CODESEPARATOR induces while we\nconsider how to patch it.\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/3a355816/attachment.html>"
            },
            {
                "author": "Sjors Provoost",
                "date": "2019-03-08T19:12:29",
                "message_text_only": "> (1) It has been well documented again and again that there is desire to remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in non-segwit scripts represents a rather significant vulnerability in Bitcoin today, and (3) lots of effort has gone into attempting to find practical use-cases for OP_CODESEPARATOR's specific construction, with no successes as of yet. I strongly, strongly disagree that the highly-unlikely remote possibility that someone created something before which could be rendered unspendable is sufficient reason to not fix a vulnerability in Bitcoin today.\n> \n>> I suggest an alternative whereby the execution of OP_CODESEPARATOR increases the transactions weight suitably as to temper the vulnerability caused by it.  Alternatively there could be some sort of limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be executed per script, but that would require an argument as to why exceeding that limit isn't reasonable.\n> \n> You could equally argue, however, that any such limit could render some moderately-large transaction unspendable, so I'm somewhat skeptical of this argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined is rather difficult in any case.\n\nAlthough I'm not a fan of extra complicity, just to explore these two ideas a bit further.\n\nWhat if such a transaction:\n\n1. must have one input; and\n2. must be smaller than 400 vbytes; and\n3. must spend from a UTXO older than fork activation\n\nAdding such a contextual check seems rather painful, perhaps comparable to nLockTime. Anything more specific than the above, e.g. counting the number of OP_CODESEPARATOR calls, seems like guess work.\n\nTransaction weight currently doesn't consider OP codes, it only considers if bytes are part of the witness. Changing that to something more akin to Ethereums gas pricing sounds too complicated to even consider.\n\n\nI would also like to believe that whoever went through the trouble of using OP_CODESEPARATOR reads this list.\n\nSjors"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-08T20:14:02",
                "message_text_only": "Aside from the complexity issues here, note that for a user to be adversely affect, they probably have to have pre-signed lock-timed transactions. Otherwise, in the crazy case that such a user exists, they should have no problem claiming the funds before activation of a soft-fork (and just switching to the swgwit equivalent, or some other equivalent scheme). Thus, adding additional restrictions like tx size limits will equally break txn.\n\n> On Mar 8, 2019, at 14:12, Sjors Provoost <sjors at sprovoost.nl> wrote:\n> \n> \n>> (1) It has been well documented again and again that there is desire to remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in non-segwit scripts represents a rather significant vulnerability in Bitcoin today, and (3) lots of effort has gone into attempting to find practical use-cases for OP_CODESEPARATOR's specific construction, with no successes as of yet. I strongly, strongly disagree that the highly-unlikely remote possibility that someone created something before which could be rendered unspendable is sufficient reason to not fix a vulnerability in Bitcoin today.\n>> \n>>> I suggest an alternative whereby the execution of OP_CODESEPARATOR increases the transactions weight suitably as to temper the vulnerability caused by it.  Alternatively there could be some sort of limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be executed per script, but that would require an argument as to why exceeding that limit isn't reasonable.\n>> \n>> You could equally argue, however, that any such limit could render some moderately-large transaction unspendable, so I'm somewhat skeptical of this argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined is rather difficult in any case.\n> \n> Although I'm not a fan of extra complicity, just to explore these two ideas a bit further.\n> \n> What if such a transaction:\n> \n> 1. must have one input; and\n> 2. must be smaller than 400 vbytes; and\n> 3. must spend from a UTXO older than fork activation\n> \n> Adding such a contextual check seems rather painful, perhaps comparable to nLockTime. Anything more specific than the above, e.g. counting the number of OP_CODESEPARATOR calls, seems like guess work.\n> \n> Transaction weight currently doesn't consider OP codes, it only considers if bytes are part of the witness. Changing that to something more akin to Ethereums gas pricing sounds too complicated to even consider.\n> \n> \n> I would also like to believe that whoever went through the trouble of using OP_CODESEPARATOR reads this list.\n> \n> Sjors\n>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-03-10T14:25:47",
                "message_text_only": "Opinion: Lock in a blockheight to get rid of it 10 years in the future. Use it as press that Bitcoin is going to lose $1,000,000 if some mystery person does not put their transaction through by then, try for global presses. Use the opportunity to get rid of it while you are able. Once gazetted anything is public knowledge.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Saturday, 9 March 2019 7:14 AM\nTo: Sjors Provoost\nCc: Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great Consensus Cleanup\n\nAside from the complexity issues here, note that for a user to be adversely affect, they probably have to have pre-signed lock-timed transactions. Otherwise, in the crazy case that such a user exists, they should have no problem claiming the funds before activation of a soft-fork (and just switching to the swgwit equivalent, or some other equivalent scheme). Thus, adding additional restrictions like tx size limits will equally break txn.\n\n> On Mar 8, 2019, at 14:12, Sjors Provoost <sjors at sprovoost.nl> wrote:\n>\n>\n>> (1) It has been well documented again and again that there is desire to remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in non-segwit scripts represents a rather significant vulnerability in Bitcoin today, and (3) lots of effort has gone into attempting to find practical use-cases for OP_CODESEPARATOR's specific construction, with no successes as of yet. I strongly, strongly disagree that the highly-unlikely remote possibility that someone created something before which could be rendered unspendable is sufficient reason to not fix a vulnerability in Bitcoin today.\n>>\n>>> I suggest an alternative whereby the execution of OP_CODESEPARATOR increases the transactions weight suitably as to temper the vulnerability caused by it.  Alternatively there could be some sort of limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be executed per script, but that would require an argument as to why exceeding that limit isn't reasonable.\n>>\n>> You could equally argue, however, that any such limit could render some moderately-large transaction unspendable, so I'm somewhat skeptical of this argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined is rather difficult in any case.\n>\n> Although I'm not a fan of extra complicity, just to explore these two ideas a bit further.\n>\n> What if such a transaction:\n>\n> 1. must have one input; and\n> 2. must be smaller than 400 vbytes; and\n> 3. must spend from a UTXO older than fork activation\n>\n> Adding such a contextual check seems rather painful, perhaps comparable to nLockTime. Anything more specific than the above, e.g. counting the number of OP_CODESEPARATOR calls, seems like guess work.\n>\n> Transaction weight currently doesn't consider OP codes, it only considers if bytes are part of the witness. Changing that to something more akin to Ethereums gas pricing sounds too complicated to even consider.\n>\n>\n> I would also like to believe that whoever went through the trouble of using OP_CODESEPARATOR reads this list.\n>\n> Sjors\n>\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190310/2a2c5be4/attachment.html>"
            },
            {
                "author": "Moral Agent",
                "date": "2019-03-10T18:24:10",
                "message_text_only": ">Lock in a blockheight to get rid of it 10 years in the future.\n\nAnd then make UTXOs containing OP_CODESEAPRATOR (etc.) and mined prior to\nthe soft fork activation standard, with weight penalties as appropriate, so\nthere would be no difficulty spending them before the cutoff?\n\nOn Sun, Mar 10, 2019 at 10:55 AM LORD HIS EXCELLENCY JAMES HRMH via\nbitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Opinion: Lock in a blockheight to get rid of it 10 years in the future.\n> Use it as press that Bitcoin is going to lose $1,000,000 if some mystery\n> person does not put their transaction through by then, try for global\n> presses. Use the opportunity to get rid of it while you are able. Once\n> gazetted anything is public knowledge.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n> ------------------------------\n> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org <\n> bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Matt Corallo\n> via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Saturday, 9 March 2019 7:14 AM\n> *To:* Sjors Provoost\n> *Cc:* Bitcoin Protocol Discussion\n> *Subject:* Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great\n> Consensus Cleanup\n>\n> Aside from the complexity issues here, note that for a user to be\n> adversely affect, they probably have to have pre-signed lock-timed\n> transactions. Otherwise, in the crazy case that such a user exists, they\n> should have no problem claiming the funds before activation of a soft-fork\n> (and just switching to the swgwit equivalent, or some other equivalent\n> scheme). Thus, adding additional restrictions like tx size limits will\n> equally break txn.\n>\n> > On Mar 8, 2019, at 14:12, Sjors Provoost <sjors at sprovoost.nl> wrote:\n> >\n> >\n> >> (1) It has been well documented again and again that there is desire to\n> remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in\n> non-segwit scripts represents a rather significant vulnerability in Bitcoin\n> today, and (3) lots of effort has gone into attempting to find practical\n> use-cases for OP_CODESEPARATOR's specific construction, with no successes\n> as of yet. I strongly, strongly disagree that the highly-unlikely remote\n> possibility that someone created something before which could be rendered\n> unspendable is sufficient reason to not fix a vulnerability in Bitcoin\n> today.\n> >>\n> >>> I suggest an alternative whereby the execution of OP_CODESEPARATOR\n> increases the transactions weight suitably as to temper the vulnerability\n> caused by it.  Alternatively there could be some sort of limit (maybe 1) on\n> the maximum number of OP_CODESEPARATORs allowed to be executed per script,\n> but that would require an argument as to why exceeding that limit isn't\n> reasonable.\n> >>\n> >> You could equally argue, however, that any such limit could render some\n> moderately-large transaction unspendable, so I'm somewhat skeptical of this\n> argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined\n> is rather difficult in any case.\n> >\n> > Although I'm not a fan of extra complicity, just to explore these two\n> ideas a bit further.\n> >\n> > What if such a transaction:\n> >\n> > 1. must have one input; and\n> > 2. must be smaller than 400 vbytes; and\n> > 3. must spend from a UTXO older than fork activation\n> >\n> > Adding such a contextual check seems rather painful, perhaps comparable\n> to nLockTime. Anything more specific than the above, e.g. counting the\n> number of OP_CODESEPARATOR calls, seems like guess work.\n> >\n> > Transaction weight currently doesn't consider OP codes, it only\n> considers if bytes are part of the witness. Changing that to something more\n> akin to Ethereums gas pricing sounds too complicated to even consider.\n> >\n> >\n> > I would also like to believe that whoever went through the trouble of\n> using OP_CODESEPARATOR reads this list.\n> >\n> > Sjors\n> >\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190310/a82ceff6/attachment-0001.html>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-03-12T07:34:55",
                "message_text_only": "I have not seen all of the emails in reply come through on the mailing list, I am sure it is always that way. There are a couple to reply to, replies indented>:\n\nOn Mon, Mar 11, 2019 at 12:47 PM Dustin Dettmer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nWhat about putting it in a deprecated state for some time. Adjust the transaction weight so using the op code is more expensive (10x, 20x?) and get the word out that it will be removed in the future.\n\nYou could even have nodes send a reject code with the message \u201cOP_CODESEPARATOR is depcrecated.\u201d\n>Yes, that sort of thing, widely publicised. Positive publicity is a good thing.\n\n\nFrom: Moral Agent via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSent: Monday, 11 March 2019 5:24 AM\nTo: LORD HIS EXCELLENCY JAMES HRMH; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great Consensus Cleanup\n\n>Lock in a blockheight to get rid of it 10 years in the future.\n\nAnd then make UTXOs containing OP_CODESEAPRATOR (etc.) and mined prior to the soft fork activation standard, with weight penalties as appropriate, so there would be no difficulty spending them before the cutoff?\n>Yes, precisely that sort of thing so that there is no difficulty spending the UTXOs before the cutoff, preferably we would never prevent spending existing valid transactions in the blockchain, also not only to morally discourage the creation of new transactions with OP_CODESEAPRATOR but to physically prevent them if possible. At the minimum, 10 years of depreciated notifications should be enough for anyone but pre-signed lock-timed transactions may be a different matter. Do we currently allow them to be mined and the UTXO's not valid to be spent until n height/time? We should.\n\nOn Sun, Mar 10, 2019 at 10:55 AM LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n\nOpinion: Lock in a blockheight to get rid of it 10 years in the future. Use it as press that Bitcoin is going to lose $1,000,000 if some mystery person does not put their transaction through by then, try for global presses. Use the opportunity to get rid of it while you are able. Once gazetted anything is public knowledge.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> <bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>> on behalf of Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSent: Saturday, 9 March 2019 7:14 AM\nTo: Sjors Provoost\nCc: Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great Consensus Cleanup\n\nAside from the complexity issues here, note that for a user to be adversely affect, they probably have to have pre-signed lock-timed transactions. Otherwise, in the crazy case that such a user exists, they should have no problem claiming the funds before activation of a soft-fork (and just switching to the swgwit equivalent, or some other equivalent scheme). Thus, adding additional restrictions like tx size limits will equally break txn.\n\n> On Mar 8, 2019, at 14:12, Sjors Provoost <sjors at sprovoost.nl<mailto:sjors at sprovoost.nl>> wrote:\n>\n>\n>> (1) It has been well documented again and again that there is desire to remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in non-segwit scripts represents a rather significant vulnerability in Bitcoin today, and (3) lots of effort has gone into attempting to find practical use-cases for OP_CODESEPARATOR's specific construction, with no successes as of yet. I strongly, strongly disagree that the highly-unlikely remote possibility that someone created something before which could be rendered unspendable is sufficient reason to not fix a vulnerability in Bitcoin today.\n>>\n>>> I suggest an alternative whereby the execution of OP_CODESEPARATOR increases the transactions weight suitably as to temper the vulnerability caused by it.  Alternatively there could be some sort of limit (maybe 1) on the maximum number of OP_CODESEPARATORs allowed to be executed per script, but that would require an argument as to why exceeding that limit isn't reasonable.\n>>\n>> You could equally argue, however, that any such limit could render some moderately-large transaction unspendable, so I'm somewhat skeptical of this argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined is rather difficult in any case.\n>\n> Although I'm not a fan of extra complicity, just to explore these two ideas a bit further.\n>\n> What if such a transaction:\n>\n> 1. must have one input; and\n> 2. must be smaller than 400 vbytes; and\n> 3. must spend from a UTXO older than fork activation\n>\n> Adding such a contextual check seems rather painful, perhaps comparable to nLockTime. Anything more specific than the above, e.g. counting the number of OP_CODESEPARATOR calls, seems like guess work.\n>\n> Transaction weight currently doesn't consider OP codes, it only considers if bytes are part of the witness. Changing that to something more akin to Ethereums gas pricing sounds too complicated to even consider.\n>\n>\n> I would also like to believe that whoever went through the trouble of using OP_CODESEPARATOR reads this list.\n>\n> Sjors\n>\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/f4b775ac/attachment-0001.html>"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-03-10T18:28:25",
                "message_text_only": "What about putting it in a deprecated state for some time. Adjust the\ntransaction weight so using the op code is more expensive (10x, 20x?) and\nget the word out that it will be removed in the future.\n\nYou could even have nodes send a reject code with the message\n\u201cOP_CODESEPARATOR is depcrecated.\u201d\n\nOn Sun, Mar 10, 2019 at 7:55 AM LORD HIS EXCELLENCY JAMES HRMH via\nbitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Opinion: Lock in a blockheight to get rid of it 10 years in the future.\n> Use it as press that Bitcoin is going to lose $1,000,000 if some mystery\n> person does not put their transaction through by then, try for global\n> presses. Use the opportunity to get rid of it while you are able. Once\n> gazetted anything is public knowledge.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n>\n> ------------------------------\n> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org <\n> bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Matt Corallo\n> via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Saturday, 9 March 2019 7:14 AM\n> *To:* Sjors Provoost\n> *Cc:* Bitcoin Protocol Discussion\n> *Subject:* Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great\n> Consensus Cleanup\n>\n> Aside from the complexity issues here, note that for a user to be\n> adversely affect, they probably have to have pre-signed lock-timed\n> transactions. Otherwise, in the crazy case that such a user exists, they\n> should have no problem claiming the funds before activation of a soft-fork\n> (and just switching to the swgwit equivalent, or some other equivalent\n> scheme). Thus, adding additional restrictions like tx size limits will\n> equally break txn.\n>\n> > On Mar 8, 2019, at 14:12, Sjors Provoost <sjors at sprovoost.nl> wrote:\n> >\n> >\n> >> (1) It has been well documented again and again that there is desire to\n> remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in\n> non-segwit scripts represents a rather significant vulnerability in Bitcoin\n> today, and (3) lots of effort has gone into attempting to find practical\n> use-cases for OP_CODESEPARATOR's specific construction, with no successes\n> as of yet. I strongly, strongly disagree that the highly-unlikely remote\n> possibility that someone created something before which could be rendered\n> unspendable is sufficient reason to not fix a vulnerability in Bitcoin\n> today.\n> >>\n> >>> I suggest an alternative whereby the execution of OP_CODESEPARATOR\n> increases the transactions weight suitably as to temper the vulnerability\n> caused by it.  Alternatively there could be some sort of limit (maybe 1) on\n> the maximum number of OP_CODESEPARATORs allowed to be executed per script,\n> but that would require an argument as to why exceeding that limit isn't\n> reasonable.\n> >>\n> >> You could equally argue, however, that any such limit could render some\n> moderately-large transaction unspendable, so I'm somewhat skeptical of this\n> argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined\n> is rather difficult in any case.\n> >\n> > Although I'm not a fan of extra complicity, just to explore these two\n> ideas a bit further.\n> >\n> > What if such a transaction:\n> >\n> > 1. must have one input; and\n> > 2. must be smaller than 400 vbytes; and\n> > 3. must spend from a UTXO older than fork activation\n> >\n> > Adding such a contextual check seems rather painful, perhaps comparable\n> to nLockTime. Anything more specific than the above, e.g. counting the\n> number of OP_CODESEPARATOR calls, seems like guess work.\n> >\n> > Transaction weight currently doesn't consider OP codes, it only\n> considers if bytes are part of the witness. Changing that to something more\n> akin to Ethereums gas pricing sounds too complicated to even consider.\n> >\n> >\n> > I would also like to believe that whoever went through the trouble of\n> using OP_CODESEPARATOR reads this list.\n> >\n> > Sjors\n> >\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190310/a327b977/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-11T19:15:38",
                "message_text_only": "Increasing the OP_CODESEPARATOR weight by 520 (p2sh redeemScript size\nlimit) + 40 (stripped txinput size) + 8 (stripped txoutput size) + a few\nmore (overhead for varints) = 572ish bytes should be enough to completely\neliminate any vulnerability caused by OP_CODESEPARATOR within P2SH\ntransactions without the need to remove it ever.  I think it is worth\nattempting to be a bit more clever than such a blunt rule, but it would be\nmuch better than eliminating OP_CODESEPARATOR within P2SH entirely.\n\nRemember that the goal isn't to eliminate OP_CODESEPARATOR per se; the goal\nis to eliminate the vulnerability associated with it.\n\nOn Mon, Mar 11, 2019 at 12:47 PM Dustin Dettmer via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> What about putting it in a deprecated state for some time. Adjust the\n> transaction weight so using the op code is more expensive (10x, 20x?) and\n> get the word out that it will be removed in the future.\n>\n> You could even have nodes send a reject code with the message\n> \u201cOP_CODESEPARATOR is depcrecated.\u201d\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190311/f2053d43/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-12T02:23:33",
                "message_text_only": "I think you may have misunderstood part of the motivation. Yes, part of the motivation *is* to remove OP_CODESEPARATOR wholesale, greatly simplifying the theoretical operation of checksig operations (thus somewhat simplifying the implementation but also simplifying analysis of future changes, such as sighash-caching code).\n\nI think a key part of the analysis here is that no one I've spoken to (and we've been discussing removing it for *years*, including many attempts at coming up with reasons to keep it) is aware of any real proposals to use OP_CODESEPARATOR, let alone anyone using it in the wild. Hiding data in invalid pubic keys is a long-discussed-and-implemented idea (despite it's discouragement, not to mention it appears on the chain in many places).\n\nIt would end up being a huge shame to have all the OP_CORESEPARATOR mess left around after all the effort that has gone into removing it for the past few years, especially given the stark difference in visibility of a fork when compared to a standardness change.\n\nAs for your specific proposal of increasing the weight of anything that has an OP_CODESEPARATOR in it by the cost of an additional (simple) input, this doesn't really solve the issue. After all, if we're assuming some user exists who has been using sending money, unspent, to scripts with OP_CODESEPARATOR to force signatures to commit to whether some other signature was present and who won't see a (invariably media-covered) pending soft-fork in time to claim their funds, we should also assume such a user has pre-signed transactions which are time-locked and claim a number of inputs and have several paths in the script which contain OP_CODESEPARATOR, rendering their transcription invalid.\n\nMatt\n\n> On Mar 11, 2019, at 15:15, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Increasing the OP_CODESEPARATOR weight by 520 (p2sh redeemScript size limit) + 40 (stripped txinput size) + 8 (stripped txoutput size) + a few more (overhead for varints) = 572ish bytes should be enough to completely eliminate any vulnerability caused by OP_CODESEPARATOR within P2SH transactions without the need to remove it ever.  I think it is worth attempting to be a bit more clever than such a blunt rule, but it would be much better than eliminating OP_CODESEPARATOR within P2SH entirely.\n> \n> Remember that the goal isn't to eliminate OP_CODESEPARATOR per se; the goal is to eliminate the vulnerability associated with it.\n> \n>> On Mon, Mar 11, 2019 at 12:47 PM Dustin Dettmer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> What about putting it in a deprecated state for some time. Adjust the transaction weight so using the op code is more expensive (10x, 20x?) and get the word out that it will be removed in the future.\n>> \n>> You could even have nodes send a reject code with the message \u201cOP_CODESEPARATOR is depcrecated.\u201d\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190311/c54f0308/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-13T01:38:44",
                "message_text_only": "Hi Matt,\n\nOn Mon, Mar 11, 2019 at 10:23 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> I think you may have misunderstood part of the motivation. Yes, part of\n> the motivation *is* to remove OP_CODESEPARATOR wholesale, greatly\n> simplifying the theoretical operation of checksig operations (thus somewhat\n> simplifying the implementation but also simplifying analysis of future\n> changes, such as sighash-caching code).\n>\n\nI see.  I was under the mistaken impression the concerns about of\nOP_CODESEPARATOR was simply due to the vulnerability it induces.\n\nI'll say it now then: Simplifying the theoretical operation of Bitcoin is\nnot a sufficient reason to make changes to the consensus rules, and it is\nmost certainly not a sufficient reason to remove usable op codes.\n\nHad I understood that this was your motivation I would have presented my\nopinion earlier. I understand that the OP_CODESEPARATOR vulnerability is\nquite serious and making it non-standard while we address the problem is a\ngood idea (hence the reason why I never objected before now).\n\nWhat I don't understand is why you feel that avoiding flushing the sigcache\nis so critical that you are willing to go through a risky consensus change\njust to achieve it?  The sigcache is effectively flushed for each input of\na transaction anyways, so what's the big deal about flushing it during\nScript execution as well?\n\n\n> I think a key part of the analysis here is that no one I've spoken to (and\n> we've been discussing removing it for *years*, including many attempts at\n> coming up with reasons to keep it) is aware of any real proposals to use\n> OP_CODESEPARATOR, let alone anyone using it in the wild. Hiding data in\n> invalid pubic keys is a long-discussed-and-implemented idea (despite it's\n> discouragement, not to mention it appears on the chain in many places).\n>\n\nWell you've spoken to me now, and I believe I have given you good reasons\nto keep it.  We all used to think that OP_CODESEPARATOR was a useless\noperation that no one in their right mind would ever use, but it turns out\nthat we were wrong.  Lesson learned.  We should be more humble about\nconsidering these sorts of changes in the future because it seems we might\nnot understand Bitcoin as well as we think we do.  At the very least I was\ncaught by surprise by the utility of OP_CODESEPARATOR.\n\nYou misunderstand my point regarding invalid public keys.  My point is that\nif no one has spoken up about the invalid public key issue on this mailing\nlist, something that we know really does affects people, why do you expect\nthat people would have spoken up about OP_CODESEPARATATOR affecting them?\n\n\n> It would end up being a huge shame to have all the OP_CORESEPARATOR mess\n> left around after all the effort that has gone into removing it for the\n> past few years, especially given the stark difference in visibility of a\n> fork when compared to a standardness change.\n>\n> As for your specific proposal of increasing the weight of anything that\n> has an OP_CODESEPARATOR in it by the cost of an additional (simple) input,\n> this doesn't really solve the issue. After all, if we're assuming some user\n> exists who has been using sending money, unspent, to scripts with\n> OP_CODESEPARATOR to force signatures to commit to whether some other\n> signature was present and who won't see a (invariably media-covered)\n> pending soft-fork in time to claim their funds, we should also assume such\n> a user has pre-signed transactions which are time-locked and claim a number\n> of inputs and have several paths in the script which contain\n> OP_CODESEPARATOR, rendering their transcription invalid.\n>\n\nAgreed, that's why we will want to not simply count the OP_CODESEPARATORS,\nbut rather count the maximum number of OP_CODESEPARATORS that can be\nexecuted through the any of the various possible OP_IF branches.  Adding\nthis sort of control-flow analysis is a pretty simple. It just requires a\nsmall stack of pairs of numbers and linear traversal through the Script.\nThis sort of OP_IF control flow analysis ought to have been done for\ncounting CHECKSIG operations, but unfortunately it is too late for that\nnow.  I could prototype the sort of analysis I have in mind if you think\nthat would be helpful.\n\nIn fact, it is really alternating uses of OP_CODESEPARATOR and CheckSig\noperations that is problematic, so it is probably worth attempting to count\nthese pairs rather than just OP_CODESEPARATORS.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/9f963552/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-09T18:29:15",
                "message_text_only": "Hi Sjors,\n\nOn Fri, Mar 8, 2019 at 2:12 PM Sjors Provoost <sjors at sprovoost.nl> wrote:\n\n> Transaction weight currently doesn't consider OP codes, it only considers\n> if bytes are part of the witness. Changing that to something more akin to\n> Ethereums gas pricing sounds too complicated to even consider.\n>\n\nI did say per executed OP_CODESEPARATOR, but upon reflection, I agree that\nwe'd like to know the weight without execution.  I think counting the\nnumber of occurrences of OP_CODESEPARATOR (perhaps at the same time we\ncount OP_CHECKSIG operations?) is a reasonable compromise, and increasing\nthe weight according to my proposed formula based on that count (ideally\nwe'd take OP_IF branches into account).\n\n\n> I would also like to believe that whoever went through the trouble of\n> using OP_CODESEPARATOR reads this list.\n>\n\nI wish this were the case too, but I don't think it is reasonable to assume\nthat (even maaku isn't subscribed\n<https://github.com/bitcoin/bitcoin/pull/15482#issuecomment-469836918>),\nand I don't even think it is fair to assume such a someone necessarily even\nspeaks English.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190309/4e7a369f/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-10T15:22:44",
                "message_text_only": "I fear that we cannot simply wait 10 years to address the vulnerability\nthat OP_CODESEPARATOR has in its current form.\n\nOn Fri, Mar 8, 2019 at 7:32 PM LORD HIS EXCELLENCY JAMES HRMH <\nwilltech at live.com.au> wrote:\n\n> Opinion: Lock in a blockheight to get rid of it 10 years in the future.\n> Use it as press that Bitcoin is going to lose $1,000,000 if some mystery\n> person does not put their transaction through by then, try for global\n> presses. Use the opportunity to get rid of it while you are able. Once\n> gazetted anything is public knowledge.\n>\n> Regards,\n> LORD HIS EXCELLENCY JAMES HRMH\n> ------------------------------\n> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org <\n> bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Sjors\n> Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Saturday, 9 March 2019 6:12 AM\n> *To:* Matt Corallo; Russell O'Connor; Bitcoin Protocol Discussion\n> *Subject:* Re: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great\n> Consensus Cleanup\n>\n>\n> > (1) It has been well documented again and again that there is desire to\n> remove OP_CODESEPARATOR, (2) it is well-documented OP_CODESEPARATOR in\n> non-segwit scripts represents a rather significant vulnerability in Bitcoin\n> today, and (3) lots of effort has gone into attempting to find practical\n> use-cases for OP_CODESEPARATOR's specific construction, with no successes\n> as of yet. I strongly, strongly disagree that the highly-unlikely remote\n> possibility that someone created something before which could be rendered\n> unspendable is sufficient reason to not fix a vulnerability in Bitcoin\n> today.\n> >\n> >> I suggest an alternative whereby the execution of OP_CODESEPARATOR\n> increases the transactions weight suitably as to temper the vulnerability\n> caused by it.  Alternatively there could be some sort of limit (maybe 1) on\n> the maximum number of OP_CODESEPARATORs allowed to be executed per script,\n> but that would require an argument as to why exceeding that limit isn't\n> reasonable.\n> >\n> > You could equally argue, however, that any such limit could render some\n> moderately-large transaction unspendable, so I'm somewhat skeptical of this\n> argument. Note that OP_CODESEPARATOR is non-standard, so getting them mined\n> is rather difficult in any case.\n>\n> Although I'm not a fan of extra complicity, just to explore these two\n> ideas a bit further.\n>\n> What if such a transaction:\n>\n> 1. must have one input; and\n> 2. must be smaller than 400 vbytes; and\n> 3. must spend from a UTXO older than fork activation\n>\n> Adding such a contextual check seems rather painful, perhaps comparable to\n> nLockTime. Anything more specific than the above, e.g. counting the number\n> of OP_CODESEPARATOR calls, seems like guess work.\n>\n> Transaction weight currently doesn't consider OP codes, it only considers\n> if bytes are part of the witness. Changing that to something more akin to\n> Ethereums gas pricing sounds too complicated to even consider.\n>\n>\n> I would also like to believe that whoever went through the trouble of\n> using OP_CODESEPARATOR reads this list.\n>\n> Sjors\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190310/f202bcfa/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "OP_CODESEPARATOR Re: BIP Proposal: The Great Consensus Cleanup",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Dustin Dettmer",
                "Russell O'Connor",
                "Gregory Maxwell",
                "Sjors Provoost",
                "Matt Corallo",
                "Moral Agent",
                "Jacob Eliosoff"
            ],
            "messages_count": 22,
            "total_messages_chars_count": 81573
        }
    },
    {
        "title": "[bitcoin-dev] Sighash Type Byte; Re: BIP Proposal: The Great Consensus Cleanup",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2019-03-07T15:16:43",
                "message_text_only": "> * If the sighash type byte (ie last byte in a signature being evaluated\n> during the execution of OP_CHECKSIG[VERIFY] or OP_CHECKMULTISIG[VERIFY])\n> is anything other than 1, 2, 3, 0x81, 0x82, or 0x83, the script\n> execution fails. This does not apply to 0-length signature stack elements.\n>\n\nThe sighash type byte is a \"great\" place to store a few bits of ancillary\ndata when making signatures.  Okay it isn't great, but it is good enough\nthat some misguided users may have been using it and have unbroadcast\ntransactions in cold storage (think sweeps) for UTXOs whose private keys\nmay have been lost.  I don't think that one's hunch that there isn't much\nrisk in disabling these sighashes is good enough to put people funds at\nrisk, especially given the alternative proposal of caching the\njust-before-the-last-byte sighash midstate that is available.\n\n-- \nRussell O'Connor\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190307/147c2ccd/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-07T19:57:29",
                "message_text_only": "I can't say I'm particularly married to this idea (hence the alternate \nproposal in the original email), but at the same time the lack of \nexisting transactions using these bits (and the redundancy thereof - \nthey don't *do* anything special) seems to be pretty strong indication \nthat they are not in use. One could argue a similarity between these \nbits and OP_NOPs - no one is going to create transactions that require \nOP_NOP execution to be valid as they are precisely the kind of thing \nthat may get soft-forked to have a new meaning. While the sighash bits \nare somewhat less candidates for soft-forking, I don't think \"someone \nmay have shoved random bits into parts of their \nlocked-for-more-than-a-year transactions\" is sufficient reason to not \nsoft-fork something out. Obviously, actually *seeing* it used in \npractice or trying to fork them out in a fast manner would be \nunacceptable, but neither is being proposed here.\n\nMatt\n\nOn 3/7/19 3:16 PM, Russell O'Connor wrote:\n> \n>     * If the sighash type byte (ie last byte in a signature being evaluated\n>     during the execution of OP_CHECKSIG[VERIFY] or\n>     OP_CHECKMULTISIG[VERIFY])\n>     is anything other than 1, 2, 3, 0x81, 0x82, or 0x83, the script\n>     execution fails. This does not apply to 0-length signature stack\n>     elements.\n> \n> \n> The sighash type byte is a \"great\" place to store a few bits of \n> ancillary data when making signatures.\u00a0 Okay it isn't great, but it is \n> good enough that some misguided users may have been using it and have \n> unbroadcast transactions in cold storage (think sweeps) for UTXOs whose \n> private keys may have been lost.\u00a0 I don't think that one's hunch that \n> there isn't much risk in disabling these sighashes is good enough to put \n> people funds at risk, especially given the alternative proposal of \n> caching the just-before-the-last-byte sighash midstate that is available."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-08T15:57:14",
                "message_text_only": "On Thu, Mar 7, 2019 at 2:57 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> I can't say I'm particularly married to this idea (hence the alternate\n> proposal in the original email), but at the same time the lack of\n> existing transactions using these bits (and the redundancy thereof -\n> they don't *do* anything special) seems to be pretty strong indication\n> that they are not in use. One could argue a similarity between these\n> bits and OP_NOPs - no one is going to create transactions that require\n> OP_NOP execution to be valid as they are precisely the kind of thing\n> that may get soft-forked to have a new meaning. While the sighash bits\n> are somewhat less candidates for soft-forking,\n\n\nI don't think \"somewhat less candidates for soft-forking\" is a fair\ndescription.  These bits essentially unsuitable for soft-forking within\nlegacy Script.\n\nI don't think \"someone\n> may have shoved random bits into parts of their\n> locked-for-more-than-a-year transactions\" is sufficient reason to not\n> soft-fork something out.\n\n\nI disagree. It is sufficient.\n\nWhen was the last time Bitcoin soft-forked out working transactions that\nsent funds from securely held UTXOs to securely held UTXOs (aside from\nthose secured by Scripts using the reserved OP_NOP1-OP_NOP10)?  AFAIK it\nhas never occurred since the time of Satoshi, even for the most\nhypothetical of transactions.  It is my understanding is that Bitcoin Core\nwould never do such a thing unless the security of Bitcoin protocol itself\nwas under existential threat (see OP_CODESEPARATOR) and even then Bitcoin\nCore would only soft-fork out the minimal amount necessary to safely\ndiffuse such a threat.\n\nSince the above soft-fork isn't addressing addressing any such threat (that\nI'm aware of), and could hypothetically destroy other people money, it\ncrosses a line I thought we were never supposed to cross.\n\n>\n> Obviously, actually *seeing* it used in\n> practice or trying to fork them out in a fast manner would be\n> unacceptable, but neither is being proposed here.\n>\n\nPerhaps you don't see them in used in the blockchain because the users\ntrying to use them are caught up by the fact they they are not being\nrelayed by default (violating SCRIPT_VERIFY_STRICTENC) and are having\ndifficulty redeeming them.\nYou cannot first make transactions non-standard and then use the fact that\nyou don't see them being used to justify a soft-fork.\n\nI know of users who have their funds tied up due to other changes in\nBitcoin Core's default relay policy.  I believe they waiting for their\nfunds to become valuable enough to go through the trouble of having them\ndirectly mined.  Shall we now permanently destroy their funds too, before\nthey have a chance to get their transactions mined?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190308/a036f658/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-03-13T01:34:21",
                "message_text_only": "Hi Matt,\n\n(I moved your comment to this thread, where I think it is more relevant).\n\nThis is a fair point.  I concede that as far as Sighash Type Byte is\nconcerned, the type of change is fairly similar to BIP 68 (though I don't\nthink the argument applies to OP_CODESEPARATOR).\nI might rephrase what you say as \"invalidating otherwise-unusable bits of\nthe protocol\".  I don't quite know the right phrasing that captures both\nthe insecure and redundant aspects of the protocol.  I'm willing to accept\nthat nSequence numbers (as they originally were), NOP1-NOP10 and these\nextra sighash types can all be classified as redundant aspects of the\nBitcoin protocol.\n\nI still think the alternative proposal of caching the sha256 midstate is\nthe better choice.  We should strive to avoid changing the consensus rules\nwhen we have reasonable alternatives to achieve our goals. However, I now\nsee that this proposal isn't entirely unprecedented.\n\nOn Tue, Mar 12, 2019 at 5:08 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> Note that even your carve-outs for OP_NOP is not sufficient here - if you\n> were using nSequence to tag different pre-signed transactions into\n> categories (roughly as you suggest people may want to do with extra sighash\n> bits) then their transactions could very easily have become\n> un-realistically-spendable. The whole point of soft forks is that we\n> invalidate otherwise-unused bits of the protocol. This does not seem\n> inconsistent with the proposal here.\n>\n> > On Mar 9, 2019, at 13:29, Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n> > Bitcoin has *never* made a soft-fork, since the time of Satoishi, that\n> invalidated transactions that send secured inputs to secured outputs\n> (excluding uses of OP_NOP1-OP_NOP10).\n>\n\nOn Fri, Mar 8, 2019 at 10:57 AM Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> On Thu, Mar 7, 2019 at 2:57 PM Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n>\n>> I can't say I'm particularly married to this idea (hence the alternate\n>> proposal in the original email), but at the same time the lack of\n>> existing transactions using these bits (and the redundancy thereof -\n>> they don't *do* anything special) seems to be pretty strong indication\n>> that they are not in use. One could argue a similarity between these\n>> bits and OP_NOPs - no one is going to create transactions that require\n>> OP_NOP execution to be valid as they are precisely the kind of thing\n>> that may get soft-forked to have a new meaning. While the sighash bits\n>> are somewhat less candidates for soft-forking,\n>\n>\n> I don't think \"somewhat less candidates for soft-forking\" is a fair\n> description.  These bits essentially unsuitable for soft-forking within\n> legacy Script.\n>\n> I don't think \"someone\n>> may have shoved random bits into parts of their\n>> locked-for-more-than-a-year transactions\" is sufficient reason to not\n>> soft-fork something out.\n>\n>\n> I disagree. It is sufficient.\n>\n> When was the last time Bitcoin soft-forked out working transactions that\n> sent funds from securely held UTXOs to securely held UTXOs (aside from\n> those secured by Scripts using the reserved OP_NOP1-OP_NOP10)?  AFAIK it\n> has never occurred since the time of Satoshi, even for the most\n> hypothetical of transactions.  It is my understanding is that Bitcoin Core\n> would never do such a thing unless the security of Bitcoin protocol itself\n> was under existential threat (see OP_CODESEPARATOR) and even then Bitcoin\n> Core would only soft-fork out the minimal amount necessary to safely\n> diffuse such a threat.\n>\n> Since the above soft-fork isn't addressing addressing any such threat\n> (that I'm aware of), and could hypothetically destroy other people money,\n> it crosses a line I thought we were never supposed to cross.\n>\n>>\n>> Obviously, actually *seeing* it used in\n>> practice or trying to fork them out in a fast manner would be\n>> unacceptable, but neither is being proposed here.\n>>\n>\n> Perhaps you don't see them in used in the blockchain because the users\n> trying to use them are caught up by the fact they they are not being\n> relayed by default (violating SCRIPT_VERIFY_STRICTENC) and are having\n> difficulty redeeming them.\n> You cannot first make transactions non-standard and then use the fact that\n> you don't see them being used to justify a soft-fork.\n>\n> I know of users who have their funds tied up due to other changes in\n> Bitcoin Core's default relay policy.  I believe they waiting for their\n> funds to become valuable enough to go through the trouble of having them\n> directly mined.  Shall we now permanently destroy their funds too, before\n> they have a chance to get their transactions mined?\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/753212f7/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Sighash Type Byte; Re: BIP Proposal: The Great Consensus Cleanup",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Matt Corallo"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 10744
        }
    },
    {
        "title": "[bitcoin-dev] BIP - Symbol for satoshi",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2019-03-06T23:35:49",
                "message_text_only": "On Wed, Mar 6, 2019 at 12:32 AM Amine Chakak via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> The idea has been floated around to switch to satoshi as a base unit.\n\nIf Satoshi wanted the currency units named after him, he would simply\nhave done it. I think this behaviour seems creepy and is harmful to\nBitcoin.\n\n> The lightning network uses satoshis as a base unit.\n\nIt absolutely does not. Lightning uses units of 10 picobitcoin (1e-11\nbtc), which is significantly smaller.\n\n> Pleas let me know if it would be appropriate to write a BIP for it.\n\nPlease don't."
            },
            {
                "author": "Amine Chakak",
                "date": "2019-03-06T23:59:12",
                "message_text_only": "Thank you for the answer.\n\nOn Wed, 6 Mar 2019 at 18:36, Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Wed, Mar 6, 2019 at 12:32 AM Amine Chakak via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > The idea has been floated around to switch to satoshi as a base unit.\n>\n> If Satoshi wanted the currency units named after him, he would simply\n> have done it. I think this behaviour seems creepy and is harmful to\n> Bitcoin.\n>\n> > The lightning network uses satoshis as a base unit.\n>\n> It absolutely does not. Lightning uses units of 10 picobitcoin (1e-11\n> btc), which is significantly smaller.\n>\n> > Pleas let me know if it would be appropriate to write a BIP for it.\n>\n> Please don't.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190306/ac879621/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-03-07T10:57:03",
                "message_text_only": "It is highly unikely that non-engineers will adopt scientific notation or mili/nano/pico prefixes for money. \n\nAll common currencies either have no change or one that is 1/100 of the base unit. \nThis is the convention that practically all existing finance software and non-Bitcoin related UI that deals with money assumes.\n\nIgnoring evident cultural preference and all pre-existenting finance related software is blatant Bitcoin engineering blindness.\n\nWe already had a BIP for bits, which I support for above reasons. https://github.com/bitcoin/bips/blob/master/bip-0176.mediawiki\n\nTamas Blummer\n\n> On Mar 7, 2019, at 00:35, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Wed, Mar 6, 2019 at 12:32 AM Amine Chakak via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> The idea has been floated around to switch to satoshi as a base unit.\n> \n> If Satoshi wanted the currency units named after him, he would simply\n> have done it. I think this behaviour seems creepy and is harmful to\n> Bitcoin.\n> \n>> The lightning network uses satoshis as a base unit.\n> \n> It absolutely does not. Lightning uses units of 10 picobitcoin (1e-11\n> btc), which is significantly smaller.\n> \n>> Pleas let me know if it would be appropriate to write a BIP for it.\n> \n> Please don't.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Federico Tenga",
                "date": "2019-03-07T18:10:41",
                "message_text_only": "On Thu, 7 Mar 2019 at 11:13, Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If Satoshi wanted the currency units named after him, he would simply\n> have done it. I think this behaviour seems creepy and is harmful to\n> Bitcoin.\n>\n\nI don't believe the will of Satoshi is particularly relevant on this\nmatter. Having a term everybody can converge on to express small amounts is\nvery important to improve the user experience, and satoshis seem to have\nmore chances to achieve this than scientific notations.\n\nMy main concern with satoshis as a unit is that it may sound weird/funny to\nnative Japanese speakers. It could probably be useful to have the opinion\nof some of them on this topic.\n\nRegarding the BIP to formalise the symbol for satoshi, I think that maybe\nis better to wait for something to emerge with more widespread usage (e.g.\nalready used by some wallets or service providers). The linked proposal\ndoes not seem to have sufficient support to be proposed as a standard.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190307/8be1fb29/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP - Symbol for satoshi",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Amine Chakak",
                "Tamas Blummer",
                "Gregory Maxwell",
                "Federico Tenga"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 4181
        }
    },
    {
        "title": "[bitcoin-dev] Signet",
        "thread_messages": [
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-08T05:54:46",
                "message_text_only": "Hello,\n\nAs some of you already know, I've been working on a network called\n\"signet\", which is bascially a complement to the already existing testnet,\nexcept it is completely centralized, and blocks are signed by a specific\nkey rather than using proof of work.\n\nBenefits of this:\n\n1. It is more predictable than testnet. Miners appear and disappear\nregularly, causing irregular block generation.\n\n2. Since it is centrally controlled, it is easy to perform global testing,\nsuch as reorgs (e.g. the network performs a 4 block reorg by request, or as\nscheduled).\n\n3. It is more stable than testnet, which occasionally sees several thousand\nblock reorgs.\n\n4. It is trivial to spin up (and shut down) new signets to make public\ntests where anyone can participate.\n\nAnyone can create a signet at any time, simply by creating a key pair and\ncreating a challenge (scriptPubKey). The network can then be used globally\nby anyone, assuming the creator sends some coins to the other participants.\n\nHaving a persistent signet would be beneficial in particular to services\nwhich need a stable place to test features over an extended period of time.\nMy own company implements protocols on top of Bitcoin with sidechains. We\nneed multi-node test frameworks to behave in a predictable manner (unlike\ntestnet) and with the same standardness relay policy as mainnet.\n\nSignets consist of 2 parameters: the challenge script (scriptPubKey) and\nthe solution length. (The latter is needed to retain fixed length block\nheaders, despite having an additional payload.)\n\nI propose that a default persistent \"signet1\" is created, which can be\nreplaced in future versions e.g. if the coins are unwisely used as real\nmoney, similarly to what happened to previous testnets. This signet is\npicked by default if a user includes -signet without providing any of the\nparameters mentioned above. The key holder would be someone sufficiently\ntrusted in the community, who would be willing to run the system (block\ngeneration code, faucet, etc). It could be made a little more sturdy by\nusing 1-of-N multisig as the challenge, in case 1 <= x < N of the signers\ndisappear. If people oppose this, it can be skipped, but will mean people\ncan't just jump onto signet without first tracking down parameters from\nsomewhere.\n\nImplementation-wise, the code adds an std::map with block hash to block\nsignature. This is serialized/deserialized as appropriate (Segwit witness\nstyle), which means block headers in p2p messages are (80 +\nsolution_length) bytes. Block header non-contextual check goes from\nchecking if block header hash < target to checking if the payload is a\nvalid signature for the block header hash instead.\n\nSingle commit with code (will split into commits and make PR later, but\njust to give an idea what it looks like):\nhttps://github.com/kallewoof/bitcoin/pull/4\n\nI don't think this PR is overly intrusive, and I'm hoping to be able to get\nsignet code into Bitcoin Core eventually, and am equally hopeful that devs\nof other (wallet etc) implementations will consider supporting it.\n\nFeedback requested on this.\n\nAttribution: parts of the signet code (in particular signblock and\ngetnewblockhex) were adapted from the ElementsProject/elements repository.\nWhen PR is split into atomic commits, I will put appropriate attribution\nthere.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190308/611a55b1/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-03-08T20:20:49",
                "message_text_only": "To make testing easier, it may make sense to keep the existing block header format (and PoW) and instead apply the signature rules to some field in the coinbase transaction. This means SPV clients (assuming they only connect to honest/trusted nodes) work as-is.\n\nA previous idea regarding reorgs (that I believe Greg came up with) is to allow multiple keys to sign blocks, with one signing no reorgs and one signing a reorg every few blocks, allowing users to choose the behavior they want.\n\n\n> On Mar 8, 2019, at 00:54, Karl-Johan Alm via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hello,\n> \n> As some of you already know, I've been working on a network called \"signet\", which is bascially a complement to the already existing testnet, except it is completely centralized, and blocks are signed by a specific key rather than using proof of work.\n> \n> Benefits of this:\n> \n> 1. It is more predictable than testnet. Miners appear and disappear regularly, causing irregular block generation.\n> \n> 2. Since it is centrally controlled, it is easy to perform global testing, such as reorgs (e.g. the network performs a 4 block reorg by request, or as scheduled).\n> \n> 3. It is more stable than testnet, which occasionally sees several thousand block reorgs.\n> \n> 4. It is trivial to spin up (and shut down) new signets to make public tests where anyone can participate.\n> \n> Anyone can create a signet at any time, simply by creating a key pair and creating a challenge (scriptPubKey). The network can then be used globally by anyone, assuming the creator sends some coins to the other participants.\n> \n> Having a persistent signet would be beneficial in particular to services which need a stable place to test features over an extended period of time. My own company implements protocols on top of Bitcoin with sidechains. We need multi-node test frameworks to behave in a predictable manner (unlike testnet) and with the same standardness relay policy as mainnet.\n> \n> Signets consist of 2 parameters: the challenge script (scriptPubKey) and the solution length. (The latter is needed to retain fixed length block headers, despite having an additional payload.)\n> \n> I propose that a default persistent \"signet1\" is created, which can be replaced in future versions e.g. if the coins are unwisely used as real money, similarly to what happened to previous testnets. This signet is picked by default if a user includes -signet without providing any of the parameters mentioned above. The key holder would be someone sufficiently trusted in the community, who would be willing to run the system (block generation code, faucet, etc). It could be made a little more sturdy by using 1-of-N multisig as the challenge, in case 1 <= x < N of the signers disappear. If people oppose this, it can be skipped, but will mean people can't just jump onto signet without first tracking down parameters from somewhere.\n> \n> Implementation-wise, the code adds an std::map with block hash to block signature. This is serialized/deserialized as appropriate (Segwit witness style), which means block headers in p2p messages are (80 + solution_length) bytes. Block header non-contextual check goes from checking if block header hash < target to checking if the payload is a valid signature for the block header hash instead.\n> \n> Single commit with code (will split into commits and make PR later, but just to give an idea what it looks like): https://github.com/kallewoof/bitcoin/pull/4\n> \n> I don't think this PR is overly intrusive, and I'm hoping to be able to get signet code into Bitcoin Core eventually, and am equally hopeful that devs of other (wallet etc) implementations will consider supporting it.\n> \n> Feedback requested on this.\n> \n> Attribution: parts of the signet code (in particular signblock and getnewblockhex) were adapted from the ElementsProject/elements repository. When PR is split into atomic commits, I will put appropriate attribution there.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190308/96e6fa83/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-10T00:43:43",
                "message_text_only": "Hi Matt,\n\nOn Sat, Mar 9, 2019 at 5:20 AM Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>\n> To make testing easier, it may make sense to keep the existing block header format (and PoW) and instead apply the signature rules to some field in the coinbase transaction. This means SPV clients (assuming they only connect to honest/trusted nodes) work as-is.\n\nKeeping the PoW rule and moving the signature would mean DoS attacks\nwould be trivial as anyone could mine blocks without a signature in\nthem, unless you ramped up the difficulty, which would mean it's just\nanother testnet. It's a test network, admittedly, but I think it would\nkind of defeat the purpose.\n\n> A previous idea regarding reorgs (that I believe Greg came up with) is to allow multiple keys to sign blocks, with one signing no reorgs and one signing a reorg every few blocks, allowing users to choose the behavior they want.\n\nNot sure how this would work in practice. The idea with signet is to\nhave an actual network that is occasionally reorged, i.e. it's a\nglobal network (for those participating) that everyone agrees on. Not\nsure how you would have choices there."
            },
            {
                "author": "David A. Harding",
                "date": "2019-03-10T17:01:34",
                "message_text_only": "On Sun, Mar 10, 2019 at 09:43:43AM +0900, Karl-Johan Alm via bitcoin-dev wrote:\n> Keeping the PoW rule and moving the signature would mean DoS attacks\n> would be trivial as anyone could mine blocks without a signature in\n> them\n\nSure, but anyone could also just connect their lite client to a trusted\nnode (or nodes) on signet.  The nodes would protect the clients from\nmissing/invalid-signature DoS and the clients wouldn't have to implement\nany more network-level changes than they need to now for testnet.\n\nFor people who don't want to run their own trusted signet nodes, there\ncould be a list of signet nodes run by well-known Bitcoiners (and this\ncould even be made available via a simple static dns seeder lite clients\ncould use).\n\n> On Sat, Mar 9, 2019 at 5:20 AM Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n> > A previous idea regarding reorgs (that I believe Greg came up with)\n> > is to allow multiple keys to sign blocks, with one signing no reorgs\n> > and one signing a reorg every few blocks, allowing users to choose\n> > the behavior they want.\n> \n> Not sure how this would work in practice.\n\nThis post from Maxwell could be the idea Corallo is describing:\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-August/016348.html\n\nI read it as:\n\n  - Trusted signer Alice only signs extensions of her previous blocks\n\n  - Trusted signer Bob periodically extends one of Alice's blocks\n    (either the tip or an earlier block) with a chain that grows faster\n    than Alice's chain, becoming the most-PoW chain.  At some point he\n    stops and Alice's chain overtakes Bob's fork as the most-PoW chain\n\n  - User0 who wants to ignore reorg problems starts his node with\n    -signet -signers=\"alice\", causing his node to only accept blocks\n    from Alice.\n\n  - User1 who wants to consider reorg problems starts his node with\n    -signet -signers=\"alice,bob\", causing his node to accept blocks from\n    both Alice and Bob, thus experiencing periodic reorgs.\n\n  - There can also be other signing keys for any sort of attack\n    that can be practically executed, allowing clients to test their\n    response to the attack when they want to but also ignore any\n    disruption it would otherwise cause the rest of the time.\n\n  - As an alternative to particular signing keys, there could just be\n    flags put in the header versionbits, header nonce, or generation\n    transaction indicating how the block should be classified (e.g.\n    no_reorg, reorg_max6, reorg_max144, merkle_vulnerability, special0,\n    special1, etc...)\n\n(If something like this is implemented, I propose reserving one of the\nsigning keys/classification flags for use by any of Bitcoin's more\ndevious devs in unannounced attacks.  Having to occasionally dig\nthrough weird log messages and odd blocks with other Bitcoin dorks on\nIRC in order to figure out why things went horribly sideways in our\nsignet clients sounds to me like an enjoyable experience.  :-)\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190310/fdf5c2e8/attachment-0001.sig>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-12T05:44:29",
                "message_text_only": "Hello all,\n\nI started writing code that puts the signature in the coinbase\ntransaction similar to the witness commitment, and encountered a\npotential issue. See inline comments below.\n\nOn Mon, Mar 11, 2019 at 2:02 AM David A. Harding <dave at dtrt.org> wrote:\n>\n> On Sun, Mar 10, 2019 at 09:43:43AM +0900, Karl-Johan Alm via bitcoin-dev wrote:\n> > Keeping the PoW rule and moving the signature would mean DoS attacks\n> > would be trivial as anyone could mine blocks without a signature in\n> > them\n>\n> Sure, but anyone could also just connect their lite client to a trusted\n> node (or nodes) on signet.  The nodes would protect the clients from\n> missing/invalid-signature DoS and the clients wouldn't have to implement\n> any more network-level changes than they need to now for testnet.\n>\n> For people who don't want to run their own trusted signet nodes, there\n> could be a list of signet nodes run by well-known Bitcoiners (and this\n> could even be made available via a simple static dns seeder lite clients\n> could use).\n\nThis sounds sensible. One issue here is that the \"proper\" signer will\nbe orders of magnitude slower than the fake miner when constructing\nblocks. Because the signature is now stuffed into the coinbase\ntransaction, it becomes a part of the block merkle root, so the true\nminer now has to (1) create a block, (2) sign it, (3) check if hash <\ntarget, (4) nudge nonce if not, and then repeat from step (2) until it\nfinds a valid block. I.e. it has to sign the entire thing for every\nnonce.\n\n> This post from Maxwell could be the idea Corallo is describing:\n>\n>     https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-August/016348.html\n\nThat's pretty cool. The plan I had was to set up some simple interface\nwhere anyone could \"order\" reorgs whenever they wanted to. It would\nreorg/double spend people on request (e.g. \"send 1 signetcoin to\nsignet1qfoobar and then double spend it in a reorg 3 blocks deep\") and\nso on.\n\nWith that kind of tool, I don't know if you need the alternate signing\napproach you described, but I could be mistaken."
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-13T03:23:46",
                "message_text_only": "On Fri, Mar 08, 2019 at 03:20:49PM -0500, Matt Corallo via bitcoin-dev wrote:\n> To make testing easier, it may make sense to keep the existing block header\n> format (and PoW) and instead apply the signature rules to some field in the\n> coinbase transaction.\n\nMaybe make the signature be an optional addition to the header, so\nthat you can have a \"light node\" that doesn't download/verify sigs\nand a full node that does? (So signatures just sign the traditional\n80-byte header, and aren't included in the block's tx merkle root, and\nthe prevHash reflects the hash of the previous block's 80-byte header,\nwithout the signature)\n\nI think you could do that by adding a p2p service bit to say \"send me\nsignatures if you have them / I can send you signatures\", which changes\nthe p2p encoding of the header from (ver, prev, mrkl, time, bits, nonce)\nto (ver, prev, mrkl, time, 0, nonce, bits, sig), and change header\nprocessing to ignore headers from nodes that don't have the service\nbit set?\n\nIf you did this, it might be a good idea to enforce including the previous\nblock's header signature in the current block's coinbase.\n\nCheers,\naj"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-14T01:07:20",
                "message_text_only": "Hi Anthony,\n\nOn Wed, Mar 13, 2019 at 12:23 PM Anthony Towns <aj at erisian.com.au> wrote:\n>\n> Maybe make the signature be an optional addition to the header, so\n> that you can have a \"light node\" that doesn't download/verify sigs\n> and a full node that does? (So signatures just sign the traditional\n> 80-byte header, and aren't included in the block's tx merkle root, and\n> the prevHash reflects the hash of the previous block's 80-byte header,\n> without the signature)\n\nThis seems to be what everyone around me thinks is the best approach.\nI.e. signet is a \"p2p level agreement\" that an additional signature is\nrequired for a block to be considered fully valid.\n\nIt has the added complexity that a signature-aware signet node talking\nto a non-signature-aware signet node should reject/discard headers\nsent from the peer, or you will run into situations where a node\ndoesn't know if the headers are valid or not and has to hold onto them\nindefinitely, which is a situation that currently does not occur in\n\"regular\" nets.\n\nIf you detach the signature from the header, you also end up with\ncases where a malicious user could send garbage data as the signature\nfor a valid header, forcing peers to mark that header as invalid, even\nthough it isn't. That is regardless of whether a fix is in place for\nthe above, too.\n\n> If you did this, it might be a good idea to enforce including the previous\n> block's header signature in the current block's coinbase.\n\nYeah that is one of the ideas we had early on, and I think it's a good\none to do. It doesn't mean someone cannot spam a bunch of invalid\nheaders at block height current_tip+1, but at least you can get all\nbut the latest signature now. So as long as you are able to fetch the\nlatest signature, you should theoretically be able to verify the\nentire chain just from the blocks + that one sig.\n\n-Kalle."
            },
            {
                "author": "Lautaro Dragan",
                "date": "2019-03-09T19:52:26",
                "message_text_only": "Hi Karl-Johan, my two cents:\n\nAt Po.et we use regtest to simulate reorgs in integration tests in Travis /\nCircleCI. It has proved quite useful.\n\nIn general regtest for automated testing has given us all we needed so far,\nbut I admit we have a rather simple use of Bitcoin right now (colored\ncoins).\n\nFor local development, we sometimes use a script that \"mines\" blocks in\nregtest periodically. It was my goal to also use this method in QA,\nalthough we wound up using testnet and didn't encounter any problems so far.\n\nOut of curiosity: what limitations did you find in using, for example, a\nprivate network of bitcoin core nodes running regtest? (this gives you the\nsame power as centralization without any changes or extra functionality\nrequired)\n\nEl vie., 8 de mar. de 2019 a la(s) 16:02, Karl-Johan Alm via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> escribi\u00f3:\n\n> Hello,\n>\n> As some of you already know, I've been working on a network called\n> \"signet\", which is bascially a complement to the already existing testnet,\n> except it is completely centralized, and blocks are signed by a specific\n> key rather than using proof of work.\n>\n> Benefits of this:\n>\n> 1. It is more predictable than testnet. Miners appear and disappear\n> regularly, causing irregular block generation.\n>\n> 2. Since it is centrally controlled, it is easy to perform global testing,\n> such as reorgs (e.g. the network performs a 4 block reorg by request, or as\n> scheduled).\n>\n> 3. It is more stable than testnet, which occasionally sees several\n> thousand block reorgs.\n>\n> 4. It is trivial to spin up (and shut down) new signets to make public\n> tests where anyone can participate.\n>\n> Anyone can create a signet at any time, simply by creating a key pair and\n> creating a challenge (scriptPubKey). The network can then be used globally\n> by anyone, assuming the creator sends some coins to the other participants.\n>\n> Having a persistent signet would be beneficial in particular to services\n> which need a stable place to test features over an extended period of time.\n> My own company implements protocols on top of Bitcoin with sidechains. We\n> need multi-node test frameworks to behave in a predictable manner (unlike\n> testnet) and with the same standardness relay policy as mainnet.\n>\n> Signets consist of 2 parameters: the challenge script (scriptPubKey) and\n> the solution length. (The latter is needed to retain fixed length block\n> headers, despite having an additional payload.)\n>\n> I propose that a default persistent \"signet1\" is created, which can be\n> replaced in future versions e.g. if the coins are unwisely used as real\n> money, similarly to what happened to previous testnets. This signet is\n> picked by default if a user includes -signet without providing any of the\n> parameters mentioned above. The key holder would be someone sufficiently\n> trusted in the community, who would be willing to run the system (block\n> generation code, faucet, etc). It could be made a little more sturdy by\n> using 1-of-N multisig as the challenge, in case 1 <= x < N of the signers\n> disappear. If people oppose this, it can be skipped, but will mean people\n> can't just jump onto signet without first tracking down parameters from\n> somewhere.\n>\n> Implementation-wise, the code adds an std::map with block hash to block\n> signature. This is serialized/deserialized as appropriate (Segwit witness\n> style), which means block headers in p2p messages are (80 +\n> solution_length) bytes. Block header non-contextual check goes from\n> checking if block header hash < target to checking if the payload is a\n> valid signature for the block header hash instead.\n>\n> Single commit with code (will split into commits and make PR later, but\n> just to give an idea what it looks like):\n> https://github.com/kallewoof/bitcoin/pull/4\n>\n> I don't think this PR is overly intrusive, and I'm hoping to be able to\n> get signet code into Bitcoin Core eventually, and am equally hopeful that\n> devs of other (wallet etc) implementations will consider supporting it.\n>\n> Feedback requested on this.\n>\n> Attribution: parts of the signet code (in particular signblock and\n> getnewblockhex) were adapted from the ElementsProject/elements repository.\n> When PR is split into atomic commits, I will put appropriate attribution\n> there.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190309/c16196eb/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-10T01:02:34",
                "message_text_only": "Hi Lautaro,\n\nUsing regtest is not ideal for public networks, as anyone anywhere can\njust rewrite the blockchain at their whim by mining a ton of blocks.\n\nOn Sun, Mar 10, 2019 at 4:52 AM Lautaro Dragan <lautarodragan at gmail.com> wrote:\n>\n> Hi Karl-Johan, my two cents:\n>\n> At Po.et we use regtest to simulate reorgs in integration tests in Travis / CircleCI. It has proved quite useful.\n>\n> In general regtest for automated testing has given us all we needed so far, but I admit we have a rather simple use of Bitcoin right now (colored coins).\n>\n> For local development, we sometimes use a script that \"mines\" blocks in regtest periodically. It was my goal to also use this method in QA, although we wound up using testnet and didn't encounter any problems so far.\n>\n> Out of curiosity: what limitations did you find in using, for example, a private network of bitcoin core nodes running regtest? (this gives you the same power as centralization without any changes or extra functionality required)\n>\n> El vie., 8 de mar. de 2019 a la(s) 16:02, Karl-Johan Alm via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> escribi\u00f3:\n>>\n>> Hello,\n>>\n>> As some of you already know, I've been working on a network called \"signet\", which is bascially a complement to the already existing testnet, except it is completely centralized, and blocks are signed by a specific key rather than using proof of work.\n>>\n>> Benefits of this:\n>>\n>> 1. It is more predictable than testnet. Miners appear and disappear regularly, causing irregular block generation.\n>>\n>> 2. Since it is centrally controlled, it is easy to perform global testing, such as reorgs (e.g. the network performs a 4 block reorg by request, or as scheduled).\n>>\n>> 3. It is more stable than testnet, which occasionally sees several thousand block reorgs.\n>>\n>> 4. It is trivial to spin up (and shut down) new signets to make public tests where anyone can participate.\n>>\n>> Anyone can create a signet at any time, simply by creating a key pair and creating a challenge (scriptPubKey). The network can then be used globally by anyone, assuming the creator sends some coins to the other participants.\n>>\n>> Having a persistent signet would be beneficial in particular to services which need a stable place to test features over an extended period of time. My own company implements protocols on top of Bitcoin with sidechains. We need multi-node test frameworks to behave in a predictable manner (unlike testnet) and with the same standardness relay policy as mainnet.\n>>\n>> Signets consist of 2 parameters: the challenge script (scriptPubKey) and the solution length. (The latter is needed to retain fixed length block headers, despite having an additional payload.)\n>>\n>> I propose that a default persistent \"signet1\" is created, which can be replaced in future versions e.g. if the coins are unwisely used as real money, similarly to what happened to previous testnets. This signet is picked by default if a user includes -signet without providing any of the parameters mentioned above. The key holder would be someone sufficiently trusted in the community, who would be willing to run the system (block generation code, faucet, etc). It could be made a little more sturdy by using 1-of-N multisig as the challenge, in case 1 <= x < N of the signers disappear. If people oppose this, it can be skipped, but will mean people can't just jump onto signet without first tracking down parameters from somewhere.\n>>\n>> Implementation-wise, the code adds an std::map with block hash to block signature. This is serialized/deserialized as appropriate (Segwit witness style), which means block headers in p2p messages are (80 + solution_length) bytes. Block header non-contextual check goes from checking if block header hash < target to checking if the payload is a valid signature for the block header hash instead.\n>>\n>> Single commit with code (will split into commits and make PR later, but just to give an idea what it looks like): https://github.com/kallewoof/bitcoin/pull/4\n>>\n>> I don't think this PR is overly intrusive, and I'm hoping to be able to get signet code into Bitcoin Core eventually, and am equally hopeful that devs of other (wallet etc) implementations will consider supporting it.\n>>\n>> Feedback requested on this.\n>>\n>> Attribution: parts of the signet code (in particular signblock and getnewblockhex) were adapted from the ElementsProject/elements repository. When PR is split into atomic commits, I will put appropriate attribution there.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Varunram Ganesh",
                "date": "2019-03-13T09:15:13",
                "message_text_only": "Hello Kalle,\n\nI like your idea of a signet as it would greatly help test reorgs and stuff\nwithout having to experiment with regtest. But I'm a bit concerned about\nrunning a common signet (Signet1) controlled by a trusted entity. I guess\nif someone wants to test signet on a global scale, they could spin up a\ncouple nodes in a couple places (and since it is anyway trusted, they can\nchoose to run it on centralised services like AWS). Another concern is that\nthe maintainer might have unscheduled work, emergencies, etc and that could\naffect how people test stuff on. This would also mean that we need people\nto run signet1 nodes in parallel with current testnet nodes (one could\nargue that Signet is trusted anyway and this doesn't matter, still)\n\nI'm sure you would have considered these while designing, so would be great\nto hear your thoughts.\n\nRegards,\nVarunram\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190313/e92ffff2/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-03-14T01:17:31",
                "message_text_only": "Hi Varunram,\n\nOn Wed, Mar 13, 2019 at 3:41 PM Varunram Ganesh\n<varunramganesh at gmail.com> wrote:\n>\n> I like your idea of a signet as it would greatly help test reorgs and stuff without having to experiment with regtest. But I'm a bit concerned about running a common signet (Signet1) controlled by a trusted entity. I guess if someone wants to test signet on a global scale, they could spin up a couple nodes in a couple places (and since it is anyway trusted, they can choose to run it on centralised services like AWS). Another concern is that the maintainer might have unscheduled work, emergencies, etc and that could affect how people test stuff on. This would also mean that we need people to run signet1 nodes in parallel with current testnet nodes (one could argue that Signet is trusted anyway and this doesn't matter, still)\n>\n> I'm sure you would have considered these while designing, so would be great to hear your thoughts.\n\nFor starters, I assume that the signer would run an automated script\nthat generated blocks on regular intervals without requiring manual\ninteraction. So even if the signer went on a vacation, the network\nwould keep on ticking. I also assume the signer would be running a\nfaucet service so users could get coins as needed. Ultimately though,\nif a signer ended up vanishing or being unreliable, people would just\nset up a new signet with a different signer and use that instead, so\nultimately it's not a big deal."
            }
        ],
        "thread_summary": {
            "title": "Signet",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "David A. Harding",
                "Anthony Towns",
                "Varunram Ganesh",
                "Matt Corallo",
                "Karl-Johan Alm",
                "Lautaro Dragan"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 29142
        }
    },
    {
        "title": "[bitcoin-dev] Pre BIP: Solving for spam and other abuse with an HTLB",
        "thread_messages": [
            {
                "author": "Alistair Mann",
                "date": "2019-03-11T16:01:12",
                "message_text_only": "Greetings all, \n\nI'm looking for thoughts on the BIPability of a relatively minor change, with \nan outsize benefit, with the provisional name 'Hashed Time-Locked Bond', HTLB \nfor short.\n\nThe minor change is to implement HTLC without its digest element. The outsize \nbenefit is to incentivise against spam and other abuse. In this post I'll \nintroduce the script, motivation, a working proof-of-concept site, and then \nround out addressing the desirability of a BIP.\n\nImplementation of HTLB:\nThe script takes the form: \n\n    OP_IF\n        OP_DUP OP_HASH160 <seller pubkey hash>            \n    OP_ELSE\n        <num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <buyer pubkey hash>\n    OP_ENDIF\n    OP_EQUALVERIFY\n    OP_CHECKSIG\n\nNotice that this is the script of BIP-0199 with '[HASHOP] <digest> \nOP_EQUALVERIFY' removed. \n\nA worked example. Alice is the buyer and Bob the seller. Alice knows that Bob \nis her father and that he doesn't know her new email address. She commits \n50,000 satoshis to the above script with a 24 hour timeout, then sends proof \nof that transaction along with an email reintroducing herself. Bob's MUA \nrecognises that the bond is good and alerts him to the email from a strange \nsender: he knows that if he disagrees with the implicit assertion that he will \nwant that email, he has 24 hours to redeem those funds at the sender's \nexpense. He reads the email. Bob is incentivised not to redeem against his \ndaughter though, and lets the timeout expire: Alice reclaims her funds. Carol \ndid not bond at all, so her email was refused at the server. Dave's bond of \n100 satoshis was too small to pass Bob's minimum, so his email too was refused \nat the server. Erin guaranteed 50,000 satoshis each to reach Bob and ten \nthousand others with an email offering triple-glazed windows: she's now well \non the way to losing them all.\n\nMotivation: \nThere is a transaction class we can identify as 'Good Behaviour Bonds' \ncurrently poorly served in Bitcoin*. Bail bonds and bar tabs are real world \nexemplars. Conceptually, Alice guarantees Bob she will do or be something for \na fixed period: if she complies Bob refrains from redeeming her guarantee; if \nshe does not comply Bob redeems some or all of it. It's inherent to the class \nthat Alice is incentivised within the transaction to good behaviour outside \nit. Conversely, Bob is incentivised outside the transaction to good behaviour \nwithin it. \n\nIn essence, Alice commits funds to a penalty in advance of a connection to \nBob. Alice is incentivised by getting her funds back, Bob is incentivised by \nher - and others - continued patronage. \n\nThis transaction class can protect any addressable resource. Alice can \ntherefore guarantee Bob that:\n1. Her email to him is not spam\n2. Her telephone call to him is not a robocall\n3. Her posts to his website are not flamebait.\nIn each case this is handled by extending the protocol concerned to detect for \nand change behaviour depending on Alice's proof of bond.\n\nThat Alice can guarantee her behaviour to addressable resources means she can \nalso guarantee her behaviour to non-addressable resources. She could \nguarantee:\n1. a group chat that she won't upload NSFW content\n2. an IRC channel that she won't flood\n3. a streamed multiplayer game that she won't swear over teamspeak.\nThis is accomplished by use of an addressable resource and an enforcement \nmechanism such as IRC's devoice command.\n\nAlice can also guarantee her behaviour offline in much the same way. She can \nguarantee to:\n1. a magistrate that she'll appear for trial by a given date (Bail bond/ \nSurety)\n2. a houseowner that she'll cover costs incurred from cleaning up after her \n(Rental/Security deposit)\n3. an innkeeper that she can pay for the drinks she's ordering (Bar tab)\nThat a transaction has been entered into online can be proved offline, so \nthese can be accomplished by means of an online, addressable resource and an \noffline plaintext token.\n\nLive site:\n\nI have put up a live proof-of-concept at http://berewic.com. This protects a \nspecific URL accessed through HTTP (the \"demo page\") whereby visitors who have \nposted bond on testnet3 get different content than those who have not posted \nbond, or whose bond has expired. This is accomplished through an experimental \nprotocol where an agent with a hot wallet speaks for a credentialed user in a \nsimilar way to how SMTP speaks for an email's original sender. That protocol \nwould seem to be outside the scope of the proposed BIP but I'm happy to \nelaborate if required.\n\nA short video demonstrating live use of the HTLB is also posted there. \n\nBIP:\n\nName: \"Hashed Time-Locked Bond\" seems a reasonable name - the script is still \nhashed even if the digest is gone, and HTLB nicely scans like HTLC - 1.\n\nIt won't have escaped notice that the HTLB script can be wholly written in an \nHTLC script: 'HTLB over HTLC', however there are additional reasons to \nconsider HTLB for a separate BIP:\n1. Alternative implementations using HTLB over HTLC would need to standardise \non what the redundant [HASHOP] and <digest> should be\n2. Using HTLB over HTLC is inefficient as it compels unused storage and \nunnecessary processing\n3. Amending or superceding BIP-0199 to recognise the digest element as \noptional creates backward compatibility issues\n4. Recognising the motivation onchain would help inform second-layer solutions \nwhere HTLB would be even more useful (eg, I believe that HTLCs and HTLBs do \nnot have analogues in the Lightning Network)\n5. Wallet support. A limiting factor for the live site above has been the lack \nof wallet HTLC support to the point that the demo does not implement CHECKSIG. \nHTLC & HTLB signing would ideally take place in the wallet that must be \npresent, and so a BIP would help bolster the case for, and inform anyone \nrevisiting, PR7601.\n\nThoughts?\n\n* The HTLB lives in the space somewhere near \nhttps://en.bitcoin.it/wiki/Fidelity_bonds and \nhttps://en.bitcoin.it/wiki/Contract#Example_1:_Providing_a_deposit. The former \nrequires an unnecessary sacrifice, the latter does not allow for penalisation."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-12T04:14:54",
                "message_text_only": "Good morning Alistair,\n\n>     It won't have escaped notice that the HTLB script can be wholly written in an\n>     HTLC script: 'HTLB over HTLC', however there are additional reasons to\n>     consider HTLB for a separate BIP:\n\nI believe there is indeed an important usecase for HTLB over HTLC, which is to improve the anonymity set.\nAn HTLB over HTLC would be indistinguishable onchain from other uses of HTLC; assuming that HTLCs have other uses, this is a (small?) plus to privacy.\n\nNote that the redundant <digest> would have to be given by Alice to Bob, since using a standardized one will also reveal use of HTLB over HTLC instead of hiding it among other HTLC UTXOs.\n\nAnother thing to improve privacy would be to apply the Funding Transaction pattern: https://zmnscpxj.github.io/offchain/generalized.html\n\nIn such a case, Alice would prepare two transactions, one which pays to a 2-of-2, and another which spends that 2-of-2 and pays to an HTLB (over HTLC).\nAlice would provide the second transaction to Bob, who must return a valid signature for that transaction, then place the first transaction onchain.\nThen the protocol resumes as normal.\nIf Alice and Bob both agree that the bond can be returned to Alice, then they recreate the second transaction as a normal spend from 2-of-2 to a flat P2PKH of Alice (or whatever address Alice desires), obscuring that HTLB was used at all.\n\n\nThe Funding Transaction Pattern is applicable to all constructions that have a fixed participant set, and is effectively gotten \"for free\" with Taproot (the requirement is the \"Taproot assumption\"), but is available now even without Taproot.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Alistair Mann",
                "date": "2019-03-17T16:11:29",
                "message_text_only": "Many thanks for your thoughts, ZmnSCPxj.\n\n> I believe there is indeed an important usecase for HTLB over HTLC, which is\n> to improve the anonymity set. An HTLB over HTLC would be indistinguishable\n> onchain from other uses of HTLC; assuming that HTLCs have other uses, this\n> is a (small?) plus to privacy.\n> \n> Note that the redundant <digest> would have to be given by Alice to Bob,\n> since using a standardized one will also reveal use of HTLB over HTLC\n> instead of hiding it among other HTLC UTXOs.\n\nBoth these are good observations and I'll act on them.\n \n> Another thing to improve privacy would be to apply the Funding Transaction\n> pattern: https://zmnscpxj.github.io/offchain/generalized.html\n<snip>\n\nI've not read of the FTP before; I welcome it, and take on board that it \nimproves privacy by keeping a script offline. My first thought is that doesn't \naffect the suggested BIP, so my next update here won't include it. I recognise \nit would improve mainnet use of scripts though, so do expect to return to it.\n\nCheers,\n-- \nAlistair Mann"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-18T04:22:52",
                "message_text_only": "Funding Transaction Pattern is how I name it; I am unaware if this pattern has been named before.\nI know gmax created Taproot precisely as an optimization of this pattern, so I presume he is aware of it, and might know a proper name for such.\nIt is massively ambiguous to call it \"gmax technique\" as that name could apply to many, many techniques.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, March 18, 2019 12:11 AM, Alistair Mann <al at pectw.net> wrote:\n\n> Many thanks for your thoughts, ZmnSCPxj.\n>\n> > I believe there is indeed an important usecase for HTLB over HTLC, which is\n> > to improve the anonymity set. An HTLB over HTLC would be indistinguishable\n> > onchain from other uses of HTLC; assuming that HTLCs have other uses, this\n> > is a (small?) plus to privacy.\n> > Note that the redundant <digest> would have to be given by Alice to Bob,\n> > since using a standardized one will also reveal use of HTLB over HTLC\n> > instead of hiding it among other HTLC UTXOs.\n>\n> Both these are good observations and I'll act on them.\n>\n> > Another thing to improve privacy would be to apply the Funding Transaction\n> > pattern: https://zmnscpxj.github.io/offchain/generalized.html\n>\n> <snip>\n>\n> I've not read of the FTP before; I welcome it, and take on board that it\n> improves privacy by keeping a script offline. My first thought is that doesn't\n> affect the suggested BIP, so my next update here won't include it. I recognise\n> it would improve mainnet use of scripts though, so do expect to return to it.\n>\n> Cheers,\n>\n> --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n>\n> Alistair Mann"
            },
            {
                "author": "Alistair Mann",
                "date": "2019-03-17T20:27:35",
                "message_text_only": "This update collects community feedback on my HTLB Pre-BIP\n\nAs reminder, I'm suggesting a BIP for a hitherto poorly supported class of \ntransactions: \"Good Behaviour Bonds\".\n\n1. On this mailing list:\nZmnSCPxj notes HTLB over HTLC can improve privacy by obscuring whether a \ntransaction is, in fact, an HTLB or an HTLC. This requires that the \n'redundant' <digest> and [HASHOP] be not standardised. I intend to follow that \nadvice.\n\n2. On Reddit at http://tinyurl.com/yxdketdo:\n/u/almkglor nudges me to consider if Bob could immediately fail the HTLB to \nAlice's benefit. I believe he could with something like this script:\n  OP_IF\n    OP_DUP OP_HASH160 <seller pubkey hash>            \n  OP_ELSE\n    OP_IF\n      [HASHOP] <digest> OP_EQUALVERIFY OP_DUP OP_HASH160 <buyer pubkey hash>\n    OP_ELSE\n      <num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <buyer pubkey hash>\n    OP_ENDIF\n  OP_ENDIF\n  OP_EQUALVERIFY\n  OP_CHECKSIG\nThe second OP_IF is new and would mean Bob can give Alice a [HASHOP] and \n<digest> that allows her to immediately redeem the funds. I will be modifying \nthe proof-of-concept code to investigate and prove this change.\n\nAt https://twitter.com/ChristopherA/status/1105153022206722048\n3. @mappum observes the HTLB idea is \"like proof-of-stake\". Such a succint \ncomparison of HTLB with existing work is useful to me even though HTLB has \nnothing to do with mining and PoS consensus. I'll be investigating if the PoS \npenalty system has more that can inform this BIP.\n\nI'm grateful to the above for their contributions, and also to the circa 60+ \nnon-bot visitors to the berewic.com site: quiet interest is positive. \n\nAssuming no other major changes my next update will be a formal write-up for \nthe BIP.\n\nCheers,\n-- \nAlistair Mann"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-19T00:22:25",
                "message_text_only": "Good morning Alistair,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, March 18, 2019 4:27 AM, Alistair Mann via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This update collects community feedback on my HTLB Pre-BIP\n>\n> As reminder, I'm suggesting a BIP for a hitherto poorly supported class of\n> transactions: \"Good Behaviour Bonds\".\n>\n> 1.  On this mailing list:\n>     ZmnSCPxj notes HTLB over HTLC can improve privacy by obscuring whether a\n>     transaction is, in fact, an HTLB or an HTLC. This requires that the\n>     'redundant' <digest> and [HASHOP] be not standardised. I intend to follow that\n>\n>\n> advice.\n>\n> 2. On Reddit at http://tinyurl.com/yxdketdo:\n> /u/almkglor nudges me to consider if Bob could immediately fail the HTLB to\n> Alice's benefit. I believe he could with something like this script:\n> OP_IF\n> OP_DUP OP_HASH160 <seller pubkey hash>\n> OP_ELSE\n> OP_IF\n> [HASHOP] <digest> OP_EQUALVERIFY OP_DUP OP_HASH160 <buyer pubkey hash>\n>\n>     OP_ELSE\n>       <num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <buyer pubkey hash>\n>\n>     OP_ENDIF\n>\n>\n> OP_ENDIF\n> OP_EQUALVERIFY\n> OP_CHECKSIG\n> The second OP_IF is new and would mean Bob can give Alice a [HASHOP] and\n> <digest> that allows her to immediately redeem the funds. I will be modifying\n>\n> the proof-of-concept code to investigate and prove this change.\n\n\nThe above is at odds with my suggestion to transport HTLBs over HTLCs.\nBIP-199 already exists and defines a standard template for HTLC contracts.\n\n    OP_IF\n        [HASHOP] <digest> OP_EQUALVERIFY OP_DUP OP_HASH160 <seller pubkey hash>\n    OP_ELSE\n        <num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <buyer pubkey hash>\n    OP_ENDIF\n    OP_EQUALVERIFY\n    OP_CHECKSIG\n\nTo use the above contract as HTLB:\n\n1.  Alice is the \"buyer\".\n2.  Bob is the \"seller\".\n3.  The preimage of `<digest>` is generated by Alice and given by Alice to Bob.\n\nI observe that an \"early return to Alice\" can be implemented by Bob, by taking the first branch, but sending the money back to an address Alice controls.\nSince Bob is the one who will decide whether to take the money (i.e. Alice is wasting Bob precious time and resource) or return to Alice (i.e. Alice sent the message in good faith), this decision can be made by Bob entirely without any input from Alice.\n\nSo the overall flow of the messages would be:\n\n1.  Alice sends preimage of `<digest>`, `[HASHOP]`, `<num>` and a new address that Alice controls (for purpose of \"early return\").\n2.  Alice makes transaction to the above HTLC pattern.\n3.  Bob has until `<num> [HASHOP]` to decide:\n3.1.  To claim the money for itself by taking the first branch and sending to a new address that Bob controls.\n3.2.  To return the money to Alice by taking the first branch and sending to the address Alice gave.\n4.  If Bob has not decided at the timeout, Alice can get her money back by taking the second branch.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Pre BIP: Solving for spam and other abuse with an HTLB",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Alistair Mann"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 15389
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal, Pay to Contract BIP43 Application",
        "thread_messages": [
            {
                "author": "Omar Shibli",
                "date": "2019-03-12T05:53:45",
                "message_text_only": "Dear Gregory,\n\nFirst of all, I would like to express my deep appreciation to your entire\ncraft in the FOSS ecosystem, specially in Bitcoin, even more In Blockstream.\nI think you are a brilliant engineer and very principled leader. your\nefforts are an inspiration for many, a truly enduring forever mark in\nhistory of FOSS.\n\nI've submitted fixes to your concerns here:\nhttps://github.com/bitcoin/bips/commit/b63ed0e17e872b7e7b8634591b0ddfa3dedfdc73#diff-deacf3a22d788a10ce12e4d92ee814ff\n\nWould appreciate your review.\n\nOn other note, I still think that this security fix is redundant, I believe\nCKD function (BIP32) does encapsulate sufficient amount of entropy, but due\nto lack of formal knowledge and assistance, I've not managed to get formal\nproof, so I fallback'ed to add this patch for security reasons.\n\nBest regards,\nOmar\n\n\n\n\n\nOn Fri, Sep 1, 2017 at 10:16 AM Omar Shibli <omarshib at gmail.com> wrote:\n\n> Hello Gregory,\n>\n> Thanks for you feedback.\n>\n> The BIP has been updated to explicitly specify the multiparty key\n> derivation scheme which hopefully addresses your concerns.\n>\n> Please have a look at the updated draft of the BIP at the link below:\n>\n>\n> https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n>\n> Any feedback is highly appreciated.\n>\n> Regards,\n> Omar\n>\n> On Tue, Aug 15, 2017 at 7:40 PM, omar shibli <omarshib at gmail.com> wrote:\n>\n>> Thank you for your time Gregory, I really appreciate that.\n>>\n>> What we are describing here is a method to embed cryptographic signatures\n>> into a public key based on HD Wallets - BIP32.\n>> In a practical application, we should have two cryptographic signatures\n>> from both sides, I don't think in that case your scenario would be an issue.\n>>\n>> More specifically in our application, we do the following construction:\n>>\n>> contract base: m/200'/0'/<contract_number>'\n>> payment base (merchant commitment):\n>> contract_base/<merchant_contract_signature>\n>> payment address (customer commitment):\n>> contract_base/<merchant_contract_signature>/<customer_contract_signature>\n>>\n>> payment address funds could be reclaimed only if the\n>> customer_contract_signature is provided by the customer.\n>>\n>> In terms of durability, our app is pretty simple at this point, we don't\n>> store anything, we let customer download and manage the files.\n>>\n>> I will update the BIP to address your concerns.\n>>\n>> On Tue, Aug 15, 2017 at 8:12 AM, Gregory Maxwell <greg at xiph.org> wrote:\n>>\n>>> This construction appears to me to be completely insecure.\n>>>\n>>>\n>>> Say my pubkey (the result of the derivation path) is P.\n>>>\n>>> We agree to contract C1.   A payment is made to P + G*H(C1).\n>>>\n>>> But in secret, I constructed contract C2 and pubkey Q and set P = Q +\n>>> G*H(C2).\n>>>\n>>> Now I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert\n>>> it was in act a payment to P' + G*H(C2).   (P' is simply Q + G*H(C1))\n>>>\n>>> I don't see anything in the proposal that addresses this. Am I missing\n>>> it?\n>>>\n>>> The applications are also not clear to me, and it doesn't appear to\n>>> address durability issues (how do you avoid losing your funds if you\n>>> lose the exact contract?).\n>>>\n>>>\n>>>\n>>>\n>>> On Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev\n>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> > Hey all,\n>>> >\n>>> > A lot of us familiar with the pay to contract protocol, and how it uses\n>>> > cleverly the homomorphic property of elliptic curve encryption system\n>>> to\n>>> > achieve it.\n>>> > Unfortunately, there is no standard specification on how to conduct\n>>> such\n>>> > transactions in the cyberspace.\n>>> >\n>>> > We have developed a basic trade finance application that relies on the\n>>> > original idea described in the Homomorphic Payment Addresses and the\n>>> > Pay-to-Contract Protocol paper, yet we have generalized it and made it\n>>> BIP43\n>>> > complaint.\n>>> >\n>>> > We would like to share our method, and get your feedback about it,\n>>> hopefully\n>>> > this effort will result into a standard for the benefit of the\n>>> community.\n>>> >\n>>> > Abstract idea:\n>>> >\n>>> > We define the following levels in BIP32 path.\n>>> > m / purpose' / coin_type' / contract_id' / *\n>>> >\n>>> > contract_id is is an arbitrary number within the valid range of\n>>> indices.\n>>> >\n>>> > Then we define, contract base as following prefix:\n>>> > m / purpose' / coin_type' / contract_id'\n>>> >\n>>> > contract commitment address is computed as follows:\n>>> > hash document using cryptographic hash function of your choice (e.g.\n>>> blake2)\n>>> > map hash to partial derivation path\n>>> > Convert hash to binary array.\n>>> > Partition the array into parts, each part length should be 16.\n>>> > Convert each part to integer in decimal format.\n>>> > Convert each integer to string.\n>>> > Join all strings with slash `/`.\n>>> > compute child public key by chaining the derivation path from step 2\n>>> with\n>>> > contract base:\n>>> > m/<contract_base>/<hash_derivation_path>\n>>> > compute address\n>>> > Example:\n>>> >\n>>> > master private extended key:\n>>> >\n>>> xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n>>> > coin type: 0\n>>> > contract id: 7777777\n>>> >\n>>> > contract base computation :\n>>> >\n>>> > derivation path:\n>>> > m/999'/0'/7777777'\n>>> > contract base public extended key:\n>>> >\n>>> xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnniiD5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n>>> >\n>>> > Contract content:\n>>> > foo\n>>> >\n>>> > Contract sha256 signature:\n>>> > 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n>>> >\n>>> > Contract partial derivation path:\n>>> >\n>>> 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>>> >\n>>> > Contract commitment pub key path:\n>>> >\n>>> m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>>> > or\n>>> >\n>>> <contract_base_extended_pub_key>/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n>>> >\n>>> > Contract commitment pub key:\n>>> >\n>>> xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n>>> >\n>>> > Contract commitment address:\n>>> > 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n>>> >\n>>> >\n>>> > You can find the full BIP draft in the following link:\n>>> >\n>>> https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n>>> >\n>>> >\n>>> > Regards,\n>>> > Omar\n>>> >\n>>> > _______________________________________________\n>>> > bitcoin-dev mailing list\n>>> > bitcoin-dev at lists.linuxfoundation.org\n>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> >\n>>>\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190312/e00eccc7/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-12T07:05:37",
                "message_text_only": "Good morning Omar,\n\nBIP32 includes this text:\n\n> In case parse_256(I_L) >= n or K_i is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i.\n\nThis seems to suggest that it is possible for an attacker with sufficient compute power to find two contracts whose derivations alias each other if we \"proceed with the next value for i\".\n\n\nMore generally, have you considered the possibility of multiple separate contracting systems?\n\nIt may be possible to have a particular sequence of bytes that has a valid interpretation under one contracting system, that also has a valid interpretation under another contracting system.\nI bring this up here: https://github.com/rgb-org/spec/issues/61\nand: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016354.html\n\nIt would then be possible to fool some victim into thinking it has committed to some innocuous contract in one contracting system, only to reveal later that the same sequence of bytes encoding that innocuous contract also corresponds to a more vicious contract in another contracting system.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, March 12, 2019 1:53 PM, Omar Shibli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Dear Gregory,\n>\n> First of all, I would like to express my deep appreciation to your entire craft in the FOSS ecosystem, specially in Bitcoin, even more In Blockstream.\n> I think you are a brilliant engineer and very principled leader. your efforts are an inspiration for many, a truly enduring forever mark in history of FOSS.\n>\n> I've submitted fixes to your concerns here:\n> https://github.com/bitcoin/bips/commit/b63ed0e17e872b7e7b8634591b0ddfa3dedfdc73#diff-deacf3a22d788a10ce12e4d92ee814ff\n>\n> Would appreciate your review.\n>\n> On other note, I still think that this security fix is redundant, I believe CKD function (BIP32) does encapsulate sufficient amount of entropy, but due to lack of formal knowledge and assistance, I've not managed to get formal proof, so I fallback'ed to add this patch for security\u00a0reasons.\n>\n> Best regards,\n> Omar\n>\n> On Fri, Sep 1, 2017 at 10:16 AM Omar Shibli <omarshib at gmail.com> wrote:\n>\n> > Hello Gregory,\n> >\n> > Thanks for you feedback.\n> >\n> > The BIP has been updated to explicitly specify the multiparty key derivation scheme which hopefully addresses your concerns.\n> >\n> > Please have a look at the updated draft of the BIP at the link below:\n> >\n> > https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n> >\n> > Any feedback is highly appreciated.\n> >\n> > Regards,\n> > Omar\n> >\n> > On Tue, Aug 15, 2017 at 7:40 PM, omar shibli <omarshib at gmail.com> wrote:\n> >\n> > > Thank you for your time Gregory, I really appreciate that.\n> > >\n> > > What we are describing here is a method to embed cryptographic signatures into a public key based on HD Wallets - BIP32.\n> > > In a practical application, we should have two cryptographic signatures from both sides, I don't think in that case your scenario would be an issue.\n> > >\n> > > More specifically in our application, we do the following construction:\n> > >\n> > > contract base: m/200'/0'/<contract_number>'\n> > > payment base (merchant commitment): contract_base/<merchant_contract_signature>\n> > > payment address (customer commitment): contract_base/<merchant_contract_signature>/<customer_contract_signature>\n> > >\n> > > payment address funds could be reclaimed only if the customer_contract_signature is provided by the customer.\n> > >\n> > > In terms of durability, our app is pretty simple at this point, we don't store anything, we let customer download and manage the files.\n> > >\n> > > I will update the BIP to address your concerns.\n> > >\n> > > On Tue, Aug 15, 2017 at 8:12 AM, Gregory Maxwell <greg at xiph.org> wrote:\n> > >\n> > > > This construction appears to me to be completely insecure.\n> > > >\n> > > > Say my pubkey (the result of the derivation path) is P.\n> > > >\n> > > > We agree to contract C1.\u00a0 \u00a0A payment is made to P + G*H(C1).\n> > > >\n> > > > But in secret, I constructed contract C2 and pubkey Q and set P = Q + G*H(C2).\n> > > >\n> > > > Now I can take that payment (paid to Q + G*(C1) + G*H(C2)) and assert\n> > > > it was in act a payment to P' + G*H(C2).\u00a0 \u00a0(P' is simply Q + G*H(C1))\n> > > >\n> > > > I don't see anything in the proposal that addresses this. Am I missing it?\n> > > >\n> > > > The applications are also not clear to me, and it doesn't appear to\n> > > > address durability issues (how do you avoid losing your funds if you\n> > > > lose the exact contract?).\n> > > >\n> > > > On Mon, Aug 14, 2017 at 6:05 AM, omar shibli via bitcoin-dev\n> > > > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > > > Hey all,\n> > > > >\n> > > > > A lot of us familiar with the pay to contract protocol, and how it uses\n> > > > > cleverly the homomorphic property of elliptic curve encryption system to\n> > > > > achieve it.\n> > > > > Unfortunately, there is no standard specification on how to conduct such\n> > > > > transactions in the cyberspace.\n> > > > >\n> > > > > We have developed a basic trade finance application that relies on the\n> > > > > original idea described in the Homomorphic Payment Addresses and the\n> > > > > Pay-to-Contract Protocol paper, yet we have generalized it and made it BIP43\n> > > > > complaint.\n> > > > >\n> > > > > We would like to share our method, and get your feedback about it, hopefully\n> > > > > this effort will result into a standard for the benefit of the community.\n> > > > >\n> > > > > Abstract idea:\n> > > > >\n> > > > > We define the following levels in BIP32 path.\n> > > > > m / purpose' / coin_type' / contract_id' / *\n> > > > >\n> > > > > contract_id is is an arbitrary number within the valid range of indices.\n> > > > >\n> > > > > Then we define, contract base as following prefix:\n> > > > > m / purpose' / coin_type' / contract_id'\n> > > > >\n> > > > > contract commitment address is computed as follows:\n> > > > > hash document using cryptographic hash function of your choice (e.g. blake2)\n> > > > > map hash to partial derivation path\n> > > > > Convert hash to binary array.\n> > > > > Partition the array into parts, each part length should be 16.\n> > > > > Convert each part to integer in decimal format.\n> > > > > Convert each integer to string.\n> > > > > Join all strings with slash `/`.\n> > > > > compute child public key by chaining the derivation path from step 2 with\n> > > > > contract base:\n> > > > > m/<contract_base>/<hash_derivation_path>\n> > > > > compute address\n> > > > > Example:\n> > > > >\n> > > > > master private extended key:\n> > > > > xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n> > > > > coin type: 0\n> > > > > contract id: 7777777\n> > > > >\n> > > > > contract base computation :\n> > > > >\n> > > > > derivation path:\n> > > > > m/999'/0'/7777777'\n> > > > > contract base public extended key:\n> > > > > xpub6CMCS9rY5GKdkWWyoeXEbmJmxGgDcbihofyARxucufdw7k3oc1JNnniiD5H2HynKBwhaem4KnPTue6s9R2tcroqkHv7vpLFBgbKRDwM5WEE\n> > > > >\n> > > > > Contract content:\n> > > > > foo\n> > > > >\n> > > > > Contract sha256 signature:\n> > > > > 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n> > > > >\n> > > > > Contract partial derivation path:\n> > > > > 11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> > > > >\n> > > > > Contract commitment pub key path:\n> > > > > m/999'/0'/7777777'/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> > > > > or\n> > > > > <contract_base_extended_pub_key>/11302/46187/26879/50831/63899/17724/7472/16692/4930/11632/25731/49056/63882/24200/25190/59310\n> > > > >\n> > > > > Contract commitment pub key:\n> > > > > xpub6iQVNpbZxdf9QJC8mGmz7cd3Cswt2itcQofZbKmyka5jdvQKQCqYSDFj8KCmRm4GBvcQW8gaFmDGAfDyz887msEGqxb6Pz4YUdEH8gFuaiS\n> > > > >\n> > > > > Contract commitment address:\n> > > > > 17yTyx1gXPPkEUN1Q6Tg3gPFTK4dhvmM5R\n> > > > >\n> > > > >\n> > > > > You can find the full BIP draft in the following link:\n> > > > > https://github.com/commerceblock/pay-to-contract-protocol-specification/blob/master/bip-draft.mediawiki\n> > > > >\n> > > > >\n> > > > > Regards,\n> > > > > Omar\n> > > > >\n> > > > > _______________________________________________\n> > > > > bitcoin-dev mailing list\n> > > > > bitcoin-dev at lists.linuxfoundation.org\n> > > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > > > >"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal, Pay to Contract BIP43 Application",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Omar Shibli"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 15573
        }
    },
    {
        "title": "[bitcoin-dev] More thoughts on NOINPUT safety",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2019-03-13T01:41:43",
                "message_text_only": "Hi all,\n\nThe following has some more thoughts on trying to make a NOINPUT\nimplementation as safe as possible for the Bitcoin ecosystem.\n\nOne interesting property of NOINPUT usage like in eltoo is that it\nactually reintroduces the possibility of third-party malleability to\ntransactions -- ie, you publish transactions to the blockchain (tx A,\nwhich is spent by tx B, which is spent by tx C), and someone can come\nalong and change A or B so that C is no longer valid). The way this works\nis due to eltoo's use of NOINPUT to \"skip intermediate states\". If you\npublish to the blockchain:\n\n      funding tx -> state 3 -> state 4[NOINPUT] -> state 5[NOINPUT] -> finish\n\nthen in the event of a reorg, state 4 could be dropped, state 5's\ninputs adjusted to refer to state 3 instead (the sig remains valid\ndue to NOINPUT, so this can be done by anyone not just holders of some\nprivate key), and finish would no longer be a valid tx (because the new\n\"state 5\" tx has different inputs so a different txid, and finish uses\nSIGHASH_ALL for the signature so committed to state 5's original txid).\n\nThere is a safety measure here though: if the \"finish\" transaction is\nitself a NOINPUT tx, and has a a CSV delay (this is the case in eltoo;\nthe CSV delay is there to give time for a hypothetical state 6 to be\npublished), then the only way to have a problem is for some SIGHASH_ALL tx\nthat spends finish, and a reorg deeper than the CSV delay (so that state\n4 can be dropped, state 5 and finish can be altered). Since the CSV delay\nis chosen by the participants, the above is still a possible scenario\nin eltoo, though, and it means there's some risk for someone accepting\nbitcoins that result from a non-cooperative close of an eltoo channel.\n\n\nBeyond that, I think NOINPUT has two fundamental ways to cause problems\nfor the people doing NOINPUT sigs:\n\n 1) your signature gets applied to a unexpectedly different\n    script, perhaps making it look like you've being dealing\n    with some blacklisted entity. OP_MASK and similar solves\n    this.\n\n 2) your signature is applied to some transaction and works\n    perfectly; but then someone else sends money to the same address\n    and reuses your prior signature to forward it on to the same\n    destination, without your consent\n\nI still like OP_MASK as a solution to (1), but I can't convince myself that\nthe problem it solves is particularly realistic; it doesn't apply to\naddress blacklists, because for OP_MASK to make the signature invalid\nthe address has to be different, and you could just short circuit the\nwhole thing by sending money from a blacklisted address to the target's\npersonal address directly. Further, if the sig's been seen on chain\nbefore, that's probably good evidence that someone's messing with you;\nand if it hasn't been seen on chain before, how is anyone going to tell\nit's your sig to blame you for it?\n\nI still wonder if there isn't a real problem hiding somewhere here,\nbut if so, I'm not seeing it.\n\nFor the second case, that seems a little more concerning. The nightmare\nscenario is maybe something like:\n\n * naive users do silly things with NOINPUT signatures, and end up\n   losing funds due to replays like the above\n\n * initial source of funds was some major exchange, who decide it's\n   cheaper to refund the lost funds than deal with the customer complaints\n\n * the lost funds end up costing enough that major exchanges just outright\n   ban sending funds to any address capable of NOINPUT, which also bans\n   all taproot/schnorr addresses\n\nThat's not super likely to happen by chance: NOINPUT sigs will commit\nto the value being spent, so to lose money, you (Alice) have to have\ndone a NOINPUT sig spending a coin sent to your address X, to someone\n(Bob) and then have to have a coin with the exact same value sent from\nsomeone else again (Carol) to your address X (or if you did a script\npath NOINPUT spend, to some related address Y with a script that uses the same\nkey). But because it involves losing money to others, bad actors might\ntrick people into having it happen more often than chance (or well\nwritten software) would normally allow.\n\nThat \"nightmare\" could be stopped at either the first step or the\nlast step:\n\n * if we \"tag\" addresses that can be spent via NOINPUT then having an\n   exchange ban those addresses doesn't also impact regular\n   taproot/schnorr addresses, though it does mean you can tell when\n   someone is using a protocol like eltoo that might need to make use\n   of NOINPUT signatures.  This way exchanges and wallets could simply\n   not provide NOINPUT capable addresses in the first place normally,\n   and issue very large warnings when asked to send money to one. That's\n   not a problem for eltoo, because all the NOINPUT-capable address eltoo\n   needs are internal parts of the protocol, and are spent automatically.\n\n * or we could make it so NOINPUT signatures aren't replayable on\n   different transactions, at least by third parties. one way of doing\n   this might be to require NOINPUT signatures always be accompanied by a\n   non-NOINPUT signature (presumably for a different public key, or there\n   would be no point). This would prevent NOINPUT key-path spends, you'd\n   always have to use the taproot script-path for a NOINPUT signature so\n   that you could specify both public keys, and would also increase the\n   witness size due to needing two signatures and specifying an additional\n   public key -- this would increase the cost in fees by about 25% compared\n   to a plain key-path spend.\n\nConversely, this \"nightmare\" scenario *can't* be stopped if we allow\nkey-path spending of (untagged) taproot addresses with NOINPUT signatures:\nexchanges could not distinguish such addresses from regular addresses, and\nthe only way to prevent the signature from applying to two tx's with the\nsame value and address would be for the sig to commit to info from the tx.\n\nIt seems like there's one big choice then:\n\n - just ignore this concern\n\n - drop NOINPUT from normal taproot key path spending\n\nIf we drop NOINPUT from taproot key path spending, then we can do NOINPUT\nas a logically separate upgrade to taproot, rather than it needing to\nbe done at the same time.  There's two ways we could do proceed:\n\n - introduce a new NOINPUT-capable scriptPubKey format (ie, \"tag\"\n   NOINPUT spendable addresses); either a different length segwit v1\n   output, or a different segwit version entirely. Using version \"16\" in\n   this scenario might be appealing: we could reserve all v16 addresses\n   for \"not intended to be used by humans directly\" and update BIP 173\n   to say these aren't even something you should use bech32 to represent.\n\n - alternatively, we could require every script to have a valid signature\n   that commits to the input. In that case, you could do eltoo with a\n   script like either:\n\n        <A> CHECKSIGVERIFY <B> CHECKSIG\n     or <P> CHECKSIGVERIFY <Q> CHECKSIG\n\n   where A is Alice's key and B is Bob's key, P is muSig(A,B) and Q is\n   a key they both know the private key for. In the first case, Alice\n   would give Bob a NOINPUT sig for the tx, and when Bob wanted to publish\n   Bob would just do a SIGHASH_ALL sig with his own key. In the second,\n   Alice and Bob would share partial NOINPUT sigs of the tx with P, and\n   finish that when they wanted to publish.\n\n   This is a bit more costly than a key path spend: you have to reveal\n   the taproot point to do a script (+33B) and you have two signatures\n   instead of one (+65B) and you have to reveal two keys as well\n   (+66B), plus some script overhead. If we did the <P,Q> variant,\n   we could provide a \"PUSH_TAPROOT_KEY\" opcode that would just push\n   the taproot key to stack, saving 33B from pushing P as a literal,\n   but you can't do much better than that. All in all, it'd be about 25%\n   overhead in order to prevent cheating. [0]\n\nI think that output tagging doesn't provide a workable defense against the\nthird party malleability via a deeper-than-the-CSV-delay reorg mentioned\nearlier; but requiring a non-NOINPUT sig does: you'd have to replace\nthe non-NOINPUT sig to make state 5 spend state 3 instead of state 4,\nand only the holders of the appropriate private key can do that.\n\n\nIn any event, if we get some experience with NOINPUT in practice, we can\nreconsider whether NOINPUT key path spends are a good idea when we do\nthe next segwit version -- both cross-input signature aggregation and\ngraftroot will need an upgrade anyway.\n\n(Also, note that, at least for eltoo, all of the above only applies to\nnon-cooperative closes: the funding tx's txid is known from the start,\nso you can always arrange to spend it via SIGHASH_ALL, so it doesn't\nneed to be tagged, and a cooperative/mutual close of the channel will\nstill just be a simple key path spend)\n\n\nAnyway, presented for your consideration.\n\n\nFWIW, I don't have a strong opinion here yet, but:\n\n - I'm still inclined to err on the side of putting more safety\n   measures in for NOINPUT, rather than fewer\n\n - the \"must have a sig that commits to the input tx\" seems like it\n   should be pretty safe, not too expensive, and keeps taproot's privacy\n   benefits in the cases where you end up needing to use NOINPUT\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "More thoughts on NOINPUT safety",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 9186
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] More thoughts on NOINPUT safety",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-13T06:41:47",
                "message_text_only": "Good morning aj,\n\nFirst off, I have little to no idea of the issues at the lower-level Bitcoin.\n\nIn any case ---\n\n> -   alternatively, we could require every script to have a valid signature\n>     that commits to the input. In that case, you could do eltoo with a\n>     script like either:\n>\n>     <A> CHECKSIGVERIFY <B> CHECKSIG\n>     or <P> CHECKSIGVERIFY <Q> CHECKSIG\n>\n>\n> where A is Alice's key and B is Bob's key, P is muSig(A,B) and Q is\n> a key they both know the private key for. In the first case, Alice\n> would give Bob a NOINPUT sig for the tx, and when Bob wanted to publish\n> Bob would just do a SIGHASH_ALL sig with his own key. In the second,\n> Alice and Bob would share partial NOINPUT sigs of the tx with P, and\n> finish that when they wanted to publish.\n>\n> This is a bit more costly than a key path spend: you have to reveal\n> the taproot point to do a script (+33B) and you have two signatures\n> instead of one (+65B) and you have to reveal two keys as well\n> (+66B), plus some script overhead. If we did the <P,Q> variant,\n> we could provide a \"PUSH_TAPROOT_KEY\" opcode that would just push\n> the taproot key to stack, saving 33B from pushing P as a literal,\n> but you can't do much better than that. All in all, it'd be about 25%\n> overhead in order to prevent cheating. [0]\n>\n> I think that output tagging doesn't provide a workable defense against the\n> third party malleability via a deeper-than-the-CSV-delay reorg mentioned\n> earlier; but requiring a non-NOINPUT sig does: you'd have to replace\n> the non-NOINPUT sig to make state 5 spend state 3 instead of state 4,\n> and only the holders of the appropriate private key can do that.\n\nAt my point of view, if a NONINPUT sig is restricted and cannot be used to spend an \"ordinary\" 2-of-2, this is output tagging regardless of exact mechanism.\nSo the restriction to add a non-NOINPUT sig in addition to a NOINPUT sig is still output tagging, as a cooperative close would still reveal that the output is not a 2-of-2.\n\nIdeally, historical data of whether onchain coin was used in Lightning or not should be revealed as little as possible.\nSo in a cooperative close (which we hope, to be a common case), ideally the spend should look no different from an ordinary 2-of-2 spend.\nOf course if the channel is published on Lightning, those who participated in Lightning at the time will learn of it, but at least the effort to remember this information is on those who want to remember this fact.\n\nNow, this can be worked around by adding a \"kickoff\" transaction that spends the eltoo setup transaction.\nThe eltoo setup transaction outputs to an ordinary 2-of-2.\nThe kickoff outputs to an output that allows NOINPUT.\nThen the rest of the protocol anchors on top of the kickoff.\n\nThe kickoff is kept offchain, until a non-cooperative close is needed.\nOf course, as it is not a NOINPUT itself, it must need onchain fees attached to it.\nThis of course complicates fees, as we know.\nAlternately maybe the kickoff can be signed with `SIGHASH_SINGLE | SIGHASH_ANYONECANPAY` so that it is possible to add a fee-paying UTXO to it.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-13T11:10:50",
                "message_text_only": "On Wed, Mar 13, 2019 at 06:41:47AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> > -   alternatively, we could require every script to have a valid signature\n> >     that commits to the input. In that case, you could do eltoo with a\n> >     script like either:\n> >     <A> CHECKSIGVERIFY <B> CHECKSIG\n> >     or <P> CHECKSIGVERIFY <Q> CHECKSIG\n> > where A is Alice's key and B is Bob's key, P is muSig(A,B) and Q is\n> > a key they both know the private key for. In the first case, Alice\n> > would give Bob a NOINPUT sig for the tx, and when Bob wanted to publish\n> > Bob would just do a SIGHASH_ALL sig with his own key. In the second,\n> > Alice and Bob would share partial NOINPUT sigs of the tx with P, and\n> > finish that when they wanted to publish.\n> At my point of view, if a NONINPUT sig is restricted and cannot be\n> used to spend an \"ordinary\" 2-of-2, this is output tagging regardless\n> of exact mechanism.\n\nWith taproot, you could always do the 2-of-2 spend without revealing a\nscript at all, let alone that it was meant to be NOINPUT capable. The\nsetup I'm thinking of in this scenario is something like:\n\n  0) my key is A, your key is B, we want to setup an eltoo channel\n\n  1) post a funding tx to the blockchain, spending money to an address\n     P = muSig(A,B)\n\n  2) we cycle through a bunch of states from 0..N, with \"0\" being the\n     refund state we establish before publishing the funding tx to\n     the blockchain. each state essentially has two corresponding tx's,\n     and update tx and a settlement tx.\n\n  3) the update tx for state k spends to an output Qk which is a\n     taproot address Qk = P + H(P,Sk)*G where Sk is the eltoo ratchet\n     condition:\n        Sk = (5e8+k+1) CLTV A CHECKDLS_NOINPUT B CHECKDLS_NOINPUT_VERIFY\n\n     we establish two partial signatures for update state k, one which\n     is a partial signature spending the funding tx with key P and\n     SIGHASH_ALL, the other is a NOINPUT signature via A (for you) and\n     via B (for me) with locktime set to (k+5e8), so that we can spend\n     any earlier state's update tx's, but not itself or any later\n     state's update tx's.\n\n  4) for each state we have also have a settlement transaction,\n     Sk, which spends update tx k, to outputs corresponding to the state\n     of the channel, after a relative timelock delay.\n\n     we have two partial signatures for this transaction too, one with\n     SIGHASH_ALL assuming that we directly spent the funding tx with\n     update state k (so the input txid is known), via the key path with\n     key Qk; the other SIGHASH_NOINPUT via the Sk path. both partially\n     signed tx's have nSequence set to the required relative timelock\n     delay.\n\n  5) if you're using scriptless scripts to do HTLCs, you'll need to\n     allow for NOINPUT sigs when claiming funds as well (and update\n     the partial signatures for the non-NOINPUT cases if you want to\n     maximise privacy), which is a bit fiddly\n\n  6) when closing the channel the process is then:\n\n       - if you're in contact with the other party, negotiate a new\n         key path spend of the funding tx, publish it, and you're done.\n\n       - otherwise, if the funding tx hasn't been spent, post the latest\n         update tx you know about, using the \"spend the funding tx via\n\t key path\" partial signature\n\n       - otherwise, trace the children of the funding tx, so you can see\n         the most recent published state:\n\t   - if that's newer than the latest state you know about, your\n\t     info is out of date (restored from an old backup?), and you\n\t     have to wait for your counterparty to post the settlement tx\n\t   - if it's equal to the latest state you know about, wait\n\t   - if it's older than the latest state, post the latest update\n\t     tx (via the NOINPUT script path sig), and wait\n\n       - once the CSV delay for the latest update tx has expired, post\n\t the corresponding settlement tx (key path if the update tx\n\t spent the funding tx, NOINPUT if the update tx spent an earlier\n\t update tx)\n\n       - once the settlement tx is posted, claim your funds\n\nSo the cases look like:\n\n   mutual close:\n     funding tx -> claimed funds\n\n     -- only see one key via muSig, single signature, SIGHASH_ALL\n     -- if there are active HTLCs when closing the channel, and they\n        timeout, then the claiming tx will likely be one-in, one-out,\n\tSIGHASH_ALL, with a locktime, which may be unusual enough to\n\tindicate a lightning channel.\n\n   unilateral close, no cheating: \n     funding tx -> update N -> settlement N -> claimed funds\n\n     -- update N is probably SINGLE|ANYONECANPAY, so chain analysis\n        of accompanying inputs might reveal who closed the channel\n     -- settlement N has relative timelock\n     -- claimed funds may have timelocks if they claim active HTLCs via\n        the refund path\n     -- no NOINPUT signatures needed, and all signatures use the key path\n        so don't reveal any scripts\n\n   unilateral close, attempted cheating:\n     funding tx -> update K -> update N -> settlement N -> claimed funds\n\n     -- update K, update N are probably SINGLE|ANYONECANPAY, so chain\n        analysis might reveal the identity of both sides of the channel \n     -- update N and settlement N both use NOINPUT signatures and\n        reveal CLTV script that looks like eltoo\n     -- update N has timelock set\n     -- settlement N has a relative timelock\n     -- claimed funds may have timelocks if they claim active HTLCs via\n        the refund path\n\n     Notes:\n      * cheating isn't 100% accurate: could be due to someone having to\n        restore from an old backup\n\n      * you could end up with:\n\n          funding tx -> update K -> update W -> update N\n\t             -> settlement N -> claimed funds\n\n\tif someone restored from an old backup and posted K, a watchtower\n\thad a newer but not current state W, and finally you posted\n\tstate N directly. with multiple watchtowers you might have more\n\tintermediate states' update tx's posted. afaics it has similar\n\tprivacy results to the 2-update-tx case.\n\n> So the restriction to add a non-NOINPUT sig in addition to a NOINPUT sig is still output tagging, as a cooperative close would still reveal that the output is not a 2-of-2.\n\nWith the above setup, you don't discover that NOINPUT was possible unless it\nis actually needed because someone cheated.\n\nAs long as you're using muSig key path spending for a cooperative close,\nyou're not even revealing the output is 2-of-2, let alone a weird\n2-of-2 variant.\n\n> Ideally, historical data of whether onchain coin was used in Lightning or not should be revealed as little as possible.\n> So in a cooperative close (which we hope, to be a common case), ideally the spend should look no different from an ordinary 2-of-2 spend.\n\nWith taproot, the goal is it shouldn't look different from an ordinary\n\"pay to public key\" spend, and I think that's pretty achievable.\n\n> Of course if the channel is published on Lightning, those who participated in Lightning at the time will learn of it, but at least the effort to remember this information is on those who want to remember this fact.\n\nWell, presumaby lightning will continue to support private channels that\ndon't get published, and the concern's definitely valid for them!\n\n> Now, this can be worked around by adding a \"kickoff\" transaction that spends the eltoo setup transaction.\n> The eltoo setup transaction outputs to an ordinary 2-of-2.\n> The kickoff outputs to an output that allows NOINPUT.\n> Then the rest of the protocol anchors on top of the kickoff.\n> [...]\n\nI think this is possible too, but I think the scheme I describe above\nis superior: iit means calculating a few more signatures each update,\nbut keeps more information off chain, which is better for privacy, and\nprobably cheaper (unless you have very high-frequency channel updates?).\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-14T05:22:59",
                "message_text_only": "Good morning aj,\n\nWhen reading through your original post I saw you mentioned something about output tagging somehow conflicting with Taproot, so I assumed Taproot is not useable in this case.\nHowever, it is probably more likely that I simply misunderstood what you said, so if you can definitively say that it would be possible to hide the clause \"or a NOINPUT sig from A with a non-NOINPUT sig from B\" behind a Taproot then I am fine.\n\nMinor pointless reactions:\n\n> 5.  if you're using scriptless scripts to do HTLCs, you'll need to\n>     allow for NOINPUT sigs when claiming funds as well (and update\n>     the partial signatures for the non-NOINPUT cases if you want to\n>     maximise privacy), which is a bit fiddly\n\nIf I remember accurately, we do not allow bilateral/cooperative close when HTLC is in-flight.\nHowever, I notice that later you point out that a non-cheating unilateral close does not need NOINPUT, so I suppose. the above thought applies to that case.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-14T07:24:56",
                "message_text_only": "On Thu, Mar 14, 2019 at 05:22:59AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> When reading through your original post I saw you mentioned something about output tagging somehow conflicting with Taproot, so I assumed Taproot is not useable in this case.\n\nI'm thinking of tagged outputs as \"taproot plus\" (ie, plus noinput),\nso if you used a tagged output, you could do everything normal taproot\naddress could, but also do noinput sigs for them.\n\nSo you might have:\n\n   funding tx -> cooperative claim\n\n   funding tx -> update 3 [TAGGED] -> settlement 3 -> claim\n\n   funding tx -> update 3 [TAGGED] -> \n                 update 4 [TAGGED,NOINPUT] -> \n\t\t settlement 4 [TAGGED,NOINPUT] -> \n\t\t claim [NOINPUT]\n\nIn the cooperative case, no output tagging needed.\n\nFor the unilateral case, you need to tag all the update tx's, because\nthey *could* be spend by a later update with a NOINPUT sig, and if\nthat actually happens, then the settlement tx also needs to use a\nNOINPUT sig, and if you're using scriptless scripts to resolve HTLCs,\nclaiming/refunding the HTLCs needs a partially-pre-signed tx which also\nneeds to be a NOINPUT sig, meaning the settlement tx also needs to be\ntagged in that case.\n\nYou'd only need the script path for the last case where there actually\nare multiple updates, but because you have to have a tagged output in the\nsecond case anyway, maybe you've already lost privacy and always using\nNOINPUT and the script path for update and settlement tx's would be fine.\n\n> However, it is probably more likely that I simply misunderstood what you said, so if you can definitively say that it would be possible to hide the clause \"or a NOINPUT sig from A with a non-NOINPUT sig from B\" behind a Taproot then I am fine.\n\nYeah, that's my thinking.\n\n> Minor pointless reactions:\n> > 5.  if you're using scriptless scripts to do HTLCs, you'll need to\n> >     allow for NOINPUT sigs when claiming funds as well (and update\n> >     the partial signatures for the non-NOINPUT cases if you want to\n> >     maximise privacy), which is a bit fiddly\n> If I remember accurately, we do not allow bilateral/cooperative close when HTLC is in-flight.\n> However, I notice that later you point out that a non-cheating unilateral close does not need NOINPUT, so I suppose. the above thought applies to that case.\n\nYeah, exactly.\n\nTrying to maximise privacy there has the disadvantage that you have to\ndo a new signature for every in-flight HTLC every time you update the\nstate, which could be a lot of signatures for very active channels.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-14T07:55:20",
                "message_text_only": "Good morning aj,\n\n>\n> Trying to maximise privacy there has the disadvantage that you have to\n> do a new signature for every in-flight HTLC every time you update the\n> state, which could be a lot of signatures for very active channels.\n\nIf I remember accurately this is already true for current Poon-Dryja channels in BOLT 1.0, so at least it is not a degradation of performance.\nIt does make this modified form of Decker-Russell-Osuntokun much less attractive for use with DLC as the Fulgurite effort would like, but the Fulgurite effort already mitigates this by splitting a channel into two sub-channels (one for high-activity LN payments, one for rare-activity DLC bets) anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-03-14T12:00:56",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> I'm thinking of tagged outputs as \"taproot plus\" (ie, plus noinput),\n> so if you used a tagged output, you could do everything normal taproot\n> address could, but also do noinput sigs for them.\n>\n> So you might have:\n>\n>    funding tx -> cooperative claim\n>\n>    funding tx -> update 3 [TAGGED] -> settlement 3 -> claim\n>\n>    funding tx -> update 3 [TAGGED] -> \n>                  update 4 [TAGGED,NOINPUT] -> \n> \t\t settlement 4 [TAGGED,NOINPUT] -> \n> \t\t claim [NOINPUT]\n>\n> In the cooperative case, no output tagging needed.\n\nI might be missing something here, but how do you bind update 3 to the\nfunding tx output, when that output is not tagged? Do we keep each\nupdate in multiple separate states, one bound to the funding tx output\nand another signed with noinput? If that's the case we just doubled our\nstorage and communication requirements for very little gain. An\nalternative is to add a trigger transaction that needs to be published\nin a unilateral case, but that'd increase our on-chain footprint."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-03-20T00:22:05",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> If you publish to the blockchain:\n...\n> 4 can be dropped, state 5 and finish can be altered). Since the CSV delay\n> is chosen by the participants, the above is still a possible scenario\n> in eltoo, though, and it means there's some risk for someone accepting\n> bitcoins that result from a non-cooperative close of an eltoo channel.\n\nAJ, this was a meandering random walk which shed very little light.\n\nI don't find the differentiation between malicious and non-malicious\ndouble-spends convincing.  Even if you trust A, you already have to\nworry about person-who-sent-the-coins-to-A.  This expands that set to be\n\"miner who mined coins sent-to-A\", but it's very hard to see what\ndifference that makes to how you'd handle coins from A.\n\n> Beyond that, I think NOINPUT has two fundamental ways to cause problems\n> for the people doing NOINPUT sigs:\n>\n>  1) your signature gets applied to a unexpectedly different\n>     script, perhaps making it look like you've being dealing\n>     with some blacklisted entity. OP_MASK and similar solves\n>     this.\n\n... followed by two paragraphs describing how it's not a \"fundamental\nway to cause problems\" that you (or I) can see.\n\n> For the second case, that seems a little more concerning. The nightmare\n> scenario is maybe something like:\n>\n>  * naive users do silly things with NOINPUT signatures, and end up\n>    losing funds due to replays like the above\n\nAs we've never seen with SIGHASH_NONE?\n\n>  * initial source of funds was some major exchange, who decide it's\n>    cheaper to refund the lost funds than deal with the customer complaints\n>\n>  * the lost funds end up costing enough that major exchanges just outright\n>    ban sending funds to any address capable of NOINPUT, which also bans\n>    all taproot/schnorr addresses\n\nI don't find this remotely credible.\n\n> FWIW, I don't have a strong opinion here yet, but:\n>\n>  - I'm still inclined to err on the side of putting more safety\n>    measures in for NOINPUT, rather than fewer\n\nIn theory, sure.  But not feel-good and complex \"safety measures\" which\ndon't actually help in practical failure scenarios.\n\n>  - the \"must have a sig that commits to the input tx\" seems like it\n>    should be pretty safe, not too expensive, and keeps taproot's privacy\n>    benefits in the cases where you end up needing to use NOINPUT\n\nIf this is considered necessary, can it be a standardness rule rather\nthan consensus?\n\nThanks,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-03-20T03:33:55",
                "message_text_only": "Sorry AJ, my prior email was not constructive :(\n\nI consider the \"my software reused my keys\" the most reasonable attack\nscenario, though still small compared to other lightning attack surfaces.\n\nBut I understand the general wariness of third-parties reusing\nSIGHASH_NOINPUT signatures.\n\nSince \"must have a non-SIGHASH_NOINPUT\" rule addresses the first reuse\nscenario (as well as the second), I'd be content with that proposal.\nFuture segwit versions may choose to relax it.[1]\n\nCheers,\nRusty.\n[1] Must be consensus, not standardness; my prev suggestion was bogus.\n\nRusty Russell <rusty at rustcorp.com.au> writes:\n> Anthony Towns <aj at erisian.com.au> writes:\n>> If you publish to the blockchain:\n> ...\n>> 4 can be dropped, state 5 and finish can be altered). Since the CSV delay\n>> is chosen by the participants, the above is still a possible scenario\n>> in eltoo, though, and it means there's some risk for someone accepting\n>> bitcoins that result from a non-cooperative close of an eltoo channel.\n>\n> AJ, this was a meandering random walk which shed very little light.\n>\n> I don't find the differentiation between malicious and non-malicious\n> double-spends convincing.  Even if you trust A, you already have to\n> worry about person-who-sent-the-coins-to-A.  This expands that set to be\n> \"miner who mined coins sent-to-A\", but it's very hard to see what\n> difference that makes to how you'd handle coins from A.\n>\n>> Beyond that, I think NOINPUT has two fundamental ways to cause problems\n>> for the people doing NOINPUT sigs:\n>>\n>>  1) your signature gets applied to a unexpectedly different\n>>     script, perhaps making it look like you've being dealing\n>>     with some blacklisted entity. OP_MASK and similar solves\n>>     this.\n>\n> ... followed by two paragraphs describing how it's not a \"fundamental\n> way to cause problems\" that you (or I) can see.\n>\n>> For the second case, that seems a little more concerning. The nightmare\n>> scenario is maybe something like:\n>>\n>>  * naive users do silly things with NOINPUT signatures, and end up\n>>    losing funds due to replays like the above\n>\n> As we've never seen with SIGHASH_NONE?\n>\n>>  * initial source of funds was some major exchange, who decide it's\n>>    cheaper to refund the lost funds than deal with the customer complaints\n>>\n>>  * the lost funds end up costing enough that major exchanges just outright\n>>    ban sending funds to any address capable of NOINPUT, which also bans\n>>    all taproot/schnorr addresses\n>\n> I don't find this remotely credible.\n>\n>> FWIW, I don't have a strong opinion here yet, but:\n>>\n>>  - I'm still inclined to err on the side of putting more safety\n>>    measures in for NOINPUT, rather than fewer\n>\n> In theory, sure.  But not feel-good and complex \"safety measures\" which\n> don't actually help in practical failure scenarios.\n>\n>>  - the \"must have a sig that commits to the input tx\" seems like it\n>>    should be pretty safe, not too expensive, and keeps taproot's privacy\n>>    benefits in the cases where you end up needing to use NOINPUT\n>\n> If this is considered necessary, can it be a standardness rule rather\n> than consensus?\n>\n> Thanks,\n> Rusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-20T07:38:22",
                "message_text_only": "Hi all,\n\n> Since \"must have a non-SIGHASH_NOINPUT\" rule addresses the first reuse\n> scenario (as well as the second), I'd be content with that proposal.\n\nHow would this work with watchtowers?\n\nAs I understand it, the current plan for eltoo watchtowers would be to store both `SIGHASH_NOINPUT` signatures from both sides in the blob sent to the watchtower.\n\nThen the watchtower can always attach this to whatever is the tipmost available on the chain of transactions.\n\nHowever, if one of the signatures MUST be non-`SIGHASH_NOINPUT` --- how does the watchtower create such a non-`SIGHASH_NOINPUT` signature?\n\nRegards,\nZmnSCPxj\n\n\n> Future segwit versions may choose to relax it.[1]\n>\n> Cheers,\n> Rusty.\n> [1] Must be consensus, not standardness; my prev suggestion was bogus.\n>\n> Rusty Russell rusty at rustcorp.com.au writes:\n>\n> > Anthony Towns aj at erisian.com.au writes:\n> >\n> > > If you publish to the blockchain:\n> > > ...\n> > > 4 can be dropped, state 5 and finish can be altered). Since the CSV delay\n> > > is chosen by the participants, the above is still a possible scenario\n> > > in eltoo, though, and it means there's some risk for someone accepting\n> > > bitcoins that result from a non-cooperative close of an eltoo channel.\n> >\n> > AJ, this was a meandering random walk which shed very little light.\n> > I don't find the differentiation between malicious and non-malicious\n> > double-spends convincing. Even if you trust A, you already have to\n> > worry about person-who-sent-the-coins-to-A. This expands that set to be\n> > \"miner who mined coins sent-to-A\", but it's very hard to see what\n> > difference that makes to how you'd handle coins from A.\n> >\n> > > Beyond that, I think NOINPUT has two fundamental ways to cause problems\n> > > for the people doing NOINPUT sigs:\n> > >\n> > > 1.  your signature gets applied to a unexpectedly different\n> > >     script, perhaps making it look like you've being dealing\n> > >     with some blacklisted entity. OP_MASK and similar solves\n> > >     this.\n> > >\n> >\n> > ... followed by two paragraphs describing how it's not a \"fundamental\n> > way to cause problems\" that you (or I) can see.\n> >\n> > > For the second case, that seems a little more concerning. The nightmare\n> > > scenario is maybe something like:\n> > >\n> > > -   naive users do silly things with NOINPUT signatures, and end up\n> > >     losing funds due to replays like the above\n> > >\n> >\n> > As we've never seen with SIGHASH_NONE?\n> >\n> > > -   initial source of funds was some major exchange, who decide it's\n> > >     cheaper to refund the lost funds than deal with the customer complaints\n> > >\n> > > -   the lost funds end up costing enough that major exchanges just outright\n> > >     ban sending funds to any address capable of NOINPUT, which also bans\n> > >     all taproot/schnorr addresses\n> > >\n> >\n> > I don't find this remotely credible.\n> >\n> > > FWIW, I don't have a strong opinion here yet, but:\n> > >\n> > > -   I'm still inclined to err on the side of putting more safety\n> > >     measures in for NOINPUT, rather than fewer\n> > >\n> >\n> > In theory, sure. But not feel-good and complex \"safety measures\" which\n> > don't actually help in practical failure scenarios.\n> >\n> > > -   the \"must have a sig that commits to the input tx\" seems like it\n> > >     should be pretty safe, not too expensive, and keeps taproot's privacy\n> > >     benefits in the cases where you end up needing to use NOINPUT\n> > >\n> >\n> > If this is considered necessary, can it be a standardness rule rather\n> > than consensus?\n> > Thanks,\n> > Rusty.\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-20T08:07:00",
                "message_text_only": "Hi aj,\n\nRe-reading again, I think perhaps I was massively confused by this:\n\n> - alternatively, we could require every script to have a valid signature\n> that commits to the input. In that case, you could do eltoo with a\n> script like either:\n>\n> <A> CHECKSIGVERIFY <B> CHECKSIG\n> or <P> CHECKSIGVERIFY <Q> CHECKSIG\n>\n>\n> where A is Alice's key and B is Bob's key, P is muSig(A,B) and Q is\n> a key they both know the private key for. In the first case, Alice\n> would give Bob a NOINPUT sig for the tx, and when Bob wanted to publish\n> Bob would just do a SIGHASH_ALL sig with his own key. In the second,\n> Alice and Bob would share partial NOINPUT sigs of the tx with P, and\n> finish that when they wanted to publish.\n\nDo you mean that *either* of the above two scripts is OK, *or* do you mean they are alternatives within a single MAST or `OP_IF`?\n\nIf you mean that *either* of the above two scripts is OK, then this script:\n\n    <muSig(A,B)> CHECKVERIFY <Q> CHECKSIG\n\nshould probably be used for Watchtower-compatibility.\n\nWhen creating a new state, both A and B would cooperatively sign with `muSig(A,B)` with a `SIGHASH_NOINPUT` that ensures the state transaction is correct.\nThen they somehow derive or share the private key to `Q`.\n\nIn the blob sent to Watchtower, A (or B) includes the `SIGHASH_NOINPUT` as well as the `q` private key.\nWould it be safe for Watchtower to know that?\n\nNote that the above `Q` would need to be the same in the \"state\" trunk of the Decker-Russell-Osuntokun construction.\n\nSo, building this, our initial setup transaction pays out to script:\n\n    <muSig(A_u,B_u)> CHECKVERIFY <Q> CHECKSIG\n\nThen each update transaction pays out to:\n\n    OP_IF\n        <csv_delta> OP_CSV OP_DROP\n        <muSig(A_si,B_si)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n    OP_ELSE\n        <i> OP_CHECKLOCKTIMEVERIFY OP_DROP\n        <muSig(A_u,B_u)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n    OP_ENDIF\n\nThe `SIGHASH_NOINPUT` signature for `muSig(A_u,B_u)` would then be sufficient to unlock the setup transaction, or any update transaction with lower `nLockTime`.\nThe watchtower would then have to generate the signature for `Q`, committing to a particular UTXO.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, March 20, 2019 3:38 PM, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> > Since \"must have a non-SIGHASH_NOINPUT\" rule addresses the first reuse\n> > scenario (as well as the second), I'd be content with that proposal.\n>\n> How would this work with watchtowers?\n>\n> As I understand it, the current plan for eltoo watchtowers would be to store both `SIGHASH_NOINPUT` signatures from both sides in the blob sent to the watchtower.\n>\n> Then the watchtower can always attach this to whatever is the tipmost available on the chain of transactions.\n>\n> However, if one of the signatures MUST be non-`SIGHASH_NOINPUT` --- how does the watchtower create such a non-`SIGHASH_NOINPUT` signature?\n>\n> Regards,\n> ZmnSCPxj\n>\n> > Future segwit versions may choose to relax it.[1]\n> > Cheers,\n> > Rusty.\n> > [1] Must be consensus, not standardness; my prev suggestion was bogus.\n> > Rusty Russell rusty at rustcorp.com.au writes:\n> >\n> > > Anthony Towns aj at erisian.com.au writes:\n> > >\n> > > > If you publish to the blockchain:\n> > > > ...\n> > > > 4 can be dropped, state 5 and finish can be altered). Since the CSV delay\n> > > > is chosen by the participants, the above is still a possible scenario\n> > > > in eltoo, though, and it means there's some risk for someone accepting\n> > > > bitcoins that result from a non-cooperative close of an eltoo channel.\n> > >\n> > > AJ, this was a meandering random walk which shed very little light.\n> > > I don't find the differentiation between malicious and non-malicious\n> > > double-spends convincing. Even if you trust A, you already have to\n> > > worry about person-who-sent-the-coins-to-A. This expands that set to be\n> > > \"miner who mined coins sent-to-A\", but it's very hard to see what\n> > > difference that makes to how you'd handle coins from A.\n> > >\n> > > > Beyond that, I think NOINPUT has two fundamental ways to cause problems\n> > > > for the people doing NOINPUT sigs:\n> > > >\n> > > > 1.  your signature gets applied to a unexpectedly different\n> > > >     script, perhaps making it look like you've being dealing\n> > > >     with some blacklisted entity. OP_MASK and similar solves\n> > > >     this.\n> > > >\n> > >\n> > > ... followed by two paragraphs describing how it's not a \"fundamental\n> > > way to cause problems\" that you (or I) can see.\n> > >\n> > > > For the second case, that seems a little more concerning. The nightmare\n> > > > scenario is maybe something like:\n> > > >\n> > > > -   naive users do silly things with NOINPUT signatures, and end up\n> > > >     losing funds due to replays like the above\n> > > >\n> > >\n> > > As we've never seen with SIGHASH_NONE?\n> > >\n> > > > -   initial source of funds was some major exchange, who decide it's\n> > > >     cheaper to refund the lost funds than deal with the customer complaints\n> > > >\n> > > > -   the lost funds end up costing enough that major exchanges just outright\n> > > >     ban sending funds to any address capable of NOINPUT, which also bans\n> > > >     all taproot/schnorr addresses\n> > > >\n> > >\n> > > I don't find this remotely credible.\n> > >\n> > > > FWIW, I don't have a strong opinion here yet, but:\n> > > >\n> > > > -   I'm still inclined to err on the side of putting more safety\n> > > >     measures in for NOINPUT, rather than fewer\n> > > >\n> > >\n> > > In theory, sure. But not feel-good and complex \"safety measures\" which\n> > > don't actually help in practical failure scenarios.\n> > >\n> > > > -   the \"must have a sig that commits to the input tx\" seems like it\n> > > >     should be pretty safe, not too expensive, and keeps taproot's privacy\n> > > >     benefits in the cases where you end up needing to use NOINPUT\n> > > >\n> > >\n> > > If this is considered necessary, can it be a standardness rule rather\n> > > than consensus?\n> > > Thanks,\n> > > Rusty.\n> >\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-03-21T08:37:54",
                "message_text_only": "> On 20 Mar 2019, at 4:07 PM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hi aj,\n> \n> Re-reading again, I think perhaps I was massively confused by this:\n> \n>> - alternatively, we could require every script to have a valid signature\n>> that commits to the input. In that case, you could do eltoo with a\n>> script like either:\n>> \n>> <A> CHECKSIGVERIFY <B> CHECKSIG\n>> or <P> CHECKSIGVERIFY <Q> CHECKSIG\n>> \n>> \n>> where A is Alice's key and B is Bob's key, P is muSig(A,B) and Q is\n>> a key they both know the private key for. In the first case, Alice\n>> would give Bob a NOINPUT sig for the tx, and when Bob wanted to publish\n>> Bob would just do a SIGHASH_ALL sig with his own key. In the second,\n>> Alice and Bob would share partial NOINPUT sigs of the tx with P, and\n>> finish that when they wanted to publish.\n> \n> Do you mean that *either* of the above two scripts is OK, *or* do you mean they are alternatives within a single MAST or `OP_IF`?\n> \n\nIt means either.\n\nIf you use <A> CHECKSIGVERIFY <B> CHECKSIG style, A and B will exchange the NOINPUT sig, and they will add the required non-NOINPUT sig when needed.\n\nIf you use <muSig(A,B)> CHECKVERIFY <Q> CHECKSIG, A and B will co-sign the muSig(A,B) with NOINPUT. They will also share the private key of Q, so they could produce a non-NOINPUT sig when needed.\n\nThe first style is slightly easier as it doesn\u2019t need muSig. But with 3 or more parties, the second style is more efficient.\n\nHowever, if you use watchtower, you have to use the second style. That means you need to share the private key for Q with the watchtower, That also means the watchtower will have the ability to reply the NOINPU muSig. But it is still strictly better than anyone-can-replay.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190321/7a2ef867/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-21T09:06:14",
                "message_text_only": "On Wed, Mar 20, 2019 at 08:07:00AM +0000, ZmnSCPxj via Lightning-dev wrote:\n> Re-reading again, I think perhaps I was massively confused by this:\n> > that commits to the input. In that case, you could do eltoo with a\n> > script like either:\n> > <A> CHECKSIGVERIFY <B> CHECKSIG\n> > or <P> CHECKSIGVERIFY <Q> CHECKSIG\n> Do you mean that *either* of the above two scripts is OK, *or* do you mean they are alternatives within a single MAST or `OP_IF`?\n\nI meant \"either of the two scripts is okay\".\n\n> In the blob sent to Watchtower, A (or B) includes the `SIGHASH_NOINPUT` as well as the `q` private key.\n> Would it be safe for Watchtower to know that?\n\nI think so. From Alice/Bob's point-of-view, the NOINPUT sig ensures they\ncontrol their money; and from the network's point-of-view (or at least\nthat part of the network that thinks NOINPUT is unsafe) the Q private\nkey being shared makes the tx no worse than a 1-of-n multisig setup,\nwhich has to be dealt with anyway.\n\n> Then each update transaction pays out to:\n>     OP_IF\n>         <csv_delta> OP_CSV OP_DROP\n>         <muSig(A_si,B_si)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n>     OP_ELSE\n>         <i> OP_CHECKLOCKTIMEVERIFY OP_DROP\n>         <muSig(A_u,B_u)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n>     OP_ENDIF\n\nYeah.\n\nI think we could potentially make that shorter still:\n\n   IF OP_CODESEPARATOR <i> OP_CHECKLOCKTIMEVERIFY OP_DROP ENDIF\n   <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n\nSigning with NOINPUT,NOSCRIPT and codeseparatorpos=1 enforces CLTV\nand allows binding to any prior update tx -- so works for an update tx\nspending previous update txs; while signing with codeseparatorpos=-1\nand NOINPUT but committing to the script code and nSequence (for the\nCSV delay) allows binding to only that update tx -- so works for the\nsettlement tx. That's two pubkeys, two sigs, and the taproot point\nreveal.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-21T10:05:09",
                "message_text_only": "Good morning aj,\n\n> > Then each update transaction pays out to:\n> > OP_IF\n> > <csv_delta> OP_CSV OP_DROP\n> > <muSig(A_si,B_si)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n> > OP_ELSE\n> > <i> OP_CHECKLOCKTIMEVERIFY OP_DROP\n> > <muSig(A_u,B_u)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n> > OP_ENDIF\n>\n> Yeah.\n>\n> I think we could potentially make that shorter still:\n>\n> IF OP_CODESEPARATOR <i> OP_CHECKLOCKTIMEVERIFY OP_DROP ENDIF\n> <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n>\n> Signing with NOINPUT,NOSCRIPT and codeseparatorpos=1 enforces CLTV\n> and allows binding to any prior update tx -- so works for an update tx\n> spending previous update txs; while signing with codeseparatorpos=-1\n> and NOINPUT but committing to the script code and nSequence (for the\n> CSV delay) allows binding to only that update tx -- so works for the\n> settlement tx. That's two pubkeys, two sigs, and the taproot point\n> reveal.\n\n\nActually, the shared keys are different in the two branches above.\nThe \"update\" branch (which has no `OP_CSV`) uses the same constant `A_u` and `B_u` points.\nThe \"state commit\" branch (which has `OP_CSV`) uses different `A_si` and `B_si` points depending on `i` (state/sequence number).\n\nAlso, I cannot understand `OP_CODESEPARATOR`, please no.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-21T11:55:22",
                "message_text_only": "On Thu, Mar 21, 2019 at 10:05:09AM +0000, ZmnSCPxj wrote:\n> > IF OP_CODESEPARATOR <i> OP_CHECKLOCKTIMEVERIFY OP_DROP ENDIF\n> > <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n> > Signing with NOINPUT,NOSCRIPT and codeseparatorpos=1 enforces CLTV\n> > and allows binding to any prior update tx -- so works for an update tx\n> > spending previous update txs; while signing with codeseparatorpos=-1\n> > and NOINPUT but committing to the script code and nSequence (for the\n> > CSV delay) allows binding to only that update tx -- so works for the\n> > settlement tx. That's two pubkeys, two sigs, and the taproot point\n> > reveal.\n> \n> Actually, the shared keys are different in the two branches above.\n\nYes, if you're not committing to the script code you need the separate\nkeys as otherwise any settlement transaction could be used with any\nupdate transaction. \n\nIf you are committing to the script code, though, then each settlement\nsig is already only usable with the corresponding update tx, so you\ndon't need to roll the keys. But you do need to make it so that the\nupdate sig requires the CLTV; one way to do that is using codeseparator\nto distinguish between the two cases.\n\n> Also, I cannot understand `OP_CODESEPARATOR`, please no.\n\nIf codeseparator is too scary, you could probably also just always\nrequire the locktime (ie for settlmenet txs as well as update txs), ie:\n\n  OP_CHECKLOCKTIMEVERIFY OP_DROP\n  <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n\nand have update txs set their timelock; and settlement txs set a absolute\ntimelock, relative timelock via sequence, and commit to the script code.\n\n(Note that both those approaches (with and without codesep) assume there's\nsome flag that allows you to commit to the scriptcode even though you're\nnot committing to your input tx (and possibly not committing to the\nscriptpubkey). BIP118 doesn't have that flexibility, so the A_s_i and\nB_s_i key rolling is necessary)\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-22T01:59:14",
                "message_text_only": "Good morning aj,\n>\n> If you are committing to the script code, though, then each settlement\n> sig is already only usable with the corresponding update tx, so you\n> don't need to roll the keys. But you do need to make it so that the\n> update sig requires the CLTV; one way to do that is using codeseparator\n> to distinguish between the two cases.\n>\n> > Also, I cannot understand `OP_CODESEPARATOR`, please no.\n>\n> If codeseparator is too scary, you could probably also just always\n> require the locktime (ie for settlmenet txs as well as update txs), ie:\n>\n> OP_CHECKLOCKTIMEVERIFY OP_DROP\n> <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n>\n> and have update txs set their timelock; and settlement txs set a absolute\n> timelock, relative timelock via sequence, and commit to the script code.\n>\n> (Note that both those approaches (with and without codesep) assume there's\n> some flag that allows you to commit to the scriptcode even though you're\n> not committing to your input tx (and possibly not committing to the\n> scriptpubkey). BIP118 doesn't have that flexibility, so the A_s_i and\n> B_s_i key rolling is necessary)\n\nI think the issue I have here is the lack of `OP_CSV` in the settlement branch.\n\nConsider a channel with offchain transactions update-1, settlement-1, update-2, and settlement-2.\nIf update-1 is placed onchain, update-1 is also immediately spendable by settlement-1.\nBut settlement-1 cannot be spent by update-2 and thus the invalidation of older state fails.\n\nThe `OP_CSV` in the settlement branch of the update transaction outputs exists to allow later update transactions have higher priority over settlement transactions.\n\nTo ensure that a settlement signature can only take the settlement branch, we need a distinct public key for the branch, so at least `A_s` and `B_s` without rolling them for each `i`, if we use `nLockTime` on the settlement transactions and enforce it with `OP_CHECKLOCKTIMEVERIFY`.\nIt might be possible to do this with `OP_CODESEPARATOR`, but we do need the `OP_CSV` in the settlement branch.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-03-22T02:58:46",
                "message_text_only": "On Fri, Mar 22, 2019 at 01:59:14AM +0000, ZmnSCPxj wrote:\n> > If codeseparator is too scary, you could probably also just always\n> > require the locktime (ie for settlmenet txs as well as update txs), ie:\n> > OP_CHECKLOCKTIMEVERIFY OP_DROP\n> > <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n> > and have update txs set their timelock; and settlement txs set a absolute\n> > timelock, relative timelock via sequence, and commit to the script code.\n> \n> I think the issue I have here is the lack of `OP_CSV` in the settlement branch.\n\nYou can enforce the relative timelock in the settlement branch simply\nby refusing to sign a settlement tx that doesn't have the timelock set;\nthe OP_CSV is redundant.\n\n> Consider a channel with offchain transactions update-1, settlement-1, update-2, and settlement-2.\n> If update-1 is placed onchain, update-1 is also immediately spendable by settlement-1.\n\nsettlement-1 was signed by you, and when you signed it you ensured that\nnsequence was set as per BIP-68, and NOINPUT sigs commit to nsequence,\nso if anyone changed that after the fact the sig isn't valid. Because\nBIP-68 is enforced by consensus, update-1 isn't immediately spendable\nby settlement-1.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-22T07:46:28",
                "message_text_only": "Good morning aj,\n\nI understand.\nLooks like that makes sense.\nIt seems possible to use this, then, together with watchtowers.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, March 22, 2019 10:58 AM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Fri, Mar 22, 2019 at 01:59:14AM +0000, ZmnSCPxj wrote:\n>\n> > > If codeseparator is too scary, you could probably also just always\n> > > require the locktime (ie for settlmenet txs as well as update txs), ie:\n> > > OP_CHECKLOCKTIMEVERIFY OP_DROP\n> > > <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n> > > and have update txs set their timelock; and settlement txs set a absolute\n> > > timelock, relative timelock via sequence, and commit to the script code.\n> >\n> > I think the issue I have here is the lack of `OP_CSV` in the settlement branch.\n>\n> You can enforce the relative timelock in the settlement branch simply\n> by refusing to sign a settlement tx that doesn't have the timelock set;\n> the OP_CSV is redundant.\n>\n> > Consider a channel with offchain transactions update-1, settlement-1, update-2, and settlement-2.\n> > If update-1 is placed onchain, update-1 is also immediately spendable by settlement-1.\n>\n> settlement-1 was signed by you, and when you signed it you ensured that\n> nsequence was set as per BIP-68, and NOINPUT sigs commit to nsequence,\n> so if anyone changed that after the fact the sig isn't valid. Because\n> BIP-68 is enforced by consensus, update-1 isn't immediately spendable\n> by settlement-1.\n>\n> Cheers,\n> aj"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-03-22T04:23:28",
                "message_text_only": "> On 22 Mar 2019, at 9:59 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Good morning aj,\n>> \n>> If you are committing to the script code, though, then each settlement\n>> sig is already only usable with the corresponding update tx, so you\n>> don't need to roll the keys. But you do need to make it so that the\n>> update sig requires the CLTV; one way to do that is using codeseparator\n>> to distinguish between the two cases.\n>> \n>>> Also, I cannot understand `OP_CODESEPARATOR`, please no.\n>> \n>> If codeseparator is too scary, you could probably also just always\n>> require the locktime (ie for settlmenet txs as well as update txs), ie:\n>> \n>> OP_CHECKLOCKTIMEVERIFY OP_DROP\n>> <muSig(A_u,B_u)> OP_CHECKDLSVERIFY <Q> OP_CHECKDLS\n>> \n>> and have update txs set their timelock; and settlement txs set a absolute\n>> timelock, relative timelock via sequence, and commit to the script code.\n>> \n>> (Note that both those approaches (with and without codesep) assume there's\n>> some flag that allows you to commit to the scriptcode even though you're\n>> not committing to your input tx (and possibly not committing to the\n>> scriptpubkey). BIP118 doesn't have that flexibility, so the A_s_i and\n>> B_s_i key rolling is necessary)\n> \n> I think the issue I have here is the lack of `OP_CSV` in the settlement branch.\n> \n> Consider a channel with offchain transactions update-1, settlement-1, update-2, and settlement-2.\n> If update-1 is placed onchain, update-1 is also immediately spendable by settlement-1.\n> But settlement-1 cannot be spent by update-2 and thus the invalidation of older state fails.\n> \n> The `OP_CSV` in the settlement branch of the update transaction outputs exists to allow later update transactions have higher priority over settlement transactions.\n> \n> To ensure that a settlement signature can only take the settlement branch, we need a distinct public key for the branch, so at least `A_s` and `B_s` without rolling them for each `i`, if we use `nLockTime` on the settlement transactions and enforce it with `OP_CHECKLOCKTIMEVERIFY`.\n> It might be possible to do this with `OP_CODESEPARATOR`, but we do need the `OP_CSV` in the settlement branch.\n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n\nOP_CSV (BIP112) is not needed. Only BIP68 relative-time is needed.\n\nWith this script:\n\n<t> OP_CHECKLOCKTIMEVERIFY OP_DROP <muSig(A,B)> OP_CHECKSIGVERIFY <Q> OP_CHECKSIG\n\nFor update purpose, A and B will co-sign the muSig with nLockTime = t, not committing to the scriptCode, and no BIP68 lock time\n\nFor settlement purpose, A and B will co-sign the muSig with nLockTime = t, committing to the scriptCode, and with an agreed BIP68 locktime\n\nWithout committing to the scriptCode and BIP68 lock time, the update sig could be bind to any previous update tx immediately.\n\nOTOH, the settlement sig will only bind to a specific update tx (thought scriptCode), and only after the relative locktime is passed.\n\nThe eltoo paper is wrong about using OP_CSV. That\u2019s a common mistake even for experienced bitcoin developer. OP_CSV is needed only if one party could single handedly decide the relative-lock-time. However, this is not the case here as it is a muSig.\n\n(With some risks of distracting the discussion, please note that even this script: <t> OP_CHECKLOCKTIMEVERIFY OP_DROP <A> OP_CHECKSIGVERIFY <B> OP_CHECKSIG doesn\u2019t need OP_CSV, despite not using muSig. It is because the 2 sigs must use the same relative locktime, or the tx is invalid.)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/3337a8f8/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "More thoughts on NOINPUT safety",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Johnson Lau",
                "ZmnSCPxj",
                "Christian Decker"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 47704
        }
    },
    {
        "title": "[bitcoin-dev] Payjoin privacy with the receiver of the transaction",
        "thread_messages": [
            {
                "author": "Kenshiro []",
                "date": "2019-03-18T10:55:34",
                "message_text_only": "Hi,\n\nI think Payjoin can be a very good privacy solution for Bitcoin, but I have a question about it:\n\n- If a user has 1 BTC in a single address and make a payjoin payment to other person of 0.1 BTC using that address as input, the other person can see in a blockchain explorer the change address with an amount of 0.9 BTC. That's a serious privacy leak. I would like to know what will be the standard solution to this issue. An easy fix could be that the user wallet check if any address contains a BTC amount higher than a \"safe\" amount like 0.01 BTC or less. If some address exceed that amount the wallet could automatically make 1 payment to itself to split the amount in several addresses. In this way nobody receiving a payment from a user will ever know that he has a bitcoin balance higher than the \"safe\" amount.\n\nWhat do you think?\n\nRegards,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190318/e1d97bdb/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-03-21T16:52:41",
                "message_text_only": "I'm not really sure the problem you're describing, but it sounds like something that affects normal bitcoin transactions as well.\n\nThere's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n\nIn general though, there's like a 1000 different things you can do with coin selection, utxo management (and payjoin contributed input selection) but more often than not you are just making just making 1 trade off for another and good solutions will be wildly different depending on how you use your wallet.\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, March 18, 2019 3:55 AM, Kenshiro \\[\\] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I think Payjoin can be a very good privacy solution for Bitcoin, but I have a question about it:\n>\n> - If a user has 1 BTC in a single address and make a payjoin payment to other person of 0.1 BTC using that address as input, the other person can see in a blockchain explorer the change address with an amount of 0.9 BTC. That's a serious privacy leak. I would like to know what will be the standard solution to this issue. An easy fix could be that the user wallet check if any address contains a BTC amount higher than a \"safe\" amount like 0.01 BTC or less. If some address exceed that amount the wallet could automatically make 1 payment to itself to split the amount in several addresses. In this way nobody receiving a payment from a user will ever know that he has a bitcoin balance higher than the \"safe\" amount.\n>\n> What do you think?\n>\n> Regards,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190321/a8697048/attachment-0001.html>"
            },
            {
                "author": "Kenshiro []",
                "date": "2019-03-22T10:23:24",
                "message_text_only": ">I'm not really sure the problem you're describing, but it sounds like something that affects normal bitcoin transactions as well.\n\nYeah, it affects normal transactions too. But I'm focused in Payjoin because it should allow private transactions. The problem I see is that Payjoin shouldn't allow that the sender or the receiver of the transaction can get information about the bitcoin balance of each other. A person could have his savings in btc in a single address, use Payjoin to send/receive a payment thinking it's private and leaking to the receptor he has a high amount of btc. But an automatic splitting to itself in the background could solve the problem (maybe 100$ amounts) or so.\n\n>There's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n\nFor users that really want privacy it should not be a problem. When a wallet receive a high amount of btc (+100$ or another amount defined by the user) it can automatically make a transaction to itself splitting the amount in several addresses. The amounts that are already small don't need to be splitted again. Small amount addresses + Payjoin could give real privacy to bitcoin users. Users that don't want privacy could disable the \"Private\" mode in the wallet and disable the auto-splitting feature.\n\ni.e.: you receive 1000$ in btc and the wallet make an automatic transaction to itself to 10 addresses, 100$ each.\n\nI would prefer wait some time and have privacy than the opposite.\n\nRegards\n\n________________________________\nFrom: rhavar at protonmail.com <rhavar at protonmail.com>\nSent: Thursday, March 21, 2019 17:52\nTo: Kenshiro \\[\\]; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] Payjoin privacy with the receiver of the transaction\n\nI'm not really sure the problem you're describing, but it sounds like something that affects normal bitcoin transactions as well.\n\nThere's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n\nIn general though, there's like a 1000 different things you can do with coin selection, utxo management (and payjoin contributed input selection) but more often than not you are just making just making 1 trade off for another and good solutions will be wildly different depending on how you use your wallet.\n\n\n-Ryan\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, March 18, 2019 3:55 AM, Kenshiro \\[\\] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\nHi,\n\nI think Payjoin can be a very good privacy solution for Bitcoin, but I have a question about it:\n\n- If a user has 1 BTC in a single address and make a payjoin payment to other person of 0.1 BTC using that address as input, the other person can see in a blockchain explorer the change address with an amount of 0.9 BTC. That's a serious privacy leak. I would like to know what will be the standard solution to this issue. An easy fix could be that the user wallet check if any address contains a BTC amount higher than a \"safe\" amount like 0.01 BTC or less. If some address exceed that amount the wallet could automatically make 1 payment to itself to split the amount in several addresses. In this way nobody receiving a payment from a user will ever know that he has a bitcoin balance higher than the \"safe\" amount.\n\nWhat do you think?\n\nRegards,\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/4684a924/attachment-0001.html>"
            },
            {
                "author": "Kenshiro []",
                "date": "2019-03-22T11:15:26",
                "message_text_only": "They Payjoin protocol could include the possibility of receive \"safe\" amounts (i.e.: 0.025 btc) to several addresses so every user using Payjoin already have a splitted balance. Only people receiving a regular public transaction should need the extra splitting transaction.\n\nRegards\n\n________________________________\nFrom: Kenshiro []\nSent: Friday, March 22, 2019 11:23\nTo: Bitcoin Protocol Discussion; rhavar at protonmail.com\nSubject: Re: [bitcoin-dev] Payjoin privacy with the receiver of the transaction\n\n>I'm not really sure the problem you're describing, but it sounds like something that affects normal bitcoin transactions as well.\n\nYeah, it affects normal transactions too. But I'm focused in Payjoin because it should allow private transactions. The problem I see is that Payjoin shouldn't allow that the sender or the receiver of the transaction can get information about the bitcoin balance of each other. A person could have his savings in btc in a single address, use Payjoin to send/receive a payment thinking it's private and leaking to the receptor he has a high amount of btc. But an automatic splitting to itself in the background could solve the problem (maybe 100$ amounts) or so.\n\n>There's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n\nFor users that really want privacy it should not be a problem. When a wallet receive a high amount of btc (+100$ or another amount defined by the user) it can automatically make a transaction to itself splitting the amount in several addresses. The amounts that are already small don't need to be splitted again. Small amount addresses + Payjoin could give real privacy to bitcoin users. Users that don't want privacy could disable the \"Private\" mode in the wallet and disable the auto-splitting feature.\n\ni.e.: you receive 1000$ in btc and the wallet make an automatic transaction to itself to 10 addresses, 100$ each.\n\nI would prefer wait some time and have privacy than the opposite.\n\nRegards\n\n________________________________\nFrom: rhavar at protonmail.com <rhavar at protonmail.com>\nSent: Thursday, March 21, 2019 17:52\nTo: Kenshiro \\[\\]; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] Payjoin privacy with the receiver of the transaction\n\nI'm not really sure the problem you're describing, but it sounds like something that affects normal bitcoin transactions as well.\n\nThere's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n\nIn general though, there's like a 1000 different things you can do with coin selection, utxo management (and payjoin contributed input selection) but more often than not you are just making just making 1 trade off for another and good solutions will be wildly different depending on how you use your wallet.\n\n\n-Ryan\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, March 18, 2019 3:55 AM, Kenshiro \\[\\] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\nHi,\n\nI think Payjoin can be a very good privacy solution for Bitcoin, but I have a question about it:\n\n- If a user has 1 BTC in a single address and make a payjoin payment to other person of 0.1 BTC using that address as input, the other person can see in a blockchain explorer the change address with an amount of 0.9 BTC. That's a serious privacy leak. I would like to know what will be the standard solution to this issue. An easy fix could be that the user wallet check if any address contains a BTC amount higher than a \"safe\" amount like 0.01 BTC or less. If some address exceed that amount the wallet could automatically make 1 payment to itself to split the amount in several addresses. In this way nobody receiving a payment from a user will ever know that he has a bitcoin balance higher than the \"safe\" amount.\n\nWhat do you think?\n\nRegards,\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/05f9ab2b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-03-22T16:05:13",
                "message_text_only": "Good morning,\n\n> >There's certainly some interesting about the idea of \"pre-fragmenting\" your wallet utxo so you can make (or in payjoin: receive) payments with better privacy aspects.However, it's pretty unlikely to be practical for normal users, as it'll generally result in pretty big and cost-ineffective transactions.\n>\n> For users that really want privacy it should not be a problem. When a wallet receive a high amount of btc (+100$ or another amount defined by the user) it can automatically make a transaction to itself splitting the amount in several addresses. The amounts that are already small don't need to be splitted again. Small amount addresses + Payjoin could give real privacy to bitcoin users. Users that don't want privacy could disable the \"Private\" mode in the wallet and disable the auto-splitting feature.\u00a0\n>\n> i.e.: you receive 1000$ in btc and the wallet make an automatic transaction to itself to 10 addresses, 100$ each.\n>\n\nIt seems to me, to interact somewhat with ZeroLink.\n\nUnder ZeroLink, post-mix UTXOs must not be combined.\n(Basic Post-Mix Wallet Requirement: \"Post-mix wallet MUST prevent joining inputs together.\")\n\nThe upshot of this, for practical use, is that as payments are done by the user, available coins become smaller and smaller.\nAnd the maximum amount the user can pay with, is limited by the largest post-mix coin they have.\n\nIf a ZeroLink post-mix wallet were to split its UTXOs as soon as it got them from the mix, then it would immediately find itself limiting the maximum amount the user could pay.\nI suppose if the ZeroLink post-mix wallet had multiple post-mix coins, it could split one of them for the same purpose as above.\n\nAnother thought, is if a ZeroLink post-mix wallet could support a Payjoin, as either receiver or sender.\nNaively, it seems to me to improve privacy to do so, as long as the ZeroLink post-mix wallet only provides a single UTXO to the Payjoin, whether as receiver or sender.\nFor a ZeroLink post-mix wallet to a ZeroLink post-mix wallet Payjoin, this would typically result in a two-input, two-output transaction, with both participants having one input and one output each in the transaction, but difficult (?) for third parties to determine which input/output belongs to which.\n\nNow, if we suppose that both ZeroLink and Payjoin become commonly used, then it is likely that two users using the same Chaumian CoinJoin mix transaction will find that one needs to pay the other.\nThus hopefully it may become common for a Chaumian CoinJoin mix transaction to have outputs that (directly or indirectly) merge into Payjoin two-input two-output transactions.\nThis can then be used to allow a ZeroLink post-mix wallet some limited amount of merging its post-mix UTXOs.\nFor instance, if a ZeroLink post-mix wallet has a 0.25BTC and a 0.15BTC coin, and needs to pay 0.3 BTC, it may very well simulate a Payjoin to itself, and create a transaction (0.25, 0.15) -> (0.35, 0.05).\nThen it can use the 0.35BTC output to pay the 0.3 BTC.\n\nPossibly, anyway.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Payjoin privacy with the receiver of the transaction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "rhavar at protonmail.com",
                "Kenshiro []"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 14331
        }
    },
    {
        "title": "[bitcoin-dev] Notice: List Infrastructure Migration",
        "thread_messages": [
            {
                "author": "Warren Togami Jr.",
                "date": "2019-03-18T22:35:47",
                "message_text_only": "Be advised that starting this week bitcoin-dev, lightning-dev and other\nBitcoin-oriented lists currently still active at\nhttps://lists.linuxfoundation.org/mailman/listinfo will begin migration to\nthe Linux Foundation's new list infrastructure operated by groups.io. You\nmay continue to use these lists as-is until each list is notified that\nmigration is complete. It is unclear when the switch-over happens because\nwe need imports to complete without error and some testing to pass.\n\nIMPORTANT: If you do not wish to be auto-subscribed to the new list\nmanagement system then please unsubscribe prior to the migration.\n\nARCHIVES: The archives are of utmost importance for prior art and historic\nvalue. We are working on a plan with the Linux Foundation sysadmins to\nensure the current archive permalinks will remain as-is static or to\nredirect to the correct post that lives at a new archive.\n\nhttps://lwn.net/Articles/748184/\nThe new archive will be operated independently outside from the Linux\nFoundation as generated by this open source tool. This hopefully will allow\nall future archives to never move again even if the underlying list\ninfrastructure needs to change. Folks will appreciate the search function\nand git clone for a local instance.\n\nMore details to be posted here soon.\n\nWarren Togami\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190318/3d416ccf/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-03-19T18:01:51",
                "message_text_only": "On Mon, Mar 18, 2019 at 06:35:47PM -0400, Warren Togami Jr. via bitcoin-dev wrote:\n> The new archive will be operated independently outside from the Linux\n> Foundation as generated by this open source tool. This hopefully will allow\n> all future archives to never move again even if the underlying list\n> infrastructure needs to change. Folks will appreciate the search function\n> and git clone for a local instance.\n\nWhere will that git archive actually be created/maintained? As this will be a\nGit repo, looks like getting it timestamped could be as simple as installing\nOpenTimestamps appropriately on whatever server is actually maintaining it.\n\nEqually, it'd be good to have the archive PGP signed.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190319/b5845f26/attachment.sig>"
            },
            {
                "author": "Omar Shibli",
                "date": "2019-03-20T06:03:24",
                "message_text_only": "Also, quick question, is groups.io has same structure as Linux Foundation?\nfoundation/transparency/openness... I think in general it would be great if\nthis migration will be communicated much more in advance with relaxed\ntimelines, just by examining priori cases, it's all suggestions. hope next\nphase will be more inclusive and open.\n\nOn Wed, Mar 20, 2019 at 2:45 AM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Mar 18, 2019 at 06:35:47PM -0400, Warren Togami Jr. via\n> bitcoin-dev wrote:\n> > The new archive will be operated independently outside from the Linux\n> > Foundation as generated by this open source tool. This hopefully will\n> allow\n> > all future archives to never move again even if the underlying list\n> > infrastructure needs to change. Folks will appreciate the search function\n> > and git clone for a local instance.\n>\n> Where will that git archive actually be created/maintained? As this will\n> be a\n> Git repo, looks like getting it timestamped could be as simple as\n> installing\n> OpenTimestamps appropriately on whatever server is actually maintaining it.\n>\n> Equally, it'd be good to have the archive PGP signed.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190320/67fa0e4a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Notice: List Infrastructure Migration",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Warren Togami Jr.",
                "Omar Shibli",
                "Peter Todd"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4123
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal - Hashed Time-Locked Collateral Contract transactions",
        "thread_messages": [
            {
                "author": "Matthew Black",
                "date": "2019-03-22T17:29:46",
                "message_text_only": "I have written up a proposed BIP. It has to do a new cross-chain debt\nprotocol. It is here:\nhttps://github.com/AtomicLoans/BIP/blob/master/README.md\n\nThis BIP was written up for the Atomic Loans protocol specified here:\nhttps://arxiv.org/pdf/1901.05117.pdf\n\nAny feedback would be appreciated. Please let me know what the steps are\nwith regards to getting a BIP number assigned or any other process steps\nrequired.\n\nRegards,\nMatthew\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/8a675a21/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal - Hashed Time-Locked Collateral Contract transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Matthew Black"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 619
        }
    },
    {
        "title": "[bitcoin-dev] New BIP - v2 peer-to-peer message transport protocol (former BIP151)",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2019-03-22T21:04:46",
                "message_text_only": "Hi\n\nThe overhauled version of the former BIP151 has fundamental differences and deserves (requires?) a new BIP.\nCalling it \u201ev2 peer-to-peer message transport protocol\u201c is more accurate since it is no longer only about encryption.\n\nThe formatted draft proposal can be found here: https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52\n\nSignificant changes compared to the current available BIP151\n* A optimised AEAD construct is now proposed (ChaCha20Poly1305 at Bitcoin), reducing the required ChaCha20 rounds (compared to the openSSH version).\n* introduce NODE_P2P_V2\n* 32bytes-per-side \u201epseudorandom\" key exchange\n* the multi message envelope has been removed\n* the length of a packet uses now a 3-byte integer with 23 available bits\n* introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in\n some v2 messages require less bandwidth then v1\n* the key derivation and what communication direction uses what key is now more\n specific\n\nFirst benchmarks of the used primitives\nhttps://github.com/bitcoin/bitcoin/pull/15519#issuecomment-469705289 <https://github.com/bitcoin/bitcoin/pull/15519#issuecomment-469705289>\n\nBenchmark of the AEAD compared to the HASH (double SHA256)\n(Indicates that v2 messages may be more performant):\nhttps://github.com/bitcoin/bitcoin/pull/15649#issuecomment-475782376 <https://github.com/bitcoin/bitcoin/pull/15649#issuecomment-475782376>\n\n\nProposal:\n\n<pre>\n  BIP: ???\n  Layer: Peer Services\n  Title: Version 2 Peer-to-Peer Message Transport Protocol\n  Author: Jonas Schnelli <dev at jonasschnelli.ch>\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-03-08\n  License: PD\n</pre>\n\n== Abstract ==\n\nThis BIP describes a new Bitcoin peer to peer transport protocol with\nopportunistic encryption.\n\n== Motivation ==\n\nThe current peer-to-peer protocol is partially inefficient and in plaintext.\n\nWith the current unencrypted message transport, BGP hijack, block delay attacks\nand message tempering are inexpensive and can be executed in a covert way\n(undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf\nHijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A.\nZohar, L.Vanbever]</ref>.\n\nAdding opportunistic encryption introduces a high risk for attackers of being\ndetected. Peer operators can compare encryption session IDs or use other form\nof authentication schemes <ref\nname=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki\nBIP150]</ref> to identify an attack.\n\nEach current version 1 Bitcoin peer-to-peer message uses a double-SHA256\nchecksum truncated to 4 bytes. Roughly the same amount of computation power\nwould be required for encrypting and authenticating a peer-to-peer message with\nChaCha20 & Poly1305.\n\nAdditionally, this BIP describes a way how data manipulation (blocking or\ntempering commands by an intercepting TCP/IP node) would be identifiable by the\ncommunicating peers.\n\nEncrypting traffic between peers is already possible with VPN, tor, stunnel,\ncurveCP or any other encryption mechanism on a deeper OSI level, however, most\nof those solutions require significant knowhow in how to setup such a secure\nchannel and are therefore not widely deployed.\n\n== Specification ==\n\n<blockquote>\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\ninterpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119\nRFC 2119]</ref>.\n</blockquote>\n\nA peer that supports the message transport protocol as defined in this proposal\nMUST accept encryption requests from all peers.\n\nBoth communication direction share the same shared-secret but have different\nsymmetric cipher keys.\n\nThe encryption handshake MUST happen before sending any other messages to the\nresponding peer.\n\nIf the responding peer closes the connection after sending the handshake\nrequest, the initiating peer MAY try to connect again with the v1 peer-to-peer\ntransport protocol. Such reconnects allow an attacker to \"downgrade\" the\nencryption to plaintext communication and thus, accepting v1 connections MUST\nnot be done when the Bitcoin peer-to-peer network uses almost only v2\ncommunication.\n\n\n=== NODE_P2P_V2 ===\n\nPeers supporting the transport protocol after this proposal MUST signal\n<code>NODE_P2P_V2</code>\n<pre>\nNODE_P2P_V2 = (1 << 11)\n</pre>\n\nA peer usually learns an address along with the expected service flags which\nMAY be used to filter possible outbound peers.\n\nA peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted communication\nspecified in this proposal.\n\nPeers MAY only make outbound connections to peers supporting\n<code>NODE_P2P_V2</code>.\n\n=== Handshake ===\n\n<pre>\n ----------------------------------------------------------------------------------------\n | Initiator                             Responder                                      |\n |                                                                                      |\n | x, X         := SECP256k1_KEYGEN()                                                   |\n | CLIENT_HDATA := X                                                                    |\n |                                                                                      |\n |               --- CLIENT_HDATA --->                                                  |\n |                                                                                      |\n |                                       y, Y           := SECP256k1_KEYGEN()           |\n |                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |\n |                                       SERVER_HDATA   := Y                            |\n |                                                                                      |\n |               <-- SERVER_HDATA ----                                                  |\n |                                                                                      |\n | ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |\n ----------------------------------------------------------------------------------------\n</pre>\n\nTo request encrypted communication (only possible if yet no other messages have\nbeen sent or received), the initiating peer generates an EC secp256k1 ephemeral\nkey and sends the corresponding 32-byte public key to the responding peer and\nwaits for the remote 32-byte public key from the counterparty.\n\nODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the\npublic key from the generated ephemeral key is an EVEN public key (starting\nwith 0x03), negating the key and recalculating its public key SHOULD be done.\nOnly using ODD public makes it more complex to identify the handshake based on\nanalyzing the traffic.\n\nThe handshake request and response message are raw 32byte payloads containing\nno header, length or checksum (the pure 32byte payload) and MUST be sent before\nanything else.\n\nPublic keys starting with the 4-byte network magic are forbidden and MUST lead\nto locally re-generate an ephemeral-key.\n\nPseudocode for the ephemeral-key generation\n<pre>\ndo {\n    ecdh_key.MakeNewKey();\n    if (ecdh_key.GetPubKey()[0] == 3) {\n        ecdh_key.Negate();\n    }\n} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);\n</pre>\n\nOnce a peer has received the public key from its counterparty, the shared\nsecret MUST be calculated by using secp256k1 ECDH.\n\nPrivate keys will never be transmitted. The shared secret can only be\ncalculated if an attacker knows at least one private key and the counterparties\npublic key. This key-exchange is based on the discrete log problem and thus not\nsufficiently strong against known forms of possible quantum computer\nalgorithms. Adding an additional quantum resistant key exchange like NewHope is\npossible but out of scope for this proposal.\n\nAfter a successful handshake, the messages format MUST use the \"v2 messages\nstructure\". Non-encrypted v1 messages from the initiating peer MUST lead to an\nimmediate connection termination.\n\nAfter a successful handshake, both peers MUST cleanse the ephemeral-session-key\nfrom memory and/or persistence storage.\n\nA peer not supporting this proposal will not perform the described handshake\nand thus send a v1 version message.\nPeers supporting this BIP MAY optionally allow unencrypted v1 communication by\ndetecting a v1 version message by the initial 11-byte sequence of <code>4byte\nnet magic || \"version\"</code>.\n\n=== Symmetric Encryption Cipher Keys ===\n\nOnce the ECDH secret (<code>ECDH_KEY</code>) is calculated on each side, the\nsymmetric encryption cipher keys MUST be derived with HKDF\n<ref>[https://tools.ietf.org/html/rfc5869 HKDF (RFC 5869)]</ref> after the\nfollowing specification:\n\n1. HKDF extraction\n<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY\", ikm=ECDH_KEY)</code>.\n\n2. Derive Key_1_A (K_1 communication direction A)\n<code>K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_A\", L=32)</code>\n\n2. Derive Key_2_A (K_2 communication direction A)\n<code>K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_A\", L=32)</code>\n\n3. Derive Key_1_B (K_1 communication direction B)\n<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_1_B\", L=32)</code>\n\n3. Derive Key_2_B (K_2 communication direction B)\n<code>K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK_2_B\", L=32)</code>\n\n=== Session ID ===\n\nBoth parties MUST also calculate the 256bit session-id using <code>SID =\nHKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The\nsession-id can be used for authenticating the encryption-session (identity\ncheck).\n\nThe session-id MUST be presented to the user on request.\n\n=== ChaCha20-Poly1305 at Bitcoin Cipher Suite ===\n\n==== Background ====\n\nChaCha20 is a stream cipher designed by Daniel Bernstein and described in\n<ref>[http://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>. It operates\nby permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64\nbit counter into 64 bytes of output. This output is used as a keystream, with\nany unused bytes simply discarded.\n\nPoly1305 <ref>[http://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>, also\nby Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit\nintegrity tag given a message and a single-use 256 bit secret key.\n\nThe chacha20-poly1305 at bitcoin combines these two primitives into an\nauthenticated encryption mode. The construction used is based on that proposed\nfor TLS by Adam Langley in\n<ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20\nand Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs in\nthe layout of data passed to the MAC and in the addition of encryption of the\npacket lengths.\n\n==== Detailed Construction ====\n\nThe chacha20-poly1305 at bitcoin cipher requires two 256 bits of key material as\noutput from the key exchange. Each key (K_1 and K_2) are used by two separate\ninstances of chacha20.\n\nThe instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\nbyte packet length field and has its own sequence number. The second instance,\nkeyed by K_2, is used in conjunction with poly1305 to build an AEAD\n(Authenticated Encryption with Associated Data) that is used to encrypt and\nauthenticate the entire packet.\n\nTwo separate cipher instances are used here so as to keep the packet lengths\nconfidential but not create an oracle for the packet payload cipher by\ndecrypting and using the packet length prior to checking the MAC. By using an\nindependently-keyed cipher instance to encrypt the length, an active attacker\nseeking to exploit the packet input handling as a decryption oracle can learn\nnothing about the payload contents or its MAC (assuming key derivation,\nChaCha20 and Poly1305 are secure).\n\nThe AEAD is constructed as follows: for each packet, generate a Poly1305 key by\ntaking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\nconsisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\nblock counter of zero. The K_2 ChaCha20 block counter is then set to the\nlittle-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\nis used for encryption of the packet payload.\n\n==== Packet Handling ====\n\nWhen receiving a packet, the length must be decrypted first. When 3 bytes of\nciphertext length have been received, they may be decrypted.\n\nA ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\ntimes a 3 bytes length field (21*3 = 63). The length field sequence number can\nthus be used 21 times (keystream caching).\n\nThe length field must be enc-/decrypted with the ChaCha20 keystream keyed with\nK_1 defined by block counter 0, the length field sequence number in little\nendian and a keystream position from 0 to 60.\n\nPseudo code example:\n<pre>\n// init\nsequence_nr_payload = 0; //payload sequence number\nsequence_nr_length_field = 0; //length field sequence number (will be reused)\naad_length_field_pos = 0; //position in the length field cipher instance keystream chunk\n\n...\n\n// actual encryption\nif cache_length_field_sequence_number != sequence_nr_length_field {\n  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);\n  cache_length_field_sequence_number = sequence_nr_length_field\n}\npacket_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])\n\nsequence_nr_payload++;\naad_length_field_pos += 3; //skip 3 bytes in keystream\nif (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...\n  aad_length_field_pos = 0; // reset at position 0\n  sequence_nr_length_field++; // increase length field sequence number\n}\n</pre>\n\nOnce the entire packet has been received, the MAC MUST be checked before\ndecryption. A per-packet Poly1305 key is generated as described above and the\nMAC tag calculated using Poly1305 with this key over the ciphertext of the\npacket length and the payload together. The calculated MAC is then compared in\nconstant time with the one appended to the packet and the packet decrypted\nusing ChaCha20 as described above (with K_2, the packet sequence number as\nnonce and a starting block counter of 1).\n\nDetection of an invalid MAC MUST lead to immediate connection termination.\n\nTo send a packet, first encode the 3 byte length and encrypt it using K_1 as\ndescribed above. Encrypt the packet payload (using K_2) and append it to the\nencrypted length. Finally, calculate a MAC tag and append it.\n\nThe initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\nthe send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\nthe receive channel.\n\nThe responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\nthe receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\non the send channel.\n\nOptimized implementations of ChaCha20-Poly1305 at bitcoin are relatively fast in\ngeneral, therefore it is very likely that encrypted messages require not more\nCPU cycles per bytes then the current unencrypted p2p message format\n(ChaCha20/Poly1305 versus double SHA256).\n\nThe initial packet sequence numbers are 0.\n\nK_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\nencryption nor may it be used to encrypt more than 2^70 bytes under the same\n{key, nonce}.\n\nK_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\nposition-in-keystream} for encryption nor may it be used to encrypt more than\n2^70 bytes under the same {key, nonce}.\n\nWe use message sequence numbers for both communication directions.\n\n<pre>\n ------------------------------------------------------------------------------------------\n | Initiator                          Responder                                           |\n |                                                                                        |\n | AEAD() = ChaCha20Poly1305Bitcoin()                                                     |\n | MSG_A_CIPH = AEAD(k=K_1_A, K_2_A, payload_nonce=0, aad_nonce=0, aad_pos=0, msg)        |\n |                                                                                        |\n |                         --- MSG_CIPH --->                                              |\n |                                                                                        |\n |                                    msg   := AEAD(k=K_1_A,K_2_A, n=0, ..., MSG_A_CIPH)  |\n |                                                                                        |\n ------------------------------------------------------------------------------------------\n</pre>\n\n==== Test Vectors ====\n\n<pre>\nmessage   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nk1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nk2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nAAD keystream\n76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n\nciphertext\n76 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n\nMAC\nd2 fc 11 82 9c 1b 6c 1d f1 f5 51 cd 61 31 ff 08\n</pre>\n\n<pre>\nmessage   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nk1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nk2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nAAD keystream\n76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86\n\nciphertext\n77 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32\n\nMAC\nba f0 c8 5b 6d ff 86 02 b0 6c f5 2a 6a ef c6 2e\n</pre>\n\n<pre>\nmessage\nff 00 00 f1 95 e6 69 82 10 5f fb 64 0b b7 75 7f 57 9d a3 16 02 fc 93 ec 01 ac 56 f8 5a c3 c1 34 a4 54 7b 73 3b 46 41 30 42 c9 44 00 49 17 69 05 d3 be 59 ea 1c 53 f1 59 16 15 5c 2b e8 24 1a 38 00 8b 9a 26 bc 35 94 1e 24 44 17 7c 8a de 66 89 de 95 26 49 86 d9 58 89 fb 60 e8 46 29 c9 bd 9a 5a cb 1c c1 18 be 56 3e b9 b3 a4 a4 72 f8 2e 09 a7 e7 78 49 2b 56 2e f7 13 0e 88 df e0 31 c7 9d b9 d4 f7 c7 a8 99 15 1b 9a 47 50 32 b6 3f c3 85 24 5f e0 54 e3 dd 5a 97 a5 f5 76 fe 06 40 25 d3 ce 04 2c 56 6a b2 c5 07 b1 38 db 85 3e 3d 69 59 66 09 96 54 6c c9 c4 a6 ea fd c7 77 c0 40 d7 0e af 46 f7 6d ad 39 79 e5 c5 36 0c 33 17 16 6a 1c 89 4c 94 a3 71 87 6a 94 df 76 28 fe 4e aa f2 cc b2 7d 5a aa e0 ad 7a d0 f9 d4 b6 ad 3b 54 09 87 46 d4 52 4d 38 40 7a 6d eb 3a b7 8f ab 78 c9\n\nk1 (DATA) 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\nk2 (AAD)  ff 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f\n\nAAD keystream\nc6 40 c1 71 1e 3e e9 04 ac 35 c5 7a b9 79 1c 8a 1c 40 86 03 a9 0b 77 a8 3b 54 f6 c8 44 cb 4b 06 d9 4e 7f c6 c8 00 e1 65 ac d6 61 47 e8 0e c4 5a 56 7f 6c e6 6d 05 ec 0c ae 67 9d ce eb 89 00 17\n\nciphertext\n39 40 c1 e9 2d a4 58 2f f6 f9 2a 77 6a eb 14 d0 14 d3 84 ee b3 0f 66 0d ac f7 0a 14 a2 3f d3 1e 91 21 27 01 33 4e 2c e1 ac f5 19 9d c8 4f 4d 61 dd be 65 71 bc a5 af 87 4b 4c 92 26 c2 6e 65 09 95 d1 57 64 4e 18 48 b9 6e d6 c2 10 2d 54 89 a0 50 e7 1d 29 a5 a6 6e ce 11 de 5f b5 c9 55 8d 54 da 28 fe 45 b0 bc 4d b4 e5 b8 80 30 bf c4 a3 52 b4 b7 06 8e cc f6 56 ba e7 ad 6a 35 61 53 15 fc 7c 49 d4 20 03 88 d5 ec a6 7c 2e 82 2e 06 93 36 c6 9b 40 db 67 e0 f3 c8 12 09 c5 0f 32 16 a4 b8 9f b3 ae 1b 98 4b 78 51 a2 ec 6f 68 ab 12 b1 01 ab 12 0e 1e a7 31 3b b9 3b 5a 0f 71 18 5c 7f ea 01 7d db 92 76 98 61 c2 9d ba 4f bc 43 22 80 d5 df f2 1b 36 d1 c4 c7 90 12 8b 22 69 99 50 bb 18 bf 74 c4 48 cd fe 54 7d 8e d4 f6 57 d8 00 5f dc 0c d7 a0 50 c2 d4 60 50 a4 4c 43 76 35 58 58\n\nMAC\n98 1f be 8b 18 42 88 27 6e 7a 93 ea bc 89 9c 4a\n</pre>\n\n\n=== v2 Messages Structure ===\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 3 || length & flag || 23 + 1 bits || Encrypted length of ciphertext payload (not counting the MAC tag) in number of bytes (only 2^23 is usable, most significant bit is the rekey-flag)\n|-\n| 1-13 || encrypted command || variable || ASCII command (or one byte short command ID)\n|-\n| ? || encrypted payload || ? || The actual data\n|-\n| 16 || MAC tag || ? || 128bit MAC-tag\n|}\n\nEncrypted messages do not have the 4byte network magic.\n\nThe maximum message size is 2^23 (8\u2019388\u2019608) bytes. Future communication MAY\nexceed this limit and thus MUST be split into different messages.\n\nDecrypting and processing the message before the authentication succeeds (MAC\nverified) MUST not be done.\n\nThe 4byte sha256 checksum is no longer required because the AEAD (MAC).\n\nBoth peers MUST keep track of the message sequence number (uint32) of sent and\nreceived messages for building a 64-bit symmetric cipher IV.\n\nThe command field MUST start with a byte that defines the length of the ASCII\ncommand string up to 12 chars (1 to 12) or a short command ID (see below).\n\n==== Short Command ID ====\n\nTo save valuable bandwidth, the v2 message format supports message command\nshort IDs for message types with high frequency. The ID/string mapping is a\npeer to peer arrangement and MAY be negotiated between the initiating and\nresponding peer. A peer conforming to this proposal MUST support short IDs\nbased on the table below and SHOULD use short command IDs for outgoing messages.\n\n{|class=\"wikitable\"\n! Number !! Command\n|-\n| 13 || INV\n|-\n| 14 || HEADERS\n|-\n| 15 || PING\n|-\n| 16 || PONG\n|-\n|}\n\n==== Length comparisons between v1 and v2 messages ====\n\n<pre>\nv1 in: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+36(Payload) == 60\nv2 inv: 3(MessageSize&Flag)+1(Command)+36(Payload)+16(MAC) == 56\n(93.33%)\n</pre>\n\n<pre>\nv1 ping: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+8(Payload) == 32\nv2 pong: 3(MessageSize&Flag)+1(Command)+8(Payload)+16(MAC) == 28\n(87.5%)\n</pre>\n\n<pre>\nv1 block: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+1\u2019048\u2019576(Payload) = 1\u2019048\u2019600\nv2 block: 3(MessageSize&Flag)+6(CommandStr)+8(Payload)+16(MAC) == 28 = 1\u2019048\u2019601\n(100.000095%)\n</pre>\n\n=== Re-Keying ===\n\nRe-keying can be signaled by setting the most significant bit in the length\nfield before encryption. A peer signaling a rekey MUST use the next key for\nencryption messages AFTER the message where the signaling has been done.\n\nA peer identifying a rekey by checking the most significant bit in the envelope\nlength must use the next key for decrypt messages AFTER the message where the\nsignaling has been detected.\n\nThe next symmetric cipher key MUST be calculated by <code>SHA256(SHA256(session\nID || old_symmetric_cipher_key))</code> and the packet sequence number of the\naccording encryption direction must be set to 0.\n\nRe-Keying interval is a peer policy with a minimum timespan of 10 seconds.\n\nThe Re-Keying must be done after every 1GB of data sent (recommended by RFC4253\nSSH Transport) or if the last rekey was more than an hour ago.\n\nPeers calculate the counterparty limits and MUST disconnect immediately if a\nviolation of the limits has been detected.\n\n\n=== Risks ===\n\nThe encryption does not include an authentication scheme. This BIP does not\ncover a proposal to avoid MITM attacks during the encryption initialization.\nHowever, peers MUST show the session-id to the user on request which allows to\nidentify a MITM by a manual verification on a secure channel.\n\nOptional authentication schemes may be covered by other proposals <ref\nname=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki\nBIP150]</ref>.\n\nAn attacker could delay or halt v2 protocol enforcement by providing a\nreasonable amount of peers not supporting the v2 protocol.\n\n== Compatibility ==\n\nThis proposal is backward compatible (as long as not enforced). Non-supporting\npeers can still use unencrypted communications.\n\n== Reference implementation ==\n* Complete Bitcoin Core implementation: https://github.com/bitcoin/bitcoin/pull/14032\n* Reference implementation of the AEAD in C: https://github.com/jonasschnelli/chacha20poly1305\n\n== References ==\n\n<references/>\n\n== Acknowledgements ==\n* Pieter Wuille and Gregory Maxwell for most of the ideas in this BIP.\n* Tim Ruffing for the review and the hint for the enhancement of the symmetric\nkey derivation\n\n\n== Copyright ==\nThis work is placed in the public domain.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/307267fd/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190322/307267fd/attachment-0001.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-03-24T13:29:10",
                "message_text_only": "On Fri, Mar 22, 2019 at 10:04:46PM +0100, Jonas Schnelli via bitcoin-dev wrote:\n> === v2 Messages Structure ===\n> \n> {|class=\"wikitable\"\n> ! Field Size !! Description !! Data type !! Comments\n> [...]\n> | 1-13 || encrypted command || variable || ASCII command (or one byte short command ID)\n> [...] \n> The command field MUST start with a byte that defines the length of the ASCII\n> command string up to 12 chars (1 to 12) or a short command ID (see below).\n> [...] \n> ==== Short Command ID ====\n> \n> To save valuable bandwidth, the v2 message format supports message command\n> short IDs for message types with high frequency. The ID/string mapping is a\n> peer to peer arrangement and MAY be negotiated between the initiating and\n> responding peer. \n\nWhy is this optional and only specified here for some message types\nrather than being required by v2 and specified for all message types?\nThere's only 26 different types at present[1], so it seems better to\nsimply make this a one-byte fixed-length field than it is to deal with\nvariable size, mapping negotiation, per-peer mapping in general, and\n(once the network is fully v2) the dual-logic of being able to process\nmessages either from a short ID or a full command name.\n\nThanks,\n\n-Dave\n\n[1] src/protocol.cpp:\n\nconst static std::string allNetMessageTypes[] = {\n    NetMsgType::VERSION,\n    NetMsgType::VERACK,\n    NetMsgType::ADDR,\n    NetMsgType::INV,\n    NetMsgType::GETDATA,\n    NetMsgType::MERKLEBLOCK,\n    NetMsgType::GETBLOCKS,\n    NetMsgType::GETHEADERS,\n    NetMsgType::TX,\n    NetMsgType::HEADERS,\n    NetMsgType::BLOCK,\n    NetMsgType::GETADDR,\n    NetMsgType::MEMPOOL,\n    NetMsgType::PING,\n    NetMsgType::PONG,\n    NetMsgType::NOTFOUND,\n    NetMsgType::FILTERLOAD,\n    NetMsgType::FILTERADD,\n    NetMsgType::FILTERCLEAR,\n    NetMsgType::REJECT,\n    NetMsgType::SENDHEADERS,\n    NetMsgType::FEEFILTER,\n    NetMsgType::SENDCMPCT,\n    NetMsgType::CMPCTBLOCK,\n    NetMsgType::GETBLOCKTXN,\n    NetMsgType::BLOCKTXN,\n};\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190324/84a5b971/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2019-03-24T15:38:56",
                "message_text_only": "On Sun, Mar 24, 2019 at 09:29:10AM -0400, David A. Harding via bitcoin-dev wrote:\n> Why is this optional and only specified here for some message types\n> rather than being required by v2 and specified for all message types?\n\nGregory Maxwell discussed this with me on IRC[1].  My summary of our\nconversation:\n\nAlthough the BIP can easily allocate short-ids to all existing messages,\nanyone who wants to add an additional protocol message later will need\nto coordinate their number allocation with all other developers working\non protocol extensions.  This includes experimental and private\nextensions.  At best this would be annoying, and at worst it'd be\nanother set of bikeshed problems we'd waste time arguing about.\n\nAllowing nodes to continue using arbitrary command names eliminates this\ncoordination problem.   Yet we can also gain the advantage of saving\nbandwidth by allowing mapping (with optional negotiation) of short-ids.\n\nNow that I understand the motivation, this part of the proposal makes\nsense to me.\n\n-Dave\n\n[1] http://www.erisian.com.au/bitcoin-core-dev/log-2019-03-24.html#l-159\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190324/2895a469/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2019-03-24T19:35:45",
                "message_text_only": "Hi Dave\n\nThanks for the review...\n\n>> ==== Short Command ID ====\n>> \n>> To save valuable bandwidth, the v2 message format supports message command\n>> short IDs for message types with high frequency. The ID/string mapping is a\n>> peer to peer arrangement and MAY be negotiated between the initiating and\n>> responding peer.\n> \n> Why is this optional and only specified here for some message types\n> rather than being required by v2 and specified for all message types?\n> There's only 26 different types at present[1], so it seems better to\n> simply make this a one-byte fixed-length field than it is to deal with\n> variable size, mapping negotiation, per-peer mapping in general, and\n> (once the network is fully v2) the dual-logic of being able to process\n> messages either from a short ID or a full command name.\n\nOne thing I was trying to avoid is some sort of central planing.\n\nStrings as message command identifier do usually bring some sort of collision resistance when competitive implementations work on different features.\nAn example are the service bits where we AFAIK had an (almost) collision.\nThis is the main reason why I think we should avoid setting the short IDs mandatory (naturally by not giving all commands a short ID).\n\nShort IDs do probably make most sense for messages with high frequency.\nBy only giving frequent messages a short ID, we may avoid ID collisions in future.\n\nShort IDs can be altered with the message protocol version (not the transport protocol, the message protocol like 70015, etc.) and new/different negation should be straight forward.\n\nI just ran some random stats (non representative) and inv makes about 66% of all messages (pruned peer, not helping IBDing others) followed by tx and getdata.\nThose three probably deserve a short ID.\n\nI have no big objection against adding short IDs for other commands as long as we don\u2019t make short IDs mandatory.\nThough, there are little benefits for commands like VERSION, FILTERxx, SENDHEADERS, etc.,... and, we only(?!) have 244 short IDs.\n\n/jonas\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190324/aef341d7/attachment.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-03-25T06:32:58",
                "message_text_only": "On 03/22/2019 02:04 PM, Jonas Schnelli via bitcoin-dev wrote:\n> Proposal:\n> \n> <pre>\n> \u00a0 BIP: ???\n> \u00a0 Layer: Peer Services\n> \u00a0 Title: Version 2 Peer-to-Peer Message Transport Protocol\n> \u00a0 Author: Jonas Schnelli <dev at jonasschnelli.ch>\n> \u00a0 Status: Draft\n> \u00a0 Type: Standards Track\n> \u00a0 Created: 2019-03-08\n> \u00a0 License: PD\n> </pre>\n> \n> == Abstract ==\n> \n> This BIP describes a new Bitcoin peer to peer transport protocol with\u00a0\n> opportunistic encryption.\n> \n> == Motivation ==\n> \n> The current peer-to-peer protocol is partially inefficient and in plaintext.\n> \n> With the current unencrypted message transport, BGP hijack,\n> block delay attacks\u00a0\n> and message tempering are inexpensive and can be executed in a covert way\u00a0\n> (undetectable MITM)<ref>[https://btc-hijack.ethz.ch/files/btc_hijack.pdf\u00a0\n> Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A.\u00a0\n> Zohar, L.Vanbever]</ref>.\n\nThis proposal does not provide mitigation for BGP hijacking, message\ntampering or delaying, between anonymous peers.\n\n\n> Adding opportunistic encryption introduces a high risk for attackers of\n> being detected. Peer operators can compare encryption session IDs\n\n\nThis is only possible if the peers have access to a secure/trusted side\nchannel between them. In other words, this does not benefit anonymous\npeers. It also seems like quite a stretch to consider it creating \"high\nrisk\" for the attacker, since the chances of any given pair of peers\nactually comparing session IDs over a secure channel seems extremely remote.\n\n\n> or use other form of authentication schemes <ref\u00a0\n> name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki\u00a0\n> BIP150]</ref> to identify an attack.\n\n\nAuthentication helps mitigate attacks by requiring the identity of the\npeer (based only on the presumption that a trusted peer wouldn't\nattack). This provides no benefit to anonymous peers.\n\nData communicated between peers is entirely public. Unlike other systems\nthat maintain data integrity through encryption, Bitcoin relies on\nvalidation. Encrypting public data between anonymous peers is pointless,\nand thus counterproductive from an engineering and software security\nstandpoint.\n\nMore importantly Bitcoin system security *requires* widespread anonymous\nparticipation. It's generally not a good idea to implement features that\nbackfire if they actually get widespread use. While we cannot prevent\npeople from using VPNs, incorporating them into the protocol is\ncounterproductive from a system security standpoint.\n\n\n> Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256\u00a0\n> checksum truncated to 4 bytes. Roughly the same amount of computation power\u00a0\n> would be required for encrypting and authenticating a peer-to-peer\n> message with ChaCha20 & Poly1305.\n\n\nThe proposal overlooks the simple alternatives of (1) not validating the\nchecksum, which is never necessary, and (2) proposing a protocol change\nto drop the checksum altogether. The former requires no protocol change\nand the latter can allow the checksum to be dropped in all messages\nexcept \"version\" given a simple protocol version number increment (i.e.\nno need to consume a service bit), saving not only the CPU resource but\nalso network bandwidth.\n\n\n> Additionally, this BIP describes a way how data manipulation (blocking or\u00a0\n> tempering commands by an intercepting TCP/IP node) would be identifiable\n> by the communicating peers.\n\n\nThe only such method described is manual comparison of session ID's\nbetween trusted parties over a secure side channel.\n\n\n> Encrypting traffic between peers is already possible with VPN, tor,\n> stunnel,\u00a0\n> curveCP or any other encryption mechanism on a deeper OSI level,\n> however, most\u00a0\n> of those solutions require significant knowhow in how to setup such a\n> secure\u00a0\n> channel and are therefore not widely deployed.\n\n\nYet this is exactly what a secure side channel is. Furthermore, being\nmanual, not only would it also suffer from not being widely deployed,\nbut also widely ignored.\n\n\n> == Specification ==\n> \n> <blockquote>\n> The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n> \"SHOULD\",\n> \"SHOULD NOT\", \"RECOMMENDED\", \u00a0\"MAY\", and \"OPTIONAL\" in this document are\n> to be\n> interpreted as described in RFC\n> 2119<ref>[https://tools.ietf.org/html/rfc2119\u00a0\n> RFC 2119]</ref>.\n> </blockquote>\n> \n> A peer that supports the message transport protocol as defined in this\n> proposal\u00a0\n> MUST accept encryption requests from all peers.\n> \n> Both communication direction share the same shared-secret but have\n> different\u00a0\n> symmetric cipher keys.\n> \n> The encryption handshake MUST happen before sending any other messages\n> to the\u00a0\n> responding peer.\n> \n> If the responding peer closes the connection after sending the handshake\u00a0\n> request, the initiating peer MAY try to connect again with the v1\n> peer-to-peer\u00a0\n> transport protocol. Such reconnects allow an attacker to \"downgrade\" the\u00a0\n> encryption to plaintext communication and thus, accepting v1 connections\n> MUST\u00a0\n> not be done when the Bitcoin peer-to-peer network uses almost only v2\u00a0\n> communication.\n> \n> \n> === NODE_P2P_V2 ===\n> \n> Peers supporting the transport protocol after this proposal MUST signal\u00a0\n> <code>NODE_P2P_V2</code>\n> <pre>\n> NODE_P2P_V2 = (1 << 11)\n> </pre>\n> \n> A peer usually learns an address along with the expected service flags\n> which\u00a0\n> MAY be used to filter possible outbound peers.\n> \n> A peer signaling <code>NODE_P2P_V2</code> MUST accept encrypted\n> communication\u00a0\n> specified in this proposal.\n> \n> Peers MAY only make outbound connections to peers supporting\u00a0\n> <code>NODE_P2P_V2</code>.\n> \n> === Handshake ===\n...\n> ==== Short Command ID ====\n\n\nThe shortening of message identifiers hardly seems worth the effort.\nDropping the checksum seems a much easier way to save more on the wire\n(and in the CPU).\n\n\n> === Risks ===\n> \n> The encryption does not include an authentication scheme.\n\n> This BIP does not \n> cover a proposal to avoid MITM attacks during the encryption\n> initialization.\n\n\nThen to be clear it cannot prevent MITM attacks. The only actual\nmitigation requires manual comparison of session IDs after each\nconnection (and reconnection).\n\n\n> However, peers MUST show the session-id to the user on request which\n> allows to identify a MITM by a manual verification on a secure channel.\n\n\nThis scenario presumes that the two peers are operated by individuals\nwho know and trust each other and have the ability to communicate over a\nsecure side channel, and will each extract the session ID from their\nrespective peers and use the side channel to compare them.\n\nNot only does this not support anonymous peering, it's not clear what\nprocess would exist to make this actually useful in practice.\n\n\n> Optional authentication schemes may be covered by other proposals <ref\u00a0\n> name=\"bip150\">[https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki\u00a0\n> BIP150]</ref>.\n> \n> An attacker could delay or halt v2 protocol enforcement by providing a\u00a0\n> reasonable amount of peers not supporting the v2 protocol.\n> \n> == Compatibility ==\n> \n> This proposal is backward compatible (as long as not enforced).\n\n\nKudos for making this second attempt backward compatible.\n\n\n> Non-supporting\u00a0\n> peers can still use unencrypted communications.\n> \n> == Reference implementation ==\n> * Complete Bitcoin Core implementation:\n> https://github.com/bitcoin/bitcoin/pull/14032\n> * Reference implementation of the AEAD in C:\n> https://github.com/jonasschnelli/chacha20poly1305\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190324/87025ec1/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "New BIP - v2 peer-to-peer message transport protocol (former BIP151)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "David A. Harding",
                "Jonas Schnelli"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 38895
        }
    }
]