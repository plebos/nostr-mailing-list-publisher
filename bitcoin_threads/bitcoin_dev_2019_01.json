[
    {
        "title": "[bitcoin-dev] BIP39 seeds",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2019-01-01T19:44:57",
                "message_text_only": "You are simplifying too much what I am suggesting\n\nWhat I am suggesting is: set a derivation method for BIP39 like for \nBIP32 (having the seed for BIP32 and not the derivation path is just \nlike having nothing) and use this derivation method from a \"book\" (a \n\"book\" being a book, a document, a link, an image, whatever your secret \ncan be), based on the fact that you will easily find from this \nderivation method \"valid\" BIP39 seeds (even if BIP39 does not enforce \nanything regarding valid phrases, everything can be valid as you \nmention, and this does not help in fact)\n\nThe derivation method will just define the way you select the words in \nthe secret, and if everybody chooses the bible as the secret then this \nwill not change the fact that it will be impossible to find the real \nseed without knowing the derivation path\n\nThen you don't need to write the seed, you can easily plausible deny it, \nyou can easily pass it to the family (using a passphrase does not say to \nthem where they are supposed to use it)\n\n\"people lost\"--> people think that there is some magic with BIP39 that \nwill save them whatever they do (ie they don't even care of managing \ncorrectly the many easy to generate BIP39 seeds they are using) where \nthey will always recover their seed and keys from BIP39/44/49, of course \nthis does not work at all\n\n\nLe 31/12/2018 \u00e0 17:52, Alan Evans a \u00e9crit :\n> > Using some algorithm to take some input and generate a bip39 phrase \n> that you can use with any bip39 wallet sounds perfectly reasonable.\n>\n> I think any method that doesn't use real entropy, but some fake source \n> of randomness, such as a book is asking to be hacked and so is not a \n> reasonable idea.\n>\n> If an algorithm for book text to BIP39 sentence ever became well used, \n> common books will be systematically searched for accounts. People will \n> also choose their favourite passages, so I would expect to see collisions.\n>\n> You should also note that BIP39 does not need input that is from the \n> word list. You can use _any text as its input_, the word list and \n> checksum check is just recommended to be a warning, but again, text \n> chosen from public sources or common phrases is a bad idea for many \n> reasons.\n>\n> From BIP0039:\n> /> The conversion of the mnemonic sentence to a binary seed is \n> completely independent from generating the sentence. This results in \n> rather simple code; *there are no constraints on sentence structure* \n> and clients are free to implement their own wordlists or even whole \n> sentence generators, allowing for flexibility in wordlists for typo \n> detection or other purposes./\n> /> Although using a mnemonic not generated by the algorithm described \n> in \"Generating the mnemonic\" section is possible, this is not advised \n> and software must compute a checksum for the mnemonic sentence using a \n> wordlist and issue a warning if it is invalid./\n>\n> What you could do is use a regular true random BIP39 sentence in \n> conjunction with a phrase from a book as the \"passphrase\" giving you \n> that plausible deniability, right up to the point you put that in your \n> will or tell someone, i.e. for the \"what if something happens to me\" \n> case. Though I still think redirecting people to a book phase is risky \n> for this, e.g. books have editions, there may be a change in the key \n> place.\n>\n> From BIP0039:/\n> /\n> /> The described method also provides plausible deniability, because \n> every passphrase generates a valid seed (and thus a deterministic \n> wallet) but only the correct one will make the desired wallet available./\n>\n> Alan\n>\n> P.S. \"I have seen many people completely lost with their wallets \n> because of [BIP39]\": I would say \"despite\" not \"because\". These people \n> would have lost/miss recorded a BIP32 hex seed as well.\n>\n>\n> On Thu, 27 Dec 2018 at 11:02, Aymeric Vitte via bitcoin-dev \n> <bitcoin-dev at lists.linuxfoundation.org \n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>\n>     Le 26/12/2018 \u00e0 19:54, James MacWhyte a \u00e9crit :\n>>\n>>     On Wed, Dec 26, 2018 at 11:33 AM Aymeric Vitte\n>>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:\n>>\n>>         so, even with a tool like yours, they can be misleaded, for\n>>         example trying a few words to replace the missing/incorrect\n>>         one, get a valid seed and stay stuck with it forever trying\n>>         to play with BIP44/49 to find their keys\n>>\n>>\n>>     Just a small detail, but my tool actually looks up all the\n>>     possible combinations and then finds which one has been used\n>>     before by looking for past transactions on the blockchain.\n>>     Therefore, it won't tell you your phrase is correct unless it is\n>>     a phrase that has actually been used before (preventing what you\n>>     described).\n>\n>     I saw that your tool was querying blockchain.info\n>     <http://blockchain.info>, but it cannot guess what derivation path\n>     was used and if it is a standard one what addresses were used, and\n>     even if successful it works only for bitcoin (so maybe it should\n>     just output the ~1500 possible phrases and/or xprv, and be\n>     completely offline, this is still doable for people)\n>\n>>\n>>     Using some algorithm to take some input and generate a bip39\n>>     phrase that you can use with any bip39 wallet sounds perfectly\n>>     reasonable.\n>\n>     I forgot to mention that this can help also solving the \"what if\n>     something happens to me\" case giving to the family the seed and\n>     the parameter(s) for the derivation path, or an easy way to find\n>     it (better than something like: remind this passphrase, take the\n>     sha256 of it, then use some other stuff to find the encryption\n>     algo, take n bytes of the hash, use it to decode my wallet or my\n>     seed... and then everybody looking at you like crazy)\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190101/916f37ee/attachment-0001.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2019-01-02T18:06:08",
                "message_text_only": "On Wed, Jan 2, 2019 at 3:40 AM Alan Evans via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> I think any method that doesn't use real entropy, but some fake source of\n> randomness, such as a book is asking to be hacked and so is not a\n> reasonable idea.\n>\n> If an algorithm for book text to BIP39 sentence ever became well used,\n> common books will be systematically searched for accounts. People will also\n> choose their favourite passages, so I would expect to see collisions.\n>\n>\nI tend to have this conversation a lot ;) I'm not sure what Aymeric has in\nmind, but my suggestions are for use by the small few who properly\nunderstand how these things work. I am not suggesting blockchain.info\nrequire every user to choose a book passage to use as their backup phrase!\n\nThere are so many small things that could be done to make a text input\nunique. Choose the X number of words from the start of the Nth sentence.\nReplace all punctuation with exclamation points. Combine two sentences from\ndifferent pages. It would be nigh impossible to brute force any of these,\nand would require hints/instructions from the owner to recover.\n\nBut I admit if this is not intended for standardization, discussing it on\nthis mailing list is probably unwarranted.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190102/c926eff7/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-01-04T00:02:35",
                "message_text_only": "What I have in mind is in my latest reply (difficult to have some kind\nof fluent discussions on this list given the moderation and delayed posts)\n\nI would just add that the derivation method (indeed something like what\nyou are sketching below) should estimate that there is enough entropy\nfrom the secret, if not just throw\n\nLe 02/01/2019 \u00e0 19:06, James MacWhyte via bitcoin-dev a \u00e9crit\u00a0:\n> On Wed, Jan 2, 2019 at 3:40 AM Alan Evans via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>\n>     I think any method that doesn't use real entropy, but some fake\n>     source of randomness, such as a book is asking to be hacked and so\n>     is not a reasonable idea.\n>\n>     If an algorithm for book text to BIP39 sentence\u00a0ever became well\n>     used, common books will be systematically searched for accounts.\n>     People will also choose their favourite passages, so I would\n>     expect to see collisions.\n>\n>\n> I tend to have this conversation a lot ;) I'm not sure what Aymeric\n> has in mind, but my suggestions are for use by the small few who\n> properly understand how these things work. I am not suggesting\n> blockchain.info <http://blockchain.info> require every user to choose\n> a book passage to use as their backup phrase!\n>\n> There are so many small things that could be done to make a text input\n> unique. Choose the X number of words from the start of the Nth\n> sentence. Replace all punctuation with exclamation points. Combine two\n> sentences from different pages. It would be nigh impossible to brute\n> force any of these, and would require hints/instructions from the\n> owner to recover.\n>\n> But I admit if this is not intended for standardization, discussing it\n> on this mailing list is probably unwarranted.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190104/d8b994a9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP39 seeds",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "James MacWhyte",
                "Aymeric Vitte"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10550
        }
    },
    {
        "title": "[bitcoin-dev] Create a BIP to implement Confidential Transactions in Bitcoin Core",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-02T13:39:57",
                "message_text_only": "Good morning SomberNight,\n\n> \"Bulletproofs ... are computationally binding. An adversary that could\n> break the discrete logarithm assumption could generate acceptable range\n> proofs for a value outside the correct range. ... An adversary that can\n> break the binding property of the commitment scheme or the soundness of\n> the proof system can generate coins out of thin air and thus create\n> uncontrolled but undetectable inflation rendering the currency useless\"\n>\n> I don't have the domain knowledge to debate whether quantum computers will\n> ever exist but AFAICT their emergence would easily kill a currency that\n> uses these kind of range proofs for confidential transactions.\n\nThis can be mitigated by splitting the blockchain into a public part and a confidential-transactions part (i.e. extension block).\nThis may be necessary for softforking of CT onto the blockchain anyway; existing pre-CT coins remain in the public part.\n\nWhen moving from public to CT, you send to some special \"lockbox address\" on the public part, then they will now be put in a coinbase-like transaction on the CT part.\nYou then do some mixing and splitting in the CT part to obscure which of your UTXOs have what value.\nThen to move from CT to public, you can claim any of the lockboxes on the public part, by revealing the values of your CT UTXOs (and destroying them) and showing that they are equal or less than the lockboxes you are claiming on the public part, and putting back any remainder between the lockboxes total and your own CT UTXOs into another lockbox UTXO.\n\nThis is essentially the same concept as sidechains, but with the \"side\" chain here being part of the consensus, and thus an extension block instead of a true sidechain.\n\nIn this way, the amount of total money in the CT part is the sum of all the lockboxes.\nIn case of a cryptographic break in the CT rangeproof protocol, then the first owner of a quantum computer can claim all the lockboxes, but at least the damage is bounded to only those UTXOs in the CT part.\nUTXOs in the public part retain their money.\nIn addition, since creation of new coins remains in the public part, coin supply is protected, which I believe is the most important property.\n\nThe weakness in this scheme is that there is incentive not to put your money for long in the CT part.\n\nNote that CT only hides transaction values.\nStructure of transactions from payers to payees remains visible onchain.\nI would suggest rather to use MimbleWimble, since at least under MimbleWimble transaction structure will need to be stored by the monitors of the blockchain rather than by the blockchain itself, which would help reduce their ability to see into historical data (they would only be able to see data they recorded themselves, and MimbleWimble allows third-party trustless CoinJoin so they might not even record accurate transaction structure).\nDrawback is lack of SCRIPT, but Scriptless Script should be sufficient for e.g. LN.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Create a BIP to implement Confidential Transactions in Bitcoin Core",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2977
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2019-01-07T15:18:52",
                "message_text_only": "Sorry for the late reply.\n\nHmm, I included the old RBF-pinning proposal as a comparison. \nPersonally, I find it both less clean and less convincingly secure.\n\nUltimately, defining a \"near the top of the mempool\" criteria is fraught \nwith issues. While it's probably OK for the original problem (large \nbatched transactions where you don't want a single counterparty to \nprevent confirmation), lightning's requirements are very different. \nInstead is wanting a high probability that the transaction in question \nconfirms \"soon\", we need certainty that it will confirm by some deadline.\n\nThus, even if you imagine a steady-state mempool growth, unless the \n\"near the top of the mempool\" criteria is \"near the top of the next \nblock\" (which is obviously *not* incentive-compatible), its easy to see \nhow the package would fail to confirm within a handful of blocks given \nblock time variance. Giving up the ability to RBF/CPFP more than once in \ncase the fee moves away from us seems to be a rather significant \nrestriction.\n\nTHe original proposal is somewhat of a hack, but its a hack on the \nboundary condition where packages meet our local anti-DoS rules in \nviolation of the \"incentive compatible\" goal anyway (essentially, though \nminers also care about anti-DoS). This proposal is very different and, \nsimilar to how it doesn't work if blocks randomly come in a bit slow for \nan hour or two, isn't incentive compatible if blocks come in a bit fast \nfor an hour or two, as all of a sudden that \"near the top of the \nmempool\" criteria makes no sense and you should have accepted the new \ntransaction(s).\n\nAs for package relay, indeed, we can probably do soemthing simpler for \nthis specific case, but itdepends on what the scope of that design is. \nSuhas opened an issue to try to scope it out a bit more at \nhttps://github.com/bitcoin/bitcoin/issues/14895\n\nMatt\n\n> On Dec 3, 2018, at 22:33, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>> As an alternative proposal, at various points there have been \n>> discussions around solving the \"RBF-pinning\" problem by allowing \n>> transactors to mark their transactions as \"likely-to-be-RBF'ed\", which \n>> could enable a relay policy where children of such transactions would be \n>> rejected unless the resulting package would be \"near the top of the \n>> mempool\". This would theoretically imply such attacks are not possible \n>> to pull off consistently, as any \"transaction-delaying\" channel \n>> participant will have to place the package containing A at an effective \n>> feerate which makes confirmation to occur soon with some likelihood. It \n>> is, however, possible to pull off this attack with low probability in \n>> case of feerate spikes right after broadcast.\n> \n> I like this idea.\n> \n> Firstly, it's incentive-compatible[1]: assuming blocks are full, miners\n> should always take a higher feerate tx if that tx would be in the\n> current block and the replaced txs would not.[2]\n> \n> Secondly, it reduces the problem that the current lightning proposal\n> adds to the UTXO set with two anyone-can-spend txs for 1000 satoshis,\n> which might be too small to cleanup later.  This rule would allow a\n> simple single P2WSH(OP_TRUE) output, or, with IsStandard changed,\n> a literal OP_TRUE.\n> \n>> Note that this clearly relies on some form of package relay, which comes \n>> with its own challenges, but I'll start a separate thread on that.\n> \n> Could be done client-side, right?  Do a quick check if this is above 250\n> satoshi per kweight but below minrelayfee, put it in a side-cache with a\n> 60 second timeout sweep.  If something comes in which depends on it\n> which is above minrelayfee, then process them as a pair[3].\n> \n> Cheers,\n> Rusty.\n> [1] Miners have generally been happy with Defaults Which Are Good For The\n>    Network, but I feel a long term development aim should to be reduce\n>    such cases to smaller and smaller corners.\n> [2] The actual condition is subtler, but this is a clear subset AFAICT.\n> [3] For Lightning, we don't care about child-pays-for-grandparent etc."
            },
            {
                "author": "Rusty Russell",
                "date": "2019-01-08T05:50:20",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> Ultimately, defining a \"near the top of the mempool\" criteria is fraught \n> with issues. While it's probably OK for the original problem (large \n> batched transactions where you don't want a single counterparty to \n> prevent confirmation), lightning's requirements are very different. \n> Instead is wanting a high probability that the transaction in question \n> confirms \"soon\", we need certainty that it will confirm by some deadline.\n\nI don't think it's different, in practice.\n\n> Thus, even if you imagine a steady-state mempool growth, unless the \n> \"near the top of the mempool\" criteria is \"near the top of the next \n> block\" (which is obviously *not* incentive-compatible)\n\nI was defining \"top of mempool\" as \"in the first 4 MSipa\", ie. next\nblock, and assumed you'd only allow RBF if the old package wasn't in the\ntop and the replacement would be.  That seems incentive compatible; more\nthan the current scheme?\n\nThe attack against this is to make a 100k package which would just get\ninto this \"top\", then push it out with a separate tx at slightly higher\nfee, then repeat.  Of course, timing makes that hard to get right, and\nyou're paying real fees for it too.\n\nSure, an attacker can make you pay next-block high fees, but it's still\nbetter than our current \"*always* overpay and hope!\", and you can always\ndecide at the time based on whether the expiring HTLC(s) are worth it.\n\nBut I think whatever's simplest to implement should win, and I'm not in\na position to judge that accurately.\n\nThanks,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2019-01-08T14:46:45",
                "message_text_only": "I responded to a few things in-line before realizing I think we're out of sync on what this alternative proposal actually implies. In my understanding is it, it does *not* imply that you are guaranteed the ability to RBF as fees change. The previous problem is still there - your counterparty can announce a bogus package and leave you unable to add a new transaction to it, the difference being it may be significantly more expensive to do so. If it were the case the you could RBF after the fact, I would likely agree with you.\n\n> On Jan 8, 2019, at 00:50, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>> Ultimately, defining a \"near the top of the mempool\" criteria is fraught \n>> with issues. While it's probably OK for the original problem (large \n>> batched transactions where you don't want a single counterparty to \n>> prevent confirmation), lightning's requirements are very different. \n>> Instead is wanting a high probability that the transaction in question \n>> confirms \"soon\", we need certainty that it will confirm by some deadline.\n> \n> I don't think it's different, in practice.\n\nI strongly disagree. If you're someone sending a batched payment, 5% chance it takes 13 blocks is perfectly acceptable. If you're a lightning operator, that quickly turns into \"5% chance, or 35% chance if your counterparty is malicious and knows more about the market structure than you\". Eg in the past it's been the case that transaction volume would spike every day at the same time when Bitmex proceed a flood of withdrawals all at once in separate transactions. Worse, it's probably still the case that, in case is sudden market movement, transaction volume can spike while people arb exchanges and move coins into exchanges to sell.\n\n>> Thus, even if you imagine a steady-state mempool growth, unless the \n>> \"near the top of the mempool\" criteria is \"near the top of the next \n>> block\" (which is obviously *not* incentive-compatible)\n> \n> I was defining \"top of mempool\" as \"in the first 4 MSipa\", ie. next\n> block, and assumed you'd only allow RBF if the old package wasn't in the\n> top and the replacement would be.  That seems incentive compatible; more\n> than the current scheme?\n\nMy point was, because of block time variance, even that criteria doesn't hold up. If you assume a steady flow of new transactions and one or two blocks come in \"late\", suddenly \"top 4MWeight\" isn't likely to get confirmed until a few blocks come in \"early\". Given block variance within a 12 block window, this is a relatively likely scenario.\n\n> The attack against this is to make a 100k package which would just get\n> into this \"top\", then push it out with a separate tx at slightly higher\n> fee, then repeat.  Of course, timing makes that hard to get right, and\n> you're paying real fees for it too.\n> \n> Sure, an attacker can make you pay next-block high fees, but it's still\n> better than our current \"*always* overpay and hope!\", and you can always\n> decide at the time based on whether the expiring HTLC(s) are worth it.\n> \n> But I think whatever's simplest to implement should win, and I'm not in\n> a position to judge that accurately.\n> \n> Thanks,\n> Rusty."
            }
        ],
        "thread_summary": {
            "title": "CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8877
        }
    },
    {
        "title": "[bitcoin-dev] Proof-of-Stake Bitcoin Sidechains",
        "thread_messages": [
            {
                "author": "Matt Bell",
                "date": "2019-01-18T22:59:35",
                "message_text_only": "I have been working on a design for Bitcoin sidechains using the Tendermint\nBFT consensus protocol, which is commonly used to build proof-of-stake\nnetworks (Cosmos is the notable one).\n\nThe design ends up being very similar to Blockstream's Liquid sidechain,\nsince Tendermint consensus is not far off from Liquid's \"strong federation\"\nconsensus.\n\nAny feedback about improvements or critical flaws would be greatly\nappreciated. The design document is here:\nhttps://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo\nalso contains a simplified implementation of this sidechain design).\n\nThanks for your feedback,\nMatt Bell\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190118/f588117a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-19T01:42:47",
                "message_text_only": "Good morning Matt,\n\nIt seems to me much more interesting if the stakes used to weigh voting power are UTXOs on the Bitcoin blockchain.\nThis idea is what I call \"mainstake\"; rather than a blockchain having its own token that is self-attesting (which is insecure).\nIt seems to me, naively, that the same script you propose here can be used for mainstake.\n\nFor instance, the sidechain network might accept potential stakers on the mainchain, if the staker proves the existence of a mainchain transaction whose output is for example:\n\n<sidechain identifier> OP_DROP\n\"1 year\" OP_CHECKSEQUENCEVERIFY OP_DROP\n<pubkey> OP_CHECKSIG\n\nThe sidechain network could accept this and use the value of the output as the weight of the vote of that stake.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have been working on a design for Bitcoin sidechains using the Tendermint BFT consensus protocol, which is commonly used to build proof-of-stake networks (Cosmos is the notable one).\n>\n> The design ends up being very similar to Blockstream's Liquid sidechain, since Tendermint consensus is not far off from Liquid's \"strong federation\" consensus.\n>\n> Any feedback about improvements or critical flaws would be greatly appreciated. The design document is here: https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo also contains a simplified implementation of this sidechain design).\n>\n> Thanks for your feedback,\n> Matt Bell"
            },
            {
                "author": "Matt Bell",
                "date": "2019-01-19T05:35:43",
                "message_text_only": "Hi ZmnSCPxj,\n\nJust to clarify, my design does not specify the source of voting power, so\nit is agnostic to whatever system you want to derive stake or valdiator set\nmembership from.\n\nYour idea of timelocking Bitcoin is interesting, I am eager to find a\nsolution where holding Bitcoin is enough to get voting power. It's possible\nthere may be an issue with the fact that the Bitcoin is not slashable\n(although their voting power is), meaning a validator who double-signs\ncannot have their Bitcoin removed from them. However their UTXO can be\nblacklisted which does make their attack costly since they lose out on the\ntime-value of their stake.\n\nOur current thinking for the source of stake is to pay out stake to Bitcoin\nmerged-miners although I'll definitely do some more thinking about\ntimelocked Bitcoin as stake.\n\nOn Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:\n\n> Good morning Matt,\n>\n> It seems to me much more interesting if the stakes used to weigh voting\n> power are UTXOs on the Bitcoin blockchain.\n> This idea is what I call \"mainstake\"; rather than a blockchain having its\n> own token that is self-attesting (which is insecure).\n> It seems to me, naively, that the same script you propose here can be used\n> for mainstake.\n>\n> For instance, the sidechain network might accept potential stakers on the\n> mainchain, if the staker proves the existence of a mainchain transaction\n> whose output is for example:\n>\n> <sidechain identifier> OP_DROP\n> \"1 year\" OP_CHECKSEQUENCEVERIFY OP_DROP\n> <pubkey> OP_CHECKSIG\n>\n> The sidechain network could accept this and use the value of the output as\n> the weight of the vote of that stake.\n>\n> Regards,\n> ZmnSCPxj\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > I have been working on a design for Bitcoin sidechains using the\n> Tendermint BFT consensus protocol, which is commonly used to build\n> proof-of-stake networks (Cosmos is the notable one).\n> >\n> > The design ends up being very similar to Blockstream's Liquid sidechain,\n> since Tendermint consensus is not far off from Liquid's \"strong federation\"\n> consensus.\n> >\n> > Any feedback about improvements or critical flaws would be greatly\n> appreciated. The design document is here:\n> https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that\n> repo also contains a simplified implementation of this sidechain design).\n> >\n> > Thanks for your feedback,\n> > Matt Bell\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190118/de50b59d/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-20T02:06:08",
                "message_text_only": "Good Morning Matt,\n\nIt seems to me that double signing can be punished by requiring that R be a trivial function on the blockheight of the block being signed on the sidechain network. Then a validator who signs multiple versions of history at a particular blockheight reveals their privkey. Since the privkey also protects their Bitcoin stake UTXO, they risk loss of their Bitcoin stake. A similar idea is used by Discrete Log Contracts to ensure Oracles do not sign multiple values at a particular time.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, January 19, 2019 1:35 PM, Matt Bell <mappum at gmail.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Just to clarify, my design does not specify the source of voting power, so it is agnostic to whatever system you want to derive stake or valdiator set membership from.\n>\n> Your idea of timelocking Bitcoin is interesting, I am eager to find a solution where holding Bitcoin is enough to get voting power. It's possible there may be an issue with the fact that the Bitcoin is not slashable (although their voting power is), meaning a validator who double-signs cannot have their Bitcoin removed from them. However their UTXO can be blacklisted which does make their attack costly since they lose out on the time-value of their stake.\n>\n> Our current thinking for the source of stake is to pay out stake to Bitcoin merged-miners although\u00a0I'll definitely do some more thinking about timelocked Bitcoin as stake.\n>\n> On Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:\n>\n> > Good morning Matt,\n> >\n> > It seems to me much more interesting if the stakes used to weigh voting power are UTXOs on the Bitcoin blockchain.\n> > This idea is what I call \"mainstake\"; rather than a blockchain having its own token that is self-attesting (which is insecure).\n> > It seems to me, naively, that the same script you propose here can be used for mainstake.\n> >\n> > For instance, the sidechain network might accept potential stakers on the mainchain, if the staker proves the existence of a mainchain transaction whose output is for example:\n> >\n> > <sidechain identifier> OP_DROP\n> > \"1 year\" OP_CHECKSEQUENCEVERIFY OP_DROP\n> > <pubkey> OP_CHECKSIG\n> >\n> > The sidechain network could accept this and use the value of the output as the weight of the vote of that stake.\n> >\n> > Regards,\n> > ZmnSCPxj\n> >\n> > Sent with ProtonMail Secure Email.\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > I have been working on a design for Bitcoin sidechains using the Tendermint BFT consensus protocol, which is commonly used to build proof-of-stake networks (Cosmos is the notable one).\n> > >\n> > > The design ends up being very similar to Blockstream's Liquid sidechain, since Tendermint consensus is not far off from Liquid's \"strong federation\" consensus.\n> > >\n> > > Any feedback about improvements or critical flaws would be greatly appreciated. The design document is here: https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that repo also contains a simplified implementation of this sidechain design).\n> > >\n> > > Thanks for your feedback,\n> > > Matt Bell"
            },
            {
                "author": "Matt Bell",
                "date": "2019-01-21T18:47:13",
                "message_text_only": "ZmnSCPxj,\n\nI'm intrigued by this mechanism of using fixed R values to prevent multiple\nsignatures, but how do we derive the R values in a way where they are\nunique for each blockheight but still can be used to create signatures or\nverify?\n\nThanks,\nMatt\n\nOn Sat, Jan 19, 2019 at 6:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good Morning Matt,\n>\n> It seems to me that double signing can be punished by requiring that R be\n> a trivial function on the blockheight of the block being signed on the\n> sidechain network. Then a validator who signs multiple versions of history\n> at a particular blockheight reveals their privkey. Since the privkey also\n> protects their Bitcoin stake UTXO, they risk loss of their Bitcoin stake. A\n> similar idea is used by Discrete Log Contracts to ensure Oracles do not\n> sign multiple values at a particular time.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, January 19, 2019 1:35 PM, Matt Bell <mappum at gmail.com> wrote:\n>\n> > Hi ZmnSCPxj,\n> >\n> > Just to clarify, my design does not specify the source of voting power,\n> so it is agnostic to whatever system you want to derive stake or valdiator\n> set membership from.\n> >\n> > Your idea of timelocking Bitcoin is interesting, I am eager to find a\n> solution where holding Bitcoin is enough to get voting power. It's possible\n> there may be an issue with the fact that the Bitcoin is not slashable\n> (although their voting power is), meaning a validator who double-signs\n> cannot have their Bitcoin removed from them. However their UTXO can be\n> blacklisted which does make their attack costly since they lose out on the\n> time-value of their stake.\n> >\n> > Our current thinking for the source of stake is to pay out stake to\n> Bitcoin merged-miners although I'll definitely do some more thinking about\n> timelocked Bitcoin as stake.\n> >\n> > On Fri, Jan 18, 2019, 5:42 PM ZmnSCPxj <ZmnSCPxj at protonmail.com wrote:\n> >\n> > > Good morning Matt,\n> > >\n> > > It seems to me much more interesting if the stakes used to weigh\n> voting power are UTXOs on the Bitcoin blockchain.\n> > > This idea is what I call \"mainstake\"; rather than a blockchain having\n> its own token that is self-attesting (which is insecure).\n> > > It seems to me, naively, that the same script you propose here can be\n> used for mainstake.\n> > >\n> > > For instance, the sidechain network might accept potential stakers on\n> the mainchain, if the staker proves the existence of a mainchain\n> transaction whose output is for example:\n> > >\n> > > <sidechain identifier> OP_DROP\n> > > \"1 year\" OP_CHECKSEQUENCEVERIFY OP_DROP\n> > > <pubkey> OP_CHECKSIG\n> > >\n> > > The sidechain network could accept this and use the value of the\n> output as the weight of the vote of that stake.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > >\n> > > Sent with ProtonMail Secure Email.\n> > >\n> > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > On Saturday, January 19, 2019 6:59 AM, Matt Bell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > >\n> > > > I have been working on a design for Bitcoin sidechains using the\n> Tendermint BFT consensus protocol, which is commonly used to build\n> proof-of-stake networks (Cosmos is the notable one).\n> > > >\n> > > > The design ends up being very similar to Blockstream's Liquid\n> sidechain, since Tendermint consensus is not far off from Liquid's \"strong\n> federation\" consensus.\n> > > >\n> > > > Any feedback about improvements or critical flaws would be greatly\n> appreciated. The design document is here:\n> https://github.com/mappum/bitcoin-peg/blob/master/bitcoinPeg.md (that\n> repo also contains a simplified implementation of this sidechain design).\n> > > >\n> > > > Thanks for your feedback,\n> > > > Matt Bell\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190121/d7bc33e3/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-22T09:19:27",
                "message_text_only": "Good Morning Matt,\n\n> ### ZmnSCPxj,\n>\n> I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are\nunique for each blockheight but still can be used to create signatures or verify?\n\nOne possibility is to derive `R` using standard hierarchical derivation.\nThen require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).\nTo sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Satoshin",
                "date": "2019-01-22T14:58:25",
                "message_text_only": "This could could be a viable option. I think this is the right approach.\n\nAny downside to this and how much does this add to the blockweight if anything at all.\n\nAnonymouse\n\n> On Jan 22, 2019, at 4:19 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Good Morning Matt,\n> \n>> ### ZmnSCPxj,\n>> \n>> I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are\n> unique for each blockheight but still can be used to create signatures or verify?\n> \n> One possibility is to derive `R` using standard hierarchical derivation.\n> Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).\n> To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.\n> \n> \n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-01-22T20:03:06",
                "message_text_only": "How could you prove the private key is in the burning transaction?\n\nOn Tue, Jan 22, 2019 at 11:56 AM Satoshin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This could could be a viable option. I think this is the right approach.\n>\n> Any downside to this and how much does this add to the blockweight if\n> anything at all.\n>\n> Anonymouse\n>\n> > On Jan 22, 2019, at 4:19 AM, ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > Good Morning Matt,\n> >\n> >> ### ZmnSCPxj,\n> >>\n> >> I'm intrigued by this mechanism of using fixed R values to prevent\n> multiple signatures, but how do we derive the R values in a way where they\n> are\n> > unique for each blockheight but still can be used to create signatures\n> or verify?\n> >\n> > One possibility is to derive `R` using standard hierarchical derivation.\n> > Then require that the staking pubkey be revealed to the sidechain\n> network as actually being `staking_pubkey = P + hash(P || parent_R) * G`\n> (possibly with some trivial protection against Taproot).\n> > To sign for a blockheight `h`, you must use your public key `P` and the\n> specific `R` we get from hierarchical derivation from `parent_R` and the\n> blockheight as index.\n> >\n> >\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190122/46b08c8b/attachment-0001.html>"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-01-22T16:33:23",
                "message_text_only": "Wouldn\u2019t a revealed private key for time locked funds create a race to\nspend? I imagine miners who are paying attention would have the advantage\nbut it would still just be a race.\n\nWould be nice to have the funds destroyed or sent somewhere specific. Like\nif somehow the revealed key was actually itself a presigned transaction. Or\nperhaps a 32 byte piece of a tx needed to complete it.\n\nOn Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good Morning Matt,\n>\n> > ### ZmnSCPxj,\n> >\n> > I'm intrigued by this mechanism of using fixed R values to prevent\n> multiple signatures, but how do we derive the R values in a way where they\n> are\n> unique for each blockheight but still can be used to create signatures or\n> verify?\n>\n> One possibility is to derive `R` using standard hierarchical derivation.\n> Then require that the staking pubkey be revealed to the sidechain network\n> as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly\n> with some trivial protection against Taproot).\n> To sign for a blockheight `h`, you must use your public key `P` and the\n> specific `R` we get from hierarchical derivation from `parent_R` and the\n> blockheight as index.\n>\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190122/0ef4688e/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-24T10:03:25",
                "message_text_only": "Good morning Dustin,\n\n> Wouldn\u2019t a revealed private key for time locked funds create a race to spend? I imagine miners who are paying attention would have the advantage but it would still just be a race.\n\nIf Bitcoin had implemented RBF \"properly\" (i.e. not have the silly \"opt-out\" rule) then such races are won by bidding up the fees.  A random person who is not the original staker would be willing to pay miners a fee up to the entire staked amount minus dustlimit satoshis; obviously a staker would be far less willing to pay up such a fee, so the random person slashing the funds would have a major advantage in that race.\nThus the race will be won by whoever mines the highest-fee transaction.\nIt still becomes very unlikely that the staker will win unless the staker already has a significant mining hashpower (and if the staker has significant hashpower, then the Bitoin layer itself is at peril anyway, never mind sidechains built on top of it).\n\nRegards,\nZmnSCPxj\n\n>\n> On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Good Morning Matt,\n> >\n> > > ### ZmnSCPxj,\n> > >\n> > > I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are\n> > unique for each blockheight but still can be used to create signatures or verify?\n> >\n> > One possibility is to derive `R` using standard hierarchical derivation.\n> > Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).\n> > To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Matt Bell",
                "date": "2019-01-24T18:46:11",
                "message_text_only": "It seems that miners would always claim the stake for themselves, why not\nsince the private key is public knowledge anyway? This is a nice security\nproperty since it wouldn't make economical sense for a miner to take a\nbribe from an attacker since it would have to be less than the stake amount.\n\nIt still becomes very unlikely that the staker will win unless the staker\n> already has a significant mining hashpower (and if the staker has\n> significant hashpower, then the Bitoin layer itself is at peril anyway,\n> never mind sidechains built on top of it).\n\n\nSince the likelihood of a successful attack is proportional to the\nattacker's share of the Bitcoin hashrate, the sidechain's integrity\nessentially has the same security level as the Bitcoin main chain.\nAlthough, the Bitcoin which was moved to the sidechain is susceptible to\nbeing stolen if 67% of the stakers collude, which does makes storing funds\non it weaker to some degree.\n\nOn Thu, Jan 24, 2019 at 2:03 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Dustin,\n>\n> > Wouldn\u2019t a revealed private key for time locked funds create a race to\n> spend? I imagine miners who are paying attention would have the advantage\n> but it would still just be a race.\n>\n> If Bitcoin had implemented RBF \"properly\" (i.e. not have the silly\n> \"opt-out\" rule) then such races are won by bidding up the fees.  A random\n> person who is not the original staker would be willing to pay miners a fee\n> up to the entire staked amount minus dustlimit satoshis; obviously a staker\n> would be far less willing to pay up such a fee, so the random person\n> slashing the funds would have a major advantage in that race.\n> Thus the race will be won by whoever mines the highest-fee transaction.\n> It still becomes very unlikely that the staker will win unless the staker\n> already has a significant mining hashpower (and if the staker has\n> significant hashpower, then the Bitoin layer itself is at peril anyway,\n> never mind sidechains built on top of it).\n>\n> Regards,\n> ZmnSCPxj\n>\n> >\n> > On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Good Morning Matt,\n> > >\n> > > > ### ZmnSCPxj,\n> > > >\n> > > > I'm intrigued by this mechanism of using fixed R values to prevent\n> multiple signatures, but how do we derive the R values in a way where they\n> are\n> > > unique for each blockheight but still can be used to create signatures\n> or verify?\n> > >\n> > > One possibility is to derive `R` using standard hierarchical\n> derivation.\n> > > Then require that the staking pubkey be revealed to the sidechain\n> network as actually being `staking_pubkey = P + hash(P || parent_R) * G`\n> (possibly with some trivial protection against Taproot).\n> > > To sign for a blockheight `h`, you must use your public key `P` and\n> the specific `R` we get from hierarchical derivation from `parent_R` and\n> the blockheight as index.\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190124/edf6f67a/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-01-25T00:16:30",
                "message_text_only": "On January 24, 2019 10:03:25 AM UTC, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Good morning Dustin,\n>\n>> Wouldn\u2019t a revealed private key for time locked funds create a race\n>to spend? I imagine miners who are paying attention would have the\n>advantage but it would still just be a race.\n>\n>If Bitcoin had implemented RBF \"properly\" (i.e. not have the silly\n>\"opt-out\" rule) then such races are won by bidding up the fees.  A\n\nNote that CSV using transactions are always RBF as CSV disables the opt-out.\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 500 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190125/471ee608/attachment.sig>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-25T05:33:37",
                "message_text_only": "Good mornint Peter,\n\n> > > Wouldn\u2019t a revealed private key for time locked funds create a race\n> > > to spend? I imagine miners who are paying attention would have the\n> > > advantage but it would still just be a race.\n> >\n> > If Bitcoin had implemented RBF \"properly\" (i.e. not have the silly\n> > \"opt-out\" rule) then such races are won by bidding up the fees. A\n>\n> Note that CSV using transactions are always RBF as CSV disables the opt-out.\n>\n\nThank you for this information.\nI forgot that RBF opt-out was hacked on top of `nSequence`, and relative timelocks were also hacked on top of `nSequence`.\nIn particular coins locked on mainchain for the purpose of staking a sidechain (mainstake) have to be locked with an `OP_CSV`, which immediately enables this protection.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Dr Adam Back",
                "date": "2019-01-22T20:22:36",
                "message_text_only": "Brands credentials use this single show, and multiple show\ncredentials. It's based on the representation problem which is the\ngeneralisation to multiple bases where Schnorr is one base, Pedersen\nCommitments are two bases, Representation problem is n>2 bases.\n\nThe method used would work for Schnorr or DSA and there was some 2013\nera #bitcoin-wizards discussion on this topic, where if you spend\ntwice miners can take your money, as a strong way to \"discourage\"\naddress reuse.  One side effect though is you force ACID log oriented\nstorage on the wallet, and many wallets are low power devices or even\na few in VMs that could be snapshotted or rolled back. Similar risk\nmodel to the lightning penalty for accidentally doing a hostile close\nin the current model (where ELTOO has non-penalty based close).\n\nYou would have to be careful to not use related nonces (k=nonce\ncommitted to by R=kG), as Schnorr and DSA are highly vulnerable to\nthat, like simultaneous equation two samples solvable.\n\nWhat the Brands n-show credential looks like is a precommitment like\nsingle show the address becomes A=H(R,Q) where Q is the public key,\nand n-show becomes A=H(R1,...,Rn,Q).\n\nSigning becomes providing i,Ri,Q in the Script to satisfy a\nScriptPubKey that includes the three. You would need to in practice\nstore the Ri values in a merkle tree probably so that you don't need\nto provide n inputs, but log(n) or some other structuring.\n\nAnyway main point being the fragility to related nonces, and cost of\nACID log structured storage levels of reliability in wallets.\n\nAdam\n\nOn Tue, 22 Jan 2019 at 15:14, ZmnSCPxj via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Good Morning Matt,\n>\n> > ### ZmnSCPxj,\n> >\n> > I'm intrigued by this mechanism of using fixed R values to prevent multiple signatures, but how do we derive the R values in a way where they are\n> unique for each blockheight but still can be used to create signatures or verify?\n>\n> One possibility is to derive `R` using standard hierarchical derivation.\n> Then require that the staking pubkey be revealed to the sidechain network as actually being `staking_pubkey = P + hash(P || parent_R) * G` (possibly with some trivial protection against Taproot).\n> To sign for a blockheight `h`, you must use your public key `P` and the specific `R` we get from hierarchical derivation from `parent_R` and the blockheight as index.\n>\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Proof-of-Stake Bitcoin Sidechains",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Satoshin",
                "Peter Todd",
                "Matt Bell",
                "ZmnSCPxj",
                "Dr Adam Back",
                "Dustin Dettmer"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 27497
        }
    },
    {
        "title": "[bitcoin-dev] bustapay BIP :: a practical sender/receiver coinjoin protocol",
        "thread_messages": [
            {
                "author": "Adam Gibson",
                "date": "2019-01-25T14:47:34",
                "message_text_only": "Ryan and list,\nI want to add some commentary to this (BIP79) to see if we can get\nfurther in standardizing this idea.\n\nWhen I first mulled it over I thought it too impractical, but its virtue\nof steganographic hiding means only minimal uptake is still enormously\ninteresting and worth pursuing; that's my current feeling. I've offered\nmore detailed thoughts in my blog post[1] (def not required reading here).\n\nBoth Joinmarket and Samourai have started implementing this kind of\ntransaction. And while that's interesting experimentally, some kind of\ncross-wallet standard would be helpful, albeit there some differences\nbetween that and the merchant/centralized service use-case.\n\nWe might imagine as a concrete goal for this BIP to create something\nthat would be acceptable for inclusion into a project like BTCPayServer,\nso that it could be used in a realistic use case by smaller bitcoin\naccepting merchants.\n\nComments to the BIP[2] as follows, with generic comments first, and then\nspecific comments for existing points in the BIP:\n\n[1] https://joinmarket.me/blog/blog/payjoin\n[2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki\n\nGeneric comments\n============\n* Protocol versioning. Since inevitably (even if only merchants), this\nmust be implemented by multiple wallets to be useful, the communication\nprotocol will need versioning (for example i have in my\nsimple/experimental Joinmarket PayJoin that sender sends min and max\nsupported version and receiver responds with a chosen protocol version\nso we can update). I do understand that as a client-server model can\napply here, we can ditch a lot of the complexities around network/p2p\ninteraction, but this much at least seems necessary.\n* Although it has its logic, I don't think \"Bustapay\" is a good name for\nthis protocol. I prefer \"PayJoin\" which is neutral sounding and\nself-descriptive. Needless to say this is not a hill I intend to die on.\n* PSBT/BIP174. I realise this has already been discussed, but this is a\ngood example of what this standardisation was designed for, so I'd be\nagainst not including it, even given the reality that, as you correctly\nobserve, it is not yet implemented in the majority of wallets and\nlibraries. One way round that is to make it optional (possibly combined\nwith above point about versioning). Note that for example you were\nobserving the necessity to check the sequence number was unchanged; that\nwould be encapsulated by checking equality of PSBT Input objects/fields.\nWhile one can make such software architecture arguments, the really\nfundamental point is the need for standards for x-wallet compatibility.\n* Version, Locktime: Perhaps this is not needed; in a peer to peer\nwallet scenario I think there might be logic in trying to get cover\ntraffic of (Core, Electrum, others), say, by using\nlast-block-locktime-mostly, as they do. Version should be 2 and sequence\nis a function of your suggestion to use BIP125. Worth noting that BIP125\nis *not* currently widely used on the network, though (see\nhttps://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason\nit should perhaps be explicitly only optional.\n* Avoidance of non-payment \"Unnecessary Input Heuristic\" (1, 2). For\nreference, see the definition here\nhttps://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539\nand some data here\nhttps://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791\n(whole comment thread may be of interest) - note this UIH name is afaik\nChris Belcher's invention, it seems useful as a categorisation.\n So, it seems that UIH2 is more important to avoid; while some more\nsophisticated wallet coin selection algorithms *may* occasionally pick\nan input set where one input is larger than any output, most won't, and\nsome in particular never will. So I think the text here should indicate\nthat *the receiver's contributed input(s) SHOULD be chosen to avoid\ntriggering the UIH2 heuristic where possible, so that the final payjoin\ntransaction is maximally plausible as an ordinary payment\" or similar.\nUIH1 is a nice-to-have (meaning the plausibility extends to two\ndifferent (both wrong) payment amounts, but it may not be necessary to\nmention it in the BIP.\n\n\nSpecific comments\n=================\n\n>> ====Step 4. Receiver validates, re-signs, and propagates on the\nbitcoin network====\n\nI believe this should say \"Sender\" not Receiver. Also for the next\nsentence, s/receiver/sender/:\n\n>> The receiver MUST validate the ''partial transaction'' was changed\ncorrectly and non-maliciously (to allow using potentially untrusted\ncommunication channels), re-sign its original inputs and propagate the\nfinal transaction over the bitcoin network.\n\nYour very correct highlighting of the attack vector of \"receiver gives\nsender other inputs belonging to sender to unwittingly sign (described\nbelow), should be highlighted here, perhaps with the phrase \"re-sign its\nORIGINAL inputs\" (only!)\".\n\n>> When the sender is creating a \"template transaction\" it is done\nalmost identically to creating a normal send, with the exception that\n*only* segwit inputs may be used. The sender is also encouraged to use a\nslightly more aggressive feerate than usual as well as BIP125 (Opt-in\nFull Replace-by-Fee Signaling), but neither is strictly required.\n\n\"slightly more aggressive feerate than usual\" - this I understand is to\nmake up for receiver contributed utxo, OK.\n\n\"*only* segwit inputs\" - it certainly makes things simpler. One can work\nwith non-segwit inputs but especially considering (as mentioned below)\nwe really ought to \"MUST\" the part about matching input types, I tend to\nagree that non-segwit should be disallowed.\n\n>> The receiver must add at least one input to the transaction (the\n\"contributed inputs\"). If the receiver has no inputs, it should use a\n500 internal server error, so the client can send the transaction as per\nnormal (or try again later).\n\nWould it not be much simpler for the server to return a different\n(non-error) response indicating that it will broadcast the template tx\nin this case?\n\n>> Its generally advised to only add a single contributed input, however\nthey are circumstances where adding more than a single input can be useful.\n\nI don't see a good reason to advise the use of only 1 input? (but this\nwill also connect with the above generic comment about \"UIH\"). I guess\nit's because of your approach to fees. I'd prefer not to create a\nlimitation here.\n\n>> To prevent an attack where a receiver is continually sent variations\nof the same transaction to enumerate the receivers utxo set, it is\nessential that the receiver always returns the same contributed inputs\nwhen it's seen the same inputs.\n\nThis is an approach to avoiding this problem which has the virtue of\nsimplicity, but it seems a little problematic. (1) You must keep a\nmapping of proposed payment utxos to one's proposed contributed input\nutxos, but (2) how should this be updated if you need to spend the\ncontribution mentioned in (1)? Ironically use of payjoin exacerbates\nthis issue, because it results in a smaller number of utxos being held\nby the receiver at any one time :) All this considered, I still see the\nvalue in your approach, but it might end up with a re-attempted payment\nbeing rejected. Certainly the more complex suggested solutions coming\nout of the summer 2018 coinjoin workshop aren't as practical as this,\nand may be overkill for small merchants/receivers.\n\n>> It is strongly preferable that the receiver makes an effort to pick a\ncontributed input of the same type as the other transaction inputs if\npossible.\n\nI have also thought about this and you could reasonably argue this\nshould be a MUST section in the BIP, that is, if the receiver cannot use\ninputs of the same type, he should fall back to the template\ntransaction. A mixed-input payjoin/coinjoin is essentially\nnear-perfectly identifiable as such (there is almost zero other usage of\nmulti-type-input transactions), which is a very different thing than a\nnon-identifiable payjoin transaction. That may or may not be OK to the\nsender. This is debatable though, for sure.\n\n>> After adding inputs to the transaction, the receiver generally will\nwant to adjust the output that pays himself by increasing it by the sum\nof the contributed input amounts (minus any fees he wants to\ncontribute). However the only strict requirement is that the receiver\n*must never* add or remove inputs, and *must not* ever decrease any\noutput amount.\n\n\"*must never* add or remove inputs\" - did you mean \"must never remove\ninputs\"? he surely has to add one! Or, perhaps you mean he must not\nalter the list of inputs provided by the sender (in which case it should\nbe clarified).\n\n\"must not decrease any output amount\" - I initally disagreed with this\nbut it is a better option than the one I currently chose in Joinmarket\npayjoin (sender pays all fee as long as receiver utxos are not too\nmuch). So this means that the receiver either consciously chooses to not\nincrease the fee, meaning the fee rate may be a bit low (hence your\nearlier comment about being generous, got it), or contributes via the\npayout amount. I guess the latter might break merchant software\nexpecting to have amount output fixed and fees determined by change.\n\nRegards,\nAdam Gibson/waxwing\n\nOn 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:\n> I've just finished writing an implementing of this, and extremely happy\n> with how it turned out. So I'd like to go and try go down the path of\n> more formally describing it and getting some comments and ultimately\n> encourage its wide-spread use.\n> \n> \n> ==Abstract==\n> \n> The way bitcoin transactions are overwhelming used is known to leak more\n> information than desirable. This has lead to fungibility concerns in bitcoin\n> and a raise of unreasonably effective blockchain analysis.\n> \n> Bustapay proposes a simple, practical way to bust these assumptions to\n> immediate\n> benefit of the sender and recievers. Furthermore it does so in such a\n> way that\n> helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.\n> \n> ==Copyright==\n> \n> This BIP is in the public domain.\n> \n> ==Motivation==\n> \n> One of the most powerful heuristic's employed by those whose goal is to\n> undermine\n> bitcoin's fungiblity has been to assume all inputs of a transaction are\n> signed by\n> a single party. In the few cases this assumption does not hold, it is\n> generally\n> readibly recognizable (e.g. traditional coinjoins have a very obvious\n> structure,\n> or multisig outputs are most frequently validated onchain).\n> \n> Bustapay requires no changes to bitcoin and creates bitcoin transactions\n> that are\n> indistinguishable from normal ones.\n> \n> It is worth noting that this specification has been intentionally kept\n> as simple\n> as possible to encourage adoption. There are almost an endless amount of\n> extensions\n> possible but the harder the implementation of clients/server the less\n> likely it\n> will ever be done. Should bustapay enjoy widespread adoption, a \"v2\"\n> specification\n> will be created with desired extensions.\n> \n> ==Specification==\n> \n> A bustapay payment is made from a sender to a receiver.\n> \n> Step 1. Sender creates a bitcoin transaction paying the receiver\n> \n> This transaction must be fully valid, signed and all inputs must use\n> segwit. This transaction is known as the \"template transaction\". This\n> transaction must not be propagated on the bitcoin network.\n> \n> Step 2. Sender gives the \"template transaction\" to the receiver\n> \n> This would generally be done as an HTTP POST. The exact URL to submit it\n> to could be specified with a bip21 encoded address. Such as\n> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit\n> and the HTTP body should be the raw transaction hex encoded as text.\n> \n> Step 3. Receiver processes the transaction and returns a partially\n> signed coinjoin\n> \n> The receiver validates the transaction is valid, pays himself and is\n> eligible for propation. The receiver then adds one of his own inputs\n> (known as the \"contributed input\") and increase the output that pays\n> himself by the contributed input amount. Doing so will invalidate the\n> \"template transaction\"'s original input signatures, so the sender needs\n> to return this \"partial transaction\" back to the receiver to sign. This\n> is returned as a hex-encoded raw transaction a response to the original\n> HTTP POST request.\n> \n> Step 4. Receiver validates, re-signs, and propagates on the bitcoin network\n> \n> The receiver is responsible in making sure the \"partial transaction\"\n> returned by the sender was changed correctly (it should assume the\n> connection has been MITM'd and act accordingly), resign its original\n> inputs and propagates this transaction over the bitcoin network. The\n> client must be aware that the server can reorder inputs and outputs.\n> \n> Step 5. Receiver observes the finalized transaction on the bitcoin network\n> \n> Once the receiver has seen the finalized transactions on the network\n> (and has enough confirmations) it can process it like a normal payment\n> for the sent amount (as opposed to the amount that it looks like on the\n> network). If the receiver does not see the finalized transaction after a\n> timeout will propagate the original \"template transaction\" to ensure the\n> payment happens and function a strong anti-DoS mechanism.\n> \n> \n> === Implementation Notes ===\n> For anyone wanting to implement bustapay payments, here are some notes\n> for receivers:\n> \n> * A transaction can easily be checked if it's suitable for the mempool\n> with testmempoolaccept in bitcoin core 0.17\n> * Tracking transactions by txid is precarious. To keep your sanity make\n> sure all inputs are segwit. But remember segwit does not prevent txid\n> malleability unless you validate the transaction. So really make sure\n> you're using testmempoolaccept at the very least\n> * Bustapay could be abused by a malicious party to query if you own a\n> deposit address or not. So never accept a bustapay transaction that pays\n> an already used deposit address\n> * You will need to keep a mapping of which utxos people have showed you\n> and which you revealed. So if you see them again, you can reveal the\n> same one of your own\n> * Check if the transaction was already sorted according to BIP69, if so\n> ensure the result stays that way. Otherwise probably just shuffle the\n> inputs/outpus\n> \n> Notes for sending applications:\n> \n> * The HTTP response must *not* be trusted. It should be fully validated\n> that no unexpected changes have been made to the transaction.\n> * The sender should be aware the original \"template transaction\" may be\n> propagated at any time, and in fact can intentionally be\n> \u00a0 done so for the purpose of RBF as it should have a slightly higher fee\n> rate.\n> \n> == Credits ==\n> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin\n> proposal, and reduced scope inspired by a simplification of the \"pay 2\n> endpoint\" (now offline) blog post by blockstream.\n> \n> \n> -Ryan\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-01-27T07:36:59",
                "message_text_only": "Thanks Adam,\n\nI have fixed the mistakes you have pointed out: https://github.com/bitcoin/bips/pull/754\n\nThanks for the detailed look!\n\n> but its virtue of steganographic hiding means only minimal uptake\n> is still enormously interesting and worth pursuing; that's my current feeling.\n\nI very much agree =) I really think anything that (silently) breaks the assumption of common ownership of transaction inputs offers outsized benefits for the whole ecosystem.\n\nOne other idea I have  is (way) better support for moving utxo's between wallets. The least controversial use case is moving funds between wallets you own. Like I might want to move *specific* utxo's from/to my joinmarket wallet, but not create a (privacy losing / expensive) transaction. Both core and joinmarket fail at this at a practical point of view.\n\nLike imho it'd be pretty cool having a standardized format for (txid:vout:privatekey) with wallets showing it as \"External UTXO\" and preferentially spending it (and wallet not automatically importing any other utxo from that address).\n\nTaken a bit further (this is the part which everyone hates) you could send someone money (or withdraw it from a service) by giving a person. It's not generally useful (for obvious reasons), but there's a lot of cases I think it's super cool.\n\n---\n\nGetting back on topic, without trying to do a point-by-point reply, I agree with pretty much everything you said but I am reluctant to make any changes.\n\nI don't meant to be obtuse or anything, but I strongly believe the limiting factor to adoption to all these protocols is actually just getting people to implement it. I made multiple implementations of bustapay from both the sending/receiving end, so I could try develop the easiest to implement system that is still practical.\n\nFor instance I like PSBT and it's nice in theory. I actually had an original implementation using it, which is how I found some bugs in the core and golang version of PSBT). But in practice it's hugely overkill and significantly increases the implementation complexity complexity and is poorly supported. Switching to just a raw transaction actually made everything easier. (And that's not to criticise PSBT, I would definitely want to use it in other contexts).\n\nAnyway, a big motivation for me even writing it as a BIP was to formalize my little anti-DOS trick of privately creating a \"template transaction\" which can just be dumped on the network as punishment. So if nothing else, hopefully I'll have demonstrated it's a pretty practical way of doing things.\n\n--\n\nAlso your analysis on \"Unnecessary Input Heuristic\" is pretty cool, but I also don't like telling people to \"avoid the UIH2\" without providing the actual algo they should use. But really I think it's better off in a sort of article \"how to pick contributed inputs\" or something, as while it's nice it's not a huge deal and there's a lot of debatable tradeoffs that can/should be used. For instance the implementation I wrote for bustabit.com currently just heavily biases tainted inputs (e.g. ones associated with address reuse).\n\n\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Ryan and list,\n> I want to add some commentary to this (BIP79) to see if we can get\n> further in standardizing this idea.\n>\n> When I first mulled it over I thought it too impractical, but its virtue\n> of steganographic hiding means only minimal uptake is still enormously\n> interesting and worth pursuing; that's my current feeling. I've offered\n> more detailed thoughts in my blog post[1] (def not required reading here).\n>\n> Both Joinmarket and Samourai have started implementing this kind of\n> transaction. And while that's interesting experimentally, some kind of\n> cross-wallet standard would be helpful, albeit there some differences\n> between that and the merchant/centralized service use-case.\n>\n> We might imagine as a concrete goal for this BIP to create something\n> that would be acceptable for inclusion into a project like BTCPayServer,\n> so that it could be used in a realistic use case by smaller bitcoin\n> accepting merchants.\n>\n> Comments to the BIP[2] as follows, with generic comments first, and then\n> specific comments for existing points in the BIP:\n>\n> [1] https://joinmarket.me/blog/blog/payjoin\n> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki\n>\n> Generic comments\n>\n> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\n>\n> -   Protocol versioning. Since inevitably (even if only merchants), this\n>     must be implemented by multiple wallets to be useful, the communication\n>     protocol will need versioning (for example i have in my\n>     simple/experimental Joinmarket PayJoin that sender sends min and max\n>     supported version and receiver responds with a chosen protocol version\n>     so we can update). I do understand that as a client-server model can\n>     apply here, we can ditch a lot of the complexities around network/p2p\n>     interaction, but this much at least seems necessary.\n>\n> -   Although it has its logic, I don't think \"Bustapay\" is a good name for\n>     this protocol. I prefer \"PayJoin\" which is neutral sounding and\n>     self-descriptive. Needless to say this is not a hill I intend to die on.\n>\n> -   PSBT/BIP174. I realise this has already been discussed, but this is a\n>     good example of what this standardisation was designed for, so I'd be\n>     against not including it, even given the reality that, as you correctly\n>     observe, it is not yet implemented in the majority of wallets and\n>     libraries. One way round that is to make it optional (possibly combined\n>     with above point about versioning). Note that for example you were\n>     observing the necessity to check the sequence number was unchanged; that\n>     would be encapsulated by checking equality of PSBT Input objects/fields.\n>     While one can make such software architecture arguments, the really\n>     fundamental point is the need for standards for x-wallet compatibility.\n>\n> -   Version, Locktime: Perhaps this is not needed; in a peer to peer\n>     wallet scenario I think there might be logic in trying to get cover\n>     traffic of (Core, Electrum, others), say, by using\n>     last-block-locktime-mostly, as they do. Version should be 2 and sequence\n>     is a function of your suggestion to use BIP125. Worth noting that BIP125\n>     is not currently widely used on the network, though (see\n>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason\n>     it should perhaps be explicitly only optional.\n>\n> -   Avoidance of non-payment \"Unnecessary Input Heuristic\" (1, 2). For\n>     reference, see the definition here\n>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539\n>     and some data here\n>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791\n>     (whole comment thread may be of interest) - note this UIH name is afaik\n>     Chris Belcher's invention, it seems useful as a categorisation.\n>     So, it seems that UIH2 is more important to avoid; while some more\n>     sophisticated wallet coin selection algorithms may occasionally pick\n>     an input set where one input is larger than any output, most won't, and\n>     some in particular never will. So I think the text here should indicate\n>     that *the receiver's contributed input(s) SHOULD be chosen to avoid\n>     triggering the UIH2 heuristic where possible, so that the final payjoin\n>     transaction is maximally plausible as an ordinary payment\" or similar.\n>     UIH1 is a nice-to-have (meaning the plausibility extends to two\n>     different (both wrong) payment amounts, but it may not be necessary to\n>     mention it in the BIP.\n>\n>     Specific comments\n>     =================\n>\n>\n> > > ====Step 4. Receiver validates, re-signs, and propagates on the\n>\n> bitcoin network====\n>\n> I believe this should say \"Sender\" not Receiver. Also for the next\n> sentence, s/receiver/sender/:\n>\n> > > The receiver MUST validate the ''partial transaction'' was changed\n>\n> correctly and non-maliciously (to allow using potentially untrusted\n> communication channels), re-sign its original inputs and propagate the\n> final transaction over the bitcoin network.\n>\n> Your very correct highlighting of the attack vector of \"receiver gives\n> sender other inputs belonging to sender to unwittingly sign (described\n> below), should be highlighted here, perhaps with the phrase \"re-sign its\n> ORIGINAL inputs\" (only!)\".\n>\n> > > When the sender is creating a \"template transaction\" it is done\n>\n> almost identically to creating a normal send, with the exception that\n> only segwit inputs may be used. The sender is also encouraged to use a\n> slightly more aggressive feerate than usual as well as BIP125 (Opt-in\n> Full Replace-by-Fee Signaling), but neither is strictly required.\n>\n> \"slightly more aggressive feerate than usual\" - this I understand is to\n> make up for receiver contributed utxo, OK.\n>\n> \"only segwit inputs\" - it certainly makes things simpler. One can work\n> with non-segwit inputs but especially considering (as mentioned below)\n> we really ought to \"MUST\" the part about matching input types, I tend to\n> agree that non-segwit should be disallowed.\n>\n> > > The receiver must add at least one input to the transaction (the\n>\n> \"contributed inputs\"). If the receiver has no inputs, it should use a\n> 500 internal server error, so the client can send the transaction as per\n> normal (or try again later).\n>\n> Would it not be much simpler for the server to return a different\n> (non-error) response indicating that it will broadcast the template tx\n> in this case?\n>\n> > > Its generally advised to only add a single contributed input, however\n>\n> they are circumstances where adding more than a single input can be useful.\n>\n> I don't see a good reason to advise the use of only 1 input? (but this\n> will also connect with the above generic comment about \"UIH\"). I guess\n> it's because of your approach to fees. I'd prefer not to create a\n> limitation here.\n>\n> > > To prevent an attack where a receiver is continually sent variations\n>\n> of the same transaction to enumerate the receivers utxo set, it is\n> essential that the receiver always returns the same contributed inputs\n> when it's seen the same inputs.\n>\n> This is an approach to avoiding this problem which has the virtue of\n> simplicity, but it seems a little problematic. (1) You must keep a\n> mapping of proposed payment utxos to one's proposed contributed input\n> utxos, but (2) how should this be updated if you need to spend the\n> contribution mentioned in (1)? Ironically use of payjoin exacerbates\n> this issue, because it results in a smaller number of utxos being held\n> by the receiver at any one time :) All this considered, I still see the\n> value in your approach, but it might end up with a re-attempted payment\n> being rejected. Certainly the more complex suggested solutions coming\n> out of the summer 2018 coinjoin workshop aren't as practical as this,\n> and may be overkill for small merchants/receivers.\n>\n> > > It is strongly preferable that the receiver makes an effort to pick a\n>\n> contributed input of the same type as the other transaction inputs if\n> possible.\n>\n> I have also thought about this and you could reasonably argue this\n> should be a MUST section in the BIP, that is, if the receiver cannot use\n> inputs of the same type, he should fall back to the template\n> transaction. A mixed-input payjoin/coinjoin is essentially\n> near-perfectly identifiable as such (there is almost zero other usage of\n> multi-type-input transactions), which is a very different thing than a\n> non-identifiable payjoin transaction. That may or may not be OK to the\n> sender. This is debatable though, for sure.\n>\n> > > After adding inputs to the transaction, the receiver generally will\n>\n> want to adjust the output that pays himself by increasing it by the sum\n> of the contributed input amounts (minus any fees he wants to\n> contribute). However the only strict requirement is that the receiver\n> must never add or remove inputs, and must not ever decrease any\n> output amount.\n>\n> \"must never add or remove inputs\" - did you mean \"must never remove\n> inputs\"? he surely has to add one! Or, perhaps you mean he must not\n> alter the list of inputs provided by the sender (in which case it should\n> be clarified).\n>\n> \"must not decrease any output amount\" - I initally disagreed with this\n> but it is a better option than the one I currently chose in Joinmarket\n> payjoin (sender pays all fee as long as receiver utxos are not too\n> much). So this means that the receiver either consciously chooses to not\n> increase the fee, meaning the fee rate may be a bit low (hence your\n> earlier comment about being generous, got it), or contributes via the\n> payout amount. I guess the latter might break merchant software\n> expecting to have amount output fixed and fees determined by change.\n>\n> Regards,\n> Adam Gibson/waxwing\n>\n> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:\n>\n> > I've just finished writing an implementing of this, and extremely happy\n> > with how it turned out. So I'd like to go and try go down the path of\n> > more formally describing it and getting some comments and ultimately\n> > encourage its wide-spread use.\n> > ==Abstract==\n> > The way bitcoin transactions are overwhelming used is known to leak more\n> > information than desirable. This has lead to fungibility concerns in bitcoin\n> > and a raise of unreasonably effective blockchain analysis.\n> > Bustapay proposes a simple, practical way to bust these assumptions to\n> > immediate\n> > benefit of the sender and recievers. Furthermore it does so in such a\n> > way that\n> > helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.\n> > ==Copyright==\n> > This BIP is in the public domain.\n> > ==Motivation==\n> > One of the most powerful heuristic's employed by those whose goal is to\n> > undermine\n> > bitcoin's fungiblity has been to assume all inputs of a transaction are\n> > signed by\n> > a single party. In the few cases this assumption does not hold, it is\n> > generally\n> > readibly recognizable (e.g. traditional coinjoins have a very obvious\n> > structure,\n> > or multisig outputs are most frequently validated onchain).\n> > Bustapay requires no changes to bitcoin and creates bitcoin transactions\n> > that are\n> > indistinguishable from normal ones.\n> > It is worth noting that this specification has been intentionally kept\n> > as simple\n> > as possible to encourage adoption. There are almost an endless amount of\n> > extensions\n> > possible but the harder the implementation of clients/server the less\n> > likely it\n> > will ever be done. Should bustapay enjoy widespread adoption, a \"v2\"\n> > specification\n> > will be created with desired extensions.\n> > ==Specification==\n> > A bustapay payment is made from a sender to a receiver.\n> > Step 1. Sender creates a bitcoin transaction paying the receiver\n> > This transaction must be fully valid, signed and all inputs must use\n> > segwit. This transaction is known as the \"template transaction\". This\n> > transaction must not be propagated on the bitcoin network.\n> > Step 2. Sender gives the \"template transaction\" to the receiver\n> > This would generally be done as an HTTP POST. The exact URL to submit it\n> > to could be specified with a bip21 encoded address. Such as\n> > bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit\n> > and the HTTP body should be the raw transaction hex encoded as text.\n> > Step 3. Receiver processes the transaction and returns a partially\n> > signed coinjoin\n> > The receiver validates the transaction is valid, pays himself and is\n> > eligible for propation. The receiver then adds one of his own inputs\n> > (known as the \"contributed input\") and increase the output that pays\n> > himself by the contributed input amount. Doing so will invalidate the\n> > \"template transaction\"'s original input signatures, so the sender needs\n> > to return this \"partial transaction\" back to the receiver to sign. This\n> > is returned as a hex-encoded raw transaction a response to the original\n> > HTTP POST request.\n> > Step 4. Receiver validates, re-signs, and propagates on the bitcoin network\n> > The receiver is responsible in making sure the \"partial transaction\"\n> > returned by the sender was changed correctly (it should assume the\n> > connection has been MITM'd and act accordingly), resign its original\n> > inputs and propagates this transaction over the bitcoin network. The\n> > client must be aware that the server can reorder inputs and outputs.\n> > Step 5. Receiver observes the finalized transaction on the bitcoin network\n> > Once the receiver has seen the finalized transactions on the network\n> > (and has enough confirmations) it can process it like a normal payment\n> > for the sent amount (as opposed to the amount that it looks like on the\n> > network). If the receiver does not see the finalized transaction after a\n> > timeout will propagate the original \"template transaction\" to ensure the\n> > payment happens and function a strong anti-DoS mechanism.\n> > === Implementation Notes ===\n> > For anyone wanting to implement bustapay payments, here are some notes\n> > for receivers:\n> >\n> > -   A transaction can easily be checked if it's suitable for the mempool\n> >     with testmempoolaccept in bitcoin core 0.17\n> >\n> > -   Tracking transactions by txid is precarious. To keep your sanity make\n> >     sure all inputs are segwit. But remember segwit does not prevent txid\n> >     malleability unless you validate the transaction. So really make sure\n> >     you're using testmempoolaccept at the very least\n> >\n> > -   Bustapay could be abused by a malicious party to query if you own a\n> >     deposit address or not. So never accept a bustapay transaction that pays\n> >     an already used deposit address\n> >\n> > -   You will need to keep a mapping of which utxos people have showed you\n> >     and which you revealed. So if you see them again, you can reveal the\n> >     same one of your own\n> >\n> > -   Check if the transaction was already sorted according to BIP69, if so\n> >     ensure the result stays that way. Otherwise probably just shuffle the\n> >     inputs/outpus\n> >\n> >\n> > Notes for sending applications:\n> >\n> > -   The HTTP response must not be trusted. It should be fully validated\n> >     that no unexpected changes have been made to the transaction.\n> >\n> > -   The sender should be aware the original \"template transaction\" may be\n> >     propagated at any time, and in fact can intentionally be\n> >     \u00a0 done so for the purpose of RBF as it should have a slightly higher fee\n> >     rate.\n> >\n> >\n> > == Credits ==\n> > The idea is obviously based upon Dr. Maxwell's seminal CoinJoin\n> > proposal, and reduced scope inspired by a simplification of the \"pay 2\n> > endpoint\" (now offline) blog post by blockstream.\n> > -Ryan\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Adam Gibson",
                "date": "2019-01-27T12:20:54",
                "message_text_only": "On 27. 01. 19 8:36, rhavar at protonmail.com wrote:\n> Thanks Adam,\n> \n> I have fixed the mistakes you have pointed out: https://github.com/bitcoin/bips/pull/754\n> \n> Thanks for the detailed look!\n> \n>> but its virtue of steganographic hiding means only minimal uptake\n>> is still enormously interesting and worth pursuing; that's my current feeling.\n> \n> I very much agree =) I really think anything that (silently) breaks the assumption of common ownership of transaction inputs offers outsized benefits for the whole ecosystem.\n> \n> One other idea I have  is (way) better support for moving utxo's between wallets. The least controversial use case is moving funds between wallets you own. Like I might want to move *specific* utxo's from/to my joinmarket wallet, but not create a (privacy losing / expensive) transaction. Both core and joinmarket fail at this at a practical point of view.\n\n(tangential, but yes coin control in JM is an obviously necessary\nfeature and will be done, I just don't have time).\n\n> \n> Like imho it'd be pretty cool having a standardized format for (txid:vout:privatekey) with wallets showing it as \"External UTXO\" and preferentially spending it (and wallet not automatically importing any other utxo from that address).\n> \n> Taken a bit further (this is the part which everyone hates) you could send someone money (or withdraw it from a service) by giving a person. It's not generally useful (for obvious reasons), but there's a lot of cases I think it's super cool.\n\nIs there a missing word. \"by giving a person..\"? Not actually sure what\nyou're getting at here but I suspect it's again tangential to this BIP\ndiscussion.\n\n> \n> ---\n> \n> Getting back on topic, without trying to do a point-by-point reply, I agree with pretty much everything you said but I am reluctant to make any changes.\n> \n> I don't meant to be obtuse or anything, but I strongly believe the limiting factor to adoption to all these protocols is actually just getting people to implement it. I made multiple implementations of bustapay from both the sending/receiving end, so I could try develop the easiest to implement system that is still practical.\n\nYou know, there's considerable evidence to the contrary, I'd argue: this\nidea *has* been implemented already three times: by yourself, by myself\nand by Samourai. And in fully incompatible ways :) So I think the\nlimiting factor is in fact creating a standard that a reasonable number\nof people could agree with (and I like operational definitions, so\nsubjective as it is, I like the goal of \"good/clear enough that it could\nbe incorporated into something like BtcPayServer\")\n\n> \n> For instance I like PSBT and it's nice in theory. I actually had an original implementation using it, which is how I found some bugs in the core and golang version of PSBT). But in practice it's hugely overkill and significantly increases the implementation complexity complexity and is poorly supported. Switching to just a raw transaction actually made everything easier. (And that's not to criticise PSBT, I would definitely want to use it in other contexts).\n\nBut this relates back to my first \"generic\" point that you haven't\naddressed here - protocol versioning and the possibility of more than\none option. Perhaps more realistic (debatable): have the current version\nbe non-PSBT but with a plan to have a version bump with PSBT in future.\nStuff like that. It seems crazy to actually long term reject it.\n\n> \n> Anyway, a big motivation for me even writing it as a BIP was to formalize my little anti-DOS trick of privately creating a \"template transaction\" which can just be dumped on the network as punishment. So if nothing else, hopefully I'll have demonstrated it's a pretty practical way of doing things.\n> \n\nI don't want to be that guy, but this was a central part of the proposal\nthat came of the meetup last summer and is in Haywood's blogpost. I mean\nif you came up it with separately, then cool :) But I was there, that\nwas established immediately as the right way of doing this to avoid a\ntrivial attack.\nWhat might have confused you is all that stuff about multiple candidates\nand even ZKP approaches - those were just extra ideas about making it\nreally secure at large scale; but those ideas don't quite meet the goal\n(for various reasons); well, arguably. The basic anti-DOS of an initial\nnon-coinjoin was sorta central.\n(Also I'm noting you didn't respond to my critique of your \"always use\nthe same contributions\" defence; I mean, probably that's fine, it was\nonly really saying it isn't perfect. Was just curious to hear\nyour/others thoughts on it).\n\n> --\n> \n> Also your analysis on \"Unnecessary Input Heuristic\" is pretty cool, but I also don't like telling people to \"avoid the UIH2\" without providing the actual algo they should use. But really I think it's better off in a sort of article \"how to pick contributed inputs\" or something, as while it's nice it's not a huge deal and there's a lot of debatable tradeoffs that can/should be used. For instance the implementation I wrote for bustabit.com currently just heavily biases tainted inputs (e.g. ones associated with address reuse).\n> \n\nGood point about algo.\nI wrote my best effort at a procedure here:\nhttps://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709\n\nI asked for comments on it but got none back so far (gists are terrible\nfor this unfortunately, perhaps I'll have more luck on the list).\n\nI would argue that this issue *should* be mentioned on the BIP. A *huge*\npart of what makes PayJoin/BustaPay of interest is the steganographic\nfeature, if you don't pay attention to this then it doesn't look like a\npayment (caveat.-->).\nThe counterargument is Laurent's statistics which I previously linked,\nsuggesting that maybe 30% of txs violate this anyway, today. I'm not\nsure about that, will need more analysis; Core's SRD algo may be one\nreason, but anyway ... better to make things look like payments.\n\nIt doesn't hurt to prompt an implementer to do this; whether it's\nfeasible in that specific wallet situation or not is up to them; whether\nthey want to go hog wild and control percentages of UIH1 and UIH2 and\nwhatnot is there business, or they can totally ignore it - but without\nit being mentioned in the BIP, they may not even think of it.\n\nA last point, you also don't see value in being more explicit about\nsimple things like transaction version and locktime? Even if you think\nthese things should *not* be controlled, e.g. the protocol should allow\neither transaction version, then it'd be better to explicitly say so.\n> \n> \n> -Ryan\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Ryan and list,\n>> I want to add some commentary to this (BIP79) to see if we can get\n>> further in standardizing this idea.\n>>\n>> When I first mulled it over I thought it too impractical, but its virtue\n>> of steganographic hiding means only minimal uptake is still enormously\n>> interesting and worth pursuing; that's my current feeling. I've offered\n>> more detailed thoughts in my blog post[1] (def not required reading here).\n>>\n>> Both Joinmarket and Samourai have started implementing this kind of\n>> transaction. And while that's interesting experimentally, some kind of\n>> cross-wallet standard would be helpful, albeit there some differences\n>> between that and the merchant/centralized service use-case.\n>>\n>> We might imagine as a concrete goal for this BIP to create something\n>> that would be acceptable for inclusion into a project like BTCPayServer,\n>> so that it could be used in a realistic use case by smaller bitcoin\n>> accepting merchants.\n>>\n>> Comments to the BIP[2] as follows, with generic comments first, and then\n>> specific comments for existing points in the BIP:\n>>\n>> [1] https://joinmarket.me/blog/blog/payjoin\n>> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki\n>>\n>> Generic comments\n>>\n>> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\n>>\n>> -   Protocol versioning. Since inevitably (even if only merchants), this\n>>     must be implemented by multiple wallets to be useful, the communication\n>>     protocol will need versioning (for example i have in my\n>>     simple/experimental Joinmarket PayJoin that sender sends min and max\n>>     supported version and receiver responds with a chosen protocol version\n>>     so we can update). I do understand that as a client-server model can\n>>     apply here, we can ditch a lot of the complexities around network/p2p\n>>     interaction, but this much at least seems necessary.\n>>\n>> -   Although it has its logic, I don't think \"Bustapay\" is a good name for\n>>     this protocol. I prefer \"PayJoin\" which is neutral sounding and\n>>     self-descriptive. Needless to say this is not a hill I intend to die on.\n>>\n>> -   PSBT/BIP174. I realise this has already been discussed, but this is a\n>>     good example of what this standardisation was designed for, so I'd be\n>>     against not including it, even given the reality that, as you correctly\n>>     observe, it is not yet implemented in the majority of wallets and\n>>     libraries. One way round that is to make it optional (possibly combined\n>>     with above point about versioning). Note that for example you were\n>>     observing the necessity to check the sequence number was unchanged; that\n>>     would be encapsulated by checking equality of PSBT Input objects/fields.\n>>     While one can make such software architecture arguments, the really\n>>     fundamental point is the need for standards for x-wallet compatibility.\n>>\n>> -   Version, Locktime: Perhaps this is not needed; in a peer to peer\n>>     wallet scenario I think there might be logic in trying to get cover\n>>     traffic of (Core, Electrum, others), say, by using\n>>     last-block-locktime-mostly, as they do. Version should be 2 and sequence\n>>     is a function of your suggestion to use BIP125. Worth noting that BIP125\n>>     is not currently widely used on the network, though (see\n>>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this reason\n>>     it should perhaps be explicitly only optional.\n>>\n>> -   Avoidance of non-payment \"Unnecessary Input Heuristic\" (1, 2). For\n>>     reference, see the definition here\n>>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539\n>>     and some data here\n>>     https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791\n>>     (whole comment thread may be of interest) - note this UIH name is afaik\n>>     Chris Belcher's invention, it seems useful as a categorisation.\n>>     So, it seems that UIH2 is more important to avoid; while some more\n>>     sophisticated wallet coin selection algorithms may occasionally pick\n>>     an input set where one input is larger than any output, most won't, and\n>>     some in particular never will. So I think the text here should indicate\n>>     that *the receiver's contributed input(s) SHOULD be chosen to avoid\n>>     triggering the UIH2 heuristic where possible, so that the final payjoin\n>>     transaction is maximally plausible as an ordinary payment\" or similar.\n>>     UIH1 is a nice-to-have (meaning the plausibility extends to two\n>>     different (both wrong) payment amounts, but it may not be necessary to\n>>     mention it in the BIP.\n>>\n>>     Specific comments\n>>     =================\n>>\n>>\n>>>> ====Step 4. Receiver validates, re-signs, and propagates on the\n>>\n>> bitcoin network====\n>>\n>> I believe this should say \"Sender\" not Receiver. Also for the next\n>> sentence, s/receiver/sender/:\n>>\n>>>> The receiver MUST validate the ''partial transaction'' was changed\n>>\n>> correctly and non-maliciously (to allow using potentially untrusted\n>> communication channels), re-sign its original inputs and propagate the\n>> final transaction over the bitcoin network.\n>>\n>> Your very correct highlighting of the attack vector of \"receiver gives\n>> sender other inputs belonging to sender to unwittingly sign (described\n>> below), should be highlighted here, perhaps with the phrase \"re-sign its\n>> ORIGINAL inputs\" (only!)\".\n>>\n>>>> When the sender is creating a \"template transaction\" it is done\n>>\n>> almost identically to creating a normal send, with the exception that\n>> only segwit inputs may be used. The sender is also encouraged to use a\n>> slightly more aggressive feerate than usual as well as BIP125 (Opt-in\n>> Full Replace-by-Fee Signaling), but neither is strictly required.\n>>\n>> \"slightly more aggressive feerate than usual\" - this I understand is to\n>> make up for receiver contributed utxo, OK.\n>>\n>> \"only segwit inputs\" - it certainly makes things simpler. One can work\n>> with non-segwit inputs but especially considering (as mentioned below)\n>> we really ought to \"MUST\" the part about matching input types, I tend to\n>> agree that non-segwit should be disallowed.\n>>\n>>>> The receiver must add at least one input to the transaction (the\n>>\n>> \"contributed inputs\"). If the receiver has no inputs, it should use a\n>> 500 internal server error, so the client can send the transaction as per\n>> normal (or try again later).\n>>\n>> Would it not be much simpler for the server to return a different\n>> (non-error) response indicating that it will broadcast the template tx\n>> in this case?\n>>\n>>>> Its generally advised to only add a single contributed input, however\n>>\n>> they are circumstances where adding more than a single input can be useful.\n>>\n>> I don't see a good reason to advise the use of only 1 input? (but this\n>> will also connect with the above generic comment about \"UIH\"). I guess\n>> it's because of your approach to fees. I'd prefer not to create a\n>> limitation here.\n>>\n>>>> To prevent an attack where a receiver is continually sent variations\n>>\n>> of the same transaction to enumerate the receivers utxo set, it is\n>> essential that the receiver always returns the same contributed inputs\n>> when it's seen the same inputs.\n>>\n>> This is an approach to avoiding this problem which has the virtue of\n>> simplicity, but it seems a little problematic. (1) You must keep a\n>> mapping of proposed payment utxos to one's proposed contributed input\n>> utxos, but (2) how should this be updated if you need to spend the\n>> contribution mentioned in (1)? Ironically use of payjoin exacerbates\n>> this issue, because it results in a smaller number of utxos being held\n>> by the receiver at any one time :) All this considered, I still see the\n>> value in your approach, but it might end up with a re-attempted payment\n>> being rejected. Certainly the more complex suggested solutions coming\n>> out of the summer 2018 coinjoin workshop aren't as practical as this,\n>> and may be overkill for small merchants/receivers.\n>>\n>>>> It is strongly preferable that the receiver makes an effort to pick a\n>>\n>> contributed input of the same type as the other transaction inputs if\n>> possible.\n>>\n>> I have also thought about this and you could reasonably argue this\n>> should be a MUST section in the BIP, that is, if the receiver cannot use\n>> inputs of the same type, he should fall back to the template\n>> transaction. A mixed-input payjoin/coinjoin is essentially\n>> near-perfectly identifiable as such (there is almost zero other usage of\n>> multi-type-input transactions), which is a very different thing than a\n>> non-identifiable payjoin transaction. That may or may not be OK to the\n>> sender. This is debatable though, for sure.\n>>\n>>>> After adding inputs to the transaction, the receiver generally will\n>>\n>> want to adjust the output that pays himself by increasing it by the sum\n>> of the contributed input amounts (minus any fees he wants to\n>> contribute). However the only strict requirement is that the receiver\n>> must never add or remove inputs, and must not ever decrease any\n>> output amount.\n>>\n>> \"must never add or remove inputs\" - did you mean \"must never remove\n>> inputs\"? he surely has to add one! Or, perhaps you mean he must not\n>> alter the list of inputs provided by the sender (in which case it should\n>> be clarified).\n>>\n>> \"must not decrease any output amount\" - I initally disagreed with this\n>> but it is a better option than the one I currently chose in Joinmarket\n>> payjoin (sender pays all fee as long as receiver utxos are not too\n>> much). So this means that the receiver either consciously chooses to not\n>> increase the fee, meaning the fee rate may be a bit low (hence your\n>> earlier comment about being generous, got it), or contributes via the\n>> payout amount. I guess the latter might break merchant software\n>> expecting to have amount output fixed and fees determined by change.\n>>\n>> Regards,\n>> Adam Gibson/waxwing\n>>\n>> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:\n>>\n>>> I've just finished writing an implementing of this, and extremely happy\n>>> with how it turned out. So I'd like to go and try go down the path of\n>>> more formally describing it and getting some comments and ultimately\n>>> encourage its wide-spread use.\n>>> ==Abstract==\n>>> The way bitcoin transactions are overwhelming used is known to leak more\n>>> information than desirable. This has lead to fungibility concerns in bitcoin\n>>> and a raise of unreasonably effective blockchain analysis.\n>>> Bustapay proposes a simple, practical way to bust these assumptions to\n>>> immediate\n>>> benefit of the sender and recievers. Furthermore it does so in such a\n>>> way that\n>>> helps recievers avoid utxo bloat, a constant problem for bitcoin merchants.\n>>> ==Copyright==\n>>> This BIP is in the public domain.\n>>> ==Motivation==\n>>> One of the most powerful heuristic's employed by those whose goal is to\n>>> undermine\n>>> bitcoin's fungiblity has been to assume all inputs of a transaction are\n>>> signed by\n>>> a single party. In the few cases this assumption does not hold, it is\n>>> generally\n>>> readibly recognizable (e.g. traditional coinjoins have a very obvious\n>>> structure,\n>>> or multisig outputs are most frequently validated onchain).\n>>> Bustapay requires no changes to bitcoin and creates bitcoin transactions\n>>> that are\n>>> indistinguishable from normal ones.\n>>> It is worth noting that this specification has been intentionally kept\n>>> as simple\n>>> as possible to encourage adoption. There are almost an endless amount of\n>>> extensions\n>>> possible but the harder the implementation of clients/server the less\n>>> likely it\n>>> will ever be done. Should bustapay enjoy widespread adoption, a \"v2\"\n>>> specification\n>>> will be created with desired extensions.\n>>> ==Specification==\n>>> A bustapay payment is made from a sender to a receiver.\n>>> Step 1. Sender creates a bitcoin transaction paying the receiver\n>>> This transaction must be fully valid, signed and all inputs must use\n>>> segwit. This transaction is known as the \"template transaction\". This\n>>> transaction must not be propagated on the bitcoin network.\n>>> Step 2. Sender gives the \"template transaction\" to the receiver\n>>> This would generally be done as an HTTP POST. The exact URL to submit it\n>>> to could be specified with a bip21 encoded address. Such as\n>>> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit\n>>> and the HTTP body should be the raw transaction hex encoded as text.\n>>> Step 3. Receiver processes the transaction and returns a partially\n>>> signed coinjoin\n>>> The receiver validates the transaction is valid, pays himself and is\n>>> eligible for propation. The receiver then adds one of his own inputs\n>>> (known as the \"contributed input\") and increase the output that pays\n>>> himself by the contributed input amount. Doing so will invalidate the\n>>> \"template transaction\"'s original input signatures, so the sender needs\n>>> to return this \"partial transaction\" back to the receiver to sign. This\n>>> is returned as a hex-encoded raw transaction a response to the original\n>>> HTTP POST request.\n>>> Step 4. Receiver validates, re-signs, and propagates on the bitcoin network\n>>> The receiver is responsible in making sure the \"partial transaction\"\n>>> returned by the sender was changed correctly (it should assume the\n>>> connection has been MITM'd and act accordingly), resign its original\n>>> inputs and propagates this transaction over the bitcoin network. The\n>>> client must be aware that the server can reorder inputs and outputs.\n>>> Step 5. Receiver observes the finalized transaction on the bitcoin network\n>>> Once the receiver has seen the finalized transactions on the network\n>>> (and has enough confirmations) it can process it like a normal payment\n>>> for the sent amount (as opposed to the amount that it looks like on the\n>>> network). If the receiver does not see the finalized transaction after a\n>>> timeout will propagate the original \"template transaction\" to ensure the\n>>> payment happens and function a strong anti-DoS mechanism.\n>>> === Implementation Notes ===\n>>> For anyone wanting to implement bustapay payments, here are some notes\n>>> for receivers:\n>>>\n>>> -   A transaction can easily be checked if it's suitable for the mempool\n>>>     with testmempoolaccept in bitcoin core 0.17\n>>>\n>>> -   Tracking transactions by txid is precarious. To keep your sanity make\n>>>     sure all inputs are segwit. But remember segwit does not prevent txid\n>>>     malleability unless you validate the transaction. So really make sure\n>>>     you're using testmempoolaccept at the very least\n>>>\n>>> -   Bustapay could be abused by a malicious party to query if you own a\n>>>     deposit address or not. So never accept a bustapay transaction that pays\n>>>     an already used deposit address\n>>>\n>>> -   You will need to keep a mapping of which utxos people have showed you\n>>>     and which you revealed. So if you see them again, you can reveal the\n>>>     same one of your own\n>>>\n>>> -   Check if the transaction was already sorted according to BIP69, if so\n>>>     ensure the result stays that way. Otherwise probably just shuffle the\n>>>     inputs/outpus\n>>>\n>>>\n>>> Notes for sending applications:\n>>>\n>>> -   The HTTP response must not be trusted. It should be fully validated\n>>>     that no unexpected changes have been made to the transaction.\n>>>\n>>> -   The sender should be aware the original \"template transaction\" may be\n>>>     propagated at any time, and in fact can intentionally be\n>>>     \u00a0 done so for the purpose of RBF as it should have a slightly higher fee\n>>>     rate.\n>>>\n>>>\n>>> == Credits ==\n>>> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin\n>>> proposal, and reduced scope inspired by a simplification of the \"pay 2\n>>> endpoint\" (now offline) blog post by blockstream.\n>>> -Ryan\n>>>\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-01-27T19:24:11",
                "message_text_only": "> Is there a missing word. \"by giving a person..\"? Not actually sure what\n> you're getting at here but I suspect it's again tangential to this BIP\n> discussion.\n\nCorrect on both points. I meant to say \"giving a (txid:vout:privkey)\" to a person as means of payment.\n\n\n> So I think the limiting factor is in fact creating a standard that a reasonable number\n> of people could agree with (and I like operational definitions, so\n> subjective as it is, I like the goal of \"good/clear enough that it could\n> be incorporated into something like BtcPayServer\")\n\n\nThe problem with BtcPayServer (and a lot of similar software), is that it's not very unsuitable for any sender/receiver coinjoin due to it not having its own wallet. As I understand the basic architecture is just a fancy wrapper around bip32 address generation and monitoring the payment to those addresses. This means that adding support is not only a large code change, but it also entails a substantial change for merchants (you can't just have your payments flow into your trezor, but need to run a hot wallet)\n\nBut I strongly believe that bustapay is good enough _right now_ for BtcPayServer integration (which I'd happily contribute myself, if it wasn't for my unfamiliarity of the project and c#)\n\n\n> But this relates back to my first \"generic\" point that you haven't\n> addressed here - protocol versioning and the possibility of more than\n> one option. Perhaps more realistic (debatable): have the current version\n> be non-PSBT but with a plan to have a version bump with PSBT in future.\n> Stuff like that. It seems crazy to actually long term reject it.\n\nAdding backwards-compatible versioning at a later stage would be pretty trivial through either the URL or HTTP header (e.g  version=2)  and if breaking backwards compatible is desirable it can also easily been done (e.g. bump the bip21 or send an incompatible request/response). I don't see this as a problem at all, and I'm not rejecting it long-term, I just don't think it's particularly helpful to bikeshed now, when adoption is pretty much zero.\n\n\n\n> I don't want to be that guy, but this was a central part of the proposal\n> that came of the meetup last summer and is in Haywood's blogpost. I mean\n> if you came up it with separately, then cool :) But I was there, that\n> was established immediately as the right way of doing this to avoid a\n> trivial attack.\n\nOh wow. had no idea. I saw the part about the receiver spamming the sender with a bunch of transactions, where only 1 of them are real and thought \"ewww\" and \"came up\" with the idea of a \"template transaction\" instead. I was always wondering why no one came up it, but now it makes sense. The transaction-spam stage was just an _additional_ layer of protection.\n\nOk, now I feel like an idiot =)  Thanks for letting me know.\n\n\n> The counterargument is Laurent's statistics which I previously linked,\n> suggesting that maybe 30% of txs violate this anyway, today. I'm not\n> sure about that, will need more analysis; Core's SRD algo may be one\n> reason, but anyway ... better to make things look like payments.\n\nI think it's interesting, but I don't think it particularly matters. Avoiding UIH1 I think is pretty much irrelevant, as it'll likely just confuse any analysis into thinking the payment is the reverse of what it actually is. And wallets already don't care about violating UIH2(as a way to do implicit consolidation). If 30% of tx's are violating it, you can be pretty sure it means the _vast majority_ of wallets run coin selection in such a way that can violation UIH2.  Most wallets use a coin selection algorithm that you can approximate with:\n\nwhile !enoughMoney {\n    inputs += getAnotherInput();\n}\n\nand don't run a final pass that would prune superfluous inputs.  Even coinsayer (shill alert) which I believe runs the most advanced coin selection algorithms, will routinely and intentionally violate UIH2 when it's ideal (e.g. most classic case: when `consolidationFeeRate >= minFeeRate`).\n\nI'm not trying to dismiss your analysis, as I find it interesting. I'm just against increasing the cognitive burden on implementations by mentioning all this stuff, when the truth is it (barely) matters.  If wallets routinely avoided UIH2 and making a UIH2 payment would \"out\" the transaction as much more likely to be a bustapay, then I'd definitely reconsider and provide a basic suggestion into how to try avoid it.\n\nAnd like I said, I also think there's much more important things that go into \"picking a contributed input\" than just this.\n\n\n\n> A last point, you also don't see value in being more explicit about\n> simple things like transaction version and locktime? Even if you think\n> these things should not be controlled, e.g. the protocol should allow\n> either transaction version, then it'd be better to explicitly say so.\n\n\nMy intention was that wallets create a transaction exactly like they normally would do, and use that as the template transaction. The only time I wanted to be prescriptive was when it would increase the implementation complexity (e.g. being non-segwit compatible is a pain in the ass. So I'd rather just be \"pure segwit only\" transactions). But something like locktime makes no difference as long as the transaction is mempool eligible, so I'd rather just wallets do what they do anyway.\n\nAlthough I think there should be a separate discussion on improving the uniformity of bitcoin transactions in general. The current state of affairs is really atrocious.\n\n\n\n---\n\n\nP.S. I know I come across as obstinate, but it's not really so. If you can come up with an alternative to bustapay with some traction, I'd love to get behind it and deprecate bustapay in favor of it. I just am pretty happy with the state of bustapay and it's status a sort of \"MVP of pay2endpoint\", and unless the argument is in the form: \"We'd love to support it, but in order to do so we'd need X\" I'm probably going to disagree."
            },
            {
                "author": "James MacWhyte",
                "date": "2019-01-27T19:42:03",
                "message_text_only": "Why does the template transaction need to be signed in step one and passed\nback and forth so many times? What is wrong with:\n\n1. Sender creates unsigned tx with their relevant inputs and outputs. This\ntx is passed to receiver.\n\n2. Receiver adds their relevant inputs and outputs and signs their portion\nbefore returning the tx to sender.\n\n3. Sender confirms their inputs and outputs have not been modified, and\nsigns the remainder of the tx before broadcasting it (or sending it to the\nrecipient if you want to follow the payment protocol spec).\n\nJames\n\nOn Sun, Jan 27, 2019, 08:45 Adam Gibson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org wrote:\n\n>\n>\n> On 27. 01. 19 8:36, rhavar at protonmail.com wrote:\n> > Thanks Adam,\n> >\n> > I have fixed the mistakes you have pointed out:\n> https://github.com/bitcoin/bips/pull/754\n> >\n> > Thanks for the detailed look!\n> >\n> >> but its virtue of steganographic hiding means only minimal uptake\n> >> is still enormously interesting and worth pursuing; that's my current\n> feeling.\n> >\n> > I very much agree =) I really think anything that (silently) breaks the\n> assumption of common ownership of transaction inputs offers outsized\n> benefits for the whole ecosystem.\n> >\n> > One other idea I have  is (way) better support for moving utxo's between\n> wallets. The least controversial use case is moving funds between wallets\n> you own. Like I might want to move *specific* utxo's from/to my joinmarket\n> wallet, but not create a (privacy losing / expensive) transaction. Both\n> core and joinmarket fail at this at a practical point of view.\n>\n> (tangential, but yes coin control in JM is an obviously necessary\n> feature and will be done, I just don't have time).\n>\n> >\n> > Like imho it'd be pretty cool having a standardized format for\n> (txid:vout:privatekey) with wallets showing it as \"External UTXO\" and\n> preferentially spending it (and wallet not automatically importing any\n> other utxo from that address).\n> >\n> > Taken a bit further (this is the part which everyone hates) you could\n> send someone money (or withdraw it from a service) by giving a person. It's\n> not generally useful (for obvious reasons), but there's a lot of cases I\n> think it's super cool.\n>\n> Is there a missing word. \"by giving a person..\"? Not actually sure what\n> you're getting at here but I suspect it's again tangential to this BIP\n> discussion.\n>\n> >\n> > ---\n> >\n> > Getting back on topic, without trying to do a point-by-point reply, I\n> agree with pretty much everything you said but I am reluctant to make any\n> changes.\n> >\n> > I don't meant to be obtuse or anything, but I strongly believe the\n> limiting factor to adoption to all these protocols is actually just getting\n> people to implement it. I made multiple implementations of bustapay from\n> both the sending/receiving end, so I could try develop the easiest to\n> implement system that is still practical.\n>\n> You know, there's considerable evidence to the contrary, I'd argue: this\n> idea *has* been implemented already three times: by yourself, by myself\n> and by Samourai. And in fully incompatible ways :) So I think the\n> limiting factor is in fact creating a standard that a reasonable number\n> of people could agree with (and I like operational definitions, so\n> subjective as it is, I like the goal of \"good/clear enough that it could\n> be incorporated into something like BtcPayServer\")\n>\n> >\n> > For instance I like PSBT and it's nice in theory. I actually had an\n> original implementation using it, which is how I found some bugs in the\n> core and golang version of PSBT). But in practice it's hugely overkill and\n> significantly increases the implementation complexity complexity and is\n> poorly supported. Switching to just a raw transaction actually made\n> everything easier. (And that's not to criticise PSBT, I would definitely\n> want to use it in other contexts).\n>\n> But this relates back to my first \"generic\" point that you haven't\n> addressed here - protocol versioning and the possibility of more than\n> one option. Perhaps more realistic (debatable): have the current version\n> be non-PSBT but with a plan to have a version bump with PSBT in future.\n> Stuff like that. It seems crazy to actually long term reject it.\n>\n> >\n> > Anyway, a big motivation for me even writing it as a BIP was to\n> formalize my little anti-DOS trick of privately creating a \"template\n> transaction\" which can just be dumped on the network as punishment. So if\n> nothing else, hopefully I'll have demonstrated it's a pretty practical way\n> of doing things.\n> >\n>\n> I don't want to be that guy, but this was a central part of the proposal\n> that came of the meetup last summer and is in Haywood's blogpost. I mean\n> if you came up it with separately, then cool :) But I was there, that\n> was established immediately as the right way of doing this to avoid a\n> trivial attack.\n> What might have confused you is all that stuff about multiple candidates\n> and even ZKP approaches - those were just extra ideas about making it\n> really secure at large scale; but those ideas don't quite meet the goal\n> (for various reasons); well, arguably. The basic anti-DOS of an initial\n> non-coinjoin was sorta central.\n> (Also I'm noting you didn't respond to my critique of your \"always use\n> the same contributions\" defence; I mean, probably that's fine, it was\n> only really saying it isn't perfect. Was just curious to hear\n> your/others thoughts on it).\n>\n> > --\n> >\n> > Also your analysis on \"Unnecessary Input Heuristic\" is pretty cool, but\n> I also don't like telling people to \"avoid the UIH2\" without providing the\n> actual algo they should use. But really I think it's better off in a sort\n> of article \"how to pick contributed inputs\" or something, as while it's\n> nice it's not a huge deal and there's a lot of debatable tradeoffs that\n> can/should be used. For instance the implementation I wrote for\n> bustabit.com currently just heavily biases tainted inputs (e.g. ones\n> associated with address reuse).\n> >\n>\n> Good point about algo.\n> I wrote my best effort at a procedure here:\n>\n> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709\n>\n> I asked for comments on it but got none back so far (gists are terrible\n> for this unfortunately, perhaps I'll have more luck on the list).\n>\n> I would argue that this issue *should* be mentioned on the BIP. A *huge*\n> part of what makes PayJoin/BustaPay of interest is the steganographic\n> feature, if you don't pay attention to this then it doesn't look like a\n> payment (caveat.-->).\n> The counterargument is Laurent's statistics which I previously linked,\n> suggesting that maybe 30% of txs violate this anyway, today. I'm not\n> sure about that, will need more analysis; Core's SRD algo may be one\n> reason, but anyway ... better to make things look like payments.\n>\n> It doesn't hurt to prompt an implementer to do this; whether it's\n> feasible in that specific wallet situation or not is up to them; whether\n> they want to go hog wild and control percentages of UIH1 and UIH2 and\n> whatnot is there business, or they can totally ignore it - but without\n> it being mentioned in the BIP, they may not even think of it.\n>\n> A last point, you also don't see value in being more explicit about\n> simple things like transaction version and locktime? Even if you think\n> these things should *not* be controlled, e.g. the protocol should allow\n> either transaction version, then it'd be better to explicitly say so.\n> >\n> >\n> > -Ryan\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Friday, January 25, 2019 6:47 AM, Adam Gibson via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >> Ryan and list,\n> >> I want to add some commentary to this (BIP79) to see if we can get\n> >> further in standardizing this idea.\n> >>\n> >> When I first mulled it over I thought it too impractical, but its virtue\n> >> of steganographic hiding means only minimal uptake is still enormously\n> >> interesting and worth pursuing; that's my current feeling. I've offered\n> >> more detailed thoughts in my blog post[1] (def not required reading\n> here).\n> >>\n> >> Both Joinmarket and Samourai have started implementing this kind of\n> >> transaction. And while that's interesting experimentally, some kind of\n> >> cross-wallet standard would be helpful, albeit there some differences\n> >> between that and the merchant/centralized service use-case.\n> >>\n> >> We might imagine as a concrete goal for this BIP to create something\n> >> that would be acceptable for inclusion into a project like BTCPayServer,\n> >> so that it could be used in a realistic use case by smaller bitcoin\n> >> accepting merchants.\n> >>\n> >> Comments to the BIP[2] as follows, with generic comments first, and then\n> >> specific comments for existing points in the BIP:\n> >>\n> >> [1] https://joinmarket.me/blog/blog/payjoin\n> >> [2] https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki\n> >>\n> >> Generic comments\n> >>\n> >>\n> ==================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\n> >>\n> >> -   Protocol versioning. Since inevitably (even if only merchants), this\n> >>     must be implemented by multiple wallets to be useful, the\n> communication\n> >>     protocol will need versioning (for example i have in my\n> >>     simple/experimental Joinmarket PayJoin that sender sends min and max\n> >>     supported version and receiver responds with a chosen protocol\n> version\n> >>     so we can update). I do understand that as a client-server model can\n> >>     apply here, we can ditch a lot of the complexities around\n> network/p2p\n> >>     interaction, but this much at least seems necessary.\n> >>\n> >> -   Although it has its logic, I don't think \"Bustapay\" is a good name\n> for\n> >>     this protocol. I prefer \"PayJoin\" which is neutral sounding and\n> >>     self-descriptive. Needless to say this is not a hill I intend to\n> die on.\n> >>\n> >> -   PSBT/BIP174. I realise this has already been discussed, but this is\n> a\n> >>     good example of what this standardisation was designed for, so I'd\n> be\n> >>     against not including it, even given the reality that, as you\n> correctly\n> >>     observe, it is not yet implemented in the majority of wallets and\n> >>     libraries. One way round that is to make it optional (possibly\n> combined\n> >>     with above point about versioning). Note that for example you were\n> >>     observing the necessity to check the sequence number was unchanged;\n> that\n> >>     would be encapsulated by checking equality of PSBT Input\n> objects/fields.\n> >>     While one can make such software architecture arguments, the really\n> >>     fundamental point is the need for standards for x-wallet\n> compatibility.\n> >>\n> >> -   Version, Locktime: Perhaps this is not needed; in a peer to peer\n> >>     wallet scenario I think there might be logic in trying to get cover\n> >>     traffic of (Core, Electrum, others), say, by using\n> >>     last-block-locktime-mostly, as they do. Version should be 2 and\n> sequence\n> >>     is a function of your suggestion to use BIP125. Worth noting that\n> BIP125\n> >>     is not currently widely used on the network, though (see\n> >>     https://p2sh.info/dashboard/db/replace-by-fee?orgId=1). For this\n> reason\n> >>     it should perhaps be explicitly only optional.\n> >>\n> >> -   Avoidance of non-payment \"Unnecessary Input Heuristic\" (1, 2). For\n> >>     reference, see the definition here\n> >>\n> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2796539\n> >>     and some data here\n> >>\n> https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2800791\n> >>     (whole comment thread may be of interest) - note this UIH name is\n> afaik\n> >>     Chris Belcher's invention, it seems useful as a categorisation.\n> >>     So, it seems that UIH2 is more important to avoid; while some more\n> >>     sophisticated wallet coin selection algorithms may occasionally pick\n> >>     an input set where one input is larger than any output, most won't,\n> and\n> >>     some in particular never will. So I think the text here should\n> indicate\n> >>     that *the receiver's contributed input(s) SHOULD be chosen to avoid\n> >>     triggering the UIH2 heuristic where possible, so that the final\n> payjoin\n> >>     transaction is maximally plausible as an ordinary payment\" or\n> similar.\n> >>     UIH1 is a nice-to-have (meaning the plausibility extends to two\n> >>     different (both wrong) payment amounts, but it may not be necessary\n> to\n> >>     mention it in the BIP.\n> >>\n> >>     Specific comments\n> >>     =================\n> >>\n> >>\n> >>>> ====Step 4. Receiver validates, re-signs, and propagates on the\n> >>\n> >> bitcoin network====\n> >>\n> >> I believe this should say \"Sender\" not Receiver. Also for the next\n> >> sentence, s/receiver/sender/:\n> >>\n> >>>> The receiver MUST validate the ''partial transaction'' was changed\n> >>\n> >> correctly and non-maliciously (to allow using potentially untrusted\n> >> communication channels), re-sign its original inputs and propagate the\n> >> final transaction over the bitcoin network.\n> >>\n> >> Your very correct highlighting of the attack vector of \"receiver gives\n> >> sender other inputs belonging to sender to unwittingly sign (described\n> >> below), should be highlighted here, perhaps with the phrase \"re-sign its\n> >> ORIGINAL inputs\" (only!)\".\n> >>\n> >>>> When the sender is creating a \"template transaction\" it is done\n> >>\n> >> almost identically to creating a normal send, with the exception that\n> >> only segwit inputs may be used. The sender is also encouraged to use a\n> >> slightly more aggressive feerate than usual as well as BIP125 (Opt-in\n> >> Full Replace-by-Fee Signaling), but neither is strictly required.\n> >>\n> >> \"slightly more aggressive feerate than usual\" - this I understand is to\n> >> make up for receiver contributed utxo, OK.\n> >>\n> >> \"only segwit inputs\" - it certainly makes things simpler. One can work\n> >> with non-segwit inputs but especially considering (as mentioned below)\n> >> we really ought to \"MUST\" the part about matching input types, I tend to\n> >> agree that non-segwit should be disallowed.\n> >>\n> >>>> The receiver must add at least one input to the transaction (the\n> >>\n> >> \"contributed inputs\"). If the receiver has no inputs, it should use a\n> >> 500 internal server error, so the client can send the transaction as per\n> >> normal (or try again later).\n> >>\n> >> Would it not be much simpler for the server to return a different\n> >> (non-error) response indicating that it will broadcast the template tx\n> >> in this case?\n> >>\n> >>>> Its generally advised to only add a single contributed input, however\n> >>\n> >> they are circumstances where adding more than a single input can be\n> useful.\n> >>\n> >> I don't see a good reason to advise the use of only 1 input? (but this\n> >> will also connect with the above generic comment about \"UIH\"). I guess\n> >> it's because of your approach to fees. I'd prefer not to create a\n> >> limitation here.\n> >>\n> >>>> To prevent an attack where a receiver is continually sent variations\n> >>\n> >> of the same transaction to enumerate the receivers utxo set, it is\n> >> essential that the receiver always returns the same contributed inputs\n> >> when it's seen the same inputs.\n> >>\n> >> This is an approach to avoiding this problem which has the virtue of\n> >> simplicity, but it seems a little problematic. (1) You must keep a\n> >> mapping of proposed payment utxos to one's proposed contributed input\n> >> utxos, but (2) how should this be updated if you need to spend the\n> >> contribution mentioned in (1)? Ironically use of payjoin exacerbates\n> >> this issue, because it results in a smaller number of utxos being held\n> >> by the receiver at any one time :) All this considered, I still see the\n> >> value in your approach, but it might end up with a re-attempted payment\n> >> being rejected. Certainly the more complex suggested solutions coming\n> >> out of the summer 2018 coinjoin workshop aren't as practical as this,\n> >> and may be overkill for small merchants/receivers.\n> >>\n> >>>> It is strongly preferable that the receiver makes an effort to pick a\n> >>\n> >> contributed input of the same type as the other transaction inputs if\n> >> possible.\n> >>\n> >> I have also thought about this and you could reasonably argue this\n> >> should be a MUST section in the BIP, that is, if the receiver cannot use\n> >> inputs of the same type, he should fall back to the template\n> >> transaction. A mixed-input payjoin/coinjoin is essentially\n> >> near-perfectly identifiable as such (there is almost zero other usage of\n> >> multi-type-input transactions), which is a very different thing than a\n> >> non-identifiable payjoin transaction. That may or may not be OK to the\n> >> sender. This is debatable though, for sure.\n> >>\n> >>>> After adding inputs to the transaction, the receiver generally will\n> >>\n> >> want to adjust the output that pays himself by increasing it by the sum\n> >> of the contributed input amounts (minus any fees he wants to\n> >> contribute). However the only strict requirement is that the receiver\n> >> must never add or remove inputs, and must not ever decrease any\n> >> output amount.\n> >>\n> >> \"must never add or remove inputs\" - did you mean \"must never remove\n> >> inputs\"? he surely has to add one! Or, perhaps you mean he must not\n> >> alter the list of inputs provided by the sender (in which case it should\n> >> be clarified).\n> >>\n> >> \"must not decrease any output amount\" - I initally disagreed with this\n> >> but it is a better option than the one I currently chose in Joinmarket\n> >> payjoin (sender pays all fee as long as receiver utxos are not too\n> >> much). So this means that the receiver either consciously chooses to not\n> >> increase the fee, meaning the fee rate may be a bit low (hence your\n> >> earlier comment about being generous, got it), or contributes via the\n> >> payout amount. I guess the latter might break merchant software\n> >> expecting to have amount output fixed and fees determined by change.\n> >>\n> >> Regards,\n> >> Adam Gibson/waxwing\n> >>\n> >> On 30. 08. 18 22:24, Ryan Havar via bitcoin-dev wrote:\n> >>\n> >>> I've just finished writing an implementing of this, and extremely happy\n> >>> with how it turned out. So I'd like to go and try go down the path of\n> >>> more formally describing it and getting some comments and ultimately\n> >>> encourage its wide-spread use.\n> >>> ==Abstract==\n> >>> The way bitcoin transactions are overwhelming used is known to leak\n> more\n> >>> information than desirable. This has lead to fungibility concerns in\n> bitcoin\n> >>> and a raise of unreasonably effective blockchain analysis.\n> >>> Bustapay proposes a simple, practical way to bust these assumptions to\n> >>> immediate\n> >>> benefit of the sender and recievers. Furthermore it does so in such a\n> >>> way that\n> >>> helps recievers avoid utxo bloat, a constant problem for bitcoin\n> merchants.\n> >>> ==Copyright==\n> >>> This BIP is in the public domain.\n> >>> ==Motivation==\n> >>> One of the most powerful heuristic's employed by those whose goal is to\n> >>> undermine\n> >>> bitcoin's fungiblity has been to assume all inputs of a transaction are\n> >>> signed by\n> >>> a single party. In the few cases this assumption does not hold, it is\n> >>> generally\n> >>> readibly recognizable (e.g. traditional coinjoins have a very obvious\n> >>> structure,\n> >>> or multisig outputs are most frequently validated onchain).\n> >>> Bustapay requires no changes to bitcoin and creates bitcoin\n> transactions\n> >>> that are\n> >>> indistinguishable from normal ones.\n> >>> It is worth noting that this specification has been intentionally kept\n> >>> as simple\n> >>> as possible to encourage adoption. There are almost an endless amount\n> of\n> >>> extensions\n> >>> possible but the harder the implementation of clients/server the less\n> >>> likely it\n> >>> will ever be done. Should bustapay enjoy widespread adoption, a \"v2\"\n> >>> specification\n> >>> will be created with desired extensions.\n> >>> ==Specification==\n> >>> A bustapay payment is made from a sender to a receiver.\n> >>> Step 1. Sender creates a bitcoin transaction paying the receiver\n> >>> This transaction must be fully valid, signed and all inputs must use\n> >>> segwit. This transaction is known as the \"template transaction\". This\n> >>> transaction must not be propagated on the bitcoin network.\n> >>> Step 2. Sender gives the \"template transaction\" to the receiver\n> >>> This would generally be done as an HTTP POST. The exact URL to submit\n> it\n> >>> to could be specified with a bip21 encoded address. Such as\n> >>> bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=\n> https://bp.bustabit.com/submit\n> >>> and the HTTP body should be the raw transaction hex encoded as text.\n> >>> Step 3. Receiver processes the transaction and returns a partially\n> >>> signed coinjoin\n> >>> The receiver validates the transaction is valid, pays himself and is\n> >>> eligible for propation. The receiver then adds one of his own inputs\n> >>> (known as the \"contributed input\") and increase the output that pays\n> >>> himself by the contributed input amount. Doing so will invalidate the\n> >>> \"template transaction\"'s original input signatures, so the sender needs\n> >>> to return this \"partial transaction\" back to the receiver to sign. This\n> >>> is returned as a hex-encoded raw transaction a response to the original\n> >>> HTTP POST request.\n> >>> Step 4. Receiver validates, re-signs, and propagates on the bitcoin\n> network\n> >>> The receiver is responsible in making sure the \"partial transaction\"\n> >>> returned by the sender was changed correctly (it should assume the\n> >>> connection has been MITM'd and act accordingly), resign its original\n> >>> inputs and propagates this transaction over the bitcoin network. The\n> >>> client must be aware that the server can reorder inputs and outputs.\n> >>> Step 5. Receiver observes the finalized transaction on the bitcoin\n> network\n> >>> Once the receiver has seen the finalized transactions on the network\n> >>> (and has enough confirmations) it can process it like a normal payment\n> >>> for the sent amount (as opposed to the amount that it looks like on the\n> >>> network). If the receiver does not see the finalized transaction after\n> a\n> >>> timeout will propagate the original \"template transaction\" to ensure\n> the\n> >>> payment happens and function a strong anti-DoS mechanism.\n> >>> === Implementation Notes ===\n> >>> For anyone wanting to implement bustapay payments, here are some notes\n> >>> for receivers:\n> >>>\n> >>> -   A transaction can easily be checked if it's suitable for the\n> mempool\n> >>>     with testmempoolaccept in bitcoin core 0.17\n> >>>\n> >>> -   Tracking transactions by txid is precarious. To keep your sanity\n> make\n> >>>     sure all inputs are segwit. But remember segwit does not prevent\n> txid\n> >>>     malleability unless you validate the transaction. So really make\n> sure\n> >>>     you're using testmempoolaccept at the very least\n> >>>\n> >>> -   Bustapay could be abused by a malicious party to query if you own a\n> >>>     deposit address or not. So never accept a bustapay transaction\n> that pays\n> >>>     an already used deposit address\n> >>>\n> >>> -   You will need to keep a mapping of which utxos people have showed\n> you\n> >>>     and which you revealed. So if you see them again, you can reveal\n> the\n> >>>     same one of your own\n> >>>\n> >>> -   Check if the transaction was already sorted according to BIP69, if\n> so\n> >>>     ensure the result stays that way. Otherwise probably just shuffle\n> the\n> >>>     inputs/outpus\n> >>>\n> >>>\n> >>> Notes for sending applications:\n> >>>\n> >>> -   The HTTP response must not be trusted. It should be fully validated\n> >>>     that no unexpected changes have been made to the transaction.\n> >>>\n> >>> -   The sender should be aware the original \"template transaction\" may\n> be\n> >>>     propagated at any time, and in fact can intentionally be\n> >>>       done so for the purpose of RBF as it should have a slightly\n> higher fee\n> >>>     rate.\n> >>>\n> >>>\n> >>> == Credits ==\n> >>> The idea is obviously based upon Dr. Maxwell's seminal CoinJoin\n> >>> proposal, and reduced scope inspired by a simplification of the \"pay 2\n> >>> endpoint\" (now offline) blog post by blockstream.\n> >>> -Ryan\n> >>>\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190127/7a236457/attachment-0001.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-01-27T22:11:47",
                "message_text_only": "> Why does the template transaction need to be signed in step one and passed back and forth so many times? What is wrong with:\n\nIt isn't passed \"back and forth so many times\".  It works exactly as you proposed, with the only difference is in \"Step 1\" the sender uses a *signed* transaction instead of an unsigned one.  This is an important anti-DoS/anti-spy tactic, as it proves the sender actually owns those inputs and if the protocol is not followed to completion, the transaction can be dumped on the network.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190127/785cba15/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2019-01-30T02:06:30",
                "message_text_only": "James\n\n\nOn Sun, Jan 27, 2019 at 2:11 PM <rhavar at protonmail.com> wrote:\n\n>\n> It isn't passed \"back and forth so many times\".\n>\n\nYou are right, I got the wrong impression the first time I read it.\n\n\n> This is an important anti-DoS/anti-spy tactic, as it proves the sender\n> actually owns those inputs and if the protocol is not followed to\n> completion, the transaction can be dumped on the network.\n>\n\nI'm not convinced this is a valid concern, at least not valid enough to add\nextra complications to the process. The sender could still refuse to sign\nthe final transaction after they see the recipient's in-/outputs; \"show me\nyours and I'll show you mine\" isn't much of a spy deterrent, and nothing\nhere prevents a DOS attack.\n\nAs an implementor, I would suggest keeping the protocol as simple as\npossible. By dropping the signing in the first step, the recipient doesn't\nneed to maintain the ability to lookup and verify unspent outputs. It also\nwould enforce the increased privacy, which the sender obviously wants if\nthey are going down this path (in other words, either have the process\ncomplete or fail -- don't give the recipient the ability to broadcast the\nnot-private transaction against the wishes of the sender).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190129/e3d08376/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2019-01-30T02:46:47",
                "message_text_only": "On Tuesday, January 29, 2019 6:06 PM, James MacWhyte <keatonatron at gmail.com> wrote:\n\n> I'm not convinced this is a valid concern, at least not valid enough to add extra complications to the process.\n\nSigning a transaction is something a wallet needs to be able to do anyway AND at the final-step. And actually a signed transaction is _simpler_ because it's more standard and way format to send and validate.\n\n> The sender could still refuse to sign the final transaction after they see the recipient's in-/outputs; \"show me yours and I'll show you mine\" isn't much of a spy deterrent, and nothing here prevents a DOS attack.\n\nIf the sender refuses to sign the final transaction, the receiver just propagates the template transaction which pays the receiver! So it's a pretty weak attack.\n\nThe only real attack is that the sender could double-spend the template-transaction before it's propagated, but the cost of doing this isn't free, as at the very least you need to pay the transaction fees of creating a double spend. It's not an amazingly good defence, but it's good enough that it's unlikely to get abused (and an attacker would only learn a single utxo of the receiver) .\n\n> As an implementor, I would suggest keeping the protocol as simple as possible. By dropping the signing in the first step, the recipient doesn't need to maintain the ability to lookup and verify unspent outputs.\n\nBeing able to verify a transaction tends to be pretty simple in practice.  (e.g. `testmempoolaccept` in bitcoin core's wallet) but if it's really hard for a receiver to do, it can easily just not do it... (and assume the template transaction is valid even if it's not).\n\nBut I suspect this actually complicates the job for the receiver, because now you have to deal with transaction malleability as they can now give you an invalid transaction, you sign it  and then they malleate into a valid transaction with a different txid. So if you're tracking the transaction by txid, you'll get really confused...).\n\n> It also would enforce the increased privacy, which the sender obviously wants if they are going down this path\n\nI guess that's a valid concern. A sender might want to make a payment, but *only* if it can be done via a bustapay, while the current spec doesn't support that.\n\nBut there's no way that justifies removing the protection for receivers. Without some _basic_ protection, every company that takes bustapayments will just get constantly attacked by a simple costless `wget` that leaks their wallet utxos...\n\nThe only viable way I can see, would be the sender pays the first part of his invoice in lightning. And then pays the rest with a bustapay. Now the anti-spy thing is the fact the first part of the invoice was already paid.\n\nBut with so many moving parts, no one is ever going to implement that :P\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/dbe00339/attachment.html>"
            },
            {
                "author": "James MacWhyte",
                "date": "2019-01-30T20:58:03",
                "message_text_only": "On Tue, Jan 29, 2019 at 6:46 PM <rhavar at protonmail.com> wrote:\n\n>\n> If the sender refuses to sign the final transaction, the receiver just\n> propagates the template transaction which pays the receiver! So it's a\n> pretty weak attack.\n>\n> The only real attack is that the sender could double-spend the\n> template-transaction before it's propagated, but the cost of doing this\n> isn't free, as at the very least you need to pay the transaction fees of\n> creating a double spend. It's not an amazingly good defence, but it's good\n> enough that it's unlikely to get abused (and an attacker would only learn a\n> single utxo of the receiver) .\n>\n\nOkay, I see what you mean. I better understand the weaknesses you've\nidentified, and I can't really think of a better solution than what you've\nproposed. I also realized that implementors who aren't capable of\nintegrating signing and UTXO validation wouldn't be the ones trying to\nimplement this feature, so my concerns there are also moot. Carry on ;)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/f26a6e84/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-28T04:14:41",
                "message_text_only": "Good morning Ryan and Adam,\n\n> [UIH2 snipped]\n\nPerhaps I am being naive, but I seem, the B2EP and similar do not need to worry about UIH2.\n\n>From the github discussion:\n\n> \"UIH2\": one input is larger than any output.\n.\nI.e. there exists an input, for all outputs, input > output\nTo avoid this, we should ensure that, for all inputs, there exists an output, input < output.\n\n>From the proposal BIP:\n\n> The receiver then adds one of his own inputs (known as the \"contributed input\") and increase the output that pays himself by the contributed input amount.\n\nSuppose the original transaction avoids the UIH2 (i.e. for all inputs, there exists an output, input < output).\nThe single added input will also avoid the UIH2, since the contributed output value is added to the receiver output, thereby ensuring that contributed input < output.\n\nSuppose the original transaction does not avoid the UIH2.\nThe receiver adding their own contributed input would then have a chance that the addition on the output will now cause the final transaction to avoid the UIH2, since the sum of the receiver amount and the contributed input may now exceed the largest sender input.\nBut since there are more transactions that avoid the UIH2 than not avoid UIH2, the increased probability of now avoiding the UIH2 will lead to a greater anonymity set (especially for the sender, whose coin selection algorithm might have a consistent bias that makes it create transactions that trigger UIH2).\n\nSo it seems to me that the simple solution, i.e. sender uses standard coin selection algorithms already in use today, and receiver does not do any UIH2 checks at all, would be an improvement in both privacy and implementation simplicity.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Adam Gibson",
                "date": "2019-01-28T13:19:09",
                "message_text_only": "ZmnSCPxj, thanks, responses inline.\n\nOn 28. 01. 19 5:14, ZmnSCPxj wrote:\n> Good morning Ryan and Adam,\n> \n>> [UIH2 snipped]\n> \n> Perhaps I am being naive, but I seem, the B2EP and similar do not need to worry about UIH2.\n> \n> From the github discussion:\n> \n>> \"UIH2\": one input is larger than any output.\n> .\n> I.e. there exists an input, for all outputs, input > output\n> To avoid this, we should ensure that, for all inputs, there exists an output, input < output.\n> \n> From the proposal BIP:\n> \n>> The receiver then adds one of his own inputs (known as the \"contributed input\") and increase the output that pays himself by the contributed input amount.\n> \n> Suppose the original transaction avoids the UIH2 (i.e. for all inputs, there exists an output, input < output).\n> The single added input will also avoid the UIH2, since the contributed output value is added to the receiver output, thereby ensuring that contributed input < output.\n> \nYes, I had noted this (see link below).\n\n> Suppose the original transaction does not avoid the UIH2.\n> The receiver adding their own contributed input would then have a chance that the addition on the output will now cause the final transaction to avoid the UIH2, since the sum of the receiver amount and the contributed input may now exceed the largest sender input.\n\n(Just to note (see link below) what I'm sure you're aware of but a\nreader might forget: if the change output that the sender provided is\nlarger than the payment amount, the above won't happen).\n\n> But since there are more transactions that avoid the UIH2 than not avoid UIH2, the increased probability of now avoiding the UIH2 will lead to a greater anonymity set (especially for the sender, whose coin selection algorithm might have a consistent bias that makes it create transactions that trigger UIH2).\n> \n> So it seems to me that the simple solution, i.e. sender uses standard coin selection algorithms already in use today, and receiver does not do any UIH2 checks at all, would be an improvement in both privacy and implementation simplicity.\n> \n> Regards,\n> ZmnSCPxj\n> \n\nReally good point, and I think your argument is reasonable, if not\nwatertight. (Just in case you missed it I tried to outline an algo to\nlet the receiver avoid UIH2 on best effort basis here:\nhttps://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e#gistcomment-2799709).\n\nAlthough I ~ sorta agree, there is a slight counterargument: receiver is\nadding utxos, so in the absence of any transaction inspection you're\ncreating a different distribution than one gets from existing wallet\nselection algos. For example:\nNote that the most likely/desirable/considered use case may be a\nmerchant use case (after all, who receives coins most frequently? in\ntheory, people selling stuff), and it is highly plausible that they\nmight concentrate larger and larger sums into utxo(s) via use of\nPayJoin. Completely mismatched input sizes could be a problem, it's\ndebatable, and it's also debatable whether it can be avoided, but what I\ndon't quite buy is that this issue can just be ignored.\n\nAnd I'm reminded that a related point is made by belcher in the gist\ncomment thread iirc (after we discussed it on IRC): over time a\n\"PayJoin-only\" merchant doing the simplest thing - using a single utxo\nover and over again, will concentrate more and more funds into it, and\ninevitably violating UIH2 in an increasingly dramatic fashion\n(contributing a 100BTC utxo to a 0.1BTC payment etc.). Suggesting it's\nbetter if there's a mix of payjoin/non-payjoin."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-01-30T08:34:46",
                "message_text_only": "Good morning Adam,\n\n> And I'm reminded that a related point is made by belcher in the gist\n> comment thread iirc (after we discussed it on IRC): over time a\n> \"PayJoin-only\" merchant doing the simplest thing - using a single utxo\n> over and over again, will concentrate more and more funds into it, and\n> inevitably violating UIH2 in an increasingly dramatic fashion\n> (contributing a 100BTC utxo to a 0.1BTC payment etc.). Suggesting it's\n> better if there's a mix of payjoin/non-payjoin.\n\nTo be pedantic: as I understand bustapay, it would still not violate UIH2 (unless I misunderstand UIH2).\n\nSuppose the original transaction is: (0.05 payer, 0.07 payer) -> (0.1 payee, 0.02 payer)\n\nThen bustapay with such a PayJoin-only merchant with 100BTC UTXO would give: (100 payee, 0.05 payer, 0.07 payer) -> (100.1 payee, 0.02 payer).\nAs I understand it, this technically does not violate UIH2.\n\nIt would still conceivably be interpreted as a payment of 100.1 BTC, from a payer who happens to have massively lopsided UTXOs being owned, but still does not violate UIH2.\n\nHowever, if that 100.1 UTXO is subsequently used to pay a 100.3 payment, then that is used to pay a 100.7 payment, that strongly suggests such a naive PayJoin-only merchant.\n\nPerhaps a simple heuristic against this would be:\n\n1.  For every UTXO you own, flip a coin.\n    If all of them come up heads, do not payjoin; just broadcast the original transaction.\n2.  Else, randomly select a UTXO (value not care?) and payjoin with that UTXO.\n\nHowever, I have no proper analysis of the blockchain, so --\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "bustapay BIP :: a practical sender/receiver coinjoin protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "rhavar at protonmail.com",
                "James MacWhyte",
                "Adam Gibson"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 105010
        }
    },
    {
        "title": "[bitcoin-dev] [BIP Proposal] Simple Proof-of-Reserves Transactions",
        "thread_messages": [
            {
                "author": "Steven Roose",
                "date": "2019-01-29T22:03:04",
                "message_text_only": "Been working on a proof-of-reserves tool POC for a while, trying to\nformalize the formats so that wallets can integrate more easily.\n\n\n<pre>\n  BIP: ?\n  Layer: Applications\n  Title: Simple Proof-of-Reserves Transactions\n  Author: Steven Roose <steven at stevenroose.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: tbd\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-01-28\n  License: CC0-1.0\n</pre>\n\n\n==Abstract==\n\nThis BIP describes a simple way to construct proof-of-reserves transactions.\nThis proposal formalizes a standard format for constructing such proofs,\neasing\ntheir construction with existing wallet infrastructure and enabling general\nproof-verification software.  It relies on existing standards such as\nregular\nBitcoin transaction serialization/validation and the BIP 174 PSBT format.\nThe proposal also includes the description of a PSBT extension for a better\nuser experience.\n\n==Copyright==\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal license.\n\n==Motivation==\n\n>From the very early days in the history of Bitcoin, there have been\ncompanies\nmanaging bitcoins for their users.  These users give up control over their\ncoins\nin return for a certain service.  Inevitably, there have been many cases of\ncompanies losing their users' bitcoins without timely disclosing such\nevents to\nthe public.  Proofs of Reserves are a way for companies managing large\namounts\nof bitcoins to prove ownership over a given amount of funds.  The regular\nproof\nof control helps to ensure that no significant loss has occurred.\n\nWhile the term proof-of-reserves is not new by any means, the procedure is\nnot\nvery common among high-value custodian companies.  One of the reasons for\nthis\nis that every company that wants to perform a proof-of-reserves has to\nconstruct\nits own way to do so.  Accordingly, their users have to understand the\nconstruction of the proof in order to be able to verify it.  This raises\nthe bar\nof entry both for custodians and for users.\n\n\n===What this BIP is not doing===\n\nThe proof-of-reserve construction described in this document has some known\nshortcomings, mostly with regards to its privacy properties.  While there\nexists\nresearch about improved proof-of-reserves mechanisms that have much better\nprivacy properties<ref>Dagher, Gaby G., Benedikt B\u00fcnz, Joseph Bonneau,\nJeremy\nClark, and Dan Boneh. \"Provisions: Privacy-preserving proofs of solvency for\nBitcoin exchanges.\" (2015).</ref>, this BIP intentionally only formalizes\nthe de-facto existing method.\n\n\n==Specification==\n\nOur specification consists of two parts:\n# the format for the actual proofs\n# a file format used to package a set of proofs and relevant metadata\n\nThe final construction should have the following properties:\n* flexible proof construction to support complex wallet infrastructures\n* easy integration with existing wallet solutions (both hardware and\nsoftware wallets)\n* support for verification via a standard procedure, regardless of\npublisher of the proof\n* proof prevents reuse of proofs by other parties by commiting to a message\n* allow validating that the issuer had the funds under his control at a\ncertain block, regardless of what happened after that block\n\n===Proof Format===\n\nTo allow for maximal compatibility with existing systems, proofs are\nformatted as regular Bitcoin\ntransactions.  However, one small adaptation to the transaction is made\nthat has two functions:\n# make the transaction unspendable to avoid putting funds at risk\n# link the proof to the issuer of the proof to prevent copying proofs from\nother custodians\n\nThe resulting construction is a Bitcoin transaction with the following\ncharacteristics:\n\n* The first input (the \"commitment input\")\n** MUST have the txid part of the previous outpoint set to the SHA-256 hash\nof the commitment message prefixed with \"Proof-of-Reserves: \"<ref>If the\nmessage is \"Some Message\", the txid part should be\n<tt>SHA-256(\"Proof-of-Reserves: Some Message\")</tt> with the string encoded\nas UTF-8.</ref> and index 0.\n* The remaining inputs\n** MUST have signatures that commit to the commitment input (e.g. using\n<tt>SIGHASH_ALL</tt>).\n* The transaction MUST have a single output that is the exact sum of all\nthe inputs, assuming the commitment input to have 0 value; this means the\ntransaction has no miner fee.\n\nThe existence of the first input (which is just a commitment hash) ensures\nthat this transaction is invalid and can never be confirmed.\n\n\n===Proof File Format===\n\nIn theory, the first part of the specification would be sufficient as a\nminimum\nviable standard.  However, there are a number of motivations to extend the\nstandard with an extra layer of metadata:\n\n# constructing and combining multiple proofs\n#:Having thousands of UTXOs spread across different offline and online\nwallets could make it difficult to construct a single proof transaction\nwith all UTXOs.  Allowing multiple proof transactions with the same\ncommitment message and block number gives extra flexibility to custodians\nwith complex wallet infrastructure without making the combined proof less\nsecure.\n# metadata for verification\n#:Not all systems that will be used for verification have access to a full\nindex of all transactions.  However, proofs should be easily verifiable\neven after some of the UTXOs used in the proof are no longer unspent.\nMetadata present in the proof allows for relatively efficient verification\nof proofs even if no transaction index is available.\n# potential future improvements\n#:The extensible metadata format allows for amending the standard in the\nfuture.  One potential improvement would be having UTXO set commitments.\nThese would allow the proofs-of-reserves to come with accompanying\nproofs-of-inclusion of all used UTXOs in the UTXO set at the block of proof\nconstsruction (making validation even more efficient).\n\nThe proposed proof-file format provides a standard way of combining multiple\nproofs and associated metadata.  The specification of the format is in the\nProtocol Buffers<ref>https://github.com/protocolbuffers/protobuf/</ref>\nformat.\n\n<pre>\nsyntax = \"proto3\";\nimport \"google/protobuf/any.proto\";\n\nmessage OutputMeta {\n// Identify the outpoint.\nbytes txid = 1;\nuint32 vout = 2;\n\n// The block hash of the block where this output was created.\nbytes block_hash = 3;\n}\n\nmessage FinalProof {\n// The proof transaction.  Should be able to be parsed like a regular\n// Bitcoin transaction.\nbytes proof_tx = 1;\n\n// The metadata of the ouputs used in the proof transaction.\nrepeated OutputMeta output_metadata = 2;\n}\n\nmessage ProofOfReserves {\n// A version number for this format to enable extending it with\n// additional fields.\nuint32 version = 1;\n\n// The network magic for the network in which the proofs are valid.\n// 0xD9B4BEF9 for mainnet, 0x0709110B for testnet\n//TODO consider BIP44 coin type ids instead:\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nuint32 network_magic = 2;\n\n// The commitment message for this proof-of-reserves.\n// This message is global for all the proofs.\nstring message = 3;\n\n// The block at which this proof is supposed to be validated.\n// Verification should take into account unspentness of outputs at this\n// block height.\nbytes block_hash = 4;\n\n// The set of final proof transactions with their output metadata.\nrepeated FinalProof final_proofs = 5;\n\n// Reserved field that can potentially be used by proof-construction tools.\n// It can be ignored for verification.\nrepeated google.protobuf.Any pending_proofs = 6;\n}\n</pre>\n\nThe last field, <tt>pending_proofs</tt>, leaves open some space in the same\nfile that can be used by proof-construction tools.  This allows them to\nconstruct different proofs incrementally without having to switch between\nfile\nformats.\n\n\n===PSBT (BIP 174) extension===\n\nThe \"commitment input\" detailed in the proof format section does not spend\nan\nexisting UTXO and thus shouldn't be signed (empty <tt>scriptSig</tt> and\nwitness).  This can cause some problems when signing this type of\ntransactions.\nFor example, hardware wallets often require the signer to provide\ninformation\nabout all inputs of transactions they are signing, such as the previous\noutput\nor previous transaction; this data obviously doesn't exist for the\ncommitment\ninputs.\n\nFor most existing devices, it's possible to circumvent these requirements by\nproviding dummy data or by instructing the device to ignore this specific\ninput.  However, there is still a UX problem.  Because the hardware wallet\ndevice doesn't recognize the transaction as a proof-of-reserves transaction\nit\nwill think it is signing a regular transaction that is spending all the\nmoney\nin the UTXOs.  Most devices will ask for confirmation with a message along\nthe\nlines of \"Are you sure you want to send XXX BTC to address [...]?\".  This is\nnot the best user experience.\n\nAn addition to the BIP 174 PSBT format could help signing devices to\nrecognize proof-of-reserve transactions.\nThe following field is added to the BIP 174 <tt>INPUT</tt> map:\n\n* Type: Proof-of-reserves commitment <tt>PSBT_IN_POR_COMMITMENT = 0x09</tt>\n** Key: None. The key must only contain the 1 byte type.\n*** <tt>{0x09}</tt>\n** Value: The UTF-8 encoded commitment message string for the\nproof-of-reserves.\n*** <tt>{porCommitment}</tt>\n\nWallets processing an input that has this field set\n* MUST make sure the txid of the previous outpoint is set to the SHA-256\nhash of the prefixed commitment message string, as detailed above;\n* MUST assume the input value to be 0 (without requiring the previous\noutput or transaction to be provided);\n* SHOULD display the commitment message to ask the user for confirmation\nbefore signing any inputs;\n* SHOULD only provide signatures with a signature hash that commits to this\ninput;\n* SHOULD accept an empty <tt>scriptSig</tt> for this input (as if the\n<tt>scriptPubKey</tt> was <tt>OP_TRUE</tt>).\n\n\n==Implementations==\n\nA proof-of-concept implementation of the PSBT extension in the\n[https://github.com/rust-bitcoin/rust-bitcoin rust-bitcoin] project can be\nfound in the <tt>psbt-por</tt> branch here:\nhttps://github.com/stevenroose/rust-bitcoin/tree/psbt-por\n\nA work-in-progress implementation of a tool that produces and verifies\nproofs\nin the described format can be found here:\nhttps://github.com/stevenroose/reserves\n\n\n== Footnotes ==\n\n<references />\n\nPR: https://github.com/bitcoin/bips/pull/756\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190129/e217f099/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Simple Proof-of-Reserves Transactions",
            "categories": [
                "bitcoin-dev",
                "BIP Proposal"
            ],
            "authors": [
                "Steven Roose"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 10549
        }
    },
    {
        "title": "[bitcoin-dev] Contribution",
        "thread_messages": [
            {
                "author": "Antoniy Shumanov",
                "date": "2019-01-30T14:24:21",
                "message_text_only": "Hi, bitcoin devs. I'm working at lbry.io and we stay closely to your core,\ni want to discuss what you think about a contribution like:\nbase_blob and/or base_uint to be derived from std::array to be enabled move\nsemantics, as well on uint160, uint256, COutPoint.\nAnother approach that bother me is acquiring / releasing recursive mutex in\na loop, snippet from minig.cpp\nwhile (nHeight < nHeightEnd && !ShutdownRequested())\n{\n    std::unique_ptr<CBlockTemplate>\n\npblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n    CBlock *pblock = &pblocktemplate->block;\n    {\n        LOCK(cs_main); // <--------- acquiring\n        IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n    } // <-------- release\n    std::shared_ptr<const CBlock> shared_pblock =\n    std::make_shared<const CBlock>(*pblock);\n    if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr)) // <----\nacquiring / release again inside\n}\nDoing it in a loop makes things to be slow down even more, what's idea\nbehind?\nAlso consider using of atomic global variable rather than acquiring mutex\nagain, no?\nDid you interested in contribution in these approaches?\n\nRegards\nAntoniy Shumanov\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190130/ed88efe2/attachment-0001.html>"
            },
            {
                "author": "Marco Falke",
                "date": "2019-01-30T16:29:05",
                "message_text_only": "This mailing list is for the development of the Bitcoin protocol (see\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev).\nCode changes to Bitcoin Core can be discussed on\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-core-dev or\npreferably be submitted to https://github.com/bitcoin/bitcoin/\ndirectly.\n\n-- Marco"
            }
        ],
        "thread_summary": {
            "title": "Contribution",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoniy Shumanov",
                "Marco Falke"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1718
        }
    },
    {
        "title": "[bitcoin-dev] Safer NOINPUT with output tagging",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2019-01-31T06:04:05",
                "message_text_only": "On Mon, Dec 24, 2018 at 11:47:38AM +0000, ZmnSCPxj via bitcoin-dev wrote:\n> A boutique protocol would reduce the number of existing onchain wallets that could be integrated in such UI.\n\nSeems like PSBT would be a sufficient protocol:\n\n 0) lightning node generates a PSBT for a new channel,\n    with no inputs and a single output of the 2-of-2 address\n\n 1) wallet funds the PSBT but doesn't sign it, adding a change address\n    if necessary, and could combine with other tx's bustapay style\n\n 2) lightning determines txid from PSBT, and creates update/settlement\n    tx's for funding tx so funds can be recovered\n\n 3) wallet signs and publishes the PSBT\n\n 4) lightning sees tx on chain and channel is open\n\nThat's a bit more convoluted than \"(0) lightning generates an address and\nvalue, and creates NOINPUT update/settlement tx's for that address/value;\n(1) wallet funds address to exactly that value; (2) lightning monitors\nblockchain for payment to that address\" of course.\n\nBut it avoids letting users get into the habit of passing NOINPUT\naddresses around, or the risk of a user typo'ing the value and losing\nmoney immediately, and it has the benefit that the wallet can tweak the\nvalue if (eg) that avoids a change address or enhances privacy (iirc,\nc-lightning tweaks payment values for that reason). If the channel's\nclosed cooperatively, it also avoids ever needing to publish a NOINPUT\nsig (or NOINPUT tagged output).\n\nDoes that seem a fair trade off?\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Safer NOINPUT with output tagging",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1472
        }
    },
    {
        "title": "[bitcoin-dev] Predicate Tree in ZkVM: a variant of Taproot/G'root",
        "thread_messages": [
            {
                "author": "Oleg Andreev",
                "date": "2019-01-31T23:44:43",
                "message_text_only": "Hi,\n\nWe've been working for a thing called ZkVM [1] for the last few weeks. It is a \"blockchain virtual machine\" in the spirit of Bitcoin, with multi-asset transfers and zero-knowledge programmable constraints.\n\nAs a part of its design, there is a \"Predicate Tree\" \u2014 a variant of Taproot by Greg Maxwell [2] and G'root by Anthony Towns [3] that I would like to present here. Hopefully it is useful to the discussion, and I would appreciate any feedback.\n\n## Background\n\nIn ZkVM there are linear types Contract and Value (in addition to plain data types), where Contract also implements \"object capabilities\" pattern: Contract \"locks\" a collection of data and Values under a \"predicate\" which is represented by a single group element (\"point\" in ECC terms). The predicate can be \"satisfied\" in a number of allowed ways which makes the contract unlock its contents, e.g. release the stored Value which can then be locked in a new unspent output.\n\n## Predicate Tree\n\nPredicate is a point that represents one of three things, which allows composing conditions in an arbitrary tree:\n\n1. Public key\n2. Program\n3. Disjunction of two other predicates\n\nPublic key allows representing N-of-N signing conditions (and M-of-N with proper threshold key setup, although small combinations like 2-of-3 can be non-interactively represented as a tree of 3 combinations of 2-of-2 conditions):\n\n   P = x*B  (x is a secret, B is a primary generator point)\n\nProgram commitment is a P2SH-like commitment:\n\n   P = hash2scalar(program)*B2   (B2 is orthogonal to B, so one cannot sign for P, but must reveal the program)\n\nDisjunction (asymmetric to allow happy-path signing with the left predicate):\n\n   P = L + hash2scalar(L,R)*B\n\n\n## VM instructions\n\nTo use the predicate trees, ZkVM provides 4 instructions:\n\n1. `signtx` to verify the signature over the transaction ID treating the predicate as a pubkey.\n2. `call` to reveal the committed program and execute it.\n3. `left`/`right` to replace the contract's predicate with one of the sub-predicates in a disjunction.\n4. `delegate` to check a signature over a program and execute that program (pay-to-signed-program pattern).\n\nMore details are in the ZkVM spec: https://github.com/interstellar/zkvm/blob/main/spec/ZkVM.md#signtx\n\n`call` and `delegate` differ in that `call` reveals and runs a pre-arranged program (like in P2SH), while `delegate` allows choosing the program later which can be signed with a pre-arranged public key. `delegate` also enables use cases for SIGHASH: if a specific output or outputs or constraints must be signed, they can be represented by such program snippet. Likewise, a \"revocation token\" for the payment channel (LN) can be implemented with `delegate` instruction.\n\n\n## Performance\n\nFor performance, the following rules are built into ZkVM:\n\n1. All point operations are deferred. Signature checks, disjunction proofs, program commitment proofs - are not executed right away, but deferred and verified in a batch after the VM execution is complete. This enables significant savings, especially since half or third of the terms reuse static points B and B2.\n2. `signtx` does not accept individual signatures, but uses a single aggregated signature for the whole transaction. All the pubkeys are remembered in a separate set and combined via MuSig-style [4] protocol to check the single 64-byte signature over txid in the end of the VM execution. In other words, signature aggregation is not optional for `signtx` (signatures over txid). Note: the `delegate` instruction permits arbitrary programs, so it uses one signature per program.\n\n\n## What is different from Taproot/G'root\n\n(1) No pure hash-based MAST: each time one peels off a layer of a tree, there's an ECC check which is more expensive than pure-hash merkle path check, but makes the design simpler and all ECC ops are batched alongside bulletproofs R1CS verification statement, making the performance difference unimportant.\n\n(2) There is no designated blinding factor or a pubkey with the program commitment like in G'root. This is not something i'm particularly sure about, but will lay out the current rationale:\n1. The happy-path one-time-key normally acts as a sufficient blinding factor for the program.\n2. If the program needs a blinding factor, it can be embedded as a `<garbage> drop`.\n3. The combo of \"sign + programmatic constraints\" is done by having instructions inside the program that wrap the value(s) in a transient contract with the required pubkey and leaving it on the stack.\n\n\n## References\n\n[1] https://github.com/interstellar/zkvm\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html\n[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016249.html\n[4] https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures/"
            }
        ],
        "thread_summary": {
            "title": "Predicate Tree in ZkVM: a variant of Taproot/G'root",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Oleg Andreev"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4821
        }
    }
]