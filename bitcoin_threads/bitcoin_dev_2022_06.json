[
    {
        "title": "[bitcoin-dev] signature abstraction",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2022-06-03T14:31:19",
                "message_text_only": "was thinking it might be possible to create a protocol for signatures where\nsome bounded elliptic curve parameters are in the script, allowing the\nefficient verification of a broad range of elliptic curves schnorr\nsignatures... rather than a fixed curve\n\nhas anyone proposed this sort of thing before?\n\nseems like it could allow higher bitness, broad hsm compatibility, and a\n\"decentralization and competitiveness\" of security parameters for different\nenvironments\n\nwould be useful to me, but not sure how many people care about this\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220603/a0d53b4f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "signature abstraction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 716
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin covenants are inevitable",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-06-03T18:39:34",
                "message_text_only": "Note: This email is an opinion and not an attack on bitcoin\n\nCovenants on bitcoin will eventually be implemented with a soft fork. CTV is the easiest and best possible way OP_TX looks good as well. Apart from the technical merits, covenants will improve a few other things:\n\n- Developers can build interesting projects with real demand in market.\n- Students learn Sapio and not just solidity.\n- Better tooling could be available for application developers.\n- Maybe we see bitcoin developer hackathons in different countries.\n- Demand for block space might increase, it wont be just exchanges and coinjoin.\n- Funding of bitcoin developers and projects might improve. Wont need to convince a few people for grants.\n\n**Why covenants are not contentious?**\n\nSome people may write paragraphs about CTV being contentious, spread misinformation and do all types of drama, politics etc. on social media but there are zero technical NACKs for CTV. We have discussed other covenant proposals in detail on mailing list and IRC meetings with an open minded approach.\n\nAll the developers that participated in the discussion are either okay with CTV or OP_TX or covenants in general.\n\n**How and when should covenants be implemented in Bitcoin?**\n\nI don't think we should wait for years anticipating a proposal that everyone will agree on or argue for years to pretend changes are hard in Bitcoin. We should improve the review process for soft fork BIPs and share honest opinions with agreement, disagreement on technical merits.\n\nI prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything else being used if that improves Bitcoin. Covenants implemented in Bitcoin before the next cycle would provide opportunity for developers to build interesting things during the bear market. Ossification supporters also believe there is some window that will close soon, maybe doing changes considering each case individually will be a better approach. CTV is not a rushed soft fork, less people followed the research and it was not mentioned on social media repeatedly by the respected developers like other soft forks.\n\n/dev/fd0\n\n\nSent with Proton Mail secure email."
            },
            {
                "author": "micaroni at gmail.com",
                "date": "2022-06-04T00:29:44",
                "message_text_only": "Totally agree.\nI couldn't agree more.\n\nOn Fri, Jun 3, 2022 at 3:44 PM alicexbt via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Note: This email is an opinion and not an attack on bitcoin\n>\n> Covenants on bitcoin will eventually be implemented with a soft fork. CTV\n> is the easiest and best possible way OP_TX looks good as well. Apart from\n> the technical merits, covenants will improve a few other things:\n>\n> - Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to\n> convince a few people for grants.\n>\n> **Why covenants are not contentious?**\n>\n> Some people may write paragraphs about CTV being contentious, spread\n> misinformation and do all types of drama, politics etc. on social media but\n> there are zero technical NACKs for CTV. We have discussed other covenant\n> proposals in detail on mailing list and IRC meetings with an open minded\n> approach.\n>\n> All the developers that participated in the discussion are either okay\n> with CTV or OP_TX or covenants in general.\n>\n> **How and when should covenants be implemented in Bitcoin?**\n>\n> I don't think we should wait for years anticipating a proposal that\n> everyone will agree on or argue for years to pretend changes are hard in\n> Bitcoin. We should improve the review process for soft fork BIPs and share\n> honest opinions with agreement, disagreement on technical merits.\n>\n> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything\n> else being used if that improves Bitcoin. Covenants implemented in Bitcoin\n> before the next cycle would provide opportunity for developers to build\n> interesting things during the bear market. Ossification supporters also\n> believe there is some window that will close soon, maybe doing changes\n> considering each case individually will be a better approach. CTV is not a\n> rushed soft fork, less people followed the research and it was not\n> mentioned on social media repeatedly by the respected developers like other\n> soft forks.\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail secure email.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220603/7ef05782/attachment.html>"
            },
            {
                "author": "John Carvalho",
                "date": "2022-06-04T12:27:53",
                "message_text_only": "Core development is not a hackathon project.\n\nNone of the quoted following items are features or responsibilities of the\nBitcoin software, nor Core developers.\n\nQuoted:\n\"- Developers can build interesting projects with real demand in market.\n- Students learn Sapio and not just solidity.\n- Better tooling could be available for application developers.\n- Maybe we see bitcoin developer hackathons in different countries.\n- Demand for block space might increase, it wont be just exchanges and\ncoinjoin.\n- Funding of bitcoin developers and projects might improve. Wont need to\nconvince a few people for grants.\"\n\nWhether you are a child or an attacker, none of us should care, but CTV,\nnor any change to Bitcoin software, will never be justifiable simply\nbecause you and some of your friends think it is totally cool and might\nmake more people like you or give your friends funding.\n\nPlease stop making noise about CTV, this is not a place for spamming.\n\n--\nJohn Carvalho\n\n\n\nOn Sat, Jun 4, 2022 at 1:00 PM <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n>\n> Date: Fri, 03 Jun 2022 18:39:34 +0000\n> From: alicexbt <alicexbt at protonmail.com>\n> To: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: [bitcoin-dev] Bitcoin covenants are inevitable\n> Message-ID:\n>\n> <QOWIpROGDv5HHP2GsDiSOsTJ9TVZhFeSP3C03_e2Z3XtOKC_4N5GJtxbdlxuhErvhLZXo1Rn_7SWAQ9XRPwHFuYyArZryTVENefDZuGTAYA=@\n> protonmail.com>\n>\n> Content-Type: text/plain; charset=utf-8\n>\n> Note: This email is an opinion and not an attack on bitcoin\n>\n> Covenants on bitcoin will eventually be implemented with a soft fork. CTV\n> is the easiest and best possible way OP_TX looks good as well. Apart from\n> the technical merits, covenants will improve a few other things:\n>\n> - Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to\n> convince a few people for grants.\n>\n> **Why covenants are not contentious?**\n>\n> Some people may write paragraphs about CTV being contentious, spread\n> misinformation and do all types of drama, politics etc. on social media but\n> there are zero technical NACKs for CTV. We have discussed other covenant\n> proposals in detail on mailing list and IRC meetings with an open minded\n> approach.\n>\n> All the developers that participated in the discussion are either okay\n> with CTV or OP_TX or covenants in general.\n>\n> **How and when should covenants be implemented in Bitcoin?**\n>\n> I don't think we should wait for years anticipating a proposal that\n> everyone will agree on or argue for years to pretend changes are hard in\n> Bitcoin. We should improve the review process for soft fork BIPs and share\n> honest opinions with agreement, disagreement on technical merits.\n>\n> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything\n> else being used if that improves Bitcoin. Covenants implemented in Bitcoin\n> before the next cycle would provide opportunity for developers to build\n> interesting things during the bear market. Ossification supporters also\n> believe there is some window that will close soon, maybe doing changes\n> considering each case individually will be a better approach. CTV is not a\n> rushed soft fork, less people followed the research and it was not\n> mentioned on social media repeatedly by the respected developers like other\n> soft forks.\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail secure email.\n>\n>\n> ------------------------------\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220604/997f931f/attachment.html>"
            },
            {
                "author": "Keagan McClelland",
                "date": "2022-06-04T13:48:40",
                "message_text_only": "> will never be justifiable simply because you and some of your friends\nthink it is totally cool and might make more people like you or give your\nfriends funding.\n\n100%\n\nBut while the OP may have given less than ideal reasons for things like\ncovenants, it does not broadly characterize the reasons for adding them to\nthe Bitcoin protocol. The reasons to do so are:\n\n- better self custody solutions that don\u2019t rely on the trust of named third\nparties\n- significantly more tractable solutions for things like coin pools\n- significantly more efficient DLCs\n\nThese are not \u201chackathon project\u201d reasons and are the main reasons people\nadvocate for covenants.\n\n> None of the quoted following items are features or responsibilities of\nthe Bitcoin software, nor Core developers.\n\nSince you seem to have the stone tablets onto which our responsibilities\nare etched, would you care to enumerate them?\n\n> Whether you are a child or an attacker, none of us should care,\n\nAre you incapable of actually treating people with respect or do you think\nthat bullying people on this mailing list is the most effective way to get\nwhat you want? If it\u2019s the latter I may suggest you go back to Twitter\nwhere that works and maybe just leave those comments out of the mailing\nlist if you actually want to convince people of your point of view.\n\nKeagan\n\nOn Sat, Jun 4, 2022 at 7:37 AM John Carvalho via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Core development is not a hackathon project.\n>\n> None of the quoted following items are features or responsibilities of the\n> Bitcoin software, nor Core developers.\n>\n> Quoted:\n> \"- Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to\n> convince a few people for grants.\"\n>\n> Whether you are a child or an attacker, none of us should care, but CTV,\n> nor any change to Bitcoin software, will never be justifiable simply\n> because you and some of your friends think it is totally cool and might\n> make more people like you or give your friends funding.\n>\n> Please stop making noise about CTV, this is not a place for spamming.\n>\n> --\n> John Carvalho\n>\n>\n>\n> On Sat, Jun 4, 2022 at 1:00 PM <\n> bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n>\n>>\n>> Date: Fri, 03 Jun 2022 18:39:34 +0000\n>> From: alicexbt <alicexbt at protonmail.com>\n>> To: Bitcoin Protocol Discussion\n>>         <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: [bitcoin-dev] Bitcoin covenants are inevitable\n>> Message-ID:\n>>\n>> <QOWIpROGDv5HHP2GsDiSOsTJ9TVZhFeSP3C03_e2Z3XtOKC_4N5GJtxbdlxuhErvhLZXo1Rn_7SWAQ9XRPwHFuYyArZryTVENefDZuGTAYA=@\n>> protonmail.com>\n>>\n>> Content-Type: text/plain; charset=utf-8\n>>\n>> Note: This email is an opinion and not an attack on bitcoin\n>>\n>> Covenants on bitcoin will eventually be implemented with a soft fork. CTV\n>> is the easiest and best possible way OP_TX looks good as well. Apart from\n>> the technical merits, covenants will improve a few other things:\n>>\n>> - Developers can build interesting projects with real demand in market.\n>> - Students learn Sapio and not just solidity.\n>> - Better tooling could be available for application developers.\n>> - Maybe we see bitcoin developer hackathons in different countries.\n>> - Demand for block space might increase, it wont be just exchanges and\n>> coinjoin.\n>> - Funding of bitcoin developers and projects might improve. Wont need to\n>> convince a few people for grants.\n>>\n>> **Why covenants are not contentious?**\n>>\n>> Some people may write paragraphs about CTV being contentious, spread\n>> misinformation and do all types of drama, politics etc. on social media but\n>> there are zero technical NACKs for CTV. We have discussed other covenant\n>> proposals in detail on mailing list and IRC meetings with an open minded\n>> approach.\n>>\n>> All the developers that participated in the discussion are either okay\n>> with CTV or OP_TX or covenants in general.\n>>\n>> **How and when should covenants be implemented in Bitcoin?**\n>>\n>> I don't think we should wait for years anticipating a proposal that\n>> everyone will agree on or argue for years to pretend changes are hard in\n>> Bitcoin. We should improve the review process for soft fork BIPs and share\n>> honest opinions with agreement, disagreement on technical merits.\n>>\n>> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything\n>> else being used if that improves Bitcoin. Covenants implemented in Bitcoin\n>> before the next cycle would provide opportunity for developers to build\n>> interesting things during the bear market. Ossification supporters also\n>> believe there is some window that will close soon, maybe doing changes\n>> considering each case individually will be a better approach. CTV is not a\n>> rushed soft fork, less people followed the research and it was not\n>> mentioned on social media repeatedly by the respected developers like other\n>> soft forks.\n>>\n>> /dev/fd0\n>>\n>>\n>> Sent with Proton Mail secure email.\n>>\n>>\n>> ------------------------------\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220604/a16a73a5/attachment-0001.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-04T16:12:54",
                "message_text_only": "Hi John,\n\n> Core development is not a hackathon project.\n>\n> None of the quoted following items are features or responsibilities of the Bitcoin software, nor Core developers\n\nCore development was never listed as a hackathon project. Although I did not share responsibilities, they will improve bitcoin development. Bitcoin isn't only about \"core developers\" and I contribute to that repository.\n\n> Whether you are a child or an attacker, none of us should care, but CTV, nor any change to Bitcoin software, will never be justifiable simply because you and some of your friends think it is totally cool and might make more people like you or give your friends funding.\n\nThese are not my friends and I don't know any of them in real life:\n\nhttps://utxos.org/signals/\n\nAlso the developers who are competent enough to understand code and soft forks that participated in CTV meetings are not my friends. Funding is a real issue for bitcoin developers, you would know if were a developer and these opportunities won't be available for me and my friends but everyone.\n\n> Please stop making noise about CTV, this is not a place for spamming.\n\nLet me share one example of spamming and noise:\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020409.html\n\nI am aware of the things that you post on twitter and your thoughts about developers, author of BIP 119 and the way you would propose changes although not interested to debate anything related to bitcoin development with you as its a waste of time:\n\nhttps://nitter.net/BitcoinErrorLog/status/1407312037408038919\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Saturday, June 4th, 2022 at 5:57 PM, John Carvalho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Core development is not a hackathon project.\n>\n> None of the quoted following items are features or responsibilities of the Bitcoin software, nor Core developers.\n>\n> Quoted:\n> \"- Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to convince a few people for grants.\"\n>\n> Whether you are a child or an attacker, none of us should care, but CTV, nor any change to Bitcoin software, will never be justifiable simply because you and some of your friends think it is totally cool and might make more people like you or give your friends funding.\n>\n> Please stop making noise about CTV, this is not a place for spamming.\n>\n> --\n>\n> John Carvalho\n>\n> On Sat, Jun 4, 2022 at 1:00 PM <bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n>\n>> Date: Fri, 03 Jun 2022 18:39:34 +0000\n>> From: alicexbt <alicexbt at protonmail.com>\n>> To: Bitcoin Protocol Discussion\n>> <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: [bitcoin-dev] Bitcoin covenants are inevitable\n>> Message-ID:\n>> <QOWIpROGDv5HHP2GsDiSOsTJ9TVZhFeSP3C03_e2Z3XtOKC_4N5GJtxbdlxuhErvhLZXo1Rn_7SWAQ9XRPwHFuYyArZryTVENefDZuGTAYA=@protonmail.com>\n>>\n>> Content-Type: text/plain; charset=utf-8\n>>\n>> Note: This email is an opinion and not an attack on bitcoin\n>>\n>> Covenants on bitcoin will eventually be implemented with a soft fork. CTV is the easiest and best possible way OP_TX looks good as well. Apart from the technical merits, covenants will improve a few other things:\n>>\n>> - Developers can build interesting projects with real demand in market.\n>> - Students learn Sapio and not just solidity.\n>> - Better tooling could be available for application developers.\n>> - Maybe we see bitcoin developer hackathons in different countries.\n>> - Demand for block space might increase, it wont be just exchanges and coinjoin.\n>> - Funding of bitcoin developers and projects might improve. Wont need to convince a few people for grants.\n>>\n>> **Why covenants are not contentious?**\n>>\n>> Some people may write paragraphs about CTV being contentious, spread misinformation and do all types of drama, politics etc. on social media but there are zero technical NACKs for CTV. We have discussed other covenant proposals in detail on mailing list and IRC meetings with an open minded approach.\n>>\n>> All the developers that participated in the discussion are either okay with CTV or OP_TX or covenants in general.\n>>\n>> **How and when should covenants be implemented in Bitcoin?**\n>>\n>> I don't think we should wait for years anticipating a proposal that everyone will agree on or argue for years to pretend changes are hard in Bitcoin. We should improve the review process for soft fork BIPs and share honest opinions with agreement, disagreement on technical merits.\n>>\n>> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything else being used if that improves Bitcoin. Covenants implemented in Bitcoin before the next cycle would provide opportunity for developers to build interesting things during the bear market. Ossification supporters also believe there is some window that will close soon, maybe doing changes considering each case individually will be a better approach. CTV is not a rushed soft fork, less people followed the research and it was not mentioned on social media repeatedly by the respected developers like other soft forks.\n>>\n>> /dev/fd0\n>>\n>> Sent with Proton Mail secure email.\n>>\n>> ------------------------------\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220604/676aca8b/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-06-06T13:02:18",
                "message_text_only": "Maintaining the security of the protocol is squarely the responsibility of\nthe Bitcoin software and the core developers\n\nContinued demand for block space is critical for Bitcoin's security.\n\nTherefore it *is* the responsibility of Bitcoin software and core\ndevelopers to maintain a continued demand for block space - which underpins\nthe game-theoretical security of the protocol.\n\nWhile I'm personally confident that demand is still high, enough to\nreasonably secure the protocol, I do think that this is a matter not best\nleft up to stern opinions.   Whether covenant tech is essential for that\nsecurity or not is a matter for simulations and proofs, not hype and\nspeculation - on either side of the issue.\n\n\nOn Sat, Jun 4, 2022 at 8:36 AM John Carvalho via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Core development is not a hackathon project.\n>\n> None of the quoted following items are features or responsibilities of the\n> Bitcoin software, nor Core developers.\n>\n> Quoted:\n> \"- Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to\n> convince a few people for grants.\"\n>\n> Whether you are a child or an attacker, none of us should care, but CTV,\n> nor any change to Bitcoin software, will never be justifiable simply\n> because you and some of your friends think it is totally cool and might\n> make more people like you or give your friends funding.\n>\n> Please stop making noise about CTV, this is not a place for spamming.\n>\n> --\n> John Carvalho\n>\n>\n>\n> On Sat, Jun 4, 2022 at 1:00 PM <\n> bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n>\n>>\n>> Date: Fri, 03 Jun 2022 18:39:34 +0000\n>> From: alicexbt <alicexbt at protonmail.com>\n>> To: Bitcoin Protocol Discussion\n>>         <bitcoin-dev at lists.linuxfoundation.org>\n>> Subject: [bitcoin-dev] Bitcoin covenants are inevitable\n>> Message-ID:\n>>\n>> <QOWIpROGDv5HHP2GsDiSOsTJ9TVZhFeSP3C03_e2Z3XtOKC_4N5GJtxbdlxuhErvhLZXo1Rn_7SWAQ9XRPwHFuYyArZryTVENefDZuGTAYA=@\n>> protonmail.com>\n>>\n>> Content-Type: text/plain; charset=utf-8\n>>\n>> Note: This email is an opinion and not an attack on bitcoin\n>>\n>> Covenants on bitcoin will eventually be implemented with a soft fork. CTV\n>> is the easiest and best possible way OP_TX looks good as well. Apart from\n>> the technical merits, covenants will improve a few other things:\n>>\n>> - Developers can build interesting projects with real demand in market.\n>> - Students learn Sapio and not just solidity.\n>> - Better tooling could be available for application developers.\n>> - Maybe we see bitcoin developer hackathons in different countries.\n>> - Demand for block space might increase, it wont be just exchanges and\n>> coinjoin.\n>> - Funding of bitcoin developers and projects might improve. Wont need to\n>> convince a few people for grants.\n>>\n>> **Why covenants are not contentious?**\n>>\n>> Some people may write paragraphs about CTV being contentious, spread\n>> misinformation and do all types of drama, politics etc. on social media but\n>> there are zero technical NACKs for CTV. We have discussed other covenant\n>> proposals in detail on mailing list and IRC meetings with an open minded\n>> approach.\n>>\n>> All the developers that participated in the discussion are either okay\n>> with CTV or OP_TX or covenants in general.\n>>\n>> **How and when should covenants be implemented in Bitcoin?**\n>>\n>> I don't think we should wait for years anticipating a proposal that\n>> everyone will agree on or argue for years to pretend changes are hard in\n>> Bitcoin. We should improve the review process for soft fork BIPs and share\n>> honest opinions with agreement, disagreement on technical merits.\n>>\n>> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything\n>> else being used if that improves Bitcoin. Covenants implemented in Bitcoin\n>> before the next cycle would provide opportunity for developers to build\n>> interesting things during the bear market. Ossification supporters also\n>> believe there is some window that will close soon, maybe doing changes\n>> considering each case individually will be a better approach. CTV is not a\n>> rushed soft fork, less people followed the research and it was not\n>> mentioned on social media repeatedly by the respected developers like other\n>> soft forks.\n>>\n>> /dev/fd0\n>>\n>>\n>> Sent with Proton Mail secure email.\n>>\n>>\n>> ------------------------------\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220606/cea5b415/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-12T03:36:45",
                "message_text_only": "On Mon, Jun 06, 2022 at 09:02:18AM -0400, Erik Aronesty via bitcoin-dev wrote:\n> Maintaining the security of the protocol is squarely the responsibility of\n> the Bitcoin software and the core developers\n> \n> Continued demand for block space is critical for Bitcoin's security.\n\nOnly because the block reward goes away. If it was made to continue\nindefinitely - most likely with an inflation hard fork - demand for block space\nwould not be critical to Bitcoin's security.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220611/af80f0d7/attachment.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-06-12T13:02:38",
                "message_text_only": "Yes\n\n\nAlthough I'm guessing most would agree that would be worse.\n\nI certainly would choose to add fee generating features over inflation\n\nProbably most other people would too\n\n\n\nOn Sat, Jun 11, 2022, 11:36 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Jun 06, 2022 at 09:02:18AM -0400, Erik Aronesty via bitcoin-dev\n> wrote:\n> > Maintaining the security of the protocol is squarely the responsibility\n> of\n> > the Bitcoin software and the core developers\n> >\n> > Continued demand for block space is critical for Bitcoin's security.\n>\n> Only because the block reward goes away. If it was made to continue\n> indefinitely - most likely with an inflation hard fork - demand for block\n> space\n> would not be critical to Bitcoin's security.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220612/b66df85b/attachment.html>"
            },
            {
                "author": "Corey Haddad",
                "date": "2022-06-12T16:35:06",
                "message_text_only": "Even if demand for block space is currently not needed to pay for security\ndue to the block rewards, demand for BTC itself is needed for those rewards\nto be worth anything.\nBitcoin, as a proof of work system, is only secure at scale. Therefore\ncontinued growth and user adoption are both critical for Bitcoin's\nsecurity. Perhaps the question then becomes\nwho feels that Bitcoin is inevitable, and who feels it is possible that it\ncan damaged or destroyed?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220612/cd752803/attachment.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-12T19:16:49",
                "message_text_only": "Hi Peter,\n\n> Only because the block reward goes away. If it was made to continue\n> indefinitely - most likely with an inflation hard fork - demand for block space\n> would not be critical to Bitcoin's security.\n\n\nI am not completely against your proposal although 100% sure this will not have \"consensus\" to be implemented. I think if bitcoin doesn't have enough demand for block space, it should die. I will be sad if bitcoin doesn't exist but it should be a lesson for all the people opposing soft forks based on drama and politics instead of technical review.\n\nI don't see anything wrong with users paying 100x fees for opening and closing LN channels.\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Sunday, June 12th, 2022 at 9:06 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On Mon, Jun 06, 2022 at 09:02:18AM -0400, Erik Aronesty via bitcoin-dev wrote:\n>\n> > Maintaining the security of the protocol is squarely the responsibility of\n> > the Bitcoin software and the core developers\n> >\n> > Continued demand for block space is critical for Bitcoin's security.\n>\n>\n> Only because the block reward goes away. If it was made to continue\n> indefinitely - most likely with an inflation hard fork - demand for block space\n> would not be critical to Bitcoin's security.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-19T10:31:38",
                "message_text_only": "On Sun, Jun 12, 2022 at 07:16:49PM +0000, alicexbt wrote:\n> Hi Peter,\n> \n> > Only because the block reward goes away. If it was made to continue\n> > indefinitely - most likely with an inflation hard fork - demand for block space\n> > would not be critical to Bitcoin's security.\n> \n> \n> I am not completely against your proposal although 100% sure this will not have \"consensus\" to be implemented. I think if bitcoin doesn't have enough demand for block space, it should die. I will be sad if bitcoin doesn't exist but it should be a lesson for all the people opposing soft forks based on drama and politics instead of technical review.\n> \n> I don't see anything wrong with users paying 100x fees for opening and closing LN channels.\n\nThe PoW security of Bitcoin benefits all Bitcoin users, proportional to the\nvalue of BTC they hold; if Bitcoin blocks aren't reliably created the value of\n*all* BTC goes down. It doesn't make sense for the entire cost of that security\nto be paid for on a per-tx basis. And there's a high chance paying for it on a\nper-tx basis won't work anyway due to lack of consistent demand.\n\nIt would be extremely unfortunate if one of the very few decentralized ways to\nstore value died simply because we couldn't find a way to pay to keep it\nsecure.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/925b89c6/attachment.sig>"
            },
            {
                "author": "Manuel Costa",
                "date": "2022-06-19T15:54:03",
                "message_text_only": "\"Long time listener, first time caller\". Just sharing my 2 sats:\n\nWhile I find it stimulating, I think this discussion (and other similar\ndoom-like scenarios) is somewhat irrelevant in practice.\n\nWhen the time comes and if we start seeing issues with block rewards being\ntoo low to maintain acceptable security, we're going to have multiple\nsolutions being implemented for it, and definitely a hard fork to\nindefinitely maintain some degree of block subsidy is going to be within\nthem.\nIf it is indeed confirmed that the original chain is now insecure,\nconsensus should eventually coalesce in one of the hard forks that can\nactually keep moving forward with some degree of security assurance.\n\nI feel like people sometimes think of these systems as when they fail\nthere's a full loss, but that's not the case as the history is not lost,\nand so we can move forward from that history with multiple alternatives and\nallow the social/economic consensus to dictate which one becomes the new\naccepted chain.\nThe genie is out of the box, and some chain whose history is prefixed by\nBitcoin's current chain history will always exist.\nThe only type of problems we should truly be worrying about are ones that\nmight invalidate the security of the history itself, like a cryptographic\nbreakthrough (quantum computing for example) that would turn some or all\nutxos into \"anyone can spend\".\n\nTransitions might be disorderly and filled with drama and discussion as the\n\"block size wars\" in 2017, but anyone who doesn't want to \"vote\", can\nalways just keep their utxos frozen in place while the drama sorts itself\nout, and maintain whatever holdings they previously had on the new accepted\nchain.\n\nPeter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> escreveu\nno dia domingo, 19/06/2022 \u00e0(s) 11:32:\n\n> On Sun, Jun 12, 2022 at 07:16:49PM +0000, alicexbt wrote:\n> > Hi Peter,\n> >\n> > > Only because the block reward goes away. If it was made to continue\n> > > indefinitely - most likely with an inflation hard fork - demand for\n> block space\n> > > would not be critical to Bitcoin's security.\n> >\n> >\n> > I am not completely against your proposal although 100% sure this will\n> not have \"consensus\" to be implemented. I think if bitcoin doesn't have\n> enough demand for block space, it should die. I will be sad if bitcoin\n> doesn't exist but it should be a lesson for all the people opposing soft\n> forks based on drama and politics instead of technical review.\n> >\n> > I don't see anything wrong with users paying 100x fees for opening and\n> closing LN channels.\n>\n> The PoW security of Bitcoin benefits all Bitcoin users, proportional to the\n> value of BTC they hold; if Bitcoin blocks aren't reliably created the\n> value of\n> *all* BTC goes down. It doesn't make sense for the entire cost of that\n> security\n> to be paid for on a per-tx basis. And there's a high chance paying for it\n> on a\n> per-tx basis won't work anyway due to lack of consistent demand.\n>\n> It would be extremely unfortunate if one of the very few decentralized\n> ways to\n> store value died simply because we couldn't find a way to pay to keep it\n> secure.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/6e169224/attachment.html>"
            },
            {
                "author": "Kate Salazar",
                "date": "2022-06-19T18:26:21",
                "message_text_only": "Hey\n\nOn Sun, Jun 19, 2022 at 8:04 PM Manuel Costa via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> \"Long time listener, first time caller\". Just sharing my 2 sats:\n>\n> While I find it stimulating, I think this discussion (and other similar\n> doom-like scenarios) is somewhat irrelevant in practice.\n>\n> When the time comes and if we start seeing issues with block rewards being\n> too low to maintain acceptable security, we're going to have multiple\n> solutions being implemented for it, and definitely a hard fork to\n> indefinitely maintain some degree of block subsidy is going to be within\n> them.\n> If it is indeed confirmed that the original chain is now insecure,\n> consensus should eventually coalesce in one of the hard forks that can\n> actually keep moving forward with some degree of security assurance.\n>\n> I feel like people sometimes think of these systems as when they fail\n> there's a full loss, but that's not the case as the history is not lost,\n> and so we can move forward from that history with multiple alternatives and\n> allow the social/economic consensus to dictate which one becomes the new\n> accepted chain.\n> The genie is out of the box, and some chain whose history is prefixed by\n> Bitcoin's current chain history will always exist.\n>\n\nI think you are right, the keywords maybe being consensus eventually\ncoalesces in the most viable chain.\n\n\n> The only type of problems we should truly be worrying about are ones that\n> might invalidate the security of the history itself, like a cryptographic\n> breakthrough (quantum computing for example) that would turn some or all\n> utxos into \"anyone can spend\".\n>\n\nI think this is wrong. An entity investing in quantum power and letting\ntheir chop onto some particular utxos is a reasonable outcome. It parallels\na tangible scenario: gang somehow getting a bulldozer and driving it into\nsome particular safe. Being able to rewind such events is the only security\nissue here.\n\nMore generally, circulating supply is circulating supply, to all effect,\noutcome is desirable or not.\n\n\n> Transitions might be disorderly and filled with drama and discussion as\n> the \"block size wars\" in 2017, but anyone who doesn't want to \"vote\", can\n> always just keep their utxos frozen in place while the drama sorts itself\n> out, and maintain whatever holdings they previously had on the new accepted\n> chain.\n>\n> Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> escreveu no dia domingo, 19/06/2022 \u00e0(s) 11:32:\n>\n>> On Sun, Jun 12, 2022 at 07:16:49PM +0000, alicexbt wrote:\n>> > Hi Peter,\n>> >\n>> > > Only because the block reward goes away. If it was made to continue\n>> > > indefinitely - most likely with an inflation hard fork - demand for\n>> block space\n>> > > would not be critical to Bitcoin's security.\n>> >\n>> >\n>> > I am not completely against your proposal although 100% sure this will\n>> not have \"consensus\" to be implemented. I think if bitcoin doesn't have\n>> enough demand for block space, it should die. I will be sad if bitcoin\n>> doesn't exist but it should be a lesson for all the people opposing soft\n>> forks based on drama and politics instead of technical review.\n>> >\n>> > I don't see anything wrong with users paying 100x fees for opening and\n>> closing LN channels.\n>>\n>> The PoW security of Bitcoin benefits all Bitcoin users, proportional to\n>> the\n>> value of BTC they hold; if Bitcoin blocks aren't reliably created the\n>> value of\n>> *all* BTC goes down. It doesn't make sense for the entire cost of that\n>> security\n>> to be paid for on a per-tx basis. And there's a high chance paying for it\n>> on a\n>> per-tx basis won't work anyway due to lack of consistent demand.\n>>\n>> It would be extremely unfortunate if one of the very few decentralized\n>> ways to\n>> store value died simply because we couldn't find a way to pay to keep it\n>> secure.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/58dc9f5b/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-06-19T22:35:55",
                "message_text_only": "On Sun, Jun 19, 2022 at 2:04 PM Manuel Costa via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>  if we start seeing issues with block rewards being too low to maintain\n> acceptable security, we're going to have multiple solutions being\n> implemented for it, and definitely a hard fork to indefinitely maintain\n> some degree of block subsidy\n>\n\nif we failed to first try increasing block demand with advanced transaction\nsupport, it would seem like we were just throwing money and growth away to\nsupport one narrative (simplicty of function), while destroying another\n(finite supply)\n\nif stuff like covenant support and mweb gets us higher fees, with stuff\nlike on-chain mixing protocols, vaults, and higher utility, it might be\nmore than enough to sustain bitcoin on fees alone forever\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/16886185/attachment.html>"
            },
            {
                "author": "Keagan McClelland",
                "date": "2022-06-21T19:00:07",
                "message_text_only": "> The PoW security of Bitcoin benefits all Bitcoin users, proportional to\nthe\nvalue of BTC they hold; if Bitcoin blocks aren't reliably created the value\nof\n*all* BTC goes down. It doesn't make sense for the entire cost of that\nsecurity\nto be paid for on a per-tx basis. And there's a high chance paying for it\non a\nper-tx basis won't work anyway due to lack of consistent demand.\n\nFWIW I prefer the demurrage route. Having something with finite supply as a\nmeans of measuring economic activity is unprecedented and I believe deeply\nimportant. I'm sympathetic to the argument that the security of the chain\nshould not be solely the responsibility of transactors. We realize the\nvalue of money on receipt, hold *and* spend and it would be appropriate for\nthere to be a balance of fees to that effect. While inflation may be\nsimpler to implement (just chop off the last few halvings), I think it\nwould be superior (on the assumption that such a hodl tax was necessary) to\nkeep the supply fixed and have people's utxo balances decay, at least at\nthe level of the UX.\n\nBut also none of this should be reasons we don't improve Bitcoin's value\n(and therefore demand)\n\nKeagan\n\nOn Mon, Jun 20, 2022 at 2:42 AM Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> On Sun, Jun 19, 2022 at 2:04 PM Manuel Costa via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>  if we start seeing issues with block rewards being too low to maintain\n>> acceptable security, we're going to have multiple solutions being\n>> implemented for it, and definitely a hard fork to indefinitely maintain\n>> some degree of block subsidy\n>>\n>\n> if we failed to first try increasing block demand with advanced\n> transaction support, it would seem like we were just throwing money and\n> growth away to support one narrative (simplicty of function), while\n> destroying another (finite supply)\n>\n> if stuff like covenant support and mweb gets us higher fees, with stuff\n> like on-chain mixing protocols, vaults, and higher utility, it might be\n> more than enough to sustain bitcoin on fees alone forever\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220621/3685c7d8/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2022-06-21T20:10:43",
                "message_text_only": "> On Jun 21, 2022, at 12:28, Keagan McClelland via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeff\n> > The PoW security of Bitcoin benefits all Bitcoin users, proportional to the\n> value of BTC they hold; if Bitcoin blocks aren't reliably created the value of\n> *all* BTC goes down. It doesn't make sense for the entire cost of that security\n> to be paid for on a per-tx basis.\n\nActually it does. People who transact are realizing the benefit of money - the avoidance of barter costs. Those who never transact, never realize any benefit.\n\n> And there's a high chance paying for it on a\n> per-tx basis won't work anyway due to lack of consistent demand.\n> \n> FWIW I prefer the demurrage route. Having something with finite supply as a means of measuring economic activity is unprecedented and I believe deeply important. I'm sympathetic to the argument that the security of the chain should not be solely the responsibility of transactors.\n\nChain security - censorship resistance (as opposed to individual double-spend security), is entirely dependent upon tx fees.\n\n> We realize the value of money on receipt, hold *and* spend and it would be appropriate for there to be a balance of fees to that effect.\n\nThere is zero point in saving if you never spend. You can instead just burn your coin.\n\n> While inflation may be simpler to implement (just chop off the last few halvings), I think it would be superior (on the assumption that such a hodl tax was necessary) to keep the supply fixed and have people's utxo balances decay, at least at the level of the UX.\n\nA hoard decays naturally due to opportunity cost. Investing it requires transaction to invest, and transaction to earn (profit), and transaction to return it (interest).\n\n> But also none of this should be reasons we don't improve Bitcoin's value (and therefore demand)\n\nDemand is the only reason we save, and eventually transacting is the only motivation for saving. No transacting implies no demand - and no security.\n\ne\n\n> Keagan\n> \n>> On Mon, Jun 20, 2022 at 2:42 AM Erik Aronesty via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> \n>>> On Sun, Jun 19, 2022 at 2:04 PM Manuel Costa via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>  if we start seeing issues with block rewards being too low to maintain acceptable security, we're going to have multiple solutions being implemented for it, and definitely a hard fork to indefinitely maintain some degree of block subsidy\n>> \n>> if we failed to first try increasing block demand with advanced transaction support, it would seem like we were just throwing money and growth away to support one narrative (simplicty of function), while destroying another (finite supply) \n>> \n>> if stuff like covenant support and mweb gets us higher fees, with stuff like on-chain mixing protocols, vaults, and higher utility, it might be more than enough to sustain bitcoin on fees alone forever\n>>  \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220621/758f2749/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-23T19:17:37",
                "message_text_only": "On Tue, Jun 21, 2022 at 01:00:07PM -0600, Keagan McClelland via bitcoin-dev wrote:\n> > The PoW security of Bitcoin benefits all Bitcoin users, proportional to\n> the\n> value of BTC they hold; if Bitcoin blocks aren't reliably created the value\n> of\n> *all* BTC goes down. It doesn't make sense for the entire cost of that\n> security\n> to be paid for on a per-tx basis. And there's a high chance paying for it\n> on a\n> per-tx basis won't work anyway due to lack of consistent demand.\n> \n> FWIW I prefer the demurrage route. Having something with finite supply as a\n> means of measuring economic activity is unprecedented and I believe deeply\n> important. I'm sympathetic to the argument that the security of the chain\n> should not be solely the responsibility of transactors. We realize the\n> value of money on receipt, hold *and* spend and it would be appropriate for\n> there to be a balance of fees to that effect. While inflation may be\n> simpler to implement (just chop off the last few halvings), I think it\n> would be superior (on the assumption that such a hodl tax was necessary) to\n> keep the supply fixed and have people's utxo balances decay, at least at\n> the level of the UX.\n\nDemurrage makes protocols like Lightning much more complex, and isn't\ncompatible with existing implementations. While demurrage could in theory be\nimplemented in a soft-fork by forcing txs to contain an output with the\ndemurrage-taxed amount, spending to a pool of future mining fees, I really\ndon't think it's practical to actually do that.\n\nAnyway, demurrage and inflation have identical economic properties. They're\nboth a tax on savings. The only difference is the way that tax is implemented.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220623/056ee0b9/attachment.sig>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-28T03:55:56",
                "message_text_only": "@Eric\n>  People who transact are realizing the benefit of money - the avoidance\nof barter costs.\n\nI'm very confident you're incorrect that holders don't receive any benefit\nand you're certainly not correct that every spend is receiving the same\nbenefit. As I'm sure you're aware, one of the primary components of a\ncurrency's value and purpose is as a store of value. Storing value happens\nwhile you're holding it, not while you're spending it. Consider the\nfollowing two scenarios: one person holds onto 10 bitcoin for 10 years and\nthen spends those 10 bitcoins in some way in 2 transactions. Another person\nspends 4 bitcoins to buy something, then sells it for 6 bitcoins, and then\nbuys something else for that 6 bitcoins and then never acquires any bitcoin\nfor 10 years.\n\nBoth people spent 10 bitcoins over 2 transactions. Over that 10 year\nperiod, only one of those people utilized bitcoin's utility as a store of\nvalue. Who benefited more from their use of bitcoin?\n\n> Those who never transact, never realize any benefit.\n\nWhile that's true, its not relevant and basically a red herring. You need\nto compare those who transact often and rarely hold, to those who hold a\nlot but rarely transact. Its not helpful to consider those who throw their\nbitcoin into a bottomless pit and never retrieve them.\n\nOn an idealistic level, I agree with Keagan that it would make sense to\nhave \"a balance of fees to that effect\". I think doing that would be\ntechnically/economically optimal. However, I think there is an enormous\nbenefit to having a cultural aversion to monetary inflation and the\nconsequences of convincing the bitcoin community that inflation is ok could\nhave unintended negative consequences (not to mention how difficult\nconvincing the community would be in the first place). There's also the\neconomic distortion that inflation causes that has a negative effect which\nshould also be considered. The idea of decaying utxo value is interesting\nto consider, but it would not solve the economic distortion that\nmonetary inflation causes, because that distortion is a result of monetary\ndevaluation (which decaying utxos would be a form of). Then again, maybe in\nthis case the distortion of inflation would actually be a correction -\ncorrecting for the externality of benefit received by holders. I'm\nstream-of-consciousnessing a bit, but anyways, I suspect its not worth the\ntrouble to perfect the distribution of bitcoin blockchain security costs to\ninclude holders. Tho, if I were to go back in time and influence how\nbitcoin was designed, I might advocate for it.\n\n@Peter\n> demurrage and inflation have identical economic properties.\n\nThe distortion of incentives is identical, however there is also the effect\nit has on a currency's property as a useful unit of account. Decaying utxos\nwould mean that it would contribute substantially less to market prices\nneeding to change. I suspect this effect would be bordering on negligible\ntho.\n\nOn Thu, Jun 23, 2022 at 2:17 PM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Jun 21, 2022 at 01:00:07PM -0600, Keagan McClelland via\n> bitcoin-dev wrote:\n> > > The PoW security of Bitcoin benefits all Bitcoin users, proportional to\n> > the\n> > value of BTC they hold; if Bitcoin blocks aren't reliably created the\n> value\n> > of\n> > *all* BTC goes down. It doesn't make sense for the entire cost of that\n> > security\n> > to be paid for on a per-tx basis. And there's a high chance paying for it\n> > on a\n> > per-tx basis won't work anyway due to lack of consistent demand.\n> >\n> > FWIW I prefer the demurrage route. Having something with finite supply\n> as a\n> > means of measuring economic activity is unprecedented and I believe\n> deeply\n> > important. I'm sympathetic to the argument that the security of the chain\n> > should not be solely the responsibility of transactors. We realize the\n> > value of money on receipt, hold *and* spend and it would be appropriate\n> for\n> > there to be a balance of fees to that effect. While inflation may be\n> > simpler to implement (just chop off the last few halvings), I think it\n> > would be superior (on the assumption that such a hodl tax was necessary)\n> to\n> > keep the supply fixed and have people's utxo balances decay, at least at\n> > the level of the UX.\n>\n> Demurrage makes protocols like Lightning much more complex, and isn't\n> compatible with existing implementations. While demurrage could in theory\n> be\n> implemented in a soft-fork by forcing txs to contain an output with the\n> demurrage-taxed amount, spending to a pool of future mining fees, I really\n> don't think it's practical to actually do that.\n>\n> Anyway, demurrage and inflation have identical economic properties. They're\n> both a tax on savings. The only difference is the way that tax is\n> implemented.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220627/83152ae9/attachment.html>"
            },
            {
                "author": "Alex Lee",
                "date": "2022-06-28T16:23:40",
                "message_text_only": "On Tue, Jun 28, 2022 at 4:43 AM Billy Tetrud via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> @Eric\n> >  People who transact are realizing the benefit of money - the avoidance\n> of barter costs.\n>\n> I'm very confident you're incorrect that holders don't receive any benefit\n> and you're certainly not correct that every spend is receiving the same\n> benefit. As I'm sure you're aware, one of the primary components of a\n> currency's value and purpose is as a store of value. Storing value happens\n> while you're holding it, not while you're spending it. Consider the\n> following two scenarios: one person holds onto 10 bitcoin for 10 years and\n> then spends those 10 bitcoins in some way in 2 transactions. Another person\n> spends 4 bitcoins to buy something, then sells it for 6 bitcoins, and then\n> buys something else for that 6 bitcoins and then never acquires any bitcoin\n> for 10 years.\n>\n> Both people spent 10 bitcoins over 2 transactions. Over that 10 year\n> period, only one of those people utilized bitcoin's utility as a store of\n> value. Who benefited more from their use of bitcoin?\n>\n>\nThe person who obtained greater economic utility from their two\ntransactions.\n\n\n> > Those who never transact, never realize any benefit.\n>\n> While that's true, its not relevant and basically a red herring. You need\n> to compare those who transact often and rarely hold, to those who hold a\n> lot but rarely transact. Its not helpful to consider those who throw their\n> bitcoin into a bottomless pit and never retrieve them.\n>\n\nThere are legitimate uses for burning bitcoin, speaking of bottomless pits.\nI would avoid confusing velocity metrics with utility, as these aren't the\nsame thing.\n\n\n>\n> On an idealistic level, I agree with Keagan that it would make sense to\n> have \"a balance of fees to that effect\". I think doing that would be\n> technically/economically optimal. However, I think there is an enormous\n> benefit to having a cultural aversion to monetary inflation and the\n> consequences of convincing the bitcoin community that inflation is ok could\n> have unintended negative consequences (not to mention how difficult\n> convincing the community would be in the first place). There's also the\n> economic distortion that inflation causes that has a negative effect which\n> should also be considered. The idea of decaying utxo value is interesting\n> to consider, but it would not solve the economic distortion that\n> monetary inflation causes, because that distortion is a result of monetary\n> devaluation (which decaying utxos would be a form of). Then again, maybe in\n> this case the distortion of inflation would actually be a correction -\n> correcting for the externality of benefit received by holders. I'm\n> stream-of-consciousnessing a bit, but anyways, I suspect its not worth the\n> trouble to perfect the distribution of bitcoin blockchain security costs to\n> include holders. Tho, if I were to go back in time and influence how\n> bitcoin was designed, I might advocate for it.\n>\n> @Peter\n> > demurrage and inflation have identical economic properties.\n>\n> The distortion of incentives is identical, however there is also the\n> effect it has on a currency's property as a useful unit of account.\n> Decaying utxos would mean that it would contribute substantially less to\n> market prices needing to change. I suspect this effect would be bordering\n> on negligible tho.\n>\n> On Thu, Jun 23, 2022 at 2:17 PM Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Tue, Jun 21, 2022 at 01:00:07PM -0600, Keagan McClelland via\n>> bitcoin-dev wrote:\n>> > > The PoW security of Bitcoin benefits all Bitcoin users, proportional\n>> to\n>> > the\n>> > value of BTC they hold; if Bitcoin blocks aren't reliably created the\n>> value\n>> > of\n>> > *all* BTC goes down. It doesn't make sense for the entire cost of that\n>> > security\n>> > to be paid for on a per-tx basis. And there's a high chance paying for\n>> it\n>> > on a\n>> > per-tx basis won't work anyway due to lack of consistent demand.\n>> >\n>> > FWIW I prefer the demurrage route. Having something with finite supply\n>> as a\n>> > means of measuring economic activity is unprecedented and I believe\n>> deeply\n>> > important. I'm sympathetic to the argument that the security of the\n>> chain\n>> > should not be solely the responsibility of transactors. We realize the\n>> > value of money on receipt, hold *and* spend and it would be appropriate\n>> for\n>> > there to be a balance of fees to that effect. While inflation may be\n>> > simpler to implement (just chop off the last few halvings), I think it\n>> > would be superior (on the assumption that such a hodl tax was\n>> necessary) to\n>> > keep the supply fixed and have people's utxo balances decay, at least at\n>> > the level of the UX.\n>>\n>> Demurrage makes protocols like Lightning much more complex, and isn't\n>> compatible with existing implementations. While demurrage could in theory\n>> be\n>> implemented in a soft-fork by forcing txs to contain an output with the\n>> demurrage-taxed amount, spending to a pool of future mining fees, I really\n>> don't think it's practical to actually do that.\n>>\n>> Anyway, demurrage and inflation have identical economic properties.\n>> They're\n>> both a tax on savings. The only difference is the way that tax is\n>> implemented.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/3c0d23a6/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-28T23:22:40",
                "message_text_only": "On Tue, Jun 28, 2022 at 12:23:40PM -0400, Alex Lee via bitcoin-dev wrote:\n> > > Those who never transact, never realize any benefit.\n> >\n> > While that's true, its not relevant and basically a red herring. You need\n> > to compare those who transact often and rarely hold, to those who hold a\n> > lot but rarely transact. Its not helpful to consider those who throw their\n> > bitcoin into a bottomless pit and never retrieve them.\n> >\n> \n> There are legitimate uses for burning bitcoin, speaking of bottomless pits.\n> I would avoid confusing velocity metrics with utility, as these aren't the\n> same thing.\n\nAll the legitimate uses for burning bitcoin are _not_ done via a \"bottomless\npit\": they're done with transactions proving that the bitcoin has actually been\nburnt.  And the value obtained by burning BTC in those scenarios is affected by\ntx fees and inflation just as much as any other tx.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/0d8a2a3c/attachment.sig>"
            },
            {
                "author": "Alex Lee",
                "date": "2022-06-29T05:02:30",
                "message_text_only": "On Tue, Jun 28, 2022 at 7:22 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Tue, Jun 28, 2022 at 12:23:40PM -0400, Alex Lee via bitcoin-dev wrote:\n> > > > Those who never transact, never realize any benefit.\n> > >\n> > > While that's true, its not relevant and basically a red herring. You\n> need\n> > > to compare those who transact often and rarely hold, to those who hold\n> a\n> > > lot but rarely transact. Its not helpful to consider those who throw\n> their\n> > > bitcoin into a bottomless pit and never retrieve them.\n> > >\n> >\n> > There are legitimate uses for burning bitcoin, speaking of bottomless\n> pits.\n> > I would avoid confusing velocity metrics with utility, as these aren't\n> the\n> > same thing.\n>\n> All the legitimate uses for burning bitcoin are _not_ done via a\n> \"bottomless\n> pit\": they're done with transactions proving that the bitcoin has actually\n> been\n> burnt.  And the value obtained by burning BTC in those scenarios is\n> affected by\n> tx fees and inflation just as much as any other tx.\n>\n>\nThe \"bottomless pit\" is a metaphor for the inability to spend the coins\nagain in the future once burned, as Billy appeared to be indicating that\nthe frequent movement of coins in itself somehow produced utility.\nNaturally you are correct that the utility of the burn comes from the\nproof; I am not sure what the meaning of \"burned coins\" would be without\nthe proof to be honest.\n\n\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220629/a99c3d6f/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-28T23:20:27",
                "message_text_only": "On Mon, Jun 27, 2022 at 10:55:56PM -0500, Billy Tetrud wrote:\n> @Eric\n> >  People who transact are realizing the benefit of money - the avoidance\n> of barter costs.\n> \n> I'm very confident you're incorrect that holders don't receive any benefit\n> and you're certainly not correct that every spend is receiving the same\n> benefit. As I'm sure you're aware, one of the primary components of a\n> currency's value and purpose is as a store of value. Storing value happens\n> while you're holding it, not while you're spending it. Consider the\n> following two scenarios: one person holds onto 10 bitcoin for 10 years and\n> then spends those 10 bitcoins in some way in 2 transactions. Another person\n> spends 4 bitcoins to buy something, then sells it for 6 bitcoins, and then\n> buys something else for that 6 bitcoins and then never acquires any bitcoin\n> for 10 years.\n> \n> Both people spent 10 bitcoins over 2 transactions. Over that 10 year\n> period, only one of those people utilized bitcoin's utility as a store of\n> value. Who benefited more from their use of bitcoin?\n\nNotice how people frequenty bring up the fact that if you divide the total\nblock reward by the number of transactions, the cost per transaction is fairly\nhigh - on the order of tens of dollars.\n\nThis makes much more sense when you realize that the average value moved per\ntransaction is also very high - thousands of dollars - making the cost due to\ninflation of those tens of dollars transactions low enough to be affordable.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/0bdda27e/attachment.sig>"
            },
            {
                "author": "Kate Salazar",
                "date": "2022-06-29T10:44:11",
                "message_text_only": "Hey\n\nOn Tue, Jun 28, 2022 at 10:43 AM Billy Tetrud via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> @Eric\n> >  People who transact are realizing the benefit of money - the avoidance\n> of barter costs.\n>\n> I'm very confident you're incorrect that holders don't receive any benefit\n> and you're certainly not correct that every spend is receiving the same\n> benefit. As I'm sure you're aware, one of the primary components of a\n> currency's value and purpose is as a store of value. Storing value happens\n> while you're holding it, not while you're spending it. Consider the\n> following two scenarios: one person holds onto 10 bitcoin for 10 years and\n> then spends those 10 bitcoins in some way in 2 transactions. Another person\n> spends 4 bitcoins to buy something, then sells it for 6 bitcoins, and then\n> buys something else for that 6 bitcoins and then never acquires any bitcoin\n> for 10 years.\n>\n> Both people spent 10 bitcoins over 2 transactions. Over that 10 year\n> period, only one of those people utilized bitcoin's utility as a store of\n> value. Who benefited more from their use of bitcoin?\n>\n> > Those who never transact, never realize any benefit.\n>\n> While that's true, its not relevant and basically a red herring. You need\n> to compare those who transact often and rarely hold, to those who hold a\n> lot but rarely transact. Its not helpful to consider those who throw their\n> bitcoin into a bottomless pit and never retrieve them.\n>\n> On an idealistic level, I agree with Keagan that it would make sense to\n> have \"a balance of fees to that effect\". I think doing that would be\n> technically/economically optimal. However, I think there is an enormous\n> benefit to having a cultural aversion to monetary inflation and the\n> consequences of convincing the bitcoin community that inflation is ok could\n> have unintended negative consequences (not to mention how difficult\n> convincing the community would be in the first place). There's also the\n> economic distortion that inflation causes that has a negative effect which\n> should also be considered. The idea of decaying utxo value is interesting\n> to consider, but it would not solve the economic distortion that\n> monetary inflation causes, because that distortion is a result of monetary\n> devaluation (which decaying utxos would be a form of). Then again, maybe in\n> this case the distortion of inflation would actually be a correction -\n> correcting for the externality of benefit received by holders. I'm\n> stream-of-consciousnessing a bit, but anyways, I suspect its not worth the\n> trouble to perfect the distribution of bitcoin blockchain security costs to\n> include holders. Tho, if I were to go back in time and influence how\n> bitcoin was designed, I might advocate for it.\n>\n\nPool operators are free to request larger fees from older utxos, or from\nall utxos, or from newer utxos, at their judgement, looking at the\nblockspace demand census and at what the other pool operators are doing.\nThis is not consensus, it's policy. It's not a technology problem, it's\nsolved above in the social layer.\n\nIf this kind of problem torments anyone, maybe miner decentralization hard\nforks are worth looking at, some already exist.\n\n\n>\n> @Peter\n> > demurrage and inflation have identical economic properties.\n>\n> The distortion of incentives is identical, however there is also the\n> effect it has on a currency's property as a useful unit of account.\n> Decaying utxos would mean that it would contribute substantially less to\n> market prices needing to change. I suspect this effect would be bordering\n> on negligible tho.\n>\n> On Thu, Jun 23, 2022 at 2:17 PM Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Tue, Jun 21, 2022 at 01:00:07PM -0600, Keagan McClelland via\n>> bitcoin-dev wrote:\n>> > > The PoW security of Bitcoin benefits all Bitcoin users, proportional\n>> to\n>> > the\n>> > value of BTC they hold; if Bitcoin blocks aren't reliably created the\n>> value\n>> > of\n>> > *all* BTC goes down. It doesn't make sense for the entire cost of that\n>> > security\n>> > to be paid for on a per-tx basis. And there's a high chance paying for\n>> it\n>> > on a\n>> > per-tx basis won't work anyway due to lack of consistent demand.\n>> >\n>> > FWIW I prefer the demurrage route. Having something with finite supply\n>> as a\n>> > means of measuring economic activity is unprecedented and I believe\n>> deeply\n>> > important. I'm sympathetic to the argument that the security of the\n>> chain\n>> > should not be solely the responsibility of transactors. We realize the\n>> > value of money on receipt, hold *and* spend and it would be appropriate\n>> for\n>> > there to be a balance of fees to that effect. While inflation may be\n>> > simpler to implement (just chop off the last few halvings), I think it\n>> > would be superior (on the assumption that such a hodl tax was\n>> necessary) to\n>> > keep the supply fixed and have people's utxo balances decay, at least at\n>> > the level of the UX.\n>>\n>> Demurrage makes protocols like Lightning much more complex, and isn't\n>> compatible with existing implementations. While demurrage could in theory\n>> be\n>> implemented in a soft-fork by forcing txs to contain an output with the\n>> demurrage-taxed amount, spending to a pool of future mining fees, I really\n>> don't think it's practical to actually do that.\n>>\n>> Anyway, demurrage and inflation have identical economic properties.\n>> They're\n>> both a tax on savings. The only difference is the way that tax is\n>> implemented.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220629/0ba8c96a/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-30T15:25:47",
                "message_text_only": "@Alex\n> The person who obtained greater economic utility from their two\ntransactions.\n\nThat is not the case. The economic utility gained by their two transactions\nis probably almost entirely related to something other than bitcoin - the\nnature of the specific transactions themselves. The value they got from\nusing bitcoin is the value they get from the properties of bitcoin when\ncompared against other competing things in the market (other currencies or\npayment systems). Bitcoin's ability to finalize quickly, have no\ncounterparty risk, reduced 3rd party middleman fees, and the willingness of\nthat person to transact using bitcoin vs something else, to name a few.\n\nMy example was intended to make it very clear that the person who held\nbitcoin over 10 years got more value from bitcoin itself, regardless of who\nreceived more economic utility from their chosen transactions.\n\n> Billy appeared to be indicating that the frequent movement of coins in\nitself somehow produced utility\n\nI was actually saying the opposite of that. My point, and the point of my\nexample I explained above, was that holders gain quite a bit of value from\nbitcoin, and so bitcoin's value to its users is not derived solely from\ntransacting.\n\n@Kate\n> Pool operators are free to request larger fees from older utxos\n\nYou're absolutely right that whoever creates their block template can\ndecide how to include transactions. However, by doing such non-standard\nthings, they would lose money, so they are not incentivized to do that.\nKeagan's point was about who pays for bitcoin's security. Right now it is\nonly transactors. And yet transactors are not the only actors who gain\nvalue from the use of bitcoin. As such, the payment for bitcoin's security\nis not spread proportionally to those who get value from the use of\nbitcoin. It would certainly be ideal if bitcoin's security was paid for by\neach actor proportionally to how much value they get from using bitcoin.\nWorth it? Questionable. But ideal, certainly. You aren't going to get to\nthat ideal by expecting individual miners to altruistically lose money to\nenact that ideal.\n\nOn Wed, Jun 29, 2022 at 3:44 AM Kate Salazar <\nmercedes.catherine.salazar at gmail.com> wrote:\n\n> Hey\n>\n> On Tue, Jun 28, 2022 at 10:43 AM Billy Tetrud via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> @Eric\n>> >  People who transact are realizing the benefit of money - the avoidance\n>> of barter costs.\n>>\n>> I'm very confident you're incorrect that holders don't receive any\n>> benefit and you're certainly not correct that every spend is receiving the\n>> same benefit. As I'm sure you're aware, one of the primary components of a\n>> currency's value and purpose is as a store of value. Storing value happens\n>> while you're holding it, not while you're spending it. Consider the\n>> following two scenarios: one person holds onto 10 bitcoin for 10 years and\n>> then spends those 10 bitcoins in some way in 2 transactions. Another person\n>> spends 4 bitcoins to buy something, then sells it for 6 bitcoins, and then\n>> buys something else for that 6 bitcoins and then never acquires any bitcoin\n>> for 10 years.\n>>\n>> Both people spent 10 bitcoins over 2 transactions. Over that 10 year\n>> period, only one of those people utilized bitcoin's utility as a store of\n>> value. Who benefited more from their use of bitcoin?\n>>\n>> > Those who never transact, never realize any benefit.\n>>\n>> While that's true, its not relevant and basically a red herring. You need\n>> to compare those who transact often and rarely hold, to those who hold a\n>> lot but rarely transact. Its not helpful to consider those who throw their\n>> bitcoin into a bottomless pit and never retrieve them.\n>>\n>> On an idealistic level, I agree with Keagan that it would make sense to\n>> have \"a balance of fees to that effect\". I think doing that would be\n>> technically/economically optimal. However, I think there is an enormous\n>> benefit to having a cultural aversion to monetary inflation and the\n>> consequences of convincing the bitcoin community that inflation is ok could\n>> have unintended negative consequences (not to mention how difficult\n>> convincing the community would be in the first place). There's also the\n>> economic distortion that inflation causes that has a negative effect which\n>> should also be considered. The idea of decaying utxo value is interesting\n>> to consider, but it would not solve the economic distortion that\n>> monetary inflation causes, because that distortion is a result of monetary\n>> devaluation (which decaying utxos would be a form of). Then again, maybe in\n>> this case the distortion of inflation would actually be a correction -\n>> correcting for the externality of benefit received by holders. I'm\n>> stream-of-consciousnessing a bit, but anyways, I suspect its not worth the\n>> trouble to perfect the distribution of bitcoin blockchain security costs to\n>> include holders. Tho, if I were to go back in time and influence how\n>> bitcoin was designed, I might advocate for it.\n>>\n>\n> Pool operators are free to request larger fees from older utxos, or from\n> all utxos, or from newer utxos, at their judgement, looking at the\n> blockspace demand census and at what the other pool operators are doing.\n> This is not consensus, it's policy. It's not a technology problem, it's\n> solved above in the social layer.\n>\n> If this kind of problem torments anyone, maybe miner decentralization hard\n> forks are worth looking at, some already exist.\n>\n>\n>>\n>> @Peter\n>> > demurrage and inflation have identical economic properties.\n>>\n>> The distortion of incentives is identical, however there is also the\n>> effect it has on a currency's property as a useful unit of account.\n>> Decaying utxos would mean that it would contribute substantially less to\n>> market prices needing to change. I suspect this effect would be bordering\n>> on negligible tho.\n>>\n>> On Thu, Jun 23, 2022 at 2:17 PM Peter Todd via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Tue, Jun 21, 2022 at 01:00:07PM -0600, Keagan McClelland via\n>>> bitcoin-dev wrote:\n>>> > > The PoW security of Bitcoin benefits all Bitcoin users, proportional\n>>> to\n>>> > the\n>>> > value of BTC they hold; if Bitcoin blocks aren't reliably created the\n>>> value\n>>> > of\n>>> > *all* BTC goes down. It doesn't make sense for the entire cost of that\n>>> > security\n>>> > to be paid for on a per-tx basis. And there's a high chance paying for\n>>> it\n>>> > on a\n>>> > per-tx basis won't work anyway due to lack of consistent demand.\n>>> >\n>>> > FWIW I prefer the demurrage route. Having something with finite supply\n>>> as a\n>>> > means of measuring economic activity is unprecedented and I believe\n>>> deeply\n>>> > important. I'm sympathetic to the argument that the security of the\n>>> chain\n>>> > should not be solely the responsibility of transactors. We realize the\n>>> > value of money on receipt, hold *and* spend and it would be\n>>> appropriate for\n>>> > there to be a balance of fees to that effect. While inflation may be\n>>> > simpler to implement (just chop off the last few halvings), I think it\n>>> > would be superior (on the assumption that such a hodl tax was\n>>> necessary) to\n>>> > keep the supply fixed and have people's utxo balances decay, at least\n>>> at\n>>> > the level of the UX.\n>>>\n>>> Demurrage makes protocols like Lightning much more complex, and isn't\n>>> compatible with existing implementations. While demurrage could in\n>>> theory be\n>>> implemented in a soft-fork by forcing txs to contain an output with the\n>>> demurrage-taxed amount, spending to a pool of future mining fees, I\n>>> really\n>>> don't think it's practical to actually do that.\n>>>\n>>> Anyway, demurrage and inflation have identical economic properties.\n>>> They're\n>>> both a tax on savings. The only difference is the way that tax is\n>>> implemented.\n>>>\n>>> --\n>>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220630/871e84df/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-06-30T17:04:50",
                "message_text_only": ">\n> Anyway, demurrage and inflation have identical economic properties. They're\n>> both a tax on savings. The only difference is the way that tax is\n>> implemented.\n>\n>\nthe fact that a conversation on inflation is continuing without being\nignored is probably an indicator that the utility of on-chain services as\nan incentive to drive fees is a worthwhile consideration.  i especially\nlike the proposed and very simple on-chain \"payment codes\" idea, for\nexample.   if a light-touch is used, bitcoin operators can thread the\nneedle allowing utility to grow a bit in response to halvings.  i suspect\nlightning ate a lot of the on-chain fees.   future \"compression and\nprivacy\" protocols, like mweb, should keep this concern in mind.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220630/a25eb642/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2022-06-04T18:43:35",
                "message_text_only": "\"Some people say CTV is contentious, but they're spreading misinformation\"?\nReally? Seriously?\nCome on, guys, we can do better than nina jankovich and the \"fact checkers\".\n\nPlease, rise the bar.\n\nOn Fri, Jun 3, 2022, 19:44 alicexbt via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Note: This email is an opinion and not an attack on bitcoin\n>\n> Covenants on bitcoin will eventually be implemented with a soft fork. CTV\n> is the easiest and best possible way OP_TX looks good as well. Apart from\n> the technical merits, covenants will improve a few other things:\n>\n> - Developers can build interesting projects with real demand in market.\n> - Students learn Sapio and not just solidity.\n> - Better tooling could be available for application developers.\n> - Maybe we see bitcoin developer hackathons in different countries.\n> - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> - Funding of bitcoin developers and projects might improve. Wont need to\n> convince a few people for grants.\n>\n> **Why covenants are not contentious?**\n>\n> Some people may write paragraphs about CTV being contentious, spread\n> misinformation and do all types of drama, politics etc. on social media but\n> there are zero technical NACKs for CTV. We have discussed other covenant\n> proposals in detail on mailing list and IRC meetings with an open minded\n> approach.\n>\n> All the developers that participated in the discussion are either okay\n> with CTV or OP_TX or covenants in general.\n>\n> **How and when should covenants be implemented in Bitcoin?**\n>\n> I don't think we should wait for years anticipating a proposal that\n> everyone will agree on or argue for years to pretend changes are hard in\n> Bitcoin. We should improve the review process for soft fork BIPs and share\n> honest opinions with agreement, disagreement on technical merits.\n>\n> I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything\n> else being used if that improves Bitcoin. Covenants implemented in Bitcoin\n> before the next cycle would provide opportunity for developers to build\n> interesting things during the bear market. Ossification supporters also\n> believe there is some window that will close soon, maybe doing changes\n> considering each case individually will be a better approach. CTV is not a\n> rushed soft fork, less people followed the research and it was not\n> mentioned on social media repeatedly by the respected developers like other\n> soft forks.\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail secure email.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220604/8d38f1f2/attachment.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-05T04:18:04",
                "message_text_only": "Hi Jorge,\n\n\nMisinformation is false or inaccurate information, especially that which is deliberately intended to deceive. A combination of 'misleading' and 'information'. Here are a few examples and I am sure I missed a lot of others but its difficult for me to keep a track of everything:\n\n\n1) Sapio is open source and everything mentioned in tweet is false: https://web.archive.org/web/20220503050140/https://twitter.com/coinableS/status/1521354192434073602\n\n2) Personal attacks on author of BIP 119 with false information: https://nitter.net/s3cp256k1/status/1521238634111770624\n\n3) Andreas Antonopoulos shared false things about CTV and explained by Ryan in this email: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020414.html\n\n4) Misleading things shared in these emails by Michael Folkson:\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020286.html\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020343.html\n\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020386.html\n\n5) Peter Todd and Zac shared misleading things about BIP 119, bitcoin and L2. I replied in this email: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020322.html\n\n6) Social media influencers like Peter McCormack tweeted they don't understand BIP 119 but its an attack (this was even retweeted by developers like Peter Todd): https://nitter.net/PeterMcCormack/status/1521253840963653632\n\n7) Some misconceptions about BIP 119 cleared by Bitcoin Magazine: https://bitcoinmagazine.com/technical/what-is-bip-119-bitcoin-controversy-explained\n\n8) There were lies and misinformation about BIP 119 on social media according to this Bitcoin Magazine article: https://bitcoinmagazine.com/technical/analyzing-bip119-and-the-controversy-surrounding-it\n\n9) John Carvalho tweeting false things:\n\n    https://nitter.net/BitcoinErrorLog/status/1468599535538745359\n\n    https://nitter.net/BitcoinErrorLog/status/1522652884218822658\n\n    https://nitter.net/BitcoinErrorLog/status/1442554615967354880\n\n    https://nitter.net/search?q=MIT%20(from%3ABitcoinErrorLog)\n\n10) Greg Maxwell responding to misinformation related to BIP 119 but adding false things in the comments: https://www.reddit.com/r/Bitcoin/comments/uim560/bip_119/i7dhfpb/\n\n\nI am not surprised by your email but it would be better if the people who are interested in reviewing BIP 119 could raise the bar and not share misleading information.\n\n\n/dev/fd0\n\n\nSent with Proton Mail secure email.\n------- Original Message -------\nOn Sunday, June 5th, 2022 at 12:12 AM, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n\n\n> \"Some people say CTV is contentious, but they're spreading misinformation\"? Really? Seriously?Come on, guys, we can do better than nina jankovich and the \"fact checkers\".\n> Please, rise the bar.\n> On Fri, Jun 3, 2022, 19:44 alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Note: This email is an opinion and not an attack on bitcoin\n> >\n> > Covenants on bitcoin will eventually be implemented with a soft fork. CTV is the easiest and best possible way OP_TX looks good as well. Apart from the technical merits, covenants will improve a few other things:\n> >\n> > - Developers can build interesting projects with real demand in market.\n> > - Students learn Sapio and not just solidity.\n> > - Better tooling could be available for application developers.\n> > - Maybe we see bitcoin developer hackathons in different countries.\n> > - Demand for block space might increase, it wont be just exchanges and coinjoin.\n> > - Funding of bitcoin developers and projects might improve. Wont need to convince a few people for grants.\n> >\n> > **Why covenants are not contentious?**\n> >\n> > Some people may write paragraphs about CTV being contentious, spread misinformation and do all types of drama, politics etc. on social media but there are zero technical NACKs for CTV. We have discussed other covenant proposals in detail on mailing list and IRC meetings with an open minded approach.\n> >\n> > All the developers that participated in the discussion are either okay with CTV or OP_TX or covenants in general.\n> >\n> > **How and when should covenants be implemented in Bitcoin?**\n> >\n> > I don't think we should wait for years anticipating a proposal that everyone will agree on or argue for years to pretend changes are hard in Bitcoin. We should improve the review process for soft fork BIPs and share honest opinions with agreement, disagreement on technical merits.\n> >\n> > I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind anything else being used if that improves Bitcoin. Covenants implemented in Bitcoin before the next cycle would provide opportunity for developers to build interesting things during the bear market. Ossification supporters also believe there is some window that will close soon, maybe doing changes considering each case individually will be a better approach. CTV is not a rushed soft fork, less people followed the research and it was not mentioned on social media repeatedly by the respected developers like other soft forks.\n> >\n> > /dev/fd0\n> >\n> >\n> > Sent with Proton Mail secure email.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-08T03:51:40",
                "message_text_only": "Wholeheartedly agree with you alicexbt. There are no technical issues that\nhave been shown that I'm aware of. Once the non-technical folks have time\nto discuss it and realize that, I'm hopeful things will move forward.\nPerhaps we can learn from this and figure out how to better catch the\nattention of the larger bitcoin community  for important changes without\nalarming them.\n\nOn Sun, Jun 5, 2022 at 2:48 AM alicexbt via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Jorge,\n>\n>\n> Misinformation is false or inaccurate information, especially that which\n> is deliberately intended to deceive. A combination of 'misleading' and\n> 'information'. Here are a few examples and I am sure I missed a lot of\n> others but its difficult for me to keep a track of everything:\n>\n>\n> 1) Sapio is open source and everything mentioned in tweet is false:\n> https://web.archive.org/web/20220503050140/https://twitter.com/coinableS/status/1521354192434073602\n>\n> 2) Personal attacks on author of BIP 119 with false information:\n> https://nitter.net/s3cp256k1/status/1521238634111770624\n>\n> 3) Andreas Antonopoulos shared false things about CTV and explained by\n> Ryan in this email:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020414.html\n>\n> 4) Misleading things shared in these emails by Michael Folkson:\n>\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html\n>\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html\n>\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020286.html\n>\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020343.html\n>\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020386.html\n>\n> 5) Peter Todd and Zac shared misleading things about BIP 119, bitcoin and\n> L2. I replied in this email:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020322.html\n>\n> 6) Social media influencers like Peter McCormack tweeted they don't\n> understand BIP 119 but its an attack (this was even retweeted by developers\n> like Peter Todd):\n> https://nitter.net/PeterMcCormack/status/1521253840963653632\n>\n> 7) Some misconceptions about BIP 119 cleared by Bitcoin Magazine:\n> https://bitcoinmagazine.com/technical/what-is-bip-119-bitcoin-controversy-explained\n>\n> 8) There were lies and misinformation about BIP 119 on social media\n> according to this Bitcoin Magazine article:\n> https://bitcoinmagazine.com/technical/analyzing-bip119-and-the-controversy-surrounding-it\n>\n> 9) John Carvalho tweeting false things:\n>\n>     https://nitter.net/BitcoinErrorLog/status/1468599535538745359\n>\n>     https://nitter.net/BitcoinErrorLog/status/1522652884218822658\n>\n>     https://nitter.net/BitcoinErrorLog/status/1442554615967354880\n>\n>     https://nitter.net/search?q=MIT%20(from%3ABitcoinErrorLog)\n>\n> 10) Greg Maxwell responding to misinformation related to BIP 119 but\n> adding false things in the comments:\n> https://www.reddit.com/r/Bitcoin/comments/uim560/bip_119/i7dhfpb/\n>\n>\n> I am not surprised by your email but it would be better if the people who\n> are interested in reviewing BIP 119 could raise the bar and not share\n> misleading information.\n>\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail secure email.\n> ------- Original Message -------\n> On Sunday, June 5th, 2022 at 12:12 AM, Jorge Tim\u00f3n <jtimon at jtimon.cc>\n> wrote:\n>\n>\n> > \"Some people say CTV is contentious, but they're spreading\n> misinformation\"? Really? Seriously?Come on, guys, we can do better than\n> nina jankovich and the \"fact checkers\".\n> > Please, rise the bar.\n> > On Fri, Jun 3, 2022, 19:44 alicexbt via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Note: This email is an opinion and not an attack on bitcoin\n> > >\n> > > Covenants on bitcoin will eventually be implemented with a soft fork.\n> CTV is the easiest and best possible way OP_TX looks good as well. Apart\n> from the technical merits, covenants will improve a few other things:\n> > >\n> > > - Developers can build interesting projects with real demand in market.\n> > > - Students learn Sapio and not just solidity.\n> > > - Better tooling could be available for application developers.\n> > > - Maybe we see bitcoin developer hackathons in different countries.\n> > > - Demand for block space might increase, it wont be just exchanges and\n> coinjoin.\n> > > - Funding of bitcoin developers and projects might improve. Wont need\n> to convince a few people for grants.\n> > >\n> > > **Why covenants are not contentious?**\n> > >\n> > > Some people may write paragraphs about CTV being contentious, spread\n> misinformation and do all types of drama, politics etc. on social media but\n> there are zero technical NACKs for CTV. We have discussed other covenant\n> proposals in detail on mailing list and IRC meetings with an open minded\n> approach.\n> > >\n> > > All the developers that participated in the discussion are either okay\n> with CTV or OP_TX or covenants in general.\n> > >\n> > > **How and when should covenants be implemented in Bitcoin?**\n> > >\n> > > I don't think we should wait for years anticipating a proposal that\n> everyone will agree on or argue for years to pretend changes are hard in\n> Bitcoin. We should improve the review process for soft fork BIPs and share\n> honest opinions with agreement, disagreement on technical merits.\n> > >\n> > > I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind\n> anything else being used if that improves Bitcoin. Covenants implemented in\n> Bitcoin before the next cycle would provide opportunity for developers to\n> build interesting things during the bear market. Ossification supporters\n> also believe there is some window that will close soon, maybe doing changes\n> considering each case individually will be a better approach. CTV is not a\n> rushed soft fork, less people followed the research and it was not\n> mentioned on social media repeatedly by the respected developers like other\n> soft forks.\n> > >\n> > > /dev/fd0\n> > >\n> > >\n> > > Sent with Proton Mail secure email.\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220607/f8344db4/attachment-0001.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2022-06-08T09:22:41",
                "message_text_only": "Who do you mean by \"the non technical folks\"?\nYou don't include alicexbt or yourself as a \"technical folk\", do you?\n\n\nOn Wed, Jun 8, 2022 at 8:38 AM Billy Tetrud via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Wholeheartedly agree with you alicexbt. There are no technical issues that\n> have been shown that I'm aware of. Once the non-technical folks have time\n> to discuss it and realize that, I'm hopeful things will move forward.\n> Perhaps we can learn from this and figure out how to better catch the\n> attention of the larger bitcoin community  for important changes without\n> alarming them.\n>\n> On Sun, Jun 5, 2022 at 2:48 AM alicexbt via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Jorge,\n>>\n>>\n>> Misinformation is false or inaccurate information, especially that which\n>> is deliberately intended to deceive. A combination of 'misleading' and\n>> 'information'. Here are a few examples and I am sure I missed a lot of\n>> others but its difficult for me to keep a track of everything:\n>>\n>>\n>> 1) Sapio is open source and everything mentioned in tweet is false:\n>> https://web.archive.org/web/20220503050140/https://twitter.com/coinableS/status/1521354192434073602\n>>\n>> 2) Personal attacks on author of BIP 119 with false information:\n>> https://nitter.net/s3cp256k1/status/1521238634111770624\n>>\n>> 3) Andreas Antonopoulos shared false things about CTV and explained by\n>> Ryan in this email:\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020414.html\n>>\n>> 4) Misleading things shared in these emails by Michael Folkson:\n>>\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html\n>>\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html\n>>\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020286.html\n>>\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020343.html\n>>\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020386.html\n>>\n>> 5) Peter Todd and Zac shared misleading things about BIP 119, bitcoin and\n>> L2. I replied in this email:\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020322.html\n>>\n>> 6) Social media influencers like Peter McCormack tweeted they don't\n>> understand BIP 119 but its an attack (this was even retweeted by developers\n>> like Peter Todd):\n>> https://nitter.net/PeterMcCormack/status/1521253840963653632\n>>\n>> 7) Some misconceptions about BIP 119 cleared by Bitcoin Magazine:\n>> https://bitcoinmagazine.com/technical/what-is-bip-119-bitcoin-controversy-explained\n>>\n>> 8) There were lies and misinformation about BIP 119 on social media\n>> according to this Bitcoin Magazine article:\n>> https://bitcoinmagazine.com/technical/analyzing-bip119-and-the-controversy-surrounding-it\n>>\n>> 9) John Carvalho tweeting false things:\n>>\n>>     https://nitter.net/BitcoinErrorLog/status/1468599535538745359\n>>\n>>     https://nitter.net/BitcoinErrorLog/status/1522652884218822658\n>>\n>>     https://nitter.net/BitcoinErrorLog/status/1442554615967354880\n>>\n>>     https://nitter.net/search?q=MIT%20(from%3ABitcoinErrorLog)\n>>\n>> 10) Greg Maxwell responding to misinformation related to BIP 119 but\n>> adding false things in the comments:\n>> https://www.reddit.com/r/Bitcoin/comments/uim560/bip_119/i7dhfpb/\n>>\n>>\n>> I am not surprised by your email but it would be better if the people who\n>> are interested in reviewing BIP 119 could raise the bar and not share\n>> misleading information.\n>>\n>>\n>> /dev/fd0\n>>\n>>\n>> Sent with Proton Mail secure email.\n>> ------- Original Message -------\n>> On Sunday, June 5th, 2022 at 12:12 AM, Jorge Tim\u00f3n <jtimon at jtimon.cc>\n>> wrote:\n>>\n>>\n>> > \"Some people say CTV is contentious, but they're spreading\n>> misinformation\"? Really? Seriously?Come on, guys, we can do better than\n>> nina jankovich and the \"fact checkers\".\n>> > Please, rise the bar.\n>> > On Fri, Jun 3, 2022, 19:44 alicexbt via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> > > Note: This email is an opinion and not an attack on bitcoin\n>> > >\n>> > > Covenants on bitcoin will eventually be implemented with a soft fork.\n>> CTV is the easiest and best possible way OP_TX looks good as well. Apart\n>> from the technical merits, covenants will improve a few other things:\n>> > >\n>> > > - Developers can build interesting projects with real demand in\n>> market.\n>> > > - Students learn Sapio and not just solidity.\n>> > > - Better tooling could be available for application developers.\n>> > > - Maybe we see bitcoin developer hackathons in different countries.\n>> > > - Demand for block space might increase, it wont be just exchanges\n>> and coinjoin.\n>> > > - Funding of bitcoin developers and projects might improve. Wont need\n>> to convince a few people for grants.\n>> > >\n>> > > **Why covenants are not contentious?**\n>> > >\n>> > > Some people may write paragraphs about CTV being contentious, spread\n>> misinformation and do all types of drama, politics etc. on social media but\n>> there are zero technical NACKs for CTV. We have discussed other covenant\n>> proposals in detail on mailing list and IRC meetings with an open minded\n>> approach.\n>> > >\n>> > > All the developers that participated in the discussion are either\n>> okay with CTV or OP_TX or covenants in general.\n>> > >\n>> > > **How and when should covenants be implemented in Bitcoin?**\n>> > >\n>> > > I don't think we should wait for years anticipating a proposal that\n>> everyone will agree on or argue for years to pretend changes are hard in\n>> Bitcoin. We should improve the review process for soft fork BIPs and share\n>> honest opinions with agreement, disagreement on technical merits.\n>> > >\n>> > > I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind\n>> anything else being used if that improves Bitcoin. Covenants implemented in\n>> Bitcoin before the next cycle would provide opportunity for developers to\n>> build interesting things during the bear market. Ossification supporters\n>> also believe there is some window that will close soon, maybe doing changes\n>> considering each case individually will be a better approach. CTV is not a\n>> rushed soft fork, less people followed the research and it was not\n>> mentioned on social media repeatedly by the respected developers like other\n>> soft forks.\n>> > >\n>> > > /dev/fd0\n>> > >\n>> > >\n>> > > Sent with Proton Mail secure email.\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220608/59e93b9a/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-09T04:30:45",
                "message_text_only": "@jorge\n\n> Who do you mean by \"the non technical folks\"?\n\nI mean people that don't have software engineering skills. This is the\ntwittersphere, reddit, most podcasters, etc etc. This is the vast majority\nof the bitcoin community, and the vast majority of.. everyone.\n\n> You don't include alicexbt or yourself as a \"technical folk\", do you?\n\nI have no idea what alicexbt's skillset is. I do include myself. I have a\ndegree in software engineering. I work as a programmer in the bitcoin\nspace. I have written papers on technical aspects of bitcoin. Why would you\nassume that I'm not technical as someone who participates in the bitcoin\ndevelopers mailing list? Perhaps its projection?\n\nOn Wed, Jun 8, 2022 at 3:31 PM Jorge Tim\u00f3n via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Who do you mean by \"the non technical folks\"?\n> You don't include alicexbt or yourself as a \"technical folk\", do you?\n>\n>\n> On Wed, Jun 8, 2022 at 8:38 AM Billy Tetrud via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Wholeheartedly agree with you alicexbt. There are no technical issues\n>> that have been shown that I'm aware of. Once the non-technical folks have\n>> time to discuss it and realize that, I'm hopeful things will move forward.\n>> Perhaps we can learn from this and figure out how to better catch the\n>> attention of the larger bitcoin community  for important changes without\n>> alarming them.\n>>\n>> On Sun, Jun 5, 2022 at 2:48 AM alicexbt via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Jorge,\n>>>\n>>>\n>>> Misinformation is false or inaccurate information, especially that which\n>>> is deliberately intended to deceive. A combination of 'misleading' and\n>>> 'information'. Here are a few examples and I am sure I missed a lot of\n>>> others but its difficult for me to keep a track of everything:\n>>>\n>>>\n>>> 1) Sapio is open source and everything mentioned in tweet is false:\n>>> https://web.archive.org/web/20220503050140/https://twitter.com/coinableS/status/1521354192434073602\n>>>\n>>> 2) Personal attacks on author of BIP 119 with false information:\n>>> https://nitter.net/s3cp256k1/status/1521238634111770624\n>>>\n>>> 3) Andreas Antonopoulos shared false things about CTV and explained by\n>>> Ryan in this email:\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020414.html\n>>>\n>>> 4) Misleading things shared in these emails by Michael Folkson:\n>>>\n>>>\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html\n>>>\n>>>\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html\n>>>\n>>>\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020286.html\n>>>\n>>>\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020343.html\n>>>\n>>>\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020386.html\n>>>\n>>> 5) Peter Todd and Zac shared misleading things about BIP 119, bitcoin\n>>> and L2. I replied in this email:\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020322.html\n>>>\n>>> 6) Social media influencers like Peter McCormack tweeted they don't\n>>> understand BIP 119 but its an attack (this was even retweeted by developers\n>>> like Peter Todd):\n>>> https://nitter.net/PeterMcCormack/status/1521253840963653632\n>>>\n>>> 7) Some misconceptions about BIP 119 cleared by Bitcoin Magazine:\n>>> https://bitcoinmagazine.com/technical/what-is-bip-119-bitcoin-controversy-explained\n>>>\n>>> 8) There were lies and misinformation about BIP 119 on social media\n>>> according to this Bitcoin Magazine article:\n>>> https://bitcoinmagazine.com/technical/analyzing-bip119-and-the-controversy-surrounding-it\n>>>\n>>> 9) John Carvalho tweeting false things:\n>>>\n>>>     https://nitter.net/BitcoinErrorLog/status/1468599535538745359\n>>>\n>>>     https://nitter.net/BitcoinErrorLog/status/1522652884218822658\n>>>\n>>>     https://nitter.net/BitcoinErrorLog/status/1442554615967354880\n>>>\n>>>     https://nitter.net/search?q=MIT%20(from%3ABitcoinErrorLog)\n>>>\n>>> 10) Greg Maxwell responding to misinformation related to BIP 119 but\n>>> adding false things in the comments:\n>>> https://www.reddit.com/r/Bitcoin/comments/uim560/bip_119/i7dhfpb/\n>>>\n>>>\n>>> I am not surprised by your email but it would be better if the people\n>>> who are interested in reviewing BIP 119 could raise the bar and not share\n>>> misleading information.\n>>>\n>>>\n>>> /dev/fd0\n>>>\n>>>\n>>> Sent with Proton Mail secure email.\n>>> ------- Original Message -------\n>>> On Sunday, June 5th, 2022 at 12:12 AM, Jorge Tim\u00f3n <jtimon at jtimon.cc>\n>>> wrote:\n>>>\n>>>\n>>> > \"Some people say CTV is contentious, but they're spreading\n>>> misinformation\"? Really? Seriously?Come on, guys, we can do better than\n>>> nina jankovich and the \"fact checkers\".\n>>> > Please, rise the bar.\n>>> > On Fri, Jun 3, 2022, 19:44 alicexbt via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> >\n>>> > > Note: This email is an opinion and not an attack on bitcoin\n>>> > >\n>>> > > Covenants on bitcoin will eventually be implemented with a soft\n>>> fork. CTV is the easiest and best possible way OP_TX looks good as well.\n>>> Apart from the technical merits, covenants will improve a few other things:\n>>> > >\n>>> > > - Developers can build interesting projects with real demand in\n>>> market.\n>>> > > - Students learn Sapio and not just solidity.\n>>> > > - Better tooling could be available for application developers.\n>>> > > - Maybe we see bitcoin developer hackathons in different countries.\n>>> > > - Demand for block space might increase, it wont be just exchanges\n>>> and coinjoin.\n>>> > > - Funding of bitcoin developers and projects might improve. Wont\n>>> need to convince a few people for grants.\n>>> > >\n>>> > > **Why covenants are not contentious?**\n>>> > >\n>>> > > Some people may write paragraphs about CTV being contentious, spread\n>>> misinformation and do all types of drama, politics etc. on social media but\n>>> there are zero technical NACKs for CTV. We have discussed other covenant\n>>> proposals in detail on mailing list and IRC meetings with an open minded\n>>> approach.\n>>> > >\n>>> > > All the developers that participated in the discussion are either\n>>> okay with CTV or OP_TX or covenants in general.\n>>> > >\n>>> > > **How and when should covenants be implemented in Bitcoin?**\n>>> > >\n>>> > > I don't think we should wait for years anticipating a proposal that\n>>> everyone will agree on or argue for years to pretend changes are hard in\n>>> Bitcoin. We should improve the review process for soft fork BIPs and share\n>>> honest opinions with agreement, disagreement on technical merits.\n>>> > >\n>>> > > I prefer BIP 8 or improved BIP 8 for soft fork but I won't mind\n>>> anything else being used if that improves Bitcoin. Covenants implemented in\n>>> Bitcoin before the next cycle would provide opportunity for developers to\n>>> build interesting things during the bear market. Ossification supporters\n>>> also believe there is some window that will close soon, maybe doing changes\n>>> considering each case individually will be a better approach. CTV is not a\n>>> rushed soft fork, less people followed the research and it was not\n>>> mentioned on social media repeatedly by the respected developers like other\n>>> soft forks.\n>>> > >\n>>> > > /dev/fd0\n>>> > >\n>>> > >\n>>> > > Sent with Proton Mail secure email.\n>>> > > _______________________________________________\n>>> > > bitcoin-dev mailing list\n>>> > > bitcoin-dev at lists.linuxfoundation.org\n>>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220608/e460f937/attachment-0001.html>"
            },
            {
                "author": "Ryan Grant",
                "date": "2022-06-09T00:03:07",
                "message_text_only": "I think Jorge's request for specifics is reasonable.  I agree that we\ncan raise the level of discussion.  Each claim about how good or bad a\nspecific BIP is should say why on the technical merits.  Comments on\nprior claims may expose misinformation, expose \"trust me\" authority,\nor point out other fallacies.  They should include a citation of the\noriginal source, a fair restatement of the problematic claim for\ncurrent readers, and a short explanation of why it doesn't advance\nunderstanding technical consensus.\n\nThere have been lots of mean comments.  Some \"Truth and\nReconciliation\" will come due, and it will be a huge amount of work.\nAnother history book?"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin covenants are inevitable",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "Eric Voskuil",
                "Manuel Costa",
                "Corey Haddad",
                "micaroni at gmail.com",
                "Kate Salazar",
                "Keagan McClelland",
                "Alex Lee",
                "John Carvalho",
                "Peter Todd",
                "alicexbt",
                "Jorge Tim\u00f3n",
                "Erik Aronesty",
                "Billy Tetrud"
            ],
            "messages_count": 31,
            "total_messages_chars_count": 110964
        }
    },
    {
        "title": "[bitcoin-dev] Using Merged Mining on a separate zero supply chain, instead of sidechains",
        "thread_messages": [
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2022-06-04T15:33:43",
                "message_text_only": "Some people think that sidechains are good. But to put them into some working solution, people think that some kind of soft-fork is needed. However, it seems that it can be done in a no-fork way, here is how to make it permissionless, and introduce them without any forks.\n\nFirst, we should make a new chain that has zero coins. When the coin supply is zero, it can be guaranteed that this chain is not generating any coins out of thin air. Then, all that is needed, is to introduce coins to this chain, just by signing a transaction from other chains, for example Bitcoin. In this way, people can make signatures in a signet way, just to sign their transaction output of any type, without moving real coins on the original chain.\n\nThen, all that is needed, is to make a way to withdraw the coins. It could be done by publishing the transaction from the original chain. It can be copy-pasted to our chain, and can be used to destroy coins that were produced earlier. In this way, our Merge-Mined chain has zero supply, and can only temporary store some coins from other chains.\n\nCreating and destroying coins from other chains is enough to make a test network. To make it independent, one more thing is needed, to get a mainnet solution: moving coins inside that chain. When it comes to that, the only limitation is the locking script. Normally, it is locked to some public key, then by forming a signature, it is possible to move coins somewhere else. In the Lightning Network, it is solved by forming 2-of-2 multisig, then coins can be moved by changing closing transactions.\n\nBut there is another option: transaction joining. So, if we have a chain of transactions: A->B->C->...->Z, then if transaction joining is possible, it can be transformed into A->Z transaction. After adding that missing piece, sidechains can be enabled.\n\nHowever, I mentioned before that this solution would require no forks. It could, if we consider using Homomorphic Encryption. Then, it is possible to add new features, without touching consensus. For example, by using Homomorphic Encryption, it is possible to execute 2-of-2 multisig on some P2PK output. That means, more things are possible, because if we can encrypt things, then operate on encrypted data, and later decrypt it (and broadcast to the network), then it can open a lot of new possible upgrades, that will be totally permissionless and unstoppable.\n\nSo, to sum up: by adding transaction joining in a homomorphic-encryption-way, it may be possible to introduce sidechains in a no-fork way, no matter if people wants that or not. Also, it is possible to add the hash of our chain to the signature inside a Bitcoin transaction, then all data from the \"zero supply chain\" can be committed to the Bitcoin blockchain, that would prevent overwriting history. Also, Merged Mining could be used to reward sidechain miners, so they will be rewarded inside the sidechain."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2022-06-05T16:37:24",
                "message_text_only": "Good morning vjudeu,\n\n\n> Some people think that sidechains are good. But to put them into some working solution, people think that some kind of soft-fork is needed. However, it seems that it can be done in a no-fork way, here is how to make it permissionless, and introduce them without any forks.\n>\n> First, we should make a new chain that has zero coins. When the coin supply is zero, it can be guaranteed that this chain is not generating any coins out of thin air. Then, all that is needed, is to introduce coins to this chain, just by signing a transaction from other chains, for example Bitcoin. In this way, people can make signatures in a signet way, just to sign their transaction output of any type, without moving real coins on the original chain.\n>\n> Then, all that is needed, is to make a way to withdraw the coins. It could be done by publishing the transaction from the original chain. It can be copy-pasted to our chain, and can be used to destroy coins that were produced earlier. In this way, our Merge-Mined chain has zero supply, and can only temporary store some coins from other chains.\n>\n> Creating and destroying coins from other chains is enough to make a test network. To make it independent, one more thing is needed, to get a mainnet solution: moving coins inside that chain. When it comes to that, the only limitation is the locking script. Normally, it is locked to some public key, then by forming a signature, it is possible to move coins somewhere else. In the Lightning Network, it is solved by forming 2-of-2 multisig, then coins can be moved by changing closing transactions.\n>\n> But there is another option: transaction joining. So, if we have a chain of transactions: A->B->C->...->Z, then if transaction joining is possible, it can be transformed into A->Z transaction. After adding that missing piece, sidechains can be enabled.\n>\n>\n> However, I mentioned before that this solution would require no forks. It could, if we consider using Homomorphic Encryption. Then, it is possible to add new features, without touching consensus. For example, by using Homomorphic Encryption, it is possible to execute 2-of-2 multisig on some P2PK output. That means, more things are possible, because if we can encrypt things, then operate on encrypted data, and later decrypt it (and broadcast to the network), then it can open a lot of new possible upgrades, that will be totally permissionless and unstoppable.\n>\n> So, to sum up: by adding transaction joining in a homomorphic-encryption-way, it may be possible to introduce sidechains in a no-fork way, no matter if people wants that or not. Also, it is possible to add the hash of our chain to the signature inside a Bitcoin transaction, then all data from the \"zero supply chain\" can be committed to the Bitcoin blockchain, that would prevent overwriting history. Also, Merged Mining could be used to reward sidechain miners, so they will be rewarded inside the sidechain.\n\nI proposed something similar years ago --- more specifically, some kind of general ZKP system would allow us to pretty much write anything, and if it terminates, we can provide a ZKP of the execution trace.\n\nAt the time it was impractical due to the ZKP systems of the time being *still* too large and too CPU-heavy *and* requiring a tr\\*sted setup.\n\nEncrypting the amount in a homomorphic encryption such as Pedersen commitments / ElGamal commitments is how MimbleWimble coins (such as Grin) work.\nThey achieve transactional cut-through in a similar manner due to the homomorphic encryption being what is validated by validators without revealing the exact balances, and with the only requirement being that a set of consumed outputs equals the set of created outputs (fees being an explicit output that has no encryption, and thus can be claimable by anyone and have a known value, which basically means that it is the miner that mines the transaction that can claim it).\n\nRegards,\nZmnSCPxj\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Using Merged Mining on a separate zero supply chain, instead of sidechains",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "vjudeu at gazeta.pl"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6874
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-dev Digest, Vol 85, Issue 4",
        "thread_messages": [
            {
                "author": "Luke Kenneth Casson Leighton",
                "date": "2022-06-05T12:31:31",
                "message_text_only": "(apologies i am subscribed digest)\n\nOn Sun, Jun 5, 2022 at 1:00 PM\n<bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Date: Sun, 05 Jun 2022 04:18:04 +0000\n> From: alicexbt <alicexbt at protonmail.com>\n> To: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Bitcoin covenants are inevitable\n> Message-ID:\n>         <zyE-uR_2M7vAE8jXf3wthIGQj_-dz9FoL50ERTmCb-MCv4zyMgoHAdSff539SPtROJpJdgrfBspM3IZJrNQ9V4kpDnyMB9X6mlWf0eSk1Rk=@protonmail.com>\n> Hi Jorge,\n>\n>\n> Misinformation is false or inaccurate information, especially that which is deliberately intended to deceive.\n> A combination of 'misleading' and 'information'.\n\nit's a classic technique that was refined by psy-ops well over\n60 years ago.  it should come as no surprise at all that it is\nbeing systematically deployed to undermine bitcoin.\n(welcome to the party, all psy-ops teams reading this: i admire your\n persistence and tenacity. you serve an extremely useful purpose\n of detecting flaws in the resilience of bitcoin and its development.)\n\na potential solution is Trust Metrics. the most successful open\nsource experiment in that regard was advogato.org by Raph Levien.\n\ni expanded it greatly so that any user could specify the \"seeds\"\nwhom *they* trusted, rather than being forced to utilise the fixed\nhard-coded user ids in the advogato.org source code (this difference\nis extremely important for de-centralisation)\n\npublic declarations of trust, and their propagation through standard\nMaximum-Flow Graph analysis, helps greatly to filter out the crap.\nadvogato deflected heavy systematic and sustained spam attacks\nthanks to the simple expedient of users declaring publicly whom\nthey trusted.\n\na more advanced version of the max-flow concept came up a few\nyears later called keynote (RFC2704)\n\nthe similarity between trust metric evaluation and the bitcoin protocol\nis so remarkable that i am, frankly, slightly stunned that it was not\nadded right from the start.\n\nit is ironic that the lack of integrated trust metric evaluation built-in\nto the bitcoin protocol is now hampering developers from being able\nto evaluate whom to trust when it comes to protocol development.\n\nl."
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-08T04:05:33",
                "message_text_only": "That sounds like an interesting mechanism to help measure consensus - and a\ngood way to do that would help bitcoin significantly I think. I don't quite\nsee what the similarity is between Trust Metric and bitcoin tho. How\nwould you propose \"building it into\" bitcoin?\n\n>From my limited searching, it looks like trust metric is basically a graph\nof who trusts who, allowing you to quantify who's trusted among a\nparticular set or subset of people. Is that right? I would think such a\nthing can be done completely separately from bitcoin, but used to answer\nquestions about bitcoin.\n\nI'm curious to know specifically how the metric works and how its resistant\nto adversaries, specifically how its sybil resistant. In particular I'm\ncurious what weaknesses it has that could be gamed. It seems sybil\nresistance might be there for a while, but I can imagine that it might be\npossible for a colluding set of users to farm aliases with higher and\nhigher reputation until they could take over the network. In bitcoin, there\nare good ways of bolstering such sybil resistance, eg by charging fees for\nidentities in some way, or by requiring proof of funds.\n\nOn Sun, Jun 5, 2022 at 8:19 AM Luke Kenneth Casson Leighton via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> (apologies i am subscribed digest)\n>\n> On Sun, Jun 5, 2022 at 1:00 PM\n> <bitcoin-dev-request at lists.linuxfoundation.org> wrote:\n>\n> > Date: Sun, 05 Jun 2022 04:18:04 +0000\n> > From: alicexbt <alicexbt at protonmail.com>\n> > To: Bitcoin Protocol Discussion\n> >         <bitcoin-dev at lists.linuxfoundation.org>\n> > Subject: Re: [bitcoin-dev] Bitcoin covenants are inevitable\n> > Message-ID:\n> >\n>  <zyE-uR_2M7vAE8jXf3wthIGQj_-dz9FoL50ERTmCb-MCv4zyMgoHAdSff539SPtROJpJdgrfBspM3IZJrNQ9V4kpDnyMB9X6mlWf0eSk1Rk=@\n> protonmail.com>\n> > Hi Jorge,\n> >\n> >\n> > Misinformation is false or inaccurate information, especially that which\n> is deliberately intended to deceive.\n> > A combination of 'misleading' and 'information'.\n>\n> it's a classic technique that was refined by psy-ops well over\n> 60 years ago.  it should come as no surprise at all that it is\n> being systematically deployed to undermine bitcoin.\n> (welcome to the party, all psy-ops teams reading this: i admire your\n>  persistence and tenacity. you serve an extremely useful purpose\n>  of detecting flaws in the resilience of bitcoin and its development.)\n>\n> a potential solution is Trust Metrics. the most successful open\n> source experiment in that regard was advogato.org by Raph Levien.\n>\n> i expanded it greatly so that any user could specify the \"seeds\"\n> whom *they* trusted, rather than being forced to utilise the fixed\n> hard-coded user ids in the advogato.org source code (this difference\n> is extremely important for de-centralisation)\n>\n> public declarations of trust, and their propagation through standard\n> Maximum-Flow Graph analysis, helps greatly to filter out the crap.\n> advogato deflected heavy systematic and sustained spam attacks\n> thanks to the simple expedient of users declaring publicly whom\n> they trusted.\n>\n> a more advanced version of the max-flow concept came up a few\n> years later called keynote (RFC2704)\n>\n> the similarity between trust metric evaluation and the bitcoin protocol\n> is so remarkable that i am, frankly, slightly stunned that it was not\n> added right from the start.\n>\n> it is ironic that the lack of integrated trust metric evaluation built-in\n> to the bitcoin protocol is now hampering developers from being able\n> to evaluate whom to trust when it comes to protocol development.\n>\n> l.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220607/917931e8/attachment.html>"
            },
            {
                "author": "Billy Tetrud",
                "date": "2022-06-15T04:02:38",
                "message_text_only": ">   two aspects to consensus\n\nWell, consensus isn't just one thing with two aspects. There are many\nthings one might ask for consensus about, and many groups you might ask for\nit from. There's miner consensus about transaction ordering, miner\nconsensus about soft fork signaling, developer consensus about the\ndesirability and readiness of a particular change (to the code / miner\nconsensus rules), there's consensus about these changes from various sub\ncommunities within and related to bitcoin, and the broader consensus of the\nwhole bitcoin community. And probably many others. Most of these types of\nconsensus involve trust to various degrees. I think that's what  you mean\nby there being more than one aspect of consensus, yes?\n\n> the live advogato system .. remained 100% spam-free of off-topic articles\nthroughout its entire life.\n\nVery impressive!\n\n>  if those pseudo-identities are not linked to anyone .. they .. remain\nisolated.\n\nI see. Because anyone measuring consensus is only measuring it with respect\nto their own trust network, anyone not transitively trusted by the person\nmeasuring consensus is simply ignored.\n\n> i made some modifications that required a *minimum number* of incoming\nTrust Declarations before Flow was permitted to cross outwards.\n\nI wouldn't think this is sufficient, since an attacker could put in effort\nto achieve whatever minimum you come up with. For example, an attacker\ncould pose as someone with a particular popular point of view, put in\neffort to produce actual helpful content that's interesting to their target\naudience, and therefore get plenty of trust from people, but then they\ncould mark themselves as trusting of various sock puppets. The only way I\ncan think of solving that problem is for people in the community to be able\nto investigate and somehow recognize something's weird about who that\noutwardly helpful person trusts and detrust them because of it. Are there\nother mechanisms to deal with this kind of thing, maybe as part of Keynote?\n\n> hilariously, such isolated networks, being easy to identify, and also\nentirely public, allow the existence of attackers to come to public\nawareness.\n\nI suppose this is related to my thought above.\n\n> negative Certs were discussed but never implemented because they could do\nmore harm than good.\n\nHow so?\n\n> the other weakess is: *it takes discipline to maintain*. you cannot\nincentivise people to do this kind of thing without risking invitation of\nbribery.\n\nWhat do you mean by \"discipline\"? Discipline amongst who? The whole\nnetwork? The operator of something like Avogato? An individual who wants to\nmeasure consensus?\n\n> a zero-value transaction gets the entry into the chain.\n> who on earth wants to pay BTC to make some \"stupid\" declaration of whom\nthey \"trust\"?\n\nI don't see a reason to commit any of this data to the blockchain. Why not\njust have a network where nodes collect and/or query for the data they\nneed? Such a thing would be far less expensive (could potentially even be\nfree). Since declarations of trust are always signed, they're all\nverifiable. There's no double spending problem here because any \"double\nspend\" (ie two signed conflicting declarations) only serves to dilute or\nnullify that person's contribution to consensus (which is basically only\nbad for the \"double spender\"). If one wanted to connect a signed\ndeclaration to a block, they could simply include the block hash in the\nsignature, which would verify that the declaration was signed after that\nblock happened, and it could mean that the declaration is valid from that\nblock until a new declaration is signed with a newer block's hash. If one\nwanted to but some financial barriers in place to limit sybil attacks, you\ncould require a zero-value transaction that records the public key (or a\nhash of the public key) like you mentioned. However, rather than charging a\nfee to register a public key, you could instead simply require that the\npublic key be associated with UTXOs. This works best when it makes sense to\nweight any declaration by the value contained in the associated UTXOs, like\nI suggest doing with coin-weighted polling here\n<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-March/020146.html>\n.\n\n\nOn Thu, Jun 9, 2022 at 6:34 AM lkcl <luke.leighton at gmail.com> wrote:\n\n> ------------------------------\n> crowd-funded eco-conscious hardware: https://www.crowdsupply.com/eoma68\n>\n> On Wed, Jun 8, 2022 at 5:05 AM Billy Tetrud <billy.tetrud at gmail.com>\n> wrote:\n> >\n> > That sounds like an interesting mechanism to help measure consensus -\n>\n> it is related to consensus but is not consensus as bitcoin sees it.\n>\n> there are two aspects to consensus:\n>\n> 1) the public declarations of \"trust\" (or other declarations)\n> 2) the programmatic evaluation of the same resulting in automated\n> decisions.\n>\n> conflating these two or assuming them to be inextricably intertwined\n> results in severe limitations of the possible applications of bitcoin.\n>\n> > and a good way to do that would help bitcoin significantly I think. I\n> don't quite see what the similarity is between Trust Metric and bitcoin\n> tho.\n>\n> the mining is a \"public declaration\" where the \"trust\" may be\n> computationally verified. it is... slightly different but similar enough to\n> be able to fit\n>\n> >How would you propose \"building it into\" bitcoin?\n>\n> without requiring going through a BEP for that, use of the comment field\n> would suffice. a zero-value transaction gets the entry into the chain.\n>\n> the comments can include a URL or a hash of a URL (if the conversation is\n> supposed to be private), and must include a hash of an identity which can\n> be verified (GPG Key, a BTC Wallet known to be linked to a user). yes, the\n> end-result here is that the blockchain subsumes the role of a web-of-trust\n> as part of the Operational Requirements [you can't have trust unless the\n> pseudonym is provably-linkable to a user in a verifiable way. Monero\n> protocol springs to mind here, as does Debian's GPG Key-signing protocols]\n>\n>\n> from there it becomes a matter of writing programs that parse the chain,\n> extracting the comments, parse them, and perform a \"trust evaluation\".\n>\n>\n> note that these programs *do not* rely on any centralised party. any user\n> may decide the \"top-level seeds\" (whom they implicitly trust 100%) which\n> may only be themselves.\n>\n> > From my limited searching, it looks like trust metric is basically a\n> graph of who trusts who, allowing you to quantify who's trusted among a\n> particular set or subset of people. Is that right?\n>\n> using Transitive Relationships, yes. A trusts B, B trusts C, therefore it\n> is reasonable for A to trust C (to some extent). If A trusts B *and* D, and\n> both B *and* D trust C, thenA has a much higher level of confidence that\n> they can trust C than in the first scenario.\n>\n> the use of the Ford-Fulkersson Max Flow Algorithm allows for an unordered\n> graph of such \"Trust Declarations\" to be turned into a Directed Acyclic\n> Graph, with weighting in order to deliberately \"peter out\" the possibility\n> of long-distance Transitive Chains from being \"faulty\".\n>\n> [btw in pymmetry i did *not* use depth-first, as in Ford-Fulkersson, i\n> used breadth-first. the cost of depth-first will be insane in a network as\n> large as BTC]\n>\n> What is nice about the Max Flow Algorithm is that should there be a large\n> genuine cluster of Declarations into a node that is a large number of\n> degrees away from the \"seeds\", that node can still potentially receive a\n> positive evaluation. Likewise, Nodes that have a limited number of\n> Declarations get quickly filtered out.\n>\n> > I would think such a thing can be done completely separately from\n> bitcoin, but used to answer questions about bitcoin.\n>\n> indeed. and many other uses.\n>\n> > I'm curious to know specifically how the metric works and how its\n> resistant to adversaries, specifically how its sybil resistant.\n>\n> had to look that up\n> https://en.m.wikipedia.org/wiki/Sybil_attack\n>\n> ok, so if those pseudo-identities are not linked to anyone that is linked\n> to the \"seeds\", they can create as many Trust Declarations in between\n> themselves as they damn well like: they get f***-all flow and consequently\n> remain isolated.\n>\n> this was exactly what happened on the live advogato system and it remained\n> 100% spam-free of off-topic articles throughout its entire life.\n>\n> > In particular I'm curious what weaknesses it has that could be gamed.\n>\n> rright. the problem comes if someone who *does* have Transitive Flow of\n> Trust is fooled by the puppets into making a Declaration, \"I trust one of\n> these puppets because what they said looked reasonable to me at the time\".\n>\n> and this was a weakness of the *original* advogato algorithm, because the\n> application of the Ford Fulkersson algorithm was naive \"flow in from edge\n> equals flow out\".\n>\n> i made some modifications that required a *minimum number* of incoming\n> Trust Declarations before Flow was permitted to cross outwards.\n>\n> this led me to investigate Keynote (RFC2704) because i realised that there\n> may be circumstances for which much more sophisticated Gating would be\n> needed, and Keynote is perfect for that.\n>\n> (you could in theory use bitcoin scripts, but they're not really up to the\n> task, as designed)\n>\n> revocation is needed, here, which will be interesting on top of a\n> blockchain, for when people realise they've been duped.\n>\n>\n> > It seems sybil resistance might be there for a while, but I can imagine\n> that it might be possible for a colluding set of users to farm aliases with\n> higher and higher reputation until they could take over the network.\n>\n> they can try but as i said above, if no Transitive Relationship exists to\n> them, they can basically do whatever they like.\n>\n> hilariously, such isolated networks, being easy to identify, and also\n> entirely public, allow the existence of attackers to come to public\n> awareness.\n>\n> the only reason why such attackers can f*** with Facebook etc. is\n> precisely because the attacks are behind the secretive closed doors of\n> proprietary systems.\n>\n> if the entire database is public they have nowhere to hide.\n>\n>\n> the other weakness of the original system was that there was neither\n> expiry, revocation, nor \"negative\" Certs. people abandoned their account,\n> someone misbehaved, and the Certs flowing to the misbehaving person\n> remained.\n>\n> negative Certs were discussed but never implemented because they could do\n> more harm than good.\n>\n> i wrote over a hundred articles on advogato, and Raph received MULTIPLE\n> DEMANDS from really quite prominent Open Source Developers who had\n> absolutely no business at all demanding Censorship and the removal of those\n> articles. Raph pointed them at the *150* \"Master\" Level Certs i had\n> received (which was a lot), and informed them that only when all 150 of\n> those Certs were removed by each of those individuals, many of whom were\n> also respected Community Members, would my \"Master\" Level drop and their\n> demands that i no longer be permitted to post Articles would automatically\n> and inherently be met.\n>\n> there's nothing that can be done about defamation or social abuse, in\n> other words. just because technology exists doesn't make people become more\n> humane.\n>\n>\n> the other weakess is: *it takes discipline to maintain*. you cannot\n> incentivise people to do this kind of thing without risking invitation of\n> bribery. there were enough people begging \"please Cert me\" on underground\n> forums as it was.\n>\n>\n> > In bitcoin, there are good ways of bolstering such sybil resistance, eg\n> by charging fees for identities in some way, or by requiring proof of funds.\n>\n> through requiring that the Trust Declarations be actual bitcoin\n> transactions, that helps as well.\n>\n> the only problem then becomes a practical social one: who on earth wants\n> to pay BTC to make some \"stupid\" declaration of whom they \"trust\"? and,\n> more than that: are the *developers themselves* being actually paid enough\n> in BTC such that they can *afford* to make a Declaration?\n>\n> or, sorry, crictical, critical correction: separating the Declaration from\n> the payment threshold is important! anyone should be able to enter a\n> zero-value Transaction with a Declaration of Trust, but whether their\n> Declaration is *included in the Graph Processing* would be (a la Keynote)\n> down to the independent post-processing.\n>\n> for example, if a Developer has five hundred incoming Declarations of\n> Trust and they are only one degree away from the \"seeds\", it should be\n> blindingly obvious that charging them for making Declarations is\n> unnecessary. this \"rule\" would be expressed a la Keynote\n>\n> these things can be solved in other words.\n>\n> l.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/4276a352/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev Digest, Vol 85, Issue 4",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Kenneth Casson Leighton",
                "Billy Tetrud"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 19105
        }
    },
    {
        "title": "[bitcoin-dev] Package Relay Proposal",
        "thread_messages": [
            {
                "author": "Gloria Zhao",
                "date": "2022-06-07T17:44:45",
                "message_text_only": "Hi Eric, aj, all,\n\nSorry for the delayed response. @aj I'm including some paraphrased points\nfrom our offline discussion (thanks).\n\n> Other idea: what if you encode the parent txs as a short hash of the\nwtxid (something like bip152 short ids? perhaps seeded per peer so\ncollisions will be different per peer?) and include that in the inv\nannouncement? Would that work to avoid a round trip almost all of the time,\nwhile still giving you enough info to save bw by deduping parents?\n\n> As I suggested earlier, a package is fundamentally a compact block (or\n> block) announcement without the header. Compact block (BIP152)\nannouncement\n> is already well-defined and widely implemented...\n\n> Let us not reinvent the wheel and/or introduce accidental complexity. I\nsee\n> no reason why packaging is not simply BIP152 without the 'header' field,\nan\n> updated protocol version, and the following sort of changes to names\n\nInterestingly, \"why not use BIP 152 shortids to save bandwidth?\" is by far\nthe most common suggestion I hear (including offline feedback). Here's a\nfull explanation:\n\nBIP 152 shortens transaction hashes (32 bytes) to shortids (6 bytes) to\nsave a significant amount of network bandwidth, which is extremely\nimportant in block relay. However, this comes at the expense of\ncomputational complexity. There is no way to directly calculate a\ntransaction hash from a shortid; upon receipt of a compact block, a node is\nexpected to calculate the shortids of every unconfirmed transaction it\nknows about to find the matches (BIP 152: [1], Bitcoin Core: [2]). This is\nexpensive but appropriate for block relay, since the block must have a\nvalid Proof of Work and new blocks only come every ~10 minutes. On the\nother hand, if we require nodes to calculate shortids for every transaction\nin their mempools every time they receive a package, we are creating a DoS\nvector. Unconfirmed transactions don't need PoW and, to have a live\ntransaction relay network, we should expect nodes to handle transactions at\na high-ish rate (i.e. at least 1000s of times more transactions than\nblocks). We can't pre-calculate or cache shortids for mempool transactions,\nsince the SipHash key depends on the block hash and a per-connection salt.\n\nAdditionally, shortid calculation is not designed to prevent intentional\nindividual collisions. If we were to use these shortids to deduplicate\ntransactions we've supposedly already seen, we may have a censorship\nvector. Again, these tradeoffs make sense for compact block relay (see\nshortid section in BIP 152 [3]), but not package relay.\n\nTLDR: DoSy if we calculate shortids on every package and censorship vector\nif we use shortids for deduplication.\n\n> Given this message there is no reason\n> to send a (potentially bogus) fee rate with every package. It can only be\n\n> validated by obtaining the full set of txs, and the only recourse is\n> dropping (etc.) the peer, as is the case with single txs.\n\nYeah, I agree with this. Combined with the previous discussion with aj\n(i.e. we can't accurately communicate the incentive compatibility of a\npackage without sending the full graph, and this whole dance is to avoid\ndownloading a few low-fee transactions in uncommon edge cases), I've\nrealized I should remove the fee + weight information from pkginfo. Yay for\nless complexity!\n\nAlso, this might be pedantic, but I said something incorrect earlier and\nwould like to correct myself:\n\n>> In theory, yes, but maybe it was announced earlier (while our node was\ndown?) or had dropped from our mempool or similar, either way we don't have\nthose txs yet.\n\nI said \"It's fine if they have Erlay, since a sender would know in advance\nthat B is missing and announce it as a package.\" But this isn't true since\nwe're only using reconciliation in place of flooding to announce\ntransactions as they arrive, not for rebroadcast, and we're not doing full\nmempool set reconciliation. In any case, making sure a node receives the\ntransactions announced when it was offline is not something we guarantee,\nnot an intended use case for package relay, and not worsened by this.\n\nThanks for your feedback!\n\nBest,\nGloria\n\n[1]:\nhttps://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#cmpctblock\n[2]:\nhttps://github.com/bitcoin/bitcoin/blob/master/src/blockencodings.cpp#L49\n[3]:\nhttps://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#short-transaction-id-calculation\n\nOn Thu, May 26, 2022 at 3:59 AM <eric at voskuil.org> wrote:\n\n> Given that packages have no header, the package requires identity in a\n> BIP152 scheme. For example 'header' and 'blockhash' fields can be replaced\n> with a Merkle root (e.g. \"identity\" field) for the package, uniquely\n> identifying the partially-ordered set of txs. And use of 'getdata' (to\n> obtain a package by hash) can be eliminated (not a use case).\n>\n> e\n>\n> > -----Original Message-----\n> > From: eric at voskuil.org <eric at voskuil.org>\n> > Sent: Wednesday, May 25, 2022 1:52 PM\n> > To: 'Anthony Towns' <aj at erisian.com.au>; 'Bitcoin Protocol Discussion'\n> > <bitcoin-dev at lists.linuxfoundation.org>; 'Gloria Zhao'\n> > <gloriajzhao at gmail.com>\n> > Subject: RE: [bitcoin-dev] Package Relay Proposal\n> >\n> > > From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On\n> > Behalf\n> > > Of Anthony Towns via bitcoin-dev\n> > > Sent: Wednesday, May 25, 2022 11:56 AM\n> >\n> > > So the other thing is what happens if the peer announcing packages to\n> us\n> > is\n> > > dishonest?\n> > >\n> > > They announce pkg X, say X has parents A B C and the fee rate is\n> garbage.\n> > But\n> > > actually X has parent D and the fee rate is excellent. Do we request\n> the\n> > > package from another peer, or every peer, to double check? Otherwise\n> > we're\n> > > allowing the first peer we ask about a package to censor that tx from\n> us?\n> > >\n> > > I think the fix for that is just to provide the fee and weight when\n> > announcing\n> > > the package rather than only being asked for its info? Then if one peer\n> > makes\n> > > it sound like a good deal you ask for the parent txids from them,\n> dedupe,\n> > > request, and verify they were honest about the parents.\n> >\n> > Single tx broadcasts do not carry an advertised fee rate, however the'\n> > feefilter' message (BIP133) provides this distinction. This should be\n> > interpreted as applicable to packages. Given this message there is no\n> reason\n> > to send a (potentially bogus) fee rate with every package. It can only be\n> > validated by obtaining the full set of txs, and the only recourse is\n> > dropping (etc.) the peer, as is the case with single txs. Relying on the\n> > existing message is simpler, more consistent, and more efficient.\n> >\n> > > >> Is it plausible to add the graph in?\n> > >\n> > > Likewise, I think you'd have to have the graph info from many nodes if\n> > you're\n> > > going to make decisions based on it and don't want hostile peers to be\n> > able to\n> > > trick you into ignoring txs.\n> > >\n> > > Other idea: what if you encode the parent txs as a short hash of the\n> wtxid\n> > > (something like bip152 short ids? perhaps seeded per peer so collisions\n> > will\n> > > be different per peer?) and include that in the inv announcement? Would\n> > > that work to avoid a round trip almost all of the time, while still\n> giving\n> > you\n> > > enough info to save bw by deduping parents?\n> >\n> > As I suggested earlier, a package is fundamentally a compact block (or\n> > block) announcement without the header. Compact block (BIP152)\n> > announcement\n> > is already well-defined and widely implemented. A node should never be\n> > required to retain an orphan, and BIP152 ensures this is not required.\n> >\n> > Once a validated set of txs within the package has been obtained with\n> > sufficient fee, a fee-optimal node would accept the largest subgraph of\n> the\n> > package that conforms to fee constraints and drop any peer that provides\n> a\n> > package for which the full graph does not.\n> >\n> > Let us not reinvent the wheel and/or introduce accidental complexity. I\n> see\n> > no reason why packaging is not simply BIP152 without the 'header' field,\n> an\n> > updated protocol version, and the following sort of changes to names:\n> >\n> > sendpkg\n> > MSG_CMPCT_PKG\n> > cmpctpkg\n> > getpkgtxn\n> > pkgtxn\n> >\n> > > > For a maximum 25 transactions,\n> > > >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.\n> > >\n> > > If you're doing short ids that's maybe 25*4B=100B already, then the\n> above\n> > is\n> > > up to 36% overhead, I guess. Might be worth thinking more about, but\n> > maybe\n> > > more interesting with ancestors than just parents.\n> > >\n> > > >Also side note, since there are no size/count params,\n> >\n> > Size is restricted in the same manner as block and transaction\n> broadcasts,\n> > by consensus. If the fee rate is sufficient there would be no reason to\n> > preclude any valid size up to what can be mined in one block (packaging\n> > across blocks is not economically rational under the assumption that one\n> > miner cannot expect to mine multiple blocks in a row). Count is\n> incorporated\n> > into BIP152 as 'shortids_length'.\n> >\n> > > > wondering if we\n> > > >should just have \"version\" in \"sendpackages\" be a bit field instead of\n> > > >sending a message for each version. 32 versions should be enough\n> right?\n> >\n> > Adding versioning to individual protocols is just a reflection of the\n> > insufficiency of the initial protocol versioning design, and that of the\n> > various ad-hoc changes to it (including yet another approach in this\n> > proposal) that have been introduced to compensate for it, though I'll\n> > address this in an independent post at some point.\n> >\n> > Best,\n> > e\n> >\n> > > Maybe but a couple of messages per connection doesn't really seem worth\n> > > arguing about?\n> > >\n> > > Cheers,\n> > > aj\n> > >\n> > >\n> > > --\n> > > Sent from my phone.\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220607/d32c46dd/attachment.html>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2022-06-08T15:59:03",
                "message_text_only": "Hi,\n\nThanks again for your work on this!\n\nOne question I have is about potential bandwidth waste in the case of nodes\nrunning with different policy rules.  Here's my understanding of a scenario\nI think could happen:\n\n1) Transaction A is both low-fee and non-standard to some nodes on the\nnetwork.\n2) Whenever a transaction T that spends A is relayed, new nodes will send\nINV(PKGINFO1, T) to all package-relay peers.\n3) Nodes on the network that have implemented package relay, but do not\naccept A, will send getdata(PKGINFO1, T) and learn all of T's unconfirmed\nparents (~32 bytes * number of parents(T)).\n4) Such nodes will reject T.  But because of transaction malleability, and\nto avoid being blinded to a transaction unnecessarily, these nodes will\nlikely still send getdata(PKGINFO1, T) to every node that announces T, in\ncase someone has a transaction that includes an alternate set of parent\ntransactions that would pass policy checks.\n\nIs that understanding correct?  I think a good design goal would be to not\nwaste bandwidth in non-adversarial situations.  In this case, there would\nbe bandwidth waste from downloading duplicate data from all your peers,\njust because the announcement doesn't commit to the set of parent wtxids\nthat we'd get from the peer (and so we are unable to determine that all our\npeers would be telling us the same thing, just based on the announcement).\n\nSome ways to mitigate this might be to: (a) include a hash (maybe even just\na 20-byte hash -- is that enough security?) of the package wtxids (in some\ncanonical ordering) along with the wtxid of the child in the initial\nannouncement; (b) limit the use of v1 packages to transactions with very\nfew parents (I don't know if this is reasonable for the use cases we have\nin mind).\n\nAnother point I wanted to bring up is about the rules around v1 package\nvalidation generally, and the use of a blockhash in transaction relay\nspecifically.  My first observation is that it won't always be the case\nthat a v1 package relay node will be able to validate that a set of package\ntransactions is fully sorted topologically, because there may be\n(non-parent) ancestors that are missing from the package and the best a\npeer can validate is topology within the package -- this means that a peer\ncan validly (under this BIP) relay transaction packages out of the true\ntopological sort (if all ancestors were included).\n\nThis makes me wonder how useful this topological rule is.  I suppose there\nis some value in preventing completely broken implementations from staying\nconnected and so there is no harm in having the rule, but perhaps it would\nbe helpful to add that nodes SHOULD order transactions based on topological\nsort in the complete transaction graph, so that if missing-from-package\nancestors are already known by a peer (which is the expected case when\nusing v1 package relay on transactions that have more than one generation\nof unconfirmed ancestor) then the remaining transactions are already\nproperly ordered, and this is helpful even if unenforceable in general.\n\nThe other observation I wanted to make was that having transaction relay\ngated on whether two nodes agree on chain tip seems like an overly\nrestrictive criteria.  I think an important design principle is that we\nwant to minimize disruption from network splits -- if there are competing\nblocks found in a small window of time, it's likely that the utxo set is\nnot materially different on the two chains (assuming miners are selecting\nfrom roughly the same sets of transactions when this happens, which is\ntypical).  Having transaction relay bifurcate on the two network halves\nwould seem to exacerbate the difference between the two sides of the split\n-- users ought to be agnostic about how benign splits are resolved and\nwould likely want their transactions to relay across the whole network.\n\nAdditionally, use of a chain tip might impose a larger burden than is\nnecessary on software that would seek to participate in transaction relay\nwithout implementing headers sync/validation.  I don't know what software\nexists on the network, but I imagine there are a lot of scripts out there\nfor transaction submission to the public p2p network, and in thinking\nabout modifying such a script to utilize package relay it seems like an\nunnecessary added burden to first learn a node's tip before trying to relay\na transaction.\n\nCould you explain again what the benefit of including the blockhash is?  It\nseems like it is just so that a node could prioritize transaction relay\nfrom peers with the same chain tip to maximize the likelihood of\ntransaction acceptance, but in the common case this seems like a pretty\nnegligible concern, and in the case of a chain fork that persists for many\nminutes it seems better to me that we not partition the network into\npackage-relay regimes and just risk a little extra bandwidth in one\ndirection or the other.  If we solve the problem I brought up at the\nbeginning (of de-duplicating package data across peers with a\npackage-wtxid-commitment in the announcement), I think this is just some\nwasted pkginfo bandwidth on a single-link, and not across links (as we\ncould cache validation failure for a package-hash to avoid re-requesting\nduplicate pkginfo1 messages).\n\nBest,\nSuhas\n\n\nOn Tue, Jun 7, 2022 at 1:57 PM Gloria Zhao via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Eric, aj, all,\n>\n> Sorry for the delayed response. @aj I'm including some paraphrased points\n> from our offline discussion (thanks).\n>\n> > Other idea: what if you encode the parent txs as a short hash of the\n> wtxid (something like bip152 short ids? perhaps seeded per peer so\n> collisions will be different per peer?) and include that in the inv\n> announcement? Would that work to avoid a round trip almost all of the time,\n> while still giving you enough info to save bw by deduping parents?\n>\n> > As I suggested earlier, a package is fundamentally a compact block (or\n> > block) announcement without the header. Compact block (BIP152)\n> announcement\n> > is already well-defined and widely implemented...\n>\n> > Let us not reinvent the wheel and/or introduce accidental complexity. I\n> see\n> > no reason why packaging is not simply BIP152 without the 'header' field,\n> an\n> > updated protocol version, and the following sort of changes to names\n>\n> Interestingly, \"why not use BIP 152 shortids to save bandwidth?\" is by far\n> the most common suggestion I hear (including offline feedback). Here's a\n> full explanation:\n>\n> BIP 152 shortens transaction hashes (32 bytes) to shortids (6 bytes) to\n> save a significant amount of network bandwidth, which is extremely\n> important in block relay. However, this comes at the expense of\n> computational complexity. There is no way to directly calculate a\n> transaction hash from a shortid; upon receipt of a compact block, a node is\n> expected to calculate the shortids of every unconfirmed transaction it\n> knows about to find the matches (BIP 152: [1], Bitcoin Core: [2]). This is\n> expensive but appropriate for block relay, since the block must have a\n> valid Proof of Work and new blocks only come every ~10 minutes. On the\n> other hand, if we require nodes to calculate shortids for every transaction\n> in their mempools every time they receive a package, we are creating a DoS\n> vector. Unconfirmed transactions don't need PoW and, to have a live\n> transaction relay network, we should expect nodes to handle transactions at\n> a high-ish rate (i.e. at least 1000s of times more transactions than\n> blocks). We can't pre-calculate or cache shortids for mempool transactions,\n> since the SipHash key depends on the block hash and a per-connection salt.\n>\n> Additionally, shortid calculation is not designed to prevent intentional\n> individual collisions. If we were to use these shortids to deduplicate\n> transactions we've supposedly already seen, we may have a censorship\n> vector. Again, these tradeoffs make sense for compact block relay (see\n> shortid section in BIP 152 [3]), but not package relay.\n>\n> TLDR: DoSy if we calculate shortids on every package and censorship vector\n> if we use shortids for deduplication.\n>\n> > Given this message there is no reason\n> > to send a (potentially bogus) fee rate with every package. It can only\n> be\n> > validated by obtaining the full set of txs, and the only recourse is\n> > dropping (etc.) the peer, as is the case with single txs.\n>\n> Yeah, I agree with this. Combined with the previous discussion with aj\n> (i.e. we can't accurately communicate the incentive compatibility of a\n> package without sending the full graph, and this whole dance is to avoid\n> downloading a few low-fee transactions in uncommon edge cases), I've\n> realized I should remove the fee + weight information from pkginfo. Yay for\n> less complexity!\n>\n> Also, this might be pedantic, but I said something incorrect earlier and\n> would like to correct myself:\n>\n> >> In theory, yes, but maybe it was announced earlier (while our node was\n> down?) or had dropped from our mempool or similar, either way we don't have\n> those txs yet.\n>\n> I said \"It's fine if they have Erlay, since a sender would know in advance\n> that B is missing and announce it as a package.\" But this isn't true since\n> we're only using reconciliation in place of flooding to announce\n> transactions as they arrive, not for rebroadcast, and we're not doing full\n> mempool set reconciliation. In any case, making sure a node receives the\n> transactions announced when it was offline is not something we guarantee,\n> not an intended use case for package relay, and not worsened by this.\n>\n> Thanks for your feedback!\n>\n> Best,\n> Gloria\n>\n> [1]:\n> https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#cmpctblock\n> [2]:\n> https://github.com/bitcoin/bitcoin/blob/master/src/blockencodings.cpp#L49\n> [3]:\n> https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#short-transaction-id-calculation\n>\n> On Thu, May 26, 2022 at 3:59 AM <eric at voskuil.org> wrote:\n>\n>> Given that packages have no header, the package requires identity in a\n>> BIP152 scheme. For example 'header' and 'blockhash' fields can be replaced\n>> with a Merkle root (e.g. \"identity\" field) for the package, uniquely\n>> identifying the partially-ordered set of txs. And use of 'getdata' (to\n>> obtain a package by hash) can be eliminated (not a use case).\n>>\n>> e\n>>\n>> > -----Original Message-----\n>> > From: eric at voskuil.org <eric at voskuil.org>\n>> > Sent: Wednesday, May 25, 2022 1:52 PM\n>> > To: 'Anthony Towns' <aj at erisian.com.au>; 'Bitcoin Protocol Discussion'\n>> > <bitcoin-dev at lists.linuxfoundation.org>; 'Gloria Zhao'\n>> > <gloriajzhao at gmail.com>\n>> > Subject: RE: [bitcoin-dev] Package Relay Proposal\n>> >\n>> > > From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On\n>> > Behalf\n>> > > Of Anthony Towns via bitcoin-dev\n>> > > Sent: Wednesday, May 25, 2022 11:56 AM\n>> >\n>> > > So the other thing is what happens if the peer announcing packages to\n>> us\n>> > is\n>> > > dishonest?\n>> > >\n>> > > They announce pkg X, say X has parents A B C and the fee rate is\n>> garbage.\n>> > But\n>> > > actually X has parent D and the fee rate is excellent. Do we request\n>> the\n>> > > package from another peer, or every peer, to double check? Otherwise\n>> > we're\n>> > > allowing the first peer we ask about a package to censor that tx from\n>> us?\n>> > >\n>> > > I think the fix for that is just to provide the fee and weight when\n>> > announcing\n>> > > the package rather than only being asked for its info? Then if one\n>> peer\n>> > makes\n>> > > it sound like a good deal you ask for the parent txids from them,\n>> dedupe,\n>> > > request, and verify they were honest about the parents.\n>> >\n>> > Single tx broadcasts do not carry an advertised fee rate, however the'\n>> > feefilter' message (BIP133) provides this distinction. This should be\n>> > interpreted as applicable to packages. Given this message there is no\n>> reason\n>> > to send a (potentially bogus) fee rate with every package. It can only\n>> be\n>> > validated by obtaining the full set of txs, and the only recourse is\n>> > dropping (etc.) the peer, as is the case with single txs. Relying on the\n>> > existing message is simpler, more consistent, and more efficient.\n>> >\n>> > > >> Is it plausible to add the graph in?\n>> > >\n>> > > Likewise, I think you'd have to have the graph info from many nodes if\n>> > you're\n>> > > going to make decisions based on it and don't want hostile peers to be\n>> > able to\n>> > > trick you into ignoring txs.\n>> > >\n>> > > Other idea: what if you encode the parent txs as a short hash of the\n>> wtxid\n>> > > (something like bip152 short ids? perhaps seeded per peer so\n>> collisions\n>> > will\n>> > > be different per peer?) and include that in the inv announcement?\n>> Would\n>> > > that work to avoid a round trip almost all of the time, while still\n>> giving\n>> > you\n>> > > enough info to save bw by deduping parents?\n>> >\n>> > As I suggested earlier, a package is fundamentally a compact block (or\n>> > block) announcement without the header. Compact block (BIP152)\n>> > announcement\n>> > is already well-defined and widely implemented. A node should never be\n>> > required to retain an orphan, and BIP152 ensures this is not required.\n>> >\n>> > Once a validated set of txs within the package has been obtained with\n>> > sufficient fee, a fee-optimal node would accept the largest subgraph of\n>> the\n>> > package that conforms to fee constraints and drop any peer that\n>> provides a\n>> > package for which the full graph does not.\n>> >\n>> > Let us not reinvent the wheel and/or introduce accidental complexity. I\n>> see\n>> > no reason why packaging is not simply BIP152 without the 'header' field,\n>> an\n>> > updated protocol version, and the following sort of changes to names:\n>> >\n>> > sendpkg\n>> > MSG_CMPCT_PKG\n>> > cmpctpkg\n>> > getpkgtxn\n>> > pkgtxn\n>> >\n>> > > > For a maximum 25 transactions,\n>> > > >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.\n>> > >\n>> > > If you're doing short ids that's maybe 25*4B=100B already, then the\n>> above\n>> > is\n>> > > up to 36% overhead, I guess. Might be worth thinking more about, but\n>> > maybe\n>> > > more interesting with ancestors than just parents.\n>> > >\n>> > > >Also side note, since there are no size/count params,\n>> >\n>> > Size is restricted in the same manner as block and transaction\n>> broadcasts,\n>> > by consensus. If the fee rate is sufficient there would be no reason to\n>> > preclude any valid size up to what can be mined in one block (packaging\n>> > across blocks is not economically rational under the assumption that one\n>> > miner cannot expect to mine multiple blocks in a row). Count is\n>> incorporated\n>> > into BIP152 as 'shortids_length'.\n>> >\n>> > > > wondering if we\n>> > > >should just have \"version\" in \"sendpackages\" be a bit field instead\n>> of\n>> > > >sending a message for each version. 32 versions should be enough\n>> right?\n>> >\n>> > Adding versioning to individual protocols is just a reflection of the\n>> > insufficiency of the initial protocol versioning design, and that of the\n>> > various ad-hoc changes to it (including yet another approach in this\n>> > proposal) that have been introduced to compensate for it, though I'll\n>> > address this in an independent post at some point.\n>> >\n>> > Best,\n>> > e\n>> >\n>> > > Maybe but a couple of messages per connection doesn't really seem\n>> worth\n>> > > arguing about?\n>> > >\n>> > > Cheers,\n>> > > aj\n>> > >\n>> > >\n>> > > --\n>> > > Sent from my phone.\n>> > > _______________________________________________\n>> > > bitcoin-dev mailing list\n>> > > bitcoin-dev at lists.linuxfoundation.org\n>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220608/84353690/attachment-0001.html>"
            },
            {
                "author": "Gloria Zhao",
                "date": "2022-06-14T09:59:23",
                "message_text_only": "Hi Suhas,\n\nThanks for your attention and feedback!\n\n> Transaction A is both low-fee and non-standard to some nodes on the\nnetwork...\n> ...Whenever a transaction T that spends A is relayed, new nodes will send\nINV(PKGINFO1, T) to all package-relay peers...\n> ...because of transaction malleability, and to avoid being blinded to a\ntransaction unnecessarily, these nodes will likely still send\ngetdata(PKGINFO1, T) to every node that announces T...\n\nYes, we'd request pkginfo unless we already had the transaction in our\nmempool. The pkginfo step is intended to prevent nodes from ever\ndownloading a transaction more than once; I was going for a benchmark of\n\"packages are announced once per p2p connection, transaction data\ndownloaded once per node\".\n\nIn this scenario, both A and T's wtxids would be sent once per p2p\nconnection and transaction data downloaded once per node. If T has other\nunconfirmed parents, the low-fee ones will only be announced once (in\npkginfo) per link. If it has high-fee parents, they will indeed be\nannounced more than once per link (once individually, then again in\npkginfo).\n\nMore precisely: if a package contains any transactions which are\nnon-standard to one peer and standard to another, the package transactions\n(parents, not child) that pass the fee filter on their own will be\nannounced twice instead of once.\n\n> I think a good design goal would be to not waste bandwidth in\nnon-adversarial situations. In this case, there would be bandwidth waste\nfrom downloading duplicate data from all your peers, just because the\nannouncement doesn't commit to the set of parent wtxids that we'd get from\nthe peer (and so we are unable to determine that all our peers would be\ntelling us the same thing, just based on the announcement).\n\nEach transaction is only downloaded once per node here, and each package\nannounced/pkginfo sent once per link. I definitely understand that this\ndoesn't pass a benchmark of \"every transaction is announced at most once\nper link,\" but it's still on the magnitude of 32-byte hashes. Adding a\ncommitment to parents in the announcements is an extra hash per link in all\ncases - my question is whether it's worth it? We'd also need to write new\ninv/getdata message types for package relay, though that's probably a\nweaker argument.\n\n> it won't always be the case that a v1 package relay node will be able to\nvalidate that a set of package transactions is fully sorted topologically,\nbecause there may be (non-parent) ancestors that are missing from the\npackage and the best a peer can validate is topology within the package --\nthis means that a peer can validly (under this BIP) relay transaction\npackages out of the true topological sort (if all ancestors were included).\n\nGood point. Since v1 packages don't necessarily include the full ancestor\nset, we wouldn't be able to verify that two parents are in the right order\nif they have an indirect dependency, e.g. parent 1 spends a tx\n(\"grandparent\") which spends parent 2. Note that the grandparent couldn't\npossibly be in the mempool unless parent 2 is. We'd eventually get\neverything submitted as long as we received the grandparent, and then know\nwhether the package was topologically sorted. But I think you're right that\nthis could be a \"nice to have\" instead of a protocol requirement.\n\n> Could you explain again what the benefit of including the blockhash is?\nIt seems like it is just so that a node could prioritize transaction relay\nfrom peers with the same chain tip to maximize the likelihood of\ntransaction acceptance, but in the common case this seems like a pretty\nnegligible concern...\n\nThe blockhash is necessary in order to disambiguate between a malformed\npackage and difference in chain tip. If a parent is missing from a package,\nit's possible it was mined in a recent block that we haven't seen yet.\nValidating using a UTXO set, all we see is \"missing inputs\" when we try to\nvalidate the child; we wouldn't know if our peer had sent us a malformed\npackage or if we were behind.\n\nI'm hoping some of these clarifications are helpful to post publicly, but I\nknow I haven't fully addressed all the concerns you've brought up. Will\ncontinue to think about this.\n\nBest,\nGloria\n\nOn Wed, Jun 8, 2022 at 4:59 PM Suhas Daftuar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> Thanks again for your work on this!\n>\n> One question I have is about potential bandwidth waste in the case of\n> nodes running with different policy rules.  Here's my understanding of a\n> scenario I think could happen:\n>\n> 1) Transaction A is both low-fee and non-standard to some nodes on the\n> network.\n> 2) Whenever a transaction T that spends A is relayed, new nodes will send\n> INV(PKGINFO1, T) to all package-relay peers.\n> 3) Nodes on the network that have implemented package relay, but do not\n> accept A, will send getdata(PKGINFO1, T) and learn all of T's unconfirmed\n> parents (~32 bytes * number of parents(T)).\n> 4) Such nodes will reject T.  But because of transaction malleability, and\n> to avoid being blinded to a transaction unnecessarily, these nodes will\n> likely still send getdata(PKGINFO1, T) to every node that announces T, in\n> case someone has a transaction that includes an alternate set of parent\n> transactions that would pass policy checks.\n>\n> Is that understanding correct?  I think a good design goal would be to not\n> waste bandwidth in non-adversarial situations.  In this case, there would\n> be bandwidth waste from downloading duplicate data from all your peers,\n> just because the announcement doesn't commit to the set of parent wtxids\n> that we'd get from the peer (and so we are unable to determine that all our\n> peers would be telling us the same thing, just based on the announcement).\n>\n> Some ways to mitigate this might be to: (a) include a hash (maybe even\n> just a 20-byte hash -- is that enough security?) of the package wtxids (in\n> some canonical ordering) along with the wtxid of the child in the initial\n> announcement; (b) limit the use of v1 packages to transactions with very\n> few parents (I don't know if this is reasonable for the use cases we have\n> in mind).\n>\n> Another point I wanted to bring up is about the rules around v1 package\n> validation generally, and the use of a blockhash in transaction relay\n> specifically.  My first observation is that it won't always be the case\n> that a v1 package relay node will be able to validate that a set of package\n> transactions is fully sorted topologically, because there may be\n> (non-parent) ancestors that are missing from the package and the best a\n> peer can validate is topology within the package -- this means that a peer\n> can validly (under this BIP) relay transaction packages out of the true\n> topological sort (if all ancestors were included).\n>\n> This makes me wonder how useful this topological rule is.  I suppose there\n> is some value in preventing completely broken implementations from staying\n> connected and so there is no harm in having the rule, but perhaps it would\n> be helpful to add that nodes SHOULD order transactions based on topological\n> sort in the complete transaction graph, so that if missing-from-package\n> ancestors are already known by a peer (which is the expected case when\n> using v1 package relay on transactions that have more than one generation\n> of unconfirmed ancestor) then the remaining transactions are already\n> properly ordered, and this is helpful even if unenforceable in general.\n>\n> The other observation I wanted to make was that having transaction relay\n> gated on whether two nodes agree on chain tip seems like an overly\n> restrictive criteria.  I think an important design principle is that we\n> want to minimize disruption from network splits -- if there are competing\n> blocks found in a small window of time, it's likely that the utxo set is\n> not materially different on the two chains (assuming miners are selecting\n> from roughly the same sets of transactions when this happens, which is\n> typical).  Having transaction relay bifurcate on the two network halves\n> would seem to exacerbate the difference between the two sides of the split\n> -- users ought to be agnostic about how benign splits are resolved and\n> would likely want their transactions to relay across the whole network.\n>\n> Additionally, use of a chain tip might impose a larger burden than is\n> necessary on software that would seek to participate in transaction relay\n> without implementing headers sync/validation.  I don't know what software\n> exists on the network, but I imagine there are a lot of scripts out there\n> for transaction submission to the public p2p network, and in thinking\n> about modifying such a script to utilize package relay it seems like an\n> unnecessary added burden to first learn a node's tip before trying to relay\n> a transaction.\n>\n> Could you explain again what the benefit of including the blockhash is?\n> It seems like it is just so that a node could prioritize transaction relay\n> from peers with the same chain tip to maximize the likelihood of\n> transaction acceptance, but in the common case this seems like a pretty\n> negligible concern, and in the case of a chain fork that persists for many\n> minutes it seems better to me that we not partition the network into\n> package-relay regimes and just risk a little extra bandwidth in one\n> direction or the other.  If we solve the problem I brought up at the\n> beginning (of de-duplicating package data across peers with a\n> package-wtxid-commitment in the announcement), I think this is just some\n> wasted pkginfo bandwidth on a single-link, and not across links (as we\n> could cache validation failure for a package-hash to avoid re-requesting\n> duplicate pkginfo1 messages).\n>\n> Best,\n> Suhas\n>\n>\n> On Tue, Jun 7, 2022 at 1:57 PM Gloria Zhao via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Eric, aj, all,\n>>\n>> Sorry for the delayed response. @aj I'm including some paraphrased points\n>> from our offline discussion (thanks).\n>>\n>> > Other idea: what if you encode the parent txs as a short hash of the\n>> wtxid (something like bip152 short ids? perhaps seeded per peer so\n>> collisions will be different per peer?) and include that in the inv\n>> announcement? Would that work to avoid a round trip almost all of the time,\n>> while still giving you enough info to save bw by deduping parents?\n>>\n>> > As I suggested earlier, a package is fundamentally a compact block (or\n>> > block) announcement without the header. Compact block (BIP152)\n>> announcement\n>> > is already well-defined and widely implemented...\n>>\n>> > Let us not reinvent the wheel and/or introduce accidental complexity. I\n>> see\n>> > no reason why packaging is not simply BIP152 without the 'header'\n>> field, an\n>> > updated protocol version, and the following sort of changes to names\n>>\n>> Interestingly, \"why not use BIP 152 shortids to save bandwidth?\" is by\n>> far the most common suggestion I hear (including offline feedback). Here's\n>> a full explanation:\n>>\n>> BIP 152 shortens transaction hashes (32 bytes) to shortids (6 bytes) to\n>> save a significant amount of network bandwidth, which is extremely\n>> important in block relay. However, this comes at the expense of\n>> computational complexity. There is no way to directly calculate a\n>> transaction hash from a shortid; upon receipt of a compact block, a node is\n>> expected to calculate the shortids of every unconfirmed transaction it\n>> knows about to find the matches (BIP 152: [1], Bitcoin Core: [2]). This is\n>> expensive but appropriate for block relay, since the block must have a\n>> valid Proof of Work and new blocks only come every ~10 minutes. On the\n>> other hand, if we require nodes to calculate shortids for every transaction\n>> in their mempools every time they receive a package, we are creating a DoS\n>> vector. Unconfirmed transactions don't need PoW and, to have a live\n>> transaction relay network, we should expect nodes to handle transactions at\n>> a high-ish rate (i.e. at least 1000s of times more transactions than\n>> blocks). We can't pre-calculate or cache shortids for mempool transactions,\n>> since the SipHash key depends on the block hash and a per-connection salt.\n>>\n>> Additionally, shortid calculation is not designed to prevent intentional\n>> individual collisions. If we were to use these shortids to deduplicate\n>> transactions we've supposedly already seen, we may have a censorship\n>> vector. Again, these tradeoffs make sense for compact block relay (see\n>> shortid section in BIP 152 [3]), but not package relay.\n>>\n>> TLDR: DoSy if we calculate shortids on every package and censorship\n>> vector if we use shortids for deduplication.\n>>\n>> > Given this message there is no reason\n>> > to send a (potentially bogus) fee rate with every package. It can only\n>> be\n>> > validated by obtaining the full set of txs, and the only recourse is\n>> > dropping (etc.) the peer, as is the case with single txs.\n>>\n>> Yeah, I agree with this. Combined with the previous discussion with aj\n>> (i.e. we can't accurately communicate the incentive compatibility of a\n>> package without sending the full graph, and this whole dance is to avoid\n>> downloading a few low-fee transactions in uncommon edge cases), I've\n>> realized I should remove the fee + weight information from pkginfo. Yay for\n>> less complexity!\n>>\n>> Also, this might be pedantic, but I said something incorrect earlier and\n>> would like to correct myself:\n>>\n>> >> In theory, yes, but maybe it was announced earlier (while our node was\n>> down?) or had dropped from our mempool or similar, either way we don't have\n>> those txs yet.\n>>\n>> I said \"It's fine if they have Erlay, since a sender would know in\n>> advance that B is missing and announce it as a package.\" But this isn't\n>> true since we're only using reconciliation in place of flooding to announce\n>> transactions as they arrive, not for rebroadcast, and we're not doing full\n>> mempool set reconciliation. In any case, making sure a node receives the\n>> transactions announced when it was offline is not something we guarantee,\n>> not an intended use case for package relay, and not worsened by this.\n>>\n>> Thanks for your feedback!\n>>\n>> Best,\n>> Gloria\n>>\n>> [1]:\n>> https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#cmpctblock\n>> [2]:\n>> https://github.com/bitcoin/bitcoin/blob/master/src/blockencodings.cpp#L49\n>> [3]:\n>> https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#short-transaction-id-calculation\n>>\n>> On Thu, May 26, 2022 at 3:59 AM <eric at voskuil.org> wrote:\n>>\n>>> Given that packages have no header, the package requires identity in a\n>>> BIP152 scheme. For example 'header' and 'blockhash' fields can be\n>>> replaced\n>>> with a Merkle root (e.g. \"identity\" field) for the package, uniquely\n>>> identifying the partially-ordered set of txs. And use of 'getdata' (to\n>>> obtain a package by hash) can be eliminated (not a use case).\n>>>\n>>> e\n>>>\n>>> > -----Original Message-----\n>>> > From: eric at voskuil.org <eric at voskuil.org>\n>>> > Sent: Wednesday, May 25, 2022 1:52 PM\n>>> > To: 'Anthony Towns' <aj at erisian.com.au>; 'Bitcoin Protocol Discussion'\n>>> > <bitcoin-dev at lists.linuxfoundation.org>; 'Gloria Zhao'\n>>> > <gloriajzhao at gmail.com>\n>>> > Subject: RE: [bitcoin-dev] Package Relay Proposal\n>>> >\n>>> > > From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On\n>>> > Behalf\n>>> > > Of Anthony Towns via bitcoin-dev\n>>> > > Sent: Wednesday, May 25, 2022 11:56 AM\n>>> >\n>>> > > So the other thing is what happens if the peer announcing packages\n>>> to us\n>>> > is\n>>> > > dishonest?\n>>> > >\n>>> > > They announce pkg X, say X has parents A B C and the fee rate is\n>>> garbage.\n>>> > But\n>>> > > actually X has parent D and the fee rate is excellent. Do we request\n>>> the\n>>> > > package from another peer, or every peer, to double check? Otherwise\n>>> > we're\n>>> > > allowing the first peer we ask about a package to censor that tx from\n>>> us?\n>>> > >\n>>> > > I think the fix for that is just to provide the fee and weight when\n>>> > announcing\n>>> > > the package rather than only being asked for its info? Then if one\n>>> peer\n>>> > makes\n>>> > > it sound like a good deal you ask for the parent txids from them,\n>>> dedupe,\n>>> > > request, and verify they were honest about the parents.\n>>> >\n>>> > Single tx broadcasts do not carry an advertised fee rate, however the'\n>>> > feefilter' message (BIP133) provides this distinction. This should be\n>>> > interpreted as applicable to packages. Given this message there is no\n>>> reason\n>>> > to send a (potentially bogus) fee rate with every package. It can only\n>>> be\n>>> > validated by obtaining the full set of txs, and the only recourse is\n>>> > dropping (etc.) the peer, as is the case with single txs. Relying on\n>>> the\n>>> > existing message is simpler, more consistent, and more efficient.\n>>> >\n>>> > > >> Is it plausible to add the graph in?\n>>> > >\n>>> > > Likewise, I think you'd have to have the graph info from many nodes\n>>> if\n>>> > you're\n>>> > > going to make decisions based on it and don't want hostile peers to\n>>> be\n>>> > able to\n>>> > > trick you into ignoring txs.\n>>> > >\n>>> > > Other idea: what if you encode the parent txs as a short hash of the\n>>> wtxid\n>>> > > (something like bip152 short ids? perhaps seeded per peer so\n>>> collisions\n>>> > will\n>>> > > be different per peer?) and include that in the inv announcement?\n>>> Would\n>>> > > that work to avoid a round trip almost all of the time, while still\n>>> giving\n>>> > you\n>>> > > enough info to save bw by deduping parents?\n>>> >\n>>> > As I suggested earlier, a package is fundamentally a compact block (or\n>>> > block) announcement without the header. Compact block (BIP152)\n>>> > announcement\n>>> > is already well-defined and widely implemented. A node should never be\n>>> > required to retain an orphan, and BIP152 ensures this is not required.\n>>> >\n>>> > Once a validated set of txs within the package has been obtained with\n>>> > sufficient fee, a fee-optimal node would accept the largest subgraph of\n>>> the\n>>> > package that conforms to fee constraints and drop any peer that\n>>> provides a\n>>> > package for which the full graph does not.\n>>> >\n>>> > Let us not reinvent the wheel and/or introduce accidental complexity. I\n>>> see\n>>> > no reason why packaging is not simply BIP152 without the 'header'\n>>> field,\n>>> an\n>>> > updated protocol version, and the following sort of changes to names:\n>>> >\n>>> > sendpkg\n>>> > MSG_CMPCT_PKG\n>>> > cmpctpkg\n>>> > getpkgtxn\n>>> > pkgtxn\n>>> >\n>>> > > > For a maximum 25 transactions,\n>>> > > >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.\n>>> > >\n>>> > > If you're doing short ids that's maybe 25*4B=100B already, then the\n>>> above\n>>> > is\n>>> > > up to 36% overhead, I guess. Might be worth thinking more about, but\n>>> > maybe\n>>> > > more interesting with ancestors than just parents.\n>>> > >\n>>> > > >Also side note, since there are no size/count params,\n>>> >\n>>> > Size is restricted in the same manner as block and transaction\n>>> broadcasts,\n>>> > by consensus. If the fee rate is sufficient there would be no reason to\n>>> > preclude any valid size up to what can be mined in one block (packaging\n>>> > across blocks is not economically rational under the assumption that\n>>> one\n>>> > miner cannot expect to mine multiple blocks in a row). Count is\n>>> incorporated\n>>> > into BIP152 as 'shortids_length'.\n>>> >\n>>> > > > wondering if we\n>>> > > >should just have \"version\" in \"sendpackages\" be a bit field instead\n>>> of\n>>> > > >sending a message for each version. 32 versions should be enough\n>>> right?\n>>> >\n>>> > Adding versioning to individual protocols is just a reflection of the\n>>> > insufficiency of the initial protocol versioning design, and that of\n>>> the\n>>> > various ad-hoc changes to it (including yet another approach in this\n>>> > proposal) that have been introduced to compensate for it, though I'll\n>>> > address this in an independent post at some point.\n>>> >\n>>> > Best,\n>>> > e\n>>> >\n>>> > > Maybe but a couple of messages per connection doesn't really seem\n>>> worth\n>>> > > arguing about?\n>>> > >\n>>> > > Cheers,\n>>> > > aj\n>>> > >\n>>> > >\n>>> > > --\n>>> > > Sent from my phone.\n>>> > > _______________________________________________\n>>> > > bitcoin-dev mailing list\n>>> > > bitcoin-dev at lists.linuxfoundation.org\n>>> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/ed4089d5/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-06-17T20:08:36",
                "message_text_only": "Hi Gloria,\n\nThanks for working on that,\n\n> Always overestimating fees may sidestep this issue temporarily (while\nmempool\n> traffic is low and predictable), but this solution is not foolproof\n> and wastes users' money. The feerate market can change due to sudden\n> spikes in traffic (e.g. huge 12sat/vB dump a few days ago [9]) or\n> sustained, high volume of Bitcoin payments (e.g.  April 2021 and\n> December 2017).\n\nEven if the LN implementations started to overestimate fees based on the\nhistorical worst-case of block inclusion feerates, there is still room for\nexploitation due to bip125 rule#3. Indeed, as long as the adversary is able\nto stick in the mempool a higher fee package while the feerate is not\ncompelling enough to get it mined, your \"honest\" LN package should be\nbounced off.\n\nConsidering Core's `MAX_STANDARD_TX_WEIGHT` of 400000 WU, I think it's\npractical for an attacker to succeed with this pinning tactic in periods of\ntraffic spikes. Of course, LN implementation could overestimate fees with a\ntarget like `MAX_STANDARD_WEIGHT` * `worst_case_block_inclusion_feerate` to\nmitigate. However, assuming a value of 20sat for the latter, it would\nrequire from any LN user a minimal channel value of 2000000 satoshis to be\ntheoretically secure against this type of pinning.\n\nSo package relay is required to mitigate efficiently and realistically\nagainst pinning attacks, while conserving the same level of \"economic\"\nopenness for Lightning. Beyond, it should be also noted that package relay\nis only building block of the full set of mitigations, and there should be\na yet to-find-consensus-as-of-today other policy change such as\nuser-elected package limits or replace-by-feerate.\n\nAnyway, I think it would be beneficial to document the design trade-offs of\npinning mitigations in the `Rationale` subsection, at the attention of\nfuture L2s devs and users ?\n\n> {|\n> |  Field Name  ||  Type  ||  Size  ||  Purpose\n> |-\n> |version || uint32_t || 4 || Denotes a package version supported by the\n> node.\n> |-\n> |max_count || uint32_t || 4 ||Specifies the maximum number of transactions\n> per package this node is\n> willing to accept.\n> |-\n> |max_weight || uint32_t || 4 ||Specifies the maximum total weight per\n> package this node is willing\n> to accept.\n> |-\n> |}\n\nIt's unclear to me what's the purpose of `max_count` and `max_weight` in\nthe overall package relay flow, if they are intended to be exposed as\nconfigurable settings to node operators. If those fields are present to\nallow DoS protection increase of low-performance host, I believe it would\nbe better to restrain the number of consumed UTXOs or executed sigops per\npackage, as DoS vectors are more likely to be CPU-based, rather than\nmemory-based as package size already bounded at acceptance by\n`MAX_PACKAGE_COUNT`.\n\nThinking more we might introduce a `MAX_SIGOPS_PER_PACKAGR` limit, as\notherwise if we naively grant one package announcement as equal to one\ntransaction announcement in our tx-request logic, we might increase our DoS\nsurface, node ressources staying equivalent ?\n\n> {|\n> |  Field Name  ||  Type  ||  Size  ||   Purpose\n> |-\n> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions\n> requested.\n\nI'm not sure if we'll ever allow 3-bytes of package size, that would be\n~32k of transactions.\n\n> |-\n> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction\nin\n> the package.\n> |}\n\nI think there is a bandwidth consumption trade-off to be aware of in the\nfunction of the package-relay usage. Let's consider a single issuer\nbroadcasting the package to spend a shared-utxo, after the first shot the\nparent component should be spread across the network mempools. At each\nfee-bump, only the bumped CPFP will propagate on the network, the parent\nwtxid is reannounced in `pckginfo1` though there is no need to fetch it\nredundantly and waste bandwidth.\n\nHowever, I think the bandwidth saving does not hold in case of competing\ntransaction issuers to spend a shared-utxo. In that case, the parent might\ndiffer at each broadcast and the list of wtxid is dissemblable at every\nclaim of the shared-utxo. We could save the 32 bytes * number of packages\nelements by announcing a package_id, computed from the list of wtxids.\n\nI don't know about the occurrence of competing broadcasts among LN\nnon-cooperative closes, where bandwidth could be potentially saved. I would\nsay it's likely low because IIRC there is nothing in the LN protocol where\nthe counterparties signal to each other they're going on-chain to introduce\na competing broadcast synchronizing event. That said, it might increase in\nthe future in a post-eltoo, multi-party contracting protocol world.\n\nSo it might be interesting to document this design trade-off, if we seek\nbandwidth optimizations in function of a changing landscape in the type of\ntransaction issuers in the future.\n\n> 3. The sender provides package information using \"pckginfo1\",\n>    including the blockhash of the sender's best block, the wtxids of\n> the transactions in the package, their total fees and total weight.\n\nIt's unclear to me how the `pckinfo1` receiver should proceed if the\nsender's best block is not in sync with the local chain tip.\n\nIf the package isn't processed further, that's annoying for all the\nlow-performance  LN mobile clients, their chain tips might be always behind\nby few blocks from the p2p network nodes. It sounds like their packages\nwon't propagate at all.\n\nIf the package is processed further whatever the sender-receiver sync on\nchain tip, what's the purpose of including the blockhash ?\n\n> A child-with-unconfirmed-parents package for a transaction should be\n> announced when it meets the peer's fee filter but one or more of its\n> parents don't; a \"inv(MSG_PCKG1)\" instead of \"inv(WTX)\" should be sent\n> for the child. Each of the parents which meet the peer's fee filter\n> should still be announced normally.\n\nI believe we might have concerns of package-feerate downgrades attacks.\nE.g, in the LN context, where your channel counterparty is aiming to jam\nthe propagation of the best-feerate version of the package.\n\nLet's say you have :\n- Alice's commitment_tx, at 1s/vB\n- package A + child B, at 3s/vB\n- package A + child C, at 10s/vB\n- block inclusion feerate at 10s/vB\n- Alice and Mallory are LN channel counterparties\n- commitment_tx is using LN's anchor outputs\n\nAlice's LN node broadcasts A+C to her mempool.\nBob's feefilter is at 3s/vB.\nMallory broadcasts her child B in Alice's mempool.\nLN commitment does not meet Bob's feefilter.\nPackage A+child B at 3s/vB meets Bob's feefilter and is announced to Bob.\nMallory broadcasts her own commitment_tx at 4s/vB in Bob's mempool.\nWhen Alice's child C is relayed to Bob, it's bounced off Bob's mempool.\n\nDo you think this situation is plausible ? Of course, it might be heavily\ndependent on package-relay yet-not-implemented internal p2p logic.\nI think it could be fixable if LN removes the counterparty's\n`anchor_output` on the local node's version of the commitment transaction,\nonce package relay is deployed.\n\nAnother question, at the next fee-bump iteration, Alice rebroadcasts\nA+child D, at 12 s/vB. Her node has already marked Alice's commitment_tx as\nknown in Bob's `m_tx_inventory_known_filter`. So when a new higher fee\nchild is  discovered, should a `child-with-unconfirmed-parents` be\nannounced between Alice and Bob ?\n\nAnyway, I think it would be interesting to pseudo-specify the\npackage-assemblage algorithm (or if there is code already available) to see\nif it's robust against adversarial or unlucky situations ?\n\n> In fact, a package\n> of transactions may be announced using both Erlay and package relay.\n> After reconciliation, if the initiator would have announced a\n> transaction by wtxid but also has package information for it, they may\n> send \"inv(MSG_PCKG)\" instead of \"inv(WTX)\".\n\nYes, I think this holds. Note, we might have to add to the reconciliation\nset low-fee parents succeeding the feefilter check due to a child. When the\nreconcildiff, we might have to bifucarte again on feefilter to decide to\nannounce missing wtixds either as `inv(MSG_PCKG)` or `inv(WTX)`.\n\n(IIRC, I've already made few feedbacks offline though good to get them in\nthe public space and think more)\n\nAntoine\n\nLe mar. 17 mai 2022 \u00e0 12:09, Gloria Zhao via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hi everybody,\n>\n> I\u2019m writing to propose a set of p2p protocol changes to enable package\n> relay, soliciting feedback on the design and approach. Here is a link\n> to the most up-to-date proposal:\n>\n> https://github.com/bitcoin/bips/pull/1324\n>\n> If you have concept or approach feedback, *please respond on the\n> mailing list* to allow everybody to view and participate in the\n> discussion. If you find a typo or inaccurate wording, please feel free\n> to leave suggestions on the PR.\n>\n> I\u2019m also working on an implementation for Bitcoin Core.\n>\n>\n> The rest of this post will include the same contents as the proposal,\n> with a bit of reordering and additional context. If you are not 100%\n> up-to-date on package relay and find the proposal hard to follow, I\n> hope you find this format more informative and persuasive.\n>\n>\n> ==Background and Motivation==\n>\n> Users may create and broadcast transactions that depend upon, i.e.\n> spend outputs of, unconfirmed transactions. A \u201cpackage\u201d is the\n> widely-used term for a group of transactions representable by a\n> connected Directed Acyclic Graph (where a directed edge exists between\n> a transaction that spends the output of another transaction).\n>\n> Incentive-compatible mempool and miner policies help create a fair,\n> fee-based market for block space. While miners maximize transaction\n> fees in order to earn higher block rewards, non-mining users\n> participating in transaction relay reap many benefits from employing\n> policies that result in a mempool with the same contents, including\n> faster compact block relay and more accurate fee estimation.\n> Additionally, users may take advantage of mempool and miner policy to\n> bump the priority of their transactions by attaching high-fee\n> descendants (Child Pays for Parent or CPFP).  Only considering\n> transactions one at a time for submission to the mempool creates a\n> limitation in the node's ability to determine which transactions have\n> the highest feerates, since it cannot take into account descendants\n> until all the transactions are in the mempool. Similarly, it cannot\n> use a transaction's descendants when considering which of two\n> conflicting transactions to keep (Replace by Fee or RBF).\n>\n> When a user's transaction does not meet a mempool's minimum feerate\n> and they cannot create a replacement transaction directly, their\n> transaction will simply be rejected by this mempool. They also cannot\n> attach a descendant to pay for replacing a conflicting transaction.\n> This limitation harms users' ability to fee-bump their transactions.\n> Further, it presents a security issue in contracting protocols which\n> rely on **presigned**, time-sensitive transactions to prevent cheating\n> (HTLC-Timeout in LN Penalty [1] [2] [3], Unvault Cancel in Revault\n> [4], Refund Transaction in Discreet Log Contracts [5], Updates in\n> eltoo [6]). In other words, a key security assumption of many\n> contracting protocols is that all parties can propagate and confirm\n> transactions in a timely manner.\n>\n> In the past few years, increasing attention [0][1][2][3][6] has been\n> brought to **pinning attacks**, a type of censorship in which the\n> attacker uses mempool policy restrictions to prevent a transaction\n> from being relayed or getting mined.  TLDR: revocation transactions\n> must meet a certain confirmation target to be effective, but their\n> feerates are negotiated well ahead of broadcast time. If the\n> forecasted feerate was too low and no fee-bumping options are\n> available, attackers can steal money from their counterparties. I walk\n> through a concrete example for stealing Lightning HTLC outputs at\n> ~23:58 in this talk [7][8].  Note that most attacks are only possible\n> when the market for blockspace at broadcast time  demands much higher\n> feerates than originally anticipated at signing time. Always\n> overestimating fees may sidestep this issue temporarily (while mempool\n> traffic is low and predictable), but this solution is not foolproof\n> and wastes users' money. The feerate market can change due to sudden\n> spikes in traffic (e.g. huge 12sat/vB dump a few days ago [9]) or\n> sustained, high volume of Bitcoin payments (e.g.  April 2021 and\n> December 2017).\n>\n> The best solution is to enable nodes to consider packages of\n> transactions as a unit, e.g. one or more low-fee parent transactions\n> with a high-fee child, instead of separately. A package-aware mempool\n> policy can help determine if it would actually be economically\n> rational to accept a transaction to the mempool if it doesn't meet fee\n> requirements individually. Network-wide adoption of these policies\n> would create a more purely-feerate-based market for block space and\n> allow contracting protocols to adjust fees (and therefore mining\n> priority) at broadcast time.  Some support for packages has existed in\n> Bitcoin Core for years. Since v0.13, Bitcoin Core has used ancestor\n> packages instead of individual transactions to evaluate the incentive\n> compatibility of transactions in the mempool [10] and select them for\n> inclusion in blocks [11].\n>\n> Package Relay, the concept of {announcing, requesting, downloading}\n> packages between nodes on the p2p network, has also been discussed for\n> many years. The earliest public mention I can find is from 2015 [12].\n> The two most common use cases for package relay are fee-bumping\n> otherwise-too-low-fee transactions and reducing the amount of orphans.\n> It seems uncontroversial to say that everybody desires package relay\n> conceptually, with varying degrees of urgency. Lots of work has been\n> done by others over the past few years, from which I've taken\n> inspiration from [13][14][15][16].\n>\n> My approach has been to split the project into two components: (1) Package\n> Mempool Accept, which includes validation logic and mempool policy.\n> (3) Package Relay, which includes the p2p protocol changes.\n>\n> Progress so far:\n> After discussions with various developers of contracting protocols\n> (with heavier emphasis towards LN), it was determined that a\n> package containing a child with all of its unconfirmed parents\n> (child-with-unconfirmed-parents or 1-child-multi-parent package) would\n> be sufficient for their use case, i.e. fee-bumping presigned\n> transactions. A child-with-unconfirmed-parents package has several\n> properties that make many things easier to reason about.\n>\n> A few months ago, I proposed a set of policies for safe package\n> validation and fee assessment for packages of this restricted\n> topology [17]. A series of PRs implementing this proposal have\n> been merged into Bitcoin Core [18].\n>\n> Theoretically, developing a safe and incentive-compatible package\n> mempool acceptance policy is sufficient to solve this issue. Nodes\n> could opportunistically accept packages (e.g. by trying combinations\n> of transactions rejected from their mempools), but this practice would\n> likely be inefficient at best and open new Denial of Service attacks\n> at worst. Additional p2p messages may enable nodes to request and\n> share package validation-related information with one another in a\n> more communication-efficient way.\n>\n> Given that only package RBF remains for package mempool accept, and we\n> can make progress on p2p and mempool in parallel, I think it\u2019s\n> appropriate to put forward a package relay proposal.\n>\n> ==Proposal==\n>\n> This proposal contains 2 components: a \u201cgeneric\u201d package relay\n> protocol and an extension of it, child-with-unconfirmed-parents\n> packages, as version 1 package relay. Another version of packages,\n> \u201ctx-with-unconfirmed-ancestors\u201d can be created to extend package relay\n> for eliminating orphans.\n>\n> ===Generic Package Relay===\n>\n> Two main ideas are introduced:\n>\n> Download and validate packages of transactions together.\n>\n> Provide information to help peers decide whether to request and/or how\n> to validate transactions which are part of a package.\n>\n> ====Intended Protocol Flow====\n>\n> Due to the asynchronous nature of a distributed transaction relay\n> network, nodes may not receive all of the information needed to\n> validate a transaction at once. For example, after a node completes\n> Initial Block Download (IBD) and first starts participating in\n> transaction relay with an empty mempool, it is common to receive\n> orphans. In such scenarios where a node is aware that it is missing\n> information, a ''receiver-initiated'' dialogue is appropriate:\n>\n> 1. Receiver requests package information.\n>\n> 2. The sender provides package information, including the wtxids of\n>    the transactions in the package and anything else that might be\n> relevant (e.g. total fees and size).\n>\n> 3. The reciever uses the package information to decide how to request\n>    and validate the transactions.\n>\n> Sometimes, no matter what order transactions are received by a node,\n> validating them individually is insufficient. When the sender is aware\n> of additional information that the receiver needs to accept a package,\n> a proactive ''sender-initiated'' dialogue should be enabled:\n>\n> 1. Sender announces they have package information pertaining to a\n>    transaction that might otherwise be undesired on its own.\n>\n> 2. The receiver requests package information.\n>\n> 3. The sender provides package information, including the wtxids of\n>    the transactions in the package and anything else that might be\n> relevant (e.g. total fees and size).\n>\n> 4. The reciever uses the package information to decide how to request\n>    and validate the transactions.\n>\n> Package relay is negotiated between two peers during the version\n> handshake. Package relay requires both peers to support wtxid-based\n> relay because package transactions are referenced by their wtxid.\n>\n> ====New Messages====\n>\n> Three new protocol messages are added for use in any version of\n> package relay. Additionally, each version of package relay must define\n> its own inv type and \"pckginfo\" message version, referred to in this\n> document as \"MSG_PCKG\" and \"pckginfo\" respectively. See\n> BIP-v1-packages for a concrete example.\n>\n> =====sendpackages=====\n>\n> {|\n> |  Field Name  ||  Type  ||  Size  ||  Purpose\n> |-\n> |version || uint32_t || 4 || Denotes a package version supported by the\n> node.\n> |-\n> |max_count || uint32_t || 4 ||Specifies the maximum number of transactions\n> per package this node is\n> willing to accept.\n> |-\n> |max_weight || uint32_t || 4 ||Specifies the maximum total weight per\n> package this node is willing\n> to accept.\n> |-\n> |}\n>\n> 1. The \"sendpackages\" message has the structure defined above, with\n>    pchCommand == \"sendpackages\".\n>\n> 2. During version handshake, nodes should send a \"sendpackages\"\n>    message indicate they support package relay and may request\n> packages.\n>\n> 3. The message should contain a version supported by the node. Nodes\n>    should send a \"sendpackages\" message for each version they support.\n>\n> 4. The \"sendpackages\" message MUST be sent before sending a \"verack\"\n>    message. If a \"sendpackages\" message is received afer \"verack\", the\n> sender should be disconnected.\n>\n> 5. If 'fRelay==false' in a peer's version message, the node must not\n>    send \"sendpackages\" to them. If a \"sendpackages\" message is\n> received by a peer after sending `fRelay==false` in their version\n> message, the sender should be disconnected.\n>\n> 6.. Upon receipt of a \"sendpackages\" message with a version that is\n> not supported, a node must treat the peer as if it never received the\n> message.\n>\n> 7. If both peers send \"wtxidrelay\" and \"sendpackages\" with the same\n>    version, the peers should announce, request, and send package\n> information to each other.\n>\n> =====getpckgtxns=====\n>\n> {|\n> |  Field Name  ||  Type  ||  Size  ||   Purpose\n> |-\n> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions\n> requested.\n> |-\n> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction\n> in the package.\n> |}\n>\n> 1. The \"getpckgtxns\" message has the structure defined above, with\n>    pchCommand == \"getpckgtxns\".\n>\n> 2. A \"getpckgtxns\" message should be used to request all or some of\n>    the transactions previously announced in a \"pckginfo\" message,\n> specified by witness transactiosome id.\n>\n> 3. Upon receipt of a \"getpckgtxns\" message, a node must respond with\n>    either a \"pckgtxns\" containing the requested transactions or a\n> \"notfound\" message indicating one or more of the transactions is\n> unavailable. This allows the receiver to avoid downloading and storing\n> transactions that cannot be validated immediately.\n>\n> 4. A \"getpckgtxns\" message should only be sent if both peers agreed to\n>    send packages in the version handshake. If a \"getpckgtxns\" message\n> is received from a peer with which package relay was not negotiated,\n> the sender should be disconnected.\n>\n> =====pckgtxns=====\n>\n> {|\n> |  Field Name  ||  Type  ||  Size  ||   Purpose\n> |-\n> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions\n> provided.\n> |-\n> |txns||List of transactions||variable|| The transactions in the package.\n> |}\n>\n> 1. The \"pckgtxns\" message has the structure defined above, with\n>    pchCommand == \"pckgtxns\".\n>\n> 2. A \"pckgtxns\" message should contain the transaction data requested\n>    using \"getpckgtxns\".\n>\n> 3. A \"pckgtxns\" message should only be sent to a peer that requested\n>    the package using \"getpckgtxns\". If a node receives an unsolicited\n> package, the sender should be disconnected.\n>\n> 4. A \"pckgtxns\" message should only be sent if both peers agreed to\n>    send packages in the version handshake. If a \"pckgtxns\" message is\n> received from a peer with which package relay was not negotiated, the\n> sender should be disconnected.\n>\n> ===Version 1 Packages: child-with-unconfirmed-parents===\n>\n> This extends package relay for packages consisting of one transaction\n> and all of its unconfirmed parents,by defining version 1 packages, a\n> pckginfo1 message, and a MSG_PCKG1 inv type. It enables the use case\n> in which a child pays for its otherwise-too-low-fee parents and their\n> mempool conflict(s).\n>\n> ====Intended Protocol Flow====\n>\n> When relaying a package of low-fee parent(s) and high-fee child, the\n> sender and receiver do the following:\n>\n> 1. Sender announces they have a child-with-unconfirmed-parents package\n>    for a child that pays for otherwise-too-low-fee parent(s) using\n> \"inv(MSG_PCKG1)\".\n>\n> 2. The receiver requests package information using\n>    \"getdata(MSG_PCKG1)\".\n>\n> 3. The sender provides package information using \"pckginfo1\",\n>    including the blockhash of the sender's best block, the wtxids of\n> the transactions in the package, their total fees and total weight.\n>\n> 4. The reciever uses the package information to decide how to request\n>    the transactions. For example, if the receiver already has some of\n> the transactions in their mempool, they only request the missing ones.\n> They could also decide not to request the package at all based on the\n> fee information provided.\n>\n> 5. Upon receiving a \"pckgtxns\", the receiver submits the transactions\n>    together as a package.\n>\n> ====New Messages====\n>\n> A new inv type, \"MSG_PCKG1\", and new protocol message, \"PCKGINFO1\",\n> are added.\n>\n> =====pckginfo1=====\n>\n> {|\n> |  Field Name  ||  Type  ||  Size  ||   Purpose\n> |-\n> |blockhash || uint256 || 32 || The chain tip at which this package is\n> defined.\n> |-\n> |pckg_fee||CAmount||4|| The sum total fees paid by all transactions in the\n> package.\n> |-\n> |pckg_weight||int64_t||8|| The sum total weight of all transactions in the\n> package.\n> |-\n> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions\n> provided.\n> |-\n> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction\n> in the package.\n> |}\n>\n>\n> 1. The \"pckginfo1\" message has the structure defined above, with\n>    pchCommand == \"pckginfo1\".\n>\n> 2. A \"pckginfo1\" message contains information about a version 1\n>    package (defined below), referenced by the wtxid of the transaction\n> it pertains to and the current blockhash.\n>\n> 3. Upon receipt of a \"pckginfo1\" message, the node should decide if it\n>    wants to validate the package, request transaction data if\n> necessary, etc.\n>\n> 4. Upon receipt of a malformed \"pckginfo1\" message or package that\n>    does not abide by the max_count, max_weight, or other rules\n> specified by the version agreed upon in the initial negotiation, the\n> sender should be disconnected.  If a node receives a \"pckginfo1\"\n> message for which the \"pckg_fee\" or \"pckg_weight\" do not reflect the\n> true total fees and weight, respectively, or the transactions in the\n> package, the message is malformed.\n>\n> 5. A node MUST NOT send a \"pckginfo1\" message that has not been\n>    requested by the recipient. Upon receipt of an unsolicited\n> \"pckginfo1\", a node should disconnect the sender.\n>\n> 6. A \"pckginfo1\" message should only be sent if both peers agreed to\n>    send version 1 packages in the version handshake. If a \"pckginfo1\"\n> message is received from a peer with which package relay was not\n> negotiated, the sender should be disconnected.\n>\n> =====MSG_PCKG1=====\n>\n> 1. A new inv type (MSG_PCKG1 == 0x6) is added, for use in inv messages\n>    and getdata requests pertaining to version 1 packages.\n>\n> 2. As an inv type, it indicates that both transaction data and version\n>    1 package information are available for the transaction. The\n> transaction is referenced by its wtxid. As a getdata request type, it\n> indicates that the sender wants package information for the\n> transaction.\n>\n> 3. Upon receipt of a \"getdata\" request for \"MSG_PCKG1\", the node\n>    should respond with the version 1 package corresponding to the\n> requested transaction and its current chain tip, or with NOTFOUND.\n> The node should not assume that the sender is requesting the\n> transaction data as well.\n>\n> ====Child With Parent Packages Rules====\n>\n> A child-with-unconfirmed-parents package sent between nodes must abide\n> by the rules below, otherwise the package is malformed and the sender\n> should be disconnected.\n>\n> A version 1 or ''child-with-unconfirmed-parents'' package can be\n> defined for any transaction that spends unconfirmed inputs. The child\n> can be thought of as the \"representative\" of the package. This package\n> can be uniquely identified by the transaction's wtxid and the current\n> chain tip block hash.\n>\n> A ''child-with-unconfirmed-parents'' package MUST be:\n>\n> 1. ''Sorted topologically.'' For every transaction t in the package,\n>    if any of t's parents are present in the package, the parent must\n> appear somewhere in the list before t. In other words, the\n> transactions must be sorted in ascending order of the number of\n> ancestors present in the package.\n>\n> 2. ''Only 1 child with unconfirmed parents.'' The package must consist\n>    of one transaction and its unconfirmed parents. There must not be\n> any other transactions in the package. Other dependency relationships\n> may exist within the package (e.g. one parent may spend the output of\n> another parent) provided that topological order is respected.\n>\n> 3. ''All unconfirmed parents.'' All of the child's unconfirmed parents\n>    must be present.\n>\n> 4. ''No conflicts.'' None of the transactions in the package may\n>    conflict with each other (i.e.  spend the same prevout).\n>\n> 5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'\n>    fields must accurately represent the sum total of all transactions'\n> fees and weights as defined in BIP141, respectively.\n>\n> Not all of the child's parents must be present; the child transaction\n> may also spend confirmed inputs. However, if the child has confirmed\n> parents, they must not be in the package.\n>\n> While a child-with-unconfirmed-parents package is perhaps most\n> relevant when the child has a higher feerate than its parents, this\n> property is not required to construct a valid package.\n>\n> ====Clarifications====\n>\n> ''Q: Under what circumstances should a sender announce a\n> child-with-unconfirmed-parents package?''\n>\n> A child-with-unconfirmed-parents package for a transaction should be\n> announced when it meets the peer's fee filter but one or more of its\n> parents don't; a \"inv(MSG_PCKG1)\" instead of \"inv(WTX)\" should be sent\n> for the child. Each of the parents which meet the peer's fee filter\n> should still be announced normally.\n>\n> ''Q: What if a new block arrives in between messages?''\n>\n> A child-with-unconfirmed-parents package is defined for a transaction\n> based on the current chain state. As such, a new block extending the\n> tip may decrease the number of transactions in the package (i.e. if\n> any of the transaction's parents were included in the block). In a\n> reorg, the number of transactions in the package may decrease or\n> increase (i.e. if any of the transaction's parents were included in a\n> block in the previous chain but not the new one).\n>\n> If the new block arrives before the \"getdata\" or \"pckginfo1\", nothing\n> needs to change.\n>\n> If the new block arrives before \"getpckgtxns\" or before \"pckgtxns\",\n> the receiver may need to re-request package information if the block\n> contained a transaction in the package. If the block doesn't contain\n> any transactions in the package, whether it extends the previous tip\n> or causes a reorg, nothing needs to change.\n>\n> ''Q: Can \"getpckgtxns\" and \"pckgtxns\" messages contain only one\n> transaction?''\n>\n> Yes.\n>\n> ===Further Protocol Extensions===\n>\n> When introducing a new type of package, assign it a version number \"n\"\n> and use an additional \"sendpackages\" message during version handshake\n> to negotiate support for it. An additional package information message\n> \"pckginfon\" and inv type \"MSG_PCKGn\" should be defined for the type of\n> package.  However, \"getpckgtxns\" and \"pckgtxns\" do not need to be\n> changed.\n>\n> Example proposal for tx-with-unconfirmed-ancestors package relay: [19]\n>\n> ===Compatibility===\n>\n> Older clients remain fully compatible and interoperable after this\n> change. Clients implementing this protocol will only attempt to send\n> and request packages if agreed upon during the version handshake.\n>\n> ===Package Erlay===\n>\n> Clients using BIP330 reconciliation-based transaction relay (Erlay)\n> are able to use package relay without interference. In fact, a package\n> of transactions may be announced using both Erlay and package relay.\n> After reconciliation, if the initiator would have announced a\n> transaction by wtxid but also has package information for it, they may\n> send \"inv(MSG_PCKG)\" instead of \"inv(WTX)\".\n>\n> ===Rationale===\n>\n> ====P2P Message Design====\n>\n> These p2p messages are added for communication efficiency and, as\n> such, one should measure alternative solutions based on the resources\n> used to communicate (not necessarily trustworthy) information: We\n> would like to minimize network bandwidth, avoid downloading a\n> transaction more than once, avoid downloading transactions that are\n> eventually rejected, and minimize storage allocated for\n> not-yet-validated transactions.\n>\n> Consider these (plausible) scenarios in transaction relay:\n>\n> Alice (the \"sender\") is relaying transactions to Bob (the \"receiver\").\n> Alice's mempool has a minimum feerate of 1sat/vB and Bob's has a\n> minimum feerate of 3sat/vB. For simplicity, all transactions are\n> 1600Wu in virtual size and 500 bytes in serialized size. Apart from\n> the spending relationships specified, all other inputs are from\n> confirmed UTXOs.\n>\n> 1. Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in\n>    fees.\n>\n> 2. Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in\n>    fees.\n>\n> 3. Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000\n>    satoshis in fees, respectively.\n>\n> ====Alternative Designs Considered====\n>\n> ''Package Information Only:'' Just having \"pckginfo\" gives enough\n> information for the receiver to accept the package. Omit the\n> \"getpckgtxns\" and \"pckgtxns\" messages. While this option is a good\n> fallback if batched transaction download fails for some reason, it\n> shouldn't be used as the default because it 'always' requires storage\n> of unvalidated transactions.\n>\n> ''No Package Information Round:'' Instead of having a package\n> information round, just use the child's wtxid to refer to the package\n> and always send the entire package together. This would cause nodes to\n> redownload duplicate transactions.\n>\n> I have also created a slidedeck exploring various alternative designs\n> and some examples in which they fall flat [20]. Please feel free to\n> suggest other alternatives.\n>\n> ====Versioning System====\n>\n> This protocol should be extensible to support multiple types of\n> packages based on future desired use cases. Two \"flavors\" of\n> versioning were considered:\n>\n> 1. When package mempool acceptance is upgraded to support more types\n>    of packages, increment the version number (similar to Erlay).\n> During version handshake, peers negotiate which version of package\n> relay they will use by each sending one \"sendpackages\" message.\n>\n> 2. When introducing another type of package, assign a version number\n>    to it and announce it as an additional supported version (similar\n> to Compact Block Relay). During version handshake, peers send one\n> \"sendpackages\" message for each version supported.\n>\n> The second option was favored because it allows different parameters\n> for different versions.  For example, it should be possible to support\n> both \"arbitrary topology but maximum 3-transaction\" package as well as\n> \"child-with-unconfirmed-parents with default mempool ancestor limits\"\n> packages simultaneously.\n>\n> ==Acknowledgements==\n>\n> I hope to have made it abundantly clear that this proposal isn\u2019t\n> inventing the concept of package relay, and in fact builds upon years\n> of work by many others, including Suhas Daftuar and Antoine Riard.\n>\n> Thank you to John Newbery and Martin Zumsande for input on the design.\n>\n> Thank you to Matt Corallo, Christian Decker, David Harding, Antoine\n> Poinsot, Antoine Riard, Gregory Sanders, Chris Stewart, Bastien\n> Teinturier, and others for input on the desired interface for\n> contracting protocols.\n>\n> Looking forward to hearing your thoughts!\n>\n> Best,\n> Gloria\n>\n> [0]:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html\n> [1]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html\n> [2]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html\n> [3]:\n> https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n> [4]:\n> https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx\n> [5]:\n> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction\n> [6]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1\n> [7]:\n> https://btctranscripts.com/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/#lightning-attacks\n> [8]: https://youtu.be/fbWSQvJjKFs?t=1438\n> [9]:\n> https://www.reddit.com/r/Bitcoin/comments/unew4e/looks_like_70_mvb_of_transactions_just_got_dumped/\n> [10]: https://github.com/bitcoin/bitcoin/pull/7594\n> [11]: https://github.com/bitcoin/bitcoin/pull/7600\n> [12]: https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820\n> [13]: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\n> [14]: https://github.com/bitcoin/bitcoin/issues/14895\n> [15]: https://github.com/bitcoin/bitcoin/pull/16401\n> [16]: https://github.com/bitcoin/bitcoin/pull/19621\n> [17]:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019464.html\n> [18]: https://github.com/users/glozow/projects/5/views/4?layout=board\n> [19]: https://gist.github.com/glozow/9b321cd3ef6505135c763112033ff2a7\n> [20]:\n> https://docs.google.com/presentation/d/1B__KlZO1VzxJGx-0DYChlWawaEmGJ9EGApEzrHqZpQc/edit?usp=sharing\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220617/eed409e3/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Package Relay Proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Suhas Daftuar",
                "Gloria Zhao",
                "Antoine Riard"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 84040
        }
    },
    {
        "title": "[bitcoin-dev] Packaged Transaction Relay",
        "thread_messages": [
            {
                "author": "eric at voskuil.org",
                "date": "2022-06-08T22:43:57",
                "message_text_only": "Hi Suhas/Gloria,\n\nGood questions. I've started a new thread because it became something else...\n\nVarious ideas about packaging seem to be focused on the idea of an atomic message that is gossiped around the network like a transaction or block. From my perspective that seems to create a set of problems without good solutions, and it is not a proper analogy to those atomic structures. It may be worth taking the time to step back and take a close look at the underlying objective.\n\nThe sole objective, as expressed in the OP proposal, is to:\n\n\"Propagate transactions that are incentive-compatible to mine, even if they don't meet minimum feerate alone.\"\n\nEffectively producing this outcome with an atomic packaging approach while at the same time maintaining network invariants seems unlikely, if not impossible.\n\nFees:\n\nA node knows what fee rate a peer will accept, and announces individual txs that satisfy peer.feerate. Similarly a node knows its own feerate, and SHOULD drop any peer that announces txs that do not satisfy node.feerate.\n\nOrphans:\n\nA node MAY drop a peer that announces txs that the node sees as orphans against its DAG. It SHOULD drop the orphan tx and MAY request missing ancestors. Presumably after some amount of time connected to peer, node does not expect to see any more orphans from that peer, so these choices could evolve with the channel. However, the design that can only consider each tx in isolation will continue to cause orphan announcements on the channel. A below peer.feerate tx does not get announced to peer, and later a descendant high peer.feerate does get announced to the peer - as an orphan.\n\nBIP133 (feefilter):\n\n\"There could be a small number of edge cases where a node's mempool min fee is actually less than the filter value a peer is aware of and transactions with fee rates between these values will now be newly inhibited.\"\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki\n\nWhether the problem is \"small\" or not depends on the disparity between node fee rates, which is not a matter of protocol. This is an existing problem that can and should be dealt with in packaging, as part of the above objective. \n\nPackaged Transaction Relay:\n\nOne might instead think of packaging as a per-connection function, operating over its transaction (input->output) DAG and the feerate of its own node and that of the peer. Logically a \"package\" is nothing more than a set of transactions (optimized by announcement). Only a node can effectively determine the packaging required by each of its peers, since only the node is aware of peer.feerate.\n\nThe only way to avoid dead-ending packages (including individual transactions, as is the objective) is for a node to package txs for each peer. The origination of any package is then just a wallet peer doing what a node does - packaging transactions that satisfy peer.feerate (i.e. that of its node).\n\nCurrent transaction relay (txB->txA):\n===============================\nNode0\ntxA.feerate > node.feerate, and not orphaned (accept txA)\ntxA.feerate > peer1.feerate (announce txA to peer1)\ntxA.feerate < peer2.feerate (do not announce txA to peer2)\n-----\ntxB.feerate > node.feerate (accept txB)\ntxB.feerate > peer1.feerate (announce txB to peer1)\ntxB.feerate > peer2.feerate (announce txB to peer2)\n\nNode1\nSees/accepts txA and txB.\n\nNode2\nNever sees txA, sees/rejects txB (as an orphan).\n\nPackaged transaction relay (txB->txA):\n===============================\nNode0\ntxA.feerate > node.feerate, and not orphaned (accept txA)\ntxA.feerate > peer1.feerate (announce txA to peer1)\ntxA.feerate < peer2.feerate (do not announce txA to peer2)\n-----\ntxB.feerate > node1.feerate (accept txB)\ntxB.feerate > peer1.feerate (announce txB to peer1)\ntxB.feerate > peer2.feerate (do not announce txB to peer2) <== avoid predictable orphan\ntxA.feerate + txB.feerate > peer2.feerate (announce pkg(A, B) to peer2) <= create minimal package\n\nNode1\nSees/accepts txA and txB.\n\nNode2\npkg(A, B) > node2.feerate (accept txA, txB)\ntxA.feerate > peer3.feerate (announce txA to peer3)\ntxB.feerate > peer3.feerate (announce txB to peer3)\n\nSees/accepts pkg(A, B).\n\nNode3\nSees/accepts txA and txB. <= avoided unnecessary packaging\n\nSummary:\n\nIn this design, any node that receives an announcement for a pkg (or tx) later determined to be less than node.feerate SHOULD drop the announcing peer. Unlike with existing tx relay, a node can become \"current\" and subsequently see few if any tx or pkg orphans, and MAY at some point decide to drop any peer that announces one. Notice that packages are created dynamically, and any package that doesn't need to be grouped gets trimmed down to individual transactions. Furthermore any tx that is \"stuck\" can be freed by simply sending another tx. The nodes at which the tx has become stuck will just package it up and relay it to peers. In other words, there is no impact on wallet implementation apart from raising the aggregate fee using a descendant transaction.\n\nThis is barely a protocol change - it's primarily implementation. All that should be required is an additional INV element type, such as MSG_TX_PACKAGE.\n\nAdditional constraints:\n\n* All elements of MSG_TX_PACKAGE in one INV message MUST to be of the same package.\n* A package MUST must define a set that can be mined into one block (size/sigops constraint).\n* A package SHOULD not contain confirmed txs (a race may cause this).\n* A package MUST minimally satisfy peer.feerate.\n* A partial tx order, as in the manner of the block.txs ordering, MUST be imposed.\n* A node SHOULD drop a peer that sends a package (or tx) below node.feerate.\n* A node MAY drop a peer that sends a non-minimal package according to node.feerate.\n\nThe partial ordering of block.txs introduces an ordering constraint that precludes full parallelism in validating input attachment. This is an implementation artifact that made its way into consensus. However in the case of packaging, the set of txs is not presumed to be valid under the proof of work DoS guard. As such constraints should minimize the work/traffic required to invalidate the message. The partial order constraint ensures that the DAG can be built incrementally, dropping the attempt (and peer as desired) as soon as the first orphan is discovered. As a result the network traffic and work required is not materially different than with tx relay, with two exceptions.\n\nThese are the two central aspects of this approach (Avoiding Predictable Orphans and Creating Minimal Packages). These are graph search algorithms, some basic computer science. Minimality requires only that the package does not introduce txs that are not necessary to reach the peer.feerate (as these can always be packaged separately). It does not require that nodes all generate the same packages. It does not require negotiation, package identity, cryptography, or hashing. As a graph search it should be O(n) where n is the unconfirmed ancestry of the package, but should typically be much lower, if not a single step.\n\nSufficiently-low-fee nodes will see only single txs. Moderate-fee nodes may cause partial breakup of packages. Sufficiently high fee nodes will cause peers (having received and completed the acceptance of a tx/pkg with pkg.feerate < peer.feerate) to navigate from each tx/package external input until reaching txs above peer.feerate, or confirmed (both of which the peer is presumed to already have). If the pkg.feerate is sufficiently high to connect all external inputs to the intervening txs, they are added to the package and it is announced to the high fee peer. Note that the individual tx.feerate > peer.feerate is insufficient to ensure that the peer should have the tx, as there may be ancestor txs that do not, and for which the tx was insufficient to cause them to be packaged. So a non-caching algorithm must be able to chase each package external input to a confirmed tx (or cache the unconfirmed ancestry fee rate at each tx). Note that fee rates are not directly additive, both size/weight and fee are required for summation (and aggregate sigops should be considered).\n\nThis makes no assumptions about current implementations. The design would call for maintenance of a transaction (input->output) DAG with tx.feerate on each tx. This could be the unconfirmed tx graph (i.e. \"memory pool\") though it does not require maintenance of anything more than the parameters necessary to confirm a set of validated txs within a block. It is very reasonable to require this of any participating node. A simple version negotiation can identify a package-accepting/sending nodes.\n\nI have thought about this for some time, but have not implemented either the graph search, source code, or BIP. Just wrote this off the top of my head. So I am sure there are some things I have incorrect or failed to consider. But I think it's worth discussing it at this point.\n\ne\n\n> -----Original Message-----\n> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On\n> Behalf Of Suhas Daftuar via bitcoin-dev\n> Sent: Wednesday, June 8, 2022 8:59 AM\n> To: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Package Relay Proposal\n> \n> Hi,\n> \n> Thanks again for your work on this!\n> \n> One question I have is about potential bandwidth waste in the case of nodes\n> running with different policy rules.  Here's my understanding of a scenario I\n> think could happen:\n> \n> 1) Transaction A is both low-fee and non-standard to some nodes on the\n> network.\n> 2) Whenever a transaction T that spends A is relayed, new nodes will send\n> INV(PKGINFO1, T) to all package-relay peers.\n> 3) Nodes on the network that have implemented package relay, but do not\n> accept A, will send getdata(PKGINFO1, T) and learn all of T's unconfirmed\n> parents (~32 bytes * number of parents(T)).\n> 4) Such nodes will reject T.  But because of transaction malleability, and to\n> avoid being blinded to a transaction unnecessarily, these nodes will likely still\n> send getdata(PKGINFO1, T) to every node that announces T, in case\n> someone has a transaction that includes an alternate set of parent\n> transactions that would pass policy checks.\n> \n> Is that understanding correct?  I think a good design goal would be to not\n> waste bandwidth in non-adversarial situations.  In this case, there would be\n> bandwidth waste from downloading duplicate data from all your peers, just\n> because the announcement doesn't commit to the set of parent wtxids that\n> we'd get from the peer (and so we are unable to determine that all our peers\n> would be telling us the same thing, just based on the announcement).\n> \n> Some ways to mitigate this might be to: (a) include a hash (maybe even just a\n> 20-byte hash -- is that enough security?) of the package wtxids (in some\n> canonical ordering) along with the wtxid of the child in the initial\n> announcement; (b) limit the use of v1 packages to transactions with very few\n> parents (I don't know if this is reasonable for the use cases we have in mind).\n> \n> Another point I wanted to bring up is about the rules around v1 package\n> validation generally, and the use of a blockhash in transaction relay\n> specifically.  My first observation is that it won't always be the case that a v1\n> package relay node will be able to validate that a set of package transactions\n> is fully sorted topologically, because there may be (non-parent) ancestors\n> that are missing from the package and the best a peer can validate is\n> topology within the package -- this means that a peer can validly (under this\n> BIP) relay transaction packages out of the true topological sort (if all\n> ancestors were included).\n> \n> This makes me wonder how useful this topological rule is.  I suppose there is\n> some value in preventing completely broken implementations from staying\n> connected and so there is no harm in having the rule, but perhaps it would\n> be helpful to add that nodes SHOULD order transactions based on topological\n> sort in the complete transaction graph, so that if missing-from-package\n> ancestors are already known by a peer (which is the expected case when\n> using v1 package relay on transactions that have more than one generation\n> of unconfirmed ancestor) then the remaining transactions are already\n> properly ordered, and this is helpful even if unenforceable in general.\n> \n> The other observation I wanted to make was that having transaction relay\n> gated on whether two nodes agree on chain tip seems like an overly\n> restrictive criteria.  I think an important design principle is that we want to\n> minimize disruption from network splits -- if there are competing blocks\n> found in a small window of time, it's likely that the utxo set is not materially\n> different on the two chains (assuming miners are selecting from roughly the\n> same sets of transactions when this happens, which is typical).  Having\n> transaction relay bifurcate on the two network halves would seem to\n> exacerbate the difference between the two sides of the split -- users ought\n> to be agnostic about how benign splits are resolved and would likely want\n> their transactions to relay across the whole network.\n> \n> Additionally, use of a chain tip might impose a larger burden than is necessary\n> on software that would seek to participate in transaction relay without\n> implementing headers sync/validation.  I don't know what software exists on\n> the network, but I imagine there are a lot of scripts out there for transaction\n> submission to the public p2p network, and in thinking about modifying such a\n> script to utilize package relay it seems like an unnecessary added burden to\n> first learn a node's tip before trying to relay a transaction.\n> \n> Could you explain again what the benefit of including the blockhash is?  It\n> seems like it is just so that a node could prioritize transaction relay from\n> peers with the same chain tip to maximize the likelihood of transaction\n> acceptance, but in the common case this seems like a pretty negligible\n> concern, and in the case of a chain fork that persists for many minutes it\n> seems better to me that we not partition the network into package-relay\n> regimes and just risk a little extra bandwidth in one direction or the other.  If\n> we solve the problem I brought up at the beginning (of de-duplicating\n> package data across peers with a package-wtxid-commitment in the\n> announcement), I think this is just some wasted pkginfo bandwidth on a\n> single-link, and not across links (as we could cache validation failure for a\n> package-hash to avoid re-requesting duplicate pkginfo1 messages).\n> \n> Best,\n> Suhas\n> \n> \n> On Tue, Jun 7, 2022 at 1:57 PM Gloria Zhao via bitcoin-dev <bitcoin-\n> dev at lists.linuxfoundation.org <mailto:bitcoin-\n> dev at lists.linuxfoundation.org> > wrote:\n> \n> \n> \tHi Eric, aj, all,\n> \n> \tSorry for the delayed response. @aj I'm including some paraphrased\n> points from our offline discussion (thanks).\n> \n> \n> \t> Other idea: what if you encode the parent txs as a short hash of the\n> wtxid (something like bip152 short ids? perhaps seeded per peer so collisions\n> will be different per peer?) and include that in the inv announcement?\n> Would that work to avoid a round trip almost all of the time, while still giving\n> you enough info to save bw by deduping parents?\n> \n> \n> \t> As I suggested earlier, a package is fundamentally a compact block\n> (or\n> \t> block) announcement without the header. Compact block (BIP152)\n> announcement\n> \t> is already well-defined and widely implemented...\n> \n> \n> \n> \t> Let us not reinvent the wheel and/or introduce accidental\n> complexity. I see\n> \t> no reason why packaging is not simply BIP152 without the 'header'\n> field, an\n> \t> updated protocol version, and the following sort of changes to\n> names\n> \n> \tInterestingly, \"why not use BIP 152 shortids to save bandwidth?\" is\n> by far the most common suggestion I hear (including offline feedback).\n> Here's a full explanation:\n> \n> \tBIP 152 shortens transaction hashes (32 bytes) to shortids (6 bytes)\n> to save a significant amount of network bandwidth, which is extremely\n> important in block relay. However, this comes at the expense of\n> computational complexity. There is no way to directly calculate a transaction\n> hash from a shortid; upon receipt of a compact block, a node is expected to\n> calculate the shortids of every unconfirmed transaction it knows about to\n> find the matches (BIP 152: [1], Bitcoin Core: [2]). This is expensive but\n> appropriate for block relay, since the block must have a valid Proof of Work\n> and new blocks only come every ~10 minutes. On the other hand, if we\n> require nodes to calculate shortids for every transaction in their mempools\n> every time they receive a package, we are creating a DoS vector.\n> Unconfirmed transactions don't need PoW and, to have a live transaction\n> relay network, we should expect nodes to handle transactions at a high-ish\n> rate (i.e. at least 1000s of times more transactions than blocks). We can't pre-\n> calculate or cache shortids for mempool transactions, since the SipHash key\n> depends on the block hash and a per-connection salt.\n> \n> \tAdditionally, shortid calculation is not designed to prevent intentional\n> individual collisions. If we were to use these shortids to deduplicate\n> transactions we've supposedly already seen, we may have a censorship\n> vector. Again, these tradeoffs make sense for compact block relay (see\n> shortid section in BIP 152 [3]), but not package relay.\n> \n> \tTLDR: DoSy if we calculate shortids on every package and censorship\n> vector if we use shortids for deduplication.\n> \n> \t> Given this message there is no reason\n> \t> to send a (potentially bogus) fee rate with every package. It can\n> only be\n> \t> validated by obtaining the full set of txs, and the only recourse is\n> \t> dropping (etc.) the peer, as is the case with single txs.\n> \n> \n> \tYeah, I agree with this. Combined with the previous discussion with\n> aj (i.e. we can't accurately communicate the incentive compatibility of a\n> package without sending the full graph, and this whole dance is to avoid\n> downloading a few low-fee transactions in uncommon edge cases), I've\n> realized I should remove the fee + weight information from pkginfo. Yay for\n> less complexity!\n> \n> \n> \tAlso, this might be pedantic, but I said something incorrect earlier\n> and would like to correct myself:\n> \n> \t>> In theory, yes, but maybe it was announced earlier (while our\n> node was down?) or had dropped from our mempool or similar, either way\n> we don't have those txs yet.\n> \n> \tI said \"It's fine if they have Erlay, since a sender would know in\n> advance that B is missing and announce it as a package.\" But this isn't true\n> since we're only using reconciliation in place of flooding to announce\n> transactions as they arrive, not for rebroadcast, and we're not doing full\n> mempool set reconciliation. In any case, making sure a node receives the\n> transactions announced when it was offline is not something we guarantee,\n> not an intended use case for package relay, and not worsened by this.\n> \n> \tThanks for your feedback!\n> \n> \tBest,\n> \n> \tGloria\n> \n> \t[1]: https://github.com/bitcoin/bips/blob/master/bip-\n> 0152.mediawiki#cmpctblock\n> \t[2]:\n> https://github.com/bitcoin/bitcoin/blob/master/src/blockencodings.cpp#L49\n> \t[3]: https://github.com/bitcoin/bips/blob/master/bip-\n> 0152.mediawiki#short-transaction-id-calculation\n> \n> \tOn Thu, May 26, 2022 at 3:59 AM <eric at voskuil.org\n> <mailto:eric at voskuil.org> > wrote:\n> \n> \n> \t\tGiven that packages have no header, the package requires\n> identity in a\n> \t\tBIP152 scheme. For example 'header' and 'blockhash' fields\n> can be replaced\n> \t\twith a Merkle root (e.g. \"identity\" field) for the package,\n> uniquely\n> \t\tidentifying the partially-ordered set of txs. And use of\n> 'getdata' (to\n> \t\tobtain a package by hash) can be eliminated (not a use case).\n> \n> \t\te\n> \n> \t\t> -----Original Message-----\n> \t\t> From: eric at voskuil.org <mailto:eric at voskuil.org>\n> <eric at voskuil.org <mailto:eric at voskuil.org> >\n> \t\t> Sent: Wednesday, May 25, 2022 1:52 PM\n> \t\t> To: 'Anthony Towns' <aj at erisian.com.au\n> <mailto:aj at erisian.com.au> >; 'Bitcoin Protocol Discussion'\n> \t\t> <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-\n> dev at lists.linuxfoundation.org> >; 'Gloria Zhao'\n> \t\t> <gloriajzhao at gmail.com <mailto:gloriajzhao at gmail.com> >\n> \t\t> Subject: RE: [bitcoin-dev] Package Relay Proposal\n> \t\t>\n> \t\t> > From: bitcoin-dev <bitcoin-dev-\n> bounces at lists.linuxfoundation.org <mailto:bitcoin-dev-\n> bounces at lists.linuxfoundation.org> > On\n> \t\t> Behalf\n> \t\t> > Of Anthony Towns via bitcoin-dev\n> \t\t> > Sent: Wednesday, May 25, 2022 11:56 AM\n> \t\t>\n> \t\t> > So the other thing is what happens if the peer\n> announcing packages to us\n> \t\t> is\n> \t\t> > dishonest?\n> \t\t> >\n> \t\t> > They announce pkg X, say X has parents A B C and the fee\n> rate is\n> \t\tgarbage.\n> \t\t> But\n> \t\t> > actually X has parent D and the fee rate is excellent. Do\n> we request the\n> \t\t> > package from another peer, or every peer, to double\n> check? Otherwise\n> \t\t> we're\n> \t\t> > allowing the first peer we ask about a package to censor\n> that tx from\n> \t\tus?\n> \t\t> >\n> \t\t> > I think the fix for that is just to provide the fee and weight\n> when\n> \t\t> announcing\n> \t\t> > the package rather than only being asked for its info?\n> Then if one peer\n> \t\t> makes\n> \t\t> > it sound like a good deal you ask for the parent txids from\n> them,\n> \t\tdedupe,\n> \t\t> > request, and verify they were honest about the parents.\n> \t\t>\n> \t\t> Single tx broadcasts do not carry an advertised fee rate,\n> however the'\n> \t\t> feefilter' message (BIP133) provides this distinction. This\n> should be\n> \t\t> interpreted as applicable to packages. Given this message\n> there is no\n> \t\treason\n> \t\t> to send a (potentially bogus) fee rate with every package. It\n> can only be\n> \t\t> validated by obtaining the full set of txs, and the only\n> recourse is\n> \t\t> dropping (etc.) the peer, as is the case with single txs.\n> Relying on the\n> \t\t> existing message is simpler, more consistent, and more\n> efficient.\n> \t\t>\n> \t\t> > >> Is it plausible to add the graph in?\n> \t\t> >\n> \t\t> > Likewise, I think you'd have to have the graph info from\n> many nodes if\n> \t\t> you're\n> \t\t> > going to make decisions based on it and don't want\n> hostile peers to be\n> \t\t> able to\n> \t\t> > trick you into ignoring txs.\n> \t\t> >\n> \t\t> > Other idea: what if you encode the parent txs as a short\n> hash of the\n> \t\twtxid\n> \t\t> > (something like bip152 short ids? perhaps seeded per\n> peer so collisions\n> \t\t> will\n> \t\t> > be different per peer?) and include that in the inv\n> announcement? Would\n> \t\t> > that work to avoid a round trip almost all of the time,\n> while still\n> \t\tgiving\n> \t\t> you\n> \t\t> > enough info to save bw by deduping parents?\n> \t\t>\n> \t\t> As I suggested earlier, a package is fundamentally a\n> compact block (or\n> \t\t> block) announcement without the header. Compact block\n> (BIP152)\n> \t\t> announcement\n> \t\t> is already well-defined and widely implemented. A node\n> should never be\n> \t\t> required to retain an orphan, and BIP152 ensures this is not\n> required.\n> \t\t>\n> \t\t> Once a validated set of txs within the package has been\n> obtained with\n> \t\t> sufficient fee, a fee-optimal node would accept the largest\n> subgraph of\n> \t\tthe\n> \t\t> package that conforms to fee constraints and drop any\n> peer that provides a\n> \t\t> package for which the full graph does not.\n> \t\t>\n> \t\t> Let us not reinvent the wheel and/or introduce accidental\n> complexity. I\n> \t\tsee\n> \t\t> no reason why packaging is not simply BIP152 without the\n> 'header' field,\n> \t\tan\n> \t\t> updated protocol version, and the following sort of changes\n> to names:\n> \t\t>\n> \t\t> sendpkg\n> \t\t> MSG_CMPCT_PKG\n> \t\t> cmpctpkg\n> \t\t> getpkgtxn\n> \t\t> pkgtxn\n> \t\t>\n> \t\t> > > For a maximum 25 transactions,\n> \t\t> > >23*24/2 = 276, seems like 36 bytes for a child-with-\n> parents package.\n> \t\t> >\n> \t\t> > If you're doing short ids that's maybe 25*4B=100B\n> already, then the\n> \t\tabove\n> \t\t> is\n> \t\t> > up to 36% overhead, I guess. Might be worth thinking\n> more about, but\n> \t\t> maybe\n> \t\t> > more interesting with ancestors than just parents.\n> \t\t> >\n> \t\t> > >Also side note, since there are no size/count params,\n> \t\t>\n> \t\t> Size is restricted in the same manner as block and\n> transaction broadcasts,\n> \t\t> by consensus. If the fee rate is sufficient there would be no\n> reason to\n> \t\t> preclude any valid size up to what can be mined in one\n> block (packaging\n> \t\t> across blocks is not economically rational under the\n> assumption that one\n> \t\t> miner cannot expect to mine multiple blocks in a row).\n> Count is\n> \t\tincorporated\n> \t\t> into BIP152 as 'shortids_length'.\n> \t\t>\n> \t\t> > > wondering if we\n> \t\t> > >should just have \"version\" in \"sendpackages\" be a bit\n> field instead of\n> \t\t> > >sending a message for each version. 32 versions should\n> be enough right?\n> \t\t>\n> \t\t> Adding versioning to individual protocols is just a reflection\n> of the\n> \t\t> insufficiency of the initial protocol versioning design, and\n> that of the\n> \t\t> various ad-hoc changes to it (including yet another\n> approach in this\n> \t\t> proposal) that have been introduced to compensate for it,\n> though I'll\n> \t\t> address this in an independent post at some point.\n> \t\t>\n> \t\t> Best,\n> \t\t> e\n> \t\t>\n> \t\t> > Maybe but a couple of messages per connection doesn't\n> really seem worth\n> \t\t> > arguing about?\n> \t\t> >\n> \t\t> > Cheers,\n> \t\t> > aj\n> \t\t> >\n> \t\t> >\n> \t\t> > --\n> \t\t> > Sent from my phone.\n> \t\t> >\n> _______________________________________________\n> \t\t> > bitcoin-dev mailing list\n> \t\t> > bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-\n> dev at lists.linuxfoundation.org>\n> \t\t> >\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n> \n> \n> \t_______________________________________________\n> \tbitcoin-dev mailing list\n> \tbitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-\n> dev at lists.linuxfoundation.org>\n> \thttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Packaged Transaction Relay",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "eric at voskuil.org"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 26058
        }
    },
    {
        "title": "[bitcoin-dev] BGP hijacking on Bitcoin p2p network",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-06-09T18:24:03",
                "message_text_only": "Hi Bitcoin Developers,\n\nBased on this [answer][1] from 2014, bitcoin nodes are vulnerable to BGP hijacking. There was an incident in March 2022, twitter prefix was hijacked and details are shared in 2 blog posts:\n\nhttps://isc.sans.edu/diary/rss/28488\n\nhttps://www.manrs.org/2022/03/lesson-learned-twitter-shored-up-its-routing-security/\n\n'nusenu' had written an article about Tor network being vulnerable to BGP hijacking attacks: https://nusenu.medium.com/how-vulnerable-is-the-tor-network-to-bgp-hijacking-attacks-56d3b2ebfd92\n\nAfter doing some research I found that RPKI ROA and BGP prefix length can help against BGP hijacking attacks. I checked BGP prefix length and RPKI ROA for first 10 IP addresses returned in `getnodeaddresses` in bitcoin core and it had vulnerable results.\n\nhttps://i.stack.imgur.com/KD7jH.png\n\nHas anyone written a detailed blog post or research article like nusenu? If not I would be interested to write one in next couple of weeks?\nLooking for some \"technical\" feedback, links if this was already discussed in past with some solutions.\n\n\u00a0 [1]: https://bitcoin.stackexchange.com/a/30305/133407\n\n\n/dev/fd0\n\nSent with Proton Mail secure email."
            },
            {
                "author": "Elias Rohrer",
                "date": "2022-06-10T06:44:05",
                "message_text_only": "Hi alicexbt,\n\nRouting attacks have actually been studied quite a bit in literature.\n\nYou may be interested in the research articles of Maria Apostolaki et al.[1,2], Muoi Tran et al.[3], and related works.\n\nBest,\n\nElias\n\n[1]: https://arxiv.org/pdf/1605.07524.pdf\n[2]: https://arxiv.org/pdf/1808.06254.pdf\n[3]: https://allquantor.at/blockchainbib/pdf/tran2020stealthier.pdf\n\nOn 9 Jun 2022, at 20:24, alicexbt via bitcoin-dev wrote:\n\n> Hi Bitcoin Developers,\n>\n> Based on this [answer][1] from 2014, bitcoin nodes are vulnerable to BGP hijacking. There was an incident in March 2022, twitter prefix was hijacked and details are shared in 2 blog posts:\n>\n> https://isc.sans.edu/diary/rss/28488\n>\n> https://www.manrs.org/2022/03/lesson-learned-twitter-shored-up-its-routing-security/\n>\n> 'nusenu' had written an article about Tor network being vulnerable to BGP hijacking attacks: https://nusenu.medium.com/how-vulnerable-is-the-tor-network-to-bgp-hijacking-attacks-56d3b2ebfd92\n>\n> After doing some research I found that RPKI ROA and BGP prefix length can help against BGP hijacking attacks. I checked BGP prefix length and RPKI ROA for first 10 IP addresses returned in `getnodeaddresses` in bitcoin core and it had vulnerable results.\n>\n> https://i.stack.imgur.com/KD7jH.png\n>\n> Has anyone written a detailed blog post or research article like nusenu? If not I would be interested to write one in next couple of weeks?\n> Looking for some \"technical\" feedback, links if this was already discussed in past with some solutions.\n>\n> \u00a0 [1]: https://bitcoin.stackexchange.com/a/30305/133407\n>\n>\n> /dev/fd0\n>\n> Sent with Proton Mail secure email.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "BGP hijacking on Bitcoin p2p network",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "alicexbt",
                "Elias Rohrer"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2993
        }
    },
    {
        "title": "[bitcoin-dev] BIP47 Prague Discussion",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2022-06-11T10:01:58",
                "message_text_only": "This discussion took place at Pizza Day Prague 2022[0] after a brief\ndiscussion on Silent Payments[1]. The main points have been summarized\nbelow.\n\nThe discussion was mainly between Alekos Filini, Martin Habov\u0161tiak, and\nmyself, as well as Daniela Brozzoni, Eric Sirion, Pavol Rusnak, Salvatore\nIngala, and others.\n\nAlso available as a gist:\nhttps://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae\n\nAnd my personal opinion can be found in the comments:\nhttps://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae?permalink_comment_id=4197284#gistcomment-4197284\n\n\nImproving BIP47\n\nBIP47 requires a notification transaction prior to making payments. This\ntransaction takes up on-chain space and can easily leak privacy if not\nhandled with extreme caution. In practice this is quite hard.\n\nThe discussion revolved around whether we can a.) minimize the on-chain\nspace required and b.) outsource the notification transaction so the link\nbetween the sender and recipient is no longer apparent on-chain.\n\n\nBIP47 space requirements\n\nAs currently implemented, BIP47 (V1/V2)[2] requires an input key for\nblinding, the blinded sender payment code in an op_return, and the\nrecipient key in an output.\n\nThe first question that came up was whether it is necessary for the\nrecipient to learn the payment code of the sender. The benefit is that this\nenables the recipient to send a notification transaction and subsequent\npayment to the sender, but in practice this never happens. It therefore\nseems acceptable to forego this requirement, as this potentially saves\nspace. The minimum notification payload that seems required is a fresh\nsender key and a static recipient key.\n\nThe sender key should ideally be deterministically derived from the sender\nxpub based on the recipient key. If the user checks all the keys that were\nregistered with the recipient prior to notification, it can statelessly\nfind out whether the sender key was already previously registered. This\nstep can be skipped, which is easier for light clients, but means the\nnotification transaction will have to be resent if the user ever forgets\nthey already sent a notification (such as when restoring from backup).\n\n\nOutsourcing the notification\n\nThe next part of the discussion revolved around the idea of putting\nmultiple notifications in a single transaction that can be outsourced to a\nthird party in order to break the sender/recipient link. This third party\ncould be paid over the Lightning Network for their services.\n\nOne idea was to use the taproot annex to insert the notification payload as\n(discounted) witness data. One downside with this approach is that it\nrequires custom software for the recipient to notice the notification,\nsince it's not tied to an easily noticeable output. The middle ground\nsolution would be to put the sender keys there but still create an output\nfor each recipient key.\n\n\nAllowing collisions\n\nOne interesting point that came up was that you could represent the\nrecipient key using e.g. only 4 bytes (provided you put it in the annex).\nThis leaves a window of 1 in ~4.3 billion for a collision, but the extra\nwork that needs to be performed when it does happen is negligible\n(essentially expecting a payment while there is none). This would reduce\nthe payload from 64 bytes to 36 bytes of witness data.\n\nWhile this did not come up in the discussion, it should be noted that using\nthe annex makes the transaction non-standard[3]. It could either be\nstandardized as the first use case for the annex, or perhaps an alternative\nmethod[4] should be considered.\n\n\n[0] Pizza Day Prague 2022: https://www.pizzaday.cz\n\n[1] Silent Payments:\nhttps://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8\n\n[2] BIP47: https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki\n\n[3] Annex non-standard:\nhttps://github.com/bitcoin/bitcoin/pull/17977/files#diff-ea6d307faa4ec9dfa5abcf6858bc19603079f2b8e110e1d62da4df98f4bdb9c0R250\n\n[4] Using p2wsh:\nhttps://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae?permalink_comment_id=4189419#gistcomment-4189419\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220611/fba8b576/attachment.html>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2022-06-11T14:30:13",
                "message_text_only": "FYI there is a version 3 of bip47 (which Ranvier published somewhere else\n[0]). It already gets them down to a marginal 64 bytes, with a small\nprivacy drawback.\n\nThe transaction from A can be double used as both a notification to Bob and\na payment to Bob. The notification output is multisig OP [Key1] [Key2]\n[Key3] , one being change for A (a sunk cost), K2 being the signal to B,\nand K3 being a blinded code only B can read.\n\n>From there you can simply insert another output to Bob (to actually pay\nhim), insert decoy change outputs, or swap Key1 for Bobs key, making it\nimpossible (at least) to tell *how much* someone is paying to Bob and how\nmuch is change for Alice.\n\nBut everyone does know that a new bidirectional relationship to Bob (from\nsomeone) is being established, of course.\n\n[0]\nhttps://github.com/OpenBitcoinPrivacyProject/rfc/blob/master/obpp-05.mediawiki\n\nPaul\n\n\nOn Sat, Jun 11, 2022, 6:03 AM Ruben Somsen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This discussion took place at Pizza Day Prague 2022[0] after a brief\n> discussion on Silent Payments[1]. The main points have been summarized\n> below.\n>\n> The discussion was mainly between Alekos Filini, Martin Habov\u0161tiak, and\n> myself, as well as Daniela Brozzoni, Eric Sirion, Pavol Rusnak, Salvatore\n> Ingala, and others.\n>\n> Also available as a gist:\n> https://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae\n>\n> And my personal opinion can be found in the comments:\n>\n> https://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae?permalink_comment_id=4197284#gistcomment-4197284\n>\n>\n> Improving BIP47\n>\n> BIP47 requires a notification transaction prior to making payments. This\n> transaction takes up on-chain space and can easily leak privacy if not\n> handled with extreme caution. In practice this is quite hard.\n>\n> The discussion revolved around whether we can a.) minimize the on-chain\n> space required and b.) outsource the notification transaction so the link\n> between the sender and recipient is no longer apparent on-chain.\n>\n>\n> BIP47 space requirements\n>\n> As currently implemented, BIP47 (V1/V2)[2] requires an input key for\n> blinding, the blinded sender payment code in an op_return, and the\n> recipient key in an output.\n>\n> The first question that came up was whether it is necessary for the\n> recipient to learn the payment code of the sender. The benefit is that this\n> enables the recipient to send a notification transaction and subsequent\n> payment to the sender, but in practice this never happens. It therefore\n> seems acceptable to forego this requirement, as this potentially saves\n> space. The minimum notification payload that seems required is a fresh\n> sender key and a static recipient key.\n>\n> The sender key should ideally be deterministically derived from the sender\n> xpub based on the recipient key. If the user checks all the keys that were\n> registered with the recipient prior to notification, it can statelessly\n> find out whether the sender key was already previously registered. This\n> step can be skipped, which is easier for light clients, but means the\n> notification transaction will have to be resent if the user ever forgets\n> they already sent a notification (such as when restoring from backup).\n>\n>\n> Outsourcing the notification\n>\n> The next part of the discussion revolved around the idea of putting\n> multiple notifications in a single transaction that can be outsourced to a\n> third party in order to break the sender/recipient link. This third party\n> could be paid over the Lightning Network for their services.\n>\n> One idea was to use the taproot annex to insert the notification payload\n> as (discounted) witness data. One downside with this approach is that it\n> requires custom software for the recipient to notice the notification,\n> since it's not tied to an easily noticeable output. The middle ground\n> solution would be to put the sender keys there but still create an output\n> for each recipient key.\n>\n>\n> Allowing collisions\n>\n> One interesting point that came up was that you could represent the\n> recipient key using e.g. only 4 bytes (provided you put it in the annex).\n> This leaves a window of 1 in ~4.3 billion for a collision, but the extra\n> work that needs to be performed when it does happen is negligible\n> (essentially expecting a payment while there is none). This would reduce\n> the payload from 64 bytes to 36 bytes of witness data.\n>\n> While this did not come up in the discussion, it should be noted that\n> using the annex makes the transaction non-standard[3]. It could either be\n> standardized as the first use case for the annex, or perhaps an alternative\n> method[4] should be considered.\n>\n>\n> [0] Pizza Day Prague 2022: https://www.pizzaday.cz\n>\n> [1] Silent Payments:\n> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8\n>\n> [2] BIP47: https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki\n>\n> [3] Annex non-standard:\n> https://github.com/bitcoin/bitcoin/pull/17977/files#diff-ea6d307faa4ec9dfa5abcf6858bc19603079f2b8e110e1d62da4df98f4bdb9c0R250\n>\n> [4] Using p2wsh:\n> https://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae?permalink_comment_id=4189419#gistcomment-4189419\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220611/7a1001f1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP47 Prague Discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Paul Sztorc",
                "Ruben Somsen"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9860
        }
    },
    {
        "title": "[bitcoin-dev] RIDDLE: Lightweight anti-Sybil with anonymity in Bitcoin",
        "thread_messages": [
            {
                "author": "AdamISZ",
                "date": "2022-06-12T23:04:47",
                "message_text_only": "List denizens,\n\nAs per the title, a suggested protocol for doing anti-Sybil that isn't too demanding for the users, but actually keeps a decent level of privacy.\n\nNotice how it's mostly focused on a user/customer of a service/product/website, but it could conceivably useful in e.g. anti-Sybil in things like Lightning.\n\nSorry that as usual I write rather long but there are several conveniently arranged sections you can click on :)\n\nhttps://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f\n\n(with apologies for my backronym-ing sins)\n\nCheers,\nwaxwing/AdamISZ\n\n\nSent with Proton Mail secure email."
            },
            {
                "author": "AdamISZ",
                "date": "2022-06-30T21:50:20",
                "message_text_only": "Just a small update to those interested:\nI migrated the gist due to failures of github's new equation formatting feature (which unfortunately started just when I published this gist!), to [1](but comments still on the gist please, or here).\n\nSecondly, I did some research (including toy code) into sublinear ring signatures and Groth/Kohlweiss 2014 can give logarithmic scaled ring signatures, whose security is reducible to that of the Pedersen commitments (essentially ECDLP). I made a note on what this looks like concretely here [2], TLDR 1 o 2 KB for 256-1024 keys. Open question how much the computational load matters. (Ring sig + key image I think is effected via ring sig + \"spend a coin\" part of \"how to leak a secret and spend a coin\", in the language of the paper).\n\nThe above paragraph is mentioned of course to address the question of how practical it might be to get genuinely big anonymity sets. In short, it might be practical. Again to mention: though bilinear pairings crypto could give substantially more efficient constructions, that would not work on 'bare' secp256k1, though there might be a sensible way of 'transferring' over to other curves (I'll leave that to others to figure out!).\n\n[1] https://reyify.com/blog/riddle\n[2] https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f?permalink_comment_id=4210892#gistcomment-4210892\n\nCheers,\nAdamISZ/waxwing\n\n\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Sunday, June 12th, 2022 at 18:04, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> List denizens,\n>\n> As per the title, a suggested protocol for doing anti-Sybil that isn't too demanding for the users, but actually keeps a decent level of privacy.\n>\n> Notice how it's mostly focused on a user/customer of a service/product/website, but it could conceivably useful in e.g. anti-Sybil in things like Lightning.\n>\n> Sorry that as usual I write rather long but there are several conveniently arranged sections you can click on :)\n>\n> https://gist.github.com/AdamISZ/51349418be08be22aa2b4b469e3be92f\n>\n> (with apologies for my backronym-ing sins)\n>\n> Cheers,\n> waxwing/AdamISZ\n>\n>\n>\n> Sent with Proton Mail secure email.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "RIDDLE: Lightweight anti-Sybil with anonymity in Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "AdamISZ"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3004
        }
    },
    {
        "title": "[bitcoin-dev] MuSig2 BIP",
        "thread_messages": [
            {
                "author": "AdamISZ",
                "date": "2022-06-12T23:07:08",
                "message_text_only": "Sent with Proton Mail secure email.\n------- Original Message -------\nOn Thursday, May 26th, 2022 at 12:34, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> Hi Jonas, list,\n> responses inline\n>\n<snip>\n> >\n> > [0] https://github.com/jonasnick/bips/pull/25\n>\n>\n> Right, thanks, will follow up.\n>\n\nJust to drop a note to the thread that as per the contents of that now merged PR, I'm much more comfortable with the contents of the draft on that sticky point re: pubkeys being repeated (and the peripheral points that got raised in that PR discussion).\n\nThanks,\nwaxwing/AdamISZ"
            }
        ],
        "thread_summary": {
            "title": "MuSig2 BIP",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "AdamISZ"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 601
        }
    },
    {
        "title": "[bitcoin-dev] Playing with full-rbf peers for fun and L2s security",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2022-06-14T00:25:11",
                "message_text_only": "Hi list,\n\nRecent discussions among LN devs have brought back on the surface concerns\nabout the security of multi-party funded transactions (coinjoins,\ndual-funded LN channels, on-chain DLCs, ...). It turns out there is a\nlow-fruit, naive DoS vector playable against the funding flow of any such\nconstruction due to the lack of existent full-rbf transaction-relay\ntopology on today's p2p network [0] [1]. While it does not consist in a\ndirect loss of funds, if exploited well I think it's annoying enough to\ninflict significant timevalue loss or fee-bumping waste\nto the future providers or distributed swarm of users doing multi-party\nfunded transactions. Of course, it can be fixed one layer above by\nintroducing either fidelity bonds or a reliable centralized coordinator,\nthough at the price of an overhead per-participant ressources cost and loss\nin system openness [1].\n\nFor that reason, I believe it would be beneficial to the flourishing of\nmulti-party funded transactions to fix the Dos vector by seeing a subset of\nthe network running full-rbf and enabling propagation of honest multi-party\ntransactions to the interested miners, replacing potential non-signaling\ndouble-spend from a malicious counterparty. Moving towards that direction,\nI've submitted a small patch against Bitcoin Core enabling it to turn on\nfull-rbf as a policy, still under review [3]. The default setting stays\n**false**, i.e keeping opt-in RBF as a default replacement policy. I've\nstarted to run the patch on a public node at 146.190.224.15.\n\nIf you're a node operator curious to play with full-rbf, feel free to\nconnect to this node or spawn up a toy, public node yourself. There is a\n##uafrbf libera chat if you would like information on the settings or\nlooking for full-rbf friends (though that step could be automated in the\nfuture by setting up a dedicated network bit and reserving a few outbound\nslots for them).\n\nIf you're a mining operator looking to increase your income, you might be\ninterested to experiment with full-rbf as a policy. Indeed, in the future I\nbelieve the multi-party transactions issuers who need full-rbf to secure\ntheir funding flow should connect by default to full-rbf peers. One can\nconjecture that their transactions are likely to be more compelling in\ntheir feerate as their liquidity needs are higher than the simple\ntransaction. For today, I think we have really few standards and bitcoin\nsoftwares relying on multi-party funded transactions [4].\n\nIf you're a Bitcoin user or business and you don't like full-rbf, please\nexpress an opinion on how it might affect your software/operations. I'm\nalways interested to learn more about mempool and transaction-relay\ninteractions with upper-layers and applications and to listen to feedback\nin those areas, and I guess a lot of other Bitcoin researchers/devs too. I\nknow there have been a lot of concerns about full-rbf in the past, however\nI believe the Bitcoin ecosystem has matured a lot since then.\n\nAny mistakes or missing context is my own.\n\nCheers,\nAntoine\n\n[0] For more info about replace-by-fee, see\nhttps://bitcoinops.org/en/topics/replace-by-fee/\n\n[1] For more details about the DoS vector, see\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\n[2] E.g I think it does not affect the Lightning Pool service, as there is\na preliminary step where the participant funds are locked first in a 2-of-2\nwith the coordinator before being committed in the multi-party batch\ntransaction.\n\n[3] https://github.com/bitcoin/bitcoin/pull/25353\n\n[4] E.g DLCs :\nhttps://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md\n; Lightning dual-funded channel :\nhttps://github.com/lightning/bolts/pull/851\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220613/1a047265/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-15T02:27:20",
                "message_text_only": "On Mon, Jun 13, 2022 at 08:25:11PM -0400, Antoine Riard via bitcoin-dev wrote:\n> If you're a node operator curious to play with full-rbf, feel free to\n> connect to this node or spawn up a toy, public node yourself. There is a\n> ##uafrbf libera chat if you would like information on the settings or\n> looking for full-rbf friends (though that step could be automated in the\n> future by setting up a dedicated network bit and reserving a few outbound\n> slots for them).\n\nI previously maintained a Bitcoin Core fork that did just that, using nServices\nbit 26:\n\nhttps://github.com/petertodd/bitcoin/commit/1cc1a46a633535c42394380b656d681258a111ac\n\nIIRC I was using the code written to prefer segwit peers; I have no idea if a\nsimilar approach is still easy to implement as I haven't worked on the Bitcoin\nCore codebase for years.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/1f57403a/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2022-06-15T02:53:58",
                "message_text_only": "Bitcoin Knots still uses this service bit, FWIW (though due to a bug in some \nolder versions, it wasn't signalled by default). There are probably at least \n100 nodes with full RBF already.\n\nOn Wednesday 15 June 2022 02:27:20 Peter Todd via bitcoin-dev wrote:\n> On Mon, Jun 13, 2022 at 08:25:11PM -0400, Antoine Riard via bitcoin-dev \nwrote:\n> > If you're a node operator curious to play with full-rbf, feel free to\n> > connect to this node or spawn up a toy, public node yourself. There is a\n> > ##uafrbf libera chat if you would like information on the settings or\n> > looking for full-rbf friends (though that step could be automated in the\n> > future by setting up a dedicated network bit and reserving a few outbound\n> > slots for them).\n>\n> I previously maintained a Bitcoin Core fork that did just that, using\n> nServices bit 26:\n>\n> https://github.com/petertodd/bitcoin/commit/1cc1a46a633535c42394380b656d681\n>258a111ac\n>\n> IIRC I was using the code written to prefer segwit peers; I have no idea if\n> a similar approach is still easy to implement as I haven't worked on the\n> Bitcoin Core codebase for years."
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-15T03:18:33",
                "message_text_only": "On Wed, Jun 15, 2022 at 02:53:58AM +0000, Luke Dashjr wrote:\n> Bitcoin Knots still uses this service bit, FWIW (though due to a bug in some \n> older versions, it wasn't signalled by default). There are probably at least \n> 100 nodes with full RBF already.\n\nRight. However it looks like you do not add NODE_REPLACE_BY_FEE to the list\nreturned by GetDesirableServiceFlags, so those nodes won't preferentially peer\nwith each other.\n\nAlso, if NODE_REPLACE_BY_FEE is added to the desirable service flags, it\nideally needs to be supported by the DNS seeds too. Currently it is not.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/db13f666/attachment-0001.sig>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-16T00:16:52",
                "message_text_only": "Hi Antoine,\n\nThanks for opening the pull request to add support for full-rbf in Bitcoin Core. I have a few disagreements with the approach and questions.\n\n> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1].\n\n1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf? If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n\n2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n\n> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy.\n\nMiners can only increase their income if users replace transactions. 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it with full RBF? Or even if we add some users in it who could not signal for some reasons, do you think it would be anything above 5%?\n\n> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n\nI am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems and the lack of basic options in Bitcoin Core to employ/disable different RBF policies. There is also a speculation about making full RBF default in an year which isn't relevant to discuss at this point without trying different RBF policies.\n\nI would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy. This can also be done using GUI if not familiar with config optionmempoolreplacement\u200b.\n\nThe rationale in PR #16171 was insufficient to justify removing it in the first place, had 2 NACKs and was reopened to merge it. Why bother with a few lines of code that may allow someone disable it if required in local mempool since it's only useful when a big percentage of miners utilize it and essentially underused according to the PR author? Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi list,\n>\n> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1]. While it does not consist in a direct loss of funds, if exploited well I think it's annoying enough to inflict significant timevalue loss or fee-bumping waste\n> to the future providers or distributed swarm of users doing multi-party funded transactions. Of course, it can be fixed one layer above by introducing either fidelity bonds or a reliable centralized coordinator, though at the price of an overhead per-participant ressources cost and loss in system openness [1].\n>\n> For that reason, I believe it would be beneficial to the flourishing of multi-party funded transactions to fix the Dos vector by seeing a subset of the network running full-rbf and enabling propagation of honest multi-party transactions to the interested miners, replacing potential non-signaling double-spend from a malicious counterparty. Moving towards that direction, I've submitted a small patch against Bitcoin Core enabling it to turn on full-rbf as a policy, still under review [3]. The default setting stays **false**, i.e keeping opt-in RBF as a default replacement policy. I've started to run the patch on a public node at 146.190.224.15.\n>\n> If you're a node operator curious to play with full-rbf, feel free to connect to this node or spawn up a toy, public node yourself. There is a ##uafrbf libera chat if you would like information on the settings or looking for full-rbf friends (though that step could be automated in the future by setting up a dedicated network bit and reserving a few outbound slots for them).\n>\n> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy. Indeed, in the future I believe the multi-party transactions issuers who need full-rbf to secure their funding flow should connect by default to full-rbf peers. One can conjecture that their transactions are likely to be more compelling in their feerate as their liquidity needs are higher than the simple transaction. For today, I think we have really few standards and bitcoin softwares relying on multi-party funded transactions [4].\n>\n> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n>\n> Any mistakes or missing context is my own.\n>\n> Cheers,\n> Antoine\n>\n> [0] For more info about replace-by-fee, see https://bitcoinops.org/en/topics/replace-by-fee/\n>\n> [1] For more details about the DoS vector, see https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [2] E.g I think it does not affect the Lightning Pool service, as there is a preliminary step where the participant funds are locked first in a 2-of-2 with the coordinator before being committed in the multi-party batch transaction.\n>\n> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>\n> [4] E.g DLCs : https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md ; Lightning dual-funded channel : https://github.com/lightning/bolts/pull/851\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220616/1b45c869/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-06-16T01:02:39",
                "message_text_only": "> If something relies on a policy which can be changed without breaking\nconsensus rules, how is it secure in any case with or without full rbf?\n\nThe security of LN and other related systems are something like: \"given\nproper fees offered, can a transaction be mined within N blocks?\" You're\nsimply not allowed to out-bid your attacker in certain circumstances due to\ntoday's miner incentive-incompatible relay policies.\n\nThere is also a time-value dimension to this with other simpler systems\nwhere your funds can be locked up for potentially weeks for similar reasons.\n\n>  ... arguments about how many people RBF being sufficient or not ...\n\nThe idea that we should only build robust systems after the broken ones are\nattacked is not a serious argument.\n\n> I am not opposed to full-rbf; rather, I am opposed to the notion that\nfull-rbf will solve all problems\n\nThis is a strawman.\n\nFull-RBF is a simple, obvious, incentive-compatible step to getting closer\nto more robust layer two systems. Fixing the rest of the holes is for\nfuture proposals which are a bit more involved and definitely less mature.\n\n>  would suggest users to try Bitcoin Knots instead\n> Developers should provide basic RBF policy options rather than attempting\nto define what constitutes a good policy and removing the ability to\ndisable something when necessary.\n\nIf Knots has these knobs, just use Knots rather than lobby all\nimplementations to have miner incentive incompatible knobs?\n\nCheers,\nGreg\n\nOn Wed, Jun 15, 2022 at 8:27 PM alicexbt via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Antoine,\n>\n>\n> Thanks for opening the pull request to add support for full-rbf in Bitcoin\n> Core. I have a few disagreements with the approach and questions.\n>\n> Recent discussions among LN devs have brought back on the surface concerns\n> about the security of multi-party funded transactions (coinjoins,\n> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n> low-fruit, naive DoS vector playable against the funding flow of any such\n> construction due to the lack of existent full-rbf transaction-relay\n> topology on today's p2p network [0] [1].\n>\n>\n> 1)If something relies on a policy which can be changed without breaking\n> consensus rules, how is it secure in any case with or without full rbf? If\n> I write a python script that expects user to enter char 'a' or 'b' but user\n> can enter 'c' and there is no code to handle exceptions or other chars,\n> will it be secure?\n>\n> 2)full-rbf is not default in the 2 open pull requests, so this experiment\n> still relies on users changing RBF policies manually. If majority of nodes\n> use default opt-in policy, how would this affect vulnerable projects?\n>\n> If you're a mining operator looking to increase your income, you might be\n> interested to experiment with full-rbf as a policy.\n>\n>\n> Miners can only increase their income if users replace transactions. 2-3%\n> transactions are replaced with opt-in RBF, if someone did not replace\n> earlier why would they do it with full RBF? Or even if we add some users in\n> it who could not signal for some reasons, do you think it would be anything\n> above 5%?\n>\n> If you're a Bitcoin user or business and you don't like full-rbf, please\n> express an opinion on how it might affect your software/operations. I'm\n> always interested to learn more about mempool and transaction-relay\n> interactions with upper-layers and applications and to listen to feedback\n> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n> know there have been a lot of concerns about full-rbf in the past, however\n> I believe the Bitcoin ecosystem has matured a lot since then.\n>\n>\n> I am not opposed to full-rbf; rather, I am opposed to the notion that\n> full-rbf will solve all problems and the lack of basic options in Bitcoin\n> Core to employ/disable different RBF policies. There is also a speculation\n> about making full RBF default in an year which isn't relevant to discuss at\n> this point without trying different RBF policies.\n>\n> I would suggest users to try Bitcoin Knots instead which already has an\n> option to disable all RBF policies if required, opt-in and full RBF policy.\n> This can also be done using GUI if not familiar with config option\n> mempoolreplacement\u200b.\n>\n> The rationale in PR #16171 was insufficient to justify removing it in the\n> first place, had 2 NACKs and was reopened to merge it. Why bother with a\n> few lines of code that may allow someone disable it if required in local\n> mempool since it's only useful when a big percentage of miners utilize it\n> and essentially underused according to the PR author? Developers should\n> provide basic RBF policy options rather than attempting to define what\n> constitutes a good policy and removing the ability to disable something\n> when necessary.\n>\n>\n> /dev/fd0\n>\n> Sent with Proton Mail <https://proton.me/> secure email.\n>\n> ------- Original Message -------\n> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi list,\n>\n> Recent discussions among LN devs have brought back on the surface concerns\n> about the security of multi-party funded transactions (coinjoins,\n> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n> low-fruit, naive DoS vector playable against the funding flow of any such\n> construction due to the lack of existent full-rbf transaction-relay\n> topology on today's p2p network [0] [1]. While it does not consist in a\n> direct loss of funds, if exploited well I think it's annoying enough to\n> inflict significant timevalue loss or fee-bumping waste\n> to the future providers or distributed swarm of users doing multi-party\n> funded transactions. Of course, it can be fixed one layer above by\n> introducing either fidelity bonds or a reliable centralized coordinator,\n> though at the price of an overhead per-participant ressources cost and loss\n> in system openness [1].\n>\n> For that reason, I believe it would be beneficial to the flourishing of\n> multi-party funded transactions to fix the Dos vector by seeing a subset of\n> the network running full-rbf and enabling propagation of honest multi-party\n> transactions to the interested miners, replacing potential non-signaling\n> double-spend from a malicious counterparty. Moving towards that direction,\n> I've submitted a small patch against Bitcoin Core enabling it to turn on\n> full-rbf as a policy, still under review [3]. The default setting stays\n> **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n> started to run the patch on a public node at 146.190.224.15.\n>\n> If you're a node operator curious to play with full-rbf, feel free to\n> connect to this node or spawn up a toy, public node yourself. There is a\n> ##uafrbf libera chat if you would like information on the settings or\n> looking for full-rbf friends (though that step could be automated in the\n> future by setting up a dedicated network bit and reserving a few outbound\n> slots for them).\n>\n> If you're a mining operator looking to increase your income, you might be\n> interested to experiment with full-rbf as a policy. Indeed, in the future I\n> believe the multi-party transactions issuers who need full-rbf to secure\n> their funding flow should connect by default to full-rbf peers. One can\n> conjecture that their transactions are likely to be more compelling in\n> their feerate as their liquidity needs are higher than the simple\n> transaction. For today, I think we have really few standards and bitcoin\n> softwares relying on multi-party funded transactions [4].\n>\n> If you're a Bitcoin user or business and you don't like full-rbf, please\n> express an opinion on how it might affect your software/operations. I'm\n> always interested to learn more about mempool and transaction-relay\n> interactions with upper-layers and applications and to listen to feedback\n> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n> know there have been a lot of concerns about full-rbf in the past, however\n> I believe the Bitcoin ecosystem has matured a lot since then.\n>\n> Any mistakes or missing context is my own.\n>\n> Cheers,\n> Antoine\n>\n> [0] For more info about replace-by-fee, see\n> https://bitcoinops.org/en/topics/replace-by-fee/\n>\n> [1] For more details about the DoS vector, see\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [2] E.g I think it does not affect the Lightning Pool service, as there is\n> a preliminary step where the participant funds are locked first in a 2-of-2\n> with the coordinator before being committed in the multi-party batch\n> transaction.\n>\n> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>\n> [4] E.g DLCs :\n> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md\n> ; Lightning dual-funded channel :\n> https://github.com/lightning/bolts/pull/851\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220615/31d6050c/attachment-0001.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-16T01:45:42",
                "message_text_only": "Hi Greg,\n\n> The security of LN and other related systems are something like: \"given proper fees offered, can a transaction be mined within N blocks?\" You're simply not allowed to out-bid your attacker in certain circumstances due to today's miner incentive-incompatible relay policies.\n\nIt is not possible to guarantee that a transaction will be mined within N blocks irrespective of fees. It is vulnerable if a project's security relies on it,and should fix it by changing the security assumptions. Miners can try full-rbf or other policy without core so I won't consider opt-in as incentive-incompatible.\n\n>> ... arguments about how many people RBF being sufficient or not ...\n>\n> The idea that we should only build robust systems after the broken ones are attacked is not a serious argument.\n\nIts true and was even mentioned in PR #16171 that a policy is only useful if enough nodes and miners follow it. We should build robust systems but I don't think this change will help in doing it.\n\n> This is a strawman.\n>\n> Full-RBF is a simple, obvious, incentive-compatible step to getting closer to more robust layer two systems.Fixing the rest of the holes is for future proposals which are a bit more involved and definitely less mature.\n\nI do not have issues with multiple RBF policies being tried out and full-rbf being one of them. My disagreements are with rationale, lack of basic options in Bitcoin Core to employ/disable different RBF policies and a few arguments made in support for full-rbf. Whether it appears strawman or offtopic on github, there should be a place to share these disagreements.\n\n> If Knots has these knobs, just use Knots rather than lobby all implementations to have miner incentive incompatible knobs?\n\nEveryone can share options that would help users in the bitcoin implementation used by 90% nodes. I don't think this is reserved only for a few developers. I would personally use Knots and others are free to try the suggestion or continue using Bitcoin Core.\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Thursday, June 16th, 2022 at 6:32 AM, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n>> If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf?\n>\n> The security of LN and other related systems are something like: \"given proper fees offered, can a transaction be mined within N blocks?\" You're simply not allowed to out-bid your attacker in certain circumstances due to today's miner incentive-incompatible relay policies.\n>\n> There is also a time-value dimension to this with other simpler systems where your funds can be locked up for potentially weeks for similar reasons.\n>\n>> ... arguments about how many people RBF being sufficient or not ...\n>\n> The idea that we should only build robust systems after the broken ones are attacked is not a serious argument.\n>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems\n>\n> This is a strawman.\n>\n> Full-RBF is a simple, obvious, incentive-compatible step to getting closer to more robust layer two systems. Fixing the rest of the holes is for future proposals which are a bit more involved and definitely less mature.\n>\n>> would suggest users to try Bitcoin Knots instead\n>> Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n>\n> If Knots has these knobs, just use Knots rather than lobby all implementations to have miner incentive incompatible knobs?\n>\n> Cheers,\n> Greg\n>\n> On Wed, Jun 15, 2022 at 8:27 PM alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Antoine,\n>>\n>> Thanks for opening the pull request to add support for full-rbf in Bitcoin Core. I have a few disagreements with the approach and questions.\n>>\n>>> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1].\n>>\n>> 1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf? If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n>>\n>> 2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n>>\n>>> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy.\n>>\n>> Miners can only increase their income if users replace transactions. 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it with full RBF? Or even if we add some users in it who could not signal for some reasons, do you think it would be anything above 5%?\n>>\n>>> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems and the lack of basic options in Bitcoin Core to employ/disable different RBF policies. There is also a speculation about making full RBF default in an year which isn't relevant to discuss at this point without trying different RBF policies.\n>>\n>> I would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy. This can also be done using GUI if not familiar with config optionmempoolreplacement\u200b.\n>>\n>> The rationale in PR #16171 was insufficient to justify removing it in the first place, had 2 NACKs and was reopened to merge it. Why bother with a few lines of code that may allow someone disable it if required in local mempool since it's only useful when a big percentage of miners utilize it and essentially underused according to the PR author? Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n>>\n>> /dev/fd0\n>>\n>> Sent with [Proton Mail](https://proton.me/) secure email.\n>>\n>> ------- Original Message -------\n>> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi list,\n>>>\n>>> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1]. While it does not consist in a direct loss of funds, if exploited well I think it's annoying enough to inflict significant timevalue loss or fee-bumping waste\n>>> to the future providers or distributed swarm of users doing multi-party funded transactions. Of course, it can be fixed one layer above by introducing either fidelity bonds or a reliable centralized coordinator, though at the price of an overhead per-participant ressources cost and loss in system openness [1].\n>>>\n>>> For that reason, I believe it would be beneficial to the flourishing of multi-party funded transactions to fix the Dos vector by seeing a subset of the network running full-rbf and enabling propagation of honest multi-party transactions to the interested miners, replacing potential non-signaling double-spend from a malicious counterparty. Moving towards that direction, I've submitted a small patch against Bitcoin Core enabling it to turn on full-rbf as a policy, still under review [3]. The default setting stays **false**, i.e keeping opt-in RBF as a default replacement policy. I've started to run the patch on a public node at 146.190.224.15.\n>>>\n>>> If you're a node operator curious to play with full-rbf, feel free to connect to this node or spawn up a toy, public node yourself. There is a ##uafrbf libera chat if you would like information on the settings or looking for full-rbf friends (though that step could be automated in the future by setting up a dedicated network bit and reserving a few outbound slots for them).\n>>>\n>>> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy. Indeed, in the future I believe the multi-party transactions issuers who need full-rbf to secure their funding flow should connect by default to full-rbf peers. One can conjecture that their transactions are likely to be more compelling in their feerate as their liquidity needs are higher than the simple transaction. For today, I think we have really few standards and bitcoin softwares relying on multi-party funded transactions [4].\n>>>\n>>> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n>>>\n>>> Any mistakes or missing context is my own.\n>>>\n>>> Cheers,\n>>> Antoine\n>>>\n>>> [0] For more info about replace-by-fee, see https://bitcoinops.org/en/topics/replace-by-fee/\n>>>\n>>> [1] For more details about the DoS vector, see https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>>\n>>> [2] E.g I think it does not affect the Lightning Pool service, as there is a preliminary step where the participant funds are locked first in a 2-of-2 with the coordinator before being committed in the multi-party batch transaction.\n>>>\n>>> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>>>\n>>> [4] E.g DLCs : https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md ; Lightning dual-funded channel : https://github.com/lightning/bolts/pull/851\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220616/b5bf2e31/attachment-0001.html>"
            },
            {
                "author": "linuxfoundation.cndm1 at dralias.com",
                "date": "2022-06-16T05:43:33",
                "message_text_only": "alicexbt wrote:\n> I do not have issues with multiple RBF policies being tried out and full-rbf being one of them. My disagreements are with rationale, lack of basic options in Bitcoin Core to employ/disable different RBF policies and a few arguments made in support for full-rbf. Whether it appears strawman or offtopic on github, there should be a place to share these disagreements.\n\nBitcoin Core is open source software, where developers open pull\nrequests to try to get them merged after review. If you see a \"lack of\nbasic options\" and no one has opened a pull request for it, it may be\nfor two reasons. First, it could be that it just doesn't make sense,\nso no one sees a point in implementing it. Secondly, it may be that it\nisn't on anyone's list of priorities. In the second case, you are\nwelcome to share your preference once. Moreover, no one is holding you\nback to implement it yourself and suggest a pull request. However,\nrepeatedly demanding others to do it for you is not helpful in open\nsource software development.\n\ncndm1"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-16T12:47:15",
                "message_text_only": "Hi cndm1,\n\n> If you see a \"lack of basic options\" and no one has opened a pull request for it, it may be for two reasons.\n\nThe basic option to disable all RBF policies in a node's mempool if required was removed in [PR #16171][1]. No one has opened a pull request to revert this because most of the maintainers and a few reviewers agreed with this change. It wasn't required, PR had weak rationale, 2 NACKS and was reopened to merge because some reviewers/maintainers believe its a policy that cannot be maintained. One of the reviewers who NACKed it already maintains the config option to disable all RBF policies in Bitcoin Knots which is a derivative of Bitcoin Core.\n\n> However, repeatedly demanding others to do it for you is not helpful in open source software development.\n\nI am not demanding anyone to add a few lines of code and open a pull request. I am _reviewing_ a pull request in an open source project and sharing my feedback. Even Antoine and Luke agreed to add it if other reviewers have no issues or I can do it. This option in context with another being added for a new RBF policy was being discussed in [PR #25353][2] and my earlier emails in this thread.\n\nOther 'basic options' will be easier to accommodate with `-mempoolreplacement` used in [PR #25373] which is unlikely to be merged.\n\n[1]: https://github.com/bitcoin/bitcoin/pull/16171\n[2]: https://github.com/bitcoin/bitcoin/pull/25353\n[3]: https://github.com/bitcoin/bitcoin/pull/25373\n\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Thursday, June 16th, 2022 at 11:13 AM, linuxfoundation.cndm1--- via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n\n\n\n> alicexbt wrote:\n>\n> > I do not have issues with multiple RBF policies being tried out and full-rbf being one of them. My disagreements are with rationale, lack of basic options in Bitcoin Core to employ/disable different RBF policies and a few arguments made in support for full-rbf. Whether it appears strawman or offtopic on github, there should be a place to share these disagreements.\n>\n> Bitcoin Core is open source software, where developers open pull\n> requests to try to get them merged after review. If you see a \"lack of\n> basic options\" and no one has opened a pull request for it, it may be\n> for two reasons. First, it could be that it just doesn't make sense,\n> so no one sees a point in implementing it. Secondly, it may be that it\n> isn't on anyone's list of priorities. In the second case, you are\n> welcome to share your preference once. Moreover, no one is holding you\n> back to implement it yourself and suggest a pull request. However,\n> repeatedly demanding others to do it for you is not helpful in open\n> source software development.\n>\n> cndm1\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-06-16T13:24:03",
                "message_text_only": "> It is not possible to guarantee that a transaction will be mined within N\nblocks irrespective of fees. It is vulnerable if a project's security\nrelies on it, and should fix it by changing the security assumptions.\n\nIt's not possible to guarantee that any funds can be moved ever. But we\nstill build an entire system assuming we can via an interesting mix of\ncryptography and incentives.\n\nOn Wed, Jun 15, 2022 at 9:45 PM alicexbt <alicexbt at protonmail.com> wrote:\n\n> Hi Greg,\n>\n>\n> The security of LN and other related systems are something like: \"given\n> proper fees offered, can a transaction be mined within N blocks?\" You're\n> simply not allowed to out-bid your attacker in certain circumstances due to\n> today's miner incentive-incompatible relay policies.\n>\n>\n> It is not possible to guarantee that a transaction will be mined within N\n> blocks irrespective of fees. It is vulnerable if a project's security\n> relies on it, and should fix it by changing the security assumptions.\n> Miners can try full-rbf or other policy without core so I won't consider\n> opt-in as incentive-incompatible.\n>\n> > ... arguments about how many people RBF being sufficient or not ...\n>\n> The idea that we should only build robust systems after the broken ones\n> are attacked is not a serious argument.\n>\n>\n> Its true and was even mentioned in PR #16171 that a policy is only useful\n> if enough nodes and miners follow it. We should build robust systems but I\n> don't think this change will help in doing it.\n>\n> This is a strawman.\n>\n> Full-RBF is a simple, obvious, incentive-compatible step to getting closer\n> to more robust layer two systems. Fixing the rest of the holes is for\n> future proposals which are a bit more involved and definitely less mature.\n>\n>\n> I do not have issues with multiple RBF policies being tried out and\n> full-rbf being one of them. My disagreements are with rationale, lack of\n> basic options in Bitcoin Core to employ/disable different RBF policies\n> and a few arguments made in support for full-rbf. Whether it appears\n> strawman or offtopic on github, there should be a place to share these\n> disagreements.\n>\n> If Knots has these knobs, just use Knots rather than lobby all\n> implementations to have miner incentive incompatible knobs?\n>\n>\n> Everyone can share options that would help users in the bitcoin\n> implementation used by 90% nodes. I don't think this is reserved only for a\n> few developers. I would personally use Knots and others are free to try the\n> suggestion or continue using Bitcoin Core.\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail <https://proton.me/> secure email.\n>\n> ------- Original Message -------\n> On Thursday, June 16th, 2022 at 6:32 AM, Greg Sanders <\n> gsanders87 at gmail.com> wrote:\n>\n> > If something relies on a policy which can be changed without breaking\n> consensus rules, how is it secure in any case with or without full rbf?\n>\n> The security of LN and other related systems are something like: \"given\n> proper fees offered, can a transaction be mined within N blocks?\" You're\n> simply not allowed to out-bid your attacker in certain circumstances due to\n> today's miner incentive-incompatible relay policies.\n>\n> There is also a time-value dimension to this with other simpler systems\n> where your funds can be locked up for potentially weeks for similar reasons.\n>\n> > ... arguments about how many people RBF being sufficient or not ...\n>\n> The idea that we should only build robust systems after the broken ones\n> are attacked is not a serious argument.\n>\n> > I am not opposed to full-rbf; rather, I am opposed to the notion that\n> full-rbf will solve all problems\n>\n> This is a strawman.\n>\n> Full-RBF is a simple, obvious, incentive-compatible step to getting closer\n> to more robust layer two systems. Fixing the rest of the holes is for\n> future proposals which are a bit more involved and definitely less mature.\n>\n> > would suggest users to try Bitcoin Knots instead\n> > Developers should provide basic RBF policy options rather than\n> attempting to define what constitutes a good policy and removing the\n> ability to disable something when necessary.\n>\n> If Knots has these knobs, just use Knots rather than lobby all\n> implementations to have miner incentive incompatible knobs?\n>\n> Cheers,\n> Greg\n>\n> On Wed, Jun 15, 2022 at 8:27 PM alicexbt via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Antoine,\n>>\n>>\n>> Thanks for opening the pull request to add support for full-rbf in\n>> Bitcoin Core. I have a few disagreements with the approach and questions.\n>>\n>> Recent discussions among LN devs have brought back on the surface\n>> concerns about the security of multi-party funded transactions (coinjoins,\n>> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n>> low-fruit, naive DoS vector playable against the funding flow of any such\n>> construction due to the lack of existent full-rbf transaction-relay\n>> topology on today's p2p network [0] [1].\n>>\n>>\n>> 1)If something relies on a policy which can be changed without breaking\n>> consensus rules, how is it secure in any case with or without full rbf? If\n>> I write a python script that expects user to enter char 'a' or 'b' but user\n>> can enter 'c' and there is no code to handle exceptions or other chars,\n>> will it be secure?\n>>\n>> 2)full-rbf is not default in the 2 open pull requests, so this experiment\n>> still relies on users changing RBF policies manually. If majority of nodes\n>> use default opt-in policy, how would this affect vulnerable projects?\n>>\n>> If you're a mining operator looking to increase your income, you might be\n>> interested to experiment with full-rbf as a policy.\n>>\n>>\n>> Miners can only increase their income if users replace transactions. 2-3%\n>> transactions are replaced with opt-in RBF, if someone did not replace\n>> earlier why would they do it with full RBF? Or even if we add some users in\n>> it who could not signal for some reasons, do you think it would be anything\n>> above 5%?\n>>\n>> If you're a Bitcoin user or business and you don't like full-rbf, please\n>> express an opinion on how it might affect your software/operations. I'm\n>> always interested to learn more about mempool and transaction-relay\n>> interactions with upper-layers and applications and to listen to feedback\n>> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n>> know there have been a lot of concerns about full-rbf in the past, however\n>> I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that\n>> full-rbf will solve all problems and the lack of basic options in Bitcoin\n>> Core to employ/disable different RBF policies. There is also a speculation\n>> about making full RBF default in an year which isn't relevant to discuss at\n>> this point without trying different RBF policies.\n>>\n>> I would suggest users to try Bitcoin Knots instead which already has an\n>> option to disable all RBF policies if required, opt-in and full RBF policy.\n>> This can also be done using GUI if not familiar with config option\n>> mempoolreplacement\u200b.\n>>\n>> The rationale in PR #16171 was insufficient to justify removing it in the\n>> first place, had 2 NACKs and was reopened to merge it. Why bother with a\n>> few lines of code that may allow someone disable it if required in local\n>> mempool since it's only useful when a big percentage of miners utilize it\n>> and essentially underused according to the PR author? Developers should\n>> provide basic RBF policy options rather than attempting to define what\n>> constitutes a good policy and removing the ability to disable something\n>> when necessary.\n>>\n>>\n>> /dev/fd0\n>>\n>> Sent with Proton Mail <https://proton.me/> secure email.\n>>\n>> ------- Original Message -------\n>> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Hi list,\n>>\n>> Recent discussions among LN devs have brought back on the surface\n>> concerns about the security of multi-party funded transactions (coinjoins,\n>> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n>> low-fruit, naive DoS vector playable against the funding flow of any such\n>> construction due to the lack of existent full-rbf transaction-relay\n>> topology on today's p2p network [0] [1]. While it does not consist in a\n>> direct loss of funds, if exploited well I think it's annoying enough to\n>> inflict significant timevalue loss or fee-bumping waste\n>> to the future providers or distributed swarm of users doing multi-party\n>> funded transactions. Of course, it can be fixed one layer above by\n>> introducing either fidelity bonds or a reliable centralized coordinator,\n>> though at the price of an overhead per-participant ressources cost and loss\n>> in system openness [1].\n>>\n>> For that reason, I believe it would be beneficial to the flourishing of\n>> multi-party funded transactions to fix the Dos vector by seeing a subset of\n>> the network running full-rbf and enabling propagation of honest multi-party\n>> transactions to the interested miners, replacing potential non-signaling\n>> double-spend from a malicious counterparty. Moving towards that direction,\n>> I've submitted a small patch against Bitcoin Core enabling it to turn on\n>> full-rbf as a policy, still under review [3]. The default setting stays\n>> **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n>> started to run the patch on a public node at 146.190.224.15.\n>>\n>> If you're a node operator curious to play with full-rbf, feel free to\n>> connect to this node or spawn up a toy, public node yourself. There is a\n>> ##uafrbf libera chat if you would like information on the settings or\n>> looking for full-rbf friends (though that step could be automated in the\n>> future by setting up a dedicated network bit and reserving a few outbound\n>> slots for them).\n>>\n>> If you're a mining operator looking to increase your income, you might be\n>> interested to experiment with full-rbf as a policy. Indeed, in the future I\n>> believe the multi-party transactions issuers who need full-rbf to secure\n>> their funding flow should connect by default to full-rbf peers. One can\n>> conjecture that their transactions are likely to be more compelling in\n>> their feerate as their liquidity needs are higher than the simple\n>> transaction. For today, I think we have really few standards and bitcoin\n>> softwares relying on multi-party funded transactions [4].\n>>\n>> If you're a Bitcoin user or business and you don't like full-rbf, please\n>> express an opinion on how it might affect your software/operations. I'm\n>> always interested to learn more about mempool and transaction-relay\n>> interactions with upper-layers and applications and to listen to feedback\n>> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n>> know there have been a lot of concerns about full-rbf in the past, however\n>> I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>> Any mistakes or missing context is my own.\n>>\n>> Cheers,\n>> Antoine\n>>\n>> [0] For more info about replace-by-fee, see\n>> https://bitcoinops.org/en/topics/replace-by-fee/\n>>\n>> [1] For more details about the DoS vector, see\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>\n>> [2] E.g I think it does not affect the Lightning Pool service, as there\n>> is a preliminary step where the participant funds are locked first in a\n>> 2-of-2 with the coordinator before being committed in the multi-party batch\n>> transaction.\n>>\n>> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>>\n>> [4] E.g DLCs :\n>> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md\n>> ; Lightning dual-funded channel :\n>> https://github.com/lightning/bolts/pull/851\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220616/8af3abae/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-06-17T01:34:17",
                "message_text_only": "Hi alicexbt,\n\n\nThanks for taking time to review the pull request,\n\n\n> 1)If something relies on a policy which can be changed without breaking\nconsensus rules, how is it secure in any case with or without full rbf?\n\n\nYour Lightning node software relies on far more software and hardware\ncomponents than the transaction-relay p2p network. One could list the\noperating system on which is running your Lightning process or the compiler\ntoolchain turning out your Lightning source code in a binary artifact. Some\nweird kernel's memory mapping change could allow access to your channel\nfunding keys, _without_ breaking the Bitcoin consensus rules [0]. Moreover,\nyour Lightning node is also relying on the existence of a global Internet\nallowing your HTLC transaction to flow from your physical host to the crowd\nof transactions confirming in the blockchain. Due to this \"protocol\nassumption\" your channel balance would be vulnerable to any change in your\nISP routing policy, e.g refusing to accept your IPV4 traffic by a\nsudden desiderata\nto impose an IPV6 supremacy. Still _without_ breaking the Bitcoin consensus\nrules. Of course, the odds of your ISP operator adopting this behavior are\nreally low, mostly because your operator has to bind to social and economic\nconstraints to stay in business.\n\n\nAnd I believe this imperative to stay in business is certainly not absent\nin the incentives of the Bitcoin node operators. You're free to run any\npolicy on your node, especially one hardening the safety of your\noperations beyond\nthe default one. However, if you start to a transaction-relay\nnon-compatible with miner incentives, you won't have an efficient view of\nthe blockspace demand, and from then won't be able to offer compelling\nfeerates to execute your business transactions to satisfy your client\nneeds. Or you won't consolidate your wallet UTXOs at times of low-demand.\nIndeed, a sane visibility of the mempools might not be critical now for your\nBitcoin operations, but this is not likely to become true with miner's\ncoinbase reward lowering with time and the system security relying on a\nfruitful fee market.\n\n\nSo assuming there is a significant number of economically rational entities\nrunning p2p nodes, I think it's a reasonable assumption for Lightning\ndevelopers that a policy maximizing miner's income and economic nodes\noperations\nwill be widely run on the p2p network, and therefore lay its security model\non that. When there is a gap between the economically optimal policy\n(full-rbf) and the effectively deployed one (optin), and this gap constitutes\na flaw for exploitation, I believe it's better to fix it.\n\n\nIf you have a different mode of thinking w.r.t how we should design\nprotocol in a trust-minimized, open, adversarial environment such as\nBitcoin, I'm curious to listen to it.\n\n\n> If I write a python script that expects user to enter char 'a' or 'b' but\nuser can enter 'c' and there is no code to handle exceptions or other\nchars, will it be secure?\n\n\nOf course not. If you deliver any critical software, you should attach a\nsolid manual explaining all the corner cases and rough edges. Even better\nwould be to enshrine the manual directly in your software API to minimize\nthe footgunish behaviors. E.g, with any ECC library, forbidding to reuse\nnonces. If your user still ignores or misread the manual and provides an\ninsecure input, there is not that much you can do.\n\n\nBy analogy, I believe that's the same with Lightning. One recommendation of\nthe deployment manual would be to be always connected to a full-rbf\ntransaction-relay topology. Defaulting to this rule and your node exposes\nfar more surface of attacks. Assuming the manual has been well-written (big\nassumption!), I don't think the system designer would be to blame.\n\n\nThat said, one issue to confess with current Lightning is our lack of\nunderstanding of what should be figured out in the LN user manual for safe\noperations. I would say that's an active area of research [1] [2] [3]\n\n\n> 2)full-rbf is not default in the 2 open pull requests, so this experiment\nstill relies on users changing RBF policies manually. If majority of nodes\nuse default opt-in policy, how would this affect vulnerable projects?\n\n\nIf we define the goal as ensuring there is a significant number of\ntransaction-relay routes between the L2s nodes requiring full-rbf and the\nset of miners supporting this policy, and the set of miners is populated\nenough, there is no need to convince the majority of nodes operators to\nswitch to full-rbf.\n\n\nBeyond landing the 'full-rbf' pull request, in pursuit of a partial\nfull-rbf deployment, I'm thinking of reaching out to Lightning vendors to\nrecommend running LN nodes operators run their full-node with the setting\nenabled. And also to few mining pool operators to advocate the potential\nincrease in their income.\n\n\nGiven there are like 17000 public LN nodes, if half of them adopt full-rbf\nit should give already a good number of full-rbf transaction-relay routes\nacross the p2p network graph. When we're there, we can measure and think\nmore about how to tune the full-rbf sub-topology.\n\n\n> 2-3% transactions are replaced with opt-in RBF, if someone did not\nreplace earlier why would they do it with full RBF?\n\n\nBecause it's breaking the reliability and security of their use-cases.\nUse-cases which didn't exist a few years ago. The mempool DoS vector is\ndescribed here [4]. To the best of my understanding, it might affect a\nbunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p\ncoinjoins, batched submarine swaps out. With the attack described, the\nhonest set of users might not have visibility of the network mempools that\nthere is a malicious, low-cost, opt-out double-spend preventing the\npropagation of their multi-party transaction. With the existence of a\nfull-rbf transaction-relay topology, the multi-party transaction is able to\nreplace the optout.\n\n\nNone of those use-cases were deployed a few years ago, and the\nunderstanding of the interactions with the mempool policy is still nascent\namong their operators. However, if we assume that layering is a way to grow the\nBitcoin ecosystem, as I do, it is reasonable to expect they will constitute\na notable share of the Bitcoin transaction traffic during the next decade.\n\n\n> I am not opposed to full-rbf; rather, I am opposed to the notion that\nfull-rbf will solve all problems\n\n\nI wished we had a magic Silver Bullet (tm) solving all the Bitcoin\nproblems...\n\n\nI'm only advocating a partial full-rbf deployment to solve a real precise\nsecurity issue affecting multi-party funded transactions. That said,\nfull-rbf is far from solving the known set of problems affecting the L2s\ndue to interactions with network mempools. E,g, see package relay\nmotivation [5]\n\n\n> I would suggest users to try Bitcoin Knots instead which already has an\noption to disable all RBF policies if required, opt-in and full RBF policy.\n\n\nSelecting a full-node to underpin any serious Bitcoin infrastructure or\nsecure a significant stack of coins should be submitted to a fully-fledged\ndecision-making process. Many factors are likely to matter such as the\nlevel of activity of the contributor community, the chain of trust w.r.t\ndependencies, the security incident track records, the quality of the\ndocumentation, the exhaustivity and robustness of the set of features, ...\n\n\nThis process might take tens of hours, to be duplicated by the number of\nnode operators who would have to do the full-node vending switch. If you\nconsider the cognitive cost at the level of the Bitcoin ecosystem, it's far\nless costly to implement and review a few lines of codes in Bitcoin Core.\n\n\n> Developers should provide basic RBF policy options rather than attempting\nto define what constitutes a good policy and removing the ability to\ndisable something when necessary.\n\n\nOf course, this statement assumes there is a clear line between the\ndevelopers and the users. Developers are also Bitcoin users, and they're\nmodifying the software to suit their use-case needs. And that's exactly the\npurpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\"\npolicy for a Lightning node, without actually seeking to change the\ndefault. If they're parties interested in implementing more RBF policy\noptions in Bitcoin Core, I think they're free to propose such changes and\ninvest the engineering effort to do so. If you're interested in advancing\nthe state of policy options in Bitcoin Core, there are a lot of interesting\nresources available and communities to encourage you in the learning\nprocess to contribute to the codebase [6].\n\n\nAntoine\n\n\n[0] https://dirtycow.ninja\n\n[1] https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n\n[2] https://arxiv.org/pdf/2006.01418.pdf\n\n[3] https://arxiv.org/pdf/2006.08513.pdf\n\n[4]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\n[5]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html\n\n[6] https://www.summerofbitcoin.org\n\n\nLe jeu. 16 juin 2022 \u00e0 00:15, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n\n> Hi Antoine,\n>\n>\n> Thanks for opening the pull request to add support for full-rbf in Bitcoin\n> Core. I have a disagreements with the approach and questions.\n>\n> Recent discussions among LN devs have brought back on the surface concerns\n> about the security of multi-party funded transactions (coinjoins,\n> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n> low-fruit, naive DoS vector playable against the funding flow of any such\n> construction due to the lack of existent full-rbf transaction-relay\n> topology on today's p2p network [0] [1].\n>\n>\n> 1)If something relies on a policy which can be changed without breaking\n> consensus rules, how is it secure in any case with or without full rbf? If\n> I write a python script that expects user to enter char 'a' or 'b' but user\n> can enter 'c' and there is no code to handle exceptions or other chars,\n> will it be secure?\n>\n> 2)full-rbf is not default in the 2 open pull requests, so this experiment\n> still relies on users changing RBF policies manually. If majority of nodes\n> use default opt-in policy, how would this affect vulnerable projects?\n>\n> If you're a mining operator looking to increase your income, you might be\n> interested to experiment with full-rbf as a policy.\n>\n>\n> Miners can only increase their income if users replace transactions. 2-3%\n> transactions are replaced with opt-in RBF, if someone did not replace\n> earlier why would they do it now even with full RBF? Or even if we add some\n> users in it who could not signal for some reasons, do you think it would be\n> anything above 5%?\n>\n> If you're a Bitcoin user or business and you don't like full-rbf, please\n> express an opinion on how it might affect your software/operations. I'm\n> always interested to learn more about mempool and transaction-relay\n> interactions with upper-layers and applications and to listen to feedback\n> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n> know there have been a lot of concerns about full-rbf in the past, however\n> I believe the Bitcoin ecosystem has matured a lot since then.\n>\n>\n> I am not opposed to full-rbf; rather, I am opposed to the notion that\n> full-rbf will solve all problems and the lack of basic options in Bitcoin\n> Core to employ/disable different RBF policies. There is also a speculation\n> about making full RBF default in an year which isn't relevant to discuss at\n> this point without trying different RBF policies.\n>\n> I would suggest users to try Bitcoin Knots instead which already has an\n> option to disable all RBF policies if required, opt-in and full RBF policy.\n> This can also be done using GUI if not familiar with config option\n> mempoolreplacement\u200b.\n>\n> The rationale in PR #16171 was insufficient to justify removing it in the\n> first place, had 2 NACKs and was reopened to merge it. Why bother with a\n> few lines of code that may allow someone disable it if required in local\n> mempool since it's only useful when a big percentage of miners utilize it\n> and essentially underused according to the PR author? Developers should\n> provide basic RBF policy options rather than attempting to define what\n> constitutes a good policy and removing the ability to disable something\n> when necessary.\n>\n>\n> /dev/fd0\n>\n> Sent with Proton Mail <https://proton.me/> secure email.\n>\n> ------- Original Message -------\n> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi list,\n>\n> Recent discussions among LN devs have brought back on the surface concerns\n> about the security of multi-party funded transactions (coinjoins,\n> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n> low-fruit, naive DoS vector playable against the funding flow of any such\n> construction due to the lack of existent full-rbf transaction-relay\n> topology on today's p2p network [0] [1]. While it does not consist in a\n> direct loss of funds, if exploited well I think it's annoying enough to\n> inflict significant timevalue loss or fee-bumping waste\n> to the future providers or distributed swarm of users doing multi-party\n> funded transactions. Of course, it can be fixed one layer above by\n> introducing either fidelity bonds or a reliable centralized coordinator,\n> though at the price of an overhead per-participant ressources cost and loss\n> in system openness [1].\n>\n> For that reason, I believe it would be beneficial to the flourishing of\n> multi-party funded transactions to fix the Dos vector by seeing a subset of\n> the network running full-rbf and enabling propagation of honest multi-party\n> transactions to the interested miners, replacing potential non-signaling\n> double-spend from a malicious counterparty. Moving towards that direction,\n> I've submitted a small patch against Bitcoin Core enabling it to turn on\n> full-rbf as a policy, still under review [3]. The default setting stays\n> **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n> started to run the patch on a public node at 146.190.224.15.\n>\n> If you're a node operator curious to play with full-rbf, feel free to\n> connect to this node or spawn up a toy, public node yourself. There is a\n> ##uafrbf libera chat if you would like information on the settings or\n> looking for full-rbf friends (though that step could be automated in the\n> future by setting up a dedicated network bit and reserving a few outbound\n> slots for them).\n>\n> If you're a mining operator looking to increase your income, you might be\n> interested to experiment with full-rbf as a policy. Indeed, in the future I\n> believe the multi-party transactions issuers who need full-rbf to secure\n> their funding flow should connect by default to full-rbf peers. One can\n> conjecture that their transactions are likely to be more compelling in\n> their feerate as their liquidity needs are higher than the simple\n> transaction. For today, I think we have really few standards and bitcoin\n> softwares relying on multi-party funded transactions [4].\n>\n> If you're a Bitcoin user or business and you don't like full-rbf, please\n> express an opinion on how it might affect your software/operations. I'm\n> always interested to learn more about mempool and transaction-relay\n> interactions with upper-layers and applications and to listen to feedback\n> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n> know there have been a lot of concerns about full-rbf in the past, however\n> I believe the Bitcoin ecosystem has matured a lot since then.\n>\n> Any mistakes or missing context is my own.\n>\n> Cheers,\n> Antoine\n>\n> [0] For more info about replace-by-fee, see\n> https://bitcoinops.org/en/topics/replace-by-fee/\n>\n> [1] For more details about the DoS vector, see\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [2] E.g I think it does not affect the Lightning Pool service, as there is\n> a preliminary step where the participant funds are locked first in a 2-of-2\n> with the coordinator before being committed in the multi-party batch\n> transaction.\n>\n> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>\n> [4] E.g DLCs :\n> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md\n> ; Lightning dual-funded channel :\n> https://github.com/lightning/bolts/pull/851\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220617/6775746f/attachment-0001.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-17T04:54:11",
                "message_text_only": "Hi Antoine,\n\n> One could list the operating system on which is running your Lightning process or the compiler toolchain turning outyour Lightning source code in a binary artifact. Some weird kernel's memory mapping change could allow access toyour channel funding keys, _without_ breaking the Bitcoin consensus rules [0].\n\nLets consider there are 2 users with name Bob (normal LN user) and Carol (attacker running LN node) which I will use in this email for examples. In this case Bob and Carol can manage security of their OS and it is not affected by others using vulnerable systems or OS.\n\n> Moreover, your Lightning node is alsorelying on the existence of a global Internet allowing your HTLC transaction to flow from your physical hostto the crowd of transactions confirming in the blockchain. Due to this \"protocol assumption\" your channel balancewould be vulnerable to any change in your ISP routing policy, e.g refusing to accept your IPV4 traffic by a suddendesiderata to impose an IPV6 supremacy. Still _without_ breaking the Bitcoin consensus rules. Of course, the odds ofyour ISP operator adopting this behavior are really low, mostly because your operator has to bind to social andeconomic constraints to stay in business.\n\nThe odds are low as you said, this can be managed by Bob and Carol because they can use a better ISP. Others using ISP with some issues may not affect their LN usage.\n\n> And I believe this imperative to stay in business is certainly not absent in the incentives of the Bitcoin nodeoperators. You're free to run any policy on your node, especially one hardening the safety of your operationsbeyond the default one. However, if you start to a transaction-relay non-compatible with miner incentives, youwon't have an efficient view of the blockspace demand, and from then won't be able to offer compelling feeratesto execute your business transactions to satisfy your client needs. Or you won't consolidate yourwallet UTXOs attimesof low-demand. Indeed, a sane visibility of the mempools might not be critical now foryour Bitcoin operations, but this is not likely to become true with miner's coinbase reward lowering with timeand the system securityrelyingon a fruitful fee market.\n\nBob might use full-rbf as its suggested by LN developers for secure LN usage and better for miners. Carol could use a different RBF policy for some nodes and mining. In this case Bob may get affected at some point because of Carol's choice to use a different RBF policy which was not true above.\n\n> So assuming there is a significant number of economically rational entities running p2p nodes, I think it's areasonable assumption for Lightning developers that a policy maximizing miner's income and economic nodesoperations will be widely run on the p2p network, and therefore lay its security model on that. When there is agap between the economically optimal policy (full-rbf) and the effectively deployed one (optin), and this gapconstitutes a flaw for exploitation, I believe it's better to fix it.\n\nAgree with the assumption there is nothing wrong in experimenting with a new RBF policy (non-default) if that helps some users and projects.\n\n> If you have a different mode of thinking w.r.t how we should design protocol in a trust-minimized, open,adversarialenvironment such as Bitcoin, I'm curious to listen to it.\n\nAllowing users to create different mempool policies is great. My thought process is to code for happy path, where X policy is expected for replacement and edge cases where Y policy or no policy would be used. Users can try out different policies and even act as attackers. This is also true for other things in mempool, 'spkreuse=conflict' prevents address reuse in the mempool when using knots. If I assume that address reuse is always relayed, this could become a problem if some users and miners adopt this setting in their mempool.\n\n> Of course not. If you deliver any critical software, you should attach a solid manual explaining all thecorner cases and rough edges. Even better would be to enshrine the manual directly in your software APIto minimize the footgunish behaviors. E.g, with any ECC library, forbidding to reuse nonces. If youruserstill ignores or misread the manual and provides an insecure input, there isnot thatmuch you can do.\n\nAgree with the documentation as it helps users.\n\n> Given there are like 17000 public LN nodes, if half of them adopt full-rbf it should givealready a good number of full-rbf transaction-relay routes across the p2p network graph.When we're there, we can measure and think more about how to tune the full-rbf sub-topology.\n\nSounds good.\n\n> Because it's breaking the reliability and security of their use-cases. Use-cases which didn't exista few years ago. The mempool DoS vector is described here [4]. To the best of my understanding, it mightaffect a bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2pcoinjoins, batched submarineswaps out. With the attack described, the honest set of users might not have visibility of the networkmempools that there is a malicious, low-cost, opt-out double-spend preventing the propagation of their multi-partytransaction. With the existence of a full-rbf transaction-relay topology, the multi-party transactionis able to replace theoptout.\n\nThis makes sense and I would be interested to follow two things once full-rbf is available in a bitcoin core release: 1. Percentage of transaction getting replaced 2. Miners profit (Fee for replaced Tx - Fee for original Tx)\n\nCan you explain how p2p coinjoin is affected with mempool DoS vector with some examples? What is considered a p2p coinjoin? Joinmarket or [Stonewall][1]?\n\n> Selecting a full-node to underpin any serious Bitcoin infrastructure or secure a significant stack of coinsshould be submitted to a fully-fledged decision-making process. Many factors are likely tomattersuch asthe level of activity of the contributor community, the chain of trust w.r.t dependencies, the security incident track records, the quality of the documentation, the exhaustivity and robustness of the set of features, ...\n\nI agree that contributor community and documentation could be improved in Knots.\n\n> Developersare also Bitcoin users, and they're modifying the software to suit their use-case needs. And that's exactlythe purpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\" policy for a Lightning node, without actually seeking to change the default.\n\nI like that default still remains opt-in and cool with different policies being tried out if that helps some users.\n\n> If they'reparties interested in implementing more RBF policy options in Bitcoin Core, I think they're free to propose suchchanges and invest the engineering effort to do so. If you're interested in advancing the state ofpolicy options in Bitcoin Core, there are a lot of interestingresourcesavailable and communities toencourage you in the learning process to contribute to the codebase [6].\n\nThanks for sharing the link. I would love to see 5 RBF policies available to use in bitcoin core. I have already tried experimenting with a few on regtest and will try to open pull request if there are enough people interested to test it on other chains (testnet3, signet, mainnet)\n\n[1]: https://docs.samourai.io/spend-tools\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Friday, June 17th, 2022 at 7:04 AM, Antoine Riard <antoine.riard at gmail.com> wrote:\n\n> Hi alicexbt,\n>\n> Thanks for taking time to review the pull request,\n>\n>> 1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf?\n>\n> Your Lightning node software relies on far more software and hardware components than the transaction-relay p2p network. One could list the operating system on which is running your Lightning process or the compiler toolchain turning out your Lightning source code in a binary artifact. Some weird kernel's memory mapping change could allow access to your channel funding keys, _without_ breaking the Bitcoin consensus rules [0]. Moreover, your Lightning node is also relying on the existence of a global Internet allowing your HTLC transaction to flow from your physical host to the crowd of transactions confirming in the blockchain. Due to this \"protocol assumption\" your channel balance would be vulnerable to any change in your ISP routing policy, e.g refusing to accept your IPV4 traffic by a sudden desiderata to impose an IPV6 supremacy. Still _without_ breaking the Bitcoin consensus rules. Of course, the odds of your ISP operator adopting this behavior are really low, mostly because your operator has to bind to social and economic constraints to stay in business.\n>\n> And I believe this imperative to stay in business is certainly not absent in the incentives of the Bitcoin node operators. You're free to run any policy on your node, especially one hardening the safety of your operationsbeyond the default one. However, if you start to a transaction-relay non-compatible with miner incentives, you won't have an efficient view of the blockspace demand, and from then won't be able to offer compelling feerates to execute your business transactions to satisfy your client needs. Or you won't consolidate your wallet UTXOs at times of low-demand. Indeed, a sane visibility of the mempools might not be critical now for your Bitcoin operations, but this is not likely to become true with miner's coinbase reward lowering with time and the system security relying on a fruitful fee market.\n>\n> So assuming there is a significant number of economically rational entities running p2p nodes, I think it's a reasonable assumption for Lightning developers that a policy maximizing miner's income and economic nodes operations will be widely run on the p2p network, and therefore lay its security model on that. When there is a gap between the economically optimal policy (full-rbf) and the effectively deployed one (optin), and this gap constitutes a flaw for exploitation, I believe it's better to fix it.\n>\n> If you have a different mode of thinking w.r.t how we should design protocol in a trust-minimized, open, adversarialenvironment such as Bitcoin, I'm curious to listen to it.\n>\n>> If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n>\n> Of course not. If you deliver any critical software, you should attach a solid manual explaining all the corner cases and rough edges. Even better would be to enshrine the manual directly in your software API to minimize the footgunish behaviors. E.g, with any ECC library, forbidding to reuse nonces. If your user still ignores or misread the manual and provides an insecure input, there is not that much you can do.\n>\n> By analogy, I believe that's the same with Lightning. One recommendation of the deployment manual would be to be always connected to a full-rbf transaction-relay topology. Defaulting to this rule and your node exposes far more surface of attacks. Assuming the manual has been well-written (big assumption!), I don't think the system designer would be to blame.\n>\n> That said, one issue to confess with current Lightning is our lack of understanding of what should be figured out in the LN user manual for safe operations. I would say that's an active area of research [1] [2] [3]\n>\n>> 2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n>\n> If we define the goal as ensuring there is a significant number of transaction-relay routes between the L2s nodes requiring full-rbf and the set of miners supporting this policy, and the set of miners is populated enough, there is no need to convince the majority of nodes operators to switch to full-rbf.\n>\n> Beyond landing the 'full-rbf' pull request, in pursuit of a partial full-rbf deployment, I'm thinking of reaching out to Lightning vendors to recommend running LN nodes operatorsrun their full-node with the setting enabled. And also to few mining pool operators to advocate the potential increase in their income.\n>\n> Given there are like 17000 public LN nodes, if half of them adopt full-rbf it should give already a good number of full-rbf transaction-relay routes across the p2p network graph. When we're there, we can measure and think more about how to tune the full-rbf sub-topology.\n>\n>> 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it with full RBF?\n>\n> Because it's breaking the reliability and security of their use-cases. Use-cases which didn't exist a few years ago. The mempool DoS vector is described here [4]. To the best of my understanding, it might affect a bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p coinjoins, batched submarine swaps out. With the attack described, the honest set of users might not have visibility of the network mempools that there is a malicious, low-cost, opt-out double-spend preventing the propagation of their multi-party transaction. With the existence of a full-rbf transaction-relay topology, the multi-party transaction is able to replace the optout.\n>\n> None of those use-cases were deployed a few years ago, and the understanding of the interactions with the mempool policy is still nascent among their operators. However, if we assume that layering is a way to grow the Bitcoin ecosystem, as I do, it is reasonable to expect they will constitute a notable share of the Bitcoin transaction traffic during the next decade.\n>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems\n>\n> I wished we had a magic Silver Bullet (tm) solving all the Bitcoin problems...\n>\n> I'm only advocating a partial full-rbf deployment to solve a real precise security issue affecting multi-party funded transactions. That said, full-rbf is far from solving the known set of problems affecting the L2s due to interactions with network mempools. E,g, see package relay motivation [5]\n>\n>> I would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy.\n>\n> Selecting a full-node to underpin any serious Bitcoin infrastructure or secure a significant stack of coins should be submitted to a fully-fledged decision-making process. Many factors are likely to matter such as the level of activity of the contributor community, the chain of trust w.r.t dependencies, the security incident track records, the quality of the documentation, the exhaustivity and robustness of the set of features, ...\n>\n> This process might take tens of hours, to be duplicated by the number of node operators who would have to do the full-node vending switch. If you consider the cognitive cost at the level of the Bitcoin ecosystem, it's far less costly to implement and review a few lines of codes in Bitcoin Core.\n>\n>> Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n>\n> Of course, this statement assumes there is a clear line between the developers and the users. Developers are also Bitcoin users, and they're modifying the software to suit their use-case needs. And that's exactly the purpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\" policy for a Lightning node, without actually seeking to change the default. If they're parties interested in implementing more RBF policy options in Bitcoin Core, I think they're free to propose such changes and invest the engineering effort to do so. If you're interested in advancing the state of policy options in Bitcoin Core, there are a lot of interesting resources available and communities to encourage you in the learning process to contribute to the codebase [6].\n>\n> Antoine\n>\n> [0] https://dirtycow.ninja\n>\n> [1] https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n>\n> [2] https://arxiv.org/pdf/2006.01418.pdf\n>\n> [3] https://arxiv.org/pdf/2006.08513.pdf\n>\n> [4] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [5] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html\n>\n> [6] https://www.summerofbitcoin.org\n>\n> Le jeu. 16 juin 2022 \u00e0 00:15, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n>\n>> Hi Antoine,\n>>\n>> Thanks for opening the pull request to add support for full-rbf in Bitcoin Core. I have a disagreements with the approach and questions.\n>>\n>>> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1].\n>>\n>> 1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf? If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n>>\n>> 2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n>>\n>>> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy.\n>>\n>> Miners can only increase their income if users replace transactions. 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it now even with full RBF? Or even if we add some users in it who could not signal for some reasons, do you think it would be anything above 5%?\n>>\n>>> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems and the lack of basic options in Bitcoin Core to employ/disable different RBF policies. There is also a speculation about making full RBF default in an year which isn't relevant to discuss at this point without trying different RBF policies.\n>>\n>> I would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy. This can also be done using GUI if not familiar with config option mempoolreplacement\u200b.\n>>\n>> The rationale in PR #16171 was insufficient to justify removing it in the first place, had 2 NACKs and was reopened to merge it. Why bother with a few lines of code that may allow someone disable it if required in local mempool since it's only useful when a big percentage of miners utilize it and essentially underused according to the PR author? Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n>>\n>> /dev/fd0\n>>\n>> Sent with [Proton Mail](https://proton.me/) secure email.\n>>\n>> ------- Original Message -------\n>> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi list,\n>>>\n>>> Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1]. While it does not consist in a direct loss of funds, if exploited well I think it's annoying enough to inflict significant timevalue loss or fee-bumping waste\n>>> to the future providers or distributed swarm of users doing multi-party funded transactions. Of course, it can be fixed one layer above by introducing either fidelity bonds or a reliable centralized coordinator, though at the price of an overhead per-participant ressources cost and loss in system openness [1].\n>>>\n>>> For that reason, I believe it would be beneficial to the flourishing of multi-party funded transactions to fix the Dos vector by seeing a subset of the network running full-rbf and enabling propagation of honest multi-party transactions to the interested miners, replacing potential non-signaling double-spend from a malicious counterparty. Moving towards that direction, I've submitted a small patch against Bitcoin Core enabling it to turn on full-rbf as a policy, still under review [3]. The default setting stays **false**, i.e keeping opt-in RBF as a default replacement policy. I've started to run the patch on a public node at 146.190.224.15.\n>>>\n>>> If you're a node operator curious to play with full-rbf, feel free to connect to this node or spawn up a toy, public node yourself. There is a ##uafrbf libera chat if you would like information on the settings or looking for full-rbf friends (though that step could be automated in the future by setting up a dedicated network bit and reserving a few outbound slots for them).\n>>>\n>>> If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy. Indeed, in the future I believe the multi-party transactions issuers who need full-rbf to secure their funding flow should connect by default to full-rbf peers. One can conjecture that their transactions are likely to be more compelling in their feerate as their liquidity needs are higher than the simple transaction. For today, I think we have really few standards and bitcoin softwares relying on multi-party funded transactions [4].\n>>>\n>>> If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n>>>\n>>> Any mistakes or missing context is my own.\n>>>\n>>> Cheers,\n>>> Antoine\n>>>\n>>> [0] For more info about replace-by-fee, see https://bitcoinops.org/en/topics/replace-by-fee/\n>>>\n>>> [1] For more details about the DoS vector, see https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>>\n>>> [2] E.g I think it does not affect the Lightning Pool service, as there is a preliminary step where the participant funds are locked first in a 2-of-2 with the coordinator before being committed in the multi-party batch transaction.\n>>>\n>>> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>>>\n>>> [4] E.g DLCs : https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md ; Lightning dual-funded channel : https://github.com/lightning/bolts/pull/851\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220617/3e36bd4e/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-19T10:42:15",
                "message_text_only": "On Fri, Jun 17, 2022 at 04:54:11AM +0000, alicexbt via bitcoin-dev wrote:\n> > If they'reparties interested in implementing more RBF policy options in Bitcoin Core, I think they're free to propose suchchanges and invest the engineering effort to do so. If you're interested in advancing the state ofpolicy options in Bitcoin Core, there are a lot of interestingresourcesavailable and communities toencourage you in the learning process to contribute to the codebase [6].\n> \n> Thanks for sharing the link. I would love to see 5 RBF policies available to use in bitcoin core. I have already tried experimenting with a few on regtest and will try to open pull request if there are enough people interested to test it on other chains (testnet3, signet, mainnet)\n\nI don't think more RBF policies in Bitcoin Core helps much. RBF policies aren't\nvery useful in isolation: unless you're getting your txs to other nodes/miners\nvia special peering efforts, the only reason to run an uncommon RBF policy is\nto accomodate local software with obsolete expectations about mempool behavior.\nThat's why my full-RBF patch advertised a special service bit, and did\npreferential peering with other nodes advertising that service bit.\n\nBitcoin Core isn't going to do that for every RBF policy. So there's no reason\nwe should try to accomodate a bunch of them.\n\nI can understand a -fullrbf flag from a political point of view, in the process\nof enabling full-RBF all the time. But there's no reason to go beyond that.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/e61b93ad/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-06-21T23:43:23",
                "message_text_only": "HI alicexbt,\n\n> Lets consider there are 2 users with name Bob (normal LN user) and Carol\n(attacker running LN node) which I will use in this email for examples. In\nthis case Bob and Carol can manage security of their OS and it is not\naffected by others using vulnerable systems or OS.\n\nYes, I believe my argument was the set of components making the security of\nyour LN node is far beyond Bitcoin softwares. Of course, you might review\nby yourself the millions lines of code entering in the trusted computing\nbase (OS, bootloader, BIOS, device firmwares, essential utilities, ...) on\nwhich your cryptocurrency software stack lays out, and as such exercise an\nextended span of control on your personal computation. Though, while I hope\nwe'll have more LN node operators doing so, I'm not sure it's realistic to\nexpect it will be the behavior standard among them..\n\n> The odds are low as you said, this can be managed by Bob and Carol\nbecause they can use a better ISP. Others using ISP with some issues may\nnot affect their LN usage.\n\nSure, though as I would like to underscore being dependent on a Bitcoin\nnode policy and being dependent on a ISP internet traffic routing policy\ncould be analyzed as logically equivalent, all things are equal. That said,\nif your personal risk aversion is too high for the Lightning security\nmodel, once it's well-understood there is a strong reliance on a\ncensorship-resistant tx-relay network back to economically-rational miners,\nyou're free to not use it and satisfy yourself with the Bitcoin base layer.\n\n> Bob might use full-rbf as its suggested by LN developers for secure LN\nusage and better for miners. Carol could use a different RBF policy for\nsome nodes and mining. In this case Bob may get affected at some point\nbecause of Carol's choice to use a different RBF policy which was not true\nabove.\n\nIndeed, your secure LN usage is going to be dependent of the number of p2p\nnetwork nodes running an economically-rational policy like full-rbf. That\nsaid, I think it's reasonable to assume that the players of the Bitcoin\ngame are economically-rational, and as such incentived to pick up a policy\nsuch as full-rbf. I know the term \"economically-rational\" is poorly defined\nhere, and I think it could be interesting for any academic with an economic\nbackground to study the incentives of Bitcoin actors.\n\n> Allowing users to create different mempool policies is great. My thought\nprocess is to code for happy path, where X policy is expected for\nreplacement and edge cases where Y policy or no policy would be used. Users\ncan try out different policies and even act as attackers. This is also true\nfor other things in mempool, 'spkreuse=conflict' prevents address reuse in\nthe mempool when using knots. If I assume that address reuse is always\nrelayed, this could become a problem if some users and miners adopt this\nsetting in their mempool.\n\nAgree, I'm all in for people to experiment with mempool policies. Though at\nthe end it's a software engineering resource question. If users are\ninterested in more features, they're always free to implement themselves.\nReally, the binary distinction developers-vs-users doesn't make sense and\nif we would like Bitcoin to be successful in the long-term, we should\npromote high degree of software literacy among bitcoiners.\n\n> This makes sense and I would be interested to follow two things once\nfull-rbf is available in a bitcoin core release: 1. Percentage of\ntransaction getting replaced 2. Miners profit (Fee for replaced Tx - Fee\nfor original Tx)\n\nYes, I would be interested too to have those metrics once full-rbf is\navailable in a bitcoin core release. I think that's something every\nfull-rbf curious node operator could observe on its own with a few more\nloggers, at least for the first metric.\n\n> Can you explain how p2p coinjoin is affected with mempool DoS vector with\nsome examples? What is considered a p2p coinjoin? Joinmarket or\n[Stonewall][1]?\n\nI don't remember the Joinmarket code right now and I don't know the ins and\nouts of Samourai coinjoin as I'm not sure the code is open source. Though\nlet's say for a p2p coinjoin as one you can build once you have implemented\nLN's interactive construction protocol [0].\n\n[0] https://github.com/lightning/bolts/pull/851\n\nHere the DoS attack situation :\n- Alice, Bob and Caroll would like to coinjoin 3 inputs to 3 outputs\n- Each of the input is singly controlled by one party, e.g Alice owns input\nA, Bob owns input B, ...\n- Alice, Bob and Caroll exchanges a PSBT to build a multi-party funded\ntransaction (the coinjoin_tx)\n- Alice is elected as the multi-party transaction broadcaster once the\nsignatures have been exchanged\n- The block feerate is around 10sat/vb\n- One of the transaction input signals opt-in RBF, the transaction is\nattached a compelling feerate 10sat/vb\n- Caroll broadcasts a double-spend of her own input C, the double-spend is\nattached with a low-fee (1sat/vb) and it does _not_ signal opt-in RBF\n- Alice broadcasts the multi-party transaction, it is rejected by the\nnetwork mempools because Alice double-spend is already present\n- Two alternatives are offered to the coinjoin participants :\n\nAlternative A)\n- They estimate the multi-party feerate as not high enough\n- They fee-bump at 20sat/vb\n- Caroll double-spend one of the input of her malicious double-spend to\neject it from the network mempools\n- The multi-party transaction is confirmed at a block feerare far above\nwhat was necessary\n- Alice, Bob, Caroll have loss fee-bumping value without compensation\n- Note, even if Caroll is attacker and assuming the fee-bumping burden is\nfairly spread among participants, the economic loss inflicted is asymmetric\n\nAlternative B)\n- They wait until some time-out\n- They double-spend their own inputs, Alice double-spend utxo A, Bob\ndouble-spend utxo B\n- They wasted the timevalue of their inputs for the time-out delay\n- Note, even if Caroll is attacker and loss some timevalue too, the\neconomic loss inflicted is asymmetric\n\nLet me know if you see any error or wrong in this DoS scenario exposure. I\nbelieve it's fairly simple to execute\nfor a medium-skilled attacker.\n\nAntoine\n\nLe ven. 17 juin 2022 \u00e0 00:54, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n\n> Hi Antoine,\n>\n>\n> One could list the operating system on which is running your Lightning\n> process or the compiler toolchain turning out your Lightning source code\n> in a binary artifact. Some weird kernel's memory mapping change could allow\n> access to your channel funding keys, _without_ breaking the Bitcoin\n> consensus rules [0].\n>\n>\n> Lets consider there are 2 users with name Bob (normal LN user) and Carol\n> (attacker running LN node) which I will use in this email for examples. In\n> this case Bob and Carol can manage security of their OS and it is not\n> affected by others using vulnerable systems or OS.\n>\n> Moreover, your Lightning node is also relying on the existence of a\n> global Internet allowing your HTLC transaction to flow from your physical\n> host to the crowd of transactions confirming in the blockchain. Due to\n> this \"protocol assumption\" your channel balance would be vulnerable to\n> any change in your ISP routing policy, e.g refusing to accept your IPV4\n> traffic by a sudden desiderata to impose an IPV6 supremacy. Still\n> _without_ breaking the Bitcoin consensus rules. Of course, the odds of your\n> ISP operator adopting this behavior are really low, mostly because your\n> operator has to bind to social and economic constraints to stay in\n> business.\n>\n>\n> The odds are low as you said, this can be managed by Bob and Carol because\n> they can use a better ISP. Others using ISP with some issues may not affect\n> their LN usage.\n>\n> And I believe this imperative to stay in business is certainly not absent\n> in the incentives of the Bitcoin node operators. You're free to run any\n> policy on your node, especially one hardening the safety of your operations\n>  beyond the default one. However, if you start to a transaction-relay\n> non-compatible with miner incentives, you won't have an efficient view of\n> the blockspace demand, and from then won't be able to offer compelling\n> feerates to execute your business transactions to satisfy your client\n> needs. Or you won't consolidate your wallet UTXOs at times of low-demand.\n> Indeed, a sane visibility of the mempools might not be critical now for your\n> Bitcoin operations, but this is not likely to become true with miner's\n> coinbase reward lowering with time and the system security relying on a\n> fruitful fee market.\n>\n>\n> Bob might use full-rbf as its suggested by LN developers for secure LN\n> usage and better for miners. Carol could use a different RBF policy for\n> some nodes and mining. In this case Bob may get affected at some point\n> because of Carol's choice to use a different RBF policy which was not true\n> above.\n>\n>\n> So assuming there is a significant number of economically rational\n> entities running p2p nodes, I think it's a reasonable assumption for\n> Lightning developers that a policy maximizing miner's income and economic\n> nodes operations will be widely run on the p2p network, and therefore lay\n> its security model on that. When there is a gap between the economically\n> optimal policy (full-rbf) and the effectively deployed one (optin), and\n> this gap constitutes a flaw for exploitation, I believe it's better to\n> fix it.\n>\n>\n> Agree with the assumption there is nothing wrong in experimenting with a\n> new RBF policy (non-default) if that helps some users and projects.\n>\n> If you have a different mode of thinking w.r.t how we should design\n> protocol in a trust-minimized, open, adversarial environment such as\n> Bitcoin, I'm curious to listen to it.\n>\n>\n> Allowing users to create different mempool policies is great. My thought\n> process is to code for happy path, where X policy is expected for\n> replacement and edge cases where Y policy or no policy would be used. Users\n> can try out different policies and even act as attackers. This is also true\n> for other things in mempool, 'spkreuse=conflict' prevents address reuse in\n> the mempool when using knots. If I assume that address reuse is always\n> relayed, this could become a problem if some users and miners adopt this\n> setting in their mempool.\n>\n> Of course not. If you deliver any critical software, you should attach a\n> solid manual explaining all the corner cases and rough edges. Even better\n> would be to enshrine the manual directly in your software API to minimize\n> the footgunish behaviors. E.g, with any ECC library, forbidding to reuse\n> nonces. If your user still ignores or misread the manual and provides an\n> insecure input, there is not that much you can do.\n>\n>\n> Agree with the documentation as it helps users.\n>\n> Given there are like 17000 public LN nodes, if half of them adopt full-rbf\n> it should give already a good number of full-rbf transaction-relay routes\n> across the p2p network graph. When we're there, we can measure and think\n> more about how to tune the full-rbf sub-topology.\n>\n>\n> Sounds good.\n>\n> Because it's breaking the reliability and security of their use-cases.\n> Use-cases which didn't exist a few years ago. The mempool DoS vector is\n> described here [4]. To the best of my understanding, it might affect a\n> bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p\n> coinjoins, batched submarine swaps out. With the attack described, the\n> honest set of users might not have visibility of the network mempools\n> that there is a malicious, low-cost, opt-out double-spend preventing the\n> propagation of their multi-party transaction. With the existence of a\n> full-rbf transaction-relay topology, the multi-party transaction is able\n> to replace the optout.\n>\n>\n> This makes sense and I would be interested to follow two things once\n> full-rbf is available in a bitcoin core release: 1. Percentage of\n> transaction getting replaced 2. Miners profit (Fee for replaced Tx - Fee\n> for original Tx)\n>\n> Can you explain how p2p coinjoin is affected with mempool DoS vector with\n> some examples? What is considered a p2p coinjoin? Joinmarket or\n> [Stonewall][1]?\n>\n> Selecting a full-node to underpin any serious Bitcoin infrastructure or\n> secure a significant stack of coins should be submitted to a\n> fully-fledged decision-making process. Many factors are likely to matter such\n> as the level of activity of the contributor community, the chain of trust\n> w.r.t dependencies, the security incident track records, the quality of\n> the documentation, the exhaustivity and robustness of the set of features,\n> ...\n>\n>\n> I agree that contributor community and documentation could be improved in\n> Knots.\n>\n> Developers are also Bitcoin users, and they're modifying the software to\n> suit their use-case needs. And that's exactly the purpose of the\n> 'full-rbf' PR I'm proposing, aiming to propose a \"good\" policy for a\n> Lightning node, without actually seeking to change the default.\n>\n>\n> I like that default still remains opt-in and cool with different policies\n> being tried out if that helps some users.\n>\n>  If they're parties interested in implementing more RBF policy options in\n> Bitcoin Core, I think they're free to propose such changes and invest the\n> engineering effort to do so. If you're interested in advancing the state of\n>  policy options in Bitcoin Core, there are a lot of interesting resources available\n> and communities to encourage you in the learning process to contribute to\n> the codebase [6].\n>\n>\n> Thanks for sharing the link. I would love to see 5 RBF policies available\n> to use in bitcoin core. I have already tried experimenting with a few on\n> regtest and will try to open pull request if there are enough people\n> interested to test it on other chains (testnet3, signet, mainnet)\n>\n>\n> [1]: https://docs.samourai.io/spend-tools\n>\n>\n> /dev/fd0\n>\n>\n> Sent with Proton Mail <https://proton.me/> secure email.\n>\n> ------- Original Message -------\n> On Friday, June 17th, 2022 at 7:04 AM, Antoine Riard <\n> antoine.riard at gmail.com> wrote:\n>\n> Hi alicexbt,\n>\n>\n> Thanks for taking time to review the pull request,\n>\n>\n> > 1)If something relies on a policy which can be changed without breaking\n> consensus rules, how is it secure in any case with or without full rbf?\n>\n>\n> Your Lightning node software relies on far more software and hardware\n> components than the transaction-relay p2p network. One could list the\n> operating system on which is running your Lightning process or the compiler\n> toolchain turning out your Lightning source code in a binary artifact.\n> Some weird kernel's memory mapping change could allow access to your\n> channel funding keys, _without_ breaking the Bitcoin consensus rules [0].\n> Moreover, your Lightning node is also relying on the existence of a\n> global Internet allowing your HTLC transaction to flow from your physical\n> host to the crowd of transactions confirming in the blockchain. Due to\n> this \"protocol assumption\" your channel balance would be vulnerable to\n> any change in your ISP routing policy, e.g refusing to accept your IPV4\n> traffic by a sudden desiderata to impose an IPV6 supremacy. Still\n> _without_ breaking the Bitcoin consensus rules. Of course, the odds of your\n> ISP operator adopting this behavior are really low, mostly because your\n> operator has to bind to social and economic constraints to stay in\n> business.\n>\n>\n> And I believe this imperative to stay in business is certainly not absent\n> in the incentives of the Bitcoin node operators. You're free to run any\n> policy on your node, especially one hardening the safety of your operations beyond\n> the default one. However, if you start to a transaction-relay\n> non-compatible with miner incentives, you won't have an efficient view of\n> the blockspace demand, and from then won't be able to offer compelling\n> feerates to execute your business transactions to satisfy your client\n> needs. Or you won't consolidate your wallet UTXOs at times of low-demand.\n> Indeed, a sane visibility of the mempools might not be critical now for your\n> Bitcoin operations, but this is not likely to become true with miner's\n> coinbase reward lowering with time and the system security relying on a\n> fruitful fee market.\n>\n>\n> So assuming there is a significant number of economically rational\n> entities running p2p nodes, I think it's a reasonable assumption for\n> Lightning developers that a policy maximizing miner's income and economic\n> nodes operations will be widely run on the p2p network, and therefore lay\n> its security model on that. When there is a gap between the economically\n> optimal policy (full-rbf) and the effectively deployed one (optin), and\n> this gap constitutes a flaw for exploitation, I believe it's better to\n> fix it.\n>\n>\n> If you have a different mode of thinking w.r.t how we should design\n> protocol in a trust-minimized, open, adversarial environment such as\n> Bitcoin, I'm curious to listen to it.\n>\n>\n> > If I write a python script that expects user to enter char 'a' or 'b'\n> but user can enter 'c' and there is no code to handle exceptions or other\n> chars, will it be secure?\n>\n>\n> Of course not. If you deliver any critical software, you should attach a\n> solid manual explaining all the corner cases and rough edges. Even better\n> would be to enshrine the manual directly in your software API to minimize\n> the footgunish behaviors. E.g, with any ECC library, forbidding to reuse\n> nonces. If your user still ignores or misread the manual and provides an\n> insecure input, there is not that much you can do.\n>\n>\n> By analogy, I believe that's the same with Lightning. One recommendation\n> of the deployment manual would be to be always connected to a full-rbf\n> transaction-relay topology. Defaulting to this rule and your node exposes\n> far more surface of attacks. Assuming the manual has been well-written (big\n> assumption!), I don't think the system designer would be to blame.\n>\n>\n> That said, one issue to confess with current Lightning is our lack of\n> understanding of what should be figured out in the LN user manual for\n> safe operations. I would say that's an active area of research [1] [2] [3]\n>\n>\n> > 2)full-rbf is not default in the 2 open pull requests, so this\n> experiment still relies on users changing RBF policies manually. If\n> majority of nodes use default opt-in policy, how would this affect\n> vulnerable projects?\n>\n>\n> If we define the goal as ensuring there is a significant number of\n> transaction-relay routes between the L2s nodes requiring full-rbf and the\n> set of miners supporting this policy, and the set of miners is populated\n> enough, there is no need to convince the majority of nodes operators to\n> switch to full-rbf.\n>\n>\n> Beyond landing the 'full-rbf' pull request, in pursuit of a partial\n> full-rbf deployment, I'm thinking of reaching out to Lightning vendors to\n> recommend running LN nodes operators run their full-node with the setting\n> enabled. And also to few mining pool operators to advocate the potential\n> increase in their income.\n>\n>\n> Given there are like 17000 public LN nodes, if half of them adopt full-rbf\n> it should give already a good number of full-rbf transaction-relay routes\n> across the p2p network graph. When we're there, we can measure and think\n> more about how to tune the full-rbf sub-topology.\n>\n>\n> > 2-3% transactions are replaced with opt-in RBF, if someone did not\n> replace earlier why would they do it with full RBF?\n>\n>\n> Because it's breaking the reliability and security of their use-cases.\n> Use-cases which didn't exist a few years ago. The mempool DoS vector is\n> described here [4]. To the best of my understanding, it might affect a\n> bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p\n> coinjoins, batched submarine swaps out. With the attack described, the\n> honest set of users might not have visibility of the network mempools\n> that there is a malicious, low-cost, opt-out double-spend preventing the\n> propagation of their multi-party transaction. With the existence of a\n> full-rbf transaction-relay topology, the multi-party transaction is able\n> to replace the optout.\n>\n>\n> None of those use-cases were deployed a few years ago, and the\n> understanding of the interactions with the mempool policy is still\n> nascent among their operators. However, if we assume that layering is a way\n> to grow the Bitcoin ecosystem, as I do, it is reasonable to expect they\n> will constitute a notable share of the Bitcoin transaction traffic during\n> the next decade.\n>\n>\n> > I am not opposed to full-rbf; rather, I am opposed to the notion that\n> full-rbf will solve all problems\n>\n>\n> I wished we had a magic Silver Bullet (tm) solving all the Bitcoin\n> problems...\n>\n>\n> I'm only advocating a partial full-rbf deployment to solve a real precise\n> security issue affecting multi-party funded transactions. That said,\n> full-rbf is far from solving the known set of problems affecting the L2s\n> due to interactions with network mempools. E,g, see package relay\n> motivation [5]\n>\n>\n> > I would suggest users to try Bitcoin Knots instead which already has an\n> option to disable all RBF policies if required, opt-in and full RBF policy.\n>\n>\n> Selecting a full-node to underpin any serious Bitcoin infrastructure or\n> secure a significant stack of coins should be submitted to a\n> fully-fledged decision-making process. Many factors are likely to matter\n> such as the level of activity of the contributor community, the chain of\n> trust w.r.t dependencies, the security incident track records, the\n> quality of the documentation, the exhaustivity and robustness of the set of\n> features, ...\n>\n>\n> This process might take tens of hours, to be duplicated by the number of\n> node operators who would have to do the full-node vending switch. If you\n> consider the cognitive cost at the level of the Bitcoin ecosystem, it's\n> far less costly to implement and review a few lines of codes in Bitcoin\n> Core.\n>\n>\n> > Developers should provide basic RBF policy options rather than\n> attempting to define what constitutes a good policy and removing the\n> ability to disable something when necessary.\n>\n>\n> Of course, this statement assumes there is a clear line between the\n> developers and the users. Developers are also Bitcoin users, and they're\n> modifying the software to suit their use-case needs. And that's exactly the\n> purpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\"\n> policy for a Lightning node, without actually seeking to change the\n> default. If they're parties interested in implementing more RBF policy\n> options in Bitcoin Core, I think they're free to propose such changes and\n> invest the engineering effort to do so. If you're interested in advancing\n> the state of policy options in Bitcoin Core, there are a lot of\n> interesting resources available and communities to encourage you in the\n> learning process to contribute to the codebase [6].\n>\n>\n> Antoine\n>\n>\n> [0] https://dirtycow.ninja\n>\n> [1]\n> https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n>\n> [2] https://arxiv.org/pdf/2006.01418.pdf\n>\n> [3] https://arxiv.org/pdf/2006.08513.pdf\n>\n> [4]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [5]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html\n>\n> [6] https://www.summerofbitcoin.org\n>\n>\n> Le jeu. 16 juin 2022 \u00e0 00:15, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n>\n>> Hi Antoine,\n>>\n>>\n>> Thanks for opening the pull request to add support for full-rbf in\n>> Bitcoin Core. I have a disagreements with the approach and questions.\n>>\n>> Recent discussions among LN devs have brought back on the surface\n>> concerns about the security of multi-party funded transactions (coinjoins,\n>> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n>> low-fruit, naive DoS vector playable against the funding flow of any such\n>> construction due to the lack of existent full-rbf transaction-relay\n>> topology on today's p2p network [0] [1].\n>>\n>>\n>> 1)If something relies on a policy which can be changed without breaking\n>> consensus rules, how is it secure in any case with or without full rbf? If\n>> I write a python script that expects user to enter char 'a' or 'b' but user\n>> can enter 'c' and there is no code to handle exceptions or other chars,\n>> will it be secure?\n>>\n>> 2)full-rbf is not default in the 2 open pull requests, so this experiment\n>> still relies on users changing RBF policies manually. If majority of nodes\n>> use default opt-in policy, how would this affect vulnerable projects?\n>>\n>> If you're a mining operator looking to increase your income, you might be\n>> interested to experiment with full-rbf as a policy.\n>>\n>>\n>> Miners can only increase their income if users replace transactions. 2-3%\n>> transactions are replaced with opt-in RBF, if someone did not replace\n>> earlier why would they do it now even with full RBF? Or even if we add some\n>> users in it who could not signal for some reasons, do you think it would be\n>> anything above 5%?\n>>\n>> If you're a Bitcoin user or business and you don't like full-rbf, please\n>> express an opinion on how it might affect your software/operations. I'm\n>> always interested to learn more about mempool and transaction-relay\n>> interactions with upper-layers and applications and to listen to feedback\n>> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n>> know there have been a lot of concerns about full-rbf in the past, however\n>> I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>>\n>> I am not opposed to full-rbf; rather, I am opposed to the notion that\n>> full-rbf will solve all problems and the lack of basic options in Bitcoin\n>> Core to employ/disable different RBF policies. There is also a speculation\n>> about making full RBF default in an year which isn't relevant to discuss at\n>> this point without trying different RBF policies.\n>>\n>> I would suggest users to try Bitcoin Knots instead which already has an\n>> option to disable all RBF policies if required, opt-in and full RBF policy.\n>> This can also be done using GUI if not familiar with config option\n>> mempoolreplacement\u200b.\n>>\n>> The rationale in PR #16171 was insufficient to justify removing it in the\n>> first place, had 2 NACKs and was reopened to merge it. Why bother with a\n>> few lines of code that may allow someone disable it if required in local\n>> mempool since it's only useful when a big percentage of miners utilize it\n>> and essentially underused according to the PR author? Developers should\n>> provide basic RBF policy options rather than attempting to define what\n>> constitutes a good policy and removing the ability to disable something\n>> when necessary.\n>>\n>>\n>> /dev/fd0\n>>\n>> Sent with Proton Mail <https://proton.me/> secure email.\n>>\n>> ------- Original Message -------\n>> On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Hi list,\n>>\n>> Recent discussions among LN devs have brought back on the surface\n>> concerns about the security of multi-party funded transactions (coinjoins,\n>> dual-funded LN channels, on-chain DLCs, ...). It turns out there is a\n>> low-fruit, naive DoS vector playable against the funding flow of any such\n>> construction due to the lack of existent full-rbf transaction-relay\n>> topology on today's p2p network [0] [1]. While it does not consist in a\n>> direct loss of funds, if exploited well I think it's annoying enough to\n>> inflict significant timevalue loss or fee-bumping waste\n>> to the future providers or distributed swarm of users doing multi-party\n>> funded transactions. Of course, it can be fixed one layer above by\n>> introducing either fidelity bonds or a reliable centralized coordinator,\n>> though at the price of an overhead per-participant ressources cost and loss\n>> in system openness [1].\n>>\n>> For that reason, I believe it would be beneficial to the flourishing of\n>> multi-party funded transactions to fix the Dos vector by seeing a subset of\n>> the network running full-rbf and enabling propagation of honest multi-party\n>> transactions to the interested miners, replacing potential non-signaling\n>> double-spend from a malicious counterparty. Moving towards that direction,\n>> I've submitted a small patch against Bitcoin Core enabling it to turn on\n>> full-rbf as a policy, still under review [3]. The default setting stays\n>> **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n>> started to run the patch on a public node at 146.190.224.15.\n>>\n>> If you're a node operator curious to play with full-rbf, feel free to\n>> connect to this node or spawn up a toy, public node yourself. There is a\n>> ##uafrbf libera chat if you would like information on the settings or\n>> looking for full-rbf friends (though that step could be automated in the\n>> future by setting up a dedicated network bit and reserving a few outbound\n>> slots for them).\n>>\n>> If you're a mining operator looking to increase your income, you might be\n>> interested to experiment with full-rbf as a policy. Indeed, in the future I\n>> believe the multi-party transactions issuers who need full-rbf to secure\n>> their funding flow should connect by default to full-rbf peers. One can\n>> conjecture that their transactions are likely to be more compelling in\n>> their feerate as their liquidity needs are higher than the simple\n>> transaction. For today, I think we have really few standards and bitcoin\n>> softwares relying on multi-party funded transactions [4].\n>>\n>> If you're a Bitcoin user or business and you don't like full-rbf, please\n>> express an opinion on how it might affect your software/operations. I'm\n>> always interested to learn more about mempool and transaction-relay\n>> interactions with upper-layers and applications and to listen to feedback\n>> in those areas, and I guess a lot of other Bitcoin researchers/devs too. I\n>> know there have been a lot of concerns about full-rbf in the past, however\n>> I believe the Bitcoin ecosystem has matured a lot since then.\n>>\n>> Any mistakes or missing context is my own.\n>>\n>> Cheers,\n>> Antoine\n>>\n>> [0] For more info about replace-by-fee, see\n>> https://bitcoinops.org/en/topics/replace-by-fee/\n>>\n>> [1] For more details about the DoS vector, see\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>\n>> [2] E.g I think it does not affect the Lightning Pool service, as there\n>> is a preliminary step where the participant funds are locked first in a\n>> 2-of-2 with the coordinator before being committed in the multi-party batch\n>> transaction.\n>>\n>> [3] https://github.com/bitcoin/bitcoin/pull/25353\n>>\n>> [4] E.g DLCs :\n>> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md\n>> ; Lightning dual-funded channel :\n>> https://github.com/lightning/bolts/pull/851\n>>\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220621/721b7e8e/attachment-0001.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-06-26T16:40:24",
                "message_text_only": "Hi Antoine,\n\nThanks for sharing the DoS attack example with alternatives.\n\n> - Caroll broadcasts a double-spend of her own input C, the double-spend is attached with a low-fee (1sat/vb) and it does _not_ signal opt-in RBF\n> - Alice broadcasts the multi-party transaction, it is rejected by the network mempools because Alice double-spend is already present\n\nI think this affects almost all types of coinjoin transaction including coordinator based implementations. I tried a few things and have already reported details for an example DoS attack to one of the team but there is no response yet.\n\nIt was fun playing with RBF, DoS and Coinjoin. Affected projects should share their opinion about full-rbf as it seems it might improve things.\n\nExample:\n\nIn Wasabi an attacker can broadcast a transaction spending input used in coinjoin after sending signature in the round. This would result in a coinjoin tx which never gets relayed: https://nitter.net/1440000bytes/status/1540727534093905920\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Tuesday, June 21st, 2022 at 11:43 PM, Antoine Riard <antoine.riard at gmail.com> wrote:\n\n\n> HI alicexbt,\n>\n> > Lets consider there are 2 users with name Bob (normal LN user) and Carol (attacker running LN node) which I will use in this email for examples. In this case Bob and Carol can manage security of their OS and it is not affected by others using vulnerable systems or OS.\n>\n> Yes, I believe my argument was the set of components making the security of your LN node is far beyond Bitcoin softwares. Of course, you might review by yourself the millions lines of code entering in the trusted computing base (OS, bootloader, BIOS, device firmwares, essential utilities, ...) on which your cryptocurrency software stack lays out, and as such exercise an extended span of control on your personal computation. Though, while I hope we'll have more LN node operators doing so, I'm not sure it's realistic to expect it will be the behavior standard among them..\n>\n> > The odds are low as you said, this can be managed by Bob and Carol because they can use a better ISP. Others using ISP with some issues may not affect their LN usage.\n>\n> Sure, though as I would like to underscore being dependent on a Bitcoin node policy and being dependent on a ISP internet traffic routing policy could be analyzed as logically equivalent, all things are equal. That said, if your personal risk aversion is too high for the Lightning security model, once it's well-understood there is a strong reliance on a censorship-resistant tx-relay network back to economically-rational miners, you're free to not use it and satisfy yourself with the Bitcoin base layer.\n>\n> > Bob might use full-rbf as its suggested by LN developers for secure LN usage and better for miners. Carol could use a different RBF policy for some nodes and mining. In this case Bob may get affected at some point because of Carol's choice to use a different RBF policy which was not true above.\n>\n> Indeed, your secure LN usage is going to be dependent of the number of p2p network nodes running an economically-rational policy like full-rbf. That said, I think it's reasonable to assume that the players of the Bitcoin game are economically-rational, and as such incentived to pick up a policy such as full-rbf. I know the term \"economically-rational\" is poorly defined here, and I think it could be interesting for any academic with an economic background to study the incentives of Bitcoin actors.\n>\n> > Allowing users to create different mempool policies is great. My thought process is to code for happy path, where X policy is expected for replacement and edge cases where Y policy or no policy would be used. Users can try out different policies and even act as attackers. This is also true for other things in mempool, 'spkreuse=conflict' prevents address reuse in the mempool when using knots. If I assume that address reuse is always relayed, this could become a problem if some users and miners adopt this setting in their mempool.\n>\n> Agree, I'm all in for people to experiment with mempool policies. Though at the end it's a software engineering resource question. If users are interested in more features, they're always free to implement themselves. Really, the binary distinction developers-vs-users doesn't make sense and if we would like Bitcoin to be successful in the long-term, we should promote high degree of software literacy among bitcoiners.\n>\n> > This makes sense and I would be interested to follow two things once full-rbf is available in a bitcoin core release: 1. Percentage of transaction getting replaced 2. Miners profit (Fee for replaced Tx - Fee for original Tx)\n>\n> Yes, I would be interested too to have those metrics once full-rbf is available in a bitcoin core release. I think that's something every full-rbf curious node operator could observe on its own with a few more loggers, at least for the first metric.\n>\n> > Can you explain how p2p coinjoin is affected with mempool DoS vector with some examples? What is considered a p2p coinjoin? Joinmarket or [Stonewall][1]?\n>\n> I don't remember the Joinmarket code right now and I don't know the ins and outs of Samourai coinjoin as I'm not sure the code is open source. Though let's say for a p2p coinjoin as one you can build once you have implemented LN's interactive construction protocol [0].\n>\n> [0] https://github.com/lightning/bolts/pull/851\n>\n> Here the DoS attack situation :\n> - Alice, Bob and Caroll would like to coinjoin 3 inputs to 3 outputs\n> - Each of the input is singly controlled by one party, e.g Alice owns input A, Bob owns input B, ...\n> - Alice, Bob and Caroll exchanges a PSBT to build a multi-party funded transaction (the coinjoin_tx)\n> - Alice is elected as the multi-party transaction broadcaster once the signatures have been exchanged\n> - The block feerate is around 10sat/vb\n> - One of the transaction input signals opt-in RBF, the transaction is attached a compelling feerate 10sat/vb\n> - Caroll broadcasts a double-spend of her own input C, the double-spend is attached with a low-fee (1sat/vb) and it does _not_ signal opt-in RBF\n> - Alice broadcasts the multi-party transaction, it is rejected by the network mempools because Alice double-spend is already present\n> - Two alternatives are offered to the coinjoin participants :\n>\n> Alternative A)\n> - They estimate the multi-party feerate as not high enough\n> - They fee-bump at 20sat/vb\n> - Caroll double-spend one of the input of her malicious double-spend to eject it from the network mempools\n> - The multi-party transaction is confirmed at a block feerare far above what was necessary\n> - Alice, Bob, Caroll have loss fee-bumping value without compensation\n> - Note, even if Caroll is attacker and assuming the fee-bumping burden is fairly spread among participants, the economic loss inflicted is asymmetric\n>\n> Alternative B)\n> - They wait until some time-out\n> - They double-spend their own inputs, Alice double-spend utxo A, Bob double-spend utxo B\n> - They wasted the timevalue of their inputs for the time-out delay\n> - Note, even if Caroll is attacker and loss some timevalue too, the economic loss inflicted is asymmetric\n>\n> Let me know if you see any error or wrong in this DoS scenario exposure. I believe it's fairly simple to execute\n> for a medium-skilled attacker.\n>\n> Antoine\n>\n> Le ven. 17 juin 2022 \u00e0 00:54, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n>\n> > Hi Antoine,\n> >\n> >\n> >\n> > > One could list the operating system on which is running your Lightning process or the compiler toolchain turning out your Lightning source code in a binary artifact. Some weird kernel's memory mapping change could allow access to your channel funding keys, _without_ breaking the Bitcoin consensus rules [0].\n> >\n> > Lets consider there are 2 users with name Bob (normal LN user) and Carol (attacker running LN node) which I will use in this email for examples. In this case Bob and Carol can manage security of their OS and it is not affected by others using vulnerable systems or OS.\n> >\n> >\n> > > Moreover, your Lightning node is also relying on the existence of a global Internet allowing your HTLC transaction to flow from your physical host to the crowd of transactions confirming in the blockchain. Due to this \"protocol assumption\" your channel balance would be vulnerable to any change in your ISP routing policy, e.g refusing to accept your IPV4 traffic by a sudden desiderata to impose an IPV6 supremacy. Still _without_ breaking the Bitcoin consensus rules. Of course, the odds of your ISP operator adopting this behavior are really low, mostly because your operator has to bind to social and economic constraints to stay in business.\n> >\n> > The odds are low as you said, this can be managed by Bob and Carol because they can use a better ISP. Others using ISP with some issues may not affect their LN usage.\n> >\n> >\n> > > And I believe this imperative to stay in business is certainly not absent in the incentives of the Bitcoin node operators. You're free to run any policy on your node, especially one hardening the safety of your operations beyond the default one. However, if you start to a transaction-relay non-compatible with miner incentives, you won't have an efficient view of the blockspace demand, and from then won't be able to offer compelling feerates to execute your business transactions to satisfy your client needs. Or you won't consolidate your wallet UTXOs at times of low-demand. Indeed, a sane visibility of the mempools might not be critical now for your Bitcoin operations, but this is not likely to become true with miner's coinbase reward lowering with time and the system security relying on a fruitful fee market.\n> >\n> > Bob might use full-rbf as its suggested by LN developers for secure LN usage and better for miners. Carol could use a different RBF policy for some nodes and mining. In this case Bob may get affected at some point because of Carol's choice to use a different RBF policy which was not true above.\n> >\n> >\n> >\n> > > So assuming there is a significant number of economically rational entities running p2p nodes, I think it's a reasonable assumption for Lightning developers that a policy maximizing miner's income and economic nodes operations will be widely run on the p2p network, and therefore lay its security model on that. When there is a gap between the economically optimal policy (full-rbf) and the effectively deployed one (optin), and this gap constitutes a flaw for exploitation, I believe it's better to fix it.\n> >\n> > Agree with the assumption there is nothing wrong in experimenting with a new RBF policy (non-default) if that helps some users and projects.\n> >\n> >\n> > > If you have a different mode of thinking w.r.t how we should design protocol in a trust-minimized, open, adversarial environment such as Bitcoin, I'm curious to listen to it.\n> >\n> > Allowing users to create different mempool policies is great. My thought process is to code for happy path, where X policy is expected for replacement and edge cases where Y policy or no policy would be used. Users can try out different policies and even act as attackers. This is also true for other things in mempool, 'spkreuse=conflict' prevents address reuse in the mempool when using knots. If I assume that address reuse is always relayed, this could become a problem if some users and miners adopt this setting in their mempool.\n> >\n> >\n> > > Of course not. If you deliver any critical software, you should attach a solid manual explaining all the corner cases and rough edges. Even better would be to enshrine the manual directly in your software API to minimize the footgunish behaviors. E.g, with any ECC library, forbidding to reuse nonces. If your user still ignores or misread the manual and provides an insecure input, there is not that much you can do.\n> >\n> > Agree with the documentation as it helps users.\n> >\n> >\n> > > Given there are like 17000 public LN nodes, if half of them adopt full-rbf it should give already a good number of full-rbf transaction-relay routes across the p2p network graph. When we're there, we can measure and think more about how to tune the full-rbf sub-topology.\n> >\n> > Sounds good.\n> >\n> >\n> > > Because it's breaking the reliability and security of their use-cases. Use-cases which didn't exist a few years ago. The mempool DoS vector is described here [4]. To the best of my understanding, it might affect a bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p coinjoins, batched submarine swaps out. With the attack described, the honest set of users might not have visibility of the network mempools that there is a malicious, low-cost, opt-out double-spend preventing the propagation of their multi-party transaction. With the existence of a full-rbf transaction-relay topology, the multi-party transaction is able to replace the optout.\n> >\n> > This makes sense and I would be interested to follow two things once full-rbf is available in a bitcoin core release: 1. Percentage of transaction getting replaced 2. Miners profit (Fee for replaced Tx - Fee for original Tx)\n> >\n> >\n> > Can you explain how p2p coinjoin is affected with mempool DoS vector with some examples? What is considered a p2p coinjoin? Joinmarket or [Stonewall][1]?\n> >\n> >\n> > > Selecting a full-node to underpin any serious Bitcoin infrastructure or secure a significant stack of coins should be submitted to a fully-fledged decision-making process. Many factors are likely to matter such as the level of activity of the contributor community, the chain of trust w.r.t dependencies, the security incident track records, the quality of the documentation, the exhaustivity and robustness of the set of features, ...\n> >\n> > I agree that contributor community and documentation could be improved in Knots.\n> >\n> >\n> > > Developers are also Bitcoin users, and they're modifying the software to suit their use-case needs. And that's exactly the purpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\" policy for a Lightning node, without actually seeking to change the default.\n> >\n> > I like that default still remains opt-in and cool with different policies being tried out if that helps some users.\n> >\n> >\n> > > If they're parties interested in implementing more RBF policy options in Bitcoin Core, I think they're free to propose such changes and invest the engineering effort to do so. If you're interested in advancing the state of policy options in Bitcoin Core, there are a lot of interesting resources available and communities to encourage you in the learning process to contribute to the codebase [6].\n> >\n> > Thanks for sharing the link. I would love to see 5 RBF policies available to use in bitcoin core. I have already tried experimenting with a few on regtest and will try to open pull request if there are enough people interested to test it on other chains (testnet3, signet, mainnet)\n> >\n> >\n> > [1]: https://docs.samourai.io/spend-tools\n> >\n> >\n> >\n> >\n> > /dev/fd0\n> >\n> >\n> >\n> > Sent with Proton Mail secure email.\n> >\n> > ------- Original Message -------\n> > On Friday, June 17th, 2022 at 7:04 AM, Antoine Riard <antoine.riard at gmail.com> wrote:\n> >\n> >\n> > > Hi alicexbt,\n> > >\n> > >\n> > >\n> > > Thanks for taking time to review the pull request,\n> > >\n> > >\n> > >\n> > > > 1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf?\n> > >\n> > >\n> > >\n> > > Your Lightning node software relies on far more software and hardware components than the transaction-relay p2p network. One could list the operating system on which is running your Lightning process or the compiler toolchain turning out your Lightning source code in a binary artifact. Some weird kernel's memory mapping change could allow access to your channel funding keys, _without_ breaking the Bitcoin consensus rules [0]. Moreover, your Lightning node is also relying on the existence of a global Internet allowing your HTLC transaction to flow from your physical host to the crowd of transactions confirming in the blockchain. Due to this \"protocol assumption\" your channel balance would be vulnerable to any change in your ISP routing policy, e.g refusing to accept your IPV4 traffic by a sudden desiderata to impose an IPV6 supremacy. Still _without_ breaking the Bitcoin consensus rules. Of course, the odds of your ISP operator adopting this behavior are really low, mostly because your operator has to bind to social and economic constraints to stay in business.\n> > >\n> > >\n> > >\n> > > And I believe this imperative to stay in business is certainly not absent in the incentives of the Bitcoin node operators. You're free to run any policy on your node, especially one hardening the safety of your operations beyond the default one. However, if you start to a transaction-relay non-compatible with miner incentives, you won't have an efficient view of the blockspace demand, and from then won't be able to offer compelling feerates to execute your business transactions to satisfy your client needs. Or you won't consolidate your wallet UTXOs at times of low-demand. Indeed, a sane visibility of the mempools might not be critical now for your Bitcoin operations, but this is not likely to become true with miner's coinbase reward lowering with time and the system security relying on a fruitful fee market.\n> > >\n> > >\n> > >\n> > > So assuming there is a significant number of economically rational entities running p2p nodes, I think it's a reasonable assumption for Lightning developers that a policy maximizing miner's income and economic nodes operations will be widely run on the p2p network, and therefore lay its security model on that. When there is a gap between the economically optimal policy (full-rbf) and the effectively deployed one (optin), and this gap constitutes a flaw for exploitation, I believe it's better to fix it.\n> > >\n> > >\n> > >\n> > > If you have a different mode of thinking w.r.t how we should design protocol in a trust-minimized, open, adversarial environment such as Bitcoin, I'm curious to listen to it.\n> > >\n> > >\n> > >\n> > > > If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n> > >\n> > >\n> > >\n> > > Of course not. If you deliver any critical software, you should attach a solid manual explaining all the corner cases and rough edges. Even better would be to enshrine the manual directly in your software API to minimize the footgunish behaviors. E.g, with any ECC library, forbidding to reuse nonces. If your user still ignores or misread the manual and provides an insecure input, there is not that much you can do.\n> > >\n> > >\n> > >\n> > > By analogy, I believe that's the same with Lightning. One recommendation of the deployment manual would be to be always connected to a full-rbf transaction-relay topology. Defaulting to this rule and your node exposes far more surface of attacks. Assuming the manual has been well-written (big assumption!), I don't think the system designer would be to blame.\n> > >\n> > >\n> > >\n> > > That said, one issue to confess with current Lightning is our lack of understanding of what should be figured out in the LN user manual for safe operations. I would say that's an active area of research [1] [2] [3]\n> > >\n> > >\n> > >\n> > > > 2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n> > >\n> > >\n> > >\n> > > If we define the goal as ensuring there is a significant number of transaction-relay routes between the L2s nodes requiring full-rbf and the set of miners supporting this policy, and the set of miners is populated enough, there is no need to convince the majority of nodes operators to switch to full-rbf.\n> > >\n> > >\n> > >\n> > > Beyond landing the 'full-rbf' pull request, in pursuit of a partial full-rbf deployment, I'm thinking of reaching out to Lightning vendors to recommend running LN nodes operators run their full-node with the setting enabled. And also to few mining pool operators to advocate the potential increase in their income.\n> > >\n> > >\n> > >\n> > > Given there are like 17000 public LN nodes, if half of them adopt full-rbf it should give already a good number of full-rbf transaction-relay routes across the p2p network graph. When we're there, we can measure and think more about how to tune the full-rbf sub-topology.\n> > >\n> > >\n> > >\n> > > > 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it with full RBF?\n> > >\n> > >\n> > >\n> > > Because it's breaking the reliability and security of their use-cases. Use-cases which didn't exist a few years ago. The mempool DoS vector is described here [4]. To the best of my understanding, it might affect a bunch of use-cases, such as dual-funded channels, on-chain DLCs, p2p coinjoins, batched submarine swaps out. With the attack described, the honest set of users might not have visibility of the network mempools that there is a malicious, low-cost, opt-out double-spend preventing the propagation of their multi-party transaction. With the existence of a full-rbf transaction-relay topology, the multi-party transaction is able to replace the optout.\n> > >\n> > >\n> > >\n> > > None of those use-cases were deployed a few years ago, and the understanding of the interactions with the mempool policy is still nascent among their operators. However, if we assume that layering is a way to grow the Bitcoin ecosystem, as I do, it is reasonable to expect they will constitute a notable share of the Bitcoin transaction traffic during the next decade.\n> > >\n> > >\n> > >\n> > > > I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems\n> > >\n> > >\n> > >\n> > > I wished we had a magic Silver Bullet (tm) solving all the Bitcoin problems...\n> > >\n> > >\n> > >\n> > > I'm only advocating a partial full-rbf deployment to solve a real precise security issue affecting multi-party funded transactions. That said, full-rbf is far from solving the known set of problems affecting the L2s due to interactions with network mempools. E,g, see package relay motivation [5]\n> > >\n> > >\n> > >\n> > > > I would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy.\n> > >\n> > >\n> > >\n> > > Selecting a full-node to underpin any serious Bitcoin infrastructure or secure a significant stack of coins should be submitted to a fully-fledged decision-making process. Many factors are likely to matter such as the level of activity of the contributor community, the chain of trust w.r.t dependencies, the security incident track records, the quality of the documentation, the exhaustivity and robustness of the set of features, ...\n> > >\n> > >\n> > >\n> > > This process might take tens of hours, to be duplicated by the number of node operators who would have to do the full-node vending switch. If you consider the cognitive cost at the level of the Bitcoin ecosystem, it's far less costly to implement and review a few lines of codes in Bitcoin Core.\n> > >\n> > >\n> > >\n> > > > Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n> > >\n> > >\n> > >\n> > > Of course, this statement assumes there is a clear line between the developers and the users. Developers are also Bitcoin users, and they're modifying the software to suit their use-case needs. And that's exactly the purpose of the 'full-rbf' PR I'm proposing, aiming to propose a \"good\" policy for a Lightning node, without actually seeking to change the default. If they're parties interested in implementing more RBF policy options in Bitcoin Core, I think they're free to propose such changes and invest the engineering effort to do so. If you're interested in advancing the state of policy options in Bitcoin Core, there are a lot of interesting resources available and communities to encourage you in the learning process to contribute to the codebase [6].\n> > >\n> > >\n> > >\n> > > Antoine\n> > >\n> > >\n> > >\n> > > [0] https://dirtycow.ninja\n> > >\n> > > [1] https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n> > >\n> > > [2] https://arxiv.org/pdf/2006.01418.pdf\n> > >\n> > > [3] https://arxiv.org/pdf/2006.08513.pdf\n> > >\n> > > [4] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> > >\n> > > [5] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html\n> > >\n> > > [6] https://www.summerofbitcoin.org\n> > >\n> > >\n> > > Le jeu. 16 juin 2022 \u00e0 00:15, alicexbt <alicexbt at protonmail.com> a \u00e9crit :\n> > >\n> > > > Hi Antoine,\n> > > >\n> > > >\n> > > > Thanks for opening the pull request to add support for full-rbf in Bitcoin Core. I have a disagreements with the approach and questions.\n> > > >\n> > > >\n> > > > > Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1].\n> > > >\n> > > > 1)If something relies on a policy which can be changed without breaking consensus rules, how is it secure in any case with or without full rbf? If I write a python script that expects user to enter char 'a' or 'b' but user can enter 'c' and there is no code to handle exceptions or other chars, will it be secure?\n> > > >\n> > > > 2)full-rbf is not default in the 2 open pull requests, so this experiment still relies on users changing RBF policies manually. If majority of nodes use default opt-in policy, how would this affect vulnerable projects?\n> > > >\n> > > >\n> > > > > If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy.\n> > > >\n> > > > Miners can only increase their income if users replace transactions. 2-3% transactions are replaced with opt-in RBF, if someone did not replace earlier why would they do it now even with full RBF? Or even if we add some users in it who could not signal for some reasons, do you think it would be anything above 5%?\n> > > >\n> > > >\n> > > > > If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n> > > >\n> > > > I am not opposed to full-rbf; rather, I am opposed to the notion that full-rbf will solve all problems and the lack of basic options in Bitcoin Core to employ/disable different RBF policies. There is also a speculation about making full RBF default in an year which isn't relevant to discuss at this point without trying different RBF policies.\n> > > >\n> > > > I would suggest users to try Bitcoin Knots instead which already has an option to disable all RBF policies if required, opt-in and full RBF policy. This can also be done using GUI if not familiar with config option `mempoolreplacement`.\n> > > >\n> > > > The rationale in PR #16171 was insufficient to justify removing it in the first place, had 2 NACKs and was reopened to merge it. Why bother with a few lines of code that may allow someone disable it if required in local mempool since it's only useful when a big percentage of miners utilize it and essentially underused according to the PR author? Developers should provide basic RBF policy options rather than attempting to define what constitutes a good policy and removing the ability to disable something when necessary.\n> > > >\n> > > >\n> > > > /dev/fd0\n> > > >\n> > > >\n> > > > Sent with Proton Mail secure email.\n> > > >\n> > > > ------- Original Message -------\n> > > > On Tuesday, June 14th, 2022 at 5:55 AM, Antoine Riard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > >\n> > > >\n> > > > > Hi list,\n> > > > >\n> > > > > Recent discussions among LN devs have brought back on the surface concerns about the security of multi-party funded transactions (coinjoins, dual-funded LN channels, on-chain DLCs, ...). It turns out there is a low-fruit, naive DoS vector playable against the funding flow of any such construction due to the lack of existent full-rbf transaction-relay topology on today's p2p network [0] [1]. While it does not consist in a direct loss of funds, if exploited well I think it's annoying enough to inflict significant timevalue loss or fee-bumping waste\n> > > > > to the future providers or distributed swarm of users doing multi-party funded transactions. Of course, it can be fixed one layer above by introducing either fidelity bonds or a reliable centralized coordinator, though at the price of an overhead per-participant ressources cost and loss in system openness [1].\n> > > > >\n> > > > > For that reason, I believe it would be beneficial to the flourishing of multi-party funded transactions to fix the Dos vector by seeing a subset of the network running full-rbf and enabling propagation of honest multi-party transactions to the interested miners, replacing potential non-signaling double-spend from a malicious counterparty. Moving towards that direction, I've submitted a small patch against Bitcoin Core enabling it to turn on full-rbf as a policy, still under review [3]. The default setting stays **false**, i.e keeping opt-in RBF as a default replacement policy. I've started to run the patch on a public node at 146.190.224.15.\n> > > > >\n> > > > > If you're a node operator curious to play with full-rbf, feel free to connect to this node or spawn up a toy, public node yourself. There is a ##uafrbf libera chat if you would like information on the settings or looking for full-rbf friends (though that step could be automated in the future by setting up a dedicated network bit and reserving a few outbound slots for them).\n> > > > >\n> > > > > If you're a mining operator looking to increase your income, you might be interested to experiment with full-rbf as a policy. Indeed, in the future I believe the multi-party transactions issuers who need full-rbf to secure their funding flow should connect by default to full-rbf peers. One can conjecture that their transactions are likely to be more compelling in their feerate as their liquidity needs are higher than the simple transaction. For today, I think we have really few standards and bitcoin softwares relying on multi-party funded transactions [4].\n> > > > >\n> > > > > If you're a Bitcoin user or business and you don't like full-rbf, please express an opinion on how it might affect your software/operations. I'm always interested to learn more about mempool and transaction-relay interactions with upper-layers and applications and to listen to feedback in those areas, and I guess a lot of other Bitcoin researchers/devs too. I know there have been a lot of concerns about full-rbf in the past, however I believe the Bitcoin ecosystem has matured a lot since then.\n> > > > >\n> > > > > Any mistakes or missing context is my own.\n> > > > >\n> > > > > Cheers,\n> > > > > Antoine\n> > > > >\n> > > > > [0] For more info about replace-by-fee, see https://bitcoinops.org/en/topics/replace-by-fee/\n> > > > >\n> > > > > [1] For more details about the DoS vector, see https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> > > > >\n> > > > > [2] E.g I think it does not affect the Lightning Pool service, as there is a preliminary step where the participant funds are locked first in a 2-of-2 with the coordinator before being committed in the multi-party batch transaction.\n> > > > >\n> > > > > [3] https://github.com/bitcoin/bitcoin/pull/25353\n> > > > >\n> > > > > [4] E.g DLCs : https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md ; Lightning dual-funded channel : https://github.com/lightning/bolts/pull/851"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-27T00:43:35",
                "message_text_only": "On Sun, Jun 26, 2022 at 04:40:24PM +0000, alicexbt via bitcoin-dev wrote:\n> Hi Antoine,\n> \n> Thanks for sharing the DoS attack example with alternatives.\n> \n> > - Caroll broadcasts a double-spend of her own input C, the double-spend is attached with a low-fee (1sat/vb) and it does _not_ signal opt-in RBF\n> > - Alice broadcasts the multi-party transaction, it is rejected by the network mempools because Alice double-spend is already present\n> \n> I think this affects almost all types of coinjoin transaction including coordinator based implementations. I tried a few things and have already reported details for an example DoS attack to one of the team but there is no response yet.\n> \n> It was fun playing with RBF, DoS and Coinjoin. Affected projects should share their opinion about full-rbf as it seems it might improve things.\n> \n> Example:\n> \n> In Wasabi an attacker can broadcast a transaction spending input used in coinjoin after sending signature in the round. This would result in a coinjoin tx which never gets relayed: https://nitter.net/1440000bytes/status/1540727534093905920\n\nNote that Wasabi already has a DoS attack vector in that a participant can stop\nparticipating after the first phase of the round, with the result that the\ncoinjoin fails. Wasabi mitigates that by punishing participating in future\nrounds. Double-spends only create additional types of DoS attack that need to\nbe detected and punished as well - they don't create a fundamentally new\nvulerability.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220626/fe2891b5/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-06-27T12:03:38",
                "message_text_only": "One key difference seems to be that properly punishing someone based on\nmempool behavior seems much more difficult. As we all know there is no \"the\nmempool\".\n\n\n\nOn Sun, Jun 26, 2022, 8:43 PM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sun, Jun 26, 2022 at 04:40:24PM +0000, alicexbt via bitcoin-dev wrote:\n> > Hi Antoine,\n> >\n> > Thanks for sharing the DoS attack example with alternatives.\n> >\n> > > - Caroll broadcasts a double-spend of her own input C, the\n> double-spend is attached with a low-fee (1sat/vb) and it does _not_ signal\n> opt-in RBF\n> > > - Alice broadcasts the multi-party transaction, it is rejected by the\n> network mempools because Alice double-spend is already present\n> >\n> > I think this affects almost all types of coinjoin transaction including\n> coordinator based implementations. I tried a few things and have already\n> reported details for an example DoS attack to one of the team but there is\n> no response yet.\n> >\n> > It was fun playing with RBF, DoS and Coinjoin. Affected projects should\n> share their opinion about full-rbf as it seems it might improve things.\n> >\n> > Example:\n> >\n> > In Wasabi an attacker can broadcast a transaction spending input used in\n> coinjoin after sending signature in the round. This would result in a\n> coinjoin tx which never gets relayed:\n> https://nitter.net/1440000bytes/status/1540727534093905920\n>\n> Note that Wasabi already has a DoS attack vector in that a participant can\n> stop\n> participating after the first phase of the round, with the result that the\n> coinjoin fails. Wasabi mitigates that by punishing participating in future\n> rounds. Double-spends only create additional types of DoS attack that need\n> to\n> be detected and punished as well - they don't create a fundamentally new\n> vulerability.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220627/ce7724b1/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-27T13:46:46",
                "message_text_only": "On June 27, 2022 8:03:38 AM EDT, Greg Sanders <gsanders87 at gmail.com> wrote:\n>One key difference seems to be that properly punishing someone based on\n>mempool behavior seems much more difficult. As we all know there is no \"the\n>mempool\".\n\nNo, that's not relevant here: the DoS condition is the existence of a (mined) double spend for a given txout used in a coin join. That condition is entirely under the control of the wallet, and can be totally avoided by the wallet regardless of mempool behavior."
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-20T23:49:55",
                "message_text_only": "On Mon, Jun 13, 2022 at 08:25:11PM -0400, Antoine Riard via bitcoin-dev wrote:\n> For that reason, I believe it would be beneficial to the flourishing of\n> multi-party funded transactions to fix the Dos vector by seeing a subset of\n> the network running full-rbf and enabling propagation of honest multi-party\n> transactions to the interested miners, replacing potential non-signaling\n> double-spend from a malicious counterparty. Moving towards that direction,\n> I've submitted a small patch against Bitcoin Core enabling it to turn on\n> full-rbf as a policy, still under review [3]. The default setting stays\n> **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n> started to run the patch on a public node at 146.190.224.15.\n\nBTW I changed one of my OTS calendars to issue fee-bumping txs without the\nopt-in RBF flag set as an experiment. I also made sure txs would propagate to\nthe above node. As of right now, it's up to 32 replacements (once per block),\nwithout any of them mined; the calendars use the strategy of starting at the\nminimum possible fee, and bumping the fee up every time a new block arrives\nwithout the tx getting mined. So that's evidence we don't have much full-rbf\nhash power at this moment.\n\nYou can see the current status at: https://alice.btc.calendar.opentimestamps.org/\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220620/b8532172/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-06-21T23:45:48",
                "message_text_only": "> BTW I changed one of my OTS calendars to issue fee-bumping txs without the\n> opt-in RBF flag set as an experiment. I also made sure txs would\npropagate to\n> the above node. As of right now, it's up to 32 replacements (once per\nblock),\n> without any of them mined; the calendars use the strategy of starting at\nthe\n> minimum possible fee, and bumping the fee up every time a new block\narrives\n> without the tx getting mined. So that's evidence we don't have much\nfull-rbf\n> hash power at this moment.\n>\n> You can see the current status at:\nhttps://alice.btc.calendar.opentimestamps.org/\n\nThat's interesting. I'm not sure if we can conclude of the absence of\nfull-rbf hash power at this moment, as it could also be a lack of full-rbf\npropagation path towards such potential hash power. I think the day we see\nan opt-out replacement transaction mined, it would constitute a good hint\nof full-rbf hash power (assuming the tx-relay topology stays relatively\nstable across the transaction issuance...)\n\nAnyway, if/when the `fullrbf` patch lands in Bitcoin Core, including\nautomatic outbound connections to few `NODE_REPLACE_BY_FEE` peers, I'm\nthinking of reaching out to a few mining node operators to advocate them\nwith the new policy setting.\n\nAntoine\n\nLe lun. 20 juin 2022 \u00e0 19:49, Peter Todd <pete at petertodd.org> a \u00e9crit :\n\n> On Mon, Jun 13, 2022 at 08:25:11PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > For that reason, I believe it would be beneficial to the flourishing of\n> > multi-party funded transactions to fix the Dos vector by seeing a subset\n> of\n> > the network running full-rbf and enabling propagation of honest\n> multi-party\n> > transactions to the interested miners, replacing potential non-signaling\n> > double-spend from a malicious counterparty. Moving towards that\n> direction,\n> > I've submitted a small patch against Bitcoin Core enabling it to turn on\n> > full-rbf as a policy, still under review [3]. The default setting stays\n> > **false**, i.e keeping opt-in RBF as a default replacement policy. I've\n> > started to run the patch on a public node at 146.190.224.15.\n>\n> BTW I changed one of my OTS calendars to issue fee-bumping txs without the\n> opt-in RBF flag set as an experiment. I also made sure txs would propagate\n> to\n> the above node. As of right now, it's up to 32 replacements (once per\n> block),\n> without any of them mined; the calendars use the strategy of starting at\n> the\n> minimum possible fee, and bumping the fee up every time a new block arrives\n> without the tx getting mined. So that's evidence we don't have much\n> full-rbf\n> hash power at this moment.\n>\n> You can see the current status at:\n> https://alice.btc.calendar.opentimestamps.org/\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220621/1164839e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-23T19:13:47",
                "message_text_only": "On Tue, Jun 21, 2022 at 07:45:48PM -0400, Antoine Riard wrote:\n> > BTW I changed one of my OTS calendars to issue fee-bumping txs without the\n> > opt-in RBF flag set as an experiment. I also made sure txs would\n> propagate to\n> > the above node. As of right now, it's up to 32 replacements (once per\n> block),\n> > without any of them mined; the calendars use the strategy of starting at\n> the\n> > minimum possible fee, and bumping the fee up every time a new block\n> arrives\n> > without the tx getting mined. So that's evidence we don't have much\n> full-rbf\n> > hash power at this moment.\n> >\n> > You can see the current status at:\n> https://alice.btc.calendar.opentimestamps.org/\n> \n> That's interesting. I'm not sure if we can conclude of the absence of\n> full-rbf hash power at this moment, as it could also be a lack of full-rbf\n> propagation path towards such potential hash power. I think the day we see\n> an opt-out replacement transaction mined, it would constitute a good hint\n> of full-rbf hash power (assuming the tx-relay topology stays relatively\n> stable across the transaction issuance...)\n\nFees are relatively low right now, so there could be 1% or so of full-rbf hash\npower and I wouldn't notice with this particular technique as the initial tx\ngets mined within 10-20 blocks; a few years back similar experiments were\nfinding a few percentage points of hashing power running full-rbf.\n\n> Anyway, if/when the `fullrbf` patch lands in Bitcoin Core, including\n> automatic outbound connections to few `NODE_REPLACE_BY_FEE` peers, I'm\n> thinking of reaching out to a few mining node operators to advocate them\n> with the new policy setting.\n\nI'd suggest doing that right now, without waiting for the patch to get merged,\nas it improves the politics of getting the patch merged. Miners tend to run\ncustomized bitcoind's anyway.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220623/7112ff50/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Playing with full-rbf peers for fun and L2s security",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "linuxfoundation.cndm1 at dralias.com",
                "Antoine Riard",
                "Peter Todd",
                "alicexbt",
                "Luke Dashjr",
                "Greg Sanders"
            ],
            "messages_count": 21,
            "total_messages_chars_count": 168740
        }
    },
    {
        "title": "[bitcoin-dev] Why OpenTimestamps does not \"linearize\" its transactions",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2022-06-14T11:12:14",
                "message_text_only": "On Mon, May 02, 2022 at 08:59:49AM -0700, Jeremy Rubin wrote:\n> Ok, got it. Won't waste anyone's time on terminology pedantism.\n> \n> \n> The model that I proposed above is simply what *any* correct timestamping\n> service must do. If OTS does not follow that model, then I suspect whatever\n> OTS is, is provably incorrect or, in this context, unreliable, even when\n> servers and clients are honest.\n\nDo you think RFC 3628 is \"provably incorrect\" too? It's just a standard for\nTrusted Time-Stamping Authorities to issue timestamp proofs via digital\nsignatures, in the most straight forward manner of signing a message claiming\nthat some digest existed as of some time.\n\nAs the RFC says in the introduction:\n\n    The TSA's role is to time-stamp a datum to establish evidence indicating that a\n    datum existed before a particular time.  This can then be used, for example, to\n    verify that a digital signature was applied to a message before the\n    corresponding certificate was revoked thus allowing a revoked public key\n    certificate to be used for verifying signatures created prior to the time of\n    revocation.\n\nSimple and straight forward.\n\nThe problem here is starts with the fact that you're asking timestamp services\nto do things that they're not claiming they do; a timestamp proof simply proves\nthat some message m existed prior to some time t. Nothing more.\n\nWorse though, linearization is a busted approach.\n\n> Unreliable might mean different things to\n> different people, I'm happy to detail the types of unreliability issue that\n> arise if you do not conform to the model I presented above (of which,\n> linearizability is one way to address it, there are others that still\n> implement epoch based recommitting that could be conceptually sound without\n> requiring linearizability).\n> \n> Do you have any formal proof of what guarantees OTS provides against which\n> threat model? This is likely difficult to produce without a formal model of\n> what OTS is, but perhaps you can give your best shot at producing one and\n> we can carry the conversation on productively from there.\n\nSo as you know, an OpenTimestamps proof consists of a series of commitment\noperations that act on an initial message m, leading to a message known to have\nbeen created at some point in time. Almost always a Bitcoin block header. But\nother schemes like trusted timestamps are possible too.\n\nA commitment operation (namely hashes + concatenation) simply needs the\nproperty that for a given input message m, the output H(m) can't be predicted\nwithout knowledge of m. In the case of concatenation, this property is achieved\ntrivially by the fact that the output includes m verbatim. Similarly, SHA1 is\nstill a valid commitment operation.\n\nBehind the scenes the OTS infrastructure builds merkle trees of commitment\noperations for scalability reasons. But none of those details are relevant to\nthe validity of OTS proofs - the OTS infrastructure could magically mine a\nblock per transaction with the digest in the coinbase, and from the client's\npoint of view, everything would work the same.\n\n\nThe important thing to recognize is that timestamp proof is simply a one-sided\nbound on when a given message existed, proving a message existed _prior_ to\nsome point in time. For example:\n\n    $ ots verify hello-world.txt.ots\n    Assuming target filename is 'hello-world.txt'\n    Success! Bitcoin block 358391 attests existence as of 2015-05-28 EDT\n\nObviously, the message \"Hello World!\" existed prior to 2015 (Indeed, it's such\na short message it's brute-forcable. But for sake of example, we'll ignore\nthat).\n\nThus your claim re: linearization that:\n\n> Having a chain of transactions would serve to linearize history of\n> OTS commitments which would let you prove, given reorgs, that knowledge of\n> commit A was before B a bit more robustly.\n\n...misunderstands the problem. We care about proving statements about messages.\nNot timestamp proofs. Building infrastructure to order timestamp proofs\nthemselves is pointless.\n\n\nWhat you're alluding to is dual-sided bounds on when messages were created.\nThat's solved by random beacons: messages known to have been created *after* a\npoint in time, and unpredictable prior. A famous example of course being the\ngenesis block quote:\n\n    The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\n\nBitcoin block hashes make for a perfectly good random beacon for use-cases with\nday to hour level precision. For higher precision, absolute time, there are\nmany trusted alternatives like the NIST random beacon, Roughtime, etc.\n\n\nOpenTimestamps could offer a trustless _relative_ random beacon service by\nmaking the per-second commitments a merkle mountain range, and publishing the\ntip digests. In fact, that's how I came up with merkle mountain ranges in the\nfirst place, and there's code from 2012 to do exactly that in depths of the git\nrepo. But that's such a niche use-case I decided against that approach for now;\nI'll probably resurrect it in the future for trusted timestamps/clock sync.\n\nAgain, involving the transactions themselves in any of this random beacon stuff\nis pointless.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/569cfb2a/attachment.sig>"
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-14T11:39:39",
                "message_text_only": "hey various,\n\nit's been obvious since its inception that opentimestamps is designed\nto be broken.\n\nif you have energy to normalise a better system, or support one of the\nother better systems that already exists, that's wonderful.\n\ni suspect the opentimestamps ecosystem is very experienced at defending itself."
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-14T11:53:29",
                "message_text_only": "I was privately asked for more opinions. I am sharing them publicly below:\n\nIt's always been clear that OTS proves longness of duration but not\nshortness. It doesn't demonstrate that an earlier work was not\npublished, because it hashes each document hash with private material\nthe author must separately publicize. Any unpublished private material\ncould be an earlier equivalent to a public proof.\n\nthe reason i call this 'designed to be broken' is that it lets people\nrewrite history to their stories by republishing other people's\ndocuments under different contexts.\n\nI would not be surprised if OTS also fails to add tx history\ncontaining its hashes to associated wallets, letting them be lost in\nchain forks."
            },
            {
                "author": "rot13maxi",
                "date": "2022-06-14T12:28:28",
                "message_text_only": "Good morning Undiscussed Horrific Abuse, One Victim of Many,\n\n> the reason i call this 'designed to be broken' is that it lets people\n> rewrite history to their stories by republishing other people's\n> documents under different contexts.\n\nThe basic service that a timestamp service provides is \u201cthis content (or at least a digest of this content) existed at least as early as this timestamp.\u201d It says nothing about how long before the timestamp the content existed, and says nothing about how long after the timestamp the content continues to exist. It also says nothing about uniqueness or validity of the content. For example, a document that existed for a year before its timestamp and was deleted immediately afterwards, and a document that was created the instant before its timestamp and was retained \u201cforever\u201d afterwards would have timestamp that are equally valid (provided you retained the digest of the document to validate the timestamp in the former case). Assurances around uniqueness (for example, preventing double spends) are a proof-of-publication or set-consistency problem, and assurances around validity are a validation problem. These other semantics can be built into systems that also rely on timestamps, but you can have a useful time stamping system without them. This is what OTS provides. When you say it\u2019s \u201cdesigned to be broken\u201d do you mean that it claims to provide assurances that it doesn\u2019t, or that the set of assurances that it provides are not a useful set.\n\n> I would not be surprised if OTS also fails to add tx history\n> containing its hashes to associated wallets, letting them be lost in\n> chain forks.\n\nI\u2019ve always used OTS through the cli, which just spits out and works with .ots files, which are sterilized commitment operations. Storage of the ots files for later checking has always been a \u201cproblem left to the application\u201d for me. Are there wallets that you\u2019ve seen that incorporate OTS? I\u2019d love to see them!\n\nBest,\nrot13maxi\n\nOn Tue, Jun 14, 2022 at 7:53 AM, Undiscussed Horrific Abuse, One Victim of Many via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I was privately asked for more opinions. I am sharing them publicly below:\n>\n> It's always been clear that OTS proves longness of duration but not\n> shortness. It doesn't demonstrate that an earlier work was not\n> published, because it hashes each document hash with private material\n> the author must separately publicize. Any unpublished private material\n> could be an earlier equivalent to a public proof.\n>\n> the reason i call this 'designed to be broken' is that it lets people\n> rewrite history to their stories by republishing other people's\n> documents under different contexts.\n>\n> I would not be surprised if OTS also fails to add tx history\n> containing its hashes to associated wallets, letting them be lost in\n> chain forks.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/883de78f/attachment.html>"
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-14T12:45:43",
                "message_text_only": "hi r1m, i'll talk with you as long as it's fun to do so.\n\n>> the reason i call this 'designed to be broken' is that it lets people\n>> rewrite history to their stories by republishing other people's\n>> documents under different contexts.\n>\n> The basic service that a timestamp service provides is \u201cthis content (or at\n> least a digest of this content) existed at least as early as this\n> timestamp.\u201d It says nothing about how long before the timestamp the content\n\nOTS needlessly adds the requirement that the user publicize their .ots\nfiles to everybody who will make use of the timestamp.\n\nThis does not provide the service you describe. It would be trivial to\ninclude enough cryptographic information in the original OP_RETURN, so\nas to obviate the need for publicizing the .ots file.\n\nIf I send my .ots file to another party, a 4th party can replace it\nwith their own, because there is no cryptographic pinning ensuring its\ncontents. This changes the timestamp to one later, no longer proving\nthe earliness of the data.\n\n>> I would not be surprised if OTS also fails to add tx history\n>> containing its hashes to associated wallets, letting them be lost in\n>> chain forks.\n\n> for me. Are there wallets that you\u2019ve seen that incorporate OTS? I\u2019d love to\n\nI mean the cryptographic wallets that hold the funds spent in etching\nthe hash to the chain."
            },
            {
                "author": "Bryan Bishop",
                "date": "2022-06-14T13:55:55",
                "message_text_only": "On Tue, Jun 14, 2022 at 8:48 AM Undiscussed Horrific Abuse, One Victim of\nMany via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> OTS needlessly adds the requirement that the user publicize their .ots\n> files to everybody who will make use of the timestamp.\n\n\nPublication is not a component of the OTS system.\n\nThis does not provide the service you describe. It would be trivial to\n> include enough cryptographic information in the original OP_RETURN, so\n> as to obviate the need for publicizing the .ots file.\n>\n\n(Why would it be needless to require everyone to publish OTS files but not\nneedless to require everyone to publish via OP_RETURN? In fact, now you\nhave blockchain users that don't ever use your OP_RETURN data.)\n\n\n> If I send my .ots file to another party, a 4th party can replace it\n> with their own, because there is no cryptographic pinning ensuring its\n> contents. This changes the timestamp to one later, no longer proving\n> the earliness of the data.\n>\n\nYou can't replace a timestamp in the OTS system; you can only make a new\ntimestamp. To use the earlier timestamp, you would have to use the earlier\ntimestamp. At any time it is allowed to make a new timestamp based on the\ncurrent clock. The use case for OTS is proving document existence as of a\ncertain time and that if you had doctored a file then said doctoring was no\nlater than the earliest timestamp that can be provided.\n\nI was just talking about this the other day actually...\nhttps://news.ycombinator.com/item?id=31640752\n\n- Bryan\nhttps://twitter.com/kanzure\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/16da0bbc/attachment.html>"
            },
            {
                "author": "digital vagabond",
                "date": "2022-06-14T15:06:22",
                "message_text_only": "If someone wants more linearity and uniqueness guarantees from a timestamp,\nthat isnt what OTS was designed for. Here is a protocol that was:\nhttps://www.commerceblock.com/mainstay/\n\nOn Tue, Jun 14, 2022, 3:56 PM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Jun 14, 2022 at 8:48 AM Undiscussed Horrific Abuse, One Victim of\n> Many via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> OTS needlessly adds the requirement that the user publicize their .ots\n>> files to everybody who will make use of the timestamp.\n>\n>\n> Publication is not a component of the OTS system.\n>\n> This does not provide the service you describe. It would be trivial to\n>> include enough cryptographic information in the original OP_RETURN, so\n>> as to obviate the need for publicizing the .ots file.\n>>\n>\n> (Why would it be needless to require everyone to publish OTS files but not\n> needless to require everyone to publish via OP_RETURN? In fact, now you\n> have blockchain users that don't ever use your OP_RETURN data.)\n>\n>\n>> If I send my .ots file to another party, a 4th party can replace it\n>> with their own, because there is no cryptographic pinning ensuring its\n>> contents. This changes the timestamp to one later, no longer proving\n>> the earliness of the data.\n>>\n>\n> You can't replace a timestamp in the OTS system; you can only make a new\n> timestamp. To use the earlier timestamp, you would have to use the earlier\n> timestamp. At any time it is allowed to make a new timestamp based on the\n> current clock. The use case for OTS is proving document existence as of a\n> certain time and that if you had doctored a file then said doctoring was no\n> later than the earliest timestamp that can be provided.\n>\n> I was just talking about this the other day actually...\n> https://news.ycombinator.com/item?id=31640752\n>\n> - Bryan\n> https://twitter.com/kanzure\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/541d0878/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-14T15:34:36",
                "message_text_only": "On Tue, Jun 14, 2022 at 08:45:43AM -0400, Undiscussed Horrific Abuse, One Victim of Many via bitcoin-dev wrote:\n> > The basic service that a timestamp service provides is \u201cthis content (or at\n> > least a digest of this content) existed at least as early as this\n> > timestamp.\u201d It says nothing about how long before the timestamp the content\n> \n> OTS needlessly adds the requirement that the user publicize their .ots\n> files to everybody who will make use of the timestamp.\n>\n> This does not provide the service you describe. It would be trivial to\n> include enough cryptographic information in the original OP_RETURN, so\n> as to obviate the need for publicizing the .ots file.\n\nThat approach does not scale. Via merkle trees, the OpenTimestamps system\nroutinely timestamps tens of thousands of messages with a single transaction:\n\nhttps://petertodd.org/2016/opentimestamps-announcement#scalability-through-aggregation\n\nClient-side validated .ots files are a necessary requirement to achieve this\nscalability.\n\nFWIW the most I've personally done is timestamped 750 million items from the\nInternet Archive with a single transaction.\n\n> If I send my .ots file to another party, a 4th party can replace it\n> with their own, because there is no cryptographic pinning ensuring its\n> contents. This changes the timestamp to one later, no longer proving\n> the earliness of the data.\n\nThey can also simply delete their copy of the data, making it impossible to\nprove anything about it.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/b7ea831b/attachment-0001.sig>"
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-14T17:15:08",
                "message_text_only": "I'm replying to Peter, skipping the other emails.\n\nI perceive all these emails as disruptive trolling, ignoring the\nimportance of real timestamping, while handwaving about things that\nare roughly false and harmful.\n\nSince the start of cryptocurrency, Bitcoin has been used to write\ntimestamps that stay intact despite malicious action to arbitrary\nsystems and records, showing the earliest on-chain publication of\ndata. It seems misleading that OTS does not do that, when it is such a\nprominent system.\n\n>> This does not provide the service you describe. It would be trivial to\n>> include enough cryptographic information in the original OP_RETURN, so\n>> as to obviate the need for publicizing the .ots file.\n>\n> That approach does not scale. Via merkle trees, the OpenTimestamps system\n> routinely timestamps tens of thousands of messages with a single\n> transaction:\n>\n> https://petertodd.org/2016/opentimestamps-announcement#scalability-through-aggregation\n\nThis makes total sense to reduce the expense and size of etching these\nvery short hashes.\n\nBut the OTS approach hashes in a _private nonce_ for every document,\npreventing anybody from validating the earliness of an item in a\nmerkle tree without access to every proof.\n\nDo you think OTS would be interested in publicizing nonces and\ndocument hashes, if the user consents?\n\nNon-developers need a tool where they can choose to pay funds to write\na strong timestamp that guarantees earliness of publication of a\ndocument, and for free discern the earliness of timestamped data they\nprovide to the tool.\n\n> Client-side validated .ots files are a necessary requirement to achieve\n> this\n> scalability.\n\nNothing in an engineering task is a strict requirement, aside from the\nspecification. The data could be publicised elsewhere, or funds\nprovided to store it on-chain.\n\n> FWIW the most I've personally done is timestamped 750 million items from\n> the\n> Internet Archive with a single transaction.\n\nThat's impressive. It's always great when we write something that can\ncondense something huge into something tiny and keep working, and use\nit reliably.\n\nI would have put the files in a shared datalad repository, and put the\ntip commit of the repository in an OP_RETURN along with a tag such as\n'DL' or 'IA'.\n\nThen a tool could look for all 'DL' or 'IA' transactions, and verify\nthat mine was the earliest. You would of course need access to the\netched repositories' git commits.\n\nIf the hash can't be verified by an anonymous observer, the archive is\nonly timestamped for people with the proof. How is the challenge of\nprotecting many proofs different from the challenge of protecting the\ndata they prove?\n\n>> If I send my .ots file to another party, a 4th party can replace it\n>> with their own, because there is no cryptographic pinning ensuring its\n>> contents. This changes the timestamp to one later, no longer proving\n>> the earliness of the data.\n>\n> They can also simply delete their copy of the data, making it impossible to\n> prove anything about it.\n\nIf they can destroy your .ots proof, the information on the blockchain\nno longer demonstrates anything."
            },
            {
                "author": "Andrew Poelstra",
                "date": "2022-06-14T20:33:01",
                "message_text_only": "On Tue, Jun 14, 2022 at 01:15:08PM -0400, Undiscussed Horrific Abuse, One Victim of Many via bitcoin-dev wrote:\n> I'm replying to Peter, skipping the other emails.\n> \n> I perceive all these emails as disruptive trolling, ignoring the\n> importance of real timestamping, while handwaving about things that\n> are roughly false and harmful.\n> \n> Since the start of cryptocurrency, Bitcoin has been used to write\n> timestamps that stay intact despite malicious action to arbitrary\n> systems and records, showing the earliest on-chain publication of\n> data. It seems misleading that OTS does not do that, when it is such a\n> prominent system.\n>\n\nPlease be cautious with tone and when assuming bad faith. I don't believe\nthat Peter is trolling. Also, as politely as I can, when something like\nOTS whose model is dead-simple, well-documented, and has been running for\nyears providing significant value to many people, comes under attack for\nbeing underspecified or failing to do what it says ... this is a\nsurprising claim, to say the least.\n\n\nAfter talking to a few people offline, all of whom are baffled at this\nentire conversation, I think the issue might come down to the way that\npeople interpret \"timestamping\".\n\nIf you believe that \"timestamping\" means providing a verifiable ordering\nto events, then of course OTS does not accomplish this, nor has it ever\nclaimed to. If you think that \"timestamping\" means proving that some\ndata existed at a particular time, then this is exactly what OTS does.\n\nPersonally -- and I suspect this is true of Peter as well -- I have always\nread the word as having the latter meaning, and it never occurred to me\nuntil now that others might have a different interpretation.\n\n\nI apologize for contributing to a thread that is getting a bit out of hand,\nbut I hope this can help the different parties see where the confusion is.\n\n\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/023b2f8a/attachment.sig>"
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-15T01:16:55",
                "message_text_only": "On 6/14/22, Andrew Poelstra <apoelstra at wpsoftware.net> wrote:\n> On Tue, Jun 14, 2022 at 01:15:08PM -0400, Undiscussed Horrific Abuse, One\n> Victim of Many via bitcoin-dev wrote:\n>> I'm replying to Peter, skipping the other emails.\n>>\n>> I perceive all these emails as disruptive trolling, ignoring the\n>> importance of real timestamping, while handwaving about things that\n>> are roughly false and harmful.\n>>\n>> Since the start of cryptocurrency, Bitcoin has been used to write\n>> timestamps that stay intact despite malicious action to arbitrary\n>> systems and records, showing the earliest on-chain publication of\n>> data. It seems misleading that OTS does not do that, when it is such a\n>> prominent system.\n>>\n>\n> Please be cautious with tone and when assuming bad faith. I don't believe\n> that Peter is trolling. Also, as politely as I can, when something like\n> OTS whose model is dead-simple, well-documented, and has been running for\n> years providing significant value to many people, comes under attack for\n> being underspecified or failing to do what it says ... this is a\n> surprising claim, to say the least.\n\nThank you for your reply, Andrew. I don't think Peter is trolling, but\nI do suspect some body like a spy agency of strengthening the\ntimestamping solutions that have nonces in their merkle trees,\navoiding usability for storing public records in a way that could be\nverified by anonymous and censored third parties.\n\n> After talking to a few people offline, all of whom are baffled at this\n> entire conversation, I think the issue might come down to the way that\n> people interpret \"timestamping\".\n>\n> If you believe that \"timestamping\" means providing a verifiable ordering\n> to events, then of course OTS does not accomplish this, nor has it ever\n> claimed to. If you think that \"timestamping\" means proving that some\n> data existed at a particular time, then this is exactly what OTS does.\n>\n> Personally -- and I suspect this is true of Peter as well -- I have always\n> read the word as having the latter meaning, and it never occurred to me\n> until now that others might have a different interpretation.\n\nI looked some into the history of timestamping and I see that what you\nare saying is the academic norm.\n\nI don't see OTS as proving the data existed at a particular time,\nbecause the proof is held in a document the user must protect. I\nunderstand somewhat now that it is designed for users who can actually\nprotect that data sufficiently.\n\nI do reiterate that it is blindingly easy to pin a public hash to the\nbitcoin blockchain that asserts the earliest publication of a document\nor collection of documents, and that this is desperately needed, to\nprotect the accuracy of history when it is not safe.\n\nI worry that this form of \"rfc timestamping\" misleads its users into\nbelieving the timestamps of their documents are preserved. These kinds\nof user interaction issues can be very dangerous.\n\nI would recommend uploading .ots files to chains with cheap storage,\nsuch as arweave or bitcoin sv. This way people can prove which one was\nfirst, when there is more than one. For that to work, we need a norm\nof how and where to do it, so that users look in the same place, and\nit is the people who make the public services and standards, that set\nthat norm.\n\nThank you for your reply, and I apologise for my poor support.\n\nIt is obvious that Peter has put incredible hard and long work into\nproviding OTS to the community in a clean and robust fashion, and that\nis always very wonderful, and I have very thoroughly failed to\nacknowledge that."
            },
            {
                "author": "Undiscussed Horrific Abuse, One Victim of Many",
                "date": "2022-06-15T01:21:29",
                "message_text_only": "> I do reiterate that it is blindingly easy to pin a public hash to the\n> bitcoin blockchain that asserts the earliest publication of a document\n> or collection of documents, and that this is desperately needed, to\n> protect the accuracy of history when it is not safe.\n\nThe concern raised here relates to scaling, and here we disagree on\nthe proper direction of Bitcoin. To me it seems clear that Bitcoin was\ndesigned to scale better than it has. It honestly looks like\ndevelopers are arbitrarily avoiding storing much data on chain, with\nquickly shoehorned solutions like the lightning protocol. Bitcoin\nsimply got big too fast. I believe it was intended to handle large\ndata smoothly: not with single gigabyte blocks that every user must\nstore, but with simplistically designed and well-backed decentralised\npropagation and storage of data. I see that not having happened due to\nmostly political issues, and that's unfortunate, but other chains have\nmade strides here.\n\nI don't think satoshi was familiar with how people behave when they\nhave a lot of money."
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-19T11:04:50",
                "message_text_only": "On Tue, Jun 14, 2022 at 09:16:55PM -0400, Undiscussed Horrific Abuse, One Victim of Many via bitcoin-dev wrote:\n> I worry that this form of \"rfc timestamping\" misleads its users into\n> believing the timestamps of their documents are preserved. These kinds\n> of user interaction issues can be very dangerous.\n> \n> I would recommend uploading .ots files to chains with cheap storage,\n> such as arweave or bitcoin sv.\n\nAccording to Coingeek, Bitcoin SV's transaction fees are currently\n0.1sats/byte. With BSV's price at $60, that works out to $644/GB.\n\nMeanwhile, Amazon Glacier Deep Archive costs $0.012/GB/year.\n\nAssuming a 25 year data lifetime, Bitcoin SV is still 2000x more expensive than\nAmazon. And with the number of BSV nodes quickly dwindling, I'd be inclined to\ntrust Amazon more for long term storage.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/5ef09a1f/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-14T15:22:21",
                "message_text_only": "On Tue, Jun 14, 2022 at 07:53:29AM -0400, Undiscussed Horrific Abuse, One Victim of Many via bitcoin-dev wrote:\n> I was privately asked for more opinions. I am sharing them publicly below:\n> \n> It's always been clear that OTS proves longness of duration but not\n> shortness. It doesn't demonstrate that an earlier work was not\n> published, because it hashes each document hash with private material\n> the author must separately publicize. Any unpublished private material\n> could be an earlier equivalent to a public proof.\n> \n> the reason i call this 'designed to be broken' is that it lets people\n> rewrite history to their stories by republishing other people's\n> documents under different contexts.\n\nSee \"What Can and Can't Timestamps Prove?\":\n\nhttps://petertodd.org/2016/opentimestamps-announcement#what-can-and-cant-timestamps-prove\n\nOpenTimestamps makes a trade-off: timestamps have significant limitations as to\nwhat they're able to prove. But in exchange, they have exceptionally good\nscalability, making them essentially free to use. Timestamps are also much\neasier to add on to existing processes and systems such as Git repositories.\nSchemes that prove uniqueness require much more engineering and redesign work\nto actually accomplish anything.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220614/14490c96/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Why OpenTimestamps does not \"linearize\" its transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "rot13maxi",
                "Bryan Bishop",
                "digital vagabond",
                "Peter Todd",
                "Andrew Poelstra",
                "Undiscussed Horrific Abuse, One Victim of Many"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 29682
        }
    },
    {
        "title": "[bitcoin-dev] Mempool and Privacy",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-06-19T16:50:38",
                "message_text_only": "Hi Bitcoin Developers,\n\nBitcoin knots has a config option to disallow address reuse in mempool: spkreuse=conflict or GUI -> Settings -> Options -> Mempool. I tried experimenting with it and running 2 nodes(signet) for which anyone can check 'getrawmempool' at a given time using:\n\nGET /mempool?node=1 HTTP/1.1\nHost: api.spkreuse.funContent-Type: application/json\n\nNode 2 has 'spkreuse=conflict' saved in bitcoin_rw.conf and it will reject all transaction reusing addresses in mempool. I have tried testing it on signet and it works as expected. Replacement transactions are exceptions and ignored even if address appears twice in mempool. I could not find any issues however debug=mempool did not print logs that could be helpful to know which transactions are getting rejected in mempool for address re-use. So running 2 nodes and comparing mempool transactions.\n\nWhat other things could affect privacy in mempool and not explored yet? I could think of 3:\n\n- RBF policies\n- Rebroadcasting mechanism- Different types of relay fee\n\nThis could be used by lot of bitcoin nodes, not sure about miners. I do not believe mempool policies only rely on miner incentives, minimum fee rate won't be be 1 sat/vbyte if that was the case. Even if its never used by lot of nodes and some miners, it was fun to play with and I like knots for providing such options.\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220619/7234a60c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mempool and Privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "alicexbt"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1602
        }
    },
    {
        "title": "[bitcoin-dev] [PROPOSAL] OP_TX: generalized covenants reduced to OP_CHECKTEMPLATEVERIFY",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2022-06-24T06:06:05",
                "message_text_only": "On Tue, May 10, 2022 at 08:05:54PM +0930, Rusty Russell via bitcoin-dev wrote:\n\n> OPTX_SEPARATELY: treat fields separately (vs concatenating)\n> OPTX_UNHASHED: push on the stack without hashing (vs SHA256 before push)\n\n> OPTX_SELECT_OUTPUT_AMOUNT32x2*: sats out, as a high-low u31 pair\n> OPTX_SELECT_OUTPUT_SCRIPTPUBKEY*: output scriptpubkey\n\nDoing random pie-in-the-sky contract design, I had a case where I\nwanted to be able to say \"update the CTV hash from commiting to outputs\n[A,B,C,D,E] to outputs [A,B,X,D,E]\". The approach above and the one CTV\ntakes are somewhat awkward for that:\n\n * you have to include all of A,B,D,E in order to generate both hashes,\n   which seems less efficient than a merkle path\n\n * proving that you're taking an output in its entirety, rather than,\n   say, the last 12 bytes of C and the first 30 bytes of D, seems hard.\n   Again, it seems like a merkle path would be better?\n\nThis is more of an upgradability concern I think -- ie, only relevant if\nadditional features like CAT or TLUV or similar are added; but both OP_TX\nand CTV seem to be trying to take upgradability into account in advance,\nso I thought this was worth raising.\n\nCheers,\naj"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-06-24T18:05:50",
                "message_text_only": "I can't find a link, but I've discussed this before somewhere a while\nago... perhaps one of the IRC meetings? I'll see if I can't turn something\nup.\n\nThe main reason not to was validation performance -- we already usually\ncompute the flat hash, so the merkle tree would be extra work for just CTV.\n\nHowever, from an API perspective, I agree that a merkle tree could be\nsuperior for CTV. It does depend on use case. If you have just, say, 3\noutputs, a merkle tree probably just 'gets in the way' compared to the\nconcatenation. It is only when you have many outputs and your need to do a\nrandom-index insertion that it adds value. In many applications, you might\nbe biased to editing the last output (e.g., change outputs?) and then\nSHASTREAM would allow you to O(1) edit the tail.\n\nBest,\n\nJeremy\n\nOn Thu, Jun 23, 2022 at 11:06 PM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, May 10, 2022 at 08:05:54PM +0930, Rusty Russell via bitcoin-dev\n> wrote:\n>\n> > OPTX_SEPARATELY: treat fields separately (vs concatenating)\n> > OPTX_UNHASHED: push on the stack without hashing (vs SHA256 before push)\n>\n> > OPTX_SELECT_OUTPUT_AMOUNT32x2*: sats out, as a high-low u31 pair\n> > OPTX_SELECT_OUTPUT_SCRIPTPUBKEY*: output scriptpubkey\n>\n> Doing random pie-in-the-sky contract design, I had a case where I\n> wanted to be able to say \"update the CTV hash from commiting to outputs\n> [A,B,C,D,E] to outputs [A,B,X,D,E]\". The approach above and the one CTV\n> takes are somewhat awkward for that:\n>\n>  * you have to include all of A,B,D,E in order to generate both hashes,\n>    which seems less efficient than a merkle path\n>\n>  * proving that you're taking an output in its entirety, rather than,\n>    say, the last 12 bytes of C and the first 30 bytes of D, seems hard.\n>    Again, it seems like a merkle path would be better?\n>\n> This is more of an upgradability concern I think -- ie, only relevant if\n> additional features like CAT or TLUV or similar are added; but both OP_TX\n> and CTV seem to be trying to take upgradability into account in advance,\n> so I thought this was worth raising.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220624/2bd255f3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "OP_TX: generalized covenants reduced to OP_CHECKTEMPLATEVERIFY",
            "categories": [
                "bitcoin-dev",
                "PROPOSAL"
            ],
            "authors": [
                "Anthony Towns",
                "Jeremy Rubin"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3686
        }
    },
    {
        "title": "[bitcoin-dev] [BIP proposal] Private Payments",
        "thread_messages": [
            {
                "author": "Alfred Hodler",
                "date": "2022-06-27T18:17:16",
                "message_text_only": "Hi,\n\nThere have been attempts to create static payment codes that function as a way for transacting parties to create \"private\" addresses, where private stands for \"known only to transacting parties\". BIP47 was one such standard.\n\nThe standard suffered from a number of problems:\n\n1. The standard promised extensibility through versioning but it never used that capability to follow innovations in the Bitcoin protocol. It was designed around the idea that legacy p2pkh addresses would always be the primary and only way to transact. As new standard script types started to emerge (Segwit v0, Taproot), the creators dealt with the problem by stating that implementing wallets should scan for all existing standard scripts. The inability of payment codes to explicitly state which address types they derive places a burden on more resource constrained wallets.\n\n2. The standard relied on a notification mechanism in order to connect a sender with a recipient, which included either offchain technology (Bitmessage), or so called \"notification addresses\" which a) left a footprint b) created toxic change. That type of footprint is particularly harmful because it makes it obvious that a particular recipient is going to receive private transactions. If the notifying party performs this process with coins linked to its identity (i.e. tainted or non-anonymized inputs), it forever becomes visible that Alice connected with Bob despite the fact that her payment code was blinded. While future transactions and their amounts aren't visible, this metadata makes it possible to build a social graph.\n\n3. The standard was implemented only by an entity that disavowed the BIP process and didn't wish to use it to keep the standard up to date. Further updates did take place but only outside the BIP process, creating a lack of clarity as to what the real specification is. Ultimately the standard was abandoned.\n\nI propose to build on the idea of payment codes under a new BIP with the following principal differences:\n\n1. The new standard will allocate a 2-byte bitflag array that will signal address/script types that the receiver is deriving. Since the vast majority of scripts are p2pkh (47.3%) and p2wpkh (26.2%), bits 0 and 1 will be used for those respectively. Bit 2 will be p2tr. The remaining 13 bits are reserved for future standard script types.\n\n2. Notification transactions still exist but no longer leave a privacy footprint on the blockchain. Instead, a notification transaction is simply a single OP_RETURN containing a value that only Alice and Bob can calculate. If Alice's notification transaction uses UTXOs not associated with her identity, there is never a footprint showing that either her or Bob are using private payments. If Alice uses tainted coins, only she is exposed as a user of Private Payments but Bob still isn't.\n\n3. Payment code versioning is no longer done because it creates the potential for fragmentation and disparate standard updates by different parties that don't follow the BIP process (BIP47 is a good example of that).\n\n4. Relying on static compressed pubkeys as opposed to extended keys means shorter payment codes.\n\n==Proposed Payment Code Structure==\n\nbytes 0-1: - enabled (watched) address types (16 possible address types)\nbytes 2-35: - compressed public key P\n\n==Encoding==\n\nA payment code is encoded in base58check and the version byte produces \"S\" for the first character. A code might look like \"SwLUHs3UfMUXq956aXLTUPPfow7a8gDfSUUAtafwqHcobf6mKcMbJk\".\n\n==Pubkey Derivation==\n\nRecipient's payment code pubkey `P` is derived from a master key using the following path: `m/purpose'/coin_type'/account'`. `purpose` will be defined once a BIP number is assigned. Its corresponding private key is `p`.\n\nNotifier/sender's pubkey `N` is derived using the following derivation path: `m/purpose'/coin_type'/account'/*`, where each recipient gets a new index. This way send-side privacy is always preserved. Its corresponding private key is `n`.\n\n==Notifications==\n\nAlice wants to notify Bob that he will receive future payments from her. Alice selects any UTXO in her wallet (preferably not associated with her) and `n_Alice`. Alice selects the public key contained in Bob's payment code `P_Bob`. Alice performs the following process (`*` and `+` are EC operations):\n\nnotification = SHA256(n_Alice * P_Bob)\n\nAlice then constructs a 72-byte OP_RETURN output whose value is set to `BIPXXXX + notification + N_Alice` (`+` is concat) and sends it in a transaction containing no other outputs (XXXX to be replaced once a BIP number is assigned). Alice MUST now keep track of `n_Alice` or its derivation path as it will be used in future transactions exclusively with Bob (not for spending but to calculate secret addresses).\n\nBob's wallet receives whole blocks but doesn't need to waste resources on decoding them if the environment is resource constrained. Bob simply needs find the string BIPXXXX in the binary blob that represents an undecoded block. Once found, Bob extracts the subsequent 32 bytes (`notification`) and the subsequent 33 bytes (`N_Alice`). The benefit of this approach is that Bob doesn't have to decode blocks and extract pubkeys from scriptsigs.\n\nSince ECDH dictates that SHA256(n_Alice * P_Bob) == SHA256(N_Alice * p_Bob), Bob calculates the expected notification value and checks if it matches the first value in the payload. If so, Bob found a notification transaction addressed to himself and stores `N_Alice` in order to be able to detect and spend future payments from Alice. The added benefit of this approach over BIP47 is that Bob doesn't learn Alice's payment code, so Alice can pay Bob without revealing her identity. To take advantage of these privacy benefits, Alice simply has to engage in coin control on her end. A real world scenario where this might be useful is anonymous donations to a party whose wallet may be seized in the future. Seizing such a wallet won't reveal who Alice is (as long as she engages in coin control), whereas BIP47 would by default leak her identity even if her coins as anonymized.\n\nIf this process fails for any reason, Bob assumes a spurious notification or one not addressed to himself and gives up.\n\n==Transacting==\n\nNow that they are connected, Alice can send transactions to Bob. Alice needs to keep track of her transaction count toward Bob; let's name that counter `X`. This process is similar to what BIP47 does.\n\nAlice calculates a secret point:\n\nS = n_Alice * P_Bob\n\nAlice calculates a shared secret:\n\ns = SHA256(S, X)\n\nAlice calculates Bob's ephemeral public key and its associated address where the funds will be sent:\n\nP_Bob' = P_Bob + s*G\n\nWhen Bob detects a payment to `P_Bob'`, he can spend such coins by calculating the shared secret `s` in the same manner using `N_Alice` and `p_Bob` and performing:\n\np_bob' = p_bob + s\n\nThe fact that Alice and Bob are using a shared counter means we can do away with chain codes and make payment codes much smaller. Bob simply needs to derive a number of addresses to watch with respect to some gap limit (which can be as low as 1 in practice).\n\n==Anti-spam==\n\nWhile DoS hasn't been a problem with BIP47, it is possible to build anti-spam measures into payment codes. The owner of a code could simply demand that a notification transaction meets some minimum miner fee or a multiple of some trailing average. This would help prevent spam notifications that might otherwise overwhelm a payment code with addresses to watch. But that is purely optional.\n\nLooking forward to hearing thoughts and ideas.\n\nAlfred"
            },
            {
                "author": "Bryan Bishop",
                "date": "2022-06-27T20:20:45",
                "message_text_only": "Hi,\n\nOn Mon, Jun 27, 2022 at 2:14 PM Alfred Hodler via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> 2. Notification transactions still exist but no longer leave a privacy\n> footprint on the blockchain. Instead, a notification transaction is simply\n> a single OP_RETURN containing a value that only Alice and Bob can\n> calculate. If Alice's notification transaction uses UTXOs not associated\n> with her identity, there is never a footprint showing that either her or\n> Bob are using private payments. If Alice uses tainted coins, only she is\n> exposed as a user of Private Payments but Bob still isn't.\n>\n\nThat's a neat trick. What about not using OP_RETURN at all, and just\npublishing on a tor hidden service that other wallets check?  Alice\nwouldn't have to expose on-chain that she is a sender of a private payment.\n\n- Bryan\nhttps://twitter.com/kanzure\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220627/9e90ead7/attachment-0001.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-06-27T20:35:34",
                "message_text_only": "Hi Bryan,\n\n>just publishing on a tor hidden service that other wallets check\n\nThe problem is that this data is critical to access the funds. By putting\nit on-chain you're guaranteeing that it's always available when you restore\nyour funds from backup.\n\nCheers,\nRuben\n\nOn Mon, Jun 27, 2022 at 10:21 PM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> On Mon, Jun 27, 2022 at 2:14 PM Alfred Hodler via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> 2. Notification transactions still exist but no longer leave a privacy\n>> footprint on the blockchain. Instead, a notification transaction is simply\n>> a single OP_RETURN containing a value that only Alice and Bob can\n>> calculate. If Alice's notification transaction uses UTXOs not associated\n>> with her identity, there is never a footprint showing that either her or\n>> Bob are using private payments. If Alice uses tainted coins, only she is\n>> exposed as a user of Private Payments but Bob still isn't.\n>>\n>\n> That's a neat trick. What about not using OP_RETURN at all, and just\n> publishing on a tor hidden service that other wallets check?  Alice\n> wouldn't have to expose on-chain that she is a sender of a private payment.\n>\n> - Bryan\n> https://twitter.com/kanzure\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220627/10c581f6/attachment-0001.html>"
            },
            {
                "author": "Alfred Hodler",
                "date": "2022-06-28T12:40:10",
                "message_text_only": "Hi Bryan,\n\nThanks for your input.\n\n>That's a neat trick. What about not using OP_RETURN at all, and just publishing on a tor hidden service that other wallets check? Alice wouldn't have to expose on-chain that she is a sender of a private payment.\n\nThis can be done (Tor keys can even be derived from master keys) but it's an off-chain solution, not very different from Bitmessage notifications in BIP47. As Ruben said, it won't work in an offline regime.\n\nAlfred\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/ac97cad9/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-06-27T20:30:39",
                "message_text_only": "Hi Alfred,\n\nThanks for taking the time to write a proposal.\n\n>The inability of payment codes to explicitly state which address types\nthey derive places a burden on more resource constrained wallets\n\nI agree it's not as efficient as it could be, but how big is this problem\nin practice? Expecting payments on more addresses doesn't seem like a huge\noverhead. Or are you talking about the hassle of having to support spending\nfrom all these address types?\n\n>a notification transaction is simply a single OP_RETURN containing a value\nthat only Alice and Bob can calculate\n\nThis seems to be the meat of the proposal. You're hiding the intended\nrecipient, but in doing so you introduce a scanning requirement. Of course\nyou only need to scan notification transactions, so it'll be much less\nheavy than Silent Payments*, but it does make it rather difficult to\nsupport light clients.\n\nIf some degree of scanning is acceptable, then Robin Linus' scheme may be\nan interesting alternative:\nhttps://gist.github.com/RobinLinus/4e7467abaf0a0f8a521d5b512dca4833\n\nThe basic idea is that everyone publishes a single pubkey on-chain, and\neveryone derives a shared secret with everyone else's pubkey. It also\nrequires \"scanning\", but the number of transactions will be lower as it's\none tx per new pubkey as opposed to one tx per sender/recipient pair. This\nalso means it uses far less block space. The main downside is that you have\nto watch as many incoming addresses as there are registered pubkeys, but\nthis could be indexed relatively efficiently. Also not light client\nfriendly, though.\n\nAnd then of course there's the recent BIP47 discussion:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020549.html\n\nThis proposes to outsource the publishing of the notification transaction\nin order to break the link (as well as reduce block space usage). There's\nno scanning, so this preserves light client support, but the downside here\nis that you now need to anonymously pay a third party (e.g. over LN).\n\n>demand that a notification transaction meets some minimum miner fee\n\nNote that this mechanism is not safe against miners, as they can pay\nthemselves arbitrarily high fees with no downside.\n\nHope this helps.\n\nCheers,\nRuben\n\n\n*Silent Payments:\nhttps://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8\n\nOn Mon, Jun 27, 2022 at 9:14 PM Alfred Hodler via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> There have been attempts to create static payment codes that function as a\n> way for transacting parties to create \"private\" addresses, where private\n> stands for \"known only to transacting parties\". BIP47 was one such standard.\n>\n> The standard suffered from a number of problems:\n>\n> 1. The standard promised extensibility through versioning but it never\n> used that capability to follow innovations in the Bitcoin protocol. It was\n> designed around the idea that legacy p2pkh addresses would always be the\n> primary and only way to transact. As new standard script types started to\n> emerge (Segwit v0, Taproot), the creators dealt with the problem by stating\n> that implementing wallets should scan for all existing standard scripts.\n> The inability of payment codes to explicitly state which address types they\n> derive places a burden on more resource constrained wallets.\n>\n> 2. The standard relied on a notification mechanism in order to connect a\n> sender with a recipient, which included either offchain technology\n> (Bitmessage), or so called \"notification addresses\" which a) left a\n> footprint b) created toxic change. That type of footprint is particularly\n> harmful because it makes it obvious that a particular recipient is going to\n> receive private transactions. If the notifying party performs this process\n> with coins linked to its identity (i.e. tainted or non-anonymized inputs),\n> it forever becomes visible that Alice connected with Bob despite the fact\n> that her payment code was blinded. While future transactions and their\n> amounts aren't visible, this metadata makes it possible to build a social\n> graph.\n>\n> 3. The standard was implemented only by an entity that disavowed the BIP\n> process and didn't wish to use it to keep the standard up to date. Further\n> updates did take place but only outside the BIP process, creating a lack of\n> clarity as to what the real specification is. Ultimately the standard was\n> abandoned.\n>\n> I propose to build on the idea of payment codes under a new BIP with the\n> following principal differences:\n>\n> 1. The new standard will allocate a 2-byte bitflag array that will signal\n> address/script types that the receiver is deriving. Since the vast majority\n> of scripts are p2pkh (47.3%) and p2wpkh (26.2%), bits 0 and 1 will be used\n> for those respectively. Bit 2 will be p2tr. The remaining 13 bits are\n> reserved for future standard script types.\n>\n> 2. Notification transactions still exist but no longer leave a privacy\n> footprint on the blockchain. Instead, a notification transaction is simply\n> a single OP_RETURN containing a value that only Alice and Bob can\n> calculate. If Alice's notification transaction uses UTXOs not associated\n> with her identity, there is never a footprint showing that either her or\n> Bob are using private payments. If Alice uses tainted coins, only she is\n> exposed as a user of Private Payments but Bob still isn't.\n>\n> 3. Payment code versioning is no longer done because it creates the\n> potential for fragmentation and disparate standard updates by different\n> parties that don't follow the BIP process (BIP47 is a good example of that).\n>\n> 4. Relying on static compressed pubkeys as opposed to extended keys means\n> shorter payment codes.\n>\n> ==Proposed Payment Code Structure==\n>\n> bytes 0-1: - enabled (watched) address types (16 possible address types)\n> bytes 2-35: - compressed public key P\n>\n> ==Encoding==\n>\n> A payment code is encoded in base58check and the version byte produces \"S\"\n> for the first character. A code might look like\n> \"SwLUHs3UfMUXq956aXLTUPPfow7a8gDfSUUAtafwqHcobf6mKcMbJk\".\n>\n> ==Pubkey Derivation==\n>\n> Recipient's payment code pubkey `P` is derived from a master key using the\n> following path: `m/purpose'/coin_type'/account'`. `purpose` will be defined\n> once a BIP number is assigned. Its corresponding private key is `p`.\n>\n> Notifier/sender's pubkey `N` is derived using the following derivation\n> path: `m/purpose'/coin_type'/account'/*`, where each recipient gets a new\n> index. This way send-side privacy is always preserved. Its corresponding\n> private key is `n`.\n>\n> ==Notifications==\n>\n> Alice wants to notify Bob that he will receive future payments from her.\n> Alice selects any UTXO in her wallet (preferably not associated with her)\n> and `n_Alice`. Alice selects the public key contained in Bob's payment code\n> `P_Bob`. Alice performs the following process (`*` and `+` are EC\n> operations):\n>\n> notification = SHA256(n_Alice * P_Bob)\n>\n> Alice then constructs a 72-byte OP_RETURN output whose value is set to\n> `BIPXXXX + notification + N_Alice` (`+` is concat) and sends it in a\n> transaction containing no other outputs (XXXX to be replaced once a BIP\n> number is assigned). Alice MUST now keep track of `n_Alice` or its\n> derivation path as it will be used in future transactions exclusively with\n> Bob (not for spending but to calculate secret addresses).\n>\n> Bob's wallet receives whole blocks but doesn't need to waste resources on\n> decoding them if the environment is resource constrained. Bob simply needs\n> find the string BIPXXXX in the binary blob that represents an undecoded\n> block. Once found, Bob extracts the subsequent 32 bytes (`notification`)\n> and the subsequent 33 bytes (`N_Alice`). The benefit of this approach is\n> that Bob doesn't have to decode blocks and extract pubkeys from scriptsigs.\n>\n> Since ECDH dictates that SHA256(n_Alice * P_Bob) == SHA256(N_Alice *\n> p_Bob), Bob calculates the expected notification value and checks if it\n> matches the first value in the payload. If so, Bob found a notification\n> transaction addressed to himself and stores `N_Alice` in order to be able\n> to detect and spend future payments from Alice. The added benefit of this\n> approach over BIP47 is that Bob doesn't learn Alice's payment code, so\n> Alice can pay Bob without revealing her identity. To take advantage of\n> these privacy benefits, Alice simply has to engage in coin control on her\n> end. A real world scenario where this might be useful is anonymous\n> donations to a party whose wallet may be seized in the future. Seizing such\n> a wallet won't reveal who Alice is (as long as she engages in coin\n> control), whereas BIP47 would by default leak her identity even if her\n> coins as anonymized.\n>\n> If this process fails for any reason, Bob assumes a spurious notification\n> or one not addressed to himself and gives up.\n>\n> ==Transacting==\n>\n> Now that they are connected, Alice can send transactions to Bob. Alice\n> needs to keep track of her transaction count toward Bob; let's name that\n> counter `X`. This process is similar to what BIP47 does.\n>\n> Alice calculates a secret point:\n>\n> S = n_Alice * P_Bob\n>\n> Alice calculates a shared secret:\n>\n> s = SHA256(S, X)\n>\n> Alice calculates Bob's ephemeral public key and its associated address\n> where the funds will be sent:\n>\n> P_Bob' = P_Bob + s*G\n>\n> When Bob detects a payment to `P_Bob'`, he can spend such coins by\n> calculating the shared secret `s` in the same manner using `N_Alice` and\n> `p_Bob` and performing:\n>\n> p_bob' = p_bob + s\n>\n> The fact that Alice and Bob are using a shared counter means we can do\n> away with chain codes and make payment codes much smaller. Bob simply needs\n> to derive a number of addresses to watch with respect to some gap limit\n> (which can be as low as 1 in practice).\n>\n> ==Anti-spam==\n>\n> While DoS hasn't been a problem with BIP47, it is possible to build\n> anti-spam measures into payment codes. The owner of a code could simply\n> demand that a notification transaction meets some minimum miner fee or a\n> multiple of some trailing average. This would help prevent spam\n> notifications that might otherwise overwhelm a payment code with addresses\n> to watch. But that is purely optional.\n>\n> Looking forward to hearing thoughts and ideas.\n>\n> Alfred\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220627/eda92cd3/attachment-0001.html>"
            },
            {
                "author": "Alfred Hodler",
                "date": "2022-06-28T12:35:31",
                "message_text_only": "Hi Ruben,\n\nGood to see your input here.\n\n>I agree it's not as efficient as it could be, but how big is this problem in practice? Expecting payments on more addresses doesn't seem like a huge overhead. Or are you talking about the hassle of having to support spending from all these address types?\n\nMy worry is that once the number of standard scripts becomes significant, wallets will have to watch all of them. This could create a performance hit eventually, though I don't know what that would be in practice. Maybe someone else can offer more insight. It's possible to mitigate that using a tighter gap limit. But we still have the problem of wallets not supporting certain scripts. For example, Bob's wallet may not support wrapped segwit but Alice could accidentally send funds there assuming Bob can spend them.\n\nSP proposes to use Taproot-only (as we've been discussing elsewhere), but I still don't think it's the right solution to lock down the BIP to a single script type, for the sake of future proofing if nothing else. Having address type flags solves these issues at the expense having a couple of extra bytes.\n\n>but it does make it rather difficult to support light clients.\n\nThat's correct. This can't take advantage of compact block filters. Doing so would require having a notification address again. The scanning scheme is lighter and a bit simpler to implement than the one proposed by SP but it still presumes a full node.\n\n>The basic idea is that everyone publishes a single pubkey on-chain,\n\nIt even seems to me that Bob doesn't even have to publish his key on-chain unless he intends on sending funds. Only senders would have to do so, and pure recipients (if there would be any such entities) would just have to publish their codes off-chain (e.g. website donation address). The downside is that Alice now has to publish her pubkey on-chain, which creates a footprint. She's now a confirmed user of stealth addresses. She can mitigate that by publishing an ephemeral pubkey for each recipient, but this might spiral out of control fast if the standard gains wider acceptance.\n\n>Note that this mechanism is not safe against miners, as they can pay themselves arbitrarily high fees with no downside.\n\nGood point. Perhaps the solution is to require an OP_RETURN burn instead. I thought it's better to benefit the ecosystem by sending coins back to miners, but burning is also possible.\n\nAlfred\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/78d3b1f1/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-06-28T23:33:45",
                "message_text_only": "On Mon, Jun 27, 2022 at 10:30:39PM +0200, Ruben Somsen via bitcoin-dev wrote:\n> >demand that a notification transaction meets some minimum miner fee\n> \n> Note that this mechanism is not safe against miners, as they can pay\n> themselves arbitrarily high fees with no downside.\n\nBlock space is relatively expensive, so maybe it's enough that the spammer has\nto publish at all.\n\nYou could also do a timelocked sacrifice with OP_CSV.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220628/a75ec921/attachment.sig>"
            },
            {
                "author": "Clark Moody",
                "date": "2022-06-29T22:33:26",
                "message_text_only": "Alfred,\n\nThanks for the proposal. This is really interesting, especially the\nadditional on-chain privacy improvements over BIP47: ephemeral\nnotifier/sender keys and shielding of the sender key(s) against\nseizure of the recipient's wallet.\n\n> A payment code is encoded in base58check and the version byte produces \"S\" for the first character.\n\nThis is a bit under-specified, but let me bike-shed here and suggest\ngoing with a Bech32m encoding. We gain more compact QR codes as well\nas error detection/correction.\n\nAlternate proposal:\n\n- Bech32m human-readable part = \"pay\"\n- Data payload is [watched address type bytes (2), compressed pubkey (33)]\n\nExample:\n\n- Address type bytes = c000\n- Pubkey 03b54543fbed9d17d9300b508c55769bc4c8385620626730b4d52e5f3e30d9a6c1\n- Published payment code:\npay1cqqq8d29g0a7m8ghmycqk5yv24mfh3xg8ptzqcn8xz6d2tjl8ccdnfkpjl7p84\n\n> The owner of a code could simply demand that a notification transaction meets some minimum miner fee or a multiple of some trailing average.\n\nI don't see how this would work, and others have pointed out that the\ncost of block space is itself an anti-spam measure.\n\n== Notification Service Idea ==\n\nA third-party service could offer to publish OP_RETURN notification\npayloads in the blockchain for a fee, paid over Lightning Network.\nThis completely de-links Alice's notification from her wallet, while\naccepting the less-known privacy implications of a Lightning payment.\nThe service would remain ignorant of Bob's identity in any event. Such\na service would also be incentivized to charge market rates for the\npotential privacy boost and for block space.\n\n== Data Service Idea ==\n\nAnother service could publish only the OP_RETURN data pertaining to\nthis BIP, which is easy to obtain due to the clear tagging scheme.\nLight wallets would check in with this service on a regular basis,\nperforming the ECDH filtering steps on each output. Upon further\nrequest, the service furnishes transaction proofs for the full\ntransaction containing the OP_RETURN. Care would need to be taken to\navoid leaking too much information to the service, and techniques such\nas using separate Tor circuits or requesting tx proofs on a bulk set\nof transactions could help obfuscate the exact transaction of\ninterest. These concerns are similar to those found in BIP157\nclient-side block filtering (Neutrino filters).\n\nAlternatively, the service publishes the block height along with the\nnotification data contained within that block. Light clients could\ndownload relevant blocks over the p2p network and perform full\nvalidation.\n\n\n-Clark\n\nOn Mon, Jun 27, 2022 at 2:14 PM Alfred Hodler via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi,\n>\n> There have been attempts to create static payment codes that function as a way for transacting parties to create \"private\" addresses, where private stands for \"known only to transacting parties\". BIP47 was one such standard.\n>\n> The standard suffered from a number of problems:\n>\n> 1. The standard promised extensibility through versioning but it never used that capability to follow innovations in the Bitcoin protocol. It was designed around the idea that legacy p2pkh addresses would always be the primary and only way to transact. As new standard script types started to emerge (Segwit v0, Taproot), the creators dealt with the problem by stating that implementing wallets should scan for all existing standard scripts. The inability of payment codes to explicitly state which address types they derive places a burden on more resource constrained wallets.\n>\n> 2. The standard relied on a notification mechanism in order to connect a sender with a recipient, which included either offchain technology (Bitmessage), or so called \"notification addresses\" which a) left a footprint b) created toxic change. That type of footprint is particularly harmful because it makes it obvious that a particular recipient is going to receive private transactions. If the notifying party performs this process with coins linked to its identity (i.e. tainted or non-anonymized inputs), it forever becomes visible that Alice connected with Bob despite the fact that her payment code was blinded. While future transactions and their amounts aren't visible, this metadata makes it possible to build a social graph.\n>\n> 3. The standard was implemented only by an entity that disavowed the BIP process and didn't wish to use it to keep the standard up to date. Further updates did take place but only outside the BIP process, creating a lack of clarity as to what the real specification is. Ultimately the standard was abandoned.\n>\n> I propose to build on the idea of payment codes under a new BIP with the following principal differences:\n>\n> 1. The new standard will allocate a 2-byte bitflag array that will signal address/script types that the receiver is deriving. Since the vast majority of scripts are p2pkh (47.3%) and p2wpkh (26.2%), bits 0 and 1 will be used for those respectively. Bit 2 will be p2tr. The remaining 13 bits are reserved for future standard script types.\n>\n> 2. Notification transactions still exist but no longer leave a privacy footprint on the blockchain. Instead, a notification transaction is simply a single OP_RETURN containing a value that only Alice and Bob can calculate. If Alice's notification transaction uses UTXOs not associated with her identity, there is never a footprint showing that either her or Bob are using private payments. If Alice uses tainted coins, only she is exposed as a user of Private Payments but Bob still isn't.\n>\n> 3. Payment code versioning is no longer done because it creates the potential for fragmentation and disparate standard updates by different parties that don't follow the BIP process (BIP47 is a good example of that).\n>\n> 4. Relying on static compressed pubkeys as opposed to extended keys means shorter payment codes.\n>\n> ==Proposed Payment Code Structure==\n>\n> bytes 0-1: - enabled (watched) address types (16 possible address types)\n> bytes 2-35: - compressed public key P\n>\n> ==Encoding==\n>\n> A payment code is encoded in base58check and the version byte produces \"S\" for the first character. A code might look like \"SwLUHs3UfMUXq956aXLTUPPfow7a8gDfSUUAtafwqHcobf6mKcMbJk\".\n>\n> ==Pubkey Derivation==\n>\n> Recipient's payment code pubkey `P` is derived from a master key using the following path: `m/purpose'/coin_type'/account'`. `purpose` will be defined once a BIP number is assigned. Its corresponding private key is `p`.\n>\n> Notifier/sender's pubkey `N` is derived using the following derivation path: `m/purpose'/coin_type'/account'/*`, where each recipient gets a new index. This way send-side privacy is always preserved. Its corresponding private key is `n`.\n>\n> ==Notifications==\n>\n> Alice wants to notify Bob that he will receive future payments from her. Alice selects any UTXO in her wallet (preferably not associated with her) and `n_Alice`. Alice selects the public key contained in Bob's payment code `P_Bob`. Alice performs the following process (`*` and `+` are EC operations):\n>\n> notification = SHA256(n_Alice * P_Bob)\n>\n> Alice then constructs a 72-byte OP_RETURN output whose value is set to `BIPXXXX + notification + N_Alice` (`+` is concat) and sends it in a transaction containing no other outputs (XXXX to be replaced once a BIP number is assigned). Alice MUST now keep track of `n_Alice` or its derivation path as it will be used in future transactions exclusively with Bob (not for spending but to calculate secret addresses).\n>\n> Bob's wallet receives whole blocks but doesn't need to waste resources on decoding them if the environment is resource constrained. Bob simply needs find the string BIPXXXX in the binary blob that represents an undecoded block. Once found, Bob extracts the subsequent 32 bytes (`notification`) and the subsequent 33 bytes (`N_Alice`). The benefit of this approach is that Bob doesn't have to decode blocks and extract pubkeys from scriptsigs.\n>\n> Since ECDH dictates that SHA256(n_Alice * P_Bob) == SHA256(N_Alice * p_Bob), Bob calculates the expected notification value and checks if it matches the first value in the payload. If so, Bob found a notification transaction addressed to himself and stores `N_Alice` in order to be able to detect and spend future payments from Alice. The added benefit of this approach over BIP47 is that Bob doesn't learn Alice's payment code, so Alice can pay Bob without revealing her identity. To take advantage of these privacy benefits, Alice simply has to engage in coin control on her end. A real world scenario where this might be useful is anonymous donations to a party whose wallet may be seized in the future. Seizing such a wallet won't reveal who Alice is (as long as she engages in coin control), whereas BIP47 would by default leak her identity even if her coins as anonymized.\n>\n> If this process fails for any reason, Bob assumes a spurious notification or one not addressed to himself and gives up.\n>\n> ==Transacting==\n>\n> Now that they are connected, Alice can send transactions to Bob. Alice needs to keep track of her transaction count toward Bob; let's name that counter `X`. This process is similar to what BIP47 does.\n>\n> Alice calculates a secret point:\n>\n> S = n_Alice * P_Bob\n>\n> Alice calculates a shared secret:\n>\n> s = SHA256(S, X)\n>\n> Alice calculates Bob's ephemeral public key and its associated address where the funds will be sent:\n>\n> P_Bob' = P_Bob + s*G\n>\n> When Bob detects a payment to `P_Bob'`, he can spend such coins by calculating the shared secret `s` in the same manner using `N_Alice` and `p_Bob` and performing:\n>\n> p_bob' = p_bob + s\n>\n> The fact that Alice and Bob are using a shared counter means we can do away with chain codes and make payment codes much smaller. Bob simply needs to derive a number of addresses to watch with respect to some gap limit (which can be as low as 1 in practice).\n>\n> ==Anti-spam==\n>\n> While DoS hasn't been a problem with BIP47, it is possible to build anti-spam measures into payment codes. The owner of a code could simply demand that a notification transaction meets some minimum miner fee or a multiple of some trailing average. This would help prevent spam notifications that might otherwise overwhelm a payment code with addresses to watch. But that is purely optional.\n>\n> Looking forward to hearing thoughts and ideas.\n>\n> Alfred\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Private Payments",
            "categories": [
                "bitcoin-dev",
                "BIP proposal"
            ],
            "authors": [
                "Bryan Bishop",
                "Peter Todd",
                "Clark Moody",
                "Alfred Hodler",
                "Ruben Somsen"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 35509
        }
    },
    {
        "title": "[bitcoin-dev] RGB / Mimblewhimble: modularity of underlying ZK schemes",
        "thread_messages": [
            {
                "author": "abdelhamid bakhta",
                "date": "2022-06-30T12:27:44",
                "message_text_only": "Hi,\nI am wondering if there is some documentation about the modularity of the\nunderlying ZK schemes used to bring privacy on RGB. Specifically, seeing\nthat it currently uses Bulletproofs that are not Quantum Resistant, I am\nwondering how hard it would be to switch to a Quantum resistant\nalternative. Generally speaking, what is the design rationale for\ncryptographic primitives used in the Bitcoin ecosystem?\nWhat do people think about using ZK-Starks for some use cases like this?\nHas anyone started to experiment something on that front ?\nI am not sure about the most important criteria for RGB use cases between:\n- proving time\n- verification time\n- size of proofs\n- quantum resistance\n- communication complexity\nI am very curious about the particular choice of Bulletproofs in this\ncontext and cannot find any useful information about it.\n\nThanks for your help.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220630/eb9d324e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "RGB / Mimblewhimble: modularity of underlying ZK schemes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "abdelhamid bakhta"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1049
        }
    }
]