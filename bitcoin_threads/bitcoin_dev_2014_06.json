[
    {
        "title": "[Bitcoin-development] testnet-seed.bitcoin.petertodd.org is up again",
        "thread_messages": [
            {
                "author": "Alex Kotenko",
                "date": "2014-06-01T09:56:52",
                "message_text_only": "So generally it seems impossible to have both DNS seeds running on same IP\naddress. Too bad.\nOk, I'll switch to serving only testnet DNS on this server for now, as this\nseems to be a much bigger problem than mainnet. Later I might buy second IP\nto setup mainnet DNS also.\n\n\nBest regards,\nAlex Kotenko\n\n\n2014-05-30 15:51 GMT+01:00 Robert McKay <robert at mckay.com>:\n\n> No, I don't think so. The problem is the 'aa' flag is missing (see the\n> 'flags' section in dig). Perhaps if you could suppress the authority\n> records the recursor would give up and just accept the non-authorative\n> answer, but that isn't a good solution even if it might work for some\n> resolvers.\n>\n> Rob\n>\n>\n> On Fri, 30 May 2014 15:13:36 +0100, Alex Kotenko wrote:\n>\n>> Hmm, you might be right, as queries\n>> dig @node.alexykot.me [8] testnet-seed.alexykot.me [9]\n>>\n>> \u200band\n>>  dig @node.alexykot.me [10] -p 18353 testnet-seed.alexykot.me\n>> [11]\u200b\n>>\n>> \u200bare giving different authority sections.\n>>\n>> Hmm, but if I setup custom SOA record for it - it should work,\n>> right?\n>>  What SOA name should it be actually, assuming that NS record for\n>> testnet-seed.alexykot.me [12] is pointing at alexykot.me [13]?\n>>\n>> Best regards,\n>>\n>> Alex Kotenko\n>>\n>> 2014-05-30 14:41 GMT+01:00 Robert McKay :\n>>\n>>  Hi Alex,\n>>>\n>>> I think the problem is with my suggestion to use bind forwarding..\n>>> basically bind is stripping off the authorative answer bit in the\n>>> reply.. this causes the recursor to go into a loop chasing the\n>>> authority server which again returns a non-authoritve answer with\n>>> itself as the authority again. Im not sure if this can be fixed\n>>> without hacking the bind src, so maybe it wasnt such a great\n>>>\n>>> suggestion in the first place. Basically I think if bind was\n>>> returning authorative answers it would work, but I cant see any way\n>>>\n>>> to make that happen in the bind configuration.\n>>>\n>>> Rob\n>>>\n>>> On Fri, 30 May 2014 14:19:05 +0100, Alex Kotenko wrote:\n>>>\n>>>  Hi Peter\n>>>>\n>>>> Ive setup DNS seeds myself a week ago, at\n>>>> testnet-seed.alexykot.me [1] [6]\n>>>> and bitcoin-seed.alexykot.me [2] [7], but there is a problem with\n>>>>\n>>>> DNS\n>>>> settings that we with Andreas couldnt sort out quickly.\n>>>>\n>>>> The problem itself is that I can reach my nameserver and get\n>>>> dnsseed\n>>>> response if I query it directly with\n>>>>  dig @node.alexykot.me [3] [8] testnet-seed.alexykot.me [4] [9]\n>>>>\n>>>>  dig @node.alexykot.me [5] [10] bitcoin-seed.alexykot.me [6]\n>>>> [11]\n>>>>\n>>>> \u200bBut when I try nslookup testnet-seed.alexykot.me [7] [12]\u200b -\n>>>>\n>>>> it\n>>>> fails.\n>>>> I guess the problem is in my DNS settings but I cant figure out\n>>>> what\n>>>> is it.\n>>>>\n>>>> \u200bS o could you share\n>>>> \u200bhow you configured DNS\n>>>>  \u200b for your seed\n>>>> \u200b to help me debug\n>>>>  \u200bmine\n>>>> ?\n>>>>\n>>>> Best regards,\n>>>>\n>>>> Alex Kotenko\n>>>>\n>>>> \u200b\n>>>>\n>>>\n>>\n>> Links:\n>> ------\n>> [1] http://testnet-seed.alexykot.me\n>> [2] http://bitcoin-seed.alexykot.me\n>> [3] http://node.alexykot.me\n>> [4] http://testnet-seed.alexykot.me\n>> [5] http://node.alexykot.me\n>> [6] http://bitcoin-seed.alexykot.me\n>> [7] http://testnet-seed.alexykot.me\n>> [8] http://node.alexykot.me/\n>> [9] http://testnet-seed.alexykot.me/\n>> [10] http://node.alexykot.me/\n>> [11] http://testnet-seed.alexykot.me/\n>> [12] http://testnet-seed.alexykot.me\n>> [13] http://alexykot.me\n>> [14] mailto:robert at mckay.com\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140601/9e40b92b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "testnet-seed.bitcoin.petertodd.org is up again",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Alex Kotenko"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3603
        }
    },
    {
        "title": "[Bitcoin-development] [QT] Feature proposal: Displaying current Units/Changing Units with status bar control.",
        "thread_messages": [
            {
                "author": "sebastien requiem",
                "date": "2014-06-02T07:23:41",
                "message_text_only": "Hello Angel,\n\nGood initiative. This looks good. If I understand, the dropdown menu is for\nthe whole application, so it make sense to have it in a common part of the\nlayout.\n\nA slight optimisation would be to write the unit in the transaction table\nheader too (since we read from top to bottom). This would give something\nlike \"Amount (mBTC)\". That way, the user doesn't have to think twice about\nthe unit of his values.\n\n\nHope it helps,\n\n\n\n\n\nOn Fri, May 30, 2014 at 6:39 PM, Angel Leon <gubatron at gmail.com> wrote:\n\n> There's been quite a lot of debate over the default unit of display to\n> use, you can read the conversation here, which was closed.\n> https://github.com/bitcoin/bitcoin/issues/3862\n>\n> Whatever the side of the debate you're on, wether it should be BTC or\n> mBTC, or other, regular users will probably take too long to find a way to\n> change the current unit of display, and if the unit of display were ever\n> changed to something other than BTC, the current transaction tables\"Amount\"\n> column don't mention anywhere what Unit of Display is being used.\n>\n> So last night I started playing with the idea of having a status bar\n> component that would:\n> 1. Show you what is the current unit of display at all times.\n> 2. Let you change the unit of display easily.\n>\n> Here's how it looks (see attachment), just wanted to get feedback, if this\n> is something you also consider valuable in terms of user experience, or\n> maybe you don't want to allow any more controls on the status bar (because\n> then people will want to add more and more)\n>\n> Just want to get some feedback before I continue working on this to polish\n> it and submit a pull request.\n>\n>\n> Cheers.\n> Angel (@gubatron)\n>\n>\n> ------------------------------------------------------------------------------\n> Time is money. Stop wasting it! Get your web API in 5 minutes.\n> www.restlet.com/download\n> http://p.sf.net/sfu/restlet\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n\n\n-- \nsebastien requiem\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140602/36be2296/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-02T07:39:29",
                "message_text_only": "On Fri, May 30, 2014 at 6:39 PM, Angel Leon <gubatron at gmail.com> wrote:\n>\n> Here's how it looks (see attachment), just wanted to get feedback, if this\n> is something you also consider valuable in terms of user experience, or\n> maybe you don't want to allow any more controls on the status bar (because\n> then people will want to add more and more)\n\nLooks good to me.\n\nThough we already allow specifying a unit in all places where the user\ncan specify a BTC amount.\n\nWe also already show the unit in all places where amounts are shown,\nexcept the tables, would be good to add a [unit] in the header there\nas well, see https://github.com/bitcoin/bitcoin/issues/3970 .\n\nIf that is done, I'm not sure how much a global setting in the status\nbar would add. It may make it more apparent to the user that multiple\nunits can be selected.\n\nWladimir"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-02T07:54:19",
                "message_text_only": "On Mon, Jun 2, 2014 at 12:39 AM, Wladimir <laanwj at gmail.com> wrote:\n> If that is done, I'm not sure how much a global setting in the status\n> bar would add. It may make it more apparent to the user that multiple\n> units can be selected.\n\nIf thats done it should be done in a way in which it's impossible that\na stray keypress could switch it or someone may eventually have a very\nvery bad day."
            },
            {
                "author": "Angel Leon",
                "date": "2014-06-02T19:41:12",
                "message_text_only": "With this I'll continue then to work on this with the addition of:\n- Showing the current unit on the header column title \"Amount ($unitHere)\"\n- Will make sure the user cannot change the current unit of display by\nmistake by adding a confirmation dialog.\n\nThanks all for the feedback!\nAngel.\n\nhttp://twitter.com/gubatron\n\n\nOn Mon, Jun 2, 2014 at 3:54 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:\n\n> On Mon, Jun 2, 2014 at 12:39 AM, Wladimir <laanwj at gmail.com> wrote:\n> > If that is done, I'm not sure how much a global setting in the status\n> > bar would add. It may make it more apparent to the user that multiple\n> > units can be selected.\n>\n> If thats done it should be done in a way in which it's impossible that\n> a stray keypress could switch it or someone may eventually have a very\n> very bad day.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140602/4ad1fddf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Feature proposal: Displaying current Units/Changing Units with status bar control.",
            "categories": [
                "Bitcoin-development",
                "QT"
            ],
            "authors": [
                "Angel Leon",
                "Gregory Maxwell",
                "Wladimir",
                "sebastien requiem"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 4555
        }
    },
    {
        "title": "[Bitcoin-development] Another uninitialized memory problem",
        "thread_messages": [
            {
                "author": "Toshi Morita",
                "date": "2014-06-02T20:01:49",
                "message_text_only": "I'm seeing another uninitialized memory problem in bitcoind using valgrind:\n\ntm at tm-VirtualBox:~/bitcoind/bitcoin/src$ valgrind ./bitcoind\n==2337== Memcheck, a memory error detector\n==2337== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.\n==2337== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info\n==2337== Command: ./bitcoind\n==2337==\n==2337== Conditional jump or move depends on uninitialised value(s)\n==2337==    at 0x319176: CWallet::LoadKeyMetadata(CPubKey const&,\nCKeyMetadata const&) (wallet.cpp:110)\n==2337==    by 0x33645A: ReadKeyValue(CWallet*, CDataStream&, CDataStream&,\nCWalletScanState&, std::string&, std::string&) (walletdb.cpp:509)\n==2337==    by 0x3374F0: CWalletDB::LoadWallet(CWallet*) (walletdb.cpp:623)\n==2337==    by 0x3218FD: CWallet::LoadWallet(bool&) (wallet.cpp:1485)\n==2337==    by 0x157F16: AppInit2(boost::thread_group&) (init.cpp:958)\n==2337==    by 0x140142: AppInit(int, char**) (bitcoind.cpp:143)\n==2337==    by 0x13649E: main (bitcoind.cpp:180)\n==2337==\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140602/762b726d/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-03T09:57:11",
                "message_text_only": "On Mon, Jun 2, 2014 at 10:01 PM, Toshi Morita <toshi at peernova.com> wrote:\n> I'm seeing another uninitialized memory problem in bitcoind using valgrind:\n\nThanks for the report.\n\nWhich version/commit id of bitcoind?\n\nWladimir"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-03T16:43:15",
                "message_text_only": "I think I see the problem.\n\n\nOn Mon, Jun 2, 2014 at 4:01 PM, Toshi Morita <toshi at peernova.com> wrote:\n> I'm seeing another uninitialized memory problem in bitcoind using valgrind:\n>\n> tm at tm-VirtualBox:~/bitcoind/bitcoin/src$ valgrind ./bitcoind\n> ==2337== Memcheck, a memory error detector\n> ==2337== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.\n> ==2337== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info\n> ==2337== Command: ./bitcoind\n> ==2337==\n> ==2337== Conditional jump or move depends on uninitialised value(s)\n> ==2337==    at 0x319176: CWallet::LoadKeyMetadata(CPubKey const&,\n> CKeyMetadata const&) (wallet.cpp:110)\n> ==2337==    by 0x33645A: ReadKeyValue(CWallet*, CDataStream&, CDataStream&,\n> CWalletScanState&, std::string&, std::string&) (walletdb.cpp:509)\n> ==2337==    by 0x3374F0: CWalletDB::LoadWallet(CWallet*) (walletdb.cpp:623)\n> ==2337==    by 0x3218FD: CWallet::LoadWallet(bool&) (wallet.cpp:1485)\n> ==2337==    by 0x157F16: AppInit2(boost::thread_group&) (init.cpp:958)\n> ==2337==    by 0x140142: AppInit(int, char**) (bitcoind.cpp:143)\n> ==2337==    by 0x13649E: main (bitcoind.cpp:180)\n> ==2337==\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Toshi Morita",
                "date": "2014-06-03T16:47:53",
                "message_text_only": "I looked at this a bit more yesterday, and it looks like both sides of the\ncomparison were uninitialized, and I fixed one side, but the other side has\nthe same problem.\n\nI'll try to investigate further this afternoon once I get out of\nmeetings/meetings prep.\n\nToshi\n\n\n\nOn Tue, Jun 3, 2014 at 9:43 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n\n> I think I see the problem.\n>\n>\n> On Mon, Jun 2, 2014 at 4:01 PM, Toshi Morita <toshi at peernova.com> wrote:\n> > I'm seeing another uninitialized memory problem in bitcoind using\n> valgrind:\n> >\n> > tm at tm-VirtualBox:~/bitcoind/bitcoin/src$ valgrind ./bitcoind\n> > ==2337== Memcheck, a memory error detector\n> > ==2337== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.\n> > ==2337== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright\n> info\n> > ==2337== Command: ./bitcoind\n> > ==2337==\n> > ==2337== Conditional jump or move depends on uninitialised value(s)\n> > ==2337==    at 0x319176: CWallet::LoadKeyMetadata(CPubKey const&,\n> > CKeyMetadata const&) (wallet.cpp:110)\n> > ==2337==    by 0x33645A: ReadKeyValue(CWallet*, CDataStream&,\n> CDataStream&,\n> > CWalletScanState&, std::string&, std::string&) (walletdb.cpp:509)\n> > ==2337==    by 0x3374F0: CWalletDB::LoadWallet(CWallet*)\n> (walletdb.cpp:623)\n> > ==2337==    by 0x3218FD: CWallet::LoadWallet(bool&) (wallet.cpp:1485)\n> > ==2337==    by 0x157F16: AppInit2(boost::thread_group&) (init.cpp:958)\n> > ==2337==    by 0x140142: AppInit(int, char**) (bitcoind.cpp:143)\n> > ==2337==    by 0x13649E: main (bitcoind.cpp:180)\n> > ==2337==\n> >\n> >\n> >\n> ------------------------------------------------------------------------------\n> > Learn Graph Databases - Download FREE O'Reilly Book\n> > \"Graph Databases\" is the definitive new guide to graph databases and\n> their\n> > applications. Written by three acclaimed leaders in the field,\n> > this first edition is now available. Download your free book today!\n> > http://p.sf.net/sfu/NeoTech\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >\n>\n>\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140603/c007c863/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-03T17:40:38",
                "message_text_only": "Does this fix it?  https://github.com/bitcoin/bitcoin/pull/4282\n\n\nOn Tue, Jun 3, 2014 at 12:47 PM, Toshi Morita <toshi at peernova.com> wrote:\n> I looked at this a bit more yesterday, and it looks like both sides of the\n> comparison were uninitialized, and I fixed one side, but the other side has\n> the same problem.\n>\n> I'll try to investigate further this afternoon once I get out of\n> meetings/meetings prep.\n>\n> Toshi\n>\n>\n>\n> On Tue, Jun 3, 2014 at 9:43 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>>\n>> I think I see the problem.\n>>\n>>\n>> On Mon, Jun 2, 2014 at 4:01 PM, Toshi Morita <toshi at peernova.com> wrote:\n>> > I'm seeing another uninitialized memory problem in bitcoind using\n>> > valgrind:\n>> >\n>> > tm at tm-VirtualBox:~/bitcoind/bitcoin/src$ valgrind ./bitcoind\n>> > ==2337== Memcheck, a memory error detector\n>> > ==2337== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.\n>> > ==2337== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright\n>> > info\n>> > ==2337== Command: ./bitcoind\n>> > ==2337==\n>> > ==2337== Conditional jump or move depends on uninitialised value(s)\n>> > ==2337==    at 0x319176: CWallet::LoadKeyMetadata(CPubKey const&,\n>> > CKeyMetadata const&) (wallet.cpp:110)\n>> > ==2337==    by 0x33645A: ReadKeyValue(CWallet*, CDataStream&,\n>> > CDataStream&,\n>> > CWalletScanState&, std::string&, std::string&) (walletdb.cpp:509)\n>> > ==2337==    by 0x3374F0: CWalletDB::LoadWallet(CWallet*)\n>> > (walletdb.cpp:623)\n>> > ==2337==    by 0x3218FD: CWallet::LoadWallet(bool&) (wallet.cpp:1485)\n>> > ==2337==    by 0x157F16: AppInit2(boost::thread_group&) (init.cpp:958)\n>> > ==2337==    by 0x140142: AppInit(int, char**) (bitcoind.cpp:143)\n>> > ==2337==    by 0x13649E: main (bitcoind.cpp:180)\n>> > ==2337==\n>> >\n>> >\n>> >\n>> > ------------------------------------------------------------------------------\n>> > Learn Graph Databases - Download FREE O'Reilly Book\n>> > \"Graph Databases\" is the definitive new guide to graph databases and\n>> > their\n>> > applications. Written by three acclaimed leaders in the field,\n>> > this first edition is now available. Download your free book today!\n>> > http://p.sf.net/sfu/NeoTech\n>> > _______________________________________________\n>> > Bitcoin-development mailing list\n>> > Bitcoin-development at lists.sourceforge.net\n>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>> >\n>>\n>>\n>>\n>> --\n>> Jeff Garzik\n>> Bitcoin core developer and open source evangelist\n>> BitPay, Inc.      https://bitpay.com/\n>\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Another uninitialized memory problem",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Toshi Morita",
                "Wladimir"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 8389
        }
    },
    {
        "title": "[Bitcoin-development] Lets discuss what to do if SHA256d is actually broken",
        "thread_messages": [
            {
                "author": "xor",
                "date": "2014-06-03T04:29:55",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nHi,\n\nI thought a lot about the worst case scenario of SHA256d being broken in a way \nwhich could be abused to \nA) reduce the work of mining a block by some significant amount\nB) reduce the work of mining a block to zero, i.e. allow instant mining.\n\nBitcoin needs to be prepared for this as any hash function has a limited \nlifetime. Usually crypto stuff is not completely broken instantly by new \nattacks but gradually. For example first the attack difficulty is reduced from \n2^128 to 2^100, then 2^64, etc.\nThis would make scenario A more likely.\n\nNow while B sounds more dangerous, I think in fact A is:\nConsider how A would happen in real life: Someone publishes a paper of a \ntheoretical reduction of SHA256d attacks to 2^96 bit. Mathematicians will \nconsider this as a serious attack and create a lot of riot.\nIf no plan is made early enough, as in now, the Bitcoin Core team might then \nprobably want to just do the easiest approach of replacing the hash function \nafter a certain block number, i.e. a hard fork.\nBut what about the Bitcoin miners, those who need to actually accept a change \nof mining algorithm which renders their hardware which cost MILLIONS \ncompletely worthless?\nOver the years they have gotten used to exponential growth of the Bitcoin \nnetworks hashrate, and therefore exponential devaluation of their mining \nhardware. Even if the attack on SHA256d causes a significant growth of \ndifficulty, the miners will not *believe* that it is an actual attack on SHA256d \n- - maybe it is just some new large mining operation?  They are used to this \nhappening! Why should they believe this and switch to a new hash function \nwhich requires completely new hardware and therefore costs them millions?\nThey will just keep mining SHA256d. Thats why this is more dangerous, because \nchanging the hash funciton won't be accepted by the miners even though it is \nbroken.\nSomething smarter needs to be thought of.\n\nNow I must admit that I am not good at cryptography at all, but I had the \nfollowing idea: Use the altcoin concept of having multiple hash functions in a \nchain. If SHA256d is broken, it is chained with a new hash function.\nThereby, people who want to mine the new replacement hash function still will \nneed ASICs which can solve the old SHA proof of work. So existing ASIC owners \ncan amend their code to do SHA256d using the ASIC, and then the second hash \nfunction using a general purpose CPU.\nThis would also allow a smooth migration of difficulty - I don't even know how \ndifficulty would react with the naive approach of just replacing SHA with \nsomething else: It would probably be an unsolvable problem to define new rules \nto make it decrease enough so new blocks can actually be mined by the now \nseveral orders of magnitude slower CPU-only mining community but still be high \nenough to be able to deal with the fact that millions of people will try their \nluck with mining at the release date.\n\nWhile this sounds simple in theory, it might be a lot of work to implement, so \nyou guys might want to take precautions for it soon :)\n\nGreetings,\n\txor - A Freenet project developer\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\n\niQIcBAEBCAAGBQJTjU9DAAoJEMtmZ+8tjWt5pNEP/2460eHu7ujrUSxinJXY7+wF\nE759/NcpNuakqu4NsS3ndi8lSiVIeixiOWZxPwLYkzC0pgPd5JrK5hdrYewsgreL\nLtkh6LKB4YZLYrV3jm62ZPMTzCopYQ1l872xbN3PJQJoXhEp4fKu99++LDzVg9Gk\nn7rvrk6Iy/nSsZ1IMANpKghbU8/Gtn6ppCJv9rxRE//CZdTso1tTyOXXkEEMTHcV\ny/iv6CHXtTXPvOgEgciU0oCPq0NOUKdIAOD//ybcKzncOoHSmwr1rZdreCTH6/Ek\n9uwq/HaQnseHPrq9qrIkIKrZDlnjKu7Tqw1BlbyBeCrWdJPCeDJg2kyCXgTvIzFD\noXwZ6r16tb2QPR4ByyO1lZy9G2Pp26thk12BnadnPYTf1rMvsY15BjfUrCU9ppt/\nYpFAZSFlXUGOuOBKUznUeO8U1bXJylcTTnyER/cudOpcKR8Jt9l5tfm5LTHCB6Q2\nTjmvsmd0BzwafLEhHD5FHoTZFNVdXWvEUO/w4I/2UWTS7CacbE1qk0rVpsF/4L1K\n/oFVnZIUKqsm5mMMb6WTQq+MjP2TF/eAAwm2UtFYmj0FVML9HBNwyiAc5UKwnD4Y\nYq3Pl5QfRobwu6pgT3zO7vK+saOl8sePWbU8Skj41OTEDrJM4QIQGAqs1U8xke8+\nYnUYiyzreJ8ofHhNBs4/\n=dkuk\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Luke Dashjr",
                "date": "2014-06-03T04:52:39",
                "message_text_only": "On Tuesday, June 03, 2014 4:29:55 AM xor wrote:\n> Hi,\n> \n> I thought a lot about the worst case scenario of SHA256d being broken in a\n> way which could be abused to\n> A) reduce the work of mining a block by some significant amount\n> B) reduce the work of mining a block to zero, i.e. allow instant mining.\n\nC) fabricate past blocks entirely.\n\nIf SHA256d is broken, Bitcoin as it is fails entirely.\n\nLuke"
            },
            {
                "author": "Ethan Heilman",
                "date": "2014-06-03T11:51:45",
                "message_text_only": "An attack on the mining difficulty algorithm does not imply violation of\nthe typical security properties of a cryptographic hash function*.\n\nAssume someone discovers a method which makes it far easier to discover new\nblocks, this method: may or may not be implementable by the current SHA256\nASIC hardware.\n\n1. If it is usable by the mining hardware, then there will be brief period\nof overproduction and then difficulty will adjust. If the attack is so bad\nthat difficulty can't scale and we run out of a leading zero's, then the\nSHA256 collision resistance is broken and we have bigger problems. Under\nthis scenario, everyone would see the need to immediately switch to new\nhardware as people could create cycles and irreconcilable forks in the\nblock chain\n\n2. If the attack is not usable by the mining hardware, then the miners will\nneed to switch to new ASICs anyways and the hash function can be changed\nwithout resistance.\n\nBut lets ignore all that and say, for some unspecified reason, the bitcoin\ncommunity wants to switch hash functions and has some lead time to do so.\nOne could require that miners find two blocks, one computed using SHA256\nand one computed using the new hash function. We could then slowly shift\nthe difficulty from SHA256 to the new hash function. This would allow\nminers a semi-predicable roadmap to switch their infrastructure away from\nSHA256.\n\n* It would be a distinguisher which would be bad, but collision resistance\ncould be merely weakened.\n\n\nOn Tue, Jun 3, 2014 at 12:52 AM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> On Tuesday, June 03, 2014 4:29:55 AM xor wrote:\n> > Hi,\n> >\n> > I thought a lot about the worst case scenario of SHA256d being broken in\n> a\n> > way which could be abused to\n> > A) reduce the work of mining a block by some significant amount\n> > B) reduce the work of mining a block to zero, i.e. allow instant mining.\n>\n> C) fabricate past blocks entirely.\n>\n> If SHA256d is broken, Bitcoin as it is fails entirely.\n>\n> Luke\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140603/5a51bf30/attachment.html>"
            },
            {
                "author": "Ashley Holman",
                "date": "2014-06-03T15:12:12",
                "message_text_only": "There is a relevant post from Satoshi on this:\n\nhttps://bitcointalk.org/index.php?topic=191.msg1585#msg1585\n\nQuote:\n\n\"If SHA-256 became completely broken, I think we could come to some\nagreement about what the honest block chain was before the trouble started,\nlock that in and continue from there with a new hash function.\n\nIf the hash breakdown came gradually, we could transition to a new hash in\nan orderly way.  The software would be programmed to start using a new hash\nafter a certain block number.  Everyone would have to upgrade by that time.\n The software could save the new hash of all the old blocks to make sure a\ndifferent block with the same old hash can't be used.\"\n\n\nOn Tue, Jun 3, 2014 at 9:21 PM, Ethan Heilman <eth3rs at gmail.com> wrote:\n\n> An attack on the mining difficulty algorithm does not imply violation of\n> the typical security properties of a cryptographic hash function*.\n>\n> Assume someone discovers a method which makes it far easier to discover\n> new blocks, this method: may or may not be implementable by the current\n> SHA256 ASIC hardware.\n>\n> 1. If it is usable by the mining hardware, then there will be brief period\n> of overproduction and then difficulty will adjust. If the attack is so bad\n> that difficulty can't scale and we run out of a leading zero's, then the\n> SHA256 collision resistance is broken and we have bigger problems. Under\n> this scenario, everyone would see the need to immediately switch to new\n> hardware as people could create cycles and irreconcilable forks in the\n> block chain\n>\n> 2. If the attack is not usable by the mining hardware, then the miners\n> will need to switch to new ASICs anyways and the hash function can be\n> changed without resistance.\n>\n> But lets ignore all that and say, for some unspecified reason, the bitcoin\n> community wants to switch hash functions and has some lead time to do so.\n> One could require that miners find two blocks, one computed using SHA256\n> and one computed using the new hash function. We could then slowly shift\n> the difficulty from SHA256 to the new hash function. This would allow\n> miners a semi-predicable roadmap to switch their infrastructure away from\n> SHA256.\n>\n> * It would be a distinguisher which would be bad, but collision resistance\n> could be merely weakened.\n>\n>\n> On Tue, Jun 3, 2014 at 12:52 AM, Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> On Tuesday, June 03, 2014 4:29:55 AM xor wrote:\n>> > Hi,\n>> >\n>> > I thought a lot about the worst case scenario of SHA256d being broken\n>> in a\n>> > way which could be abused to\n>> > A) reduce the work of mining a block by some significant amount\n>> > B) reduce the work of mining a block to zero, i.e. allow instant mining.\n>>\n>> C) fabricate past blocks entirely.\n>>\n>> If SHA256d is broken, Bitcoin as it is fails entirely.\n>>\n>> Luke\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Learn Graph Databases - Download FREE O'Reilly Book\n>> \"Graph Databases\" is the definitive new guide to graph databases and their\n>> applications. Written by three acclaimed leaders in the field,\n>> this first edition is now available. Download your free book today!\n>> http://p.sf.net/sfu/NeoTech\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/287312fb/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2014-06-03T12:45:23",
                "message_text_only": "Luke Dashjr <luke at dashjr.org> writes:\n> On Tuesday, June 03, 2014 4:29:55 AM xor wrote:\n>> Hi,\n>> \n>> I thought a lot about the worst case scenario of SHA256d being broken in a\n>> way which could be abused to\n>> A) reduce the work of mining a block by some significant amount\n>> B) reduce the work of mining a block to zero, i.e. allow instant mining.\n>\n> C) fabricate past blocks entirely.\n>\n> If SHA256d is broken, Bitcoin as it is fails entirely.\n\nI normally just lurk, but I looked at this issue last year, so thought\nI'd chime in.  I never finished my paper though...\n\nIn the event of an *anticipated* weakening of SHA256, a gradual\ntransition is possible which avoids massive financial disruption.\n\nMy scheme used a similar solve-SHA256-then-solve-SHA3 (requiring an\nextra nonce for the SHA3), with the difficulty of SHA256 ramping down\nand SHA3 ramping up over the transition (eg for a 1 year transition,\nstart with 25/26 SHA2 and 1/26 SHA3).\n\nThe hard part is to estimate what the SHA3 difficulty should be over\ntime.  My solution was to adjust only the SHA3 target on every *second*\ndifficulty change (otherwise assume that SHA2 and SHA3 have equally\nchanged rate and adjust targets on both).\n\nThis works reasonably well even if the initial SHA3 difficulty is way\noff, and also if SHA2 breaks completely halfway through the transition.\n\nI can provide more details if anyone is interested.\n\nCheers,\nRusty."
            },
            {
                "author": "Charlie 'Charles' Shrem",
                "date": "2014-06-04T01:38:04",
                "message_text_only": "Hey Rusty,\n\nThis is intriguing, do you have a writeup somewhere I can read more about ?\n\nThanks,\n\nCharlie\n\nCharlieShrem.com | *Please **encrypt messages with my PGP key\n<http://charlieshrem.com/contact/>*\n\n\nOn Tue, Jun 3, 2014 at 8:45 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Luke Dashjr <luke at dashjr.org> writes:\n> > On Tuesday, June 03, 2014 4:29:55 AM xor wrote:\n> >> Hi,\n> >>\n> >> I thought a lot about the worst case scenario of SHA256d being broken\n> in a\n> >> way which could be abused to\n> >> A) reduce the work of mining a block by some significant amount\n> >> B) reduce the work of mining a block to zero, i.e. allow instant mining.\n> >\n> > C) fabricate past blocks entirely.\n> >\n> > If SHA256d is broken, Bitcoin as it is fails entirely.\n>\n> I normally just lurk, but I looked at this issue last year, so thought\n> I'd chime in.  I never finished my paper though...\n>\n> In the event of an *anticipated* weakening of SHA256, a gradual\n> transition is possible which avoids massive financial disruption.\n>\n> My scheme used a similar solve-SHA256-then-solve-SHA3 (requiring an\n> extra nonce for the SHA3), with the difficulty of SHA256 ramping down\n> and SHA3 ramping up over the transition (eg for a 1 year transition,\n> start with 25/26 SHA2 and 1/26 SHA3).\n>\n> The hard part is to estimate what the SHA3 difficulty should be over\n> time.  My solution was to adjust only the SHA3 target on every *second*\n> difficulty change (otherwise assume that SHA2 and SHA3 have equally\n> changed rate and adjust targets on both).\n>\n> This works reasonably well even if the initial SHA3 difficulty is way\n> off, and also if SHA2 breaks completely halfway through the transition.\n>\n> I can provide more details if anyone is interested.\n>\n> Cheers,\n> Rusty.\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140603/1b65e2fd/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2014-06-05T06:09:15",
                "message_text_only": "Charlie 'Charles' Shrem <cshrem at gmail.com> writes:\n> Hey Rusty,\n>\n> This is intriguing, do you have a writeup somewhere I can read more about ?\n\nOK, ignore the FIXMEs, but I rehashed my stupid sim code, added some\ngraphs to the (clearly unfinished) paper and uploaded it to github:\n\nhttps://github.com/rustyrussell/bitcoin_hashchange\n\nPDF is in there too, for easier reading.\n\nCheers,\nRusty."
            },
            {
                "author": "Kevin",
                "date": "2014-06-03T14:43:39",
                "message_text_only": "On 6/3/2014 12:29 AM, xor wrote:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA256\n>\n> Hi,\n>\n> I thought a lot about the worst case scenario of SHA256d being broken in a way\n> which could be abused to\n> A) reduce the work of mining a block by some significant amount\n> B) reduce the work of mining a block to zero, i.e. allow instant mining.\n>\n> Bitcoin needs to be prepared for this as any hash function has a limited\n> lifetime. Usually crypto stuff is not completely broken instantly by new\n> attacks but gradually. For example first the attack difficulty is reduced from\n> 2^128 to 2^100, then 2^64, etc.\n> This would make scenario A more likely.\n>\n> Now while B sounds more dangerous, I think in fact A is:\n> Consider how A would happen in real life: Someone publishes a paper of a\n> theoretical reduction of SHA256d attacks to 2^96 bit. Mathematicians will\n> consider this as a serious attack and create a lot of riot.\n> If no plan is made early enough, as in now, the Bitcoin Core team might then\n> probably want to just do the easiest approach of replacing the hash function\n> after a certain block number, i.e. a hard fork.\n> But what about the Bitcoin miners, those who need to actually accept a change\n> of mining algorithm which renders their hardware which cost MILLIONS\n> completely worthless?\n> Over the years they have gotten used to exponential growth of the Bitcoin\n> networks hashrate, and therefore exponential devaluation of their mining\n> hardware. Even if the attack on SHA256d causes a significant growth of\n> difficulty, the miners will not *believe* that it is an actual attack on SHA256d\n> - - maybe it is just some new large mining operation?  They are used to this\n> happening! Why should they believe this and switch to a new hash function\n> which requires completely new hardware and therefore costs them millions?\n> They will just keep mining SHA256d. Thats why this is more dangerous, because\n> changing the hash funciton won't be accepted by the miners even though it is\n> broken.\n> Something smarter needs to be thought of.\n>\n> Now I must admit that I am not good at cryptography at all, but I had the\n> following idea: Use the altcoin concept of having multiple hash functions in a\n> chain. If SHA256d is broken, it is chained with a new hash function.\n> Thereby, people who want to mine the new replacement hash function still will\n> need ASICs which can solve the old SHA proof of work. So existing ASIC owners\n> can amend their code to do SHA256d using the ASIC, and then the second hash\n> function using a general purpose CPU.\n> This would also allow a smooth migration of difficulty - I don't even know how\n> difficulty would react with the naive approach of just replacing SHA with\n> something else: It would probably be an unsolvable problem to define new rules\n> to make it decrease enough so new blocks can actually be mined by the now\n> several orders of magnitude slower CPU-only mining community but still be high\n> enough to be able to deal with the fact that millions of people will try their\n> luck with mining at the release date.\n>\n> While this sounds simple in theory, it might be a lot of work to implement, so\n> you guys might want to take precautions for it soon :)\n>\n> Greetings,\n> \txor - A Freenet project developer\n>\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1.4.14 (GNU/Linux)\n>\n> iQIcBAEBCAAGBQJTjU9DAAoJEMtmZ+8tjWt5pNEP/2460eHu7ujrUSxinJXY7+wF\n> E759/NcpNuakqu4NsS3ndi8lSiVIeixiOWZxPwLYkzC0pgPd5JrK5hdrYewsgreL\n> Ltkh6LKB4YZLYrV3jm62ZPMTzCopYQ1l872xbN3PJQJoXhEp4fKu99++LDzVg9Gk\n> n7rvrk6Iy/nSsZ1IMANpKghbU8/Gtn6ppCJv9rxRE//CZdTso1tTyOXXkEEMTHcV\n> y/iv6CHXtTXPvOgEgciU0oCPq0NOUKdIAOD//ybcKzncOoHSmwr1rZdreCTH6/Ek\n> 9uwq/HaQnseHPrq9qrIkIKrZDlnjKu7Tqw1BlbyBeCrWdJPCeDJg2kyCXgTvIzFD\n> oXwZ6r16tb2QPR4ByyO1lZy9G2Pp26thk12BnadnPYTf1rMvsY15BjfUrCU9ppt/\n> YpFAZSFlXUGOuOBKUznUeO8U1bXJylcTTnyER/cudOpcKR8Jt9l5tfm5LTHCB6Q2\n> Tjmvsmd0BzwafLEhHD5FHoTZFNVdXWvEUO/w4I/2UWTS7CacbE1qk0rVpsF/4L1K\n> /oFVnZIUKqsm5mMMb6WTQq+MjP2TF/eAAwm2UtFYmj0FVML9HBNwyiAc5UKwnD4Y\n> Yq3Pl5QfRobwu6pgT3zO7vK+saOl8sePWbU8Skj41OTEDrJM4QIQGAqs1U8xke8+\n> YnUYiyzreJ8ofHhNBs4/\n> =dkuk\n> -----END PGP SIGNATURE-----\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\nIt is good to start thinking about such things.  Let's face it, it could \nhappen.  However, short of having bitcoin use another algorithm for \nencryption, I am not sure much could be done.  That's just me.\n\n\n-- \nKevin"
            }
        ],
        "thread_summary": {
            "title": "Lets discuss what to do if SHA256d is actually broken",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Rusty Russell",
                "Ashley Holman",
                "xor",
                "Kevin",
                "Luke Dashjr",
                "Ethan Heilman",
                "Charlie 'Charles' Shrem"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 20620
        }
    },
    {
        "title": "[Bitcoin-development] # error \"Bitcoin cannot be compiled without assertions.\" <<<<NOT",
        "thread_messages": [
            {
                "author": "Ron",
                "date": "2014-06-03T19:07:01",
                "message_text_only": "Hello\n\nWhat is the issue with the Bitcoin code for 0.9.x with regard to assertions that isn't in 0.8.6 or previous releases?\n\non April 18th, I offered \n\nhttps://github.com/bc4-old-c-coder/bitcoin/commit/f0d221e56a12947b67b9c8f43cc5832b665052c8 \n\nthis commit and code with all side effects removed from the assertions.\n\n\nThen on the 28th,\n\nhttps://github.com/bc4-old-c-coder/bitcoin/tree/0.8.6 \n\nthis code with unit tests working.\n\nAnd if that isn't enough, I did a video series on building Bitcoind.exe and the static libraries (on MSVC++) all in NDEBUG (release) mode.\n\nSee\nhttps://www.youtube.com/playlist?list=PLFnWb0ttBBMLyUuniLp3PJ5Mn4tVUlliZ\u00a0 \nNotice that the NDEBUG release mode is featured, and I even run it!\n\nLastly what does that say about building Bitcoin-qt in release mode?\u00a0 Should one or not??\n\nThere is also a video on building an alternate coin-qt.exe in release mode (gcc version) and running it!\u00a0 See \nhttps://www.youtube.com/watch?v=C8GvHpjbAnM \n\n\n\u00a0\n\n\nassert() should have no side effects, that is the problem.\n\nSee\nhttp://books.google.com/books?id=L5ZbzVnpkXAC&pg=PA72&lpg=PA72&dq=Gotcha+%2328+Side+Effects&source=bl&ots=Rn15TlPmje&sig=tymHqta0aSANwaM2GaXC-1Di_tk&hl=en&sa=X&ei=uVKNU47fCcvTsAT6goHIBA&ved=0CCAQ6AEwAA#v=onepage&q=Gotcha%20%2328%20Side%20Effects&f=false\n\na\n great book, BTW.\u00a0 Everyone who thinks they know what they are doing \nwhen they write C++ should read this book!\u00a0 They will realize that they \ndon't know Jack \n\nWhy weren't these and all the other examples of amateur, i.e., non-professional, software fixed way back in version 0.3.0 in 2010, before any more releases were done?\u00a0 And why were these and other sub-standard coding practices continued and expanded in later releases, right up until the present? \n\nRon\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140603/194feac4/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-04T09:51:31",
                "message_text_only": "Hi Ron,\n\nFYI your mail is being spamfoldered due to Yahoo's DMARC policy and the\nbrokenness of the SF.net mailing list software. I would not expect to get\nreplies reliably whilst this is the case. I think we should move away from\nSF.net for hosting mailing lists personally, because it's this list that's\nat fault not Yahoo, but until then you may wish to send to the list with a\ndifferent email address.\n\nAs to your question,\n\nassert() should have *no* side effects, that is the problem.\n>\n> See\n>\n> http://books.google.com/books?id=L5ZbzVnpkXAC&pg=PA72&lpg=PA72&dq=Gotcha+%2328+Side+Effects&source=bl&ots=Rn15TlPmje&sig=tymHqta0aSANwaM2GaXC-1Di_tk&hl=en&sa=X&ei=uVKNU47fCcvTsAT6goHIBA&ved=0CCAQ6AEwAA#v=onepage&q=Gotcha%20%2328%20Side%20Effects&f=false\n>\n> a great book, BTW.  Everyone who thinks they know what they are doing when\n> they write C++ should read this book!  They will realize that they don't\n> know Jack [image: Roll Eyes]\n>\n> Why weren't these and all the other examples of amateur, i.e.,\n> non-professional, software fixed way back in version 0.3.0 in 2010, before\n> any more releases were done?  And why were these and other sub-standard\n> coding practices continued and expanded in later releases, right up until\n> the present?\n>\n\nBack in 2010 most code was still being written by Satoshi so perhaps you\nshould ask him. Regardless, it's very common for professional codebases to\nrequire assertions be enabled. For example the entire Google C++ codebase\nuses always-on assertions that have side effects liberally: it's convenient\nand safe, when you have the guarantee the code will always run, and the\nperformance benefits of compiling out assertions are usually non-existent.\n\nSo for this reason I think Bitcoin Core currently will fail to build if\nassertions are disabled, and that seems OK to me.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/f6f1ec3a/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-04T10:12:29",
                "message_text_only": ">\n>\n>  assert() should have *no* side effects, that is the problem.\n>>\n>\nI'm pretty sure that all the side effects of assertions have been removed\nbefore 0.9.0.\n\nHowever, the assertion checks are extremely important to the proper sanity\nof the client and network, so IMHO it's fair to still require building with\nthem enabled.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/49578ca3/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-04T10:15:04",
                "message_text_only": "On Wed, Jun 4, 2014 at 2:51 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> Hi Ron,\n>\n> FYI your mail is being spamfoldered due to Yahoo's DMARC policy and the\n> brokenness of the SF.net mailing list software. I would not expect to get\n> replies reliably whilst this is the case. I think we should move away from\n> SF.net for hosting mailing lists personally, because it's this list that's\n> at fault not Yahoo, but until then you may wish to send to the list with a\n> different email address.\n>\n> As to your question,\n>\n>  assert() should have *no* side effects, that is the problem.\n>>\n>> See\n>>\n>> http://books.google.com/books?id=L5ZbzVnpkXAC&pg=PA72&lpg=PA72&dq=Gotcha+%2328+Side+Effects&source=bl&ots=Rn15TlPmje&sig=tymHqta0aSANwaM2GaXC-1Di_tk&hl=en&sa=X&ei=uVKNU47fCcvTsAT6goHIBA&ved=0CCAQ6AEwAA#v=onepage&q=Gotcha%20%2328%20Side%20Effects&f=false\n>>\n>> a great book, BTW.  Everyone who thinks they know what they are doing\n>> when they write C++ should read this book!  They will realize that they\n>> don't know Jack [image: Roll Eyes]\n>>\n>> Why weren't these and all the other examples of amateur, i.e.,\n>> non-professional, software fixed way back in version 0.3.0 in 2010, before\n>> any more releases were done?  And why were these and other sub-standard\n>> coding practices continued and expanded in later releases, right up until\n>> the present?\n>>\n>\n> Back in 2010 most code was still being written by Satoshi so perhaps you\n> should ask him. Regardless, it's very common for professional codebases to\n> require assertions be enabled. For example the entire Google C++ codebase\n> uses always-on assertions that have side effects liberally: it's convenient\n> and safe, when you have the guarantee the code will always run, and the\n> performance benefits of compiling out assertions are usually non-existent.\n>\n> So for this reason I think Bitcoin Core currently will fail to build if\n> assertions are disabled, and that seems OK to me.\n>\n\nAs a matter of procedure we do not use assertions with side effects\u2014 the\ncodebase did at one point, but have cleaned them up.  In an abundance of\ncaution we also made it refuse to compile without assertions enabled: A\ndecision who's wisdom was clearly demonstrated when not long after, some\nadditional side-effect having assert was contributed. In the real world\nerrors happen here and there, and making robust software involves defense\nin depth.\n\nConsidering the normal criticality of the software it should always be with\nthe assertions. Without them is an untested configuration.  It would\nprobably be superior to use our own assertion macros (for one, they can\ngive some better reporting\u2026) that don't have the baggage ordinary\nassertions have, but as a the codebase is a production thing, making larger\nchanges all at once to satisfy aesthetics would be unwise... simply\nrefusing to compile in that untested, unsupported configuration is prudent,\nfor the time being.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/6b1862c6/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-04T10:20:43",
                "message_text_only": ">\n> As a matter of procedure we do not use assertions with side effects\u2014 the\n> codebase did at one point, but have cleaned them up.  In an abundance of\n> caution we also made it refuse to compile without assertions enabled: A\n> decision who's wisdom was clearly demonstrated when not long after, some\n> additional side-effect having assert was contributed. In the real world\n> errors happen here and there, and making robust software involves defense\n> in depth.\n>\n\nI think this class of errors could be removed entirely by just saying it's\nOK for assertions to have side effects and requiring them to be enabled, as\nis currently done.\n\nThe glog library:\n\nhttp://google-glog.googlecode.com/svn/trunk/doc/glog.html\n\nprovides CHECK macros that print stack traces when they fail. Using them\nwould also be good.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/e90f6937/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-04T10:31:24",
                "message_text_only": "On Wed, Jun 4, 2014 at 3:20 AM, Mike Hearn <mike at plan99.net> wrote:\n>> As a matter of procedure we do not use assertions with side effects\u2014 the\n>> codebase did at one point, but have cleaned them up.  In an abundance of\n>> caution we also made it refuse to compile without assertions enabled: A\n>> decision who's wisdom was clearly demonstrated when not long after, some\n>> additional side-effect having assert was contributed. In the real world\n>> errors happen here and there, and making robust software involves defense in\n>> depth.\n>\n>\n> I think this class of errors could be removed entirely by just saying it's\n> OK for assertions to have side effects and requiring them to be enabled, as\n> is currently done.\n>\n> The glog library:\n>\n> http://google-glog.googlecode.com/svn/trunk/doc/glog.html\n>\n> provides CHECK macros that print stack traces when they fail. Using them\n> would also be good.\n\nYes... it takes only about 10 lines of code to have a nicer assert\nthan the posix one, all my own software does... and with the noreturn\nattribute on the failure path it behaves the same for most static\nanalysis tools as a regular assert does. I would have just dropped one\nin, but an IFDEF seemed more prudent at the time."
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-04T12:15:08",
                "message_text_only": "Yes, check macros like that can be useful.\n\nI like the kernel's policy, which parallels our direction:\n1) Enable and use lightweight assertions for most users.\n2) No assertions with side effects\n\nIf you want to compile them out, that's fine, but they should always\nbe present in production software.\n\n\n\nOn Wed, Jun 4, 2014 at 6:20 AM, Mike Hearn <mike at plan99.net> wrote:\n>> As a matter of procedure we do not use assertions with side effects\u2014 the\n>> codebase did at one point, but have cleaned them up.  In an abundance of\n>> caution we also made it refuse to compile without assertions enabled: A\n>> decision who's wisdom was clearly demonstrated when not long after, some\n>> additional side-effect having assert was contributed. In the real world\n>> errors happen here and there, and making robust software involves defense in\n>> depth.\n>\n>\n> I think this class of errors could be removed entirely by just saying it's\n> OK for assertions to have side effects and requiring them to be enabled, as\n> is currently done.\n>\n> The glog library:\n>\n> http://google-glog.googlecode.com/svn/trunk/doc/glog.html\n>\n> provides CHECK macros that print stack traces when they fail. Using them\n> would also be good.\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Jannis Froese",
                "date": "2014-06-04T10:42:37",
                "message_text_only": "There are reasons to have assertions enabled by default in software like\nBitcoin Core, where incorrect behaviour can be costly. But this comes at\na prize: our assertions have to satisfy certain performance\nrequirements. It's no longer possible to do expensive, redundant checks\nin performance critical code, which is one of the main advantages of\nasserts. Imho, asserts are not intended for small range checks etc, but\nare meant for checks that a hash hasn't changed, that a tree structure\nis still a tree, that data is still sorted, or that data structures are\nin sync.\n\nI think most concerns about the current use of asserts would be resolved\nif the currently used asserts would be changed to a nicer definition\nwhich is independent of NDEBUG, and a second class of debugging asserts\nwould be introduced, which is exclusively for expensive, redundant\nchecks and is disabled by NDEBUG.\n\n\n\nAm 2014-06-04 12:15, schrieb Gregory Maxwell:\n> On Wed, Jun 4, 2014 at 2:51 AM, Mike Hearn <mike at plan99.net\n> <mailto:mike at plan99.net>> wrote:\n>\n>     Hi Ron,\n>\n>     FYI your mail is being spamfoldered due to Yahoo's DMARC policy\n>     and the brokenness of the SF.net mailing list software. I would\n>     not expect to get replies reliably whilst this is the case. I\n>     think we should move away from SF.net for hosting mailing lists\n>     personally, because it's this list that's at fault not Yahoo, but\n>     until then you may wish to send to the list with a different email\n>     address.\n>\n>     As to your question,\n>\n>         assert() should have *no* side effects, that is the problem.\n>\n>         See\n>         http://books.google.com/books?id=L5ZbzVnpkXAC&pg=PA72&lpg=PA72&dq=Gotcha+%2328+Side+Effects&source=bl&ots=Rn15TlPmje&sig=tymHqta0aSANwaM2GaXC-1Di_tk&hl=en&sa=X&ei=uVKNU47fCcvTsAT6goHIBA&ved=0CCAQ6AEwAA#v=onepage&q=Gotcha%20%2328%20Side%20Effects&f=false\n>\n>         a great book, BTW.  Everyone who thinks they know what they\n>         are doing when they write C++ should read this book!  They\n>         will realize that they don't know Jack Roll Eyes\n>\n>         Why weren't these and all the other examples of amateur, i.e.,\n>         non-professional, software fixed way back in version 0.3.0 in\n>         2010, before any more releases were done?  And why were these\n>         and other sub-standard coding practices continued and expanded\n>         in later releases, right up until the present?\n>\n>\n>     Back in 2010 most code was still being written by Satoshi so\n>     perhaps you should ask him. Regardless, it's very common for\n>     professional codebases to require assertions be enabled. For\n>     example the entire Google C++ codebase uses always-on assertions\n>     that have side effects liberally: it's convenient and safe, when\n>     you have the guarantee the code will always run, and the\n>     performance benefits of compiling out assertions are usually\n>     non-existent.\n>\n>     So for this reason I think Bitcoin Core currently will fail to\n>     build if assertions are disabled, and that seems OK to me.\n>\n>\n> As a matter of procedure we do not use assertions with side effects---\n> the codebase did at one point, but have cleaned them up.  In an\n> abundance of caution we also made it refuse to compile without\n> assertions enabled: A decision who's wisdom was clearly demonstrated\n> when not long after, some additional side-effect having assert was\n> contributed. In the real world errors happen here and there, and\n> making robust software involves defense in depth.\n>\n> Considering the normal criticality of the software it should always be\n> with the assertions. Without them is an untested configuration.  It\n> would probably be superior to use our own assertion macros (for one,\n> they can give some better reporting...) that don't have the baggage\n> ordinary assertions have, but as a the codebase is a production thing,\n> making larger changes all at once to satisfy aesthetics would be\n> unwise... simply refusing to compile in that untested, unsupported\n> configuration is prudent, for the time being.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their \n> applications. Written by three acclaimed leaders in the field, \n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/602a213b/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-04T10:51:15",
                "message_text_only": "Currently expensive checks are guarded with command line flags. It'd be\nnice if there could be one unified command line flag -expensivechecks that\nsubsumes -checkmempool and so on.\n\n\nOn Wed, Jun 4, 2014 at 6:42 PM, Jannis Froese <s9jafroe at stud.uni-saarland.de\n> wrote:\n\n>  There are reasons to have assertions enabled by default in software like\n> Bitcoin Core, where incorrect behaviour can be costly. But this comes at a\n> prize: our assertions have to satisfy certain performance requirements.\n> It's no longer possible to do expensive, redundant checks in performance\n> critical code, which is one of the main advantages of asserts. Imho,\n> asserts are not intended for small range checks etc, but are meant for\n> checks that a hash hasn't changed, that a tree structure is still a tree,\n> that data is still sorted, or that data structures are in sync.\n>\n> I think most concerns about the current use of asserts would be resolved\n> if the currently used asserts would be changed to a nicer definition which\n> is independent of NDEBUG, and a second class of debugging asserts would be\n> introduced, which is exclusively for expensive, redundant checks and is\n> disabled by NDEBUG.\n>\n>\n>\n> Am 2014-06-04 12:15, schrieb Gregory Maxwell:\n>\n> On Wed, Jun 4, 2014 at 2:51 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n>> Hi Ron,\n>>\n>>  FYI your mail is being spamfoldered due to Yahoo's DMARC policy and the\n>> brokenness of the SF.net mailing list software. I would not expect to get\n>> replies reliably whilst this is the case. I think we should move away from\n>> SF.net for hosting mailing lists personally, because it's this list that's\n>> at fault not Yahoo, but until then you may wish to send to the list with a\n>> different email address.\n>>\n>>  As to your question,\n>>\n>>     assert() should have *no* side effects, that is the problem.\n>>>\n>>> See\n>>>\n>>> http://books.google.com/books?id=L5ZbzVnpkXAC&pg=PA72&lpg=PA72&dq=Gotcha+%2328+Side+Effects&source=bl&ots=Rn15TlPmje&sig=tymHqta0aSANwaM2GaXC-1Di_tk&hl=en&sa=X&ei=uVKNU47fCcvTsAT6goHIBA&ved=0CCAQ6AEwAA#v=onepage&q=Gotcha%20%2328%20Side%20Effects&f=false\n>>>\n>>> a great book, BTW.  Everyone who thinks they know what they are doing\n>>> when they write C++ should read this book!  They will realize that they\n>>> don't know Jack [image: Roll Eyes]\n>>>\n>>>  Why weren't these and all the other examples of amateur, i.e.,\n>>> non-professional, software fixed way back in version 0.3.0 in 2010, before\n>>> any more releases were done?  And why were these and other sub-standard\n>>> coding practices continued and expanded in later releases, right up until\n>>> the present?\n>>>\n>>\n>>  Back in 2010 most code was still being written by Satoshi so perhaps\n>> you should ask him. Regardless, it's very common for professional codebases\n>> to require assertions be enabled. For example the entire Google C++\n>> codebase uses always-on assertions that have side effects liberally: it's\n>> convenient and safe, when you have the guarantee the code will always run,\n>> and the performance benefits of compiling out assertions are usually\n>> non-existent.\n>>\n>>  So for this reason I think Bitcoin Core currently will fail to build if\n>> assertions are disabled, and that seems OK to me.\n>>\n>\n>  As a matter of procedure we do not use assertions with side effects\u2014 the\n> codebase did at one point, but have cleaned them up.  In an abundance of\n> caution we also made it refuse to compile without assertions enabled: A\n> decision who's wisdom was clearly demonstrated when not long after, some\n> additional side-effect having assert was contributed. In the real world\n> errors happen here and there, and making robust software involves defense\n> in depth.\n>\n>  Considering the normal criticality of the software it should always be\n> with the assertions. Without them is an untested configuration.  It would\n> probably be superior to use our own assertion macros (for one, they can\n> give some better reporting\u2026) that don't have the baggage ordinary\n> assertions have, but as a the codebase is a production thing, making larger\n> changes all at once to satisfy aesthetics would be unwise... simply\n> refusing to compile in that untested, unsupported configuration is prudent,\n> for the time being.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!http://p.sf.net/sfu/NeoTech\n>\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/0547c1d3/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-04T12:13:15",
                "message_text_only": "On Wed, Jun 4, 2014 at 12:42 PM, Jannis Froese <\ns9jafroe at stud.uni-saarland.de> wrote:\n\n>  I think most concerns about the current use of asserts would be resolved\n> if the currently used asserts would be changed to a nicer definition which\n> is independent of NDEBUG, and a second class of debugging asserts would be\n> introduced, which is exclusively for expensive, redundant checks and is\n> disabled by NDEBUG.\n>\n\nSounds good to me.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/cc5f8d4e/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-06T08:29:13",
                "message_text_only": "On Wed, Jun 4, 2014 at 12:42 PM, Jannis Froese <\ns9jafroe at stud.uni-saarland.de> wrote:\n\nI think most concerns about the current use of asserts would be resolved if\n> the currently used asserts would be changed to a nicer definition which is\n> independent of NDEBUG, and a second class of debugging asserts would be\n> introduced, which is exclusively for expensive, redundant checks and is\n> disabled by NDEBUG.\n>\n\nAlso, most assertion errors that happen to people running Bitcoin Core are\nnot caused by software bugs but database corruption errors (usually due to\nunclean shutdown).\n\nFor example in case we detect missing/truncated block files or UTXO db\nconsistency we should, instead of raising an assertion error, propose a\n-reindex - see also https://github.com/bitcoin/bitcoin/issues/2202 .\n\nSo instead of using assertions we need a fatal error function for those\nproblems which are probably recoverable in a certain specific way. In\nprinciple starting a reindex wouldn't even need to take down the entire\nprocess (though that's easier for implementation due to cleanup and\nassumptions made).\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/ffca619d/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-06-06T08:40:20",
                "message_text_only": "On Fri, Jun 6, 2014 at 10:29 AM, Wladimir <laanwj at gmail.com> wrote:\n> On Wed, Jun 4, 2014 at 12:42 PM, Jannis Froese\n> <s9jafroe at stud.uni-saarland.de> wrote:\n>\n>> I think most concerns about the current use of asserts would be resolved\n>> if the currently used asserts would be changed to a nicer definition which\n>> is independent of NDEBUG, and a second class of debugging asserts would be\n>> introduced, which is exclusively for expensive, redundant checks and is\n>> disabled by NDEBUG.\n\nThere are a few examples of things that would classify as\nexpensive/redundant checks:\n* addrman consistency checks (only enabled with -DDEBUG_ADDRMAN).\n* mempool consistency checks (only enabled with -checkmempool).\n* deadlock detection (only enabled with -DDEBUG_LOCKORDER).\n\nI'm not sure all of these make sense to put under a single runtime\nflag. For example, addrman consistency is unlikely to be affected\nunless you're working on addrman code, and is pretty expensive.\n\nStill, I do like the idea of optional consistency checks, that help\nguarantee the software always has a consistency state.\n\n-- \nPieter"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-07T00:57:04",
                "message_text_only": "Speaking very generally, the Linux kernel wisdom on this tends to be,\n\n* Compile in as many cheap, compiler-predictable asserts as possible\ninto the production runtime.\n* Debug builds are of limited value.  Users do not recompile software,\njust to provide better bug reports/diagnostics.\n* Make it as easy as possible for users to send reports that are\nuseful to programmers.\n* Expensive diagnostics are fine. Compile in, but disable by default\nat runtime (and make sure these features, when turned off, do not slow\ndown the system).\n* Make sure the assert/dump provides a high level of diagnostics.\nStack trace of each thread + multi-threaded core dump are a good\nstart.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "# error \"Bitcoin cannot be compiled without assertions.\" <<<<NOT",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Wladimir",
                "Mike Hearn",
                "Jannis Froese",
                "Gregory Maxwell",
                "Pieter Wuille",
                "Ron"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 25916
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Core 0.9.2 release candidate 1 is available",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-04T06:37:52",
                "message_text_only": "Bitcoin Core version 0.9.2rc1 is now available from:\n\n  https://bitcoin.org/bin/0.9.2/test\n\nThis is a release candidate for a new minor version release, bringing\nmostly bug fixes and some minor improvements.\nRelease candidates are wide-scale testing releases, so use with care.\nNon-technical users may want to wait until 0.9.2 final.\n\nPlease report bugs using the issue tracker at github:\n\n  https://github.com/bitcoin/bitcoin/issues\n\nUpgrading and downgrading\n==========================\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\nbitcoind/bitcoin-qt (on Linux).\n\nIf you are upgrading from version 0.7.2 or earlier, the first time you run\n0.9.0 your blockchain files will be re-indexed, which will take anywhere from\n30 minutes to several hours, depending on the speed of your machine.\n\nDowngrading warnings\n--------------------\n\nThe 'chainstate' for this release is not always compatible with previous\nreleases, so if you run 0.9.x and then decide to switch back to a\n0.8.x release you might get a blockchain validation error when starting the\nold release (due to 'pruned outputs' being omitted from the index of\nunspent transaction outputs).\n\nRunning the old release with the -reindex option will rebuild the chainstate\ndata structures and correct the problem.\n\nAlso, the first time you run a 0.8.x release on a 0.9 wallet it will rescan\nthe blockchain for missing spent coins, which will take a long time (tens\nof minutes on a typical machine).\n\nImportant changes\n==================\n\nGitian OSX build\n-----------------\n\nThe deterministic build system that was already used for Windows and Linux\nbuilds is now used for OSX as well. Although the resulting executables have\nbeen tested quite a bit, there could be possible regressions. Be sure to report\nthese on the Github bug tracker mentioned above.\n\nCompatibility of Linux build\n-----------------------------\n\nFor Linux we now build against Qt 4.6, and filter the symbols for\nlibstdc++ and glibc.\nThis brings back compatibility with\n\n- Debian 6+ / Tails\n- Ubuntu 10.04\n- CentOS 6.5\n\n0.9.2 Release notes\n=======================\n\nRPC:\n- Add `getwalletinfo`, `getblockchaininfo` and `getnetworkinfo` calls\n(will replace hodge-podge `getinfo` at some point)\n- Add a `relayfee` field to `getnetworkinfo`\n- Fix RPC related shutdown hangs and leaks\n- Always show syncnode in `getpeerinfo`\n- `sendrawtransaction`: report the reject code and reason, and make it\npossible to re-send transactions that are already in the mempool\n- `getmininginfo` show right genproclimit\n\nCommand-line options:\n- Fix `-printblocktree` output\n- Show error message if ReadConfigFile fails\n\nBlock-chain handling and storage:\n- Fix for GetBlockValue() after block 13,440,000 (BIP42)\n- Upgrade leveldb to 1.17\n\nProtocol and network code:\n- Per-peer block download tracking and stalled download detection\n- Add new DNS seed from bitnodes.io\n- Prevent socket leak in ThreadSocketHandler and correct some proxy\nrelated socket leaks\n\nWallet:\n- Make GetAvailableCredit run GetHash() only once per transaction\n(performance improvement)\n- Lower paytxfee warning threshold from 0.25 BTC to 0.01 BTC\n- Fix importwallet nTimeFirstKey (trigger necessary rescans)\n- Log BerkeleyDB version at startup\n\nBuild system:\n- Add OSX build descriptors to gitian\n- Fix explicit --disable-qt-dbus\n- Don't require db_cxx.h when compiling with wallet disabled and GUI enabled\n- Improve missing boost error reporting\n- Upgrade miniupnpc version to 1.9\n- gitian-linux: --enable-glibc-back-compat for binary compatibility\nwith old distributions\n- gitian: don't export any symbols from executable\n- gitian: build against Qt 4.6\n- devtools: add script to check symbols from Linux gitian executables\n- Remove build-time no-IPv6 setting\n\nGUI:\n- Fix various coin control visual issues\n- Show number of in/out connections in debug console\n- Show weeks as well as years behind for long timespans behind\n- Enable and disable the Show and Remove buttons for requested\npayments history based on whether any entry is selected.\n- Show also value for options overridden on command line in options dialog\n- Fill in label from address book also for URIs\n- Fixes feel when resizing the last column on tables (issue #2862)\n- Fix ESC in disablewallet mode\n- Add expert section to wallet tab in optionsdialog\n- Do proper boost::path conversion (fixes unicode in datadir)\n- Only override -datadir if different from the default (fixes -datadir\nin config file)\n- Show rescan progress at start-up\n- Show importwallet progress\n- Get required locks upfront in polling functions (avoids hanging on locks)\n- Catch Windows shutdown events while client is running\n- Optionally add third party links to transaction context menu\n- Check for !pixmap() before trying to export QR code (avoids crashes\nwhen no QR code could be generated)\n- Fix \"Start bitcoin on system login\"\n\nMiscellaneous:\n\n- Replace non-threadsafe C functions (gmtime, strerror and setlocale)\n- Add missing cs_main and wallet locks\n- Avoid exception at startup when system locale not recognized\n- Changed bitrpc.py's raw_input to getpass for passwords to conceal\ncharacters during command line input\n- devtools: add a script to fetch and postprocess translations\n\nCredits\n--------\n\nThanks to everyone who contributed to this release:\n\n- Addy Yeow\n- Altoidnerd\n- Andrea D'Amore\n- Andreas Schildbach\n- Bardi Harborow\n- Brandon Dahler\n- Bryan Bishop\n- Chris Beams\n- Christian von Roques\n- Cory Fields\n- Cozz Lovan\n- daniel\n- Daniel Newton\n- David A. Harding\n- ditto-b\n- duanemoody\n- Eric S. Bullington\n- Fabian Raetz\n- Gavin Andresen\n- Gregory Maxwell\n- gubatron\n- Haakon Nilsen\n- harry\n- Hector Jusforgues\n- Isidoro Ghezzi\n- Jeff Garzik\n- Johnathan Corgan\n- jtimon\n- Kamil Domanski\n- langerhans\n- Luke Dashjr\n- Manuel Araoz\n- Mark Friedenbach\n- Matt Corallo\n- Matthew Bogosian\n- Meeh\n- Michael Ford\n- Michagogo\n- Mikael Wikman\n- Mike Hearn\n- olalonde\n- paveljanik\n- peryaudo\n- Philip Kaufmann\n- philsong\n- Pieter Wuille\n- R E Broadley\n- richierichrawr\n- Rune K. Svendsen\n- rxl\n- shshshsh\n- Simon de la Rouviere\n- Stuart Cardall\n- super3\n- Telepatheic\n- Thomas Zander\n- Torstein Huseb\u00c3\u00b8\n- Warren Togami\n- Wladimir J. van der Laan\n- Yoichi Hirai"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-04T08:10:00",
                "message_text_only": "On Wed, Jun 4, 2014 at 8:37 AM, Wladimir <laanwj at gmail.com> wrote:\n> Bitcoin Core version 0.9.2rc1 is now available from:\n>\n>   https://bitcoin.org/bin/0.9.2/test\n>\n> This is a release candidate for a new minor version release, bringing\n> mostly bug fixes and some minor improvements.\n\nAlmost forgot to mention: new translations from Transifex,\n\nMuch thanks to everyone who submitted translations there as well (I\ndon't have a list handy right now)!\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.9.2 release candidate 1 is available",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6855
        }
    },
    {
        "title": "[Bitcoin-development] Timelock: time-release encryption incentivised by Bitcoins",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-06-04T12:54:50",
                "message_text_only": "Decided to take a break yesterday and write some code...\n\n\nTimelock\n========\n\nCreate a secret key that can be decrypted in a known amount of time\nusing parallel-serial hash chains. The creator can compute the timelock\nin parallel, taking advantage of the large amount of cheap parallelism\navailable today, while others are forced to compute it serially,\nconstrained by the lack of scalar performance growth.\n\nThe chains are constructed such that Bitcoin addresses can be derived\nfrom them and bounties placed, incentivizing third-parties to crack the\ntimelocks. This gives us a valuable chance to incentivize others to push\nthe envelope of scalar performance - important knowledge if we are going\nto have any hope of knowing how soon our timelocked secrets will\nactually be revealed! The Bitcoin secret keys and addresses are\nconstructed from the chains as follows:\n\n    iv -> <chain> -> privkey -> pubkey -> secret -> hashed_secret\n\n    secret        = SHA256(pubkey)\n    hashed_secret = RIPEMD160(secret)\n\nUnlocking a given chain starting from the initialization vector gives\nthe person doing the work the private key, giving them an exclusive\nopportunity to collect the bounty. Collecting that bounty forces them to\nreveal the pubkey, from which the secret is derived. The hashed_secret\nis then just a standard Bitcoin address, letting everyone see how large\nthe bounty is for unlocking the timelock.\n\nOnly a single algorithm - SHA256 - is supported by design: timelock\nencryption works best if we're all on an even playing field.\n\nSourcecode: https://github.com/petertodd/timelock\n\nCredit goes to Amir Taaki for helping develop the idea.\n\n\nTo make things interesting I've made a ~256 hour timelock with 32\nchains, 8 hours per chain. The addresses associated are as follows:\n\n1ERvMr5J8FETF7zj4QM98u8ZANaL1o9XGZ\n18h7LwKpd9c6u8zJka3vMCASa8BfbiZFd4\n1DBJDp57QmbigLEbUsFeqJT3mkArGzH3gv\n1C1d6Tj7mZADurfj5yJ64p5BeRstquk7pu\n1FsH58jnq5Kc6D7hb7vmUhjh8fwnijiWss\n1PDwPYStrrkKpGtV2zX71XCDYL3E2g3KM7\n1BF6oYLeTG7WxNWJjC8p4SHz62q7vgZhXX\n1DxFiHr9ehVvi8JR2Cc5pcD4DEURUeFFda\n1NKg3buX5BzhYgSY6Yvws9kMqZ6F1xnneD\n1Kptov9sgDqQcavz1rVsuQvfi8PcQcL4rc\n1P9k1HEfe3Z8LaiFejqsuDLjWXPZk1coDL\n1Mw25mU89Wp2b9zyMCSnjAVQ7x4AVWx3sf\n1B8gdbd1StpVnV99Few1ae1XXfKH6iry1D\n13bisx8T42CzmFA2oAm1evEytcijrHJ2iR\n1DyR6aNSbrJCzwqdeo9UN5obGR9L73Y2sa\n1Fx7j3gU3q7bQdoni2zZhGQx7BnLt8xNeK\n19q541m17opVcAxwisem7ak7YPuSpdS3Uj\n1DYWzBpLBDd7fpta2JYLf7QZ7nAYiZiamR\n13sZYBMdyzffwvCkzhGTu49pCGGR5C5B9v\n1DFSjViJLTNhNj5wvsqRwoqPyR9UTAzLgW\n13Zi9eawpkzZwRC8RgHJausQmUS4ECBzho\n1BCQ5GVkAEzNYZ5WroAwXSspgpYfhQrojd\n1K1gbE7qGLwbJDEoRyrCGxCsgJ4mHcFKwP\n14Z4EawE1Kd3HRut43vWjgYUWYR3ZV5i2p\n1NZTFVXVzKXvPMsFKZfkhZCBcbzqm7cGCj\n1GFBBahQC5DzpLuJc6X1yVvvSKP2kCpUGf\n184PkQFdzhPR3TjoCxddsNK7sr3DVVhJ45\n14SLK5fXWdajoQZ2AX5WmAGbvRtLpdTgMq\n1LagrzYykb8w4NveKrw2SDcpKMezwxX72Z\n16XdtV2U3ksdhKkByRpiq3VN61aB62Ndgh\n1Mu1SaUBu7aV4DHzEc4hxcgGzaYWdvuaAh\n1EJWWxwZckP9eLS2VzgbUwqzxFDZKZcF9b\n\nI've funded them with 10mBTC each, 320mBTC total. The full timelock\ndefinition is as follows:\n\n{\n    \"chains\": [\n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": null, \n            \"hashed_secret\": \"1ERvMr5J8FETF7zj4QM98u8ZANaL1o9XGZ\", \n            \"i\": 0, \n            \"iv\": \"353b124909ec8774325d3f2f6b0a01c839e79e3ce687ee6e893310368afdf336\", \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"495c6092c9004dc23c2deefb1db1deba88f8895a319f5d9f7ce8a53b2a9ecfe9\", \n            \"hashed_secret\": \"18h7LwKpd9c6u8zJka3vMCASa8BfbiZFd4\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"8cbdf731374a71f22d59251890997ea001c2efa6e9c0bf808700c3d432ccf269\", \n            \"hashed_secret\": \"1DBJDp57QmbigLEbUsFeqJT3mkArGzH3gv\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"bc4d75fa5ec8f28e121cd73806ce058e82036577130cffb3bd596f2aa59b2a7f\", \n            \"hashed_secret\": \"1C1d6Tj7mZADurfj5yJ64p5BeRstquk7pu\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"80c622521c7aed318dac2b3c7d929e4e504d3c60650009b1abc0bae18fff979b\", \n            \"hashed_secret\": \"1FsH58jnq5Kc6D7hb7vmUhjh8fwnijiWss\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"1ba76f9a694f987e1758dbc65cf104984dbedfae01b134fe09135b64cb8c4034\", \n            \"hashed_secret\": \"1PDwPYStrrkKpGtV2zX71XCDYL3E2g3KM7\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"1cedd5a71a96f439c20e9f4f5957b8c159b23d472063fa07a05121333888cdf5\", \n            \"hashed_secret\": \"1BF6oYLeTG7WxNWJjC8p4SHz62q7vgZhXX\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"30d88e0fd113ce38d22a210012914e5331bd89dda408d85dfa9e9bfcbd40d8eb\", \n            \"hashed_secret\": \"1DxFiHr9ehVvi8JR2Cc5pcD4DEURUeFFda\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"5e654bfc1534b03e45548b59d407518b5915c3ae51c266e374ea8a368f72433c\", \n            \"hashed_secret\": \"1NKg3buX5BzhYgSY6Yvws9kMqZ6F1xnneD\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"10095f9aa85ceb221d00975a1db66fcffcae516c1d3d5dee66995567522f68ab\", \n            \"hashed_secret\": \"1Kptov9sgDqQcavz1rVsuQvfi8PcQcL4rc\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"6ecfd5282c650b1ebabbf39f5e72dd0e8e9724456e6b357e83c53a9a144b49eb\", \n            \"hashed_secret\": \"1P9k1HEfe3Z8LaiFejqsuDLjWXPZk1coDL\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"197796e5010f189165c2010cd7cfb0f3b933670276231292555b5540765bb6fa\", \n            \"hashed_secret\": \"1Mw25mU89Wp2b9zyMCSnjAVQ7x4AVWx3sf\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"58fe436839724b03f3ffd41e864d5dc030de2eeb5a3c4df19ed65ef9abe21cc2\", \n            \"hashed_secret\": \"1B8gdbd1StpVnV99Few1ae1XXfKH6iry1D\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"d2af3dd9cdfbb081149212ead19cbd85f6dcc31177de586d1c6dd6139c16141f\", \n            \"hashed_secret\": \"13bisx8T42CzmFA2oAm1evEytcijrHJ2iR\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"512f20d2a4f342cb635d5c73a0c3ad30272bdd84d73f2bb0f2849d17557f162f\", \n            \"hashed_secret\": \"1DyR6aNSbrJCzwqdeo9UN5obGR9L73Y2sa\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"75cb98d4abfd84318347220547f017f8285333dd55b41622c9220ece49e227e2\", \n            \"hashed_secret\": \"1Fx7j3gU3q7bQdoni2zZhGQx7BnLt8xNeK\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"d1d264674ba9b1c4baba189809a0d37ca4b8f402f91a145303907c3730ff890c\", \n            \"hashed_secret\": \"19q541m17opVcAxwisem7ak7YPuSpdS3Uj\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"31f2df6ae00e118f72063cb640c150bad5c0c015d12533826439d45f593ebb89\", \n            \"hashed_secret\": \"1DYWzBpLBDd7fpta2JYLf7QZ7nAYiZiamR\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"8113452a165b673957f6d707f19d6b407683499ef6a08e03ba35ca79306b8e3b\", \n            \"hashed_secret\": \"13sZYBMdyzffwvCkzhGTu49pCGGR5C5B9v\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"c0b8e246cd4a2a1abe760b1d2763931c8e04960e6a2e69f0f6723dd4892413ae\", \n            \"hashed_secret\": \"1DFSjViJLTNhNj5wvsqRwoqPyR9UTAzLgW\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"c4d0bc902093f21e1745193345909e080dee5b4cc410108a637ded75fcdc9e01\", \n            \"hashed_secret\": \"13Zi9eawpkzZwRC8RgHJausQmUS4ECBzho\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"588d778adb3180a9783781a175171790d8099d7942190fa853b235262c074a99\", \n            \"hashed_secret\": \"1BCQ5GVkAEzNYZ5WroAwXSspgpYfhQrojd\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"643b3afe4b674b44fee943507559d6218c5f53671ab01b09c8aaafa65f9f2e37\", \n            \"hashed_secret\": \"1K1gbE7qGLwbJDEoRyrCGxCsgJ4mHcFKwP\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"62e65d48eb215734c00165130027a6cb04842d95cc570a278968f7070d41936f\", \n            \"hashed_secret\": \"14Z4EawE1Kd3HRut43vWjgYUWYR3ZV5i2p\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"f89566d49c4765522cd382c16589486b90702cc99caff6801a4e8b504694ab6b\", \n            \"hashed_secret\": \"1NZTFVXVzKXvPMsFKZfkhZCBcbzqm7cGCj\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"3d9acd9785f12890b88f30576d81d583ba0ada2d98c9a17f6cc79a0ed1b7e027\", \n            \"hashed_secret\": \"1GFBBahQC5DzpLuJc6X1yVvvSKP2kCpUGf\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"4d886799cfef728add5c14b27e780f96511b78060d86d3b77b0d0ed5130f6f02\", \n            \"hashed_secret\": \"184PkQFdzhPR3TjoCxddsNK7sr3DVVhJ45\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"24b495c95129ca0062297b019af3684b12303382e4282e032ba5fd2ab805b127\", \n            \"hashed_secret\": \"14SLK5fXWdajoQZ2AX5WmAGbvRtLpdTgMq\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"0eec24b55713a85a41c996904def8f8b5b61a9efa2491dacf63f7161a71a6514\", \n            \"hashed_secret\": \"1LagrzYykb8w4NveKrw2SDcpKMezwxX72Z\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"1b3ecc11b7f6cd80a5111b11a15fa2cb8b1c006041f8ad5b7c7316947de2e3fa\", \n            \"hashed_secret\": \"16XdtV2U3ksdhKkByRpiq3VN61aB62Ndgh\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"7fed7012e601fb9431d48c072d060c391b1985fd9717d51b12bbcb7e271f656f\", \n            \"hashed_secret\": \"1Mu1SaUBu7aV4DHzEc4hxcgGzaYWdvuaAh\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }, \n        {\n            \"algorithm\": \"sha256\", \n            \"encrypted_iv\": \"7f3a0c156be2c08714b9296999dddca8c178385e145aa3156ea00ffd742075f8\", \n            \"hashed_secret\": \"1EJWWxwZckP9eLS2VzgbUwqzxFDZKZcF9b\", \n            \"i\": 0, \n            \"iv\": null, \n            \"midstate\": null, \n            \"n\": 86400000000, \n            \"seckey\": null, \n            \"secret\": null\n        }\n    ], \n    \"version\": 1\n}\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000002d204cce4ee5e7976a0a485d658b4a15ebf31cdbce8a4915\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/eab31aed/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Timelock: time-release encryption incentivised by Bitcoins",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 15795
        }
    },
    {
        "title": "[Bitcoin-development] error \"Bitcoin cannot be compiled without assertions.\" <<<<NOT",
        "thread_messages": [
            {
                "author": "Ron",
                "date": "2014-06-04T19:13:45",
                "message_text_only": "________________________________________________________\n Message: 2\n Date: Wed, 4 Jun 2014 08:15:08 -0400\n From: Jeff Garzik <jgarzik at bitpay.com>\n Subject: Re: [Bitcoin-development] # error \"Bitcoin cannot\n be compiled\n \u00a0\u00a0\u00a0 without assertions.\" <<<<NOT\n To: Mike Hearn <mike at plan99.net>\n Cc: \"bitcoin-development at lists.sourceforge.net\"\n \u00a0\u00a0\u00a0 <bitcoin-development at lists.sourceforge.net>,\n Ron <rdwnj at yahoo.com>\n Message-ID:\n \u00a0\u00a0\u00a0\n <CAJHLa0PTTHfvd-1BR5s2k-4UW6V6qLEyAbF2YSRxOOSjtH9+_Q at mail.gmail.com>\n Content-Type: text/plain; charset=UTF-8\n \n Yes, check macros like that can be useful.\n \n I like the kernel's policy, which parallels our direction:\n 1) Enable and use lightweight assertions for most users.\n 2) No assertions with side effects\n \n If you want to compile them out, that's fine, but they\n should always\n be present in production software.\n _____________________________________________________\n\nI don't think many of you actually read what I said, and you went off on your own tangents.\n\nI said:\nthis commit and code with all side effects removed from the assertions.\nin Vol 37, Issue 4\n\nI intentionally left the gcc code alone.  Only the MSC code is assert \"fixed\".  I would have hoped that someone would have noticed and incorporated these changes into the gcc code.  Simply by removing the #ifdef _MSC_VER ... #else ...  #endif etc. etc.  \n\nDid I say I compiled them out? No!  Did anyone bother to look at my code or what I said?\n\nHere is an example from main.cpp  CTransaction::UpdateCoins(...\n-    // add outputs\n+    // add outputs      sure looks like an assert with side effects here!?\n+#ifdef _MSC_VER\n+    bool\n+        fTest = inputs.SetCoins(txhash, CCoins(*this, nHeight));\n+    #ifdef _DEBUG\n+        assert(fTest);\n+    #else\n+    if( !fTest )\n+        releaseModeAssertionfailure( __FILE__, __LINE__, __PRETTY_FUNCTION__ );\n+    #endif\n+#else\n     assert(inputs.SetCoins(txhash, CCoins(*this, nHeight)));\n+#endif\n\nNote that I do the test, and if debugging, I let it abort() the program if it fails.  Note that in release mode it calls a new function on failure, that I leave you to discover what it does.  I see that this assert has been \"fixed\" in 0.9.x, but I think my \"fix\" is better, since it allows release mode code to run better, if not identically.\n\nI changed every assert() in the bitcoind 086 sources to behave this way.  Since C++ is perniciously baroque, it is not clear if a side effect can or has occurred in the most innocuous of C++ statements. Is the example above side-effect free?\n\nHere is a piece of what I made my decision on:\nhttp://www.gnu.org/software/libc/manual/html_node/Consistency-Checking.html and the link to the book previously given.\n\nAlso, no one answered the question about bitcoin-qt, to whit, can or should it be compiled in RELEASE mode because of this?  Should it have always been compiled in DEBUG mode in the past too?\n\nRon"
            }
        ],
        "thread_summary": {
            "title": "error \"Bitcoin cannot be compiled without assertions.\" <<<<NOT",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Ron"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2909
        }
    },
    {
        "title": "[Bitcoin-development] Future Feature Proposal - getgist",
        "thread_messages": [
            {
                "author": "Richard Moore",
                "date": "2014-06-04T19:30:10",
                "message_text_only": "Bitcoin development team,\n\nI recently started implementing my own Python full-node, and had an idea, so I\u2019m prowling through BIP 001 for this proposal, which says to e-mail you kind folks to make sure the idea is original (enough) and that there aren\u2019t other existing means to accomplish what I was thinking. :)\n\nThe only way to grab all the headers seems to be to serially get one, then the next and so on, as you need the last hash of a headers() call to the next getheaders(). But we are on a peer-to-peer network, potentially able to getheaders() from many peers simultaneously, if we only knew the hash to look for.\n\nWhat I was thinking is something to the effect of a getgist() command, fully backward compatible (any node not understanding it, can silently ignore it\u2026 Otherwise version or services could be used to announce the capability, but that seems like a little overkill). The inputs to getgist() would be similar to getheaders(); version, hash_count, block_locator_hash, stop_hash and an additional field, segment_count. The response would be a normal headers() message, except, not sequential block headers\u2026 Rather they would be spaced out, preferably 2000-block-hash-aligned from the first block hash. So, for example, if you have a blockchain with 198,005 blocks, and you passed it the block locator of height 0 (the genesis block), and a segment_count of 25, you would expect (approximately, the actual algorithm needs to be figured out), the block hashes at the following 25 (segment_count) heights:\n\n1, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 72000, 80000, 88000, 96000, 104000, 112000, 120000, 128000, 136000, 144000, 152000, 160000, 168000, 176000, 184000, 192000\n\nWhich can now be spread across 25 different nodes, fetching the block headers (albeit, out of order, possibly increasing the complexity of the local block chain database) but vastly increasing the speed the whole blockchain can have all headers synced.\n\nI still need to perform some tests to see what type of speed gains there are, but I would suspect it should be segment_count times faster.\n\nExisting methods could be to use checkpoint-ish nodes or bootstrap data files, but these begin relying on semi-cetralizenesses.\n\nIdeas? Suggestions? Concerns? Prior it-ain\u2019t-gonna-works?\n\nThanks!\n\nRicMoo\n\n\n.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n\nRichard Moore ~ Founder\nGenetic Mistakes Software inc.\nphone: (778) 882-6125\nemail: ricmoo at geneticmistakes.com\nwww: http://GeneticMistakes.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140604/55a199b0/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-05T03:42:27",
                "message_text_only": "Why do you want to optimise this? getheaders is used by SPV clients not\nfull nodes. SPV clients like bitcoinj can and do simply ship with gist\nfiles in them, then getheaders from the last \"checkpoint\"   (I wish I\nhadn't reused terminology like that but this is what bitcoinj calls them).\n\nIn practice when I look at performance issues with current SPV clients,\ngetheaders speed is not on my radar.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140605/b277ec31/attachment.html>"
            },
            {
                "author": "Richard Moore",
                "date": "2014-06-05T17:43:38",
                "message_text_only": "I was considering names like getcheckpoints() to use the terminology that already seemed to be in place, but they were too long :)\n\nI have been using getheaders() in my thick client to quickly grab all the headers before downloading the full blocks since I can grab more at a time. Even with getblocks(), there is the case for a  getgist() call. Right now you call getblocks(), which can take some time to get the corresponding inv(), at which time you can then start the call to getdata() as well as the next call to getblocks().\n\nWith a gist, for example of segment_count 50, you could call getgist(), then with the response, you could request 50 getblocks() each with a block_locator of 1 hash from the gist (and optimally the stop_hash of the next hash in the gist) to 50 different peers, providing 25,000 (50 x 500) block hashes.\n\nCurrently:\n>>> getblocks()\n<<< inv()\n>>> getdata()\n<<< block(), block(), block(), \u2026 (x 500)\n\nSaturates one peer, while leaving the rest un-used. Step 1 and 2 can be repeated and dispatched to different peers, but there is still the latency between the two calls.\n\nGist:\n>>> getgist()\n<<< inv()\n>>> getblocks(), getblocks(), getblocks(), \u2026 (x segment_count, 1 per peer)\n<<< inv(), inv(), inv(), \u2026 (x segment_count, 1 per peer)\n>>> getdata(), getdata(), getdata(), \u2026 (x segment_count, 1 per peer)\n<<< block(), block(), block(), \u2026 (x (500 * segment_count), ie. 500 in per peer)\n\nEach peer can be saturated.\n\nI will try to run some experiments this weekend to get numbers as to whether there is actually any performance improvement using a gist, or whether the getdata(), block() latency ends up dominating the time anyways.\n\n\nRicMoo\n\n\nOn Jun 4, 2014, at 11:42 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> Why do you want to optimise this? getheaders is used by SPV clients not full nodes. SPV clients like bitcoinj can and do simply ship with gist files in them, then getheaders from the last \"checkpoint\"   (I wish I hadn't reused terminology like that but this is what bitcoinj calls them).\n> \n> In practice when I look at performance issues with current SPV clients, getheaders speed is not on my radar.\n\n.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n\nRichard Moore ~ Founder\nGenetic Mistakes Software inc.\nphone: (778) 882-6125\nemail: ricmoo at geneticmistakes.com\nwww: http://GeneticMistakes.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140605/a9500408/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-06-05T19:34:15",
                "message_text_only": "On Thu, Jun 5, 2014 at 7:43 PM, Richard Moore <me at ricmoo.com> wrote:\n> I was considering names like getcheckpoints() to use the terminology that\n> already seemed to be in place, but they were too long :)\n>\n> I have been using getheaders() in my thick client to quickly grab all the\n> headers before downloading the full blocks since I can grab more at a time.\n> Even with getblocks(), there is the case for a  getgist() call. Right now\n> you call getblocks(), which can take some time to get the corresponding\n> inv(), at which time you can then start the call to getdata() as well as the\n> next call to getblocks().\n>\n> With a gist, for example of segment_count 50, you could call getgist(), then\n> with the response, you could request 50 getblocks() each with a\n> block_locator of 1 hash from the gist (and optimally the stop_hash of the\n> next hash in the gist) to 50 different peers, providing 25,000 (50 x 500)\n> block hashes.\n\nI don't understand. If you're using getheaders(), there is no need to\nuse getblocks() anymore. You just do a getdata() immediately for the\nblock hashes you have the headers but not the transactions for.\n\nIn general, I think we should aim for as much verifiability as\npossible. Much of the reference client's design is built around doing\nas much validation on received data as soon as possible, to avoid\nbeing misled by a particular peer. Getheaders() provides this: you\nreceive a set of headers starting from a point you already know, in\norder, and can validate them syntactically and for proof-of-work\nimmediately. That allows building a very-hard-to-beat tree structure\nlocally already, at which point you can start requesting blocks along\nthe good branches of that tree immediately - potentially in parallel\nfrom multiple peers. In fact, that's the planned approach for the\nheaders-first synchronization.\n\nThe getgist() proposed here allows the peer to basically give you\nbullshit headers at the end, and you won't notice until you've\ndownloaded every single block (or at least every single header) up to\nthat point. That risks wasting time, bandwidth and diskspace,\ndepending on implementation.\n\nBased on earlier experimenting with my former experimental\nheadersfirst branch, it's quite possible to have 2 mostly independent\nsynchronization mechanisms going on; 1) asking and downloading headers\nfrom every peer, and validating them, and 2) asking and downloading\nblocks from multiple peers in parallel, for blocks corresponding to\nvalidated headers. Downloading the headers succeeds within minutes,\nand within seconds you have enough to start fetching blocks. After\nthat point, you can keep a \"download window\" full with outstanding\nblock requests, and as blocks go much slower than headers, the headers\nprocess never becomes a blocker for blocks to download.\n\nUnless we're talking about a system with billions of headers to\ndownload, I don't think this is a worthwhile optimization.\n\n-- \nPieter"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-05T14:28:04",
                "message_text_only": "The correct approach here is header hash-tree commitments which enable\ncompact (logarithmic) SPV proofs that elide nearly all intervening\nheaders since the last checkpoint. You could then query the hash tree\nfor references to any of the headers you actually need.\n\nSee this message for details:\n\nhttp://sourceforge.net/p/bitcoin/mailman/message/32111357/\n\nOn 06/04/2014 12:30 PM, Richard Moore wrote:\n> Bitcoin development team,\n> \n> I recently started implementing my own Python full-node, and had an\n> idea, so I\u2019m prowling through BIP 001 for this proposal, which says to\n> e-mail you kind folks to make sure the idea is original (enough) and\n> that there aren\u2019t other existing means to accomplish what I was thinking. :)\n> \n> The only way to grab all the headers seems to be to serially get one,\n> then the next and so on, as you need the last hash of a headers() call\n> to the next getheaders(). But we are on a peer-to-peer network,\n> potentially able to getheaders() from many peers simultaneously, if we\n> only knew the hash to look for.\n> \n> What I was thinking is something to the effect of a getgist() command,\n> fully backward compatible (any node not understanding it, can silently\n> ignore it\u2026 Otherwise version or services could be used to announce the\n> capability, but that seems like a little overkill). The inputs to\n> getgist() would be similar to getheaders(); version, hash_count,\n> block_locator_hash, stop_hash and an additional field, segment_count.\n> The response would be a normal headers() message, except, not sequential\n> block headers\u2026 Rather they would be spaced out, preferably\n> 2000-block-hash-aligned from the first block hash. So, for example, if\n> you have a blockchain with 198,005 blocks, and you passed it the block\n> locator of height 0 (the genesis block), and a segment_count of 25, you\n> would expect (approximately, the actual algorithm needs to be figured\n> out), the block hashes at the following 25 (segment_count) heights:\n> \n> 1, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 72000, 80000,\n> 88000, 96000, 104000, 112000, 120000, 128000, 136000, 144000, 152000,\n> 160000, 168000, 176000, 184000, 192000\n> \n> Which can now be spread across 25 different nodes, fetching the block\n> headers (albeit, out of order, possibly increasing the complexity of the\n> local block chain database) but vastly increasing the speed the whole\n> blockchain can have all headers synced.\n> \n> I still need to perform some tests to see what type of speed gains there\n> are, but I would suspect it should be segment_count times faster.\n> \n> Existing methods could be to use checkpoint-ish nodes or bootstrap data\n> files, but these begin relying on semi-cetralizenesses.\n> \n> Ideas? Suggestions? Concerns? Prior it-ain\u2019t-gonna-works?\n> \n> Thanks!\n> \n> RicMoo\n> \n> \n> .\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n> \n> Richard Moore ~ Founder\n> Genetic Mistakes Software inc.\n> phone: (778) 882-6125\n> email: ricmoo at geneticmistakes.com <mailto:ricmoo at geneticmistakes.com>\n> www: http://GeneticMistakes.com <http://GeneticMistakes.com/>\n> \n> \n> \n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their \n> applications. Written by three acclaimed leaders in the field, \n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "Future Feature Proposal - getgist",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Mike Hearn",
                "Richard Moore",
                "Pieter Wuille",
                "Mark Friedenbach"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 12406
        }
    },
    {
        "title": "[Bitcoin-development] Do not use github issues on BIPs repository",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-06T04:05:32",
                "message_text_only": "Hello,\n\nI see that people have been filing issues on the Bitcoin Improvement\nRequests repository, https://github.com/bitcoin/bips.\n\nThis is not how it is supposed to work -- BIP authors are not required\nto monitor the github issues, and it is not a good place to discuss in\nthe first place. If you have a remark about a BIP or want to discuss\nit please use this mailing list (preferably) or contact the authors\nsome other way.\n\nAfter discussion you can submit a pull request. Or if the change is\ntrivial, such as a typo, you can submit a pull immediately.\n\nFor this reason I intend to disable issues (not pull requests, of\ncourse) on the repository.\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Do not use github issues on BIPs repository",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 659
        }
    },
    {
        "title": "[Bitcoin-development] NODE_BLOOM service bit",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-06-06T08:19:33",
                "message_text_only": "BIP: https://github.com/petertodd/bips/blob/bip-node-bloom/bip-node-bloom.mediawiki\n\nPull-req: https://github.com/bitcoin/bitcoin/pull/2900\n\nPretty simple really: service bit NODE_BLOOM is defined to allow nodes\nto advertise to their peers that they support bloom filters. The network\nprotocol version number is also bumped. Recommended behavior for nodes\nthat do not support bloom is to simply disconnect peers who send a\nfilter* message anyway to let them quickly find another peer.\n\nRational: Bloom filters are not always supported or appropriate. For\ninstance no node implementation other than Bitcoin Core supports them,\ne.g btcd and obelisk. (which ironically implement this BIP already,\nmodulo the version number bump) In the long term bloom filters will be\nobsoleted eventually as they have poor scaling properties - problematic\nwith blocksize increases - and are incompatible with UTXO/TXO\ncommitments, which will use prefix-based filtering instead. (already\nbeing implemented in electrum and obelisk)\n\nIn the short term bloom filters have high IO loads, which have lead to\nDoS attacks, and are not an optimal use of resources for nodes which are\nIO constrained rather than bandwidth constrained. (common in VPS setups\nwhich could better help the network by serving full blocks)\n\nAdding NODE_BLOOM as a service bit now will save us some hassle later\ndown the road, reflects what actual implementations do anyway, has been\nalready deployed on Litecoin, Dogecoin, and a zillion other alts with no\nissues, (including SPV client support) and is a trivial patch.\n\n\nGregory Maxwell: Please assign a BIP #\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000049066dab2483c9e069656239f5782da204bd4995bd92c19f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/86eca22c/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2014-06-06T08:48:52",
                "message_text_only": "Advertising NODE BLOOM as a service sounds good.\n\nBut the critique of bloom filters, I am not so sure prefix filters are\nbetter.  Prefix filters offer questionable privacy tradeoffs in my opinion. \nSame problem as with stealth address proposed use of prefixes.\n\nAll for scalability, efficiency and decentralization but not ideally at the\nexpense of nuking privacy.  The effects on privacy are cumulative, and\naffect everyone not just the user.  Same pattern of local decision, global\neffect as with reused addresses.\n\nAdam\n\nOn Fri, Jun 06, 2014 at 04:19:33AM -0400, Peter Todd wrote:\n>In the short term bloom filters have high IO loads, which have lead to\n>DoS attacks, and are not an optimal use of resources for nodes which are\n>IO constrained rather than bandwidth constrained. (common in VPS setups\n>which could better help the network by serving full blocks)"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-06T09:03:29",
                "message_text_only": "On Fri, Jun 6, 2014 at 1:48 AM, Adam Back <adam at cypherspace.org> wrote:\n> Advertising NODE BLOOM as a service sounds good.\n>\n> But the critique of bloom filters, I am not so sure prefix filters are\n> better.  Prefix filters offer questionable privacy tradeoffs in my opinion.\n> Same problem as with stealth address proposed use of prefixes.\n>\n> All for scalability, efficiency and decentralization but not ideally at the\n> expense of nuking privacy.  The effects on privacy are cumulative, and\n> affect everyone not just the user.  Same pattern of local decision, global\n> effect as with reused addresses.\n\nThe performance Bytecoin/Monero/Fantom/etc. systems that use ECDH\naddresses for all transactions seem to be suggesting that the prefixes\naren't really needed.\n\nAt least with current system rules doing the ECDH for each transaction\nseems pretty reasonable."
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-06T09:11:34",
                "message_text_only": "On Fri, Jun 06, 2014 at 02:03:29AM -0700, Gregory Maxwell wrote:\n> On Fri, Jun 6, 2014 at 1:48 AM, Adam Back <adam at cypherspace.org> wrote:\n> > Advertising NODE BLOOM as a service sounds good.\n> >\n> > But the critique of bloom filters, I am not so sure prefix filters are\n> > better.  Prefix filters offer questionable privacy tradeoffs in my opinion.\n> > Same problem as with stealth address proposed use of prefixes.\n> >\n> > All for scalability, efficiency and decentralization but not ideally at the\n> > expense of nuking privacy.  The effects on privacy are cumulative, and\n> > affect everyone not just the user.  Same pattern of local decision, global\n> > effect as with reused addresses.\n> \n> The performance Bytecoin/Monero/Fantom/etc. systems that use ECDH\n> addresses for all transactions seem to be suggesting that the prefixes\n> aren't really needed.\n> \n> At least with current system rules doing the ECDH for each transaction\n> seems pretty reasonable.\n\nYup. Obelisk's indexing is sufficiently fast that they hadn't even\nbothered making Dark Wallet store transaction information between\nsessions until recently. Prefix brute-forcing isn't yet implemented,\nalthough prefix filters is being implemented for lookups in general. (at\nthe very least it gives the server operators some valuable plausible\ndeniability)\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000003a68ee16d702ca5dd5547fb4aead910a004747cb06241dd6\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/27d1b164/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-06T09:04:41",
                "message_text_only": "On Fri, Jun 06, 2014 at 10:48:52AM +0200, Adam Back wrote:\n> Advertising NODE BLOOM as a service sounds good.\n> \n> But the critique of bloom filters, I am not so sure prefix filters are\n> better.  Prefix filters offer questionable privacy tradeoffs in my\n> opinion. Same problem as with stealth address proposed use of\n> prefixes.\n\nThat's assuming you're doing the proposed prefix brute forcing - if you\ndon't do that they have privacy equal or better than bloom filters, but\nwith better scalability. In particular that better scalability lets you\nefficiently query multiple servers for blockchain data, only giving up\ninfo on a subset of the addresses in your wallet to each server. This\ncan be a significant improvement to bloom filters if your attacker is\nrunning logging nodes to try to, say, deanonymize CoinJoin transactions.\n\n> All for scalability, efficiency and decentralization but not ideally at the\n> expense of nuking privacy.  The effects on privacy are cumulative, and\n> affect everyone not just the user.  Same pattern of local decision, global\n> effect as with reused addresses.\n\nIndeed. But again, remember that the existing systems suck too;\nprefix-brute forcing is a engineering tradeoff implementable with\nexisting and well understood technology.\n\nNow if you want to come up with something better and write code, please\ndo! I'm sure the math exists; what doesn't exist is robust and well\ntested code in multiple languages. Stealth addresses at least have been\ndesigned so that future blockchain filter upgrades can be added in a\nbackwards compatible way.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000003a68ee16d702ca5dd5547fb4aead910a004747cb06241dd6\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/0aa750e4/attachment.sig>"
            },
            {
                "author": "Adam Back",
                "date": "2014-06-06T10:45:43",
                "message_text_only": "On Fri, Jun 06, 2014 at 05:04:41AM -0400, Peter Todd wrote:\n>On Fri, Jun 06, 2014 at 10:48:52AM +0200, Adam Back wrote:\n>> Prefix filters offer questionable privacy tradeoffs in my opinion.  Same\n>> problem as with stealth address proposed use of prefixes.\n>\n>That's assuming you're doing the proposed prefix brute forcing\n\nAs I recall prefix brute forcing was a bit twiddle saving, ie searching for\nEDH key that has the users public prefix.  That does not improve privacy\nover an explicit prefix, it saves a byte or so at the expense of average 128\nEDH exchanges to send and provides also some probably relatively ineffective\nplausible deniability by enabling the transaction to be indistinguishable\nfrom some other (not very common) types of transaction.\n\n>don't do that they have privacy equal or better than bloom filters, but\n>with better scalability. \n\neither its full node only where prefixes are not used, which is less\nscalable than bloom; or prefixes are used explicitly or implicitly\n(brute-force) and either way privacy is weakened by the extra correlation\nhook provided by elimination from the network graph of payments with\nmismatched prefixes.\n\n>In particular that better scalability lets you efficiently query multiple\n>servers for blockchain data, only giving up info on a subset of the\n>addresses in your wallet to each server.  This can be a significant\n>improvement to bloom filters if your attacker is running logging nodes to\n>try to, say, deanonymize CoinJoin transactions.\n\nWe need to consider the two types of privacy involved.  Privacy from the\nfull node an SPV client is relying on to find its payments, vs privacy from\nanalysis of the public transaction graph.  The latter is more damaging. \nBetter to design for privacy against future analysis of public info, than\nprivacy by argument to select non-hostile nodes.  Tor has changed recently\nto account for the fact that chosing fresh random nodes is actually worse. \nie you have a probability of identity/address identification per route/node,\nand repeatedly selecting routes/nodes just cumulatively increases the chance\nyou'll be identified.  Better to pick a random node, identify it and stick\nto it and hope you chose well.\n\n>Now if you want to come up with something better and write code, please\n>do! I'm sure the math exists; what doesn't exist is robust and well\n>tested code in multiple languages. \n\nMaybe other simpler, but yes there was the proof of concept that the math\nexists in the form of the weil pairing.\n\nhttps://bitcointalk.org/index.php?topic=431756.new\n\nBut what problem are we trying to solve here?  Is it an immediate problem? \nMaybe better to figure out a more privacy compatible solution which will\ntake longer, than let coding drive protocol.\n\nAdam"
            }
        ],
        "thread_summary": {
            "title": "NODE_BLOOM service bit",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Adam Back",
                "Gregory Maxwell",
                "Peter Todd"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 10108
        }
    },
    {
        "title": "[Bitcoin-development] Bloom bait",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-06-06T16:46:39",
                "message_text_only": "On Fri, Jun 06, 2014 at 12:45:43PM +0200, Adam Back wrote:\n\n(changed subject line as this discussion has nothing to do with\nNODE_BLOOM)\n\n> As I recall prefix brute forcing was a bit twiddle saving, ie searching for\n> EDH key that has the users public prefix.  That does not improve privacy\n> over an explicit prefix, it saves a byte or so at the expense of average 128\n> EDH exchanges to send and provides also some probably relatively ineffective\n> plausible deniability by enabling the transaction to be indistinguishable\n> from some other (not very common) types of transaction.\n\nI think you should re-read my original proposal; there's a whole host of\nmisunderstandings above, for instance I have no idea where you got the\nidea that it has anything to do with \"saving a byte\" came from, or where\nthe number 128 came from.\n\n> >don't do that they have privacy equal or better than bloom filters, but\n> >with better scalability.\n> \n> either its full node only where prefixes are not used, which is less\n> scalable than bloom; or prefixes are used explicitly or implicitly\n> (brute-force) and either way privacy is weakened by the extra correlation\n> hook provided by elimination from the network graph of payments with\n> mismatched prefixes.\n\nAgain, you have a misunderstanding. Both bloom filters and prefix\nfilters are just ways of giving a peer a probabalistic filter to match\ntransactions against. Where they differ is that bloom filters has O(n)\nscaling, where n is the size of a block, and prefix filters have O(log n)\nscaling with slightly(1) higher k. Again, if you *don't* use brute forcing\nin conjunction with prefixes they have no different transactional graph\nprivacy than bloom filters, but the better scalability lets you do\nthings like split your queries across multiple peers that give you\nbetter protection against hostile nodes.  Additionally prefix filters\nare compatible with future miner committed indexes to make the data\nauthenticated.\n\n1) see Amir's experience implementing prefix lookup in Obelisk\n\n> We need to consider the two types of privacy involved.  Privacy from the\n> full node an SPV client is relying on to find its payments, vs privacy from\n> analysis of the public transaction graph.\n\nAgreed\n\n> The latter is more damaging.\n\nMaybe! If adversaries are operating a significant fraction of the peers\nyou are connecting to the current design of bloom filters + HD wallets\nresults in situations where those adversaries have better transactional\ngraph information than the alternative.\n\n> Better to design for privacy against future analysis of\n> public info, than\n> privacy by argument to select non-hostile nodes.  Tor has changed recently\n> to account for the fact that chosing fresh random nodes is actually\n> worse. ie you have a probability of identity/address identification\n> per route/node,\n> and repeatedly selecting routes/nodes just cumulatively increases the chance\n> you'll be identified.  Better to pick a random node, identify it and stick\n> to it and hope you chose well.\n\nThat's basically what Electrum and Obelisk already do - by default you\nconnect to a relatively small set of blockchain data servers operated by\nwell known people and use the same server repeatedly.\n\nApplying that to the P2P network however is tricky as there is a huge\namount of churn in the nodes:\n\n    #bitcoin-dev/14/06/14-06-06.log:11:18 < hearn> bitcoinj can't use\n    [service bits] as it relies on DNS seeds and that is unlikely to change\n    any time soon due to the general churn rate in the network making it\n    hard to bootstrap quickly using just remembered sets of IPs.\n\n> Maybe other simpler, but yes there was the proof of concept that the math\n> exists in the form of the weil pairing.\n> \n> https://bitcointalk.org/index.php?topic=431756.new\n\nI know, where can I find running code? Remember that a bug can easily\nlose thousands of dollars worth of Bitcoins.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001d2af1653c415b7801ce4c9b18ac7e87bef597e652b203e6\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/fe30ab0b/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-06T16:58:19",
                "message_text_only": "On Fri, Jun 6, 2014 at 9:46 AM, Peter Todd <pete at petertodd.org> wrote:\n> transactions against. Where they differ is that bloom filters has O(n)\n> scaling, where n is the size of a block, and prefix filters have O(log n)\n> scaling with slightly(1) higher k. Again, if you *don't* use brute forcing\n> in conjunction with prefixes they have no different transactional graph\n> privacy than bloom filters,\n\nHuh? How are you thinking that something that gets put in transactions\nand burned forever into the blockchain that lets you (statically) link\ntxout ownership is \"no different\" from something which is shared\ndirectly with a couple peers, potentially peers you trust and which\nare run by yourself or your organization?"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-06T17:05:24",
                "message_text_only": "On Fri, Jun 06, 2014 at 09:58:19AM -0700, Gregory Maxwell wrote:\n> On Fri, Jun 6, 2014 at 9:46 AM, Peter Todd <pete at petertodd.org> wrote:\n> > transactions against. Where they differ is that bloom filters has O(n)\n> > scaling, where n is the size of a block, and prefix filters have O(log n)\n> > scaling with slightly(1) higher k. Again, if you *don't* use brute forcing\n> > in conjunction with prefixes they have no different transactional graph\n> > privacy than bloom filters,\n> \n> Huh? How are you thinking that something that gets put in transactions\n> and burned forever into the blockchain that lets you (statically) link\n> txout ownership is \"no different\" from something which is shared\n> directly with a couple peers, potentially peers you trust and which\n> are run by yourself or your organization?\n\nAgain, you *don't* have to use brute-force prefix selection. You can\njust as easily give your peer multiple prefixes, each of which\ncorresponds at least one address in your wallet with some false positive\nrate. I explained all this in detail in my original blockchain data\nprivacy writeup months ago.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000029d945c3832c7f4afabce11e6cb1c27b6f5e8c0f2bbb356c\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/34c15a27/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-06T17:10:51",
                "message_text_only": "On Fri, Jun 6, 2014 at 10:05 AM, Peter Todd <pete at petertodd.org> wrote:\n> Again, you *don't* have to use brute-force prefix selection. You can\n> just as easily give your peer multiple prefixes, each of which\n> corresponds at least one address in your wallet with some false positive\n> rate. I explained all this in detail in my original blockchain data\n> privacy writeup months ago.\n\nI'm not trying to pick nits about all the options,  I just found it\nsurprising that you were saying that data published in a super public\nmanner is no different than something used between nodes.\n\n> I explained all this in detail in my original blockchain data privacy writeup months ago.\n\nCommunication is a two way street, Adam and I (and others) are\nearnestly trying\u2014 that we're not following your arguments may be a\nsuggestion that they need to be communicated somewhat differently.\n\nI'm still failing to see the usefulness of having any prefix filtering\nfor DH-private outputs. It really complicates the security story\u2014 in\nparticular you don't know _now_ what activities will turn your prior\ninformation leaks into compromising ones retrospectivelly, and doesn't\nseem at very necessary for scanning performance."
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-06T17:45:45",
                "message_text_only": "On Fri, Jun 06, 2014 at 10:10:51AM -0700, Gregory Maxwell wrote:\n> On Fri, Jun 6, 2014 at 10:05 AM, Peter Todd <pete at petertodd.org> wrote:\n> > Again, you *don't* have to use brute-force prefix selection. You can\n> > just as easily give your peer multiple prefixes, each of which\n> > corresponds at least one address in your wallet with some false positive\n> > rate. I explained all this in detail in my original blockchain data\n> > privacy writeup months ago.\n> \n> I'm not trying to pick nits about all the options,  I just found it\n> surprising that you were saying that data published in a super public\n> manner is no different than something used between nodes.\n\nBecause I was designing a system under the assumption that you were\nhighly likely to connect to an attacker at some point, and the trade-off\navailable with the available math was to either give very detailed info\nto that attacker, or give away some probabalistic info to everyone.\n\n> > I explained all this in detail in my original blockchain data privacy writeup months ago.\n> \n> Communication is a two way street, Adam and I (and others) are\n> earnestly trying\u2014 that we're not following your arguments may be a\n> suggestion that they need to be communicated somewhat differently.\n\nQuite likely - I think most of this disagreement stems from the fact\nthat we have different starting assumptions. In particular my assumption\nthat you are likely to end up connecting to an attacker logging data,\nand my desire to have a standard that can be implemented with existing\ncryptographic primatives. Remember that I'm spending a lot of time\nworking with wallet authors; they have approximately zero interest in\nstandards that require crypto any more fancy than HD wallets do.\n\n> I'm still failing to see the usefulness of having any prefix filtering\n> for DH-private outputs. It really complicates the security story\u2014 in\n> particular you don't know _now_ what activities will turn your prior\n> information leaks into compromising ones retrospectivelly, and doesn't\n> seem at very necessary for scanning performance.\n\nScanning performance is different from bandwidth performance. Prefix\nbrute-forcing was designed to address the latter concern for cases where\nyou are bandwidth limited and don't have a trusted peer to do the\nscanning for you.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000001c5e0fca7bd6d96211a37543c1d0cc2f594c15423ee3cdd8\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/9272e1f0/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-07T11:22:56",
                "message_text_only": "You can send different bloom filters to different peers too, so I'm not\nsure why you're listing subsetting as a unique advantage of prefix filters.\n\nThe main advantage of prefix filters seems to be faster lookups if the node\nis calculating a sorted index for each block, and the utxo commitment\nstuff, both of those would be cool but involve imposing extra costs on\nnodes. We lack models that let us understand the tradeoffs involved in\nvarious indexing schemes, I feel.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140607/846c248c/attachment.html>"
            },
            {
                "author": "Alan Reiner",
                "date": "2014-06-07T19:44:07",
                "message_text_only": "On 06/07/2014 07:22 AM, Mike Hearn wrote:\n>\n> You can send different bloom filters to different peers too, so I'm\n> not sure why you're listing subsetting as a unique advantage of prefix\n> filters.\n>\n>\n\nPlease let me know if we've gone down this path before, but it would\nseem that the more different bloom filters you create, the more\ninformation you give away.  It would be most useful to create a single\nbloom filter that captures every address you ever intend to use (say a\nlook ahead of 1000 addresses), and then only ever communicate that. \nOnce people see multiple filters that you produce, they can start\nlooking at the intersection of them to reduce the identity space.  I\nwould expect that after enough bloom variants, they could figure out a\nperfect subset of blockchain addresses in your wallet.  (I suppose you\ncould intentionally select an extra 20% addresses to include in every\nbloom filter, but it's a hack).\n\nSimilarly, if you keep updating your bloom filter to include more\naddresses, the difference in what passes through the previous one and\nthe new one gives away information about new addresses you created."
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-08T21:45:29",
                "message_text_only": "On Sat, Jun 07, 2014 at 03:44:07PM -0400, Alan Reiner wrote:\n> \n> On 06/07/2014 07:22 AM, Mike Hearn wrote:\n> >\n> > You can send different bloom filters to different peers too, so I'm\n> > not sure why you're listing subsetting as a unique advantage of prefix\n> > filters.\n> >\n> >\n> \n> Please let me know if we've gone down this path before, but it would\n> seem that the more different bloom filters you create, the more\n> information you give away.  It would be most useful to create a single\n> bloom filter that captures every address you ever intend to use (say a\n> look ahead of 1000 addresses), and then only ever communicate that. \n> Once people see multiple filters that you produce, they can start\n> looking at the intersection of them to reduce the identity space.  I\n> would expect that after enough bloom variants, they could figure out a\n> perfect subset of blockchain addresses in your wallet.  (I suppose you\n> could intentionally select an extra 20% addresses to include in every\n> bloom filter, but it's a hack).\n> \n> Similarly, if you keep updating your bloom filter to include more\n> addresses, the difference in what passes through the previous one and\n> the new one gives away information about new addresses you created.\n\nYou're completely correct. You can use the same nTweak value for each\nfilter and then slice up the filters bitwise, but then you end up\nlinking every query you make to your identity unless you just used a\nfixed nTweak that everyone else uses.  (e.g. zero) If you do that, you\nstill have the problem that you're greatly increasing the load on the\nnetwork.\n\nIn any case, all this shows is that in the future bloom filters will\nvery likely go away eventually, and to make that upgrade path smooth it\nonly makes sense to define a way for nodes to let others know whether or\nnot bloom is supported. A NODE_BLOOM service bit is a very reasonable\nand simple way to do exactly that, and is defacto what implementations\nthat don't support bloom filters do anyway.\n\nNote BTW that re: DNS seeds, once the NODE_BLOOM BIP is accepted and the\nNODE_BLOOM patch merged into bitcoind, I'll write a patch for sipa's\nseeder to make it only return seeds with bloom filter support.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000003afb1fdf0867fc063775e69f9ae79870bb8727f25b49e88f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140608/a9dfa31a/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-10T10:41:35",
                "message_text_only": ">\n>  A NODE_BLOOM service bit is a very reasonable\n> and simple way to do exactly that, and is defacto what implementations\n> that don't support bloom filters do anyway.\n>\n\nBTW, I find it curious that any nodes have code to disconnect peers that\nsend Bloom filters. It shouldn't be necessary. Bitcoinj is the only large\nscale user of filtering and it will disconnect itself if a peer advertises\nsupport for a version lower than 70000. If a node advertises support for\nthis version or higher then it is supposed to implement BIP37.\n\nIt sounds like some node authors decided to advertise support for a\nprotocol version they didn't bother implementing, which would be a bug.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140610/5cefdcc2/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-08T21:35:34",
                "message_text_only": "On Sat, Jun 07, 2014 at 07:22:56PM +0800, Mike Hearn wrote:\n> You can send different bloom filters to different peers too, so I'm not\n> sure why you're listing subsetting as a unique advantage of prefix filters.\n\nAs I explained in the email you're replying to and didn't quote, bloom\nfilters has O(n) cost per query, so sending different bloom filters to\ndifferent peers for privacy reasons costs the network significant disk\nIO resources. If I were to actually implement it it'd look like a DoS\nattack on the network.\n\nEssentially with bloom filters you have to make a tradeoff between\nscalability and privacy; with prefix filters you don't have to make that\nugly tradeoff. Notably that tradeoff gets worse if we ever increase the\nBitcoin blocksize.\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000003afb1fdf0867fc063775e69f9ae79870bb8727f25b49e88f\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140608/70ac7017/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-10T10:38:23",
                "message_text_only": ">\n> As I explained in the email you're replying to and didn't quote, bloom\n> filters has O(n) cost per query, so sending different bloom filters to\n> different peers for privacy reasons costs the network significant disk\n> IO resources. If I were to actually implement it it'd look like a DoS\n> attack on the network.\n>\n\nDoS attack? Nice try.\n\nPerformance is subtle, disk iops especially so. I suspect you'd find - if\nyou implemented it - that for the kinds of loads Bitcoin is processing both\ntoday and tomorrow prefix filtering either doesn't save any disk seeks or\nactively makes it worse.\n\nConsider a client that is syncing the last 24 hours of chain. bitcoind\npre-allocates space for blocks in large chunks, so most blocks are laid out\nsequentially on disk. Almost all the cost of a disk read is rotational\nlatency. Once the head is in place data can be read in very fast and modern\nkernels will attempt to adaptively read ahead in order to exploit this,\nespecially if a program seems to be working through a disk file\nsequentially. The work of Bloom filtering parts of the chain for this\nclient boils down to a handful of disk seeks at best and the rest of the\nwork is all CPU/memory bound as the block is parsed into objects and tested\nagainst the filter. A smarter filtering implementation than ours could do\nSAX-style parsing of the block and avoid the overhead of turning it all\ninto objects.\n\nNow consider a prefix filtering implementation. You need to calculate a\nsorted list of all the data elements and tx hashes in the block, that maps\nto the location in the block where the tx data can be found. These\nper-block indexes take up extra disk space and, realistically, would likely\nbe implemented using LevelDB as that's a tool which is designed for\ncreating and using these kinds of tables, so then you're both loading the\nblock data itself (blocks are sized about right currently to always fit in\nthe default kernel readahead window) AND also seeking through the indexes,\nand building them too. A smart implementation might try and pack the index\nnext to each block so it's possible to load both at once with a single\nseek, but that would probably be more work, as it'd force building of the\nindex to be synchronous with saving the block to disk thus slowing down\nblock relay. In contrast a LevelDB based index would do the bulk of the\nindex-building work on a separate core.\n\nAt *some* block size and client load the additional data storage and\nincreased pressure on the page cache would probably make it worthwhile. But\nI find it unlikely to be true at current traffic levels, or double or\ntriple today's levels. So I'd rather we spend our very limited collective\ntime on finding ways to increase usage rather than worrying about resources\nwhich are not presently scarce.\n\n(as an aside, some of the above analysis would be invalidated if most nodes\nend up running on SSDs, but I doubt most are. It'd be neat to export\nstorage tech via some kind of stats message - LevelDB is designed for HDDs\nnot SSDs so at some point a new storage subsystem might make sense if the\nnetwork switched over).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140610/c4a4cf3e/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-10T13:02:00",
                "message_text_only": "Most of this description of disk activity is true, but it omits one\nkey point:  Total cached data (working set).  It is a binary, first\norder question:  are you hitting pagecache, or the disk?  When nodes\nact as archival data sources, the pagecache pressure is immense.  When\nnodes just primarily serve recent blocks, that data is being served\nout of pagecache. As I directly observed running public nodes, the\ndisks were running constantly, impacting all clients, even clients\ndownloading only recent blocks.\n\nLuckily, headers are served out of RAM, so that part of the sync is always fast.\n\nNODE_BLOOM -- and block download in general -- will tend to be slower\nthan it could be, due to the working set almost always being larger\nthan available pagecache.  Fix that problem, NODE_BLOOM will always\noperate out of pagecache, and disk activity will not be an issue.\n\nOnce you start hitting the disk, you've already lost.\n\n\n\nOn Tue, Jun 10, 2014 at 6:38 AM, Mike Hearn <mike at plan99.net> wrote:\n>> As I explained in the email you're replying to and didn't quote, bloom\n>> filters has O(n) cost per query, so sending different bloom filters to\n>> different peers for privacy reasons costs the network significant disk\n>> IO resources. If I were to actually implement it it'd look like a DoS\n>> attack on the network.\n>\n>\n> DoS attack? Nice try.\n>\n> Performance is subtle, disk iops especially so. I suspect you'd find - if\n> you implemented it - that for the kinds of loads Bitcoin is processing both\n> today and tomorrow prefix filtering either doesn't save any disk seeks or\n> actively makes it worse.\n>\n> Consider a client that is syncing the last 24 hours of chain. bitcoind\n> pre-allocates space for blocks in large chunks, so most blocks are laid out\n> sequentially on disk. Almost all the cost of a disk read is rotational\n> latency. Once the head is in place data can be read in very fast and modern\n> kernels will attempt to adaptively read ahead in order to exploit this,\n> especially if a program seems to be working through a disk file\n> sequentially. The work of Bloom filtering parts of the chain for this client\n> boils down to a handful of disk seeks at best and the rest of the work is\n> all CPU/memory bound as the block is parsed into objects and tested against\n> the filter. A smarter filtering implementation than ours could do SAX-style\n> parsing of the block and avoid the overhead of turning it all into objects.\n>\n> Now consider a prefix filtering implementation. You need to calculate a\n> sorted list of all the data elements and tx hashes in the block, that maps\n> to the location in the block where the tx data can be found. These per-block\n> indexes take up extra disk space and, realistically, would likely be\n> implemented using LevelDB as that's a tool which is designed for creating\n> and using these kinds of tables, so then you're both loading the block data\n> itself (blocks are sized about right currently to always fit in the default\n> kernel readahead window) AND also seeking through the indexes, and building\n> them too. A smart implementation might try and pack the index next to each\n> block so it's possible to load both at once with a single seek, but that\n> would probably be more work, as it'd force building of the index to be\n> synchronous with saving the block to disk thus slowing down block relay. In\n> contrast a LevelDB based index would do the bulk of the index-building work\n> on a separate core.\n>\n> At some block size and client load the additional data storage and increased\n> pressure on the page cache would probably make it worthwhile. But I find it\n> unlikely to be true at current traffic levels, or double or triple today's\n> levels. So I'd rather we spend our very limited collective time on finding\n> ways to increase usage rather than worrying about resources which are not\n> presently scarce.\n>\n> (as an aside, some of the above analysis would be invalidated if most nodes\n> end up running on SSDs, but I doubt most are. It'd be neat to export storage\n> tech via some kind of stats message - LevelDB is designed for HDDs not SSDs\n> so at some point a new storage subsystem might make sense if the network\n> switched over).\n>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-10T17:08:46",
                "message_text_only": "On Tue, Jun 10, 2014 at 06:38:23PM +0800, Mike Hearn wrote:\n> >\n> > As I explained in the email you're replying to and didn't quote, bloom\n> > filters has O(n) cost per query, so sending different bloom filters to\n> > different peers for privacy reasons costs the network significant disk\n> > IO resources. If I were to actually implement it it'd look like a DoS\n> > attack on the network.\n> >\n> \n> DoS attack? Nice try.\n\nSuppose I wrote an single address lookup tool for Android that connected\nto multiple peers and used bloom filters to find the history of a\nspecific address. Of course, I don't want to use too much bandwidth\nbeing on mobile, so I'll use as specific a bloom filter as possible. I\nmight even connect to multiple peers to speed up the lookup.\n\nIs this any different from my bloom filter IO attack code? Nope. Hence,\nsplitting up bloom filter requests for better privacy will certainly\nlook like a DoS attack and will certainly greatly increase the load on\nthe network.\n\n\n> Now consider a prefix filtering implementation. You need to calculate a\n> sorted list of all the data elements and tx hashes in the block, that maps\n> to the location in the block where the tx data can be found. These\n> per-block indexes take up extra disk space and, realistically, would likely\n> be implemented using LevelDB as that's a tool which is designed for\n> creating and using these kinds of tables, so then you're both loading the\n> block data itself (blocks are sized about right currently to always fit in\n> the default kernel readahead window) AND also seeking through the indexes,\n> and building them too. A smart implementation might try and pack the index\n> next to each block so it's possible to load both at once with a single\n> seek, but that would probably be more work, as it'd force building of the\n> index to be synchronous with saving the block to disk thus slowing down\n> block relay. In contrast a LevelDB based index would do the bulk of the\n> index-building work on a separate core.\n\nThat's exactly the kinds of optimizations obelisk is implementing to\nmake its prefix lookup database fast. Also those optimizations are\nsituation dependent, for instance \"packing the index next to each block\"\nis irrelevant if you put archival blockchain data on a slow HD, and\nindexes on a fast SSD, something some obelisk servers do.\n\nMore to the point, your showing quite clearly there isn't just one\noptimal way to do it. Applying a bloom filter, or a prefix filter, or\nsome as yet unknown filter, to blockchain data is a service and that\nservice has different tradeoffs compared to just serving up archival\nblock history. There is zero reason not to make that service something\nyou advertise with NODE_BLOOM - after all, you already have the code in\nbitcoinj to do the exact same thing by checking the advertised protocol\nversion.\n\n\nOn Tue, Jun 10, 2014 at 09:02:00AM -0400, Jeff Garzik wrote:\n> Most of this description of disk activity is true, but it omits one\n> key point:  Total cached data (working set).  It is a binary, first\n> order question:  are you hitting pagecache, or the disk?  When nodes\n> act as archival data sources, the pagecache pressure is immense.  When\n> nodes just primarily serve recent blocks, that data is being served\n> out of pagecache. As I directly observed running public nodes, the\n> disks were running constantly, impacting all clients, even clients\n> downloading only recent blocks.\n> \n> Luckily, headers are served out of RAM, so that part of the sync is always fast.\n> \n> NODE_BLOOM -- and block download in general -- will tend to be slower\n> than it could be, due to the working set almost always being larger\n> than available pagecache.  Fix that problem, NODE_BLOOM will always\n> operate out of pagecache, and disk activity will not be an issue.\n> \n> Once you start hitting the disk, you've already lost.\n\nYup. I discussed this with Matt Corallo at the financial crypto\nconference a few months back and he made the same point. Unfortunately\nwe'll need an upgrade to let nodes advertise ranges of blocks to begin\nto fix that issue, and even then it still shows quite clearly how it's\nnot optimal if we force everyone to share blockchain data in the same\nway.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000023c7fc084ed84b891cc2fa90e4a34708d6b2370d3ec1c85d\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140610/8239070c/attachment.sig>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-11T08:57:29",
                "message_text_only": ">\n> Is this any different from my bloom filter IO attack code? Nope.\n>\n\nIt's obviously different; a thin client trying to obtain more privacy is\nnot attempting to deny service to anyone. You can't simply state that a\nfeature which uses resources for a legitimate reason is a DoS attack,\nthat's a spurious definition that would reclassify innocuous things like\nweb browser prefetching as DoS attacks too.\n\nWith respect to the work you're proposing, trying to retroactively make\nBloom filtering an optional part of the protocol is just wasting people's\ntime at this point:\n\n   - There is no evidence there's an actual problem today.\n   - There is no evidence there will be a problem any time soon, given the\n   meagre levels of traffic growth we have.\n   - It involves a complicated rollout strategy that would create work for\n   many people.\n   - Gavin, Wladimir and myself have all concluded it's not worth the cost.\n   - The only justification you have provided is that two node\n   implementations hardly anyone uses can't be bothered to implement Bloom\n   filtering, but want to advertise support in their ver message anyway. They\n   can simply lower the number they advertise in their ver message.\n\nThat said, if you want to implement better support for archival nodes then\nthat'd be great. The way to do it would be either to implement block ranges\nin the addr announcements as has been discussed many times before, or\nperhaps introduce a new protocol optimised for serving the chain. Nodes\nthat are CPU limited won't want to take part in the rest of the P2P\nprotocol anyway, it's not just Bloom filtering that uses CPU time but also\nblock and tx relay.\n\nBut until you have done these things, please stop attempting to reclassify\nany feature you can imagine a more efficient version of as an \"attack\".\nIt's just silly.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140611/fdd726e2/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bloom bait",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Mike Hearn",
                "Peter Todd",
                "Alan Reiner",
                "Gregory Maxwell"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 31457
        }
    },
    {
        "title": "[Bitcoin-development] Wallet nLockTime best practices",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2014-06-06T19:00:13",
                "message_text_only": "We are considering pulling in https://github.com/bitcoin/bitcoin/pull/2340\n\"Discourage fee sniping with nLockTime\"\n\nComments from other wallet implementors in particular are welcomed.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Aaron Voisine",
                "date": "2014-06-06T20:17:49",
                "message_text_only": "I'll implement it in breadwallet (oss SPV wallet, hopefully about to\nbe in the app store) if other wallet authors are planning to.\n\nAaron\nhttps://github.com/voisine/breadwallet\n\nThere's no trick to being a humorist when you have the whole\ngovernment working for you -- Will Rodgers\n\n\nOn Fri, Jun 6, 2014 at 12:00 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> We are considering pulling in https://github.com/bitcoin/bitcoin/pull/2340\n> \"Discourage fee sniping with nLockTime\"\n>\n> Comments from other wallet implementors in particular are welcomed.\n>\n> --\n> Jeff Garzik\n> Bitcoin core developer and open source evangelist\n> BitPay, Inc.      https://bitpay.com/\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-25T15:43:05",
                "message_text_only": "I'm inclined to merge https://github.com/bitcoin/bitcoin/pull/2340\n\nwhich sets nLockTime on wallet-created transactions by default.  I\nthink this is good practice for wallets, long term.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Wallet nLockTime best practices",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Aaron Voisine"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 1820
        }
    },
    {
        "title": "[Bitcoin-development] Possible attack: Keeping unconfirmed transactions",
        "thread_messages": [
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-06T22:02:36",
                "message_text_only": "I dont know if this attack is even possible, it came to my mind and I will\ntry to explain it as good as possible.\n\nSome transacions keep unconfirmed forever and finally they are purged by\nBitcoin nodes, mostly due to the lack of fees.\n\n\nExample:\n---------\n\nAlice is selling a pizza to Bob, Bob is now making the payment with Bitcoin.\nThe main goal of this attack is to store a unconfirmed transaction send by\nBob for a few days (it will not be included in the blockchain because it\nhas no fee or due to other reason), Bob might resend the payment or might\njust cancel the deal with Alice.\n\nBob forgets about that failed trade but a couple of days later, Alice, who\nhas stored the signed transacion, relays the transaction to the network (or\nmines it directly with his own hashpower).\nBob does not know what is happening, he believed that that transaction was\n\"canceled forever\", he even does not remember the failed pizza deal.\n\nAlice has now the bitcoins and Bob does not know what happened with his\nmoney.\n\n---------\n\nThis might also work with the Payment Protocol because when using it Bob\ndoes not relay the transaction to the network, its Alices job to do it,\nAlice stores it and tells Bob to resend the payment, Bob creates another\ntransaction (If has the same inputs as the first TX this does not work)\n(this one is relayed by Alice to the network).\n\nAlice comes back a couple of days later and mines with his hashrate the\nfirst transaction (the one she didnt relayed to the network).\n\nAlice now has two payments, Bob does not know what happened.\n\n\n-----------\n\nI hope that I explained well this possible attack, I dont know if there is\nalready a fix for this problem or if it is simply impossible to execute\nthis kind of attack.\n\nThanks for your time.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140607/bc2e4b23/attachment.html>"
            },
            {
                "author": "Toshi Morita",
                "date": "2014-06-06T22:11:28",
                "message_text_only": ">From what I know, Alice does not know to which node Bob will broadcast the\ntransaction. Therefore, Alice cannot intercept the transaction and prevent\nthe rest of the network from seeing it.\n\nToshi\n\n\n\nOn Fri, Jun 6, 2014 at 3:02 PM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n\n> I dont know if this attack is even possible, it came to my mind and I will\n> try to explain it as good as possible.\n>\n> Some transacions keep unconfirmed forever and finally they are purged by\n> Bitcoin nodes, mostly due to the lack of fees.\n>\n>\n> Example:\n> ---------\n>\n> Alice is selling a pizza to Bob, Bob is now making the payment with\n> Bitcoin.\n> The main goal of this attack is to store a unconfirmed transaction send by\n> Bob for a few days (it will not be included in the blockchain because it\n> has no fee or due to other reason), Bob might resend the payment or might\n> just cancel the deal with Alice.\n>\n> Bob forgets about that failed trade but a couple of days later, Alice, who\n> has stored the signed transacion, relays the transaction to the network (or\n> mines it directly with his own hashpower).\n> Bob does not know what is happening, he believed that that transaction was\n> \"canceled forever\", he even does not remember the failed pizza deal.\n>\n> Alice has now the bitcoins and Bob does not know what happened with his\n> money.\n>\n> ---------\n>\n> This might also work with the Payment Protocol because when using it Bob\n> does not relay the transaction to the network, its Alices job to do it,\n> Alice stores it and tells Bob to resend the payment, Bob creates another\n> transaction (If has the same inputs as the first TX this does not work)\n> (this one is relayed by Alice to the network).\n>\n> Alice comes back a couple of days later and mines with his hashrate the\n> first transaction (the one she didnt relayed to the network).\n>\n> Alice now has two payments, Bob does not know what happened.\n>\n>\n> -----------\n>\n> I hope that I explained well this possible attack, I dont know if there is\n> already a fix for this problem or if it is simply impossible to execute\n> this kind of attack.\n>\n> Thanks for your time.\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/f0ad4565/attachment.html>"
            },
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-06T22:21:48",
                "message_text_only": "Alice does not intercept the transaction, she only saves it and expect that\nit will not be confirmed (because has 0 fee for example).\n\nAlso using the Payment Protocol I believe that Alice is the only person\nthat can relay Bob's transaction.\n\nSource: https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\n\n*When the merchant's server receives the Payment message, it must determine\n> whether or not the transactions satisfy conditions of payment. If and only\n> if they do, if should broadcast the transaction(s) on the Bitcoin p2p\n> network.*\n>\n\n\n2014-06-07 0:11 GMT+02:00 Toshi Morita <toshi at peernova.com>:\n\n> From what I know, Alice does not know to which node Bob will broadcast the\n> transaction. Therefore, Alice cannot intercept the transaction and prevent\n> the rest of the network from seeing it.\n>\n> Toshi\n>\n>\n>\n> On Fri, Jun 6, 2014 at 3:02 PM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n>\n>> I dont know if this attack is even possible, it came to my mind and I\n>> will try to explain it as good as possible.\n>>\n>> Some transacions keep unconfirmed forever and finally they are purged by\n>> Bitcoin nodes, mostly due to the lack of fees.\n>>\n>>\n>> Example:\n>> ---------\n>>\n>> Alice is selling a pizza to Bob, Bob is now making the payment with\n>> Bitcoin.\n>> The main goal of this attack is to store a unconfirmed transaction send\n>> by Bob for a few days (it will not be included in the blockchain because it\n>> has no fee or due to other reason), Bob might resend the payment or might\n>> just cancel the deal with Alice.\n>>\n>> Bob forgets about that failed trade but a couple of days later, Alice,\n>> who has stored the signed transacion, relays the transaction to the network\n>> (or mines it directly with his own hashpower).\n>> Bob does not know what is happening, he believed that that transaction\n>> was \"canceled forever\", he even does not remember the failed pizza deal.\n>>\n>> Alice has now the bitcoins and Bob does not know what happened with his\n>> money.\n>>\n>> ---------\n>>\n>> This might also work with the Payment Protocol because when using it Bob\n>> does not relay the transaction to the network, its Alices job to do it,\n>> Alice stores it and tells Bob to resend the payment, Bob creates another\n>> transaction (If has the same inputs as the first TX this does not work)\n>> (this one is relayed by Alice to the network).\n>>\n>> Alice comes back a couple of days later and mines with his hashrate the\n>> first transaction (the one she didnt relayed to the network).\n>>\n>> Alice now has two payments, Bob does not know what happened.\n>>\n>>\n>> -----------\n>>\n>> I hope that I explained well this possible attack, I dont know if there\n>> is already a fix for this problem or if it is simply impossible to execute\n>> this kind of attack.\n>>\n>> Thanks for your time.\n>>\n>>\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Learn Graph Databases - Download FREE O'Reilly Book\n>> \"Graph Databases\" is the definitive new guide to graph databases and their\n>> applications. Written by three acclaimed leaders in the field,\n>> this first edition is now available. Download your free book today!\n>> http://p.sf.net/sfu/NeoTech\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140607/6bd6e287/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-06-06T22:27:44",
                "message_text_only": "Whenever you do a reissuing of a transaction that didn't go through\nearlier, you should make sure to reuse one of the inputs for it. That\nguarantees that both cannot confirm simultaneously.\n\nOn Sat, Jun 7, 2014 at 12:21 AM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n> Alice does not intercept the transaction, she only saves it and expect that\n> it will not be confirmed (because has 0 fee for example).\n>\n> Also using the Payment Protocol I believe that Alice is the only person that\n> can relay Bob's transaction.\n>\n> Source: https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\n>\n>> When the merchant's server receives the Payment message, it must determine\n>> whether or not the transactions satisfy conditions of payment. If and only\n>> if they do, if should broadcast the transaction(s) on the Bitcoin p2p\n>> network.\n>\n>\n>\n> 2014-06-07 0:11 GMT+02:00 Toshi Morita <toshi at peernova.com>:\n>\n>> From what I know, Alice does not know to which node Bob will broadcast the\n>> transaction. Therefore, Alice cannot intercept the transaction and prevent\n>> the rest of the network from seeing it.\n>>\n>> Toshi\n>>\n>>\n>>\n>> On Fri, Jun 6, 2014 at 3:02 PM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n>>>\n>>> I dont know if this attack is even possible, it came to my mind and I\n>>> will try to explain it as good as possible.\n>>>\n>>> Some transacions keep unconfirmed forever and finally they are purged by\n>>> Bitcoin nodes, mostly due to the lack of fees.\n>>>\n>>>\n>>> Example:\n>>> ---------\n>>>\n>>> Alice is selling a pizza to Bob, Bob is now making the payment with\n>>> Bitcoin.\n>>> The main goal of this attack is to store a unconfirmed transaction send\n>>> by Bob for a few days (it will not be included in the blockchain because it\n>>> has no fee or due to other reason), Bob might resend the payment or might\n>>> just cancel the deal with Alice.\n>>>\n>>> Bob forgets about that failed trade but a couple of days later, Alice,\n>>> who has stored the signed transacion, relays the transaction to the network\n>>> (or mines it directly with his own hashpower).\n>>> Bob does not know what is happening, he believed that that transaction\n>>> was \"canceled forever\", he even does not remember the failed pizza deal.\n>>>\n>>> Alice has now the bitcoins and Bob does not know what happened with his\n>>> money.\n>>>\n>>> ---------\n>>>\n>>> This might also work with the Payment Protocol because when using it Bob\n>>> does not relay the transaction to the network, its Alices job to do it,\n>>> Alice stores it and tells Bob to resend the payment, Bob creates another\n>>> transaction (If has the same inputs as the first TX this does not work)\n>>> (this one is relayed by Alice to the network).\n>>>\n>>> Alice comes back a couple of days later and mines with his hashrate the\n>>> first transaction (the one she didnt relayed to the network).\n>>>\n>>> Alice now has two payments, Bob does not know what happened.\n>>>\n>>>\n>>> -----------\n>>>\n>>> I hope that I explained well this possible attack, I dont know if there\n>>> is already a fix for this problem or if it is simply impossible to execute\n>>> this kind of attack.\n>>>\n>>> Thanks for your time.\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> Learn Graph Databases - Download FREE O'Reilly Book\n>>> \"Graph Databases\" is the definitive new guide to graph databases and\n>>> their\n>>> applications. Written by three acclaimed leaders in the field,\n>>> this first edition is now available. Download your free book today!\n>>> http://p.sf.net/sfu/NeoTech\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> Learn Graph Databases - Download FREE O'Reilly Book\n> \"Graph Databases\" is the definitive new guide to graph databases and their\n> applications. Written by three acclaimed leaders in the field,\n> this first edition is now available. Download your free book today!\n> http://p.sf.net/sfu/NeoTech\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2014-06-06T22:53:25",
                "message_text_only": "On Sat, Jun 07, 2014 at 12:02:36AM +0200, Ra\u00fal Mart\u00ednez wrote:\n> I dont know if this attack is even possible, it came to my mind and I will\n> try to explain it as good as possible.\n> \n> Some transacions keep unconfirmed forever and finally they are purged by\n> Bitcoin nodes, mostly due to the lack of fees.\n>\n\nIt's definitely possible. As Pieter says it is important to always reuse\ninputs if you are \"resending\" a transaction. If you don't reuse inputs,\nyou are creating a new transaction and you should think of it as\nspending twice as much money.\n\nLike any information on the Internet, once a signed transaction leaves\nyour system there is no way to undo this. (Though of course, you can\nrespend the inputs to ensure that if ever your transaction resurfaces it\nwill not confirm.) This is true even if the transaction has low fees, is\nnonstandard, or is otherwise inhibited from relaying.\n\nI would go so far as to say that any UI which suggests otherwise (e.g.\noffering a \"cancel\" feature which does not involve respending inputs or\nthat makes any guarantees about being effective) is dangerously broken.\n\n-- \nAndrew Poelstra\nMathematics Department, University of Texas at Austin\nEmail: apoelstra at wpsoftware.net\nWeb:   http://www.wpsoftware.net/andrew\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 490 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140606/20d1c22a/attachment.sig>"
            },
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-06T22:03:28",
                "message_text_only": "I dont know if this attack is even possible, it came to my mind and I will\ntry to explain it as good as possible.\n\nSome transacions keep unconfirmed forever and finally they are purged by\nBitcoin nodes, mostly due to the lack of fees.\n\n\nExample:\n---------\n\nAlice is selling a pizza to Bob, Bob is now making the payment with Bitcoin.\nThe main goal of this attack is to store a unconfirmed transaction send by\nBob for a few days (it will not be included in the blockchain because it\nhas no fee or due to other reason), Bob might resend the payment or might\njust cancel the deal with Alice.\n\nBob forgets about that failed trade but a couple of days later, Alice, who\nhas stored the signed transacion, relays the transaction to the network (or\nmines it directly with his own hashpower).\nBob does not know what is happening, he believed that that transaction was\n\"canceled forever\", he even does not remember the failed pizza deal.\n\nAlice has now the bitcoins and Bob does not know what happened with his\nmoney.\n\n---------\n\nThis might also work with the Payment Protocol because when using it Bob\ndoes not relay the transaction to the network, its Alices job to do it,\nAlice stores it and tells Bob to resend the payment, Bob creates another\ntransaction (If has the same inputs as the first TX this does not work)\n(this one is relayed by Alice to the network).\n\nAlice comes back a couple of days later and mines with his hashrate the\nfirst transaction (the one she didnt relayed to the network).\n\nAlice now has two payments, Bob does not know what happened.\n\n\n-----------\n\nI hope that I explained well this possible attack, I dont know if there is\nalready a fix for this problem or if it is simply impossible to execute\nthis kind of attack.\n\nThanks for your time.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140607/c2a4569b/attachment.html>"
            },
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-10T11:25:05",
                "message_text_only": "I believe that the Payment Protocol works that way, the merchant broadcast\nthe Tx.\nEl 10/06/2014 13:23, \"Chris D'Costa\" <chrisjdcosta at gmail.com> escribi\u00f3:\n\n> I wonder if Raul is mistakenly under the impression that the transaction\n> only reaches the Bitcoin network via Alice? In which case the premise of\n> this \"attack\" is incorrect.\n>\n> *Chris D'Costa*\n>\n>\n> Follow on Twitter: *@cjdcosta*\n>\n> *---------------------------------------------------------------------------------------*\n> chris.dcosta at meek.io (Meek)\n> chris.dcosta at sossee.com (Blog)\n> chrisjdcosta at gmail.com <chris_dcosta at me.com> (Personal)\n> chris.dcosta at bitcoinassociation.be (Belgian Bitcoin Association)\n>\n> ---------------------------------------------------------------------------------------\n>\n>\n> On 7 June 2014 00:02, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n>\n>> I dont know if this attack is even possible, it came to my mind and I\n>> will try to explain it as good as possible.\n>>\n>> Some transacions keep unconfirmed forever and finally they are purged by\n>> Bitcoin nodes, mostly due to the lack of fees.\n>>\n>>\n>> Example:\n>> ---------\n>>\n>> Alice is selling a pizza to Bob, Bob is now making the payment with\n>> Bitcoin.\n>> The main goal of this attack is to store a unconfirmed transaction send\n>> by Bob for a few days (it will not be included in the blockchain because it\n>> has no fee or due to other reason), Bob might resend the payment or might\n>> just cancel the deal with Alice.\n>>\n>> Bob forgets about that failed trade but a couple of days later, Alice,\n>> who has stored the signed transacion, relays the transaction to the network\n>> (or mines it directly with his own hashpower).\n>> Bob does not know what is happening, he believed that that transaction\n>> was \"canceled forever\", he even does not remember the failed pizza deal.\n>>\n>> Alice has now the bitcoins and Bob does not know what happened with his\n>> money.\n>>\n>> ---------\n>>\n>> This might also work with the Payment Protocol because when using it Bob\n>> does not relay the transaction to the network, its Alices job to do it,\n>> Alice stores it and tells Bob to resend the payment, Bob creates another\n>> transaction (If has the same inputs as the first TX this does not work)\n>> (this one is relayed by Alice to the network).\n>>\n>> Alice comes back a couple of days later and mines with his hashrate the\n>> first transaction (the one she didnt relayed to the network).\n>>\n>> Alice now has two payments, Bob does not know what happened.\n>>\n>>\n>> -----------\n>>\n>> I hope that I explained well this possible attack, I dont know if there\n>> is already a fix for this problem or if it is simply impossible to execute\n>> this kind of attack.\n>>\n>> Thanks for your time.\n>>\n>>\n>>\n>>\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> Learn Graph Databases - Download FREE O'Reilly Book\n>> \"Graph Databases\" is the definitive new guide to graph databases and their\n>> applications. Written by three acclaimed leaders in the field,\n>> this first edition is now available. Download your free book today!\n>> http://p.sf.net/sfu/NeoTech\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140610/d7a8ec9c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Possible attack: Keeping unconfirmed transactions",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Andrew Poelstra",
                "Ra\u00fal Mart\u00ednez",
                "Pieter Wuille",
                "Toshi Morita"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 19774
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin miner heads-up: \"getwork\" RPC going away",
        "thread_messages": [
            {
                "author": "Jeff Garzik",
                "date": "2014-06-07T01:55:31",
                "message_text_only": "\"getwork\" has long been unused on mainnet, and mostly unused elsewhere\nas well.  It generates work by a method that cannot keep up with the\ndemands of the modern network.\n\nAs such, it is planned to remove \"getwork\" in the next release.  Most\nif not all pool servers have switched away from \"getwork\" years ago.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-07T08:29:18",
                "message_text_only": "On Sat, Jun 7, 2014 at 3:55 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> As such, it is planned to remove \"getwork\" in the next release.  Most\n> if not all pool servers have switched away from \"getwork\" years ago.\n\nTo be clear, they switched to \"getblocktemplate\" and \"submitblock\"\nwhich provides a much more flexible and scalable way to do mining.\nThis is explained in https://en.bitcoin.it/wiki/Getblocktemplate .\n\nWladimir"
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-06-21T15:14:15",
                "message_text_only": "On Sat, Jun 7, 2014 at 10:29 AM, Wladimir <laanwj at gmail.com> wrote:\n> On Sat, Jun 7, 2014 at 3:55 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>> As such, it is planned to remove \"getwork\" in the next release.  Most\n>> if not all pool servers have switched away from \"getwork\" years ago.\n>\n> To be clear, they switched to \"getblocktemplate\" and \"submitblock\"\n> which provides a much more flexible and scalable way to do mining.\n> This is explained in https://en.bitcoin.it/wiki/Getblocktemplate .\n\nAs there doesn't seem to be any objection, we may go ahead and merge\nhttps://github.com/bitcoin/bitcoin/pull/4100 (which among other things\nremoves the getwork RPC).\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin miner heads-up: \"getwork\" RPC going away",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Pieter Wuille",
                "Wladimir"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 1524
        }
    },
    {
        "title": "[Bitcoin-development] PSA: Please sign your git commits",
        "thread_messages": [
            {
                "author": "Chris Beams",
                "date": "2014-06-09T15:34:18",
                "message_text_only": "An update on this topic:\n\nWith the release of Git 2.0, automatic commit signing is now possible with the 'commit.gpgsign' configuration option [1]. This means that interactively rebased or cherry-picked commits are also re-signed on the fly. The absence of this ability in prior versions of Git meant that signing every commit wasn't a practical policy for anyone using rebase as a regular part of their local development workflow. Now it can be.\n\nMerging also works as expected with this feature turned on.\n\nOne caveat I've identified thus far is a negative impact on speed when a large number of commits are involved. Any time you're signing a commit, you're interacting with the gpg-agent daemon, and this is roughly an order of magnitude slower than signing without committing.\n\nSpeed without signing:\n\n    $ echo '' >> README.md; time git commit -am\"Test commit speed\" --no-gpg-sign\n    [...]\n    real    0m0.031s\n\nand with:\n\n    $ echo '' >> README.md; time git commit -am\"Test commit speed\" --gpg-sign\n    [...]\n    real    0m0.360s\n\nFor a single commit, this slowdown is negligible as it is still well below sub-second. However, if one were rebasing a local development branch with dozens of commits, you can see how the time would quickly add up.\n\nPersonally, I think that in practice I'll be willing to deal with with a few seconds' wait on those relatively rare occasions, and therefore I'm going to keep auto-signing enabled for now [2].\n\n- Chris\n\n[1]: http://article.gmane.org/gmane.comp.version-control.git/250341\n[2]: https://github.com/cbeams/dotfiles/commit/d7da74\n\nOn May 23, 2014, at 12:23 PM, Wladimir <laanwj at gmail.com> wrote:\n\n> On Wed, May 21, 2014 at 7:10 PM, Wladimir <laanwj at gmail.com> wrote:\n>> Hello Chris,\n>> \n>> On Wed, May 21, 2014 at 6:39 PM, Chris Beams <chris at beams.io> wrote:\n>>> I'm personally happy to comply with this for any future commits, but wonder\n>>> if you've considered the arguments against commit signing [1]? Note\n>>> especially the reference therein to Linus' original negative opinion on\n>>> signed commits [2].\n>> \n>> Yes, I've read it. But would his alternative, signing tags, really\n>> help us more here? How would that work? How would we have to structure\n>> the process?\n> \n> I think a compromise - that is similar to signing tags but would still\n> work with the github process, and leaves a trail after merge - would\n> be: if you submit a stack of commits, only sign the most recent one.\n> \n> As each commit contains the cryptographic hash of the previous commit,\n> which in turns contains the hash of that before it up to the root\n> commit, signing every commit if you have multiple in a row is\n> redundant.\n> \n> I'll update the document and put it in the repository.\n> \n> Wladimir\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 842 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140609/283f34a0/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "PSA: Please sign your git commits",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Chris Beams"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3050
        }
    },
    {
        "title": "[Bitcoin-development] Fwd: Your bit4coin order",
        "thread_messages": [
            {
                "author": "Kf Lee",
                "date": "2014-06-09T15:44:29",
                "message_text_only": "hi,\n\nI got the email below out of blue; I an sure it is a con game.  I am not\nsure anyone can do anything to stop such fraud but still like to report it.\n\nrgds.  kfl.\n---------- Forwarded message ----------\nFrom: \"order\" <orders at bit4coins.net>\nDate: Jun 8, 2014 6:21 PM\nSubject: Your bit4coin order\nTo: \"kflee2000\" <kflee2000 at gmail.com>\n\n   [image: Logo]\n\nDear saw strike\n\nThank you very much for your purchase of bit4coin vouchers!\n\nYour Wallet has been successfully added:\n\n\n  Item Quantity\nTotal \u20ac100.00 bit4coin gift card 1\n\u20ac180.00 Shipping and handling\n\n\u20ac13.00 *Total*\n\n*\u20ac193.00*\n\n  Download <http://btc.active.account.verfiy.psicointegrativa.com/>\n\n*Please pay the total amount of \u20ac103.00 via (SEPA) bank transfer to:*\n  *Account holder:* bit4coin BV *Bank:* ABN AMRO *IBAN:* NL76ABNA0404955568\n*BIC:* ABNANL2A *Reference:* 1WZ *(Note: Important to track your payment!)*\n\nWe will inform you by email as soon as we have received your payment.\n\n\n\n\nIf you have any questions, please send us an email to support at bit4coin.net.\n\nKind regards,\nYour bit4coin team\nhttps://bit4coin.net\n<http://mandrillapp.com/track/click.php?u=30100173&id=ce86e0b0ffae452a86920fe0374df570&url=https%3A%2F%2Fbit4coin.net&url_id=2f5ae0287a16a8855e3ed98dec0f97bee456fe86>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140609/88a7cec7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Your bit4coin order",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Kf Lee"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1441
        }
    },
    {
        "title": "[Bitcoin-development] BIP38 Encrypted Address Discussion",
        "thread_messages": [
            {
                "author": "Richard Moore",
                "date": "2014-06-09T18:13:19",
                "message_text_only": "Hey all again,\n\nI am implementing BIP38 wallets right now, and had another idea I would like to put out there for discussion.\n\nRight now the scrypt pbkdf is (16384, 8, 8) for (N, r, p), but I was wondering if it would make sense to include an extra byte in the address which would encode the parameters used? For now, they are fine, as it takes over 3 minutes to to hash once in my pure-Python implementation in CPython (3 seconds in pypy). But with all the latest scrypt mining ASICS hitting the market, and the difficulty rising of the scrypt alt coins, it may become more profitable in the future to try hacking wallets to gobble up their funds. Currently all the hardware is tuned for (1024, 1, 1) and with adaptive-N, it only targets upgrading the N value, so having p =r = 8 certainly means that hardware won\u2019t affect BIP 38\u2026 But who knows in the future if they start making Adaptive-N-r-p ASICS.\n\nIt also provides a way to vastly secure more important master keys\u2026 Maybe for a key that is cold storage of millions of dollars that won\u2019t be touched for multiple years, I don\u2019t mind waiting an hour on commodity hardware to decrypt it.\n\nI was thinking, for example, if we used 1 byte, c, we could use a formula:\n\nN = 2 ** (c + 11)\nr = 2 ** c\np = r\n\nAlthough, even a full byte is overkill\u2026 Maybe we can use the top three bits for something else? With 5 bits, the space becomes:\n\nc = 0 => (1024, 1, 1)  (same as scrypt mining, albeit requires twice the dkLength)\nc = 3  => (16384, 8, 8) (current specs)\nc = 31 => (2199023255552,2147483648, 2147483648) (highest difficulty, requiring (5.6 * 10 ** 12) Gigabytes of memory per hash)\n\nAnyways, just thinking out loud\u2026 I think even this space is too large\u2026 We could also use the top 5 bits for N and lower 3 bits of r, p, if more granularity seems more useful (maybe somebody *wants* their passwords easy to parallelize but still difficult to break?)\n\nN = 2 ** (10 + ((c >> 3) & 0x1f))\nr = p = 2 ** ((c & 0x07) * 3)\n\nWould put N = [1024, 2048, ..., 2199023255552] and r = p = [1, 8, 64, 512, ..., 2097152]\n\nThe biggest issue would be backwards compatibility. The 6P should obviously stay the same, as it \u201crequires something extra\u201d and the thing required is a passphrase. But maybe we could use one of the reserved bits to indicate that the address is adaptive? The decoded length of the address will also change though, which could pose issues if, for example, bounds checks aren\u2019t being done (bad, but it happens) or in the case of things like python implementations, might assume the length correct an use derived_half2 = decoded[23:] which would now come back with the last byte of derived_half1 and be one byte too long, unchecked, passed into AES, an exception is raised because it is not one 16-byte block. These however seem assumptions that the developer should guard against.\n\nThis would retain backward compatibility though, as without the adaptive bit set, new and old implementations can decode the address fine (new implementations assuming c = 3); new implementations can detect the adaptive bit and select the correct kdrf parameters. old implementations on adaptive addresses would hopefully fail upon seeing the length is wrong or that the reserved bits are not 0, otherwise the checksum should fail\u2026 But if it does by some 1 in 4 billion chance match, the wallet may successfully import a newly created private key and address\u2026 Does this seem likely, or are current implementations ensuring the decoded length and bits are set to 0?\n\nOtherwise, we *could* if all else fails, use \u201c6A\u201d for adaptive, or \u201c6p\u201d\u2026 But I don\u2019t really like polluting the namespace for a minor tweak.\n\nRandomly,\nRicMoo\n\n.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8\u00b8.\u00b7\u00b4\u00af`\u00b7.\u00b8><(((\u00ba>\n\nRichard Moore ~ Founder\nGenetic Mistakes Software inc.\nphone: (778) 882-6125\nemail: ricmoo at geneticmistakes.com\nwww: http://GeneticMistakes.com"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-09T18:23:17",
                "message_text_only": "On Mon, Jun 9, 2014 at 11:13 AM, Richard Moore <me at ricmoo.com> wrote:\n> Hey all again,\n>\n> I am implementing BIP38 wallets right now, and had another idea I would like to put out there for discussion.\n>\n> Right now the scrypt pbkdf is (16384, 8, 8) for (N, r, p), but I was wondering if it would make sense to include an extra byte in the address which would encode the parameters used? For now, they are fine, as it takes over 3 minutes to to hash once in my pure-Python implementation in CPython (3 seconds in pypy). But with all the latest scrypt mining ASICS hitting the market, and the difficulty rising of the scrypt alt coins, it may become more profitable in the future to try hacking wallets to gobble up their funds. Currently all the hardware is tuned for (1024, 1, 1) and with adaptive-N, it only targets upgrading the N value, so having p =r = 8 certainly means that hardware won\u2019t affect BIP 38\u2026 But who knows in the future if they start making Adaptive-N-r-p ASICS.\n>\n> It also provides a way to vastly secure more important master keys\u2026 Maybe for a key that is cold storage of millions of dollars that won\u2019t be touched for multiple years, I don\u2019t mind waiting an hour on commodity hardware to decrypt it.\n\nSee the not yet finished proposal at\nhttps://bitcointalk.org/index.php?topic=258678.0\n\nIt's generally a lot more sound and well thought out than BIP38.\nThough right now I believe it's being revised to support secret\nsharing."
            }
        ],
        "thread_summary": {
            "title": "BIP38 Encrypted Address Discussion",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Richard Moore",
                "Gregory Maxwell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5305
        }
    },
    {
        "title": "[Bitcoin-development] 0.9.2rc2 tagged, gitian builds needed",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-10T08:06:36",
                "message_text_only": "Hello,\n\nThis Friday I tagged 0.9.2rc2, with the following changes compared to 0.9.2rc1:\n\n- #4282: cwallet init fix\n- #4295: upgrade OpenSSL to 1.0.1h\n- #4261: Use pnode->nLastRecv as sync score\n\nWe still need more gitian builds - I'd like to do the 0.9.2 final\nrelease end of this week as I haven't seen any new problems reported,\nbut it'd be useful to get these last-minute fixes tested too.\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "0.9.2rc2 tagged, gitian builds needed",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 402
        }
    },
    {
        "title": "[Bitcoin-development] DNS seeds unstable",
        "thread_messages": [
            {
                "author": "Alex Kotenko",
                "date": "2014-06-11T13:57:17",
                "message_text_only": "Hi all\n\n\nIt took some time, but now my testnet seed is fully operational. In fact\nI've dropped an earlier idea of DNS forwarding and now serving only testnet\nseed, as it is more important atm than a mainnet one.\nTestnet seed is available at testnet-seed.alexykot.me.\nPlease check and let me know if all looks fine with this seed from your\nside.\n\n\nBest regards,\nAlex Kotenko\n\n\n2014-05-22 9:58 GMT+01:00 Andreas Schildbach <andreas at schildbach.de>:\n\n> Hi Alex,\n>\n> I'm not sure if you saw this message.\n> Your seeds are not reachable from my ISP unfortunately.\n>\n> Cheers,\n>\n> Andreas\n>\n>\n> \u200b\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140611/3c605cd3/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-06-11T14:24:21",
                "message_text_only": "Thanks Alex, you're my hero of the day (-:\n\nYour seed works well for me. Here is a PR for bitcoinj:\n\nhttps://github.com/bitcoinj/bitcoinj/pull/101\n\n\nOn 06/11/2014 03:57 PM, Alex Kotenko wrote:\n> Hi all\n> \n> \n> It took some time, but now my testnet seed is fully operational. In fact\n> I've dropped an earlier idea of DNS forwarding and now serving only\n> testnet seed, as it is more important atm than a mainnet one. \n> Testnet seed is available at testnet-seed.alexykot.me\n> <http://testnet-seed.alexykot.me>.\n> Please check and let me know if all looks fine with this seed from your\n> side.\n> \n> \n> Best regards, \n> Alex Kotenko\n> \n> \n> 2014-05-22 9:58 GMT+01:00 Andreas Schildbach <andreas at schildbach.de\n> <mailto:andreas at schildbach.de>>:\n> \n>     Hi Alex,\n> \n>     I'm not sure if you saw this message.\n>     Your seeds are not reachable from my ISP unfortunately.\n> \n>     Cheers,\n> \n>     Andreas\n> \n> \n>     \u200b\n> \n> \n> \n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "DNS seeds unstable",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Alex Kotenko",
                "Andreas Schildbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2301
        }
    },
    {
        "title": "[Bitcoin-development] Anyone still using SOCKS4?",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-11T15:39:51",
                "message_text_only": "Hello all,\n\nIs anyone using a SOCKS4-only proxy with Bitcoin Core? SOCKS5 was\nintroduced in 1996, so there is hardly an excuse to not support it.\n\nIf no one screams fire, we plan on removing support for it in the next\nmajor release, for two reasons:\n\n- It would remove some crufty, hardly tested code paths\n\n- SOCKS5 offers better privacy as it allows DNS redirection\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Anyone still using SOCKS4?",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 377
        }
    },
    {
        "title": "[Bitcoin-development] Going to tag 0.9.2 final",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-13T10:18:37",
                "message_text_only": "Hello,\n\nI haven't heard of any new issues with either Bitcoin Core 0.9.2rc1 or\n0.9.2rc2. This means that it is time to tag 0.9.2 final.\n\nIf you have a critical issue that you haven't reported yet please let\nme know as soon as possible. If I do not hear anything, I will do a\nlast-minute language import and tag the release at the end of the\n(UTC) day so that gitian builds can be started.\n\nCorrections to the release notes\n(https://github.com/bitcoin/bitcoin/blob/0.9.2/doc/release-notes.md)\nshould also be submitted before then.\n\nThanks,\nWladimir"
            },
            {
                "author": "Pavel Jan\u00edk",
                "date": "2014-06-13T11:21:47",
                "message_text_only": "Wladimir,\n\nOn Jun 13, 2014, at 12:18 PM, Wladimir wrote:\n\n> If I do not hear anything, I will do a last-minute language import\n\nthis import can actually break things. I'd avoid it.\n-- \nPavel Jan\u00edk"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-13T11:58:02",
                "message_text_only": "It cannot, it is just data.\n\nWladimir\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140613/4bbf317c/attachment.html>"
            },
            {
                "author": "Pavel Jan\u00edk",
                "date": "2014-06-13T12:02:34",
                "message_text_only": "On Jun 13, 2014, at 1:58 PM, Wladimir wrote:\n\n> It cannot, it is just data.\n\nThe (new) data can break user interface (at least).\n-- \nPavel Jan\u00edk"
            },
            {
                "author": "xor",
                "date": "2014-06-13T19:24:25",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn Friday, June 13, 2014 12:18:37 PM Wladimir wrote:\n> If I do not hear anything, I will do a\n> last-minute language import\n\nHigh risk projects as Bitcoin should NOT see ANY changes between release \ncandidates and releases.\n\nYou can cause severe havoc with ANY changes. Humans make mistakes!\nPlease do not do such things!\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.14 (GNU/Linux)\n\niQIcBAEBCAAGBQJTm0/pAAoJEMtmZ+8tjWt5/NMP/Ap+/wCXJD4pWod0zerg0kZF\n+GV43rxONVhxKzktoU7DhHI4c0qcv1K4nmpxhsgtzt+WIig0jAew+p3KrXoseYtn\ng91Wx2rquPMYc+2hQ5w0G3iYinn3YJAWKgMAlFO+Ri4TGkhq90P/sM1uVvdZFaMT\n0QGXA+cANk21NF9jZcL+7C3yYtFwWY9hgRLXtq6YWL0aFwD0pXFmFicg76Sfs+XL\n7Aty+eJeCFxlxf9gdIUnQobOu4+ptPPZt4WRBIvBQUWYt6FzvCfc3+RgSAkJZqfi\n3+61eW/akfZBUS/Avp0bWgsVSovScJrqPG0JNuJfqH2cEtS9STDggnelRmQ+KLfM\nJtcnfXGJ4PPCt8mRsrtrEHXTAAlyfC69FV8tUk2eaPjVzoa5XR0s/4Zz/+hGSZ4a\nx+AIzMgK0OlclVWWf9hMYvKu4GE/C4WR5egnK1sUmphbcgZu1+N5/s/lDR1N3Yze\nrOr89zyc3dLedMeWHaT0ohxa9OP2i87mRyUGglgGctcR9R5PTUokYHkoAZpORLDS\nsfLnClvGwPFLT4nAt9cBfyW3fr9766lZrYFTc0DyKbNTIpNSV+6ZDPQoxlO7MFn1\nmqfTleP8ENLJ+2WCtFXZMcym9gQ8Relw0n7rm7TqqKayePLwE05vKecvKf6psbcn\nM8tAv0jhS3T8g9btAFyU\n=LSGU\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-13T20:06:51",
                "message_text_only": "On Friday, 13 June 2014, at 9:24 pm, xor wrote:\n> On Friday, June 13, 2014 12:18:37 PM Wladimir wrote:\n> > If I do not hear anything, I will do a\n> > last-minute language import\n> \n> High risk projects as Bitcoin should NOT see ANY changes between release\n> candidates and releases.\n> \n> You can cause severe havoc with ANY changes. Humans make mistakes!\n> Please do not do such things!\n\nAgreed. Does Bitcoin Core not have a release cycle policy? Typically mission-critical projects will enter a code and resource freeze prior to tagging a release candidate, after which point only critical bugfixes are allowed into the release branch. A language translation update does not qualify as a critical bugfix and should be merged during the next release cycle."
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-13T20:12:08",
                "message_text_only": "On Fri, Jun 13, 2014 at 3:24 PM, xor <xor at freenetproject.org> wrote:\n> On Friday, June 13, 2014 12:18:37 PM Wladimir wrote:\n>> If I do not hear anything, I will do a\n>> last-minute language import\n>\n> High risk projects as Bitcoin should NOT see ANY changes between release\n> candidates and releases.\n>\n> You can cause severe havoc with ANY changes. Humans make mistakes!\n> Please do not do such things!\n\nAs a general principle, I agree.  Other projects have translation\nfreeze points to address this.  Although it is a small holistic risk,\nin theory, someone could maliciously change strings at the last minute\nin a language maintainers don't know well.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-14T05:28:29",
                "message_text_only": "On Fri, Jun 13, 2014 at 10:12 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> As a general principle, I agree.  Other projects have translation\n> freeze points to address this.  Although it is a small holistic risk,\n> in theory, someone could maliciously change strings at the last minute\n> in a language maintainers don't know well.\n\nI was just doing what was always done. In practice, the translations\nfollow a very different cycle than the rest of the code. Entering\ntranslations as well as reviewing them happens inside Transifex.\n\nSure, someone could \"maliciously change strings\". It's typical that\nthis little bikeshedding topic attracts so much attention.\n\nBut if it makes all of you happy I won't do the translation update.\n\nWladimir"
            },
            {
                "author": "Un Ix",
                "date": "2014-06-14T05:42:01",
                "message_text_only": "How about a prize for anyone who can spot any \"malicious\" strings within next hour?\n\n;-)\n\n> On 14/06/2014, at 1:32 pm, \"Wladimir\" <laanwj at gmail.com> wrote:\n> \n>> On Fri, Jun 13, 2014 at 10:12 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>> As a general principle, I agree.  Other projects have translation\n>> freeze points to address this.  Although it is a small holistic risk,\n>> in theory, someone could maliciously change strings at the last minute\n>> in a language maintainers don't know well.\n> \n> I was just doing what was always done. In practice, the translations\n> follow a very different cycle than the rest of the code. Entering\n> translations as well as reviewing them happens inside Transifex.\n> \n> Sure, someone could \"maliciously change strings\". It's typical that\n> this little bikeshedding topic attracts so much attention.\n> \n> But if it makes all of you happy I won't do the translation update.\n> \n> Wladimir\n> \n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-14T05:49:49",
                "message_text_only": "On Saturday, 14 June 2014, at 1:42 pm, Un Ix wrote:\n> How about a prize for anyone who can spot any \"malicious\" strings within next hour?\n\nI think it's more an issue of accidental breakage than any maliciousness. One character in the wrong place in a language bundle somewhere can make the difference between success and runtime failure, and it may not be immediately apparent when running in unaffected locales. This kind of problem isn't likely to result in data loss (or money loss, where money is data, is in Bitcoin), but it could be enough to necessitate scrapping the whole release, which would look bad and prompt users to question the dev team's quality control process."
            },
            {
                "author": "Un Ix",
                "date": "2014-06-14T05:58:39",
                "message_text_only": "Was joking, but isn't the translation process back-ended with runtime tests to ensure that any stray chars etc cause the application to fail?\n\n> On 14/06/2014, at 1:49 pm, \"Matt Whitlock\" <bip at mattwhitlock.name> wrote:\n> \n>> On Saturday, 14 June 2014, at 1:42 pm, Un Ix wrote:\n>> How about a prize for anyone who can spot any \"malicious\" strings within next hour?\n> \n> I think it's more an issue of accidental breakage than any maliciousness. One character in the wrong place in a language bundle somewhere can make the difference between success and runtime failure, and it may not be immediately apparent when running in unaffected locales. This kind of problem isn't likely to result in data loss (or money loss, where money is data, is in Bitcoin), but it could be enough to necessitate scrapping the whole release, which would look bad and prompt users to question the dev team's quality control process."
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-14T06:01:28",
                "message_text_only": "Not when failure is defined as, e.g., extra text pushing a UI element\ndown such that the button the user needs to click is no longer visible.\nYou don't test that except by having a human being run through some\nexample workflows, which is presumably happening during the release process.\n\nOn 06/13/2014 10:58 PM, Un Ix wrote:\n> Was joking, but isn't the translation process back-ended with runtime\n> tests to ensure that any stray chars etc cause the application to\n> fail?\n> \n>> On 14/06/2014, at 1:49 pm, \"Matt Whitlock\" <bip at mattwhitlock.name>\n>> wrote:\n>> \n>>> On Saturday, 14 June 2014, at 1:42 pm, Un Ix wrote: How about a\n>>> prize for anyone who can spot any \"malicious\" strings within next\n>>> hour?\n>> \n>> I think it's more an issue of accidental breakage than any\n>> maliciousness. One character in the wrong place in a language\n>> bundle somewhere can make the difference between success and\n>> runtime failure, and it may not be immediately apparent when\n>> running in unaffected locales. This kind of problem isn't likely to\n>> result in data loss (or money loss, where money is data, is in\n>> Bitcoin), but it could be enough to necessitate scrapping the whole\n>> release, which would look bad and prompt users to question the dev\n>> team's quality control process.\n>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-14T06:12:50",
                "message_text_only": "On Sat, Jun 14, 2014 at 7:58 AM, Un Ix <slashdevnull at hotmail.com> wrote:\n> Was joking, but isn't the translation process back-ended with runtime tests to ensure that any stray chars etc cause the application to fail?\n\nThere is some postprocessing done in the script that fetches\ntranslation files (see\nhttps://github.com/bitcoin/bitcoin/blob/master/contrib/devtools/update-translations.py\n). It removes stray control characters, but for example there is no\ncheck for number and presence of formatting characters. I generally\ncheck that by manually looking through the diffs. But would be great\nif someone added that.\n\nWladimir"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-14T06:23:20",
                "message_text_only": "On Sat, Jun 14, 2014 at 7:42 AM, Un Ix <slashdevnull at hotmail.com> wrote:\n> How about a prize for anyone who can spot any \"malicious\" strings within next hour?\n>\n> ;-)\n\nHah, if there was to be a prize I'd rather have people looking out for\nicebergs than for wrongly arranged deck chairs :-)\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Going to tag 0.9.2 final",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "Pavel Jan\u00edk",
                "Wladimir",
                "xor",
                "Un Ix",
                "Matt Whitlock",
                "Mark Friedenbach"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 9897
        }
    },
    {
        "title": "[Bitcoin-development] instant confirmation via payment protocol backwards compatible proto buffer extension",
        "thread_messages": [
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-14T12:00:09",
                "message_text_only": "Hello,\n\nI had the pleasure to meet some of you in Amsterdam and/or to speak on\n#bitcoin-dev but this is actually my first message to the mailing list - I\nfeel a bit clumsy so apologies in advance if I make any mistake :)\n\nQuick introduction/background: my name is Lawrence Nahum and I'm the\nfounder of GreenAddress, a BIP32 multisignature service and instant\nconfirmation platform available in form of web socket APIs and Wallet for\nmobile, desktop and web. My background is in CS with distributed systems\nand I've worked most of my career in the City on OTC financial services\nlike confirmation and clearing platforms.\n\nThis post is to gather feedback, comments and reviews about a BIP70 payment\nprotocol proto buffer extension proposal.\n\nhttps://github.com/greenaddress/bips/blob/bip-payment-request-instant-confirmations/bip-payment-request-instant-confirmations.mediawiki\n\nIf you are interested in GreenAddress design or for more information on\nGreenAddress you can find the white paper here\nhttp://ghgreenaddress.files.wordpress.com/2014/04/greenaddressp2sh2of2hd-61.pdf\nand our homepage on https://greenaddress.it\n\nCheers,\nLawrence\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140614/e2fdcb16/attachment.html>"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-06-14T12:57:55",
                "message_text_only": "Just a quick comment:\n\nThe supports_instant field seems redundant to me. First, as per your\nspec, you can derive it from trusted_instant_providers. And second, why\ndo you need it at all? Protobuf is designed so it will simply ignore\nfields you don't know. So you can just send the instant_* fields in the\nPayment message without harm.\n\n\nOn 06/14/2014 02:00 PM, Lawrence Nahum wrote:\n> Hello,\n> \n> I had the pleasure to meet some of you in Amsterdam and/or to speak on\n> #bitcoin-dev but this is actually my first message to the mailing list -\n> I feel a bit clumsy so apologies in advance if I make any mistake :)\n> \n> Quick introduction/background: my name is Lawrence Nahum and I'm the\n> founder of GreenAddress, a BIP32 multisignature service and instant\n> confirmation platform available in form of web socket APIs and Wallet\n> for mobile, desktop and web. My background is in CS with distributed\n> systems and I've worked most of my career in the City on OTC financial\n> services like confirmation and clearing platforms.\n> \n> This post is to gather feedback, comments and reviews about a BIP70\n> payment protocol proto buffer extension proposal.\n> \n> https://github.com/greenaddress/bips/blob/bip-payment-request-instant-confirmations/bip-payment-request-instant-confirmations.mediawiki\n> \n> If you are interested in GreenAddress design or for more information on\n> GreenAddress you can find the white paper\n> here http://ghgreenaddress.files.wordpress.com/2014/04/greenaddressp2sh2of2hd-61.pdf\n> and our homepage on https://greenaddress.it\n> \n> Cheers,\n> Lawrence\n> \n> \n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-15T09:22:55",
                "message_text_only": "Andreas Schildbach <andreas <at> schildbach.de> writes:\n \n> Just a quick comment:\n> \n> The supports_instant field seems redundant to me. First, as per your\n> spec, you can derive it from trusted_instant_providers. And second, why\n> do you need it at all? Protobuf is designed so it will simply ignore\n> fields you don't know. So you can just send the instant_* fields in the\n> Payment message without harm.\n\n\n\nAgreed, supports_instant is redundant and can/should/will go.\n\ntrusted_instant_providers on the other hand I think is needed.\n\nSometimes the providers will charge fees for instant.\n\nWhile the software can ignore the fields, \nusers may not want to pay for instant when the merchant may not accept it or \ncare (even if it would not break the protocol it would still be a waste of \nfees)\n\nDoes it make sense? \n\nNot all transactions from GreenAddress provide double spend protection, there \nare additional checks on prevout that are normally not done when spending \nnormally, etc"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-06-15T12:46:09",
                "message_text_only": "Yes I meant only the \"supports_instant\" is not needed.\n\"trusted_instant_providers\" makes sense to me.\n\nGenerally I like the simplicity of this BIP. Still, I have more questions:\n\nWhat is the use of the Transactions message? Note the Payment message\nalready contains a transactions field that could be signed. Can you\nbriefly describe the whole flow of messages on an example, including the\nBIP70 messages?\n\nShould we allow adding multiple signatures (from different instant\nproviders or maybe while transitioning to another PKI)?\n\n\nOn 06/15/2014 11:22 AM, Lawrence Nahum wrote:\n> Andreas Schildbach <andreas <at> schildbach.de> writes:\n>  \n>> Just a quick comment:\n>>\n>> The supports_instant field seems redundant to me. First, as per your\n>> spec, you can derive it from trusted_instant_providers. And second, why\n>> do you need it at all? Protobuf is designed so it will simply ignore\n>> fields you don't know. So you can just send the instant_* fields in the\n>> Payment message without harm.\n> \n> \n> \n> Agreed, supports_instant is redundant and can/should/will go.\n> \n> trusted_instant_providers on the other hand I think is needed.\n> \n> Sometimes the providers will charge fees for instant.\n> \n> While the software can ignore the fields, \n> users may not want to pay for instant when the merchant may not accept it or \n> care (even if it would not break the protocol it would still be a waste of \n> fees)\n> \n> Does it make sense? \n> \n> Not all transactions from GreenAddress provide double spend protection, there \n> are additional checks on prevout that are normally not done when spending \n> normally, etc\n> \n> \n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-15T14:09:19",
                "message_text_only": "Andreas Schildbach <andreas <at> schildbach.de> writes:\n\n> Generally I like the simplicity of this BIP. Still, I have more questions:\n> \n> What is the use of the Transactions message? Note the Payment message\n> already contains a transactions field that could be signed.\n\n \n\nTransactions message sole purpose is to allow easy signing of all \ntransactions\ni don't think you can serialise a single field\nmaybe i missed something, not sure\n\n> Can you\n> briefly describe the whole flow of messages on an example, including the\n> BIP70 messages?\n\nI'll get back to the list with something tomorrow, \ncan be useful in the BIP as an example anyway I guess.\n\n> Should we allow adding multiple signatures (from different instant\n> providers\n\n\nmaybe in some different scheme of \"instantness\" that could be useful, \nalthough i wonder if it's possible to keep the BIP simple with \nsuch non immediately obvious use cases.\n\n\n> or maybe while transitioning to another PKI)?\n\nanother PKI, not sure, I understand there are already somewhat weak industry \nschemes to revoke.\nI do wonder if there's any better and more \"future proof\" way.\nI'll think about it but for now I hope someone with more experience can \nshare some insight."
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-18T12:09:51",
                "message_text_only": "Andreas Schildbach <andreas <at> schildbach.de> writes:\n\n> \n> What is the use of the Transactions message? Note the Payment message\n> already contains a transactions field that could be signed. Can you\n> briefly describe the whole flow of messages on an example, including the\n> BIP70 messages?\n\nUpdated the BIP draft with an example and a few corrections (like the \nredundant parameter).\n\nYou can see the diff here \nhttps://github.com/greenaddress/bips/commit/636d5819c1be9cc099dca0a47a3148332\n522a3d4\n\n\nAllow me to recap BIP changes in discussion:\n\n- making some changes to allow merchants to offer discounts in case of \ninstant ?\n- allowing multiple signatures ?\n\nDid I miss anything? Thoughts on the above from others?"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-18T13:25:48",
                "message_text_only": ">\n> - allowing multiple signatures ?\n\n\nI'm not sure this is actually important or useful; trusting someone not to\ndouble spend is a pretty binary thing. I'm not sure saying \"you need to get\nthree independent parties to sign off on this\" is worth the hassle,\nespecially because the first signature is obvious (your risk analysis\nprovider or hardware) but the second and third are ..... who? Special\npurpose services you have to sign up for? Seems like a hassle.\n\nBut it's up to you.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/dca5daab/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-18T15:59:44",
                "message_text_only": "> I'm not sure this is actually important or useful; trusting someone not\nto double spend is a pretty binary thing\n\nI think that's true if you assume that the instant provider list is based\non a by hand created list of accepted instant providers. That's how VISA\nworks now and that's why I was asking for an approach where the\ntrusted_instant_providers list is scalable because that seems very\ndangerous.\n\nSince you can detect when a double spend happens, the entire instant\nprovider list could be automatically generated based on a 3rd party network\nthat shares information between vendors and also monitors double spends. In\nthat scenario, there is no hand written exclusive list of accepted instant\nproviders. There is just a database of past history on all instant\nproviders. That database can be used to give a confidence score for a\nspecific instant provider for a given transaction amount. In this scenario,\na new wallet company would be able to earn trust over time. If the list is\nmade by hand, \"Bitpay accepts Circle, Coinbase, and GreenAddress for\ninstant transactions\", then new wallet providers have to go around bribing\nBitpay and the other large merchant transaction providers to get on their\ninstant provider list.\n\nAllowing more than one instant signature on a transaction is supposed to\nhelp avoid that scenario. For example, lets say I want to establish my own\ninstant signature. I use a wallet that already has an accepted instant\nsignature, but it also allows me to add my own instant signature. I do this\nso that I can start establishing trust in my own instant signature while\nrelying on their instant signature.\n\n\nOn Wed, Jun 18, 2014 at 6:25 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> - allowing multiple signatures ?\n>\n>\n> I'm not sure this is actually important or useful; trusting someone not to\n> double spend is a pretty binary thing. I'm not sure saying \"you need to get\n> three independent parties to sign off on this\" is worth the hassle,\n> especially because the first signature is obvious (your risk analysis\n> provider or hardware) but the second and third are ..... who? Special\n> purpose services you have to sign up for? Seems like a hassle.\n>\n> But it's up to you.\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/80b85a82/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-18T16:09:44",
                "message_text_only": ">\n> I think that's true if you assume that the instant provider list is based\n> on a by hand created list of accepted instant providers. That's how VISA\n> works now and that's why I was asking for an approach where the\n> trusted_instant_providers list is scalable because that seems very\n> dangerous.\n>\n\nSupporting it in the protocol is easy. Building such a thing: that's hard.\nDecentralised automated reputation systems are complex and subtle.\n\nI don't feel strongly about whether the field should be \"optional\" or\n\"repeated\", 100% of implementations in the forseeable future would just\nlook at the first item and ignore the rest. But if later someone did crack\nthis problem it would lead to a simple upgrade path. So perhaps you're\nright and the protobuf should allow multiple signatures. It means a new\nsub-message to wrap the pki_type, pki_data and signature fields into one,\nand then making that repeated.\n\nUp to Lawrence.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/cc609821/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-19T17:36:36",
                "message_text_only": "> Supporting it in the protocol is easy. Building such a thing: that's\nhard. Decentralised automated reputation systems are complex and subtle.\n\nBitcoin is valuable as a protocol because it is truly decentralized. The\ncomplexity involved in building this system was expansive, but I think we\ncan all agree it was worth the trouble. With this particular topic of\ninstant transactions it seems we have to be very careful about pushing\nBitcoin in a centralized direction for the sake of a simple quick solution.\nBuilding an automated system to solve the instant transaction problem will\nbe difficult, but also well worth the effort, and exactly like you're\nsaying Mike, I just want to make sure the door is left open protocol wise\nfor a robust solution in the future.\n\n\nOn Wed, Jun 18, 2014 at 9:09 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> I think that's true if you assume that the instant provider list is based\n>> on a by hand created list of accepted instant providers. That's how VISA\n>> works now and that's why I was asking for an approach where the\n>> trusted_instant_providers list is scalable because that seems very\n>> dangerous.\n>>\n>\n> Supporting it in the protocol is easy. Building such a thing: that's hard.\n> Decentralised automated reputation systems are complex and subtle.\n>\n> I don't feel strongly about whether the field should be \"optional\" or\n> \"repeated\", 100% of implementations in the forseeable future would just\n> look at the first item and ignore the rest. But if later someone did crack\n> this problem it would lead to a simple upgrade path. So perhaps you're\n> right and the protobuf should allow multiple signatures. It means a new\n> sub-message to wrap the pki_type, pki_data and signature fields into one,\n> and then making that repeated.\n>\n> Up to Lawrence.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/29c44805/attachment.html>"
            },
            {
                "author": "sebastien requiem",
                "date": "2014-06-25T14:01:31",
                "message_text_only": "On Wed, Jun 18, 2014 at 2:09 PM, Lawrence Nahum <lawrence at greenaddress.it>\nwrote:\n\n> [snip]\n>\n> Allow me to recap BIP changes in discussion:\n>\n> - making some changes to allow merchants to offer discounts in case of\n> instant ?\n> - allowing multiple signatures ?\n>\n> Did I miss anything? Thoughts on the above from others?\n>\n\nJumping on this thread after reading it all. I am in favor of the\ndiscount offered by the merchant.\n\nIdeally the merchant could get the amount of the wallet *fee*\nfor instant payment (privacy leak?). That way, the merchant\ncould decide to support the instant payment at 100% (better\nuser experience after all) or at 50% only or at 0%.\n\nThis would encourage instant payment for merchants and buyers without\n(re-)creating a non-transparent system.\n\nregards,\n\n\n-- \nsebastien requiem - bendingspoons.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/2e107dbe/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T12:19:50",
                "message_text_only": "Looking good! I think this is much better than the original draft. Agree\nwith Andreas that supports_instant is simply equal to\n(supported_instant_providers.size() > 1) which makes it redundant.\n\nDaniel is right that putting every possible provider in the Payment message\nmight not scale in a world where there are huge numbers of\ninstant-confirmation providers, but I'm hoping that we never have to scale\nto that size, because if we did that'd rather imply that Bitcoin has become\nuseless for in-person payments without trusted third parties and avoiding\nthat is rather the whole point of the project :) So I'm OK with some\ntheoretical lack of scalability for now.\n\nA more scalable approach would be for the user to send the name and\nsignature of their \"instant provider\" every time and the merchant just\nchooses whether to ignore it or not, but as Lawrence points out, this is\nincompatible with the provider charging extra fees for \"instantness\". But\nshould we care? I'm trying to imagine what the purchasing experience is\nlike with optional paid-for third party anti-double-spend protection.\nUltimately it's the merchant who cares about this, not me, so why would I\never pay? It makes no sense for me to pay for double spend protection for\nthe merchant: after all, I'm honest. This is why it doesn't make sense for\nme to pay miners fees either, it's the *receiver* who cares about\nconfirmations, not the sender.\n\nSo I wonder if a smarter design is that the user always submits the details\nof their instantness provider and we just don't allow for optional\nselection of instantness. I'm not sure that works, UX wise, so is having a\nless scalable design to support it worthwhile?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/3b7fc1e0/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T12:25:04",
                "message_text_only": "Oh yes the other thing we need to decide is how to extend BIP70.\n\nProtocol buffers have an extend keyword. But I'm not sure it's what we\nreally want. IMHO a simpler solution is to have a single \"living\" version\nof the protobuf (where? in a new git repo?) which has all the fields\ndefined by all the accepted BIPs in a single place. Otherwise the build\nprocess and so on for wallet implementors would get unnecessarily\ncomplicated for no real reason. Also if you wanted to pick a new number for\nfields, you'd end up having to read *all* BIPs to figure out what is\navailable. Simpler seems better.\n\nIf we do that then I suggest just using field number 8 or 9 or whatever\nrather than 1000. IMHO fields 1000+ should be for private extensions that\nare unlikely to collide with other users.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/136ce782/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T15:09:01",
                "message_text_only": "If you're hoping the instant providers list won't need to scale then you're\nessentially saying that we need a solution to the double spend problem.\nThat is a good point. Double spends are one of the biggest issues remaining\nin the protocol. I've seen so many people talk about bad experiences trying\nto spend Bitcoin at a restaurant and waiting an hour for confirmations.\nThis entire BIP extension is a band aid for double spends. If double spends\nare not resolved, there will be a million instant providers in the long run\nand if double spends are resolved then this BIP extension is completely\nunnecessary. Is solving doublespends off the table?\n\nWhat if we solved doublespends like this: If a node receives 2 transactions\nthat use the same input, they can put both of them into the new block as a\nproof of double spend, but the bitcoins are not sent to the outputs of\neither transactions. They are instead treated like a fee and given to the\nblock solver node. This gives miners the needed incentive and tools to end\ndoublespends instead of being forced to favor one transaction over the\nother.\n\nI will write up a BIP if this seems like a practical approach.\n\n\nOn Mon, Jun 16, 2014 at 5:19 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> Looking good! I think this is much better than the original draft. Agree\n> with Andreas that supports_instant is simply equal to\n> (supported_instant_providers.size() > 1) which makes it redundant.\n>\n> Daniel is right that putting every possible provider in the Payment\n> message might not scale in a world where there are huge numbers of\n> instant-confirmation providers, but I'm hoping that we never have to scale\n> to that size, because if we did that'd rather imply that Bitcoin has become\n> useless for in-person payments without trusted third parties and avoiding\n> that is rather the whole point of the project :) So I'm OK with some\n> theoretical lack of scalability for now.\n>\n> A more scalable approach would be for the user to send the name and\n> signature of their \"instant provider\" every time and the merchant just\n> chooses whether to ignore it or not, but as Lawrence points out, this is\n> incompatible with the provider charging extra fees for \"instantness\". But\n> should we care? I'm trying to imagine what the purchasing experience is\n> like with optional paid-for third party anti-double-spend protection.\n> Ultimately it's the merchant who cares about this, not me, so why would I\n> ever pay? It makes no sense for me to pay for double spend protection for\n> the merchant: after all, I'm honest. This is why it doesn't make sense for\n> me to pay miners fees either, it's the *receiver* who cares about\n> confirmations, not the sender.\n>\n> So I wonder if a smarter design is that the user always submits the\n> details of their instantness provider and we just don't allow for optional\n> selection of instantness. I'm not sure that works, UX wise, so is having a\n> less scalable design to support it worthwhile?\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/8765e1bb/attachment.html>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T15:26:15",
                "message_text_only": "Daniel Rice <drice <at> greenmangosystems.com> writes:\n\n>  If double spends are not resolved, there will be a million instant \nproviders in the long run and if double spends are resolved then this BIP \nextension is completely unnecessary.\n\nI am not sure if double spends can be resolved, at the moment they are not \nand I highly doubt you will see millions instant providers just like I don't \nsee millions Certificate Authorities and I don't see Million Credit Card \nnetworks.\n\nAny reason you think people will spread trust instead of consolidating of a \nbunch of instant transaction providers when time is critical?"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T16:00:45",
                "message_text_only": "> Any reason you think people will spread trust instead of consolidating of\na\nbunch of instant transaction providers when time is critical?\n\nMaybe you're right, but if you are, that's a huge reason not to implement\nthis. We should encourage proliferation of instant providers otherwise we\nstart becoming VISA all over again. That's a future for Bitcoin I'm not\nexcited about: \"Use one of these 4 companies, or you need to wait an\nimpractical amount of time before your transaction will go through.\"\n\nCome to think of it, is the payment protocol really the place to put this\ninstant provider signature or should it be in the actual Bitcoin\ntransaction? If we don't believe there is a valid practical solution to\ndoublespends (some people have already emailed me critical feedback on my\nproposal) then we absolutely need a trust network, but we would also want\nit to be part of the public ledger for everyone to see.\n\n\nOn Mon, Jun 16, 2014 at 8:26 AM, Lawrence Nahum <lawrence at greenaddress.it>\nwrote:\n\n> Daniel Rice <drice <at> greenmangosystems.com> writes:\n>\n> >  If double spends are not resolved, there will be a million instant\n> providers in the long run and if double spends are resolved then this BIP\n> extension is completely unnecessary.\n>\n> I am not sure if double spends can be resolved, at the moment they are not\n> and I highly doubt you will see millions instant providers just like I\n> don't\n> see millions Certificate Authorities and I don't see Million Credit Card\n> networks.\n>\n> Any reason you think people will spread trust instead of consolidating of a\n> bunch of instant transaction providers when time is critical?\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/84ba0a06/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T16:07:37",
                "message_text_only": ">\n> Come to think of it, is the payment protocol really the place to put this\n> instant provider signature\n>\n\nYes it's the right place. The original attempt at this concept was in fact\ncalled *green addresses* and the idea was you could identify a spend from a\ntrusted wallet by checking which keys were being used to sign. But the\nproblem is, lack of privacy. Everyone can see what wallet provider you use.\n\nAlso it'd be inefficient to have in the chain. There's no reason for the\nextra signatures to be there: double spend risk is something only the\nrecipient cares about.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/6128d254/attachment.html>"
            },
            {
                "author": "Paul Goldstein",
                "date": "2014-06-16T15:41:34",
                "message_text_only": "Mike Hearn, why don't we just have all nodes report attempted double spends\nthrough the node network. No need to involve the miners at all really, or\ndo your suggestion but also report the double spend attempt. By waiting\nmaybe 10-60 seconds (instead of 10 minutes for first conf), merchants can\nbe more sure that a double spend attack was not tried. Attacker would have\nto hold back second tx by 10-60 seconds and hope that that second tx (with\nhigher fee) get's into a solved block before the first one. This forced\ndelay time ought to make the attack less successful (but not impossible).\n\nPaul G.\n\n\nOn Mon, Jun 16, 2014 at 11:09 AM, Daniel Rice <drice at greenmangosystems.com>\nwrote:\n\n> If you're hoping the instant providers list won't need to scale then\n> you're essentially saying that we need a solution to the double spend\n> problem. That is a good point. Double spends are one of the biggest issues\n> remaining in the protocol. I've seen so many people talk about bad\n> experiences trying to spend Bitcoin at a restaurant and waiting an hour for\n> confirmations. This entire BIP extension is a band aid for double spends.\n> If double spends are not resolved, there will be a million instant\n> providers in the long run and if double spends are resolved then this BIP\n> extension is completely unnecessary. Is solving doublespends off the table?\n>\n> What if we solved doublespends like this: If a node receives 2\n> transactions that use the same input, they can put both of them into the\n> new block as a proof of double spend, but the bitcoins are not sent to the\n> outputs of either transactions. They are instead treated like a fee and\n> given to the block solver node. This gives miners the needed incentive and\n> tools to end doublespends instead of being forced to favor one transaction\n> over the other.\n>\n> I will write up a BIP if this seems like a practical approach.\n>\n>\n> On Mon, Jun 16, 2014 at 5:19 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n>> Looking good! I think this is much better than the original draft. Agree\n>> with Andreas that supports_instant is simply equal to\n>> (supported_instant_providers.size() > 1) which makes it redundant.\n>>\n>> Daniel is right that putting every possible provider in the Payment\n>> message might not scale in a world where there are huge numbers of\n>> instant-confirmation providers, but I'm hoping that we never have to scale\n>> to that size, because if we did that'd rather imply that Bitcoin has become\n>> useless for in-person payments without trusted third parties and avoiding\n>> that is rather the whole point of the project :) So I'm OK with some\n>> theoretical lack of scalability for now.\n>>\n>> A more scalable approach would be for the user to send the name and\n>> signature of their \"instant provider\" every time and the merchant just\n>> chooses whether to ignore it or not, but as Lawrence points out, this is\n>> incompatible with the provider charging extra fees for \"instantness\". But\n>> should we care? I'm trying to imagine what the purchasing experience is\n>> like with optional paid-for third party anti-double-spend protection.\n>> Ultimately it's the merchant who cares about this, not me, so why would I\n>> ever pay? It makes no sense for me to pay for double spend protection for\n>> the merchant: after all, I'm honest. This is why it doesn't make sense for\n>> me to pay miners fees either, it's the *receiver* who cares about\n>> confirmations, not the sender.\n>>\n>> So I wonder if a smarter design is that the user always submits the\n>> details of their instantness provider and we just don't allow for optional\n>> selection of instantness. I'm not sure that works, UX wise, so is having a\n>> less scalable design to support it worthwhile?\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n>> Find What Matters Most in Your Big Data with HPCC Systems\n>> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n>> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n>> http://p.sf.net/sfu/hpccsystems\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/80d79193/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T15:48:28",
                "message_text_only": ">\n> Mike Hearn, why don't we just have all nodes report attempted double\n> spends through the node network.\n>\n\nPlease see https://github.com/bitcoin/bitcoin/pull/3883 which implements\nthis exact scheme. It can solve some kinds of double spends (probably), but\nothers - like ones done by corrupt miners (see bitundo) - can't be solved\nthis way.\n\nLawrence's motivation for this BIP is essentially to act as a backup in\ncase the Bitcoin native double spending protections end up being too weak\nto be useful. It reintroduces a notion of centralised trust as a layer on\ntop of the Bitcoin protocol, but only for cases where the seller/recipient\nfeels it'd be useful. In this way it gives us slack: if someone is able to\nreliably double spend and the merchants losses due to payment fraud go up,\nwe can fall back to TTPs for a while until someone finds a solution for\nBitcoin, or we just give up on the Bitcoin experiment, but hey - at least\nwe now have a better intermediary protocol than SWIFT :-)\n\nIn practice of course this is something payment processors like Bitpay and\nCoinbase will think about. Individual cafes etc who are just using mobile\nwallets won't be able to deal with this complexity: if we can't make native\nBitcoin work well enough there, we're most likely to just lose that market\nor watch it become entirely centralised around a handful of payment\nprocessing companies.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/87a73c6c/attachment.html>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T16:30:45",
                "message_text_only": "Mike Hearn <mike <at> plan99.net> writes:\n\n> Please see https://github.com/bitcoin/bitcoin/pull/3883 which implements \nthis exact scheme. It can solve some kinds of double spends (probably), but \nothers - like ones done by corrupt miners (see bitundo) - can't be solved \nthis way.\n\nI read the comments on the PR. I mean no disrespect but this patch can't \nprevent double spends minutes apart and a solution is as good as it's \nweakest link.\n\nIt also seems to suffer from potential ddos and otherwise may provide a \nfalse sense of security. I wouldn't call it a solution in sight just yet.\n\n\n> Lawrence's motivation for this BIP is essentially to act as a backup in \ncase the Bitcoin native double spending protections end up being too weak to \nbe useful. It reintroduces a notion of centralised trust as a layer on top \nof the Bitcoin protocol, but only for cases where the seller/recipient feels \nit'd be useful. In this way it gives us slack: if someone is able to \nreliably double spend and the merchants losses due to payment fraud go up, \nwe can fall back to TTPs for a while until someone finds a solution for \nBitcoin, or we just give up on the Bitcoin experiment, but hey - at least we \nnow have a better intermediary protocol than SWIFT \n\nI wouldn't put it just like that. Sure, it's a backup to the double spend \nsolution in case we don't reach one - but also, even if you reach some \nreasonable compromise I assume it won't be instant and instant confirmation \nbetween exchanges can create huge arbitrage opportunities and as such \nliquidity.\n\nIt's not really aimed at the merchant but more at service providers and \npayment processors - or simply, between users that don't know each other in \nlocal traders environments/squares, assuming they are ok trusting a \nknown/respected/reputable third party.\n\n> In practice of course this is something payment processors like Bitpay and \nCoinbase will think about. Individual cafes etc who are just using mobile \nwallets won't be able to deal with this complexity: if we can't make native \nBitcoin work well enough there, we're most likely to just lose that market \nor watch it become entirely centralised around a handful of payment \nprocessing companies.\n\n\nWhat do you expect for e-commerce and escrow to happen? Don't you think the \nmarket will naturally converge to a handful of hubs that will helps with \nrefunds and things like that? Or do you expect to just 'trust' all people on  \nonline markets and smaller unknown online shops?\n\nI mean, the beauty of Bitcoin is that it brings much more transparency and \nthe tools to build such things without huge barriers to entry and without \nusing closed protocols - not that it solves _every_ problem."
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T16:45:58",
                "message_text_only": ">\n> I read the comments on the PR. I mean no disrespect but this patch can't\n> prevent double spends minutes apart and a solution is as good as it's\n> weakest link.\n>\n\nActually Tom is running a page where he shows double spends detected by his\nnode or relayed by mine (there are only two nodes in this little detection\nnetwork currently), and it does show double spends that occur seconds,\nminutes or even days apart.\n\nRegardless, whether that approach helps or not is off topic for this\nthread. Let's all hope it does and discuss the details in some other\nthread, or on the pull request.\n\n\n> instant confirmation between exchanges can create huge arbitrage\n> opportunities and as such\n> liquidity.\n>\n\nYes indeed, if you want to do high frequency trading then every millisecond\ncounts and you probably don't want to rely on watching transactions\npropagate across the block chain. For inter-exchange traffic this BIP would\nprobably be useful. I've been talking about the consumer case.\n\n\n> What do you expect for e-commerce and escrow to happen? Don't you think the\n> market will naturally converge to a handful of hubs that will helps with\n> refunds and things like that?\n\n\nNo, I expect there to be many kinds of trades where dispute mediation is\nunnecessary, e.g. when I buy a drink at Starbucks or a burger at McDonalds\nthe chances of me wanting to charge it back is basically zero. Same for\nsending between people who know each other, large corporate transactions\nwhere the threat of a lawsuit is more useful than mediation, etc.\n\nBut for transactions where third parties are needed for dispute mediation,\nyes, I'd expect there to be a handful of well known trusted names for the\nmajority of such transactions, and then a long tail of specialists who only\nmediate e.g. purchases of rare Aztec artifacts or other things where a\ngeneric company might be easily fooled.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/1fb740b4/attachment.html>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T16:56:56",
                "message_text_only": "Mike Hearn <mike <at> plan99.net> writes:\n\n> Actually Tom is running a page where he shows double spends detected by \nhis node or relayed by mine (there are only two nodes in this little \ndetection network currently), and it does show double spends that occur \nseconds, minutes or even days apart.\n\nI only meant that double spends minutes apart are possible and that by then \nthe sole use of a monitor is too late even if it will tell you.\n\n> Regardless, whether that approach helps or not is off topic for this \nthread. Let's all hope it does and discuss the details in some other thread, \nor on the pull request.\n\nFair enough.\n\n> Yes indeed, if you want to do high frequency trading then every \nmillisecond counts and you probably don't want to rely on watching \ntransactions propagate across the block chain. For inter-exchange traffic \nthis BIP would probably be useful. I've been talking about the consumer \ncase.\n\nThat's quite different, granted.\n\n> No, I expect there to be many kinds of trades where dispute mediation is \nunnecessary, e.g. when I buy a drink at Starbucks or a burger at McDonalds \nthe chances of me wanting to charge it back is basically zero. Same for \nsending between people who know each other, large corporate transactions \nwhere the threat of a lawsuit is more useful than mediation, etc.\n\nI wouldn't assume that if bitcoin alone (i.e. without third parties) can't \nbe used for medium-high value purchases then it's useless. \n\n> But for transactions where third parties are needed for dispute mediation, \nyes, I'd expect there to be a handful of well known trusted names for the \nmajority of such transactions, and then a long tail of specialists who only \nmediate e.g. purchases of rare Aztec artifacts or other things where a \ngeneric company might be easily fooled.\n\nAgreed."
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T17:01:40",
                "message_text_only": ">\n> I only meant that double spends minutes apart are possible and that by then\n> the sole use of a monitor is too late even if it will tell you.\n>\n\nAs long as miners stick to Satoshi's first seen rule, which is the default,\nit's useful:\n\nhttps://bitcointalk.org/index.php?topic=423.msg3819#msg3819\n\n(this is the famous \"snack machine\" thread from 2010)\n\nIf they decide to change to something like highest-fee-always-wins, then\nthey (again) centralise things by forcing all instant transactions to pay\nGreenAddress and its competitors money - much though I like your product\nLawrence, let's hope they don't collectively lemming us all off a cliff by\ndoing that ;)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/aad4540f/attachment.html>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T17:16:24",
                "message_text_only": "Mike Hearn <mike <at> plan99.net> writes:\n\n> As long as miners stick to Satoshi's first seen rule, which is the \ndefault, it's useful:\n> \n> \n> https://bitcointalk.org/index.php?topic=423.msg3819#msg3819\n> \n> \n> \n> \n> (this is the famous \"snack machine\" thread from 2010)\n> \n> If they decide to change to something like highest-fee-always-wins, then \nthey (again) centralise things by forcing all instant transactions to pay \nGreenAddress and its competitors money - much though I like your product \nLawrence, let's hope they don't collectively lemming us all off a cliff by \ndoing that ;)\n\n\nI assume we can't enforce to miners rules about which tx will go in and \nwhich won't and therefore whether this will cause more or less double \nspends.\n\n\nI mean, you can try but I would rather have to option to pick an third party \ninstant provider explicitly than  enforce bigger rules on mining which would \nIMHO lead to implicit centralization."
            },
            {
                "author": "Alex Kotenko",
                "date": "2014-06-16T18:02:47",
                "message_text_only": "Hi Lawrence/All\n\n\nI'm afraid with this BIP for TTP of instant transactions we will end up in\nVISA world again. As I see it - it's not about if the TTPs will centralize,\nit's only when. Simply because if economy of scales makes growth profitable\nand coming into this market is at least a little expensive - this\n(centralization, VISA world) will happen, sooner rather than later.\nAnd while some may argue that coming to market in Bitcoin world is cheap so\nthe crowd will always have a chance to come in and beat the monopolists -\nthink of one thing. Right now Bitcoin is not seen as money and not\nregulated accordingly anywhere in the world, thanks God, but how many years\naway we are from the point when it will start to be regulated that way? And\nonce it is - the monopolies will make sure that rules are restrictive\nenough to prevent competition, especially in conjunction with economy of\nscales playing against the small newcomers.\nThe \"instant providers list\" is susceptible to regulatory influence, and\nonce in place and widespread - it will be a timebomb under Bitcoin. We need\nto solve the doublespend issue without TTP involvement, or at least without\neven a slight chance of making this involvement regulateable. Otherwise I\nthink the Bitcoin experiment will fail.\n\n\nBest regards,\nAlex Kotenko\n\n\n2014-06-16 18:16 GMT+01:00 Lawrence Nahum <lawrence at greenaddress.it>:\n\n> Mike Hearn <mike <at> plan99.net> writes:\n>\n> > As long as miners stick to Satoshi's first seen rule, which is the\n> default, it's useful:\n> >\n> >\n> > https://bitcointalk.org/index.php?topic=423.msg3819#msg3819\n> >\n> >\n> >\n> >\n> > (this is the famous \"snack machine\" thread from 2010)\n> >\n> > If they decide to change to something like highest-fee-always-wins, then\n> they (again) centralise things by forcing all instant transactions to pay\n> GreenAddress and its competitors money - much though I like your product\n> Lawrence, let's hope they don't collectively lemming us all off a cliff by\n> doing that ;)\n>\n>\n> I assume we can't enforce to miners rules about which tx will go in and\n> which won't and therefore whether this will cause more or less double\n> spends.\n>\n>\n> I mean, you can try but I would rather have to option to pick an third\n> party\n> instant provider explicitly than  enforce bigger rules on mining which\n> would\n> IMHO lead to implicit centralization.\n>\n>\n>\n>\n>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/b38e4996/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T18:09:24",
                "message_text_only": "I think many of us feel it'd be better if this kind of thing were not\nneeded at all, however, the best way to ensure it doesn't end up being used\nis to write code, not to try and block alternative approaches. If Bitcoin\nis robust the market should sort it out. If it's robust for some\ntransactions and not others, that makes for a fun project for a future\ngeneration of hackers to sort out.\n\nOK, enough philosophy - let's try and keep this thread just for discussion\nof the BIP itself from now on. If you'd like to continue debating the\nFuture of Bitcoin please change the subject line and break it out into a\nnew thread.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/8135d9e8/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T20:29:54",
                "message_text_only": "I'm trying to think through how to encourage the maximum number of instant\nsignature providers and avoid the VISA monopoly. Ideal case would be that\npeople can even be their own instant provider.\n\nWhat if the protocol allowed multiple instant signatures on a transaction?\nWould it encourage more instant providers? For example, a new instant\nprovider could bootstrap their own trust by paying an already trusted\ninstant provider to co-sign the same transaction. This would be useful in\nthe case that a new company tries to release a new wallet once the trust\nring is already established. Nobody will use that wallet because it does\nnot have the trusted history to do instant transactions, but if they can\npay a small amount per transaction to a third party to cosign, they can\nbuild trust in their own signature till they can eventually have enough\ntrust on their own. This could be how an individual user could grow trust\nin their own instant signature as well.\n\n\nOn Mon, Jun 16, 2014 at 11:09 AM, Mike Hearn <mike at plan99.net> wrote:\n\n> I think many of us feel it'd be better if this kind of thing were not\n> needed at all, however, the best way to ensure it doesn't end up being used\n> is to write code, not to try and block alternative approaches. If Bitcoin\n> is robust the market should sort it out. If it's robust for some\n> transactions and not others, that makes for a fun project for a future\n> generation of hackers to sort out.\n>\n> OK, enough philosophy - let's try and keep this thread just for discussion\n> of the BIP itself from now on. If you'd like to continue debating the\n> Future of Bitcoin please change the subject line and break it out into a\n> new thread.\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/d9d757fa/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T20:32:15",
                "message_text_only": "On Mon, Jun 16, 2014 at 10:29 PM, Daniel Rice <drice at greenmangosystems.com>\nwrote:\n\n> I'm trying to think through how to encourage the maximum number of instant\n> signature providers and avoid the VISA monopoly. Ideal case would be that\n> people can even be their own instant provider.\n>\n\nA provider does not have to be an interactive third party. One reason I\nsuggested using X.509 is so secure hardware devices like the TREZOR could\nalso be instant providers. The hardware would be tamperproof and assert\nusing a secret key embedded in it that the tx came from a genuine,\nunflashed TREZOR. The the server can know the device won't double spend.\n\nIn this way you have decentralised anti-double spending. Of course, it's an\nold solution. MintChip sort of worked a bit like this.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/263c333e/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T20:37:52",
                "message_text_only": "True, that would work, but still how are you going to bootstrap the trust?\nTREZOR is well known, but in a future where there could be 100 different\ncompanies trying to release a similar product to TREZOR it seems like one\ncompany could corner the market by being the only one that is an accepted\ninstant provider at most vendors. It seems to encourage monopoly unless\nthere is a standard way to bootstrap trust in your signature.\n\n\nOn Mon, Jun 16, 2014 at 1:32 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> On Mon, Jun 16, 2014 at 10:29 PM, Daniel Rice <drice at greenmangosystems.com\n> > wrote:\n>\n>> I'm trying to think through how to encourage the maximum number of\n>> instant signature providers and avoid the VISA monopoly. Ideal case would\n>> be that people can even be their own instant provider.\n>>\n>\n> A provider does not have to be an interactive third party. One reason I\n> suggested using X.509 is so secure hardware devices like the TREZOR could\n> also be instant providers. The hardware would be tamperproof and assert\n> using a secret key embedded in it that the tx came from a genuine,\n> unflashed TREZOR. The the server can know the device won't double spend.\n>\n> In this way you have decentralised anti-double spending. Of course, it's\n> an old solution. MintChip sort of worked a bit like this.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/6b6146b3/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T20:46:47",
                "message_text_only": "On Mon, Jun 16, 2014 at 10:37 PM, Daniel Rice <drice at greenmangosystems.com>\nwrote:\n\n> True, that would work, but still how are you going to bootstrap the trust?\n> TREZOR is well known, but in a future where there could be 100 different\n> companies trying to release a similar product to TREZOR it seems like one\n> company could corner the market by being the only one that is an accepted\n> instant provider at most vendors\n>\n\nIt's no different to the CA problem. People can only mentally handle a few\ntrust anchors, so for SSL it goes:\n\n   1 User -> 2-3 browser makers -> 100's of CAs -> millions of websites\n\nThe trust starts out narrowly funnelled and grows outwards as things get\noutsourced.\n\nFor this it'd go\n\n   1 merchant -> 4-5 payment processing engines -> dozens of hardware\nmanufacturers -> hundreds of thousands of devices\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/ec9d9509/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T20:53:09",
                "message_text_only": "The trust can be more automated in this case than it can with CAs. The\ndifference is that when a CA does something it shouldn't, like generates an\nextra cert for a government to use in spoofing a site, nobody knows about\nit, unless they mess up. Double spends on the network can be monitored and\nstored for history. Merchants can and will share information on instant\nprovider trust with eachother, so they will essentially be able to build up\na credit history on a given instant provider without really knowing who\nthey are.\n\n\nOn Mon, Jun 16, 2014 at 1:46 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> On Mon, Jun 16, 2014 at 10:37 PM, Daniel Rice <drice at greenmangosystems.com\n> > wrote:\n>\n>> True, that would work, but still how are you going to bootstrap the\n>> trust? TREZOR is well known, but in a future where there could be 100\n>> different companies trying to release a similar product to TREZOR it seems\n>> like one company could corner the market by being the only one that is an\n>> accepted instant provider at most vendors\n>>\n>\n> It's no different to the CA problem. People can only mentally handle a few\n> trust anchors, so for SSL it goes:\n>\n>    1 User -> 2-3 browser makers -> 100's of CAs -> millions of websites\n>\n> The trust starts out narrowly funnelled and grows outwards as things get\n> outsourced.\n>\n> For this it'd go\n>\n>    1 merchant -> 4-5 payment processing engines -> dozens of hardware\n> manufacturers -> hundreds of thousands of devices\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/c00bb23f/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T20:55:23",
                "message_text_only": "Yes that's true. Though it's off topic, check out\nhttp://www.certificate-transparency.org/  .... it's a project to force CA's\nto publish all certs they make publicly.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/88751e2e/attachment.html>"
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T21:02:45",
                "message_text_only": "Mike Hearn <mike at plan99.net> wrote:\n>> A more scalable approach would be for the user to send the name and\n>> signature of their \"instant provider\" every time and the merchant just\n>> chooses whether to ignore it or not, but as Lawrence points out, this is\n>> incompatible with the provider charging extra fees for \"instantness\". But\n>> should we care? I'm trying to imagine what the purchasing experience is\nlike\n>> with optional paid-for third party anti-double-spend protection.\nUltimately\n>> it's the merchant who cares about this, not me, so why would I ever pay?\n\nLawrence Nahum <lawrence at greenaddress.it> wrote:\n> I think you are wrong here.\n> Just because up to date credit cards charged the merchant which in turn\n> charged you and the ordinary cash payer doesn't mean a newer and better\n> system can't be transparent from day one.\n\nI don't think a whitelist of trust is a practical approach because you are\ngoing to want to have varying levels of trust in different instant\nproviders. This would be based on how large their past transaction volume\nhas been. For that reason maybe another approach is an additional\nnegotiation message between the merchant and wallet. Merchant sends payment\ndetails -> wallet responds with their instant information requesting if an\ninstant transaction will be accepted for this transaction. Merchant weighs\nthe risk based on historical data about this particular instant provider\nand the amount of the requested transaction -> Merchant responds yes or no.\n\nThat approach avoids the scaling issue, but also allows for Lawrence's use\ncase of charging the user a fee only in the case where the instant\ntransaction is supported.\n\n\nOn Mon, Jun 16, 2014 at 1:29 PM, Daniel Rice <drice at greenmangosystems.com>\nwrote:\n\n> I'm trying to think through how to encourage the maximum number of instant\n> signature providers and avoid the VISA monopoly. Ideal case would be that\n> people can even be their own instant provider.\n>\n> What if the protocol allowed multiple instant signatures on a transaction?\n> Would it encourage more instant providers? For example, a new instant\n> provider could bootstrap their own trust by paying an already trusted\n> instant provider to co-sign the same transaction. This would be useful in\n> the case that a new company tries to release a new wallet once the trust\n> ring is already established. Nobody will use that wallet because it does\n> not have the trusted history to do instant transactions, but if they can\n> pay a small amount per transaction to a third party to cosign, they can\n> build trust in their own signature till they can eventually have enough\n> trust on their own. This could be how an individual user could grow trust\n> in their own instant signature as well.\n>\n>\n> On Mon, Jun 16, 2014 at 11:09 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n>> I think many of us feel it'd be better if this kind of thing were not\n>> needed at all, however, the best way to ensure it doesn't end up being used\n>> is to write code, not to try and block alternative approaches. If Bitcoin\n>> is robust the market should sort it out. If it's robust for some\n>> transactions and not others, that makes for a fun project for a future\n>> generation of hackers to sort out.\n>>\n>> OK, enough philosophy - let's try and keep this thread just for\n>> discussion of the BIP itself from now on. If you'd like to continue\n>> debating the Future of Bitcoin please change the subject line and break it\n>> out into a new thread.\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n>> Find What Matters Most in Your Big Data with HPCC Systems\n>> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n>> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n>> http://p.sf.net/sfu/hpccsystems\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/f6c6111b/attachment.html>"
            },
            {
                "author": "Alex Kotenko",
                "date": "2014-06-16T20:32:40",
                "message_text_only": "True, enough philosophy. Once this BIP will be finalized - we will it's\nschedule implementation in XBTerminal. This is a solution to the problem we\nhave, probably best one we have to date, so we will use it.\n\n\n2014-06-16 19:09 GMT+01:00 Mike Hearn <mike at plan99.net>:\n\n> I think many of us feel it'd be better if this kind of thing were not\n> needed at all, however, the best way to ensure it doesn't end up being used\n> is to write code, not to try and block alternative approaches. If Bitcoin\n> is robust the market should sort it out. If it's robust for some\n> transactions and not others, that makes for a fun project for a future\n> generation of hackers to sort out.\n>\n> OK, enough philosophy - let's try and keep this thread just for discussion\n> of the BIP itself from now on. If you'd like to continue debating the\n> Future of Bitcoin please change the subject line and break it out into a\n> new thread.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/d67b537a/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-16T17:44:33",
                "message_text_only": "On 6/16/14, Mike Hearn <mike at plan99.net> wrote:\n> If they decide to change to something like highest-fee-always-wins, then\n> they (again) centralise things by forcing all instant transactions to pay\n> GreenAddress and its competitors money - much though I like your product\n> Lawrence, let's hope they don't collectively lemming us all off a cliff by\n> doing that ;)\n\nReplace-by-fee doesn't imply the use of green addresses (there's other\nsolutions to 0 conf transactions in that context, for example,\n\"scorched earth\"). And giving up the non-enforceable first-seen\ndefault mining policy doesn't mean \"giving up on the Bitcoin\nexperiment\" either."
            },
            {
                "author": "Isidor Zeuner",
                "date": "2014-06-17T15:58:45",
                "message_text_only": "quote:\n> On 6/16/14, Mike Hearn <mike at plan99.net> wrote:\n> > If they decide to change to something like highest-fee-always-wins, then\n> > they (again) centralise things by forcing all instant transactions to pay\n> > GreenAddress and its competitors money - much though I like your product\n> > Lawrence, let's hope they don't collectively lemming us all off a cliff by\n> > doing that ;)\n>\n> Replace-by-fee doesn't imply the use of green addresses (there's other\n> solutions to 0 conf transactions in that context, for example,\n> \"scorched earth\"). And giving up the non-enforceable first-seen\n> default mining policy doesn't mean \"giving up on the Bitcoin\n> experiment\" either.\n>\n\nIf something means \"giving up on the Bitcoin experiment\", then for\nsure it's not one mining policy or another, but the assumption\nthat we should have one uniform mining policy. If we had a community\nwhere enough miners had their own opinion about the best mining\npolicy, and expressed it by choosing an appropriate mining pool, then\nwe would have better decentralized mining based on selfish motives of\nthe miners, rather than based on an abstract thought of\n\"centralization is bad, so I will consider how much mining profit\nfrom qualitatively interchangable mining pools I'm willing to\nsacrifice in order to ease my centralization fears\".\n\nBest regards,\n\nIsidor"
            },
            {
                "author": "Tom Harding",
                "date": "2014-06-18T01:39:42",
                "message_text_only": "On 6/16/2014 8:48 AM, Mike Hearn wrote:\n> In practice of course this is something payment processors like Bitpay \n> and Coinbase will think about. Individual cafes etc who are just using \n> mobile wallets won't be able to deal with this complexity: if we can't \n> make native Bitcoin work well enough there, we're most likely to just \n> lose that market or watch it become entirely centralised around a \n> handful of payment processing companies.\n\nI have trouble seeing how could the real-time anonymous payments market \ncan be cleanly separated from everything else.  If trusted third parties \nbecome the norm for that market, there will inevitably be a huge overlap \neffect on other markets that bitcoin can serve best, even today.  I \ndon't see how any currency, any cash, can concede this market."
            },
            {
                "author": "Isidor Zeuner",
                "date": "2014-06-17T15:58:45",
                "message_text_only": "quote:\n> Mike Hearn, why don't we just have all nodes report attempted double spends\n> through the node network. No need to involve the miners at all really, or\n> do your suggestion but also report the double spend attempt. By waiting\n> maybe 10-60 seconds (instead of 10 minutes for first conf), merchants can\n> be more sure that a double spend attack was not tried. Attacker would have\n> to hold back second tx by 10-60 seconds and hope that that second tx (with\n> higher fee) get's into a solved block before the first one. This forced\n> delay time ought to make the attack less successful (but not impossible).\n>\n\nWhat prevents the following steps from happening:\n\n1. attacker sends first transaction, paying to the merchant\n\n2. merchant waits 10-60 seconds\n\n3. merchant confirms the payment as received\n\n4. attacker sees merchant's confirmation\n\n5. attacker sends double spend\n\nThe security improvement seems to be pretty much exactly the chance\nthat during the 10-60 seconds, a block is solved. Am I missing\nsomething?\n\nRegarding \"reporting double spends\", this would only help if it comes\nwith some kind of penalty for the double spend. Now what if the double\nspend was not done on malicious motives? Maybe someone posted a\ntransaction which does not confirm for some reason, and wants to\nrecover his funds? Should we regard transactions which do not confirm\nas forever lost, in order to get to an \"every double spend is a\nmisbehaviour\" policy?\n\nBest regards,\n\nIsidor"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-18T09:15:48",
                "message_text_only": "Please, let's talk about other anti-double spend things on a separate\nthread.\n\nOn Tue, Jun 17, 2014 at 5:58 PM, Isidor Zeuner <cryptocurrencies at quidecco.de\n> wrote:\n\n> What prevents the following steps from happening:\n>\n\nI linked to Satoshi's post on this earlier, he explains why it works there,\nassuming people follow the original protocol rules.\n\nYour analysis holds as long as network abandons the original Bitcoin\ndesign. Obviously, we hope people won't do that. If everyone decides not to\ndo things how Satoshi laid out then things will break, although whether we\nhave a failure of \"Bitcoin\" at that point is debatable.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/a006ecf1/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2014-06-18T20:47:20",
                "message_text_only": "Den 17 jun 2014 17:59 skrev \"Isidor Zeuner\" <cryptocurrencies at quidecco.de>:\n>\n> quote:\n> > Mike Hearn, why don't we just have all nodes report attempted double\nspends\n> > through the node network. No need to involve the miners at all really,\nor\n> > do your suggestion but also report the double spend attempt. By waiting\n> > maybe 10-60 seconds (instead of 10 minutes for first conf), merchants\ncan\n> > be more sure that a double spend attack was not tried. Attacker would\nhave\n> > to hold back second tx by 10-60 seconds and hope that that second tx\n(with\n> > higher fee) get's into a solved block before the first one. This forced\n> > delay time ought to make the attack less successful (but not\nimpossible).\n> >\n>\n> What prevents the following steps from happening:\n>\n> 1. attacker sends first transaction, paying to the merchant\n>\n> 2. merchant waits 10-60 seconds\n>\n> 3. merchant confirms the payment as received\n>\n> 4. attacker sees merchant's confirmation\n>\n> 5. attacker sends double spend\n>\n> The security improvement seems to be pretty much exactly the chance\n> that during the 10-60 seconds, a block is solved. Am I missing\n> something?\n>\n> Regarding \"reporting double spends\", this would only help if it comes\n> with some kind of penalty for the double spend. Now what if the double\n> spend was not done on malicious motives? Maybe someone posted a\n> transaction which does not confirm for some reason, and wants to\n> recover his funds? Should we regard transactions which do not confirm\n> as forever lost, in order to get to an \"every double spend is a\n> misbehaviour\" policy?\n>\n> Best regards,\n>\n> Isidor\n\nWith 2-of-2 multisignature notaries, the doublespend (the set of\nconflicting transactions) would be published and propagated together as\nevidence of the notary being malicious. This is trivial and self-evident\nself-contained proof.\n\nBut there should be no direct penalty IMHO in the Bitcoin protocol itself.\n\nIf a transaction would have to be replaced honestly because of being wrong\nor simply not confirming, then I think there should be some means of\nshowing the second transaction is \"legitimate\". Don't ask me how exactly it\nwould work in practice, but one method could be through showing the\noriginal recipients have signed off on it (showing they agree it should be\nreversed).\n\nIf you can't get the original recipient to sign, then you're stuck with\neither not replacing it or the notary trying to prove the replacing\ntransaction was legitimate.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/527586ea/attachment.html>"
            },
            {
                "author": "Tom Harding",
                "date": "2014-06-18T02:01:33",
                "message_text_only": "On 6/16/2014 8:09 AM, Daniel Rice wrote:\n> What if we solved doublespends like this: If a node receives 2 \n> transactions that use the same input, they can put both of them into \n> the new block as a proof of double spend, but the bitcoins are not \n> sent to the outputs of either transactions. They are instead treated \n> like a fee and given to the block solver node. This gives miners the \n> needed incentive and tools to end doublespends instead of being forced \n> to favor one transaction over the other.\n\nBefore considering a hard fork with unpredictable effects on the \nuncertainty window, it would be interesting to look at a soft fork that \nwould directly target the goal of reducing the uncertainty window, like \ntreating locally-detected double-spends aged > T as invalid (see earlier \nmessage \"A statistical consensus rule for reducing 0-conf double-spend \nrisk\").\n\nIf anything is worth a soft fork, wouldn't reducing the double-spend \nuncertainty window by an order of magnitude be in the running?\n\nReducing the reasons that transactions don't get relayed, which actually \nseems to have a shot of happening pretty soon, would also make this kind \nof thing work better."
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T15:28:00",
                "message_text_only": "Mike Hearn <mike <at> plan99.net> writes:\n[snip]\n> Daniel is right that putting every possible provider in the Payment \nmessage might not scale in a world where there are huge numbers of instant-\nconfirmation providers, but I'm hoping that we never have to scale to that \nsize, because if we did that'd rather imply that Bitcoin has become useless \nfor in-person payments without trusted third parties and avoiding that is \nrather the whole point of the project :) So I'm OK with some theoretical \nlack of scalability for now. \n\nHard to say for now. I like the current simplicity but if someone can come \nup with some use case for other options we should discuss and investigate \nthem. I don't see more than a bunch of accepted payment methods anywhere I \never been in my life, I don't see merchants trusting more than a handful of \nthird parties.\n\n> A more scalable approach would be for the user to send the name and \nsignature of their \"instant provider\" every time and the merchant just \nchooses whether to ignore it or not, but as Lawrence points out, this is \nincompatible with the provider charging extra fees for \"instantness\". But \nshould we care? I'm trying to imagine what the purchasing experience is like \nwith optional paid-for third party anti-double-spend protection. Ultimately \nit's the merchant who cares about this, not me, so why would I ever pay?\n\nI think you are wrong here.\nJust because up to date credit cards charged the merchant which in turn \ncharged you and the ordinary cash payer doesn't mean a newer and better \nsystem can't be transparent from day one.\n\nUltimately you care because the alternative is to wait.\n\n> It makes no sense for me to pay for double spend protection for the \nmerchant: after all, I'm honest.\n\nIt's quite simple, in a low amounts world people will probably accept zero \nconfs, just like occasionally people can walk out with a bag of crisps \nwithout paying from a Pret in London. Guards would cost more than what \nthey'd save from thefts.\n\nWith higher amounts they will either not accept bitcoin unless instant \nconfirmed or they will make you wait if that's even feasible (unlikely in a \nsupermarket or petrol station but perfectly fine at the restaurant maybe).\n\n> This is why it doesn't make sense for me to pay miners fees either, it's \nthe receiver\u00a0who cares about confirmations, not the sender.\n\nYou care too: time and money, or just money if you want to use the old \nsimplification.\n\n> So I wonder if a smarter design is that the user always submits the \ndetails of their instantness provider and we just don't allow for optional \nselection of instantness. I'm not sure that works, UX wise, so is having a \nless scalable design to support it worthwhile?\n\nWe would not support that I think. Explicit is better than implicit.\n\nWe will charge for instant confirmation and wouldn't want the user charged \nunless pre-agreed, especially if then they also have to wait because the \ninstant tx was not recognized as such.\n\nYeah we can charge the merchant that can then in turn charge you, we may as \nwell charge you and be transparent about it but also have deals with \nmerchant where they pay fixed amounts per month for unlimited tx and make it \nfree for their users.\n\nPerhaps just like today people ask you which card you are going to use and \nthey may not accept Amex or Diners the same will go for instant and they, \nthe merchants, will just pick the instant provider from a touch screen \nbefore allowing the payment in."
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T15:43:26",
                "message_text_only": ">\n> I don't see more than a bunch of accepted payment methods anywhere I\n> ever been in my life, I don't see merchants trusting more than a handful of\n> third parties.\n>\n\nSure. I buy this. Although the credit card market is a great example of\nwhat we *don't* want: a stagnant duopoly of trusted third parties who\nrampantly abuse their position. So I'd hope we see either (a) nobody really\ncaring about this BIP because Bitcoin gives good enough double spend\nprotection or (b) lots of anti-double-spend providers (hundreds seems fine).\n\n\n> Ultimately you care because the alternative is to wait.\n>\n\nNo, I will never wait. Neither me nor the merchant wants to me to be\npointlessly hanging around for an hour. The alternative is to pay by credit\ncard or cash. Outside of experiments there is no such thing as a shop that\nonly accepts only Bitcoin and will require me to wait for a block because I\ndidn't use a TTP to guarantee anti-double spends.\n\nSo this seems like a fundamental problem to me: having the ability to say,\n\"here is a proof I won't double spend\" is fine, but it doesn't achieve\nanything if the merchant would have sold me the goods in return for a\nnormal Bitcoin tx anyway, which in practice they always will because this\nsystem starts out from zero users and would have to work upwards. I\n*especially* will never use this system if I have to pay for it - I'd much\nrather just put my money into a wallet that can't generate these proofs and\npay the sticker price.\n\nMaybe what this BIP needs is an extra field that lets the merchant say, I\nwill give you a discount of X satoshis if you give me a no-double-spends\nproof. In other words invert it: the sticker price is what normal Bitcoin\ntransactions cost, and then your wallet shows you the regular BIP70 price\nminus the discount plus the third parties fee as what you finally pay. I\ncompare it to the sticker price the merchant is asking and if it's lower\nI'm happy, and if it's higher my wallet would automatically avoid using the\nTTP because I don't want to ever pay more, only less.\n\nThe market would then figure out if the fees the TTP charges are worth the\nlower losses due to double spending fraud.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/fc5f6e7b/attachment.html>"
            },
            {
                "author": "Lawrence Nahum",
                "date": "2014-06-16T17:05:27",
                "message_text_only": "Mike Hearn <mike <at> plan99.net> writes:\n\n> Sure. I buy this. Although the credit card market is a great example of \nwhat we don't\u00a0want: a stagnant duopoly of trusted third parties who \nrampantly abuse their position. So I'd hope we see either (a) nobody really \ncaring about this BIP because Bitcoin gives good enough double spend \nprotection or (b) lots of anti-double-spend providers (hundreds seems fine).\n\nMaybe hundreds, maybe less. I can imagine there would/could be local ones.\nIt's not the same as credit cards though: it's an open protocol with \nexplicit intent from all parties and no forced fees for normal transactions \n- just for instant ones.\n\n> No, I will never wait. Neither me nor the merchant wants to me to be \npointlessly hanging around for an hour. The alternative is to pay by credit \ncard or cash. Outside of experiments there is no such thing as a shop that \nonly accepts only Bitcoin and will require me to wait for a block because I \ndidn't use a TTP to guarantee anti-double spends.\n\nI tend to agree but _today_ people are trying to use bitcoin and are waiting \nand waiting ..\n\n\n> So this seems like a fundamental problem to me: having the ability to say, \n\"here is a proof I won't double spend\" is fine, but it doesn't achieve \nanything if the merchant would have sold me the goods in return for a normal \nBitcoin tx anyway, which in practice they always will because this system \nstarts out from zero users and would have to work upwards. I especially\u00a0will \nnever use this system if I have to pay for it - I'd much rather just put my \nmoney into a wallet that can't generate these proofs and pay the sticker \nprice.\n\nThis is a cultural thing. In some places if you pay by cards you pay extra.\nI think it may be good to support both models but I like better the \ntransparent one even if I'm going to admit that the least transparent one \nmay be more attractive as it fools consumers.\n\n> Maybe what this BIP needs is an extra field that lets the merchant say, I \nwill give you a discount of X satoshis if you give me a no-double-spends \nproof. In other words invert it: the sticker price is what normal Bitcoin \ntransactions cost, and then your wallet shows you the regular BIP70 price \nminus the discount plus the third parties fee as what you finally pay. I \ncompare it to the sticker price the merchant is asking and if it's lower I'm \nhappy, and if it's higher my wallet would automatically avoid using the TTP \nbecause I don't want to ever pay more, only less.\n> The market would then figure out if the fees the TTP charges are worth the \nlower losses due to double spending fraud.\n\nI think this is worth discussing further. Would love also more input from \nother people on this."
            },
            {
                "author": "Daniel Rice",
                "date": "2014-06-16T08:53:38",
                "message_text_only": "Jumping in on this conversation because I've been doing research in this\narea. Using a list of trusted providers in the payment details will be very\nlimiting and not scalable. I understand the reason for wanting the\nsupports_instant field, but I think that's a bad idea because the list\ncould literally be a million providers. Secondly, some merchants already\nsupport instant transactions without any trust signature, so they should\nalso be able to advertise that as well.\n\nI also don't believe that trusted or not trusted is a valid on and off\nswitch. For example, I might trust an instant provider for a 1 btc\ntransaction, but not 1,000,000 btc. Trust is all about the risk involved.\nWe can definitely learn from the current financial system in this realm.\n\nI 100% agree with the In Payment Message portion of the BIP extension.\nHere's how I think this will practically shake out in an automated way:\nAnyone can become an instant provider, but nobody will trust them at first.\nAs that particular instant provider processes more and more transactions\nwithout any double spends, they essentially build up trust. Based on the\npast history of a particular instant provider a risk factor could be\ncalculated for a given transaction. This would also factor in the size of\nthe transaction. It would be very similar to a credit file showing the past\nhistory of that particular instant provider based on all the transactions\nthey signed.\n\nAndreas Schildbach <andreas <at> schildbach.de> writes:\n\n> Just a quick comment:\n>\n> The supports_instant field seems redundant to me. First, as per your\n> spec, you can derive it from trusted_instant_providers. And second, why\n> do you need it at all? Protobuf is designed so it will simply ignore\n> fields you don't know. So you can just send the instant_* fields in the\n> Payment message without harm.\n\n\n\nAgreed, supports_instant is redundant and can/should/will go.\n\ntrusted_instant_providers on the other hand I think is needed.\n\nSometimes the providers will charge fees for instant.\n\nWhile the software can ignore the fields,\nusers may not want to pay for instant when the merchant may not accept it or\ncare (even if it would not break the protocol it would still be a waste of\nfees)\n\nDoes it make sense?\n\nNot all transactions from GreenAddress provide double spend protection, there\nare additional checks on prevout that are normally not done when spending\nnormally, etc\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/6b3ca796/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "instant confirmation via payment protocol backwards compatible proto buffer extension",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Natanael",
                "Isidor Zeuner",
                "Alex Kotenko",
                "Andreas Schildbach",
                "Lawrence Nahum",
                "Mike Hearn",
                "sebastien requiem",
                "Daniel Rice",
                "Jorge Tim\u00f3n",
                "Paul Goldstein",
                "Tom Harding"
            ],
            "messages_count": 45,
            "total_messages_chars_count": 78841
        }
    },
    {
        "title": "[Bitcoin-development] Fidelity bonds for decentralized instant confirmation guarantees",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-06-16T20:50:41",
                "message_text_only": "On Mon, Jun 16, 2014 at 01:37:52PM -0700, Daniel Rice wrote:\n> True, that would work, but still how are you going to bootstrap the trust?\n> TREZOR is well known, but in a future where there could be 100 different\n> companies trying to release a similar product to TREZOR it seems like one\n> company could corner the market by being the only one that is an accepted\n> instant provider at most vendors. It seems to encourage monopoly unless\n> there is a standard way to bootstrap trust in your signature.\n\nYou can always use fidelity bonds, or as I called it at the time(1),\n\"Trusted identities\":\n\n    Lets suppose Alice has some bitcoins held at bitcoin address A. She\n    wants to establish trust in the \"identity\" associated with the ECC\n    keypair associated with A, for instance for the purpose of having other\n    users trust her not to attempt to double spend. Since the trust she\n    seeks is financial in nature, she can do this by valuing the identity\n    associated with A, by delibrately throwing away resources. A simple way\n    to do this would of course be to transfer coins to a null address,\n    provably incurring a cost to her.\n\n    A more socially responsible way would be for her to create a series of\n    transactions that happen to have large, and equal, transaction fees.\n    Bitcoin makes the assumption that no one entity controls more than 50%\n    of the network, so if she makes n of these transactions consecutively,\n    each spending m BTC to transaction fees, there is a high probability\n    that she has given up at least n/2 * m BTC of value. This of course is\n    all public knowledge, recorded in the block chain. It also increases the\n    transaction fees for miners, which will be very important for the\n    network in the future.\n\n    Now Bob can easily examine the block chain, and upon verifying Alice's\n    trust purchase, can decide to accept a zero-confirmation transaction at\n    face value. If Alice breaks that promise, he simply publishes her signed\n    transaction proving that Alice is a fraudster, and future Bob's will\n    distrust Alice's trusted identity, thus destroying the value needed to\n    create it.\n\n    In effect, we now have a distributed green address system.\n\nNote that the second paragraph is seriously obsolete - better to either\nuse announce-commit sacrifices, or much preferably, simple destruction\nof coins. (sacrifice to fees encourages mining centralization for\nobvious reasons)\n\n1) \"[Bitcoin-development] Trusted identities\", Apr 26th 2012, Peter Todd,\n   http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg01005.html\n\nIncidentally, my first post to this mailing list!\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000058ca7ee3a40438ea5a96e499910638352468c6d69abdb226\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/ada1a3cf/attachment.sig>"
            },
            {
                "author": "Goss, Brian C., M.D.",
                "date": "2014-06-17T20:40:50",
                "message_text_only": "Can two signed transactions using the same output as an input (ie, a double spend) be used to trigger a third transaction? \n\nIt would be nice if I could sign a tx that would pay m bitcoins to an arbitrary address if and only if someone could present proof that I signed more than 1 transaction using the same output. Thus, a merchant could trust that I would not attempt a double spend for a purchase of n < m bitcoins. \n\nCan this type of transaction be expressed in Bitcoin's scripting language? \n\nChaum had a similar feature in Digicash way back when...a double spend would let the second merchant compute the identity of the double spender and serve as proof of double spending. It didn't automate punishment though!\n\nMy apologies if this has been discussed previously. \n\n-----------------------------\n> \n> Message: 2\n> Date: Mon, 16 Jun 2014 16:50:41 -0400\n> From: Peter Todd <pete at petertodd.org>\n> Subject: Re: [Bitcoin-development] Fidelity bonds for decentralized\n>    instant confirmation guarantees\n> To: Daniel Rice <drice at greenmangosystems.com>\n> Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net>,    Lawrence\n>    Nahum <lawrence at greenaddress.it>\n> Message-ID: <20140616205041.GA21784 at savin>\n> Content-Type: text/plain; charset=\"us-ascii\"\n> \n>> On Mon, Jun 16, 2014 at 01:37:52PM -0700, Daniel Rice wrote:\n>> True, that would work, but still how are you going to bootstrap the trust?\n>> TREZOR is well known, but in a future where there could be 100 different\n>> companies trying to release a similar product to TREZOR it seems like one\n>> company could corner the market by being the only one that is an accepted\n>> instant provider at most vendors. It seems to encourage monopoly unless\n>> there is a standard way to bootstrap trust in your signature.\n> \n> You can always use fidelity bonds, or as I called it at the time(1),\n> \"Trusted identities\":\n> \n>    Lets suppose Alice has some bitcoins held at bitcoin address A. She\n>    wants to establish trust in the \"identity\" associated with the ECC\n>    keypair associated with A, for instance for the purpose of having other\n>    users trust her not to attempt to double spend. Since the trust she\n>    seeks is financial in nature, she can do this by valuing the identity\n>    associated with A, by delibrately throwing away resources. A simple way\n>    to do this would of course be to transfer coins to a null address,\n>    provably incurring a cost to her.\n> \n>    A more socially responsible way would be for her to create a series of\n>    transactions that happen to have large, and equal, transaction fees.\n>    Bitcoin makes the assumption that no one entity controls more than 50%\n>    of the network, so if she makes n of these transactions consecutively,\n>    each spending m BTC to transaction fees, there is a high probability\n>    that she has given up at least n/2 * m BTC of value. This of course is\n>    all public knowledge, recorded in the block chain. It also increases the\n>    transaction fees for miners, which will be very important for the\n>    network in the future.\n> \n>    Now Bob can easily examine the block chain, and upon verifying Alice's\n>    trust purchase, can decide to accept a zero-confirmation transaction at\n>    face value. If Alice breaks that promise, he simply publishes her signed\n>    transaction proving that Alice is a fraudster, and future Bob's will\n>    distrust Alice's trusted identity, thus destroying the value needed to\n>    create it.\n> \n>    In effect, we now have a distributed green address system.\n> \n> Note that the second paragraph is seriously obsolete - better to either\n> use announce-commit sacrifices, or much preferably, simple destruction\n> of coins. (sacrifice to fees encourages mining centralization for\n> obvious reasons)\n> \n> 1) \"[Bitcoin-development] Trusted identities\", Apr 26th 2012, Peter Todd,\n>   http://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg01005.html\n> \n> Incidentally, my first post to this mailing list!\n> \n> -- \n> 'peter'[:-1]@petertodd.org\n> 000000000000000058ca7ee3a40438ea5a96e499910638352468c6d69abdb226\n> -------------- next part --------------\n> A non-text attachment was scrubbed...\n> Name: not available\n> Type: application/pgp-signature\n> Size: 685 bytes\n> Desc: Digital signature\n> \n> ------------------------------\n> \n> \n> \n> End of Bitcoin-development Digest, Vol 37, Issue 27\n> ***************************************************"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-17T22:28:36",
                "message_text_only": "Not with current script, but there are mechanisms by which you can do a\ndigital signature where signing two pieces of information reveals the\nECDSA k parameter, thereby allowing anyone to recover the private key\nand steal the coins.\n\nPractically speaking, these are not very safe systems to use. For\nexample, imagine accidentally loading up the same wallet on two machines\nor the wallet software crashing after signing and sending the\ntransaction, and the user recreates & sends on recovery.\n\nIt also invalidates reasonably legitimate use cases for repeating\naddresses (in the absence of other solutions), and its not really\npossible to prevent people from sending multiple coins to the same\naddress (which could then be stolen).\n\nOn 06/17/2014 01:40 PM, Goss, Brian C., M.D. wrote:\n> Can two signed transactions using the same output as an input (ie, a\n> double spend) be used to trigger a third transaction?\n> \n> It would be nice if I could sign a tx that would pay m bitcoins to an\n> arbitrary address if and only if someone could present proof that I\n> signed more than 1 transaction using the same output. Thus, a\n> merchant could trust that I would not attempt a double spend for a\n> purchase of n < m bitcoins.\n> \n> Can this type of transaction be expressed in Bitcoin's scripting\n> language?\n> \n> Chaum had a similar feature in Digicash way back when...a double\n> spend would let the second merchant compute the identity of the\n> double spender and serve as proof of double spending. It didn't\n> automate punishment though!\n> \n> My apologies if this has been discussed previously.\n>"
            }
        ],
        "thread_summary": {
            "title": "Fidelity bonds for decentralized instant confirmation guarantees",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Goss, Brian C., M.D.",
                "Peter Todd",
                "Mark Friedenbach"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 9077
        }
    },
    {
        "title": "[Bitcoin-development] Incentivizing the running of full nodes",
        "thread_messages": [
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-06-16T08:12:39",
                "message_text_only": "I have been noticing for some time the problem which Mike H. identified as\nhow we are bleeding nodes ~ losing nodes over time.\n\nThis link was referenced in the coindesk article of May 9, 2014:\n\nhttp://sourceforge.net/p/bitcoin/mailman/bitcoin-development/thread/CANEZrP2rgiQHpekEpFviJ22QsiV%2Bs-F2pqosaZOA5WrRtJx5pg%40mail.gmail.com/#msg32196023\n\n(coindesk article for reference: http://www.coindesk.com/bitcoin-nodes-need/)\n\nThe proposed solution is noted here as a portion of an issue at:\n https://github.com/bitcoin/bitcoin/issues/4079\n\nEssentially that part which has to do with helping reduce\nthe loss of nodes is as follows:\n\n\"a feature similar to that suggested by @gmaxwell that would process small\nchange and tiny txouts to user specified donation targets, in an\nincentivized process. Those running full nodes (Bitcoin Core all the\ntime), processing their change and txouts through Core, would be provided\nincentives in the form of a 'decentralizing lottery' such that all\nparticipants who are running nodes and donating no matter how infrequently\n(and no matter who they donate to) will be entered in the 'decentralizing\nlottery,' the 'award amounts' (which would be distinct from 'block\nrewards' for any mining) would vary from small to large bitcoin amounts\ndepending on how many participants are involved in the donations process.\nThis would help incentivize individuals to run full nodes as well as\nencouraging giving and microdonations. The option could be expressed in\nthe transactions area to contribute to help bitcoin core development for\nthose that are setting up change and txouts for donations, regarding the\nmicrodonation portion (which has also has been expressed conceptually at\nabis.io\"\n\nThis addresses the issue of how to incentivize more\ninterested individuals to run full nodes (Bitcoin Core).  The lottery\nconcept (which would be applicable to anyone running the full node\nregardless of whether or not they are mining) is attractive from the point\nof view that it will complement the block reward concept already in place\nwhich serves those who mine, but more attractive to the individual who\ndoesn't feel the urge to mine, but would like to have the chance of being\ncompensated for the effort they put into the system.\n\nI hope that this leads to additional development discussion on these\nconcepts regarding incentivizing giving. This may also involve a process\nBIP.  I look forward to your remarks.\n\nRespect,\n\nOdinn"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T11:35:33",
                "message_text_only": "Hi Odinn,\n\nI think trying to incentivise nodes with money is tricky: it makes\nintuitive sense but right now the market is flooded with supply relative to\ndemand. Yes, we worry about the falling number of nodes, but that's for\nreasons that aren't really economic: the more nodes we have, the bigger and\nmore grassroots the project seems to the outside world, plus the cheaper it\ngets for everyone as the biggest cost (chain upload bandwidth) is spread\nover multiple people.\n\nAlso there's research showing that when you have people volunteering,\nintroducing money can ruin the motivation of the volunteers, so the\ntransition to a pay-for-node-services world could be quite painful and\ndifficult.\n\nRight now rather than microdonations to all nodes, IMO the lowest hanging\nfruit is to move chain upload onto specialised \"archival nodes\" which can\npotentially charge for their services. I prototyped this here\n\nhttps://github.com/mikehearn/PayFile\n\nbut never finished it.\n\n\nOn Mon, Jun 16, 2014 at 10:12 AM, Odinn Cyberguerrilla <\nodinn.cyberguerrilla at riseup.net> wrote:\n\n> I have been noticing for some time the problem which Mike H. identified as\n> how we are bleeding nodes ~ losing nodes over time.\n>\n> This link was referenced in the coindesk article of May 9, 2014:\n>\n>\n> http://sourceforge.net/p/bitcoin/mailman/bitcoin-development/thread/CANEZrP2rgiQHpekEpFviJ22QsiV%2Bs-F2pqosaZOA5WrRtJx5pg%40mail.gmail.com/#msg32196023\n>\n> (coindesk article for reference:\n> http://www.coindesk.com/bitcoin-nodes-need/)\n>\n> The proposed solution is noted here as a portion of an issue at:\n>  https://github.com/bitcoin/bitcoin/issues/4079\n>\n> Essentially that part which has to do with helping reduce\n> the loss of nodes is as follows:\n>\n> \"a feature similar to that suggested by @gmaxwell that would process small\n> change and tiny txouts to user specified donation targets, in an\n> incentivized process. Those running full nodes (Bitcoin Core all the\n> time), processing their change and txouts through Core, would be provided\n> incentives in the form of a 'decentralizing lottery' such that all\n> participants who are running nodes and donating no matter how infrequently\n> (and no matter who they donate to) will be entered in the 'decentralizing\n> lottery,' the 'award amounts' (which would be distinct from 'block\n> rewards' for any mining) would vary from small to large bitcoin amounts\n> depending on how many participants are involved in the donations process.\n> This would help incentivize individuals to run full nodes as well as\n> encouraging giving and microdonations. The option could be expressed in\n> the transactions area to contribute to help bitcoin core development for\n> those that are setting up change and txouts for donations, regarding the\n> microdonation portion (which has also has been expressed conceptually at\n> abis.io\"\n>\n> This addresses the issue of how to incentivize more\n> interested individuals to run full nodes (Bitcoin Core).  The lottery\n> concept (which would be applicable to anyone running the full node\n> regardless of whether or not they are mining) is attractive from the point\n> of view that it will complement the block reward concept already in place\n> which serves those who mine, but more attractive to the individual who\n> doesn't feel the urge to mine, but would like to have the chance of being\n> compensated for the effort they put into the system.\n>\n> I hope that this leads to additional development discussion on these\n> concepts regarding incentivizing giving. This may also involve a process\n> BIP.  I look forward to your remarks.\n>\n> Respect,\n>\n> Odinn\n>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/58bb7b51/attachment.html>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-16T16:25:20",
                "message_text_only": "How can there be any kind of lottery that doesn't involve proof of work or proof of stake? Without some resource-limiting factor, there is no way to limit the number of \"lottery tickets\" any given individual could acquire. The very process of Bitcoin mining was invented specifically to overcome the Sybil problem, which had plagued computer scientists for decades, and now you're proposing a system that suffers from the same problem. Or am I wrong about this?\n\n\nOn Monday, 16 June 2014, at 1:12 am, Odinn Cyberguerrilla wrote:\n> I have been noticing for some time the problem which Mike H. identified as\n> how we are bleeding nodes ~ losing nodes over time.\n> \n> This link was referenced in the coindesk article of May 9, 2014:\n> \n> http://sourceforge.net/p/bitcoin/mailman/bitcoin-development/thread/CANEZrP2rgiQHpekEpFviJ22QsiV%2Bs-F2pqosaZOA5WrRtJx5pg%40mail.gmail.com/#msg32196023\n> \n> (coindesk article for reference: http://www.coindesk.com/bitcoin-nodes-need/)\n> \n> The proposed solution is noted here as a portion of an issue at:\n>  https://github.com/bitcoin/bitcoin/issues/4079\n> \n> Essentially that part which has to do with helping reduce\n> the loss of nodes is as follows:\n> \n> \"a feature similar to that suggested by @gmaxwell that would process small\n> change and tiny txouts to user specified donation targets, in an\n> incentivized process. Those running full nodes (Bitcoin Core all the\n> time), processing their change and txouts through Core, would be provided\n> incentives in the form of a 'decentralizing lottery' such that all\n> participants who are running nodes and donating no matter how infrequently\n> (and no matter who they donate to) will be entered in the 'decentralizing\n> lottery,' the 'award amounts' (which would be distinct from 'block\n> rewards' for any mining) would vary from small to large bitcoin amounts\n> depending on how many participants are involved in the donations process.\n> This would help incentivize individuals to run full nodes as well as\n> encouraging giving and microdonations. The option could be expressed in\n> the transactions area to contribute to help bitcoin core development for\n> those that are setting up change and txouts for donations, regarding the\n> microdonation portion (which has also has been expressed conceptually at\n> abis.io\"\n> \n> This addresses the issue of how to incentivize more\n> interested individuals to run full nodes (Bitcoin Core).  The lottery\n> concept (which would be applicable to anyone running the full node\n> regardless of whether or not they are mining) is attractive from the point\n> of view that it will complement the block reward concept already in place\n> which serves those who mine, but more attractive to the individual who\n> doesn't feel the urge to mine, but would like to have the chance of being\n> compensated for the effort they put into the system.\n> \n> I hope that this leads to additional development discussion on these\n> concepts regarding incentivizing giving. This may also involve a process\n> BIP.  I look forward to your remarks.\n> \n> Respect,\n> \n> Odinn"
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-06-16T17:07:24",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 06/16/2014 04:25 PM, Matt Whitlock wrote:\n> How can there be any kind of lottery that doesn't involve proof of\n> work or proof of stake? Without some resource-limiting factor,\n> there is no way to limit the number of \"lottery tickets\" any given\n> individual could acquire. The very process of Bitcoin mining was\n> invented specifically to overcome the Sybil problem, which had\n> plagued computer scientists for decades, and now you're proposing a\n> system that suffers from the same problem. Or am I wrong about\n> this?\n\nIf you allow the solution set to include pay-to-play networks, and not\njust free P2P networks, then it's easier to find a solution\n\nImagine every node is competing with its peers in terms of relevancy.\nRelevancy is established by delivering newly-seen transactions first.\n\nEach node keeps track of which of its peers send it transactions that\nit hadn't seen and forwarded to them yet (making sure that the\ntransactions do make it into a block) and uses that information to\ndetermine whether or not it should be paying that peer, or if that\npeer should be paying it, or if they are equal relevancy and no net\npayment is required.\n\nOnce any given pair of nodes can establish who, if anyone, should be\npaying they could use micropayment channels to handle payments.\n\nNodes that are well connected, and with high uptimes would end up\nbeing net recipients of payments. Mobile nodes and other low-uptime\nnodes would be net payers.\n\nNow that you've established a market for the service of delivering\ntransaction information, you can rely on price signals to properly\nmatch supply and demand.\n\nPeople who hate market-based solutions could always run these nodes\nand configure them to refuse to pay anyone, and to charge nothing to\ntheir peers, if that's what they wanted.\n\n\n- -- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBAgAGBQJTnyRMAAoJEMP3uyY4RQ21XwgH/RPlhgR63XF9/Sm+z0EBxVtO\n0hzDngD0iTO1v5LRmas9P5ZuQ97j8169pui+EJO8clXjV41yEu96jc0BiOQTnfMR\nrzPfgeZqfnVNDvIfJnLRMeVCJMiu9Tjdqx83S28Tz9sx/sgy1uw9INX7M7wOIHFR\n7GLA16k4g8qcmnX89XXM3Uf7/3fhL2kiN/E59V2n6qYJAnYTUEb+uehclzR+T4v4\n93oAF3TjgLU6J0VleDrvgFcyLriGBjOmkTAvmOJQF1H/s4gzHol5kbOb9vqQ7BJX\nQQ/mEYHEdCHTxU59FdZ5CmFYZrINHj+mNnu1RorYYF1FLbBDTDpq4zjrJpngayI=\n=9qQJ\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x38450DB5.asc\nType: application/pgp-keys\nSize: 12464 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/7a64d188/attachment.bin>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-16T17:26:48",
                "message_text_only": "On Monday, 16 June 2014, at 5:07 pm, Justus Ranvier wrote:\n> On 06/16/2014 04:25 PM, Matt Whitlock wrote:\n> > How can there be any kind of lottery that doesn't involve proof of\n> > work or proof of stake? Without some resource-limiting factor,\n> > there is no way to limit the number of \"lottery tickets\" any given\n> > individual could acquire. The very process of Bitcoin mining was\n> > invented specifically to overcome the Sybil problem, which had\n> > plagued computer scientists for decades, and now you're proposing a\n> > system that suffers from the same problem. Or am I wrong about\n> > this?\n> \n> If you allow the solution set to include pay-to-play networks, and not\n> just free P2P networks, then it's easier to find a solution\n> \n> Imagine every node is competing with its peers in terms of relevancy.\n> Relevancy is established by delivering newly-seen transactions first.\n> \n> Each node keeps track of which of its peers send it transactions that\n> it hadn't seen and forwarded to them yet (making sure that the\n> transactions do make it into a block) and uses that information to\n> determine whether or not it should be paying that peer, or if that\n> peer should be paying it, or if they are equal relevancy and no net\n> payment is required.\n> \n> Once any given pair of nodes can establish who, if anyone, should be\n> paying they could use micropayment channels to handle payments.\n> \n> Nodes that are well connected, and with high uptimes would end up\n> being net recipients of payments. Mobile nodes and other low-uptime\n> nodes would be net payers.\n> \n> Now that you've established a market for the service of delivering\n> transaction information, you can rely on price signals to properly\n> match supply and demand.\n> \n> People who hate market-based solutions could always run these nodes\n> and configure them to refuse to pay anyone, and to charge nothing to\n> their peers, if that's what they wanted.\n\nThis is a cool idea, but doesn't it generate some perverse incentives? If I'm running a full node and I want to pay CheapAir for some plane tickets, I'll want to pay in the greatest number of individual transactions possible, to maximize the rewards that I'll receive from my connected peers. This maybe would not be a problem if transaction fees were required on all transactions, but as it is (e.g., while fee-free transactions can be accepted into blocks if they have high enough priority), I can \"preload\" my wallet with hundreds of small-ish outputs, let them sit there for a few months to accumulate coin age, and then spend each little piece in a separate transaction when it comes time to pay for a big-ticket purchase. It's more lucrative for me to pay for my plane ticket in 100 separate, low-value transactions than in one high-value transaction. So you're incentivizing greater consumption of bandwidth and storage."
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-16T17:59:12",
                "message_text_only": ">\n> This is a cool idea, but doesn't it generate some perverse incentives? If\n> I'm running a full node and I want to pay CheapAir for some plane tickets,\n> I'll want to pay in the greatest number of individual transactions possible\n\n\nPeers can calculate rewards based on number of inputs or total kb used:\nyou're paying for kilobytes with either coin age or fees no matter what. So\nI think in practice it's not a big deal.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/61dabb34/attachment.html>"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-16T18:10:33",
                "message_text_only": "On Monday, 16 June 2014, at 7:59 pm, Mike Hearn wrote:\n> >\n> > This is a cool idea, but doesn't it generate some perverse incentives? If\n> > I'm running a full node and I want to pay CheapAir for some plane tickets,\n> > I'll want to pay in the greatest number of individual transactions possible\n> \n> Peers can calculate rewards based on number of inputs or total kb used:\n> you're paying for kilobytes with either coin age or fees no matter what. So\n> I think in practice it's not a big deal.\n\nSo effectively, if you pay for your bandwidth/storage usage via fees, then the reward system is constrained by proof of burn, and if you pay for your usage via coin age, then the reward system is constrained by proof of stake.\n\nNow another concern: won't this proposal increase the likelihood of a network split? The free-market capitalist nodes will want to charge their peers and will kick and ban peers that don't pay up (and will pay their peers to avoid being kicked and banned themselves), whereas the socialist nodes will want all of their peers to feed them transactions out of the goodness of their hearts and will thus necessarily be relegated to connecting only to other altrustic peers. Thus, the network will comprise two incompatible ideological camps, whose nodes won't interconnect."
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-06-16T19:00:17",
                "message_text_only": "There can be multiple independent transport networks for Bitcoin.\n\nThere already is: ipv4, ipv6, Tor, and native_i2p (out of tree patch).\n\nAs long as multihomed hosts that act as bridges then information will propagate across all of them.\n--\nJustus Ranvier\n-----------------\nsent with R2Mail2\n\n----- Original Message -----\nFrom: Matt Whitlock <bip at mattwhitlock.name>\nSent: 2014/06/16 - 13:10\nTo: Mike Hearn <mike at plan99.net>, Justus Ranvier <justusranvier at gmail.com>\nSubject: Re: [Bitcoin-development] Incentivizing the running of full nodes\n\n> On Monday, 16 June 2014, at 7:59 pm, Mike Hearn wrote:\n>> >\n>> > This is a cool idea, but doesn't it generate some perverse incentives? If\n>> > I'm running a full node and I want to pay CheapAir for some plane tickets,\n>> > I'll want to pay in the greatest number of individual transactions possible\n>>\n>> Peers can calculate rewards based on number of inputs or total kb used:\n>> you're paying for kilobytes with either coin age or fees no matter what. So\n>> I think in practice it's not a big deal.\n>\n> So effectively, if you pay for your bandwidth/storage usage via fees, then the reward system is constrained by proof of burn, and if you pay for your usage via coin age, then the reward system is constrained by proof of stake.\n>\n> Now another concern: won't this proposal increase the likelihood of a network split? The free-market capitalist nodes will want to charge their peers and will kick and ban peers that don't pay up (and will pay their peers to avoid being kicked and banned themselves), whereas the socialist nodes will want all of their peers to feed them transactions out of the goodness of their hearts and will thus necessarily be relegated to connecting only to other altrustic peers. Thus, the network will comprise two incompatible ideological camps, whose nodes won't interconnect.\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 532 bytes\nDesc: PGP/MIME digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/b09ddd18/attachment.sig>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-06-16T20:55:12",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 06/16/2014 07:00 PM, Justus Ranvier wrote:\n> There can be multiple independent transport networks for Bitcoin.\n> \n> There already is: ipv4, ipv6, Tor, and native_i2p (out of tree\n> patch).\n> \n> As long as multihomed hosts that act as bridges then information\n> will propagate across all of them. -- Justus Ranvier \n> ----------------- sent with R2Mail2\n> \n> ----- Original Message ----- From: Matt Whitlock\n> <bip at mattwhitlock.name>\n>> Now another concern: won't this proposal increase the likelihood\n>> of a network split? The free-market capitalist nodes will want to\n>> charge their peers and will kick and ban peers that don't pay up\n>> (and will pay their peers to avoid being kicked and banned\n>> themselves), whereas the socialist nodes will want all of their\n>> peers to feed them transactions out of the goodness of their\n>> hearts and will thus necessarily be relegated to connecting only\n>> to other altrustic peers. Thus, the network will comprise two\n>> incompatible ideological camps, whose nodes won't interconnect.\n\nAlso consider that currently there are many people have already\ndemonstrated a willingness to donate bandwidth and resources to the\npublic by running nodes, so those people aren't going to disappear.\n\nThey could operate mixed-mode nodes, with a fraction of the allowed\nincoming connections reserved for free peer, with free connections\nmight be limited in terms of time duration. Bitcoin-accepting\nbrick-and-mortars would probably allow free access to anyone connected\nto their internal wifi to facilitate people wanting to pay.\n\nCrowdfunded free bridges, assurance contracts, etc are all other ways\nto let people get into the network with no upfront cost.\n\n\n- -- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBAgAGBQJTn1mwAAoJEMP3uyY4RQ21ePwIALpMV/GDpAyD4SeL6hWi32vQ\n197YD1LPuLWrEbUs/+gl1Sk2gIsWWlq/o86KcP7Cn4fZdBAKEiF5RpQ6iPsO2+bj\nJR0W/EbgUyzIhYaxFysCzQ1HPzQx+0a2vHn/6FsB7YMha8gvxviF7InDEwcfxbok\no0QS5SeYWryp5mH7IokC6fLYsAPmiueugPVRSD/l8IRFYWVFS9nB+XAR1PWAdYSQ\nXyzu9oyPwlKAjYKxl4XHYB4DofacS89DpWMVbWHviYiZ7UufmzMgwPtfMCsQAxSb\nq3OMAkcSGJZL8pcy9/9NWpOGAHY2DRtGtu8oSqXcBSW/IQCubmUNmzopt8O/H74=\n=9hrW\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x38450DB5.asc\nType: application/pgp-keys\nSize: 12464 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140616/d36e6db3/attachment.bin>"
            },
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-06-17T17:47:53",
                "message_text_only": "> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA1\n>\n> On 06/16/2014 07:00 PM, Justus Ranvier wrote:\n>> There can be multiple independent transport networks for Bitcoin.\n>>\n>> There already is: ipv4, ipv6, Tor, and native_i2p (out of tree\n>> patch).\n>>\n>> As long as multihomed hosts that act as bridges then information\n>> will propagate across all of them. -- Justus Ranvier\n>> ----------------- sent with R2Mail2\n>>\n>> ----- Original Message ----- From: Matt Whitlock\n>> <bip at mattwhitlock.name>\n>>> Now another concern: won't this proposal increase the likelihood\n>>> of a network split? The free-market capitalist nodes will want to\n>>> charge their peers and will kick and ban peers that don't pay up\n>>> (and will pay their peers to avoid being kicked and banned\n>>> themselves), whereas the socialist nodes will want all of their\n>>> peers to feed them transactions out of the goodness of their\n>>> hearts and will thus necessarily be relegated to connecting only\n>>> to other altrustic peers. Thus, the network will comprise two\n>>> incompatible ideological camps, whose nodes won't interconnect.\n\n\nIf the technical development emanating from the proposal follows a design\nwhich ensures that the notion of whether or not someone were to donate\nremains voluntary in nature (there's never any requirement that someone\ndonate to anyone, but incentives can be made), then I don't feel that\nnetwork split would be an issue, because it's just an issue of choice.\nJustus Ranvier suggested a system which would naturally include\npay-to-play networks, and not just free P2P networks.  The question of how\nto limit the number of entries the system registers in the framework of\nthe proposed 'decentralizing lottery' would be fairly straightforward,\nthere could one entry for a distinct period of time (say 30 days as an\nexample) for anyone who meets the suggested criteria of:\n \"those running full nodes (Bitcoin Core (...)), processing their\n  change and txouts through Core, would be provided incentives in the form\n  of a 'decentralizing lottery' such that all participants who are running\n  nodes and donating no matter how infrequently (and no matter who they\n  donate to) will be entered in the 'decentralizing lottery,'\" for a\n  chance to receive \"the 'award amounts'\"\n\nIn my mind I imagine that the smart property qualities of Bitcoin may\neventually enable people to represent what sort of time and energy they\nare putting into maintaining the network, so that rather solely a currency\naspect, people who have done something collaborative with each other to\nhelp advance or develop Bitcoin would be able to show in their donations\nfield that they have a smart property, which could be also expressed in\nequivalence terms as a value of a certain amount of btc, would also be\nable to have the smart property representing their voluntary efforts\nrepresented and given a voice in the blockchain, whether or not they want\nto participate in such a 'decentralizing lottery.'  In point of fact, I\ncontemplate that all aspects of this, at least ideally (to me) should be\nvoluntary, such that if a person is donating through this system, that is\nvoluntary, if they wish to have their donations result in a chance at\nwinning the 'decentralizing lottery,' that is voluntary / an option, and\nif they win, they would have the option to accept the winnings or return\nthem (the bitcoin 'award amount') back to the network.\n\n>\n> Also consider that currently there are many people have already\n> demonstrated a willingness to donate bandwidth and resources to the\n> public by running nodes, so those people aren't going to disappear.\n>\n\nThose who are already dedicated to running nodes will likely (mostly)\nremain, but any ideas reaching technical development and reality as a\nresult of this concept would be intended to help grow that base by\nbringing in persons who might not otherwise be as interested to do so.\n\n> They could operate mixed-mode nodes, with a fraction of the allowed\n> incoming connections reserved for free peer, with free connections\n> might be limited in terms of time duration. Bitcoin-accepting\n> brick-and-mortars would probably allow free access to anyone connected\n> to their internal wifi to facilitate people wanting to pay.\n\n\nThat's a great idea.  The incentives could certainly go beyond just\npointing to Bitcoin Core.  Giving is important to everyone.\n\n>\n> Crowdfunded free bridges, assurance contracts, etc are all other ways\n> to let people get into the network with no upfront cost.\n>\n>\n> - --\n> Support online privacy by using email encryption whenever possible.\n> Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v2.0.22 (GNU/Linux)\n>\n> iQEcBAEBAgAGBQJTn1mwAAoJEMP3uyY4RQ21ePwIALpMV/GDpAyD4SeL6hWi32vQ\n> 197YD1LPuLWrEbUs/+gl1Sk2gIsWWlq/o86KcP7Cn4fZdBAKEiF5RpQ6iPsO2+bj\n> JR0W/EbgUyzIhYaxFysCzQ1HPzQx+0a2vHn/6FsB7YMha8gvxviF7InDEwcfxbok\n> o0QS5SeYWryp5mH7IokC6fLYsAPmiueugPVRSD/l8IRFYWVFS9nB+XAR1PWAdYSQ\n> Xyzu9oyPwlKAjYKxl4XHYB4DofacS89DpWMVbWHviYiZ7UufmzMgwPtfMCsQAxSb\n> q3OMAkcSGJZL8pcy9/9NWpOGAHY2DRtGtu8oSqXcBSW/IQCubmUNmzopt8O/H74=\n> =9hrW\n> -----END PGP SIGNATURE-----\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems_______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            }
        ],
        "thread_summary": {
            "title": "Incentivizing the running of full nodes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Matt Whitlock",
                "Mike Hearn",
                "Justus Ranvier",
                "Odinn Cyberguerrilla"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 27903
        }
    },
    {
        "title": "[Bitcoin-development] Proposal: allocate 8 service bits for experimental use",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2014-06-17T07:23:51",
                "message_text_only": "For my replace-by-fee implementation(1) I used service bit 26 to let\npreferential peering work so that replace-by-fee nodes could easily find\neach other. Of course, that's a temporary/experimental usage that can be\ndropped after wider adoption, so I included the following comment:\n\n    // Reserve 24-31 for temporary experiments\n    NODE_REPLACE_BY_FEE = (1 << 26)\n\nService bits are never a guaranteed thing anyway, so occasional\ncollisions can and should be tolerated by applications using these\nexperimental service bits.\n\n\nAlternately Wladimir J. van der Laan brought up elsewhere(2) the\npossibility for a wider notion of an extension namespace. I'm personally\nnot convinced of the short-term need - we've got 64 service bits yet\nNODE_BLOOM is the first fully fleshed out proposal to use one - but it's\nworth thinking about for the long term.\n\n1) https://github.com/petertodd/bitcoin/tree/replace-by-fee-v0.9.1\n2) https://github.com/bitcoin/bitcoin/pull/4351#issuecomment-46272958\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000058ca7ee3a40438ea5a96e499910638352468c6d69abdb226\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/f952e072/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-17T07:57:35",
                "message_text_only": "On Tue, Jun 17, 2014 at 9:23 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> Alternately Wladimir J. van der Laan brought up elsewhere(2) the\n> possibility for a wider notion of an extension namespace. I'm personally\n> not convinced of the short-term need - we've got 64 service bits yet\n> NODE_BLOOM is the first fully fleshed out proposal to use one - but it's\n> worth thinking about for the long term\n\nYes, as I said in the github topic\n(https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a\nstring-based name space for extensions.\n\nA new network version could add a command 'getextensions' to query the\nsupported extensions, returning a list of extension strings or\n(extension,version) pairs. For BIPs some something like 'BIP0064'\ncould be defined, but for an experiment for example\n'experimental-getutxo'. This would be easy to implement and specify.\n\nUnlike with the 64 service bits it does not require (as much) central\ncoordination to assign as there is no real danger of collisions. It\ntakes the political aspect out of P2P network extensions, and gives\nmore freedom to alternative implementations to experiment with their\nown extensions. And no more need for bitcoin core to drive what must\nbe supported with increasing network versions.\n\nWladimir"
            },
            {
                "author": "Matt Whitlock",
                "date": "2014-06-17T08:02:41",
                "message_text_only": "On Tuesday, 17 June 2014, at 9:57 am, Wladimir wrote:\n> Yes, as I said in the github topic\n> (https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a\n> string-based name space for extensions.\n\nWhy use textual strings? These fields are not for human consumption. Why not use UUIDs, which are fixed length and will not waste as much bandwidth in the protocol? Or if you'd prefer a hierarchical namespace, you could use OIDs, a la ASN.1."
            },
            {
                "author": "Wladimir",
                "date": "2014-06-17T08:08:31",
                "message_text_only": "On Tue, Jun 17, 2014 at 10:02 AM, Matt Whitlock <bip at mattwhitlock.name> wrote:\n> On Tuesday, 17 June 2014, at 9:57 am, Wladimir wrote:\n>> Yes, as I said in the github topic\n>> (https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a\n>> string-based name space for extensions.\n>\n> Why use textual strings? These fields are not for human consumption. Why not use UUIDs, which are fixed length and will not waste as much bandwidth in the protocol? Or if you'd prefer a hierarchical namespace, you could use OIDs, a la ASN.1.\n\nCome on, this is only sent over the line at connection time at most\nonce. No need to overdesign a scheme here.\n\nAnyhow, if we like to bike-shed so much:\n- UUIDs are 16 bytes -- most human-recognizable strings are shorter.\nAnd they're ugly to use as well.\n- OIDs need central and hierarchical coordination, just what we're\ntrying to avoid.\n\nWladimir"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-17T08:16:01",
                "message_text_only": "On Tue, Jun 17, 2014 at 10:08 AM, Wladimir <laanwj at gmail.com> wrote:\n> On Tue, Jun 17, 2014 at 10:02 AM, Matt Whitlock <bip at mattwhitlock.name> wrote:\n>> On Tuesday, 17 June 2014, at 9:57 am, Wladimir wrote:\n>>> Yes, as I said in the github topic\n>>> (https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a\n>>> string-based name space for extensions.\n>>\n>> Why use textual strings? These fields are not for human consumption. Why not use UUIDs, which are fixed length and will not waste as much bandwidth in the protocol? Or if you'd prefer a hierarchical namespace, you could use OIDs, a la ASN.1.\n\nAlso it IS useful for these fields to be human readable for\nstatistics, peer list views and such. When encountering a new, unknown\nextension when connecting to a node it's much more useful to get a\ngoogle-able string to find out what it is about, than some long\nhexadecimal or dotted-number identifier.\n\nWladimir"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-17T21:29:07",
                "message_text_only": "I wrote a patch for string-based name extensions, circa 2011-2012.  I\nagree that is preferable to unreadable bits, for reasons you cite.\n\nHowever, it was noted that extensions (or UUIDs etc.) would not be\npropagated around the network in \"addr\" messages, as service bits are.\n\nOn Tue, Jun 17, 2014 at 3:57 AM, Wladimir <laanwj at gmail.com> wrote:\n> On Tue, Jun 17, 2014 at 9:23 AM, Peter Todd <pete at petertodd.org> wrote:\n>\n>> Alternately Wladimir J. van der Laan brought up elsewhere(2) the\n>> possibility for a wider notion of an extension namespace. I'm personally\n>> not convinced of the short-term need - we've got 64 service bits yet\n>> NODE_BLOOM is the first fully fleshed out proposal to use one - but it's\n>> worth thinking about for the long term\n>\n> Yes, as I said in the github topic\n> (https://github.com/bitcoin/bitcoin/pull/4351) I suggest we adapt a\n> string-based name space for extensions.\n>\n> A new network version could add a command 'getextensions' to query the\n> supported extensions, returning a list of extension strings or\n> (extension,version) pairs. For BIPs some something like 'BIP0064'\n> could be defined, but for an experiment for example\n> 'experimental-getutxo'. This would be easy to implement and specify.\n>\n> Unlike with the 64 service bits it does not require (as much) central\n> coordination to assign as there is no real danger of collisions. It\n> takes the political aspect out of P2P network extensions, and gives\n> more freedom to alternative implementations to experiment with their\n> own extensions. And no more need for bitcoin core to drive what must\n> be supported with increasing network versions.\n>\n> Wladimir\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-18T06:20:26",
                "message_text_only": "On Tue, Jun 17, 2014 at 11:29 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> I wrote a patch for string-based name extensions, circa 2011-2012.  I\n> agree that is preferable to unreadable bits, for reasons you cite.\n>\n> However, it was noted that extensions (or UUIDs etc.) would not be\n> propagated around the network in \"addr\" messages, as service bits are.\n\nThanks for letting me know, I didn't remember your patch.\n\nUgh, yes, propagating all extensions in `addr` messages is not how I\nimagined this to work.\n\nBut then there would need to be an alternative way to discover nodes\nthat offer a certain extension. Alas, this moves it from a\nstraightforward and common sense change to a significant change to the\nprotocol.\n\nWladimir"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-18T10:23:57",
                "message_text_only": "On Tue, Jun 17, 2014 at 9:23 AM, Peter Todd <pete at petertodd.org> wrote:\n> For my replace-by-fee implementation(1) I used service bit 26 to let\n> preferential peering work so that replace-by-fee nodes could easily find\n> each other. Of course, that's a temporary/experimental usage that can be\n> dropped after wider adoption, so I included the following comment:\n>\n>     // Reserve 24-31 for temporary experiments\n>     NODE_REPLACE_BY_FEE = (1 << 26)\n>\n> Service bits are never a guaranteed thing anyway, so occasional\n> collisions can and should be tolerated by applications using these\n> experimental service bits.\n\nAnyhow -- back to the original proposal. I'm fine with setting aside\npart of the service bit space for experiments.\n\nWladimir"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-18T11:48:47",
                "message_text_only": "On Wed, Jun 18, 2014 at 5:23 AM, Wladimir <laanwj at gmail.com> wrote:\n> Anyhow -- back to the original proposal. I'm fine with setting aside\n> part of the service bit space for experiments.\n\nACK\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            }
        ],
        "thread_summary": {
            "title": "Proposal: allocate 8 service bits for experimental use",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Matt Whitlock",
                "Wladimir",
                "Peter Todd",
                "Jeff Garzik"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 9021
        }
    },
    {
        "title": "[Bitcoin-development] Proposals for improving Bitcoin mining decentralization",
        "thread_messages": [
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-17T08:57:06",
                "message_text_only": "First of all I apologice due to the possible mistakes in my writing below,\nI am not a Bitcoin developer but I have some knowledge about it.\n\n----\n\nWe all know the recent news, Ghash pool controlling 51% of the hashrate.\nWhile some consider it a threat others think that is not harmful.\n\nThe thing is that we have to do something to stop this from happening again.\n\nMy proposal is to start thinking about miners that join a pool like\nindependent miners and not slave miners, this includes creating a new\nmining protocol that does not rely on the pool sending the list of\ntransactions to include in a block. Each individual miner has to collect\ntransactions by his own and mine that, this can be achieved by running a\nfull node or by running a SPV like node that ask other nodes for\ntransactions.\n\nOnce this protocol is developed and standarised we as a community could\nrequire all pools to use it (because its better, because is more\ntrustless...), not by imposing it but by recommending it.\n\nPool owners could send some instructions using this protocol to the miner\nabout how many transactions to include per block (some pools want small\nblocks), how many 0 fee transactions to include, how much is the minimum\nfee per Kb to include transactions and some info about the Coinbase field\nin the block.\n\nThis way is impossible to perform some of the possible 51% attacks:\n\n   - A pool owner cant mine a new chain (selfish mining) (pool clients have\n   a SPV or full node that has checkpoints and ask other peers about the\n   length of the chain)\n   - A pool owner can't perform double spends or reverse transactions (pool\n   clients know all the transactions relayed to the network, they know if they\n   are already included on a block)\n   - A pool owner cant decide which transactions not to include (but they\n   can configure the minimum fee).\n   - A pool owner cant get all the rewards by avoiding other pools from\n   mining blocks (Because the pool client knows the last block independently\n   that is from his pool or other).\n\n\nThe only thing that a 51% pool owner can do is to shut down his pool and\ndrop the hashrate by 51% because he does not control the miners.\n\nIf the pool owner owns all the hardware in the pool my proposal is not\nvalid, if the pool clients dont use this protocol my proposal is not valid.\n\n\nI want to know if this is possible or its been developed or there is\nalready a working protocol that works like this, also I want to read other\npeople's ways to address this threat, thanks for reading.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/9529a793/attachment.html>"
            },
            {
                "author": "Ron Elliott",
                "date": "2014-06-17T13:58:53",
                "message_text_only": "In this scenario how do you ensure the miner solving the block cannot\nreapportion the subsidy to himself rather than the pool?\nOn Jun 17, 2014 2:09 AM, \"Ra\u00fal Mart\u00ednez\" <rme at i-rme.es> wrote:\n\n> First of all I apologice due to the possible mistakes in my writing below,\n> I am not a Bitcoin developer but I have some knowledge about it.\n>\n> ----\n>\n> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n> While some consider it a threat others think that is not harmful.\n>\n> The thing is that we have to do something to stop this from happening\n> again.\n>\n> My proposal is to start thinking about miners that join a pool like\n> independent miners and not slave miners, this includes creating a new\n> mining protocol that does not rely on the pool sending the list of\n> transactions to include in a block. Each individual miner has to collect\n> transactions by his own and mine that, this can be achieved by running a\n> full node or by running a SPV like node that ask other nodes for\n> transactions.\n>\n> Once this protocol is developed and standarised we as a community could\n> require all pools to use it (because its better, because is more\n> trustless...), not by imposing it but by recommending it.\n>\n> Pool owners could send some instructions using this protocol to the miner\n> about how many transactions to include per block (some pools want small\n> blocks), how many 0 fee transactions to include, how much is the minimum\n> fee per Kb to include transactions and some info about the Coinbase field\n> in the block.\n>\n> This way is impossible to perform some of the possible 51% attacks:\n>\n>    - A pool owner cant mine a new chain (selfish mining) (pool clients\n>    have a SPV or full node that has checkpoints and ask other peers about the\n>    length of the chain)\n>    - A pool owner can't perform double spends or reverse transactions\n>    (pool clients know all the transactions relayed to the network, they know\n>    if they are already included on a block)\n>    - A pool owner cant decide which transactions not to include (but they\n>    can configure the minimum fee).\n>    - A pool owner cant get all the rewards by avoiding other pools from\n>    mining blocks (Because the pool client knows the last block independently\n>    that is from his pool or other).\n>\n>\n> The only thing that a 51% pool owner can do is to shut down his pool and\n> drop the hashrate by 51% because he does not control the miners.\n>\n> If the pool owner owns all the hardware in the pool my proposal is not\n> valid, if the pool clients dont use this protocol my proposal is not valid.\n>\n>\n> I want to know if this is possible or its been developed or there is\n> already a working protocol that works like this, also I want to read other\n> people's ways to address this threat, thanks for reading.\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/7251f9ba/attachment.html>"
            },
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-17T14:01:02",
                "message_text_only": "Because he cant change the coinbase once the proof of work is done.\n El 17/06/2014 15:58, \"Ron Elliott\" <ronaldbelliott at gmail.com> escribi\u00f3:\n\n> In this scenario how do you ensure the miner solving the block cannot\n> reapportion the subsidy to himself rather than the pool?\n> On Jun 17, 2014 2:09 AM, \"Ra\u00fal Mart\u00ednez\" <rme at i-rme.es> wrote:\n>\n>> First of all I apologice due to the possible mistakes in my writing\n>> below, I am not a Bitcoin developer but I have some knowledge about it.\n>>\n>> ----\n>>\n>> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n>> While some consider it a threat others think that is not harmful.\n>>\n>> The thing is that we have to do something to stop this from happening\n>> again.\n>>\n>> My proposal is to start thinking about miners that join a pool like\n>> independent miners and not slave miners, this includes creating a new\n>> mining protocol that does not rely on the pool sending the list of\n>> transactions to include in a block. Each individual miner has to collect\n>> transactions by his own and mine that, this can be achieved by running a\n>> full node or by running a SPV like node that ask other nodes for\n>> transactions.\n>>\n>> Once this protocol is developed and standarised we as a community could\n>> require all pools to use it (because its better, because is more\n>> trustless...), not by imposing it but by recommending it.\n>>\n>> Pool owners could send some instructions using this protocol to the miner\n>> about how many transactions to include per block (some pools want small\n>> blocks), how many 0 fee transactions to include, how much is the minimum\n>> fee per Kb to include transactions and some info about the Coinbase field\n>> in the block.\n>>\n>> This way is impossible to perform some of the possible 51% attacks:\n>>\n>>    - A pool owner cant mine a new chain (selfish mining) (pool clients\n>>    have a SPV or full node that has checkpoints and ask other peers about the\n>>    length of the chain)\n>>    - A pool owner can't perform double spends or reverse transactions\n>>    (pool clients know all the transactions relayed to the network, they know\n>>    if they are already included on a block)\n>>    - A pool owner cant decide which transactions not to include (but\n>>    they can configure the minimum fee).\n>>    - A pool owner cant get all the rewards by avoiding other pools from\n>>    mining blocks (Because the pool client knows the last block independently\n>>    that is from his pool or other).\n>>\n>>\n>> The only thing that a 51% pool owner can do is to shut down his pool and\n>> drop the hashrate by 51% because he does not control the miners.\n>>\n>> If the pool owner owns all the hardware in the pool my proposal is not\n>> valid, if the pool clients dont use this protocol my proposal is not valid.\n>>\n>>\n>> I want to know if this is possible or its been developed or there is\n>> already a working protocol that works like this, also I want to read other\n>> people's ways to address this threat, thanks for reading.\n>>\n>>\n>> ------------------------------------------------------------------------------\n>> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n>> Find What Matters Most in Your Big Data with HPCC Systems\n>> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n>> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n>> http://p.sf.net/sfu/hpccsystems\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/d5e763e6/attachment.html>"
            },
            {
                "author": "Ron Elliott",
                "date": "2014-06-17T14:06:41",
                "message_text_only": "as I understood your proposal the entire block would be created on the\nminer rather than just the block header. Currently miners do not receive a\nlist of transactions, they receive information required to create the block\nheader, this is how you keep miners honest. if the miner is creating the\nfull block we are right back to where we were.\n\nI've only worked with implementing the mining process for a few months now\nso someone correct me if I have the process wrong\nOn Jun 17, 2014 7:01 AM, \"Ra\u00fal Mart\u00ednez\" <rme at i-rme.es> wrote:\n\n> Because he cant change the coinbase once the proof of work is done.\n>  El 17/06/2014 15:58, \"Ron Elliott\" <ronaldbelliott at gmail.com> escribi\u00f3:\n>\n>> In this scenario how do you ensure the miner solving the block cannot\n>> reapportion the subsidy to himself rather than the pool?\n>> On Jun 17, 2014 2:09 AM, \"Ra\u00fal Mart\u00ednez\" <rme at i-rme.es> wrote:\n>>\n>>> First of all I apologice due to the possible mistakes in my writing\n>>> below, I am not a Bitcoin developer but I have some knowledge about it.\n>>>\n>>> ----\n>>>\n>>> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n>>> While some consider it a threat others think that is not harmful.\n>>>\n>>> The thing is that we have to do something to stop this from happening\n>>> again.\n>>>\n>>> My proposal is to start thinking about miners that join a pool like\n>>> independent miners and not slave miners, this includes creating a new\n>>> mining protocol that does not rely on the pool sending the list of\n>>> transactions to include in a block. Each individual miner has to collect\n>>> transactions by his own and mine that, this can be achieved by running a\n>>> full node or by running a SPV like node that ask other nodes for\n>>> transactions.\n>>>\n>>> Once this protocol is developed and standarised we as a community could\n>>> require all pools to use it (because its better, because is more\n>>> trustless...), not by imposing it but by recommending it.\n>>>\n>>> Pool owners could send some instructions using this protocol to the\n>>> miner about how many transactions to include per block (some pools want\n>>> small blocks), how many 0 fee transactions to include, how much is the\n>>> minimum fee per Kb to include transactions and some info about the Coinbase\n>>> field in the block.\n>>>\n>>> This way is impossible to perform some of the possible 51% attacks:\n>>>\n>>>    - A pool owner cant mine a new chain (selfish mining) (pool clients\n>>>    have a SPV or full node that has checkpoints and ask other peers about the\n>>>    length of the chain)\n>>>    - A pool owner can't perform double spends or reverse transactions\n>>>    (pool clients know all the transactions relayed to the network, they know\n>>>    if they are already included on a block)\n>>>    - A pool owner cant decide which transactions not to include (but\n>>>    they can configure the minimum fee).\n>>>    - A pool owner cant get all the rewards by avoiding other pools from\n>>>    mining blocks (Because the pool client knows the last block independently\n>>>    that is from his pool or other).\n>>>\n>>>\n>>> The only thing that a 51% pool owner can do is to shut down his pool and\n>>> drop the hashrate by 51% because he does not control the miners.\n>>>\n>>> If the pool owner owns all the hardware in the pool my proposal is not\n>>> valid, if the pool clients dont use this protocol my proposal is not valid.\n>>>\n>>>\n>>> I want to know if this is possible or its been developed or there is\n>>> already a working protocol that works like this, also I want to read other\n>>> people's ways to address this threat, thanks for reading.\n>>>\n>>>\n>>> ------------------------------------------------------------------------------\n>>> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n>>> Find What Matters Most in Your Big Data with HPCC Systems\n>>> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n>>> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n>>> http://p.sf.net/sfu/hpccsystems\n>>> _______________________________________________\n>>> Bitcoin-development mailing list\n>>> Bitcoin-development at lists.sourceforge.net\n>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/14874493/attachment.html>"
            },
            {
                "author": "Christophe Biocca",
                "date": "2014-06-17T14:20:42",
                "message_text_only": "https://en.bitcoin.it/wiki/Getblocktemplate is supposed to solve most\nof the pooling-centralization problems. Unfortunately, it is opt-in,\nand GHash.io doesn't support it.\n\nAlso most miners don't care and don't do the work to set it up. To do\ntransaction inclusion themselves, they'd need to run a full node,\nwhich is a bit more work and resources than just pointing hashpower at\na stratum server.\n\nIf you figure out a way to make GBT widely used (>50% hashpower), kudos to you.\n\nOn Tue, Jun 17, 2014 at 4:57 AM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n> First of all I apologice due to the possible mistakes in my writing below, I\n> am not a Bitcoin developer but I have some knowledge about it.\n>\n> ----\n>\n> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n> While some consider it a threat others think that is not harmful.\n>\n> The thing is that we have to do something to stop this from happening again.\n>\n> My proposal is to start thinking about miners that join a pool like\n> independent miners and not slave miners, this includes creating a new mining\n> protocol that does not rely on the pool sending the list of transactions to\n> include in a block. Each individual miner has to collect transactions by his\n> own and mine that, this can be achieved by running a full node or by running\n> a SPV like node that ask other nodes for transactions.\n>\n> Once this protocol is developed and standarised we as a community could\n> require all pools to use it (because its better, because is more\n> trustless...), not by imposing it but by recommending it.\n>\n> Pool owners could send some instructions using this protocol to the miner\n> about how many transactions to include per block (some pools want small\n> blocks), how many 0 fee transactions to include, how much is the minimum fee\n> per Kb to include transactions and some info about the Coinbase field in the\n> block.\n>\n> This way is impossible to perform some of the possible 51% attacks:\n>\n> A pool owner cant mine a new chain (selfish mining) (pool clients have a SPV\n> or full node that has checkpoints and ask other peers about the length of\n> the chain)\n> A pool owner can't perform double spends or reverse transactions (pool\n> clients know all the transactions relayed to the network, they know if they\n> are already included on a block)\n> A pool owner cant decide which transactions not to include (but they can\n> configure the minimum fee).\n> A pool owner cant get all the rewards by avoiding other pools from mining\n> blocks (Because the pool client knows the last block independently that is\n> from his pool or other).\n>\n>\n> The only thing that a 51% pool owner can do is to shut down his pool and\n> drop the hashrate by 51% because he does not control the miners.\n>\n> If the pool owner owns all the hardware in the pool my proposal is not\n> valid, if the pool clients dont use this protocol my proposal is not valid.\n>\n>\n> I want to know if this is possible or its been developed or there is already\n> a working protocol that works like this, also I want to read other people's\n> ways to address this threat, thanks for reading.\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Isidor Zeuner",
                "date": "2014-06-17T15:58:45",
                "message_text_only": "quote:\n> https://en.bitcoin.it/wiki/Getblocktemplate is supposed to solve most\n> of the pooling-centralization problems. Unfortunately, it is opt-in,\n> and GHash.io doesn't support it.\n> \n> Also most miners don't care and don't do the work to set it up. To do\n> transaction inclusion themselves, they'd need to run a full node,\n> which is a bit more work and resources than just pointing hashpower at\n> a stratum server.\n> \n> If you figure out a way to make GBT widely used (>50% hashpower), kudos to you.\n>\n\nWell, as soon as miners learn about the merits of controlling the\nblocks' contents, this issue may get solved by the market pressure\nof miners expecting this kind of service from their pool.\n\nI mean, the dev community constantly has some level of disagreement\nabout the best policies for what to include in blocks. But seen from\nthe perspective of some Bitcoin business or another, certain policies\nmight be more preferable. So if miners start to understand that they\ncould take a stake for their favourite Bitcoin businesses by choosing\na mining pool which employs a preferable transaction inclusion policy,\nthe question would not anymore be \"which pool gives me the most\nBitcoins or the lowest variance, regardless of the technical\nbackground\", but \"which pools does the best for my Bitcoin economy\nneeds\". And this may be a very economically driven decision by itself,\nconsidering that the exchange rates for Bitcoins depend on Bitcoin\nbusinesses doing well.\n\nIf we get to this point with respect to user (miner) education, then\nit is probably only a matter of time until people start to find it\ncumbersome to mine on a black-box pool and having to manually verify\nthat they still have an agreeable transaction inclusion policy, when\nthey can just mine on a GBT pool and configure things in their mining\nsoftware.\n\n> On Tue, Jun 17, 2014 at 4:57 AM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n[...]\n> > We all know the recent news, Ghash pool controlling 51% of the hashrate.\n> > While some consider it a threat others think that is not harmful.\n> >\n> > The thing is that we have to do something to stop this from happening again.\n> >\n\nBear with me, but this piece of rhetorics struck me. Why even mention\nthose who think it's not harmful, when your next sentence states\nthat their opinion should be ignored completely?\n\nBest regards,\n\nIsidor\n>"
            },
            {
                "author": "Karel B\u00edlek",
                "date": "2014-06-17T18:25:39",
                "message_text_only": "On Tue, Jun 17, 2014 at 4:20 PM, Christophe Biocca\n<christophe.biocca at gmail.com> wrote:\n> https://en.bitcoin.it/wiki/Getblocktemplate is supposed to solve most\n> of the pooling-centralization problems.\n\nThis. There is no need to create anything new when GBT already exists.\nIn my opinion.\n\n> Unfortunately, it is opt-in,\n> and GHash.io doesn't support it.\n\nYep. As pools in general are not a part of the bitcoin protocol itself\n(nobody cares how the work happened), I am not sure how this can be\nforced.\n\n> Also most miners don't care and don't do the work to set it up. To do\n> transaction inclusion themselves, they'd need to run a full node,\n> which is a bit more work and resources than just pointing hashpower at\n> a stratum server.\n\nAlso, yep. If the miners cared about 51% attack, they wouldn't join\nghash in the first place. All the miners willingly accept the risk in\njoining the big pool.\n\nK. B.\n\n> If you figure out a way to make GBT widely used (>50% hashpower), kudos to you.\n>\n> On Tue, Jun 17, 2014 at 4:57 AM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n>> First of all I apologice due to the possible mistakes in my writing below, I\n>> am not a Bitcoin developer but I have some knowledge about it.\n>>\n>> ----\n>>\n>> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n>> While some consider it a threat others think that is not harmful.\n>>\n>> The thing is that we have to do something to stop this from happening again.\n>>\n>> My proposal is to start thinking about miners that join a pool like\n>> independent miners and not slave miners, this includes creating a new mining\n>> protocol that does not rely on the pool sending the list of transactions to\n>> include in a block. Each individual miner has to collect transactions by his\n>> own and mine that, this can be achieved by running a full node or by running\n>> a SPV like node that ask other nodes for transactions.\n>>\n>> Once this protocol is developed and standarised we as a community could\n>> require all pools to use it (because its better, because is more\n>> trustless...), not by imposing it but by recommending it.\n>>\n>> Pool owners could send some instructions using this protocol to the miner\n>> about how many transactions to include per block (some pools want small\n>> blocks), how many 0 fee transactions to include, how much is the minimum fee\n>> per Kb to include transactions and some info about the Coinbase field in the\n>> block.\n>>\n>> This way is impossible to perform some of the possible 51% attacks:\n>>\n>> A pool owner cant mine a new chain (selfish mining) (pool clients have a SPV\n>> or full node that has checkpoints and ask other peers about the length of\n>> the chain)\n>> A pool owner can't perform double spends or reverse transactions (pool\n>> clients know all the transactions relayed to the network, they know if they\n>> are already included on a block)\n>> A pool owner cant decide which transactions not to include (but they can\n>> configure the minimum fee).\n>> A pool owner cant get all the rewards by avoiding other pools from mining\n>> blocks (Because the pool client knows the last block independently that is\n>> from his pool or other).\n>>\n>>\n>> The only thing that a 51% pool owner can do is to shut down his pool and\n>> drop the hashrate by 51% because he does not control the miners.\n>>\n>> If the pool owner owns all the hardware in the pool my proposal is not\n>> valid, if the pool clients dont use this protocol my proposal is not valid.\n>>\n>>\n>> I want to know if this is possible or its been developed or there is already\n>> a working protocol that works like this, also I want to read other people's\n>> ways to address this threat, thanks for reading.\n>>\n>> ------------------------------------------------------------------------------\n>> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n>> Find What Matters Most in Your Big Data with HPCC Systems\n>> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n>> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n>> http://p.sf.net/sfu/hpccsystems\n>> _______________________________________________\n>> Bitcoin-development mailing list\n>> Bitcoin-development at lists.sourceforge.net\n>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development"
            },
            {
                "author": "Ra\u00fal Mart\u00ednez",
                "date": "2014-06-17T19:01:00",
                "message_text_only": "But miners dont want to run full nodes, its better to develop some SPV like\nthat connects to some nodes.\n\nAlso I believe that stratum mining protocol improves some performance\nthings that GBT lacks.\n\nIf a new protocol that requires blocks created by miners is developed and\nnamed in a cool way, miners could ask for protocol support to his favourite\npool.\nEl 17/06/2014 20:26, \"Karel B\u00edlek\" <kb at karelbilek.com> escribi\u00f3:\n\n> On Tue, Jun 17, 2014 at 4:20 PM, Christophe Biocca\n> <christophe.biocca at gmail.com> wrote:\n> > https://en.bitcoin.it/wiki/Getblocktemplate is supposed to solve most\n> > of the pooling-centralization problems.\n>\n> This. There is no need to create anything new when GBT already exists.\n> In my opinion.\n>\n> > Unfortunately, it is opt-in,\n> > and GHash.io doesn't support it.\n>\n> Yep. As pools in general are not a part of the bitcoin protocol itself\n> (nobody cares how the work happened), I am not sure how this can be\n> forced.\n>\n> > Also most miners don't care and don't do the work to set it up. To do\n> > transaction inclusion themselves, they'd need to run a full node,\n> > which is a bit more work and resources than just pointing hashpower at\n> > a stratum server.\n>\n> Also, yep. If the miners cared about 51% attack, they wouldn't join\n> ghash in the first place. All the miners willingly accept the risk in\n> joining the big pool.\n>\n> K. B.\n>\n> > If you figure out a way to make GBT widely used (>50% hashpower), kudos\n> to you.\n> >\n> > On Tue, Jun 17, 2014 at 4:57 AM, Ra\u00fal Mart\u00ednez <rme at i-rme.es> wrote:\n> >> First of all I apologice due to the possible mistakes in my writing\n> below, I\n> >> am not a Bitcoin developer but I have some knowledge about it.\n> >>\n> >> ----\n> >>\n> >> We all know the recent news, Ghash pool controlling 51% of the hashrate.\n> >> While some consider it a threat others think that is not harmful.\n> >>\n> >> The thing is that we have to do something to stop this from happening\n> again.\n> >>\n> >> My proposal is to start thinking about miners that join a pool like\n> >> independent miners and not slave miners, this includes creating a new\n> mining\n> >> protocol that does not rely on the pool sending the list of\n> transactions to\n> >> include in a block. Each individual miner has to collect transactions\n> by his\n> >> own and mine that, this can be achieved by running a full node or by\n> running\n> >> a SPV like node that ask other nodes for transactions.\n> >>\n> >> Once this protocol is developed and standarised we as a community could\n> >> require all pools to use it (because its better, because is more\n> >> trustless...), not by imposing it but by recommending it.\n> >>\n> >> Pool owners could send some instructions using this protocol to the\n> miner\n> >> about how many transactions to include per block (some pools want small\n> >> blocks), how many 0 fee transactions to include, how much is the\n> minimum fee\n> >> per Kb to include transactions and some info about the Coinbase field\n> in the\n> >> block.\n> >>\n> >> This way is impossible to perform some of the possible 51% attacks:\n> >>\n> >> A pool owner cant mine a new chain (selfish mining) (pool clients have\n> a SPV\n> >> or full node that has checkpoints and ask other peers about the length\n> of\n> >> the chain)\n> >> A pool owner can't perform double spends or reverse transactions (pool\n> >> clients know all the transactions relayed to the network, they know if\n> they\n> >> are already included on a block)\n> >> A pool owner cant decide which transactions not to include (but they can\n> >> configure the minimum fee).\n> >> A pool owner cant get all the rewards by avoiding other pools from\n> mining\n> >> blocks (Because the pool client knows the last block independently that\n> is\n> >> from his pool or other).\n> >>\n> >>\n> >> The only thing that a 51% pool owner can do is to shut down his pool and\n> >> drop the hashrate by 51% because he does not control the miners.\n> >>\n> >> If the pool owner owns all the hardware in the pool my proposal is not\n> >> valid, if the pool clients dont use this protocol my proposal is not\n> valid.\n> >>\n> >>\n> >> I want to know if this is possible or its been developed or there is\n> already\n> >> a working protocol that works like this, also I want to read other\n> people's\n> >> ways to address this threat, thanks for reading.\n> >>\n> >>\n> ------------------------------------------------------------------------------\n> >> HPCC Systems Open Source Big Data Platform from LexisNexis Risk\n> Solutions\n> >> Find What Matters Most in Your Big Data with HPCC Systems\n> >> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> >> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> >> http://p.sf.net/sfu/hpccsystems\n> >> _______________________________________________\n> >> Bitcoin-development mailing list\n> >> Bitcoin-development at lists.sourceforge.net\n> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n> >>\n> >\n> >\n> ------------------------------------------------------------------------------\n> > HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> > Find What Matters Most in Your Big Data with HPCC Systems\n> > Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> > Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> > http://p.sf.net/sfu/hpccsystems\n> > _______________________________________________\n> > Bitcoin-development mailing list\n> > Bitcoin-development at lists.sourceforge.net\n> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/679356fb/attachment.html>"
            },
            {
                "author": "Mistr Bigs",
                "date": "2014-06-17T09:23:06",
                "message_text_only": "I have been surprised by the lack of discussion of this topic here!\n\nOn 6/17/2014 10:57 AM, Ra\u00fal Mart\u00ednez wrote:\n\nWe all know the recent news, Ghash pool controlling 51% of the hashrate.\nWhile some consider it a threat others think that is not harmful.\n\nThe thing is that we have to do something to stop this from happening again.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/e97faf7c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposals for improving Bitcoin mining decentralization",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Isidor Zeuner",
                "Karel B\u00edlek",
                "Ron Elliott",
                "Ra\u00fal Mart\u00ednez",
                "Christophe Biocca",
                "Mistr Bigs"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 31657
        }
    },
    {
        "title": "[Bitcoin-development] [ann] Bitcoin Core version 0.9.2 has been released",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-17T09:46:52",
                "message_text_only": "Bitcoin Core version 0.9.2 is now available from:\n\n  https://bitcoin.org/bin/0.9.2/\n\n(or https://bitcoin.org/en/download)\n\nThis is a new minor version release, bringing mostly bug fixes and some minor\nimprovements. OpenSSL has been updated because of a security issue\n(CVE-2014-0224).\nUpgrading to this release is recommended.\n\nPlease report bugs using the issue tracker at github:\n\n  https://github.com/bitcoin/bitcoin/issues\n\nUpgrading and downgrading\n==========================\n\nHow to Upgrade\n--------------\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\nbitcoind/bitcoin-qt (on Linux).\n\nIf you are upgrading from version 0.7.2 or earlier, the first time you run\n0.9.0 your blockchain files will be re-indexed, which will take anywhere from\n30 minutes to several hours, depending on the speed of your machine.\n\nDowngrading warnings\n--------------------\n\nThe 'chainstate' for this release is not always compatible with previous\nreleases, so if you run 0.9.x and then decide to switch back to a\n0.8.x release you might get a blockchain validation error when starting the\nold release (due to 'pruned outputs' being omitted from the index of\nunspent transaction outputs).\n\nRunning the old release with the -reindex option will rebuild the chainstate\ndata structures and correct the problem.\n\nAlso, the first time you run a 0.8.x release on a 0.9 wallet it will rescan\nthe blockchain for missing spent coins, which will take a long time (tens\nof minutes on a typical machine).\n\nImportant changes\n==================\n\nGitian OSX build\n-----------------\n\nThe deterministic build system that was already used for Windows and Linux\nbuilds is now used for OSX as well. Although the resulting executables have\nbeen tested quite a bit, there could be possible regressions. Be sure to report\nthese on the Github bug tracker mentioned above.\n\nCompatibility of Linux build\n-----------------------------\n\nFor Linux we now build against Qt 4.6, and filter the symbols for\nlibstdc++ and glibc.\nThis brings back compatibility with\n\n- Debian 6+ / Tails\n- Ubuntu 10.04\n- CentOS 6.5\n\n0.9.2 Release notes\n=======================\n\nThe OpenSSL dependency in the gitian builds has been upgraded to\n1.0.1h because of CVE-2014-0224.\n\nRPC:\n- Add `getwalletinfo`, `getblockchaininfo` and `getnetworkinfo` calls\n(will replace hodge-podge `getinfo` at some point)\n- Add a `relayfee` field to `getnetworkinfo`\n- Fix RPC related shutdown hangs and leaks\n- Always show syncnode in `getpeerinfo`\n- `sendrawtransaction`: report the reject code and reason, and make it\npossible to re-send transactions that are already in the mempool\n- `getmininginfo` show right genproclimit\n\nCommand-line options:\n- Fix `-printblocktree` output\n- Show error message if ReadConfigFile fails\n\nBlock-chain handling and storage:\n- Fix for GetBlockValue() after block 13,440,000 (BIP42)\n- Upgrade leveldb to 1.17\n\nProtocol and network code:\n- Per-peer block download tracking and stalled download detection\n- Add new DNS seed from bitnodes.io\n- Prevent socket leak in ThreadSocketHandler and correct some proxy\nrelated socket leaks\n- Use pnode->nLastRecv as sync score (was the wrong way around)\n\nWallet:\n- Make GetAvailableCredit run GetHash() only once per transaction\n(performance improvement)\n- Lower paytxfee warning threshold from 0.25 BTC to 0.01 BTC\n- Fix importwallet nTimeFirstKey (trigger necessary rescans)\n- Log BerkeleyDB version at startup\n- CWallet init fix\n\nBuild system:\n- Add OSX build descriptors to gitian\n- Fix explicit --disable-qt-dbus\n- Don't require db_cxx.h when compiling with wallet disabled and GUI enabled\n- Improve missing boost error reporting\n- Upgrade miniupnpc version to 1.9\n- gitian-linux: --enable-glibc-back-compat for binary compatibility\nwith old distributions\n- gitian: don't export any symbols from executable\n- gitian: build against Qt 4.6\n- devtools: add script to check symbols from Linux gitian executables\n- Remove build-time no-IPv6 setting\n\nGUI:\n- Fix various coin control visual issues\n- Show number of in/out connections in debug console\n- Show weeks as well as years behind for long timespans behind\n- Enable and disable the Show and Remove buttons for requested\npayments history based on whether any entry is selected.\n- Show also value for options overridden on command line in options dialog\n- Fill in label from address book also for URIs\n- Fixes feel when resizing the last column on tables (issue #2862)\n- Fix ESC in disablewallet mode\n- Add expert section to wallet tab in optionsdialog\n- Do proper boost::path conversion (fixes unicode in datadir)\n- Only override -datadir if different from the default (fixes -datadir\nin config file)\n- Show rescan progress at start-up\n- Show importwallet progress\n- Get required locks upfront in polling functions (avoids hanging on locks)\n- Catch Windows shutdown events while client is running\n- Optionally add third party links to transaction context menu\n- Check for !pixmap() before trying to export QR code (avoids crashes\nwhen no QR code could be generated)\n- Fix \"Start bitcoin on system login\"\n\nMiscellaneous:\n\n- Replace non-threadsafe C functions (gmtime, strerror and setlocale)\n- Add missing cs_main and wallet locks\n- Avoid exception at startup when system locale not recognized\n- Changed bitrpc.py's raw_input to getpass for passwords to conceal\ncharacters during command line input\n- devtools: add a script to fetch and postprocess translations\n\nCredits\n--------\n\nThanks to everyone who contributed to this release:\n\n- Addy Yeow\n- Altoidnerd\n- Andrea D'Amore\n- Andreas Schildbach\n- Bardi Harborow\n- Brandon Dahler\n- Bryan Bishop\n- Chris Beams\n- Christian von Roques\n- Cory Fields\n- Cozz Lovan\n- daniel\n- Daniel Newton\n- David A. Harding\n- ditto-b\n- duanemoody\n- Eric S. Bullington\n- Fabian Raetz\n- Gavin Andresen\n- Gregory Maxwell\n- gubatron\n- Haakon Nilsen\n- harry\n- Hector Jusforgues\n- Isidoro Ghezzi\n- Jeff Garzik\n- Johnathan Corgan\n- jtimon\n- Kamil Domanski\n- langerhans\n- Luke Dashjr\n- Manuel Araoz\n- Mark Friedenbach\n- Matt Corallo\n- Matthew Bogosian\n- Meeh\n- Michael Ford\n- Michagogo\n- Mikael Wikman\n- Mike Hearn\n- olalonde\n- paveljanik\n- peryaudo\n- Philip Kaufmann\n- philsong\n- Pieter Wuille\n- R E Broadley\n- richierichrawr\n- Rune K. Svendsen\n- rxl\n- shshshsh\n- Simon de la Rouviere\n- Stuart Cardall\n- super3\n- Telepatheic\n- Thomas Zander\n- Torstein Huseb\u00f8\n- Warren Togami\n- Wladimir J. van der Laan\n- Yoichi Hirai"
            },
            {
                "author": "Jesus Cea",
                "date": "2014-06-17T14:27:24",
                "message_text_only": "On 17/06/14 11:46, Wladimir wrote:\n> For Linux we now build against Qt 4.6, and filter the symbols for\n> libstdc++ and glibc.\n> This brings back compatibility with\n> \n> - Debian 6+ / Tails\n> - Ubuntu 10.04\n> - CentOS 6.5\n\nUnder Ubuntu 10.04:\n\njcea at ubuntu:/tmp/bitcoin-0.9.2-linux/bin/64$ ./bitcoin-qt\n./bitcoin-qt: symbol lookup error: ./bitcoin-qt: undefined symbol:\n_ZN10QTextCodec11validCodecsEv\n\n-- \nJes\u00fas Cea Avi\u00f3n                         _/_/      _/_/_/        _/_/_/\njcea at jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/\nTwitter: @jcea                        _/_/    _/_/          _/_/_/_/_/\njabber / xmpp:jcea at jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/\n\"Things are not so easy\"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/\n\"My name is Dump, Core Dump\"   _/_/_/        _/_/_/      _/_/  _/_/\n\"El amor es poner tu felicidad en la felicidad de otro\" - Leibniz\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 538 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/45f99d95/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-17T15:01:35",
                "message_text_only": "On Tue, Jun 17, 2014 at 4:27 PM, Jesus Cea <jcea at jcea.es> wrote:\n> On 17/06/14 11:46, Wladimir wrote:\n> Under Ubuntu 10.04:\n>\n> jcea at ubuntu:/tmp/bitcoin-0.9.2-linux/bin/64$ ./bitcoin-qt\n> ./bitcoin-qt: symbol lookup error: ./bitcoin-qt: undefined symbol:\n> _ZN10QTextCodec11validCodecsEv\n\nDid it work with the release candidate?\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core version 0.9.2 has been released",
            "categories": [
                "Bitcoin-development",
                "ann"
            ],
            "authors": [
                "Jesus Cea",
                "Wladimir"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8096
        }
    },
    {
        "title": "[Bitcoin-development] Proposal: relax the IsStandard rules for P2SH transactions",
        "thread_messages": [
            {
                "author": "Gavin Andresen",
                "date": "2014-06-17T19:40:36",
                "message_text_only": "Assuming there is rough consensus, I'll make this a pull request (see\nhttps://github.com/gavinandresen/bitcoin-git/tree/relax_isstandard for code\nchanges).\n\n----\n\nNow that we are finally starting to see the use of multi-signature and\nother more complicated transaction forms in applications I think it is time\nto open up the \"IsStandard\" transaction rules on the main Bitcoin network.\n\nThere are two main risks to doing this:\n\n1. The risk that one of the seldom-used opcodes has a not-yet-discovered\nchain-forking bug. I believe that risk to be very low; we have never seen\nsuch a bug on the test network (where all transaction forms are allowed)\nand have never found a bug after writing extensive unit tests.\n2. The risk of opening up a denial-of-service attack (either bloat the\nblockchain or use an excessive amount of CPU time) via a very\nexpensive-to-store-or-verify transaction. This proposal does not entirely\neliminate IsStandard checks to mitigate the potential for DoS attacks.\n\nProposal\n--------\nAllow any Script containing 15 or fewer signature operations as a\npay-to-script-hash (P2SH) Script to be relayed and mined by the reference\nimplementation.\n\nThis should be a simple change to the AreInputsStandard() method in the\nreference implementation.\n\nDiscussion\n----------\nP2SH Scripts are limited to 520 bytes, and are currently limited to one of\nthe \"standard\" transaction forms on the main network. In practice that\nmeans you can currently encode a n-of-15 OP_CHECKMULTISIG which can be\nredeemed as a 'standard' transaction.\n\nAllowing any P2SH Script would allow an attacker to craft a single standard\ntransaction output that requires on the order of 200 ECDSA signature\nchecking operations to validate-- an order of magnitude more than is\ncurrently allowed. Therefore I am proposing that we keep the current\n15-signature-checking-operations-per-transaction-output limit in place, but\nallow any combination of enabled Script opcodes. So, for example, you might\nhave a P2SH Script that is redeemed with 2-of-2 OR 2-of-3 using:\n```\nOP_IF 2 pubkey1 pubkey2 2 OP_CHECKMULTISIG OP_ELSE 2 pubkey3 pubkey4\npubkey5 3 OP_CHECKMULTISIG OP_ENDIF\n```\n(this would count as 5 signature operations)\n\nRestricting arbitrary Scripts to P2SH transaction types limits unspent\ntransaction output set bloat in two ways:\n1. The Scripts are not stored in UTXO set.\n2. They are limited to 520 bytes by the Script rule on the amount of data\nthat can be pushed onto the stack.\n\nThe reference implementation's wallet will still only recognize P2SH\ntransactions that use one of the standard transaction forms. To actually\nUSE a new transaction form will require specialized wallets or specialized\napplications.\n\n-- \n--\nGavin Andresen\nChief Scientist, Bitcoin Foundation\nhttps://www.bitcoinfoundation.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/68c2ab99/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-18T00:15:03",
                "message_text_only": "On Tue, Jun 17, 2014 at 03:40:36PM -0400, Gavin Andresen wrote:\n> Assuming there is rough consensus, I'll make this a pull request (see\n> https://github.com/gavinandresen/bitcoin-git/tree/relax_isstandard for code\n> changes).\n\nI'm also working on a very similar patch with some additional\nprotections to ensure forwards compatibility during soft-fork upgrades\nand provide protections against transaction malleability.\n\n> Now that we are finally starting to see the use of multi-signature and\n> other more complicated transaction forms in applications I think it is time\n> to open up the \"IsStandard\" transaction rules on the main Bitcoin network.\n\nAgreed.\n\n> There are two main risks to doing this:\n> \n> 1. The risk that one of the seldom-used opcodes has a not-yet-discovered\n> chain-forking bug. I believe that risk to be very low; we have never seen\n> such a bug on the test network (where all transaction forms are allowed)\n> and have never found a bug after writing extensive unit tests.\n\nAgreed.\n\nThe script execution code is probably in the 99.9th percentile of open\nsource code in terms of code review.\n\n> 2. The risk of opening up a denial-of-service attack (either bloat the\n> blockchain or use an excessive amount of CPU time) via a very\n> expensive-to-store-or-verify transaction. This proposal does not entirely\n> eliminate IsStandard checks to mitigate the potential for DoS attacks.\n\n3. The risk that non-upgraded miners produce invalid blocks after a\n   soft-fork due to them mining transactions that are now invalid.\n\n4. Transaction malleability.\n\n> Proposal\n> --------\n> Allow any Script containing 15 or fewer signature operations as a\n> pay-to-script-hash (P2SH) Script to be relayed and mined by the reference\n> implementation.\n> \n> This should be a simple change to the AreInputsStandard() method in the\n> reference implementation.\n\nIn addition to these changes the soft-fork-safe patch I'm working on\nwould do the following:\n\na) Define an opcode whitelist of soft-fork-safe opcodes.\n\nThis whitelist includes every opcode but the invalid opcodes, and most\nimportantly, the OP_NOPx opcodes that may be redefined in a future\nsoft-fork with new behavior. This rule, along with rejecting transations\nwith unknown nVersion's, ensures that a miner still running an old\nversion of Bitcoin Core will only mine transactions that the new version\nof Bitcoin Core considers valid.\n\nb) Consider scripts that leave extra items on the stack after execution\n   to be non-standard.\n\nAs per Pieter Wuille's BIP62 \"Dealing with malleability\" extra scriptSig\npushes are a malleability source. If adding extra pushes causes a\ntransaction to be invalid, scriptPubKeys will in most cases be\nautomatically non-malleable. This change I've already submitted as a\nseparate pull-req: https://github.com/bitcoin/bitcoin/pull/4311\n\n\nI'd be happy to add the above to your existing patch and submit the\npull-req for you.\n\n-- \n'peter'[:-1]@petertodd.org\n0000000000000000407e409a626b01bfb275cb88768ca74f3ea9bd87b2e7e1d9\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140617/ce84f461/attachment.sig>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-06-18T12:52:22",
                "message_text_only": "RE: most of Peter Todd's comments:\n\nAll of that should be separate pull requests.  Big Honking Pull Requests\nare harder to review and are more likely to be bike-shedded to death.\n\n\nRE: not relaying/mining transactions with OP_NOPs so miners don't mine\nup-version transactions that are invalid under future-new-rules: I'm not\nconvinced it is worth adding more code (more potential for bugs) to protect\nagainst something that isn't going to happen because up-version\ntransactions are non-standard (due to version check) in any case.\n\nIn any case, lets make that a separate pull request.\n\nI'm going to take the lack of immediate \"That's a Terrible Idea!\" as rough\nconsensus...\n\n-- \n--\nGavin Andresen\nChief Scientist, Bitcoin Foundation\nhttps://www.bitcoinfoundation.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140618/8221909b/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-19T10:09:09",
                "message_text_only": "On Wed, Jun 18, 2014 at 08:52:22AM -0400, Gavin Andresen wrote:\n> RE: most of Peter Todd's comments:\n> \n> All of that should be separate pull requests.  Big Honking Pull Requests\n> are harder to review and are more likely to be bike-shedded to death.\n\nWell, just doing one and not the rest isn't necessarily a good idea. The\nmalleability protection definitely seems like a good idea, and has had\nquite a bit of review.\n\n> RE: not relaying/mining transactions with OP_NOPs so miners don't mine\n> up-version transactions that are invalid under future-new-rules: I'm not\n> convinced it is worth adding more code (more potential for bugs) to protect\n> against something that isn't going to happen because up-version\n> transactions are non-standard (due to version check) in any case.\n\nDo we have consensus that future soft-forks to add new opcodes will\nalways be done in conjunction with a transaction nVersion bump? If so,\nthen that's ok, if not, then we should have a whitelist.\n\nThe code to restrict the opcodes to the softfork-safe subset is trivial,\na GetOp() loop and a switch statement. It can always be removed later.\n\nSomething that comes to mind is if we do always bump nVersion then\nOP_NOPx always will have a parallel \"do-nothing\" behavior, which means\nEvalScript() will always have to have code enabling that backwards\ncompatible behavior.\n\n-- \n'peter'[:-1]@petertodd.org\n000000000000000004e51d8d00eedb31ec1505d245f48960896b79f0e7193c2a\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/7b5d77e8/attachment.sig>"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-06-19T13:54:31",
                "message_text_only": "RE: soft-forks bumping version numbers:\n\nYes, we have consensus that is the way we will do it.  I should probably\nturn https://gist.github.com/gavinandresen/2355445 into an informational\nBIP.\n\nRE: malleability:\n\nOrthogonal (but related) issue to IsStandard.\n\nDetecting Scripts that leave extra items on the stack will be done in a\ndifferent part of the code than the code addressed by this pull reques. No\nneed to execute the Script twice to figure out if it leaves extra stuff,\nand the idea behind IsStandard is to get to a quick yes/no before running a\npotentially expensive Script execution.\n\n\n\n-- \n--\nGavin Andresen\nChief Scientist, Bitcoin Foundation\nhttps://www.bitcoinfoundation.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/f20c1c3e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2014-06-20T00:45:29",
                "message_text_only": "On Thu, Jun 19, 2014 at 09:54:31AM -0400, Gavin Andresen wrote:\n> RE: soft-forks bumping version numbers:\n> \n> Yes, we have consensus that is the way we will do it.  I should probably\n> turn https://gist.github.com/gavinandresen/2355445 into an informational\n> BIP.\n\nSounds like it could turn EvalScript() into a mess over time, but that's\na long way away. Anyway a BIP will be useful.\n\n> RE: malleability:\n> \n> Orthogonal (but related) issue to IsStandard.\n> \n> Detecting Scripts that leave extra items on the stack will be done in a\n> different part of the code than the code addressed by this pull reques. No\n> need to execute the Script twice to figure out if it leaves extra stuff,\n> and the idea behind IsStandard is to get to a quick yes/no before running a\n> potentially expensive Script execution.\n\nYeah, that's what I implemented in https://github.com/bitcoin/bitcoin/pull/4311\n\n-- \n'peter'[:-1]@petertodd.org\n00000000000000004f73d48c972aa30493526191aa009f95e4a71dcfbdca08b2\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 685 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/740bd5f2/attachment.sig>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-18T07:42:12",
                "message_text_only": "On Tue, Jun 17, 2014 at 9:40 PM, Gavin Andresen\n<gavin at bitcoinfoundation.org> wrote:\n> Assuming there is rough consensus, I'll make this a pull request (see\n> https://github.com/gavinandresen/bitcoin-git/tree/relax_isstandard for code\n> changes).\n>\n> ----\n>\n> Now that we are finally starting to see the use of multi-signature and other\n> more complicated transaction forms in applications I think it is time to\n> open up the \"IsStandard\" transaction rules on the main Bitcoin network.\n\nAgreed!\n\n> Discussion\n> ----------\n> Allowing any P2SH Script would allow an attacker to craft a single standard\n> transaction output that requires on the order of 200 ECDSA signature\n> checking operations to validate-- an order of magnitude more than is\n> currently allowed. Therefore I am proposing that we keep the current\n> 15-signature-checking-operations-per-transaction-output limit in place, but\n> allow any combination of enabled Script opcodes. So, for example, you might\n> have a P2SH Script that is redeemed with 2-of-2 OR 2-of-3 using:\n\nSoungs good to me - to lift the restrictions and increase flexibility,\nbut also to be a careful and keep the DoS limits.\n\n> The reference implementation's wallet will still only recognize P2SH\n> transactions that use one of the standard transaction forms. To actually USE\n> a new transaction form will require specialized wallets or specialized\n> applications.\n\nThat's of course completely separate. As we all know, most wallet\ninnovation doesn't happen in the reference implementation wallet, and\nit should not be used as the guide here.\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Proposal: relax the IsStandard rules for P2SH transactions",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Peter Todd",
                "Wladimir",
                "Gavin Andresen"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 12651
        }
    },
    {
        "title": "[Bitcoin-development] CoinJoin bounty fund question",
        "thread_messages": [
            {
                "author": "Odinn Cyberguerrilla",
                "date": "2014-06-17T21:14:41",
                "message_text_only": "Hoping that this is the right place for this, I am asking a question as to\nwhat happens with what is in the CoinJoin bounty fund address at:\n\nhttp://blockchain.info/address/3M8XGFBKwkf7miBzpkU3x2DoWwAVrD1mhk\n\n(a P2SH / multisignature address)\n\nI encouraged people to donate to it in late 2013 (around mid-November)\nafter seeing some reddit discussions ~ I think the original one I saw was\nat\nhttp://www.reddit.com/r/Bitcoin/comments/1qmhkh/coinjoin_fundraising_drive/\n\nSince that time I know it's been implemented in various places, such as\nthings seen floating about the web with some relation to CoinJoin or\nanother:\nsuch as:\nhttps://github.com/calafou/coinjoin\nand blockchain.info\nhttps://twitter.com/blockchain/status/402224010492006400/ |\nhttps://github.com/blockchain/Sharedcoin\netc..\n\nI'm curious what the CoinJoin bounty fund supports at this point and where\nit's intended to go (I assume, CoinJoin related stuff, but I'm interested\nto know a bit more detail).  And if it will help fund other things I am\ncurious about what those other things are too.\nAgain, hopefully the bitcoin-development list is the right place for this\nquestion, I felt it would be better asked here rather than on twitter or\nsimilar.\n\nRespect,\n\nOdinn"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2014-06-17T22:46:11",
                "message_text_only": "On Tue, Jun 17, 2014 at 2:14 PM, Odinn Cyberguerrilla\n<odinn.cyberguerrilla at riseup.net> wrote:\n> Hoping that this is the right place for this, I am asking a question as to\n> what happens with what is in the CoinJoin bounty fund address at:\n\nThe correct place for more information is the Bitcointalk forum thread\nwhere it was announced:\nhttps://bitcointalk.org/index.php?topic=279249.0\n\ncheers,"
            },
            {
                "author": "Kristov Atlas",
                "date": "2014-06-17T23:14:58",
                "message_text_only": "On 06/17/2014 06:46 PM, Gregory Maxwell wrote:\n> The correct place for more information is the Bitcointalk forum thread\n> where it was announced:\n> https://bitcointalk.org/index.php?topic=279249.0\nCan anyone summarize the current status of the bounty? I see nothing \ndefinite about the bounty in that thread from the beginning of January \n2014, other than that the multisig address continues to accumulate \nbitcoins. Meanwhile, on other mailing lists, I've seen some talk about \npaying a portion or the whole of the bounty to the Dark Wallet team.\n\n-Kristov"
            }
        ],
        "thread_summary": {
            "title": "CoinJoin bounty fund question",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Kristov Atlas",
                "Gregory Maxwell",
                "Odinn Cyberguerrilla"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2185
        }
    },
    {
        "title": "[Bitcoin-development] 0 confirmation txs using replace-by-fee and game theory",
        "thread_messages": [
            {
                "author": "Isidor Zeuner",
                "date": "2014-06-19T03:47:17",
                "message_text_only": "quote:\n[...]\n> On 4/24/14, Chris Pacia <ctpacia at gmail.com> wrote:\n> > It would work but it's an ugly hack IMO. What do people do if they don't\n> > have extra to pay when making a purchase? I have 200 mbtc and want to buy a\n> > 200 mbtc phone but I can't because I need 400 mbtc. Sucks for me.\n> >\n> > I would much prefer the hassle of a green address notary than always having\n> > to make sure I have double what I need to make a purchase.\n>\n> This scheme wouldn't be mandatory. You can still wait for\n> confirmations or rely somehow on existing trust instead if that's\n> better for you on that situation.\n>\n\nConsidering hotel or car rental payments where the credit card\nprocessor reserves a higher amount in order to cover risks, it\ndoesn't seem like anything new or particularly inconvenient that a\npayment system may require a larger amount than the final price being\navailable.\n\nWhich brings us to the question: Is it an important characteristic in\na payment system that it is capable of quickly spending your last\npenny?\n\nBest regards,\n\nIsidor"
            }
        ],
        "thread_summary": {
            "title": "0 confirmation txs using replace-by-fee and game theory",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Isidor Zeuner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1052
        }
    },
    {
        "title": "[Bitcoin-development] BlockPow: A Practical Proposal to prevent mining pools AND reduce payoff variance:",
        "thread_messages": [
            {
                "author": "Sergio Lerner",
                "date": "2014-06-19T16:58:38",
                "message_text_only": "I propose a setting that prevent mining pools AND reduce payoff variance\nwhich requires two changes: increasing the block-rate and changing the\nBitcoin PoW (but still allowing current Bitcoin ASICs to work (as far as\nI know)). The block rate must be increased at least 20 times and block\nmust still be near full (e.g. there must be at least 20 more\ntransactions/second than there is today)\n\nBlockPow is kind of PoW that only practically prevents mining pools for\ncertain cryptocurrency settings based on concepts similar to parmacoin,\nbut in a much simple degree. The idea is that if miners try to join a\npool, then they incur in overhead of transmitting information and earn\nless than working solo. Let b (the payload) contain a full block. b must\ncontain all the transactions and the header, and not only the\ntransaction hashes. b should not hide anything. Let h be the block\nheader (which contains the previous block hash and the Merkle tree root\nof the transactions). Let d be the difficulty. hash-block-length(b)\nreturns the number of blocks processed by the hash function when fed\nwith the block b. The target is divided by hash-block-length(b) so that\nthe difficulty does not depend on the length of the block. Some other\nfunction can be used to encourage nodes to add more or less transactions.\n\nDef: Basic BlockPoW concept\n\nFor each r in the nonce-range: if H ( H( r || b ) || h || r) ) < 2^-d/\nhash-block-length(b) then return r\n\nreturn null\n\nThe header (h) is appended to the hashed message to allow SPV clients to\nverify the PoW without requiring the full block to be downloaded. Peers\ncan send only (x,r,h) to SPV nodes, where x = H( r || b ), so they can\nverify the PoW. The verification procedure is obvious, and is skipped\nhere. r is inserted at the beginning of the message to prevent pool\nadministrators from keeping a secret mid-state of the hash function\nsecret in order to prevent block stealing and also to force the miner to\nknow b in the inner mining loop.\n\nSo now mining requires the knowledge of the block b to be mined, and b\nmust be received at each block-chain epoch. This could create an\nincentive not to include any transaction and use an almost empty b,\nbecause that way the bandwidth requirements is decreased. But this\nincentive should not exists normally, since by including transactions\nthe solo miner gets an additional revenue from fees, which is lost if\nthe block is empty. Anyway, to prevent this possible incentive we can\nappend to b a subset of previous blocks (e.g 100 blocks). The block\nsubset to include could be derived from a peudo-random function seeded\nby the previous block hash. Then a node would still need to download\npart or all the block-chain in order to mine.\n\nNow if the miner wants to be a dumb node and take part of a pool, then\nthe current working unsolved block (the template) must be sent each time\nfrom the pool admin to each miner. If the pool admin hosts 1000 miners,\nthen to serve them with fresh block templates he needs 1000 times more\nbandwidth that the miners, making this much more expensive. If miners\ncreate another network topology to distribute templates, they are\nincurring in the same overhead as being actively part of the\ncryptocurrency network, so they gain nothing.\n\nFor example, in a block-chain with a 5 seconds block-rate, such as in\nNimbleCoin <http://nimbleCoin.org>, each block can be as large as 200\nKbytes (100 tps are allowed). A miner will require the block template to\nbe ready as fast as possible, say before 3 seconds, so as not to loose\nmore than 60% of the times the transaction fees present in the block\ntemplate. This means that a pool admin serving 1000 clients must have a\nupload bandwidth of at least 60 Mbytes/sec, and load balance servers,\nbecause all miners will demand the block template at the same time and\nwill compete for it.\n\nThe same miner, working solo, will not loose the 60% of block fees. If\nblock fees are 10% of block reward, then solo miners earn 6% more than\npool miners. Also, having a block rate of 5 seconds allows solo miners\nto receive payments more often and so it reduces the payment variance.\n\nThis method to discourage mining pools only work as long as time is\ntakes to transmit a block is comparable to the block interval time, e.g.\n20%. This seems not to be a problem since if the cryptocurrency becomes\npopular, then we can expect blocks to be near full, while if is is not,\nthen nobody will care about mining pools.\n\nFor this method to work for Bitcoin, Bitcoin should reduce the block\nrate to at least 1 minute, and keep blocks of at least 10 Mbytes. Or go\nthe NimbleCoin way, and reduce the block interval to 5 seconds. The sole\nreduction of the block rate from 10 minutes to 5 seconds would reduce\nnotably the mining reward variance, which is the main reason miners\ndon't mine solo.\n\nBitcoinBlockPow\n\nThe basic BlockPoW is incompatible with Bitcoin ASICs as is but it can\nbe made partially compatible with some tweaks: The value b is replaced\nby a a a subset or an integrity check of the block.\n\nUsing a subset:\n\nFirst the hashMerkleRoot and hashPrevBlock fields are replaced by the\nfields: ChildBlock (32 bytes) and ScatteredBlockBytes (32 bytes).\nChildBlock is the hash of a message with stores the old hashMerkleRoot\nand hashPrevBlock. ScatteredBlockBytes is a pseudo-random subset of\nbytes taken from the block template being mined. The seed for the\npseudo-random function that selects the subset is  the hashMerkleRoot\nplus the block time. When a miner scans all the 32bit nonce space, then\na new hashMerkleRoot must be created to increase the extra-nonce field\nor the time must be updated. When this happens, a new subset of\npseudo-random 32 block bytes must be collected. If the miner only stores\n10% of the block template (e.g. 100 Kbytes instead of 1 Mbyte), then the\nprobability he can build the ScatteredBlockBytes by brute-forcing the\nseed is 10^-32. If the miner performs 100 GH/sec, then the 32-bit nonce\nwill overflow every 20 msec and the miner could request the\nScatteredBlockBytes from the pool admin using a bandwidth of 1 Kbyte/s.\nA pool hosting 6 PH/sec (such as Eligious, which has 8%) would need to\nstream more than 60 Mb/s of ScatteredBlockBytes fields. A mining pool\nhaving 50% would need to stream 500 Mb/s, which is quite challenging. So\nminers will download the block normally, and become active part of the\nnetwork.\n\nUsing an integrity check:\n\nScatteredBlockBytes  is replaced by a field BlockHash defined as H(\nfull-block-with-zero-nonce ). Obviously the header must be at the\nbeginning of the block to force the re-hash.\n\nBest regards,\n Sergio.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/f8b2f0d1/attachment.html>"
            },
            {
                "author": "Kevin",
                "date": "2014-06-19T17:11:44",
                "message_text_only": "On 6/19/2014 12:58 PM, Sergio Lerner wrote:\n>\n> I propose a setting that prevent mining pools AND reduce payoff \n> variance which requires two changes: increasing the block-rate and \n> changing the Bitcoin PoW (but still allowing current Bitcoin ASICs to \n> work (as far as I know)). The block rate must be increased at least 20 \n> times and block must still be near full (e.g. there must be at least \n> 20 more transactions/second than there is today)\n>\n> BlockPow is kind of PoW that only practically prevents mining pools \n> for certain cryptocurrency settings based on concepts similar to \n> parmacoin, but in a much simple degree. The idea is that if miners try \n> to join a pool, then they incur in overhead of transmitting \n> information and earn less than working solo. Let b (the payload) \n> contain a full block. b must contain all the transactions and the \n> header, and not only the transaction hashes. b should not hide \n> anything. Let h be the block header (which contains the previous block \n> hash and the Merkle tree root of the transactions). Let d be the \n> difficulty. hash-block-length(b) returns the number of blocks \n> processed by the hash function when fed with the block b. The target \n> is divided by hash-block-length(b) so that the difficulty does not \n> depend on the length of the block. Some other function can be used to \n> encourage nodes to add more or less transactions.\n>\n> Def: Basic BlockPoW concept\n>\n> For each r in the nonce-range: if H ( H( r || b ) || h || r) ) < 2^-d/ \n> hash-block-length(b) then return r\n>\n> return null\n>\n> The header (h) is appended to the hashed message to allow SPV clients \n> to verify the PoW without requiring the full block to be downloaded. \n> Peers can send only (x,r,h) to SPV nodes, where x = H( r || b ), so \n> they can verify the PoW. The verification procedure is obvious, and is \n> skipped here. r is inserted at the beginning of the message to prevent \n> pool administrators from keeping a secret mid-state of the hash \n> function secret in order to prevent block stealing and also to force \n> the miner to know b in the inner mining loop.\n>\n> So now mining requires the knowledge of the block b to be mined, and b \n> must be received at each block-chain epoch. This could create an \n> incentive not to include any transaction and use an almost empty b, \n> because that way the bandwidth requirements is decreased. But this \n> incentive should not exists normally, since by including transactions \n> the solo miner gets an additional revenue from fees, which is lost if \n> the block is empty. Anyway, to prevent this possible incentive we can \n> append to b a subset of previous blocks (e.g 100 blocks). The block \n> subset to include could be derived from a peudo-random function seeded \n> by the previous block hash. Then a node would still need to download \n> part or all the block-chain in order to mine.\n>\n> Now if the miner wants to be a dumb node and take part of a pool, then \n> the current working unsolved block (the template) must be sent each \n> time from the pool admin to each miner. If the pool admin hosts 1000 \n> miners, then to serve them with fresh block templates he needs 1000 \n> times more bandwidth that the miners, making this much more expensive. \n> If miners create another network topology to distribute templates, \n> they are incurring in the same overhead as being actively part of the \n> cryptocurrency network, so they gain nothing.\n>\n> For example, in a block-chain with a 5 seconds block-rate, such as in \n> NimbleCoin <http://nimbleCoin.org>, each block can be as large as 200 \n> Kbytes (100 tps are allowed). A miner will require the block template \n> to be ready as fast as possible, say before 3 seconds, so as not to \n> loose more than 60% of the times the transaction fees present in the \n> block template. This means that a pool admin serving 1000 clients must \n> have a upload bandwidth of at least 60 Mbytes/sec, and load balance \n> servers, because all miners will demand the block template at the same \n> time and will compete for it.\n>\n> The same miner, working solo, will not loose the 60% of block fees. If \n> block fees are 10% of block reward, then solo miners earn 6% more than \n> pool miners. Also, having a block rate of 5 seconds allows solo miners \n> to receive payments more often and so it reduces the payment variance.\n>\n> This method to discourage mining pools only work as long as time is \n> takes to transmit a block is comparable to the block interval time, \n> e.g. 20%. This seems not to be a problem since if the cryptocurrency \n> becomes popular, then we can expect blocks to be near full, while if \n> is is not, then nobody will care about mining pools.\n>\n> For this method to work for Bitcoin, Bitcoin should reduce the block \n> rate to at least 1 minute, and keep blocks of at least 10 Mbytes. Or \n> go the NimbleCoin way, and reduce the block interval to 5 seconds. The \n> sole reduction of the block rate from 10 minutes to 5 seconds would \n> reduce notably the mining reward variance, which is the main reason \n> miners don't mine solo.\n>\n> BitcoinBlockPow\n>\n> The basic BlockPoW is incompatible with Bitcoin ASICs as is but it can \n> be made partially compatible with some tweaks: The value b is replaced \n> by a a a subset or an integrity check of the block.\n>\n> Using a subset:\n>\n> First the hashMerkleRoot and hashPrevBlock fields are replaced by the \n> fields: ChildBlock (32 bytes) and ScatteredBlockBytes (32 bytes). \n> ChildBlock is the hash of a message with stores the old hashMerkleRoot \n> and hashPrevBlock. ScatteredBlockBytes is a pseudo-random subset of \n> bytes taken from the block template being mined. The seed for the \n> pseudo-random function that selects the subset is  the hashMerkleRoot \n> plus the block time. When a miner scans all the 32bit nonce space, \n> then a new hashMerkleRoot must be created to increase the extra-nonce \n> field or the time must be updated. When this happens, a new subset of \n> pseudo-random 32 block bytes must be collected. If the miner only \n> stores 10% of the block template (e.g. 100 Kbytes instead of 1 Mbyte), \n> then the probability he can build the ScatteredBlockBytes by \n> brute-forcing the seed is 10^-32. If the miner performs 100 GH/sec, \n> then the 32-bit nonce will overflow every 20 msec and the miner could \n> request the ScatteredBlockBytes from the pool admin using a bandwidth \n> of 1 Kbyte/s. A pool hosting 6 PH/sec (such as Eligious, which has 8%) \n> would need to stream more than 60 Mb/s of ScatteredBlockBytes fields. \n> A mining pool having 50% would need to stream 500 Mb/s, which is quite \n> challenging. So miners will download the block normally, and become \n> active part of the network.\n>\n> Using an integrity check:\n>\n> ScatteredBlockBytes  is replaced by a field BlockHash defined as H( \n> full-block-with-zero-nonce ). Obviously the header must be at the \n> beginning of the block to force the re-hash.\n>\n> Best regards,\n>  Sergio.\n>\n>\n>\n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n>\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\nWhy do you want to punish pools?\n\n\n-- \nKevin\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/47807d7c/attachment.html>"
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-06-19T17:37:13",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 06/19/2014 05:11 PM, Kevin wrote:\n> Why do you want to punish pools?\n\nIt's part of a general trend wherein people look at all the things\nthat can be accomplished in an economy that has a division of labor*,\nand see some misbehavior at the edges, and decide that rather than\nfixing the misbehavior we should throw out the entire concept of labor\nspecialization.\n\nHating on labor specialization as a concept, rather than simply\nfinding solutions for specialist misbehavior, was the basis for scrypt\nmining, PoS, and MaidSafe.\n\n\n(*) http://www.econlib.org/library/Essays/rdPncl1.html\n\n- -- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBAgAGBQJTox/JAAoJEMP3uyY4RQ216F0IAKo26MEK/IrIlHMw4UYsWBWK\nLWWLe4mfUb+I74ZHPzC2ZE7u6Lf6vAeeG/mLe8K/ls1qBJk9ae7bsA+DVvRn8LfW\nIr/seYtCCnLpxhHGbVtYOeWaS+WyOWMKBz1moOTJcgWwPPiL5BLk9SvaLqgy2GDV\nfJeniqtkZ96Vzif1DNdQtiLfn9aJRL2Er0EO7VL4ojmaM3Bv6Z6l+e0eLVVh8DKe\nu1Sp4UOpqJmVHJq+9EeMhdfmOqNWGUA5wFRiDsWfzUDHLkAlISM+sFFSD0CzO0RK\nP5whGxo58bSMigbQYOfoTZqgKQefQeXAqtlnrLOLq9/EOZ/34cJET5Z0S/K/F5E=\n=3KMH\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x38450DB5.asc\nType: application/pgp-keys\nSize: 12464 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/3a80b41e/attachment.bin>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-19T17:17:50",
                "message_text_only": "Sergio, why is preventing mining pools a good thing? The issue is not\nmining pools, which provide a needed service in greatly reducing\nvariance beyond what any proposal like this can do.\n\nThe issue is centralized transaction selection policies, which is\nentirely orthogonal. And the solution already exists: getblocktemplate.\nWe just need more or better infrastructure which makes use of this\ntechnology to perform local transaction selection.\n\nIf you have a proposal for eliminating hosted mining while keeping\nvariance-reducing pools, that would be an interesting read.\n\nOn 06/19/2014 09:58 AM, Sergio Lerner wrote:\n> I propose a setting that prevent mining pools AND reduce payoff variance\n> which requires two changes: increasing the block-rate and changing the\n> Bitcoin PoW (but still allowing current Bitcoin ASICs to work (as far as\n> I know)). The block rate must be increased at least 20 times and block\n> must still be near full (e.g. there must be at least 20 more\n> transactions/second than there is today)\n> \n> BlockPow is kind of PoW that only practically prevents mining pools for\n> certain cryptocurrency settings based on concepts similar to parmacoin,\n> but in a much simple degree. The idea is that if miners try to join a\n> pool, then they incur in overhead of transmitting information and earn\n> less than working solo. Let b (the payload) contain a full block. b must\n> contain all the transactions and the header, and not only the\n> transaction hashes. b should not hide anything. Let h be the block\n> header (which contains the previous block hash and the Merkle tree root\n> of the transactions). Let d be the difficulty. hash-block-length(b)\n> returns the number of blocks processed by the hash function when fed\n> with the block b. The target is divided by hash-block-length(b) so that\n> the difficulty does not depend on the length of the block. Some other\n> function can be used to encourage nodes to add more or less transactions.\n> \n> Def: Basic BlockPoW concept\n> \n> For each r in the nonce-range: if H ( H( r || b ) || h || r) ) < 2^-d/\n> hash-block-length(b) then return r\n> \n> return null\n> \n> The header (h) is appended to the hashed message to allow SPV clients to\n> verify the PoW without requiring the full block to be downloaded. Peers\n> can send only (x,r,h) to SPV nodes, where x = H( r || b ), so they can\n> verify the PoW. The verification procedure is obvious, and is skipped\n> here. r is inserted at the beginning of the message to prevent pool\n> administrators from keeping a secret mid-state of the hash function\n> secret in order to prevent block stealing and also to force the miner to\n> know b in the inner mining loop.\n> \n> So now mining requires the knowledge of the block b to be mined, and b\n> must be received at each block-chain epoch. This could create an\n> incentive not to include any transaction and use an almost empty b,\n> because that way the bandwidth requirements is decreased. But this\n> incentive should not exists normally, since by including transactions\n> the solo miner gets an additional revenue from fees, which is lost if\n> the block is empty. Anyway, to prevent this possible incentive we can\n> append to b a subset of previous blocks (e.g 100 blocks). The block\n> subset to include could be derived from a peudo-random function seeded\n> by the previous block hash. Then a node would still need to download\n> part or all the block-chain in order to mine.\n> \n> Now if the miner wants to be a dumb node and take part of a pool, then\n> the current working unsolved block (the template) must be sent each time\n> from the pool admin to each miner. If the pool admin hosts 1000 miners,\n> then to serve them with fresh block templates he needs 1000 times more\n> bandwidth that the miners, making this much more expensive. If miners\n> create another network topology to distribute templates, they are\n> incurring in the same overhead as being actively part of the\n> cryptocurrency network, so they gain nothing.\n> \n> For example, in a block-chain with a 5 seconds block-rate, such as in\n> NimbleCoin <http://nimbleCoin.org>, each block can be as large as 200\n> Kbytes (100 tps are allowed). A miner will require the block template to\n> be ready as fast as possible, say before 3 seconds, so as not to loose\n> more than 60% of the times the transaction fees present in the block\n> template. This means that a pool admin serving 1000 clients must have a\n> upload bandwidth of at least 60 Mbytes/sec, and load balance servers,\n> because all miners will demand the block template at the same time and\n> will compete for it.\n> \n> The same miner, working solo, will not loose the 60% of block fees. If\n> block fees are 10% of block reward, then solo miners earn 6% more than\n> pool miners. Also, having a block rate of 5 seconds allows solo miners\n> to receive payments more often and so it reduces the payment variance.\n> \n> This method to discourage mining pools only work as long as time is\n> takes to transmit a block is comparable to the block interval time, e.g.\n> 20%. This seems not to be a problem since if the cryptocurrency becomes\n> popular, then we can expect blocks to be near full, while if is is not,\n> then nobody will care about mining pools.\n> \n> For this method to work for Bitcoin, Bitcoin should reduce the block\n> rate to at least 1 minute, and keep blocks of at least 10 Mbytes. Or go\n> the NimbleCoin way, and reduce the block interval to 5 seconds. The sole\n> reduction of the block rate from 10 minutes to 5 seconds would reduce\n> notably the mining reward variance, which is the main reason miners\n> don't mine solo.\n> \n> BitcoinBlockPow\n> \n> The basic BlockPoW is incompatible with Bitcoin ASICs as is but it can\n> be made partially compatible with some tweaks: The value b is replaced\n> by a a a subset or an integrity check of the block.\n> \n> Using a subset:\n> \n> First the hashMerkleRoot and hashPrevBlock fields are replaced by the\n> fields: ChildBlock (32 bytes) and ScatteredBlockBytes (32 bytes).\n> ChildBlock is the hash of a message with stores the old hashMerkleRoot\n> and hashPrevBlock. ScatteredBlockBytes is a pseudo-random subset of\n> bytes taken from the block template being mined. The seed for the\n> pseudo-random function that selects the subset is  the hashMerkleRoot\n> plus the block time. When a miner scans all the 32bit nonce space, then\n> a new hashMerkleRoot must be created to increase the extra-nonce field\n> or the time must be updated. When this happens, a new subset of\n> pseudo-random 32 block bytes must be collected. If the miner only stores\n> 10% of the block template (e.g. 100 Kbytes instead of 1 Mbyte), then the\n> probability he can build the ScatteredBlockBytes by brute-forcing the\n> seed is 10^-32. If the miner performs 100 GH/sec, then the 32-bit nonce\n> will overflow every 20 msec and the miner could request the\n> ScatteredBlockBytes from the pool admin using a bandwidth of 1 Kbyte/s.\n> A pool hosting 6 PH/sec (such as Eligious, which has 8%) would need to\n> stream more than 60 Mb/s of ScatteredBlockBytes fields. A mining pool\n> having 50% would need to stream 500 Mb/s, which is quite challenging. So\n> miners will download the block normally, and become active part of the\n> network.\n> \n> Using an integrity check:\n> \n> ScatteredBlockBytes  is replaced by a field BlockHash defined as H(\n> full-block-with-zero-nonce ). Obviously the header must be at the\n> beginning of the block to force the re-hash.\n> \n> Best regards,\n>  Sergio.\n> \n> \n> \n> ------------------------------------------------------------------------------\n> HPCC Systems Open Source Big Data Platform from LexisNexis Risk Solutions\n> Find What Matters Most in Your Big Data with HPCC Systems\n> Open Source. Fast. Scalable. Simple. Ideal for Dirty Data.\n> Leverages Graph Analysis for Fast Processing & Easy Data Exploration\n> http://p.sf.net/sfu/hpccsystems\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-19T17:35:15",
                "message_text_only": ">\n> The issue is centralized transaction selection policies, which is\n> entirely orthogonal. And the solution already exists: getblocktemplate.\n\n\nMy (fresh!) understanding is that the reason we don't see people using\ngetblocktemplate to decentralise pools is because libblkmaker and other\nimplementations don't actually support connecting your own node to the\nminers and choosing your own blocks, even though the protocol does.\n\nI've written up a blog post that I hope will go out on the Foundation blog\nsoon with some low hanging fruity ideas for miner decentralisation.\n\nSergio, I'd love to give you intelligent feedback but unfortunately reading\nit made my brain explode :) Sorry!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/c6dcb3bb/attachment.html>"
            },
            {
                "author": "slush",
                "date": "2014-06-19T20:26:41",
                "message_text_only": "On Thu, Jun 19, 2014 at 7:35 PM, Mike Hearn <mike at plan99.net> wrote:\n>\n> My (fresh!) understanding is that the reason we don't see people using\n> getblocktemplate to decentralise pools is because libblkmaker and other\n> implementations don't actually support connecting your own node to the\n> miners and choosing your own blocks, even though the protocol does.\n>\n>\nWell, I don't want to start flamewar (and this topic has potential!), but\nthe *real* reason why there isn't such infrastructure is that although GBT\nas a protocol *does* support of decentralized building of blocks, it is\n*extremely* resource consuming to validate these shares on pool side.\n\nWith GBT, simply hashing the block header is not enough, because pool\ncannot rely on anything provided by the client. Its not only about things\nlike withdrawal attacks, but more about hidden bugs in various miners. It\nis extremely hard to do full validation for *every* of submitted shares.\n\nAlthough I see benefits of GBT and I see limits of Stratum, I don't think\nthat supporting full GBT validation have economic sense for any medium\nsized pool, because such pool would need multiply his running costs on\nservers many times.\n\n> It's part of a general trend wherein people look at all the things\nthat can be accomplished in an economy that has a division of labor*,\nand see some misbehavior at the edges, and decide that rather than\nfixing the misbehavior we should throw out the entire concept of labor\nspecialization.\n\nWell written! This reminds me - what about Stratum + SPV validation on\nminer side?\n\nWith SPV, miner cannot choose his own transactions, so it is not fully\ndecentralized, but at least miner can detect (in real time) two major pool\nmisbehaviours - selfish mining (building private blockchain) and chain\nforking (not working on longest known blockchain).\n\nI read such proposal about Stratum + SPV on reddit and I actually like it;\nIt removes major drawbacks of \"centralized\" Stratum mining, yet is gives\ntools to miners to instantly switch to fallback pool when something wrong\nis happening.\n\nslush\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/85314caf/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-19T20:39:13",
                "message_text_only": "Do you need to do full validation? There's an economic cost to mining\ninvalid blocks, and even if that were acceptable there's really no\nreason to perform such an attack. The result would be similar to a block\nwithholding attack, but unlike block withholding it would be trivially\ndetectable if/when full validation was performed.\n\nTo protect yourself and to detect incorrect mining software you could\nstochastically validate a randomly selected sample of shares, as your\nhardware requirements allow.\n\nOn 06/19/2014 01:26 PM, slush wrote:\n> With GBT, simply hashing the block header is not enough, because pool\n> cannot rely on anything provided by the client. Its not only about\n> things like withdrawal attacks, but more about hidden bugs in various\n> miners. It is extremely hard to do full validation for *every* of\n> submitted shares."
            },
            {
                "author": "slush",
                "date": "2014-06-19T20:55:48",
                "message_text_only": "Miner issues are just one thing what came to my mind. What about validating\ntransactions? How the pool can be sure that miner is running up to date\nbitcoind which do full validation of transactions? Not talking that if\nevery miner takes his own set of transaction, pool need to calculate merkle\nroot for every submit, to check its correctness.\n\nI don't think it *cannot* be done, it is just extremely hard and there's no\neconomic motivation for such complication on pool side. Just see current\npools, they are full of security and stability bugs even while using such\ntrivial protocol like Stratum...\n\nslush\n\nOn Thu, Jun 19, 2014 at 10:39 PM, Mark Friedenbach <mark at monetize.io> wrote:\n\n> Do you need to do full validation? There's an economic cost to mining\n> invalid blocks, and even if that were acceptable there's really no\n> reason to perform such an attack. The result would be similar to a block\n> withholding attack, but unlike block withholding it would be trivially\n> detectable if/when full validation was performed.\n>\n> To protect yourself and to detect incorrect mining software you could\n> stochastically validate a randomly selected sample of shares, as your\n> hardware requirements allow.\n>\n> On 06/19/2014 01:26 PM, slush wrote:\n> > With GBT, simply hashing the block header is not enough, because pool\n> > cannot rely on anything provided by the client. Its not only about\n> > things like withdrawal attacks, but more about hidden bugs in various\n> > miners. It is extremely hard to do full validation for *every* of\n> > submitted shares.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140619/75de20af/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2014-06-19T21:07:17",
                "message_text_only": "It's not the pool operator's business what software the miner is running\nto select transactions for his block, so long as the miner follows the\ntemplate and doesn't generate invalid blocks. We already discussed\ninvalid blocks, and checking the template requires parsing the coinbase\ntransaction and verifying the merkleroot. The most expensive operations\nare the hashes in the merkleroot verification, but you have to do that\nin stratum too because of the extranonce, right?\n\nOn 06/19/2014 01:55 PM, slush wrote:\n> Miner issues are just one thing what came to my mind. What about\n> validating transactions? How the pool can be sure that miner is running\n> up to date bitcoind which do full validation of transactions? Not\n> talking that if every miner takes his own set of transaction, pool need\n> to calculate merkle root for every submit, to check its correctness."
            }
        ],
        "thread_summary": {
            "title": "BlockPow: A Practical Proposal to prevent mining pools AND reduce payoff variance:",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "slush",
                "Mike Hearn",
                "Sergio Lerner",
                "Kevin",
                "Mark Friedenbach",
                "Justus Ranvier"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 30767
        }
    },
    {
        "title": "[Bitcoin-development] Plans to separate wallet from core",
        "thread_messages": [
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-23T09:50:00",
                "message_text_only": "I know there are plans to separate the wallet from the core code and I\nthink it's a great idea that will result in cleaner and more modular\nsoftware.\nBut it seems like my assumptions on how this would be done may be incorrect.\n\nI was assuming that the wallet would consume data from a trusted\nbitcoind core node using rpc or a better interface like an http rest\napi (see PR #2844).\nSo the core would take care of the hard consensus stuff, and the\nwallet would maintain its own database with private keys, addresses,\nbalances, etc. and would consume some data contained in bitcoind's\ndatabase.\nI also assumed that the interface between wallet and core would\ninclude queries to the UTXO (see PR #4351) and maybe TXO (see PR\n#3652) for getting the historic balances.\n\nAs said, I'm not sure these assumptions are true anymore so I ask.\nIs this the plan?\nIs the plan that the wallet will use the p2p directly and maintain its\nown chain database?\n\nWell, it's something that generally interests me so if anyone can\ndetail the steps for separating the wallet a little bit, maybe I can\nhelp with some of the steps.\n\nMaybe there's no roadway yet. In that case I would like to advance\nthat discussion in this thread.\n\n-- \nJorge Tim\u00f3n"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-23T10:32:50",
                "message_text_only": "On Mon, Jun 23, 2014 at 11:50 AM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n> I know there are plans to separate the wallet from the core code and I\n> think it's a great idea that will result in cleaner and more modular\n> software.\n> But it seems like my assumptions on how this would be done may be incorrect.\n>\n> I was assuming that the wallet would consume data from a trusted\n> bitcoind core node using rpc or a better interface like an http rest\n> api (see PR #2844).\n\nIt's least surprising if the wallet works as a SPV client by default.\nThen, users can use it without first setting up a core. Thus the idea\nwould be to use P2P primarily.\n\nThere could be a mode to use a trusted core by RPC for\nmempool/conflicted transaction validation and such. But I'm not sure\nabout this - as we've seen, pure-SPV wallets work pretty well. If you\nwant it to act as an edge router you can point a SPV wallet at your\ntrusted core as well.\n\nThere are no plans for adding Electrum-like functionality to bitcoind.\nThere is already Electrum. Let's not reinvent any wheels.\n\n> So the core would take care of the hard consensus stuff, and the\n> wallet would maintain its own database with private keys, addresses,\n> balances, etc. and would consume some data contained in bitcoind's\n> database.\n\nRight, the wallet would keep track of those.\n\n> I also assumed that the interface between wallet and core would\n> include queries to the UTXO (see PR #4351) and maybe TXO (see PR\n> #3652) for getting the historic balances.\n>\n> As said, I'm not sure these assumptions are true anymore so I ask.\n> Is this the plan?\n> Is the plan that the wallet will use the p2p directly and maintain its\n> own chain database?\n\nIt does not need to keep a full chain database. But it needs its own\nrecord of the chain, headers-only + what concerns the keys in the\nwallet.\n\nWladimir"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-23T20:15:19",
                "message_text_only": "On 6/23/14, Wladimir <laanwj at gmail.com> wrote:\n> It's least surprising if the wallet works as a SPV client by default.\n> Then, users can use it without first setting up a core. Thus the idea\n> would be to use P2P primarily.\n\nSo first bitcoind will support SPV mode then we separate the wallet?\nAre the core and the wallet share any code (say, the p2p messages via\na sub-repo or something)?\n\n> There could be a mode to use a trusted core by RPC for\n> mempool/conflicted transaction validation and such. But I'm not sure\n> about this - as we've seen, pure-SPV wallets work pretty well. If you\n> want it to act as an edge router you can point a SPV wallet at your\n> trusted core as well.\n\nI thought we would first separate wallet from core (maintaining the\nfull-node wallet status) and then implement an optional SPV mode for\nthe core (and transitively for \"qt-wallet\", which would support both\nfull and SPV mode).\n\n> There are no plans for adding Electrum-like functionality to bitcoind.\n> There is already Electrum. Let's not reinvent any wheels.\n\nI'm sorry, but I still don't know what Electrum has to do with all this.\nBitcoin companies often like to interface with the network via\nbitcoind nodes, what's wrong with their custom wallets consuming some\noptional indexes from a bitcoind node their run themselves?\nI'm not proposing a \"bitcoind-client\" similar to a electrum-client. I\nthought it was assumed you where still going to run both the core and\nthe wallet and we just wanted to separate the code for better\nmodularity. Seriously, Mike also said something about Electrum too and\nI'm really lost about what you people mean here.\n\n> It does not need to keep a full chain database. But it needs its own\n> record of the chain, headers-only + what concerns the keys in the\n> wallet.\n\nWhy cannot consume that data from a bitcoind node that always run alongside it?\n\nI still don't get the plan but it feels like it won't look as DRY as I\nwas expecting..."
            },
            {
                "author": "Wladimir",
                "date": "2014-06-24T09:07:16",
                "message_text_only": "On Mon, Jun 23, 2014 at 10:15 PM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n> On 6/23/14, Wladimir <laanwj at gmail.com> wrote:\n>> It's least surprising if the wallet works as a SPV client by default.\n>> Then, users can use it without first setting up a core. Thus the idea\n>> would be to use P2P primarily.\n>\n> So first bitcoind will support SPV mode then we separate the wallet?\n> Are the core and the wallet share any code (say, the p2p messages via\n> a sub-repo or something)?\n\nYes, they will share code. At least the basic data structures and\nserialization and deserialization. Probably also part of the network\ncode and utilities like argument parsing (although that's not a hard\nrequirement - it may be an opportunity to do things better).\n\nSo part of Bitcoin Core will have to be turned into a library or\nlibraries. Movement toward this is already in progress for a while.\n\n>> There could be a mode to use a trusted core by RPC for\n>> mempool/conflicted transaction validation and such. But I'm not sure\n>> about this - as we've seen, pure-SPV wallets work pretty well. If you\n>> want it to act as an edge router you can point a SPV wallet at your\n>> trusted core as well.\n>\n> I thought we would first separate wallet from core (maintaining the\n> full-node wallet status) and then implement an optional SPV mode for\n> the core (and transitively for \"qt-wallet\", which would support both\n> full and SPV mode).\n\nWe want to move away from \"full node wallets\". In the beginning it\nmade some sense to jump-start the network, but the more the chain\ngrows the less unwieldy they become.\n\nMy main argument for the split is that full nodes and wallets have\ncompletely different usage scenarios:\n\n- A wallet should be online as little as possible, ideally only when\nyou do transactions or want to check for them.\n\n- A full node should be online 24/7 or it is virtually useless to the network.\n\n>> There are no plans for adding Electrum-like functionality to bitcoind.\n>> There is already Electrum. Let's not reinvent any wheels.\n>\n> I'm sorry, but I still don't know what Electrum has to do with all this.\n\nI suggest you look at the interface for Electrum. It probably does\nexactly what you expected the interface between the Bitcoin Core\nwallet and Bitcoin Core to become. Electrum server keeps some extra\nindices that can be queried by the wallets. It already exists!\n\nBut IMO this is a passed stage. SPV wallets w/ Bloom filtering can\nwork without any special servers, so why require a 'close binding' to\na trusted bitcoin core?\n\n(As said - I'm fine with optional close binding to a core using RPC\nwith slight security benefits like utxo queries and conflicted\ntransaction checking, and to get the dynamic fee data, but it should\nnot be required)\n\n>> It does not need to keep a full chain database. But it needs its own\n>> record of the chain, headers-only + what concerns the keys in the\n>> wallet.\n>\n> Why cannot consume that data from a bitcoind node that always run alongside it?\n\nTo not require having a bitcoind node always running alongside it.\n\nWladimir"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-24T09:44:01",
                "message_text_only": "> But IMO this is a passed stage. SPV wallets w/ Bloom filtering can\n> work without any special servers, so why require a 'close binding' to\n> a trusted bitcoin core?\n\nTo clarify (and not piss off ThomasV :-): I do not think the idea of\nhaving servers with a reputation of their own is a passed stage. There\nare many things that cannot be done at SPV level security with just\nthe P2P protocol yet. So having fewer but more trusted Electrum\nservers is a reasonable compromise.\n\nBut for basic wallet functionality it isn't necessary.\n\nWladimir"
            },
            {
                "author": "Thomas Voegtlin",
                "date": "2014-06-24T13:24:42",
                "message_text_only": "Le 24/06/2014 11:44, Wladimir a \u00e9crit :\n>> But IMO this is a passed stage. SPV wallets w/ Bloom filtering can\n>> work without any special servers, so why require a 'close binding' to\n>> a trusted bitcoin core?\n> \n> To clarify (and not piss off ThomasV :-): I do not think the idea of\n> having servers with a reputation of their own is a passed stage. There\n> are many things that cannot be done at SPV level security with just\n> the P2P protocol yet. So having fewer but more trusted Electrum\n> servers is a reasonable compromise.\n> \n\n\nThanks for that :)\n\nNote that my goal is to make the Electrum servers as trustless as\npossible, and not to rely on some sort of 'reputation'.\n\nThomas"
            },
            {
                "author": "Justus Ranvier",
                "date": "2014-06-24T15:33:41",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA1\n\nOn 06/24/2014 09:07 AM, Wladimir wrote:\n> My main argument for the split is that full nodes and wallets have \n> completely different usage scenarios:\n> \n> - A wallet should be online as little as possible, ideally only\n> when you do transactions or want to check for them.\n> \n> - A full node should be online 24/7 or it is virtually useless to\n> the network.\n\nI think btcd has done this right.\n\nA wallet is a daemon that runs constantly in the background, just like\nthe full node.\n\nThe GUI (which is distinct from the wallet) runs as little as\npossible. Presumably there's no need for a 1:1 relationship between\nwallets and GUIs.\n\n\n- -- \nSupport online privacy by using email encryption whenever possible.\nLearn how here: http://www.youtube.com/watch?v=bakOKJFtB-k\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBAgAGBQJTqZpVAAoJEMP3uyY4RQ21E48H/0XNYBzR8QZjfku/MeL5IbwL\nA56jrlWe2EZTabwfKdGx12L5oeBXe3DOeLsTizqIu0vijcl7qQryU49AjrVe91Rx\nOdEi4lmaiXdkM3lWeWUxLoLLHR1B+1f8T18Mrnzo+yasyrywPb+6H79VN5KERdA2\n5yHYCZyHXdNoXpzyf38GC2PdYJmAZdrRfAGyC5+OXSwE3XLhpRBrSBh/mrx0ct5M\nghkCKtsmJCJJ6sR2TbFxaj71kPp0J0tp8JVvjVEqC2uB4Ih0NY+79kz8L81TaNmw\nol1o6p7TypIk7QRQ4ES3Fq0ALh2aQ/tX4rc0GC0ed+xLi+dHJ2wGBI37HoyGIyg=\n=Nn9X\n-----END PGP SIGNATURE-----\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: 0x38450DB5.asc\nType: application/pgp-keys\nSize: 12464 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/67dda293/attachment.bin>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-24T16:40:16",
                "message_text_only": "On 6/24/14, Justus Ranvier <justusranvier at gmail.com> wrote:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA1\n>\n> On 06/24/2014 09:07 AM, Wladimir wrote:\n>> My main argument for the split is that full nodes and wallets have\n>> completely different usage scenarios:\n>>\n>> - A wallet should be online as little as possible, ideally only\n>> when you do transactions or want to check for them.\n>>\n>> - A full node should be online 24/7 or it is virtually useless to\n>> the network.\n>\n> I think btcd has done this right.\n>\n> A wallet is a daemon that runs constantly in the background, just like\n> the full node.\n>\n> The GUI (which is distinct from the wallet) runs as little as\n> possible. Presumably there's no need for a 1:1 relationship between\n> wallets and GUIs.\n\nI think he means that the wallet shouldn't be running as much as it is\ncurrently doing.\nBut yes, I think you're right about wallets and GUIs not necessarily\nmapping 1:1."
            },
            {
                "author": "Wladimir",
                "date": "2014-06-25T05:43:23",
                "message_text_only": "On Tue, Jun 24, 2014 at 6:40 PM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n>\n> I think he means that the wallet shouldn't be running as much as it is\n> currently doing.\n> But yes, I think you're right about wallets and GUIs not necessarily\n> mapping 1:1.\n\nI haven't been talking about the GUI at all in this entire\nconversation. When I say wallet, I mean the wallet code. There are\nvery few reasons for running a wallet 24/7. One could be if you're\nrunning an exchange that has to send and receive transactions all the\ntime.\n\nBut that's an exception - in the usual merchant/end-user case you're\nmostly receiving transactions and sometimes manually or batched-\nsending them. No need to leave the wallet running, exposed to the\nnetwork outside those times.\n\nHow the wallet GUI (if any) relates to the wallet code is a completely\ndifferent topic, and a much less pressing matter. Anything from 'GUI\nuses wallet as a library' (multibit, electrum, bitcoin core) to\nelaborate client-server protocols (btcd, coinvault?) are acceptable\ndepending on the use case.\n\nWladimir"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T09:11:03",
                "message_text_only": ">\n> So first bitcoind will support SPV mode then we separate the wallet?\n> Are the core and the wallet share any code (say, the p2p messages via\n> a sub-repo or something)?\n>\n\nbitcoind already supports SPV mode, that's how bitcoinj clients work.\nHowever the current wallet code doesn't use it, it integrates directly with\nthe full mode main loop and doesn't talk P2P internally. Which is the fine\nand obvious way to implement the wallet feature. I'm not totally convinced\nit should become an SPV wallet given the complexity of doing that. But if\nyou did want to separate the wallet code from the full node then that'd be\nthe way to do it.\n\nThe question is; what does this buy us, and is it worth the potentially\nhuge amount of time it could take? My gut feeling is we have bigger fish to\nfry. There's plenty of work to do just on the core consensus code, making\nBitcoin Core into a competitive wallet as well would be an additional\nburden.\n\nHowever I may be quite biased, as I am the maintainer of what is primarily\na wallet library :)\n\n\n> I'm sorry, but I still don't know what Electrum has to do with all this.\n>\n\nPeople use Electrum as shorthand to mean \"something a bit like the P2P\nnetwork, but with trusted remote servers which build additional databases\nand thus support additional commands\".\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/13998f76/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-24T09:40:41",
                "message_text_only": "> The question is; what does this buy us, and is it worth the potentially huge\n> amount of time it could take? My gut feeling is we have bigger fish to fry.\n> There's plenty of work to do just on the core consensus code, making Bitcoin\n> Core into a competitive wallet as well would be an additional burden.\n\nI don't intend to work on that myself but that's up to the people that\nwant to contribute to that. Once it's a separate project it could\neither be a big success, or it could slowly wither away. It can have a\nrelease cycle separate from the node. Likely faster.\n\nThe organizational reason to split off the wallet is to get rid of\nthat responsibility (and code) from the bitcoind repo. Maintaining a\nwallet should not be part of maintaining the core infrastructure. But\njust deleting it would be unreasonable.\n\n> However I may be quite biased, as I am the maintainer of what is primarily a wallet library :)\n\nHah. I've thought about that migration path as well.\n\n>From my experience the main thing people are missing with BitcoinJ is\na quick and easy way to set up a wallet as a daemon, to use the\nfunctionality from non-java through RPC.\n\nBut there are other interesting upcoming wallet projects as well, for\nexample CoinVault.\n\nWladimir"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T10:12:27",
                "message_text_only": ">\n> From my experience the main thing people are missing with BitcoinJ is\n> a quick and easy way to set up a wallet as a daemon, to use the\n> functionality from non-java through RPC.\n\n\nYes. I'd love to have a mostly Core compatible JSON-RPC frontend. Most of\nmy current users are happy using it as a library though. A lot of popular\nlanguages can run directly on the JVM these days. The big ones we miss are\nC++ and PHP, I think. But you can use JavaScript, Python 2.7, Lisp, Ruby,\nalong with other less well known ones.\n\nThe other good reason to have JSON-RPC support would be to reuse the Core\nregression tests.\n\nAnyway, this is off topic :)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/a7da15fc/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-24T11:29:28",
                "message_text_only": "On 6/24/14, Mike Hearn <mike at plan99.net> wrote:\n> bitcoind already supports SPV mode, that's how bitcoinj clients work.\n> However the current wallet code doesn't use it, it integrates directly with\n> the full mode main loop and doesn't talk P2P internally. Which is the fine\n> and obvious way to implement the wallet feature. I'm not totally convinced\n> it should become an SPV wallet given the complexity of doing that. But if\n> you did want to separate the wallet code from the full node then that'd be\n> the way to do it.\n>\n> The question is; what does this buy us, and is it worth the potentially\n> huge amount of time it could take? My gut feeling is we have bigger fish to\n> fry. There's plenty of work to do just on the core consensus code, making\n> Bitcoin Core into a competitive wallet as well would be an additional\n> burden.\n\nExactly, this is part of my point, the qt-wallet does not support SPV\noperation at this point, and that complex work should be done after\nthe wallet is separated. Thus the first version of the separated\nwallet should be functionally equivalent to today's wallet, that is, a\nfull node wallet (even though I understand Wladimir's arguments\nagainst full-node wallets).\n\n>> I'm sorry, but I still don't know what Electrum has to do with all this.\n>>\n>\n> People use Electrum as shorthand to mean \"something a bit like the P2P\n> network, but with trusted remote servers which build additional databases\n> and thus support additional commands\".\n\nOk, thanks. So a bitcoin core node which maintains and serves\nadditional indexes (say, an utxo index via rpc or something else) is\nreferred to as \"an electrum\" even though it doesn't use\nelectrum-server. Strange, but now I get it.\n\nSo in summary:\n\n1) I accept the library approach over the \"core-wallet protocol\".\n\n2) That doesn't necessarily mean that optionally maintaining\nadditional indexes in the core is not interesting for some use cases\n(interesting for bitcoind, I don't care much if electrum-server\ncurrently does this and more [with more dependencies]). Although\nPieter thinks that should also be separated into an \"index node\" too,\nbut I think that's another discussion.\n\n3) The wallet doesn't currently operate as SPV and that work should be\ndone (if there's enough interest) only after the wallet is separated\nfrom the core."
            },
            {
                "author": "Tamas Blummer",
                "date": "2014-06-24T11:48:05",
                "message_text_only": "I think there are three typical uses:\n\n1. Building consensus on the block chain. This is what the core is for.\n2. Single user wallets. This is where SPV alone is good.\n3. Services e.g. exchange, payment processor .... This is where core + indexing server talking SPV to core is the right choice\n\nRegards,\n\nTam\u00e1s Blummer\nFounder, CEO\n\nhttp://bitsofproof.com\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/f0dec0c3/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: email.png\nType: image/png\nSize: 7120 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/f0dec0c3/attachment.png>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 495 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/f0dec0c3/attachment.sig>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-24T13:26:19",
                "message_text_only": "On 6/24/14, Tamas Blummer <tamas at bitsofproof.com> wrote:\n> 3. Services e.g. exchange, payment processor .... This is where core +\n> indexing server talking SPV to core is the right choice\n\nI think this is my main question, what's the advantage of having the\nprocesses talking via the p2p protocol instead of something more\ndirect when you control both processes?\n\nWladimir, of course headers-first is generally good, and of course\nnobody will be force to separate the code in a way he doesn't like, I\nwas just testing the waters to see what people had in mind, since I\nrealized the ideas could be more different than I had assumed.\nI don't have any issues with electrum, I'm just not convinced by the\narguments that say that the indexes must be necessarily out of the\ncore, specially when some of them could be committed in the future.\nSo I'm all in favor of modularity and competing codebases, I'm just\nnot convinced that the \"core full-node\" must be necessarily restricted\nto validation only (for example, I think it should maintain a minimal\nand non-optimized mining functionality,even if it's only used for\ntesting purposes).\n\nSo far it is great that everybody seems to agree that the wallet code\nneeds to be separated.\n\nThanks everyone for sharing your views on the subject."
            },
            {
                "author": "Pieter Wuille",
                "date": "2014-06-24T13:37:59",
                "message_text_only": "I'd like to point out that there is quite a difference between \"what\ncore nodes should be like\" and \"what the codebase core nodes are built\nfrom must support\".\n\nGiven sufficiently modularized code (which I think everyone seems to\nbe in favor of, regardless of the goals), you can likely build a\nbinary that does full verification and maintains some indexes of some\nsort.\n\nI still believe that what we push for to run as the core nodes of the\nnetwork should aim for purely verification and relay, and nothing\nelse, but people can and will do things differently if the source code\nallows it. And that's fine.\n\nOn Tue, Jun 24, 2014 at 3:26 PM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n> I think this is my main question, what's the advantage of having the\n> processes talking via the p2p protocol instead of something more\n> direct when you control both processes?\n\nIMHO, maintaining a correct view of the current state of the chain\n(excluding blocks, just headers) is already sufficiently hard (I hope\nthat everyone who ever implemented an SPV wallet can agree). You\nsimplify things a bit by not needing to verify what the peer claims if\nyou trust them, but not much. You still need to support\nreorganizations, counting confirmations, making sure you stay\nup-to-date. These are functions the (SPV) P2P protocol has already\nshown to do well, and there are several codebases out there that\nimplement it. No need to reinvent the wheel with a marginally more\nefficient protocol, if it means starting over everything else.\n\n-- \nPieter"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-24T11:58:58",
                "message_text_only": "On Tue, Jun 24, 2014 at 1:29 PM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n> On 6/24/14, Mike Hearn <mike at plan99.net> wrote:\nou did want to separate the wallet code from the full node then that'd be\n>> the way to do it.\n>\n> Exactly, this is part of my point, the qt-wallet does not support SPV\n> operation at this point, and that complex work should be done after\n> the wallet is separated. Thus the first version of the separated\n> wallet should be functionally equivalent to today's wallet, that is, a\n> full node wallet (even though I understand Wladimir's arguments\n> against full-node wallets).\n\nDo mind that some of the steps on the path of bitcoind towards SPV are\nalso useful in general. For example, headers-first allows parallel\nblock download, which would solve a lot of sync issues people are\nhaving - a much higher priority than the wallet.\n\nBut anyhow I'm describing how I would do it. If you're going to do it,\nyou can do it in any order that you want. As we're talking about a\nseparate project here it's not even clear who will be maintainer.\n\n> 2) That doesn't necessarily mean that optionally maintaining\n> additional indexes in the core is not interesting for some use cases\n> (interesting for bitcoind, I don't care much if electrum-server\n> currently does this and more [with more dependencies]). Although\n> Pieter thinks that should also be separated into an \"index node\" too,\n> but I think that's another discussion.\n\nI don't understand your argument against Electrum here. Dependencies?\nCome on, that's a matter of software distribution. If that really\nbothers you I suppose you could contribute to Electrum server so that\nit has less deps. It doesn't make the protocol worth any less.\n\nAlthough Pieter and I disagree with regard to issue #4351, we agree on\nwanting to keep (or at least making) bitcoind as lean as possible.\nMaintaining extra indices for others doesn't fit in there - that's\nalso why the address index patch was not merged. An 'index node' could\nbe a different animal.\n\nWladimir"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T12:16:00",
                "message_text_only": ">\n> Although Pieter and I disagree with regard to issue #4351, we agree on\n> wanting to keep (or at least making) bitcoind as lean as possible.\n> Maintaining extra indices for others doesn't fit in there - that's\n> also why the address index patch was not merged. An 'index node' could\n> be a different animal.\n\n\nWe definitely want to head in the direction of allowing a p2p node to be as\nuseful as possible within its resource constraints and optional advertising\nof new (expensive) indexes is the way to go.\n\nSometimes I wonder if we should have an RPC or new socket based method\nwhere additional programs could run along side Bitcoin Core and opt to\nhandle a subset of p2p commands. But then I think, that seems like a lot of\ncomplexity for people who just want to help out the system, which I guess\nis the bulk of our network now. Keeping their lives simple should have a\nhigh priority. So a single unified program that just figures it out\nautomatically rather than expecting users to assemble a bag of parts seems\na goal worth striving for.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/76627853/attachment.html>"
            },
            {
                "author": "Wladimir",
                "date": "2014-06-24T12:41:40",
                "message_text_only": "On Tue, Jun 24, 2014 at 2:16 PM, Mike Hearn <mike at plan99.net> wrote:\n> priority. So a single unified program that just figures it out automatically\n> rather than expecting users to assemble a bag of parts seems a goal worth\n> striving for.\n\nAs I've said before -- and I think we disagree here - I like moving\ntowards a bag of parts of specialized tools, maintained by people that\nspecialize in those tools, instead of a single project that aims to do\nand know everything. This encourages experimentation  and makes\ncompetition possible and I think that is healthy in this space.\n\nBitcoin has a strict need for consensus in the block chain format,\nscripting system and validation. Outside of those, innovation should\nbe possible without any gatekeeper bottleneck or even widespread\nagreement. Wallets, what data to store on disk, what indices to\nmaintain. But even P2P message extensions, as long as it doesn't\ninterfere with the rest of the network.\n\nAfter an experiment is successful it could always be merged into\nbitcoin core. But then the 'what-ifers' have less ammo, as it has been\ntested in the real world.\n\nFor user convenience it's still possible to package pre-assembled\nbags. But that doesn't need to figure into how things are developed.\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "Plans to separate wallet from core",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Tamas Blummer",
                "Thomas Voegtlin",
                "Wladimir",
                "Mike Hearn",
                "Jorge Tim\u00f3n",
                "Pieter Wuille",
                "Justus Ranvier"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 27176
        }
    },
    {
        "title": "[Bitcoin-development] Proposed BIP 70 extension",
        "thread_messages": [
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T13:27:57",
                "message_text_only": "Coinbase have started allowing merchants to set discounts for purchasing\nwith Bitcoin. Seeing an individual discount is not very motivating as they\ntend to be small. Seeing them stack up over time can be more motivating\nbecause it feels like free money. Many businesses exploit this effect with\nloyalty points, etc. Bitcoin should do this too - show the user how much\nthey're saving by using Bitcoin instead of credit cards.\n\nI suggested to Charlie Lee (who pushed this through at Coinbase) and\nStephen Pair the following minor BIP 70 extension:\n\n\nmessage PaymentDetails {\n    // Size in satoshis of any discount provided by the merchant ONLY\n    // because the user chose to pay using Bitcoin or other similar\n    // digital currency. Other kinds of discounts, loyalty bonuses and\n    // so on should not be recorded here, rather they could be mentioned\n    // in the memo field. This field exists so wallets can show the user\n    // a running total of how much money they have saved by avoiding\n    // credit cards and bank payments; the goal is to encourage people to\n    // use Bitcoin. Putting other kinds of discounts here would make the\n    // running total calculated meaningless; so don't do it!\n    optional uint64 currency_usage_discount_size = 8;\n}\n\nWallets would then be able to persist this data to disk and compete on cool\nvisualisations for how much money you saved over time.\n\nWe haven't formalised how to extend BIP 70 yet, that's my fault. We should\ndo that. In the meantime, what do people think of this proposal?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/5e36249c/attachment.html>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-24T14:21:46",
                "message_text_only": "On Tue, Jun 24, 2014 at 9:27 AM, Mike Hearn <mike at plan99.net> wrote:\n> Wallets would then be able to persist this data to disk and compete on cool visualisations for how much money you saved over time.\n\nheh, this is a cool idea.\n\nIt also seems like it would be subject to instant inflation, as it's\nunprovable, and a rational economic actor may choose to exaggerate\nsuch numbers.  It also seems collectively rational by some points of\nview for all bitcoin actors to inflate this number.\n\nAt a minimum, I would either add \"marketing_\" to the field name\nitself, or include additional comment caveats noting in BOLD language\nthat this field is informational, and should not be relied upon for\naccounting/auditing purposes.\n\nIt just seems like a statistic that everyone has an incentive to exaggerate.\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T14:24:53",
                "message_text_only": ">\n> It also seems like it would be subject to instant inflation, as it's\n> unprovable\n\n\nThe user knows the price that is on the website or menu, they know the\nprice they actually paid ... if the numbers don't add up that would seem to\nbe pretty easily detectable. But sure it's only for marketing.  I think the\ncomment makes it clear it's just for fun.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/a3b6016f/attachment.html>"
            },
            {
                "author": "slush",
                "date": "2014-06-24T14:32:17",
                "message_text_only": "Sounds like marketing bullshit to me. It does not have even statistical\nmeaning; well, you can \"save\" a lot of satoshis, but nobody tell you that\nthe merchant cut you on BTC/USD exchange rate in tens of %.\n\nPayment protocol should not contain these fictional data, which has no real\nmeaning for the payment itself. Put these marketing claims to memo field\ninstead...\n\nslush\n\n\nOn Tue, Jun 24, 2014 at 4:24 PM, Mike Hearn <mike at plan99.net> wrote:\n\n> It also seems like it would be subject to instant inflation, as it's\n>> unprovable\n>\n>\n> The user knows the price that is on the website or menu, they know the\n> price they actually paid ... if the numbers don't add up that would seem to\n> be pretty easily detectable. But sure it's only for marketing.  I think the\n> comment makes it clear it's just for fun.\n>\n>\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/ef92af63/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T15:06:34",
                "message_text_only": ">\n> Sounds like marketing bullshit to me. It does not have even statistical\n> meaning; well, you can \"save\" a lot of satoshis, but nobody tell you that\n> the merchant cut you on BTC/USD exchange rate in tens of %.\n>\n\nYour own wallet can look up the exchange rate and compare it to what you're\ngetting (and in fact, wallets do!).\n\nBesides, assuming the customer is *always* being scammed seems extreme.\nThere are plenty of merchants that genuinely care about their reputation\nand genuinely want people to pay with Bitcoin so they can avoid card fees.\n\n\n> Payment protocol should not contain these fictional data\n>\n\nWell, I think the protocol should contain whatever is useful.\n\nI'll probably draft a BIP for this next week or so.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/96462d5a/attachment.html>"
            },
            {
                "author": "Gmail",
                "date": "2014-06-24T15:15:10",
                "message_text_only": "> On Jun 24, 2014, at 10:32, slush <slush at centrum.cz> wrote:\n> \n> Sounds like marketing bullshit to me. It does not have even statistical meaning; well, you can \"save\" a lot of satoshis, but nobody tell you that the merchant cut you on BTC/USD exchange rate in tens of %.\n\nPeople would also abuse this feature in the same way amazon (and other sales sites) abuse the definition of \"save\". For example, Amazon will indicate that you're getting x% off by shopping at amazon, but all that number really means is x% off MSRP. In reality, every website has the same price. I have no doubt that merchants would put similarly meaningless and/or misleading data in this field. \n\nI agree, the memo field is appropriate for this data. \n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 1593 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/bbd4c63a/attachment.p7s>"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-24T15:48:15",
                "message_text_only": "I think there is nothing wrong with having a numeric memo field, which\nis effectively what this is.  Structured rather than unstructured\ndata.\n\nOn Tue, Jun 24, 2014 at 11:15 AM, Gmail <will.yager at gmail.com> wrote:\n>\n>\n>> On Jun 24, 2014, at 10:32, slush <slush at centrum.cz> wrote:\n>>\n>> Sounds like marketing bullshit to me. It does not have even statistical meaning; well, you can \"save\" a lot of satoshis, but nobody tell you that the merchant cut you on BTC/USD exchange rate in tens of %.\n>\n> People would also abuse this feature in the same way amazon (and other sales sites) abuse the definition of \"save\". For example, Amazon will indicate that you're getting x% off by shopping at amazon, but all that number really means is x% off MSRP. In reality, every website has the same price. I have no doubt that merchants would put similarly meaningless and/or misleading data in this field.\n>\n> I agree, the memo field is appropriate for this data.\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "Gmail",
                "date": "2014-06-24T19:00:02",
                "message_text_only": "Ok, wanting structured data is a decent argument, but why this random arbitrary case in particular? There are hundreds of fields like this that people might want to use. \n\nIf we're going to support one random cosmetic field, we might as well support them all with a generic structured data format. \n\nI'd rather we just didn't have this essentially pointless \"feature\" at all. Let's try and keep as much cruft as possible out of the payment protocol. The textual memo field is already more than sufficient. \n\n> On Jun 24, 2014, at 11:48, Jeff Garzik <jgarzik at bitpay.com> wrote:\n> \n> I think there is nothing wrong with having a numeric memo field, which\n> is effectively what this is.  Structured rather than unstructured\n> data.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/27e30be9/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 1593 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/27e30be9/attachment.p7s>"
            },
            {
                "author": "Andy Alness",
                "date": "2014-06-24T19:34:03",
                "message_text_only": "I somewhat agree with Will (but also with Mike, Jeff, and Charlie.) I\nthink the idea of letting consumers know advanced details about the\ntransaction is good and defining these with strong types is also good.\nMaybe an arbitrary set of accounting line items would be more\npalatable. You could have a line item for state sales tax for example,\nor a cash back reward, or a merchant discount like the proposed,\nwhatever is applicable. It would be a list of amount / label tuples\nmaybe.\n\nOn Tue, Jun 24, 2014 at 12:00 PM, Gmail <will.yager at gmail.com> wrote:\n> Ok, wanting structured data is a decent argument, but why this random\n> arbitrary case in particular? There are hundreds of fields like this that\n> people might want to use.\n>\n> If we're going to support one random cosmetic field, we might as well\n> support them all with a generic structured data format.\n>\n> I'd rather we just didn't have this essentially pointless \"feature\" at all.\n> Let's try and keep as much cruft as possible out of the payment protocol.\n> The textual memo field is already more than sufficient.\n>\n> On Jun 24, 2014, at 11:48, Jeff Garzik <jgarzik at bitpay.com> wrote:\n>\n> I think there is nothing wrong with having a numeric memo field, which\n> is effectively what this is.  Structured rather than unstructured\n> data.\n>\n>\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n\n\n\n-- \nAndy Alness\nSoftware Engineer\nCoinbase\nSan Francisco, CA"
            },
            {
                "author": "Gavin Andresen",
                "date": "2014-06-24T20:12:09",
                "message_text_only": "On Tue, Jun 24, 2014 at 3:00 PM, Gmail <will.yager at gmail.com> wrote:\n\n> Ok, wanting structured data is a decent argument, but why this random\n> arbitrary case in particular? There are hundreds of fields like this that\n> people might want to use.\n>\n\nProtocol buffers are designed to be extensible, and there are hundreds of\nfield numbers available.\n\nIt would be silly to add a \"generic stuff\" field inside a container format\nthat ALREADY has all the mechanisms necessary for forwards and backwards\nextensibility.\n\n\n-- \n--\nGavin Andresen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/ec32513e/attachment.html>"
            },
            {
                "author": "Gmail",
                "date": "2014-06-24T20:28:23",
                "message_text_only": "> On Jun 24, 2014, at 16:12, Gavin Andresen <gavinandresen at gmail.com> wrote:\n> \n> It would be silly to add a \"generic stuff\" field inside a container format that ALREADY has all the mechanisms necessary for forwards and backwards extensibility.\n\nI agree. It would be even sillier to start specifying container formats for random one-off \"that would be kind of nice, I guess\" features. \n\nHow about exchange rate? Sharing links? Referral information? Any of these things are just as deserving of specification (and just as arbitrary). \n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 1593 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/d2ebb0cc/attachment.p7s>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-25T08:25:43",
                "message_text_only": ">\n> I agree. It would be even sillier to start specifying container formats\n> for random one-off \"that would be kind of nice, I guess\" features.\n>\n\nNo, it'd be sensible.\n\nHere's a list I drew up a long time ago of features I imagined adding to\nthe payment protocol:\n\nhttps://bitcointalk.org/index.php?topic=270055.msg2890147#msg2890147\n\nThe protocol is there to contain features! There is zero benefit to\nslavishly following some religious notion of purity or minimalism here. The\nshared resource in question is just varint encoded integers. So, we should\nbe guided by what will help our users and what will help adoption.\n\nAnyway, Gavin asked me to start handling more BIP 70 stuff a few weeks ago.\nI want to use something simple to set up the extensions process more\nformally. IMO we need a \"living document\" version of the payment protocol\nwith all the different extensions out there folded into it, to simplify\nprogramming tasks and ensure field numbers don't collide.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/bc9bd69b/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2014-06-25T13:33:28",
                "message_text_only": "+1 on setting up the payment protocol extensions process more formally.\nOn the feature itself, it is interesting to note that some\ncomplementary currencies backed by national currencies offer a\ndiscount when converting from fiat to complementary, which has an\nequivalent effect to this \"discount for paying with btc\". The main\ndifference is that in local currencies the merchants are a relatively\nsmall group and the discount is uniform whereas here each merchant can\nset his own discount. There's scientific studies on how different\ncurrency features like these discounts affect adoption, velocity and\nother variables. I can ask for them if anyone is interested.\n\nOn the implementation, I think a percentage/proportion would be\npreferable over an amount in satoshis.\nLet's imagine for a second that the bitcoin payment protocol ends up\nbeing a generalized and universal payment protocol. The field would be\nreally something like \"discount/additional_charge for paying with the\nchosen currency/payment_method\".\nYou could have 0.95 for a 5% discount or 1.05 for a 5% additional\ncharge. Mhmm, maybe a flat discount/charge in addition to the\nproportional one...\n\nOn security, being an optional field, I don't see how can it harm anything.\nIt is true that the merchants can lie about the discount, but wallets\ncan be smart or stupid about it, or just completely ignore the field\nas they wish.\n\nAnyway, it feels like a random simple extension as an excuse to\ndevelop the extension process. If it gets too complicated we can start\nwith a simpler and less critical one but it's hard for me to imagine\nit.\n\n\nOn 6/25/14, Mike Hearn <mike at plan99.net> wrote:\n>>\n>> I agree. It would be even sillier to start specifying container formats\n>> for random one-off \"that would be kind of nice, I guess\" features.\n>>\n>\n> No, it'd be sensible.\n>\n> Here's a list I drew up a long time ago of features I imagined adding to\n> the payment protocol:\n>\n> https://bitcointalk.org/index.php?topic=270055.msg2890147#msg2890147\n>\n> The protocol is there to contain features! There is zero benefit to\n> slavishly following some religious notion of purity or minimalism here. The\n> shared resource in question is just varint encoded integers. So, we should\n> be guided by what will help our users and what will help adoption.\n>\n> Anyway, Gavin asked me to start handling more BIP 70 stuff a few weeks ago.\n> I want to use something simple to set up the extensions process more\n> formally. IMO we need a \"living document\" version of the payment protocol\n> with all the different extensions out there folded into it, to simplify\n> programming tasks and ensure field numbers don't collide.\n>\n\n\n-- \nJorge Tim\u00f3n"
            },
            {
                "author": "Jeff Garzik",
                "date": "2014-06-25T18:10:58",
                "message_text_only": "Remember the IETF RFC process.\n\n1) RFCs are never updated.  Extensions go into new RFCs.\n2) Build an implementation, write a draft, circulate both.  Then get a\nBIP number.\n3) As MH indicated, it would be useful to have a living payment\nprotocol document that _is_ updated.\n4) Let's stop calling it BIP70.  That just reinforces the desire to\nupdate the BIP70 document.\n\n\n\nOn Wed, Jun 25, 2014 at 9:33 AM, Jorge Tim\u00f3n <jtimon at monetize.io> wrote:\n> +1 on setting up the payment protocol extensions process more formally.\n> On the feature itself, it is interesting to note that some\n> complementary currencies backed by national currencies offer a\n> discount when converting from fiat to complementary, which has an\n> equivalent effect to this \"discount for paying with btc\". The main\n> difference is that in local currencies the merchants are a relatively\n> small group and the discount is uniform whereas here each merchant can\n> set his own discount. There's scientific studies on how different\n> currency features like these discounts affect adoption, velocity and\n> other variables. I can ask for them if anyone is interested.\n>\n> On the implementation, I think a percentage/proportion would be\n> preferable over an amount in satoshis.\n> Let's imagine for a second that the bitcoin payment protocol ends up\n> being a generalized and universal payment protocol. The field would be\n> really something like \"discount/additional_charge for paying with the\n> chosen currency/payment_method\".\n> You could have 0.95 for a 5% discount or 1.05 for a 5% additional\n> charge. Mhmm, maybe a flat discount/charge in addition to the\n> proportional one...\n>\n> On security, being an optional field, I don't see how can it harm anything.\n> It is true that the merchants can lie about the discount, but wallets\n> can be smart or stupid about it, or just completely ignore the field\n> as they wish.\n>\n> Anyway, it feels like a random simple extension as an excuse to\n> develop the extension process. If it gets too complicated we can start\n> with a simpler and less critical one but it's hard for me to imagine\n> it.\n>\n>\n> On 6/25/14, Mike Hearn <mike at plan99.net> wrote:\n>>>\n>>> I agree. It would be even sillier to start specifying container formats\n>>> for random one-off \"that would be kind of nice, I guess\" features.\n>>>\n>>\n>> No, it'd be sensible.\n>>\n>> Here's a list I drew up a long time ago of features I imagined adding to\n>> the payment protocol:\n>>\n>> https://bitcointalk.org/index.php?topic=270055.msg2890147#msg2890147\n>>\n>> The protocol is there to contain features! There is zero benefit to\n>> slavishly following some religious notion of purity or minimalism here. The\n>> shared resource in question is just varint encoded integers. So, we should\n>> be guided by what will help our users and what will help adoption.\n>>\n>> Anyway, Gavin asked me to start handling more BIP 70 stuff a few weeks ago.\n>> I want to use something simple to set up the extensions process more\n>> formally. IMO we need a \"living document\" version of the payment protocol\n>> with all the different extensions out there folded into it, to simplify\n>> programming tasks and ensure field numbers don't collide.\n>>\n>\n>\n> --\n> Jorge Tim\u00f3n\n>\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n\n\n\n-- \nJeff Garzik\nBitcoin core developer and open source evangelist\nBitPay, Inc.      https://bitpay.com/"
            },
            {
                "author": "slush",
                "date": "2014-06-25T14:15:01",
                "message_text_only": "On Wed, Jun 25, 2014 at 10:25 AM, Mike Hearn <mike at plan99.net> wrote:\n>\n> The protocol is there to contain features! There is zero benefit to\n> slavishly following some religious notion of purity or minimalism here.\n>\n\nGood standard must be explicit as much as possible. Having million optional\nfields with ambiguous meaning is even worse than not having these fields.\n\nHTTP status codes are good example. There are hundreds of them, still\napplications understands just few of them, because other have ambiguous\nmeaning and software don't know how to handle them.\n\nGood example of such over-engineering is also XMPP. XMPP has milions\nextensions and features, but look at Jabber clients; call yourself lucky\nwhen you can send messages and files, although there're various extensions\nlike searching for contacts (something which has be working in ICQ decade\nago), voice support, end to end encryption or alerting users. These\nfeatures are defined, but not widely implemented, because its definition is\nvague or the feature is abused because of poor design.\n\nPlease don't over-engineer payment protocol.\n\nThank you for your attention.\n\nslush\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/c0bd2c59/attachment.html>"
            },
            {
                "author": "Gmail",
                "date": "2014-06-25T16:03:31",
                "message_text_only": "> On Jun 25, 2014, at 10:15, slush <slush at centrum.cz> wrote:\n> Good standard must be explicit as much as possible. Having million optional fields with ambiguous meaning is even worse than not having these fields.\n\n+1. BIP70 is important. We want to keep it very simple and generalized, or there is a very real risk that implementers will either not bother with it or implement it in buggy, poorly standardized ways. \n\nAny information not required by the machine should only exist in human-oriented fields (namely, the memo field). \n\nLet's try to avoid ending up with another horrendously complicated, edge-case-oriented protocol like we programmers frequently complain about. \n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: smime.p7s\nType: application/pkcs7-signature\nSize: 1593 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/a3be5f65/attachment.p7s>"
            },
            {
                "author": "Roy Badami",
                "date": "2014-06-24T18:34:34",
                "message_text_only": "On Tue, Jun 24, 2014 at 10:21:46AM -0400, Jeff Garzik wrote:\n> On Tue, Jun 24, 2014 at 9:27 AM, Mike Hearn <mike at plan99.net> wrote:\n> > Wallets would then be able to persist this data to disk and compete on cool visualisations for how much money you saved over time.\n> \n> heh, this is a cool idea.\n> \n> It also seems like it would be subject to instant inflation, as it's\n> unprovable, and a rational economic actor may choose to exaggerate\n> such numbers.  It also seems collectively rational by some points of\n> view for all bitcoin actors to inflate this number.\n\nRather than offering discounts, how about offering automatic cashback?\nI know they're kinda stupid, but I gather cashback deals are very\ncommonplace in the US and (probably as a result) not unheard of elsewhere.\n\nSo you add an optional cashback_to field to the Payment message,\ndistinct from but conceptually similar to the refund_to field.  The\nwallet can tally up how much cashback is received, without having to\ntrust the merchants.\n\nMuch harder to game, AFAICS.\n\nroy"
            },
            {
                "author": "Andreas Schildbach",
                "date": "2014-06-24T15:43:51",
                "message_text_only": "I think it should be made more clear what's the reference price for the\ndiscount. In Germany, we generally don't use credit cards but rather\n\"EC-Cards\", which is already much cheaper. Or maybe for some merchants\nthe only alternative is cash, and they would still offer a Bitcoin discount.\n\nAlso, currently PR are created by the payment processors afaik. How can\nthey know what other payment option the merchant provides and what's the\nconditions? Maybe we should first solve the signature delegation problem\nso that the merchant can create the request.\n\nAlthough I'm sure this feature will get abused, I (as a wallet author)\nwould be willing to give it a try. I agree with Jeff that the name of\nthe field should start with something like \"marketing\".\n\n\nOn 06/24/2014 03:27 PM, Mike Hearn wrote:\n> Coinbase have started allowing merchants to set discounts for purchasing\n> with Bitcoin. Seeing an individual discount is not very motivating as\n> they tend to be small. Seeing them stack up over time can be more\n> motivating because it feels like free money. Many businesses exploit\n> this effect with loyalty points, etc. Bitcoin should do this too - show\n> the user how much they're saving by using Bitcoin instead of credit cards.\n> \n> I suggested to Charlie Lee (who pushed this through at Coinbase) and\n> Stephen Pair the following minor BIP 70 extension:\n> \n> \n> message PaymentDetails {\n>     // Size in satoshis of any discount provided by the merchant ONLY\n>     // because the user chose to pay using Bitcoin or other similar \n>     // digital currency. Other kinds of discounts, loyalty bonuses and \n>     // so on should not be recorded here, rather they could be mentioned\n>     // in the memo field. This field exists so wallets can show the user\n>     // a running total of how much money they have saved by avoiding\n>     // credit cards and bank payments; the goal is to encourage people to\n>     // use Bitcoin. Putting other kinds of discounts here would make the\n>     // running total calculated meaningless; so don't do it!\n>     optional uint64 currency_usage_discount_size = 8;\n> }\n> \n> Wallets would then be able to persist this data to disk and compete on\n> cool visualisations for how much money you saved over time.\n> \n> We haven't formalised how to extend BIP 70 yet, that's my fault. We\n> should do that. In the meantime, what do people think of this proposal?\n> \n> \n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> \n> \n> \n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-24T15:59:27",
                "message_text_only": ">\n> I think it should be made more clear what's the reference price for the\n> discount.\n>\n\nThat might be useful for merchants that already provide a series of\nprice-differentiated payment methods, yes. Will think about it.\n\n\n> Also, currently PR are created by the payment processors afaik. How can\n> they know what other payment option the merchant provides and what's the\n> conditions?\n>\n\nCurrently Coinbase let merchants specify the size of their discount (I\nguess in percentage terms, I should ask). So the merchants tell the payment\nprocessor. I don't think this is a worry at the moment.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/f88f8983/attachment.html>"
            },
            {
                "author": "Drak",
                "date": "2014-06-24T17:37:02",
                "message_text_only": "Seems like a nice idea.\n\n\nOn 24 June 2014 14:27, Mike Hearn <mike at plan99.net> wrote:\n\n> Coinbase have started allowing merchants to set discounts for purchasing\n> with Bitcoin. Seeing an individual discount is not very motivating as they\n> tend to be small. Seeing them stack up over time can be more motivating\n> because it feels like free money. Many businesses exploit this effect with\n> loyalty points, etc. Bitcoin should do this too - show the user how much\n> they're saving by using Bitcoin instead of credit cards.\n>\n> I suggested to Charlie Lee (who pushed this through at Coinbase) and\n> Stephen Pair the following minor BIP 70 extension:\n>\n>\n> message PaymentDetails {\n>     // Size in satoshis of any discount provided by the merchant ONLY\n>     // because the user chose to pay using Bitcoin or other similar\n>     // digital currency. Other kinds of discounts, loyalty bonuses and\n>     // so on should not be recorded here, rather they could be mentioned\n>     // in the memo field. This field exists so wallets can show the user\n>     // a running total of how much money they have saved by avoiding\n>     // credit cards and bank payments; the goal is to encourage people to\n>     // use Bitcoin. Putting other kinds of discounts here would make the\n>     // running total calculated meaningless; so don't do it!\n>     optional uint64 currency_usage_discount_size = 8;\n> }\n>\n> Wallets would then be able to persist this data to disk and compete on\n> cool visualisations for how much money you saved over time.\n>\n> We haven't formalised how to extend BIP 70 yet, that's my fault. We should\n> do that. In the meantime, what do people think of this proposal?\n>\n>\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/cb67ab5f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposed BIP 70 extension",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Jeff Garzik",
                "slush",
                "Andreas Schildbach",
                "Mike Hearn",
                "Roy Badami",
                "Andy Alness",
                "Jorge Tim\u00f3n",
                "Gavin Andresen",
                "Gmail",
                "Drak"
            ],
            "messages_count": 20,
            "total_messages_chars_count": 30241
        }
    },
    {
        "title": "[Bitcoin-development] Bill Request Message - (another) Proposed BIP 70 extension",
        "thread_messages": [
            {
                "author": "Paul Goldstein",
                "date": "2014-06-24T19:44:30",
                "message_text_only": "Here's an idea for a BIP 70 extension to let wallets be scanned by merchant\nbar code readers to start off a payment request flow instead of the other\nway around (wallet scanning the merchant QR). Useful for brick and mortar\nmerchants and mobile wallet apps.\n\n\nMotivation:\nA mechanism is needed for mobile wallets to request a bill, so that a\npayment protocol flow can be initiated. Current mechanisms for initiating\nBIP70 payment flows generally require wallets to either scan a merchant\nbarcode (not optimal, see below), or click on a specially formatted url\nlink (only suitable while browsing and purchasing on a merchant website).\n\nSuccessful non-bitcoin mobile wallet apps to date (a popular coffee shop\napp comes to mind) allow for the wallet app to be scanned by the merchant\nand not the other way around (as is commonly done in bitcoin wallets\ntoday). For broad bitcoin adoption we need a mechanism for wallets to be\nscanned by merchant bar code readers at brick and mortar shops. This will\nalso greatly ease checkouts at drive throughs and allows merchants to\nleverage existing hardware (barcode readers).\n\nOther technologies like NFC may obviate the need for this extension,\nhowever, those technologies remain somewhat uncommon and may not be\nsuitable for smaller wearables hitting the market.\n\nmessage BillRequest {\n required uint64 time = 1;\n optional uint64 expires = 2;\n required string bill_request_uri = 3;\n}\n\n\ntime - Unix timestamp (seconds since 1-Jan-1970 UTC) when the BillRequest\nwas created.\nexpires - Unix timestamp (UTC) after which the BillRequest should be\nconsidered invalid (wallets may only be monitoring for messages for a short\ntime).\nbill_req_addr - Typically a URL where a BIP70 payment request can be sent\nthat is being monitored by the wallet. However this could also support URIs\nlike \"sms:860-555-1212\" or \"mailto:asdf at gmail.com\" allowing for a variety\nof connection options.\n\nRecommendations: it is recommended that wallet apps display a non-QR\nbarcode like a PDF417 barcode to initiate the Bill Request flow. This will\navoid confusion with existing QR code usage in wallet apps.\n\n--------\nPaul G.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140624/b092242c/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-25T11:23:45",
                "message_text_only": "I'm not convinced this inversion is really a problem, but as this is quite\na complex proposal (e.g. new barcode types) the best way to move it forward\nat this stage is to implement it in some existing wallets.\n\nFWIW NFC is a lot more common than you might think. For the drive-thru case\nyou could also consider using wifi hotspots with a special name or\nBluetooth LE tags. So I suspect before trying to write a specification it'd\nbe better to explore different technologies and see what works best in\npractice.\n\n\n\nOn Tue, Jun 24, 2014 at 9:44 PM, Paul Goldstein <paul at realfoot.com> wrote:\n\n> Here's an idea for a BIP 70 extension to let wallets be scanned by\n> merchant bar code readers to start off a payment request flow instead of\n> the other way around (wallet scanning the merchant QR). Useful for brick\n> and mortar merchants and mobile wallet apps.\n>\n>\n> Motivation:\n> A mechanism is needed for mobile wallets to request a bill, so that a\n> payment protocol flow can be initiated. Current mechanisms for initiating\n> BIP70 payment flows generally require wallets to either scan a merchant\n> barcode (not optimal, see below), or click on a specially formatted url\n> link (only suitable while browsing and purchasing on a merchant website).\n>\n> Successful non-bitcoin mobile wallet apps to date (a popular coffee shop\n> app comes to mind) allow for the wallet app to be scanned by the merchant\n> and not the other way around (as is commonly done in bitcoin wallets\n> today). For broad bitcoin adoption we need a mechanism for wallets to be\n> scanned by merchant bar code readers at brick and mortar shops. This will\n> also greatly ease checkouts at drive throughs and allows merchants to\n> leverage existing hardware (barcode readers).\n>\n> Other technologies like NFC may obviate the need for this extension,\n> however, those technologies remain somewhat uncommon and may not be\n> suitable for smaller wearables hitting the market.\n>\n> message BillRequest {\n>  required uint64 time = 1;\n>  optional uint64 expires = 2;\n>  required string bill_request_uri = 3;\n> }\n>\n>\n> time - Unix timestamp (seconds since 1-Jan-1970 UTC) when the BillRequest\n> was created.\n> expires - Unix timestamp (UTC) after which the BillRequest should be\n> considered invalid (wallets may only be monitoring for messages for a short\n> time).\n> bill_req_addr - Typically a URL where a BIP70 payment request can be sent\n> that is being monitored by the wallet. However this could also support URIs\n> like \"sms:860-555-1212\" or \"mailto:asdf at gmail.com\" allowing for a variety\n> of connection options.\n>\n> Recommendations: it is recommended that wallet apps display a non-QR\n> barcode like a PDF417 barcode to initiate the Bill Request flow. This will\n> avoid confusion with existing QR code usage in wallet apps.\n>\n> --------\n> Paul G.\n>\n>\n> ------------------------------------------------------------------------------\n> Open source business process management suite built on Java and Eclipse\n> Turn processes into business applications with Bonita BPM Community Edition\n> Quickly connect people, data, and systems into organized workflows\n> Winner of BOSSIE, CODIE, OW2 and Gartner awards\n> http://p.sf.net/sfu/Bonitasoft\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/717ef2d0/attachment.html>"
            },
            {
                "author": "Mike Hearn",
                "date": "2014-06-25T14:38:06",
                "message_text_only": "Alright. I still tend to think it's not a big deal, but there's no reason\nboth or all mechanisms can't co-exist.\n\nBTW: a QR code next to a cash register can be fixed i.e. printed on paper\nwhen using BIP70. The PoS would upload payment details to the server and\nthe URL for that particular PoS unit would then serve it when the user\nscans the QR code. Alternatively, Andreas' work on Bluetooth may be more\nappropriate: the QR code can contain the BT MAC of the device and the\npayment request is downloaded that way. That's already implemented! I still\nfeel that if a seller can scan a users phone, the users phone can certainly\nscan some rectangle that's physically near by the sales counter.\n\nThe other nice thing about that approach is the QRcode can also be an NFC\ntag i.e. have the tag behind it with a little icon in the middle of the QR\ncode to indicate that touching works as well as scanning.\n\nOne project I keep wanting to play with is making these little NFC-QRcode\nhybrids and a simple PoS app to go with them. But no time, alas ....\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140625/e3a3e533/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bill Request Message - (another) Proposed BIP 70 extension",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Paul Goldstein",
                "Mike Hearn"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7138
        }
    },
    {
        "title": "[Bitcoin-development] Bitcoin Protocol Specification",
        "thread_messages": [
            {
                "author": "Krzysztof Okupski",
                "date": "2014-06-26T11:30:01",
                "message_text_only": "Dear all,\n\na while ago I've posted a work of mine, namely the Bitcoin Protocol\nSpecification,\nthat should by now ring a bell to some of you. Ever since I've received\nplenty of\ncomments from Bitcoin Core developers, Bitcoin enthusiasts and many others.\nFor the encouraging words and improvement proposals I'm very grateful. I\ntried\nto incorporate to the best of my abilities and am happy to present a\nrevised version.\nAs before, it can be found under:\n\nhttp://enetium.com/resources/Bitcoin.pdf\n\nI hope it will prove useful to the community and thank in advance for\nany further\nimprovement proposals.\n\n\nKind regards,\nKrzysztof"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Protocol Specification",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Krzysztof Okupski"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 624
        }
    },
    {
        "title": "[Bitcoin-development] About the small number of bitcoin nodes",
        "thread_messages": [
            {
                "author": "Wladimir",
                "date": "2014-06-30T10:16:01",
                "message_text_only": "> - Create a \"grafical interface\" for bitcoind on Linux servers:\n> Create a command, for example \"bitcoind show\" that shows a nice summary in\n> your Terminal (Console) with all the data that a node administrator wants to\n> know.\n> When I say \"grafical interface\" I mean like \"top\" command, an interface made\n> out of characters in ASCII.\n\nFYI someone created this! It's still in the initial stages, I'm sure\nthe author could use some help to grow this into a full-functional\nnode admin tool.\n\nhttps://github.com/azeteki/bitcoind-ncurses\n\nWladimir"
            }
        ],
        "thread_summary": {
            "title": "About the small number of bitcoin nodes",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Wladimir"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 546
        }
    },
    {
        "title": "[Bitcoin-development] Payment Protocol for Face-to-face Payments",
        "thread_messages": [
            {
                "author": "Alex Kotenko",
                "date": "2014-06-30T19:26:36",
                "message_text_only": "It took some time but we have finally implemented bluetooth integration\noffered by Andreas in our bitcoin payment terminals.\n\n\u200bHowever it's not ideal at the moment. Basically the main problem is that\nin the BIP72 there is no way to provide a fallback alternative URI for\npayment request fetch if client wallet supports BIP70 but doesn't not\nsupport fetching over bluetooth or bluetooth connection fails for any\nreason.\nThere is a way to define alternative URIs inside payment request itself,\nbut that doesn't really work as client first needs to get payment request\nmessage itself somehow and this is exactly the problem.\n\nAs far as I see there is three ways to solve that:\n1. add new URI parameter for bluetooth address\n  (e.g. r=http://<web_address>&rbt=bt:<BT_MAC_addres>).\n2. allow multiple \"r\" parameters\n  (e.g. r=http://<web_address>&r=bt:<BT_MAC_addres>).\n3. allow \"r\" to be an array\n  (e.g. r%5B0%5D=http://<web_address>&r%5B1%5D=bt:<BT_MAC_addres>).\n\nOption #1 isn't great at all, as it solves existing problem, but not\nprovides any way to solve same problem appearing again for another possible\nprotocol.\n\nOptions #2 & #3 may be working and seem to be nearly equal, and both are\nnot great in the way that URI parser behavior in these cases is not clearly\ndefined. I've checked through relevant RFCs and found nothing specific\nabout this. According to my limited web experience the array scheme is\nworking better than multiple repeating parameters.\n\nSo I'm looking for some advice on which route of three proposed may be\nbetter here, or if there are any other ways I'm missing.\n\n\n2014-03-27 13:31 GMT+00:00 vv01f <vv01f at riseup.net>:\n\n> Companies can have a Cert with their name via CAcert. It requires some\n> work though to get assured as an organisation.\n> Did you already think about what CA is to be trusted or do users need to\n> do that. The least good decision in my POV would be to accept OS/browser\n> built in CAs only.\n>\n> Am 27.03.2014 um 11:08 schrieb Mike Hearn <mike at plan99.net>:\n>\n>  But these cases are the norm, rather than the exception.\n>>\n>\n> Well, you're lucky, you live in Berlin. Most of the payments I make with\n> Bitcoin are online, to websites. So this will differ between people.\n>\n> I wonder how critical it is. Let's say you are paying for a meal. In your\n> head the place you're at is just \"the little Indian restaurant on the\n> corner\". In the companies register and therefore certificate it's something\n> like \"Singh Food GmbH\". That's probably good enough to prevent shenanigans.\n> Even if there's a virus on your phone, it can't really replace the cert\n> with a random stolen one, otherwise your meal could show up like \"IronCore\n> Steel Inc\" or something that's obviously bogus. It'd have to be an\n> incredibly smart virus that knew how to substitute one name for a different\n> one, from a large library of stolen identities, such that the swap seemed\n> plausible. That sounds very hard, certainly too hard to bother with for\n> stealing restaurant fees.\n>\n> And if a waiter at the restaurant is corrupt and they replace the cert\n> with one that's for their own 1-man business \"BP-Gupta\" or something, OK,\n> you might pay the wrong person by mistake. But eventually the corrupt\n> waiter will be discovered and then someone will have proof of what they\n> did. It's FAR more likely they'd just strip the signature entirely and try\n> to convince you the restaurant doesn't use BIP70 at all.\n>\n> Still, if we want to fix this, one approach I was thinking about is to\n> have a super-cheesy CA just for us that issues certs with addresses in\n> them, for any name you ask for. That is, if you say you want a cert for\n> \"Shamrock Irish Pub, Wollishofen, Zurich, CH\" then it either sends a\n> postcard to that address with a code to check ownership of the address, or\n> it checks ownership of the place on Google Maps (which does the same\n> postcard trick but for free!).\n>\n> That doesn't work for vending machines, but perhaps we just don't care\n> about those. If a MITM steals your lunch money, boo hoo.\n>\n>\n> ------------------------------------------------------------------------------\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n>\n> ------------------------------------------------------------------------------\n>\n> _______________________________________________\n> Bitcoin-development mailing list\n> Bitcoin-development at lists.sourceforge.net\n> https://lists.sourceforge.net/lists/listinfo/bitcoin-development\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140630/c57b4bfb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Payment Protocol for Face-to-face Payments",
            "categories": [
                "Bitcoin-development"
            ],
            "authors": [
                "Alex Kotenko"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4804
        }
    }
]