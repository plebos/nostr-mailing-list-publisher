[
    {
        "title": "[bitcoin-dev] Smaller Transactions with PubRef",
        "thread_messages": [
            {
                "author": "Mike Brooks",
                "date": "2020-08-01T05:09:25",
                "message_text_only": "The attached BIP describes a new opcode that unlocks the ability to have\ntransactions that are about 37% smaller than a traditional single-source\nsegwit transaction.  (Savings vary based on the number of inputs.)\n\nThe pursuit of smaller transactions is vital for Inclusive Accountability\nas less data needs to be recorded on chain. Frugality is improved in two\nways; more transactions can be confirmed in a  block, and small value\ninputs otherwise inaccessible can now be referenced without losing\nunrecoverable value due to transaction overhead.\n\nhttps://github.com/TheRook/bip-pubref/blob/master/bip-PubRef.mediawiki\n\nThe variant of this technology on the ethereum side is Ditto Transactions:\nhttps://ethereum-magicians.org/t/eip-ditto-transactions/4455\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200731/e20309cb/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-02T00:36:08",
                "message_text_only": "Good morning Mike,\n\nHard NAK.\n\nThe responses to the original posting already pointed out important problems with this:\n\n* Encourages address reuse, hurting fungibility and privacy.\n* Prevents pruning, since access to previous blocks must always be available in order to validate.\n* Optimized implementation requires creating yet another index to previous block data, increasing requirements on fullnodes.\n* Requires SCRIPT to be re-evaluated on transactions arriving in  newblocks, to protect against reorgs of the chaintip, and in particular `OP_PUBREF` references to near the chaintip.\n\nNone of these issues have been addressed in your current proposal.\nThe proposal looks at clients only, without considering what validators have to implement in order to validate new blocks with this opcode.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Mike Brooks",
                "date": "2020-08-02T01:12:16",
                "message_text_only": "Hey  ZmnSCPxj,\n\nRe-orgs should be solved in a different way.\n\nBest Regards,\nMicahel\n\nOn Sat, Aug 1, 2020 at 5:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Mike,\n>\n> Hard NAK.\n>\n> The responses to the original posting already pointed out important\n> problems with this:\n>\n> * Encourages address reuse, hurting fungibility and privacy.\n> * Prevents pruning, since access to previous blocks must always be\n> available in order to validate.\n> * Optimized implementation requires creating yet another index to previous\n> block data, increasing requirements on fullnodes.\n> * Requires SCRIPT to be re-evaluated on transactions arriving in\n> newblocks, to protect against reorgs of the chaintip, and in particular\n> `OP_PUBREF` references to near the chaintip.\n>\n> None of these issues have been addressed in your current proposal.\n> The proposal looks at clients only, without considering what validators\n> have to implement in order to validate new blocks with this opcode.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200801/39c1cb94/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Floating-Point Nakamoto Consensus.pdf\nType: application/pdf\nSize: 70769 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200801/39c1cb94/attachment-0001.pdf>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-02T14:22:30",
                "message_text_only": "Good morning Mike,\n\nThe issue with SCRIPT re-evaluation is that reorgs cause more processing to be done by nodes.\n\nFloating-point Nakamoto Consensus does not help here, since a node can receive the lower-scored block first, and *then* a higher-scored block, and thus will ***still*** observe a reorg since the chain tip is replaced with a higher-scored block later.\n\nThis still increases the processing load on validating fullnodes, and prevents any kind of pruning from working for validating fullnodes.\n\nA miner can also still mount a DoS on validating fullnodes, with `OP_PUBREF` and Floating-Point Nakamoto Consensus by re-mining the same block, and broadcasting a block if it has higher score than the previous chain tip.\nThis locks the blockchain ***and*** increases the load on fullnodes, which have to re-validate uses of `OP_PUBREF` that might refer to the chain tip.\n\nRegards,\nZmnSCPxj\n\n> Hey\u00a0 ZmnSCPxj,\n>\n> Re-orgs should be solved in a different\u00a0way.\u00a0\n>\n> Best Regards,\n> Micahel\n>\n> On Sat, Aug 1, 2020 at 5:36 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Mike,\n> >\n> > Hard NAK.\n> >\n> > The responses to the original posting already pointed out important problems with this:\n> >\n> > * Encourages address reuse, hurting fungibility and privacy.\n> > * Prevents pruning, since access to previous blocks must always be available in order to validate.\n> > * Optimized implementation requires creating yet another index to previous block data, increasing requirements on fullnodes.\n> > * Requires SCRIPT to be re-evaluated on transactions arriving in\u00a0 newblocks, to protect against reorgs of the chaintip, and in particular `OP_PUBREF` references to near the chaintip.\n> >\n> > None of these issues have been addressed in your current proposal.\n> > The proposal looks at clients only, without considering what validators have to implement in order to validate new blocks with this opcode.\n> >\n> > Regards,\n> > ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Smaller Transactions with PubRef",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Mike Brooks"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 5197
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.20.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2020-08-01T12:46:44",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n0.20.1 Release Notes\n====================\n\nBitcoin Core version 0.20.1 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.20.1/>\n\nOr through BitTorrent:\n\n    magnet:?xt=urn:btih:6e2c72d73d763465a725e3ae941b2b937edd0300&dn=bitcoin-core-0.20.1&tr=https%3A%2F%2Fopenbittorrent.com%2F&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969\n\nThis minor release includes various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes in some cases), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nUpgrading directly from a version of Bitcoin Core that has reached its EOL is\npossible, but it might take some time if the data directory needs to be migrated. Old\nwallet versions of Bitcoin Core are generally supported.\n\nCompatibility\n==============\n\nBitcoin Core is supported and extensively tested on operating systems\nusing the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin\nCore should also work on most other Unix-like systems but is not as\nfrequently tested on them.  It is not recommended to use Bitcoin Core on\nunsupported systems.\n\n- From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no\nlonger supported. Additionally, Bitcoin Core does not yet change appearance\nwhen macOS \"dark mode\" is activated.\n\nKnown Bugs\n==========\n\nThe process for generating the source code release (\"tarball\") has changed in an\neffort to make it more complete, however, there are a few regressions in\nthis release:\n\n- - The generated `configure` script is currently missing, and you will need to\n  install autotools and run `./autogen.sh` before you can run\n  `./configure`. This is the same as when checking out from git.\n\n- - Instead of running `make` simply, you should instead run\n  `BITCOIN_GENBUILD_NO_GIT=1 make`.\n\nNotable changes\n===============\n\nChanges regarding misbehaving peers\n- -----------------------------------\n\nPeers that misbehave (e.g. send us invalid blocks) are now referred to as\ndiscouraged nodes in log output, as they're not (and weren't) strictly banned:\nincoming connections are still allowed from them, but they're preferred for\neviction.\n\nFurthermore, a few additional changes are introduced to how discouraged\naddresses are treated:\n\n- - Discouraging an address does not time out automatically after 24 hours\n  (or the `-bantime` setting). Depending on traffic from other peers,\n  discouragement may time out at an indeterminate time.\n\n- - Discouragement is not persisted over restarts.\n\n- - There is no method to list discouraged addresses. They are not returned by\n  the `listbanned` RPC. That RPC also no longer reports the `ban_reason`\n  field, as `\"manually added\"` is the only remaining option.\n\n- - Discouragement cannot be removed with the `setban remove` RPC command.\n  If you need to remove a discouragement, you can remove all discouragements by\n  stop-starting your node.\n\nNotification changes\n- --------------------\n\n`-walletnotify` notifications are now sent for wallet transactions that are\nremoved from the mempool because they conflict with a new block. These\nnotifications were sent previously before the v0.19 release, but had been\nbroken since that release (bug\n[#18325](https://github.com/bitcoin/bitcoin/issues/18325)).\n\nPSBT changes\n- ------------\n\nPSBTs will contain both the non-witness utxo and the witness utxo for segwit\ninputs in order to restore compatibility with wallet software that are now\nrequiring the full previous transaction for segwit inputs. The witness utxo\nis still provided to maintain compatibility with software which relied on its\nexistence to determine whether an input was segwit.\n\n0.20.1 change log\n=================\n\n### Mining\n- - #19019 Fix GBT: Restore \"!segwit\" and \"csv\" to \"rules\" key (luke-jr)\n\n### P2P protocol and network code\n- - #19219 Replace automatic bans with discouragement filter (sipa)\n\n### Wallet\n- - #19300 Handle concurrent wallet loading (promag)\n- - #18982 Minimal fix to restore conflicted transaction notifications (ryanofsky)\n\n### RPC and other APIs\n- - #19524 Increment input value sum only once per UTXO in decodepsbt (fanquake)\n- - #19517 psbt: Increment input value sum only once per UTXO in decodepsbt (achow101)\n- - #19215 psbt: Include and allow both non_witness_utxo and witness_utxo for segwit inputs (achow101)\n\n### GUI\n- - #19097 Add missing QPainterPath include (achow101)\n- - #19059 update Qt base translations for macOS release (fanquake)\n\n### Build system\n- - #19152 improve build OS configure output (skmcontrib)\n- - #19536 qt, build: Fix QFileDialog for static builds (hebasto)\n\n### Tests and QA\n- - #19444 Remove cached directories and associated script blocks from appveyor config (sipsorcery)\n- - #18640 appveyor: Remove clcache (MarcoFalke)\n\n### Miscellaneous\n- - #19194 util: Don't reference errno when pthread fails (miztake)\n- - #18700 Fix locking on WSL using flock instead of fcntl (meshcollider)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Aaron Clauson\n- - Andrew Chow\n- - fanquake\n- - Hennadii Stepanov\n- - Jo\u00e3o Barbosa\n- - Luke Dashjr\n- - MarcoFalke\n- - MIZUTA Takeshi\n- - Pieter Wuille\n- - Russell Yanofsky\n- - sachinkm77\n- - Samuel Dobson\n- - Wladimir J. van der Laan\n\nAs well as to everyone that helped with translations on\n[Transifex](https://www.transifex.com/bitcoin/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl8lYXMACgkQHkrtYphs\n0l2A/Af+POYB8GbqA/MnjGRk8Uw6togCO+06gydbbCSHiVEXv9KN17eSimeUw7B8\nTcatI0d0+Dx2Exv5vhes3rZrX7eh6clma4WMpxKuWlnL8LzeTV5Hz2lxD6Kg9eZO\ngyqsYOgQCtAatApO71z6exzhkqxakzTnWEnWijjG1qVnjGhUPIqEv9KisfhQfWRt\nCKGazPK3k6KxVsDG7p5s9a5ue7b88t1E6jiWt/OR6U5Z50AVQzc7Keji7wuG9byr\nWsDq8w8VuxLtvLbfNJyR9TguiU3vr85Wm3kK9kjDi4t83l1dzbU4hVllb970dzEK\nllclXg5rRi2c52uW4qVXGw2oEMmdfw==\n=lUXy\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.20.1 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6636
        }
    },
    {
        "title": "[bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT",
        "thread_messages": [
            {
                "author": "Richard Myers",
                "date": "2020-08-03T19:27:13",
                "message_text_only": "Thanks AJ for the updated BIP - very exciting!\n\nI'm also interested in this in the context of a Taproot version of\nDecker-Russell-Osuntokun (eltoo). Thanks ZmnSCPxj for summarizing your\nthoughts on how this would work. I have had some difficulty understanding\nwhen someone might want to use ANYPREVOUT vs. ANYPREVOUTANYSCRIPT and this\nis a clever demonstration of how the differences can be exploited.\n\nI sketched out the protocol you described to help my understand it (below)\nand some questions came to mind:\n\n1) If you do a collaborative close, would you need to use script-path\nspending, or could you use key-path spending instead to improve privacy?\n\n2) You mention 1.5 round trips for the (two party) MuSig signing session.\nMust there be separate 1.5 round trips for each of the two signatures\nproduced (update, settlement) for each state update?\n\n3) A related question: can the 1.5 round trips for signing be combined with\nthe 1.5 round trips required to update the channel (ie. A signs settlement\ntx, B signs settlement & update txs, A signs update tx)?\n\nPerhaps something like this:\n -> A provides partial signature for settlement tx\n <- B provides complete signature for settlement tx and partial signature\nfor update tx\n -> A provides complete signature for update tx\n\n4) I'm not sure why AJ's formulation included an addition sig(X), but\notherwise is it similar to what you're suggesting?\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001996.html\n\nAll the best,\n\n  -- Richard\n\n------- my interpretation of your scheme ----\n\n\n  [Fund Channel]\n    |\n    |\n    |\n    v\n   P=Musig(A,B)+scripts (Taproot internal key, aka script path key?)\n   Q=Musig(A,B) (Taproot output key, aka root key?)\n\n   OR ----------- [Cooperative Close]\n   |||            Sig(Q) -----+\n   |||                        |----> Sig(A)...\n   |||                        |\n   |||                        |----> Sig(B)...\n   |||\n   |||\n   ||+-->[Update(n)]\n   ||    nlocktime/state > n\n   ||    Sig(P)+ANYPREVOUTANYSCRIPT\n   ||\n   ||     OR ---------->[Settle(n)]           [Uncooperative Close @\nstate n]\n   ||      |            Sig(P)+ANYPREVOUT\n   ||      |            csv [delay] --------+---> Sig(A)...    [HTLCs\n& Settled\n   ||      |                                |\nOutputs ]\n   ||      |                                |---> Sig(B)...\n   ||      v\n   |+---->[Update(n+1)]\n   |      nlocktime/state > n+1\n   |      Sig(P)+ANYPREVOUTANYSCRIPT\n   |\n   |      OR ----------->[Settle(n+1)]        [Uncooperative Close @\nstate n+1]\n   |       |             Sig(P)+ANYPREVOUT\n   |       |             csv [delay] -------+---> Sig(A)...    [HTLCs\n& Settled\n   |       |                                |\nOutputs ]\n   v       v                                |---> Sig(B)...\n\n\n\n\n\nOn Fri, Jul 10, 2020 at 5:30 AM ZmnSCPxj via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n...\n\n> Slightly off-topic, but I suppose a Decker-Russell-Osuntokun construction\n> could, in theory, have only a single internal taproot pubkey, `P = MuSig(A,\n> B)` for a channel between A and B.\n>\n> So the funding outpoint would be spent with a taprooted P + a single\n> tapscript `<1> OP_CHECKSIG`.\n>\n> Update transactions would be signed with the internal taproot pubkey using\n> `SIGHASH_ANYPREVOUTANYSCRIPT`.\n> The update transaction output would be spendable with a taprooted P + a\n> single tapscript `<index + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <1>\n> OP_CHECKSIG`.\n> Each update transaction would have a monotonically-increasing `nLockTime`,\n> i.e. the above `index`.\n>\n> Then a state transaction would be signed with the internal taproot pubkey\n> using `SIGHASH_ANYPREVOUT`, which commits to the exact script including\n> `<index + 1>`, which is unique for each update transaction.\n> Thus a state transaction can only spend the specific update transaction,\n> but the update transaction can spend the funding outpoint or any update\n> transaction outpoint.\n> State transaction input would have an `nSequence` requiring a relative\n> locktime of the agreed-upon unilateral close delay.\n>\n> The above assumes MuSig signing, which requires 1.5 round trips for a\n> channel, or three broadcast rounds for a multiparticipant (n >= 3)\n> construction.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200803/fadaa364/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-04T01:38:55",
                "message_text_only": "Good morning Richard,\n\n> Thanks AJ for the updated BIP - very exciting!\n>\n> I'm also interested in this in the context of a Taproot version of Decker-Russell-Osuntokun (eltoo).\u00a0Thanks ZmnSCPxj for summarizing your thoughts on how this would work. I have had some difficulty understanding when someone might want to use ANYPREVOUT vs. ANYPREVOUTANYSCRIPT and this is a clever demonstration of how the\u00a0differences can be exploited.\n>\n> I sketched out the protocol you described to help my understand it (below) and some questions came to mind:\n>\n> 1) If you do a collaborative close, would you need to use script-path spending, or could you use key-path spending instead to improve privacy?\n\nIt can (and should) use key-path, yes.\n\n>\n> 2) You mention 1.5 round trips for the (two party) MuSig signing session. Must there be separate 1.5 round trips for each of the two signatures produced (update, settlement) for each state update?\n\nI believe we can amortize this slightly by providing the `R` commitments for the *next* signing session with the `s` for the *current* signing session, reducing to 1.0 round trips.\n\nHowever, I believe a provably-safe 2-round MuSig (with composable MuSig even!) is being worked on and should be released in a week or two, and if it is safe to provide the first round of the *next* session with the final round of the *current* session then we could reduce it to just one (large) message send per update.\n\n>\n> 3) A related question: can the 1.5 round trips for signing be combined with the 1.5 round trips required to update the channel (ie. A signs settlement tx, B signs settlement & update txs, A signs update tx)?\u00a0\n>\n> Perhaps something like this:\n> \u00a0-> A provides partial signature for settlement tx\n> \u00a0<- B provides complete signature for settlement tx and partial signature for update tx\n> \u00a0-> A provides complete signature for update tx\n\nMy understanding (which might be incorrect!) is that it should be safe to perform the signing sessions for the settlement and update txes simultaneously, i.e.\n\n* round 1: send `R` commitments for both update and settlement tx (can be sent with round 3 of previous signing session).\n* round 2: send `R` for both update and settlement tx.\n* round 3: send `s` for both update and settlement tx.\n\nDepending on how we do the HTLCs / PTLCs, we might also need to send signatures for all HTLCs, in parallel with the update+settlement tx signatures, as well.\n\n> 4) I'm not sure why AJ's formulation included an addition sig(X), but otherwise is it similar to what you're suggesting?\n> \u00a0\u00a0https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001996.html\n\nThis might have been the \"chaperone signatures\" proposed for `SIGHASH_NOINPUT` / `SIGHASH_ANYPREVOUT` back then.\nThis was supposed to protect against replaying a `SIGHASH_ANYPREVOUT` signature in case of address reuse.\nI pointed out that it would be much simpler for a Lightning spec to provide a privkey for a common `X` used by all Lightning nodes, and thus would not really provide much better security in practice.\n\n\nI believe what we intend now is a form of hidden output tagging to protect against signature replay.\nAn output has to have a special taproot version in order to be spent with `SIGHASH_ANYPREVOUT` or `SIGHASH_ANYPREVOUTANYSCRIPT` in the script path, and `SIGHASH_ANYPREVOUT`/`SIGHASH_ANYPREVOUTANYSCRIPT` is not usable with key path spends.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "lf-lists at mattcorallo.com",
                "date": "2020-08-04T04:02:21",
                "message_text_only": "While I admit I haven\u2019t analyzed the feasibility, I want to throw one additional design consideration into the ring.\n\nNamely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node\u2019s mempool and you should be able to describe to that node that you are spending then nonetheless.\n\nThis is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.\n\nThe least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).\n\nMatt\n\n> On Jul 9, 2020, at 17:46, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffHello world,\n> \n> After talking with Christina ages ago, we came to the conclusion that\n> it made more sense to update BIP 118 to the latest thinking than have\n> a new BIP number, so I've (finally) opened a (draft) PR to update BIP\n> 118 with the ANYPREVOUT bip I've passed around to a few people,\n> \n> https://github.com/bitcoin/bips/pull/943\n> \n> Probably easiest to just read the new BIP text on github:\n> \n> https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-0118.mediawiki\n> \n> It doesn't come with tested code at this point, but I figure better to\n> have the text available for discussion than nothing.\n> \n> Some significant changes since previous discussion include complete lack\n> of chaperone signatures or anything like it (if you want them, you can\n> always add them yourself, of course), and that ANYPREVOUTANYSCRIPT no\n> longer commits to the value (details/rationale in the text).\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-04T04:23:03",
                "message_text_only": "Good morning Matt,\n\n> While I admit I haven\u2019t analyzed the feasibility, I want to throw one additional design consideration into the ring.\n>\n> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node\u2019s mempool and you should be able to describe to that node that you are spending then nonetheless.\n>\n> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.\n>\n> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).\n\nAh, right.\n\nA feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.\nThen you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a *different* old tx, call it B.\nThe victim reacts only to tA, but does not react to B since it does not see B in the mempool.\n\nOn the other hand --- what the victim needs to react to is *onchain* confirmed transactions.\nSo I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.\n\nSo if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be \"locked\" to that txid, unless a reorg unconfirms the transaction.\nWe only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.\n\nIn addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.\n\nOr are there other attack vectors you can see that I do not?\nI think this is fixed by looking at the blockchain.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2020-08-04T10:38:20",
                "message_text_only": "> Ah, right.\n>\n> A feasible attack, without the above, would be to connect to the\n> fullnode of the victim, and connect to miners separately.  Then you\n> broadcast to the victim one of the old txes, call it tx A, but you\n> broadcast to the miners a *different* old tx, call it B.  The victim\n> reacts only to tA, but does not react to B since it does not see B in\n> the mempool.\n>\n> On the other hand --- what the victim needs to react to is *onchain*\n> confirmed transactions.  So I think all the victim needs to do, in a\n> Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based\n> mechanisms, is to monitor onchain events and ignore mempool events.\n>\n> So if we give fairly long timeouts for our mechanisms, it should be\n> enough, I think, since once a transaction is confirmed its txid does\n> not malleate without a reorg and a `SIGHASH_NOINPUT` signature can\n> then be \"locked\" to that txid, unless a reorg unconfirms the\n> transaction.  We only need to be aware of deep reorgs and re-broadcast\n> with a malleated prevout until the tx being spent is deeply confirmed.\n\nThis is indeed part of the reason why we chose to describe the protocol\non-chain first in the paper and lift it off-chain after showing the\nbasic functionality. This means that the protocol is still correct even\nif executed solely on information derived from blocks and confirmed\ntransactions in those blocks. The timeouts have to be chosen carefully\nto allow reacting in a timely fashion, however that is true for all\noff-chain protocols.\n\n> In addition, we want to implement scorch-the-earth,\n> keep-bumping-the-fee strategies anyway, so we would keep\n> rebroadcasting new versions of the spending transaction, and spending\n> from a transaction that is confirmed.\n\nCorrect, it might be desirable to give a misbehaving node a papercut by\nletting their update transaction confirm (taking their fee along with\nit) and then reacting to the outdated update by overriding the effects\nwith a new update-settlement pair.\n\nSo, while being able to react to a transaction in the memory pool early\nmight be a nice addition, it is not strictly required for safety of the\nprotocol. I say nice addition, because it can allow replacing the\noutdated transaction directly, thus saving the misbehaving node from the\nfee papercut, but also save a bit of blockspace which that fee would\nhave paid for, and leave it available for other transactions.\n\nCheers,\nChristian"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-04T13:10:02",
                "message_text_only": "Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, \u201cjust handle it when it confirms\u201d doesn\u2019t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.\n\n> On Aug 4, 2020, at 00:23, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> \ufeffGood morning Matt,\n> \n>> While I admit I haven\u2019t analyzed the feasibility, I want to throw one additional design consideration into the ring.\n>> \n>> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node\u2019s mempool and you should be able to describe to that node that you are spending then nonetheless.\n>> \n>> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.\n>> \n>> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).\n> \n> Ah, right.\n> \n> A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.\n> Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a *different* old tx, call it B.\n> The victim reacts only to tA, but does not react to B since it does not see B in the mempool.\n> \n> On the other hand --- what the victim needs to react to is *onchain* confirmed transactions.\n> So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.\n> \n> So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be \"locked\" to that txid, unless a reorg unconfirms the transaction.\n> We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.\n> \n> In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.\n> \n> Or are there other attack vectors you can see that I do not?\n> I think this is fixed by looking at the blockchain.\n> \n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-04T14:59:52",
                "message_text_only": "Good morning Matt,\n\n> Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, \u201cjust handle it when it confirms\u201d doesn\u2019t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.\n>\n\nAh, okay.\n\nSo the attack is this:\n\n* Attacker connects twice to the LN: one to any node near the victim, one to the victim.\n* Attacker arranges for the attacker-victim channel to have most funds in the side of the victim.\n* The attacker routes a circular payment terminating in the victim-attacker channel.\n  * The victim accepts some incoming HTLC, and provides an outgoing HTLC to the attacker via the victim-attacker channel.\n* The attacker broadcasts a very low-fee old-state transaction of the victim-attacker channel, one that is too low-fee to practically get confirmed, just before the HTLC timeout.\n* The victim-outgoing HTLC times out, making the victim broadcast a unilateral close attempt for the victim-attacker channel in order to enforce the HTLC onchain.\n  * Unfortunately for the victim, relay shenanigans prevent the latest commitment from being broadcast.\n* The attacker waits for the victim-incoming HTLC to timeout, which forces the victim to `update_htlc_failed` the incoming HTLC or risk having that channel closed (and losing future routing fees).\n  * The attacker now gets back its outgoing funds.\n* The attacker lets the old-state transaction get relayed, and then re-seats the latest update transaction to that.\n* Once the latest transaction allows the HTLCs to be published, the attacker claims the victim-outgoing HTLC with the hashlock branch.\n  * The attacker now gets its incoming funds, doubling its money, because that is how the \"send me 1 BTC I send you 2 BTC back\" Twitter thing works right?\n\nHmmm.\n\nThe only thing I can imagine helping here is for the forwarding node to drop channels onchain \"early\", i.e. if the HTLC will time out in say 14 blocks we drop the channel onchain, so we have a little leeway in bumping up fees for the commitment transaction.\nMaybe.\nI am sure Matt can find yet another relay attack that prevents that, at this point, haha.\n\n\"Are we *still* talking about onchain fees....?\" - Adelaide 2018\n\nRegards,\nZmnSCPxj\n\n\n\n\n> > On Aug 4, 2020, at 00:23, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > Good morning Matt,\n> >\n> > > While I admit I haven\u2019t analyzed the feasibility, I want to throw one additional design consideration into the ring.\n> > > Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node\u2019s mempool and you should be able to describe to that node that you are spending then nonetheless.\n> > > This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.\n> > > The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).\n> >\n> > Ah, right.\n> > A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.\n> > Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a different old tx, call it B.\n> > The victim reacts only to tA, but does not react to B since it does not see B in the mempool.\n> > On the other hand --- what the victim needs to react to is onchain confirmed transactions.\n> > So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.\n> > So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be \"locked\" to that txid, unless a reorg unconfirms the transaction.\n> > We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.\n> > In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.\n> > Or are there other attack vectors you can see that I do not?\n> > I think this is fixed by looking at the blockchain.\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-06T15:58:53",
                "message_text_only": "Yep! That is the attack I had in mind - just in general any time you have a non-relative time limit (ie an HTLC) for\nconfirmation, relay attacks become critical and its no longer just about revocation (which is fine when your time limit\nis CSV-based).\n\nIn general, SIGHASH_NOINPUT makes these issues much, much simpler to address, but only if we assume that nodes can\nsomehow be \"smart\" about replacement when they see a SIGHASH_NOINPUT spend which can spend an output that something else\nin the mempool already spends (potentially a different input than the relaying node thinks the transaction should\nspend). While ideally we'd be able to shove that (significant) complexity into the Bitcoin P2P network, that may not be\nfeasible, but we could imagine a relay network of lightning nodes doing that calculation and then passing the\ntransactions to their local full nodes.\n\nGiven such an overlay network would represent an increase in local mempool fees, it is not unreasonable to expect at\nleast some miners to run a local node which can submit such transactions to their template-generating nodes.\n\nMatt\n\nOn 8/4/20 10:59 AM, ZmnSCPxj wrote:\n> Good morning Matt,\n> \n>> Hmm, apologies that little context was provided - this was meant in the context of the current crop of relay-based attacks that have been discovered. As we learned in those contexts, \u201cjust handle it when it confirms\u201d doesn\u2019t provide the types of guarantees we were hoping for as placing commitment transactions in mempools can be used to prevent honest nodes from broadcasting the latest state. This implies that HTLC security may be at risk.\n>>\n> \n> Ah, okay.\n> \n> So the attack is this:\n> \n> * Attacker connects twice to the LN: one to any node near the victim, one to the victim.\n> * Attacker arranges for the attacker-victim channel to have most funds in the side of the victim.\n> * The attacker routes a circular payment terminating in the victim-attacker channel.\n>   * The victim accepts some incoming HTLC, and provides an outgoing HTLC to the attacker via the victim-attacker channel.\n> * The attacker broadcasts a very low-fee old-state transaction of the victim-attacker channel, one that is too low-fee to practically get confirmed, just before the HTLC timeout.\n> * The victim-outgoing HTLC times out, making the victim broadcast a unilateral close attempt for the victim-attacker channel in order to enforce the HTLC onchain.\n>   * Unfortunately for the victim, relay shenanigans prevent the latest commitment from being broadcast.\n> * The attacker waits for the victim-incoming HTLC to timeout, which forces the victim to `update_htlc_failed` the incoming HTLC or risk having that channel closed (and losing future routing fees).\n>   * The attacker now gets back its outgoing funds.\n> * The attacker lets the old-state transaction get relayed, and then re-seats the latest update transaction to that.\n> * Once the latest transaction allows the HTLCs to be published, the attacker claims the victim-outgoing HTLC with the hashlock branch.\n>   * The attacker now gets its incoming funds, doubling its money, because that is how the \"send me 1 BTC I send you 2 BTC back\" Twitter thing works right?\n> \n> Hmmm.\n> \n> The only thing I can imagine helping here is for the forwarding node to drop channels onchain \"early\", i.e. if the HTLC will time out in say 14 blocks we drop the channel onchain, so we have a little leeway in bumping up fees for the commitment transaction.\n> Maybe.\n> I am sure Matt can find yet another relay attack that prevents that, at this point, haha.\n> \n> \"Are we *still* talking about onchain fees....?\" - Adelaide 2018\n> \n> Regards,\n> ZmnSCPxj\n> \n> \n> \n> \n>>> On Aug 4, 2020, at 00:23, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n>>> Good morning Matt,\n>>>\n>>>> While I admit I haven\u2019t analyzed the feasibility, I want to throw one additional design consideration into the ring.\n>>>> Namely, it would ideally be trivial, at the p2p protocol layer, to relay a transaction to a full node without knowing exactly which input transaction that full node has in its mempool/active chain. This is at least potentially important for systems like lighting where you do not know which counterparty commitment transaction(s) are in a random node\u2019s mempool and you should be able to describe to that node that you are spending then nonetheless.\n>>>> This is (obviously) an incredibly nontrivial problem both in p2p protocol complexity and mempool optimization, but it may leave SIGHASH_NOINPUT rather useless for lighting without it.\n>>>> The least we could do is think about the consensus design in that context, even if we have to provide an external overlay relay network in order to make lighting transactions relay properly (presumably with miners running such software).\n>>>\n>>> Ah, right.\n>>> A feasible attack, without the above, would be to connect to the fullnode of the victim, and connect to miners separately.\n>>> Then you broadcast to the victim one of the old txes, call it tx A, but you broadcast to the miners a different old tx, call it B.\n>>> The victim reacts only to tA, but does not react to B since it does not see B in the mempool.\n>>> On the other hand --- what the victim needs to react to is onchain confirmed transactions.\n>>> So I think all the victim needs to do, in a Lightning universe utilizing primarily `SIGHASH_NOINPUT`-based mechanisms, is to monitor onchain events and ignore mempool events.\n>>> So if we give fairly long timeouts for our mechanisms, it should be enough, I think, since once a transaction is confirmed its txid does not malleate without a reorg and a `SIGHASH_NOINPUT` signature can then be \"locked\" to that txid, unless a reorg unconfirms the transaction.\n>>> We only need to be aware of deep reorgs and re-broadcast with a malleated prevout until the tx being spent is deeply confirmed.\n>>> In addition, we want to implement scorch-the-earth, keep-bumping-the-fee strategies anyway, so we would keep rebroadcasting new versions of the spending transaction, and spending from a transaction that is confirmed.\n>>> Or are there other attack vectors you can see that I do not?\n>>> I think this is fixed by looking at the blockchain.\n>>> Regards,\n>>> ZmnSCPxj\n> \n>"
            },
            {
                "author": "Richard Myers",
                "date": "2020-08-07T15:34:43",
                "message_text_only": "When you say that a special relay network might be more \"smart about\nreplacement\" in the context of ANYPREVOUT*, do you mean these nodes could\nRBF parts of a package like this:\n\n\nGiven:\n - Package A = UpdateTx_A(n=1): txin: AnchorTx, txout: SettlementTx_A(n=1)\n-> HtlcTxs(n=1)_A -> .chain of  transactions that pin UpdateTx_A(n=1) with\nhigh total fee, etc.\n\n\nAnd a new package with higher fee rate versions of ANYPREVOUT* transactions\nin the package, but otherwise lower total fee:\n\n - Package B = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1)\n-> HtlcTxs(n=1)_B -> low total fee package\n\n\nRelay just the higher up-front fee-rate transactions from package B which\nget spent by the high absolute fee child transactions from package A:\n\n - Package A' = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1)\n-> HtlcTxs(n=1)_A -> ...chain of up to 25 txs that pin UpdateTx(n=1) with\nhigh total fee, etc.\n\nOn Thu, Aug 6, 2020 at 5:59 PM Matt Corallo via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> In general, SIGHASH_NOINPUT makes these issues much, much simpler to\n> address, but only if we assume that nodes can\n> somehow be \"smart\" about replacement when they see a SIGHASH_NOINPUT spend\n> which can spend an output that something else\n> in the mempool already spends (potentially a different input than the\n> relaying node thinks the transaction should\n> spend). While ideally we'd be able to shove that (significant) complexity\n> into the Bitcoin P2P network, that may not be\n> feasible, but we could imagine a relay network of lightning nodes doing\n> that calculation and then passing the\n> transactions to their local full nodes.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200807/79ab9202/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-11T00:14:29",
                "message_text_only": "I was assuming, largely, that Bitcoin Core will eventually get what you describe here (which is generally termed \n\"package relay\", implying we relay, and process, groups of transactions as one).\n\nWhat we'd need for SIGHASH_ANYPREVOUT is a relay network that isn't just smart about fee calculation, but can actually \nrewrite the transactions themselves before passing them on to a local bitcoind.\n\neg such a network would need to be able to relay\n\"I have transaction A, with one input, which is valid for any output-idx-0 in a transaction spending output B\".\nand then have the receiver go look up which transaction in its mempool/chain spends output B, then fill in the input \nwith that outpoint and hand the now-fully-formed transaction to their local bitcoind for processing.\n\nMatt\n\nOn 8/7/20 11:34 AM, Richard Myers wrote:\n> When you say that a special relay network might be more \"smart about replacement\" in the context of ANYPREVOUT*, do you \n> mean these nodes could RBF parts of a package like this:\n> \n> \n> Given:\n>  \u00a0- Package A = UpdateTx_A(n=1): txin: AnchorTx, txout: SettlementTx_A(n=1) -> HtlcTxs(n=1)_A -> .chain of\u00a0 transactions \n> that pin UpdateTx_A(n=1) with high total fee, etc.\n> \n> \n> And a new package with higher fee rate versions of ANYPREVOUT* transactions in the package, but otherwise lower total fee:\n> \n>  \u00a0- Package B = UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1) ->\u00a0HtlcTxs(n=1)_B -> low total fee package\n> \n> \n> Relay just\u00a0the higher up-front fee-rate transactions from package B which get spent by the high absolute fee child \n> transactions from package A:\n> \n>  \u00a0- Package A' =\u00a0UpdateTx_B(n=1): txin: AnchorTx, txout: SettlementTx_B(n=1) -> HtlcTxs(n=1)_A -> ...chain of up to 25 \n> txs that pin UpdateTx(n=1) with high total fee, etc.\n> \n> On Thu, Aug 6, 2020 at 5:59 PM Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org \n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     In general, SIGHASH_NOINPUT makes these issues much, much simpler to address, but only if we assume that nodes can\n>     somehow be \"smart\" about replacement when they see a SIGHASH_NOINPUT spend which can spend an output that something else\n>     in the mempool already spends (potentially a different input than the relaying node thinks the transaction should\n>     spend). While ideally we'd be able to shove that (significant) complexity into the Bitcoin P2P network, that may not be\n>     feasible, but we could imagine a relay network of lightning nodes doing that calculation and then passing the\n>     transactions to their local full nodes. \n> \n>"
            }
        ],
        "thread_summary": {
            "title": "BIP 118 and SIGHASH_ANYPREVOUT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "lf-lists at mattcorallo.com",
                "Matt Corallo",
                "Richard Myers",
                "Christian Decker"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 33578
        }
    },
    {
        "title": "[bitcoin-dev] On the compatibility of Bech32 and Shamir's Secret Sharing",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2020-08-03T22:49:10",
                "message_text_only": "With the help of Pieter I've recently made some interesting mathematical\nobservations about Bech32 codewords and Shamir's secret sharing:\n\n(1) Affine combinations of two Bech32 codewords is again a valid Bech32\ncodeword.\n(2) Lagrange polynomials form a partition of unity.\n\nThe consequences of these facts is that when you perform Shamir's secret\nsharing where all your shares have valid Bech32 checksums, then the\nresulting secret will also have a valid Bech32 checksum.  Conversely, if\nyour secret has a valid Bech32 checksum, and your random shares have valid\nBech32 checksums, then all your derived shares will have valid Bech32\nchecksums.  This can form a basis on which we can build a simple secret\nsharing scheme for dividing up a BIP-32 master seed.\n\nIn order to illustrate this, I'll describe an example scheme for *k*-of-*n*\nShamir's secret sharing scheme where *2 <= k* <= *n* <= 31.\n\nSuppose we have a 128-bit master seed 0xb6721d937d82f238672de4db91b87d0c.\nWe encode this secret as the following Bech32 codeword: \"\ndonotusesss321s2name00keepmymasterseedunderwraps2n89wr\".  Let's deconstruct\nthis codeword.\n\n\"donotusesss32\": A Bech32 hrp for this example scheme.\n\"1\": The Bech32 separator.\n\"s\": The first data character is the index of this share. Each index is a\nBech32 character.  In this scheme the secret share is always at index \"s\",\nwhich stands for \"secret\".\n\"2\": The second data character is the threshold.  In this example we are\nusing a 2-of-n threshold.  We use the digits 2-9 for thresholds upto 9.  We\nuse Bech32 characters a-y for thresholds from 10 to 31.\n\"name00\": The next 6 characters are an id for this set of shares.  This id\nisn't part of the secret data. It is used to ensure that the shares you are\nreconstructing were generated for the same secret.  This id just needs to\nbe unique for all the secrets that you are dividing up with this scheme.\nThe id can be chosen randomly, sequentially, or even set to the constant\nsuch as \"qqqqqq\" if you do not want to use it for identification.\n\"keepmymasterseedunderwraps\": This is the 128-bit secret master seed\n0xb6721d937d82f238672de4db91b87d0c encoded in Bech32.  The master seed can\nbe a 128-bit, 256-bit or 512-bit value.\n\"2n89wr\" is the Bech32 checksum.\n\nWe will generate shares for a 2-of-3 threshold.  We generate the first\nshare at index \"a\".  In this example we generate \"\ndonotusesss321a2name00q0h5aajczn04g9sh0wtsl2f0y0g3vlkr\".\n\n\"donotusesss32\": The Bech32 hrp for this example scheme.\n\"1\": The Bech32 separator.\n\"a\": The first data character is the index of this share which we have\nchosen to be \"a\".\n\"2\": The second data character is the threshold, which is 2.\n\"name00\": The next 6 characters is the id we chose above for this set of\nshares.\n\"q0h5aajczn04g9sh0wtsl2f0y0\": This is 26 randomly selected bech32 characters\n\"g3vlkr\" is the Bech32 checksum.\n\nWe generated the next two shares at index \"c\" and and index \"d\".  These\nshares are generated using characterwise Lagrange interpolation of the\nsecret share and the above randomly generated share.\nThe resulting shares are \"\ndonotusesss321c2name00chzu58ep57hd9xmaw6zmuyjeau0kq4mr\" and \"\ndonotusesss321d2name00ung8rmkf2snftj57zu45g7z84hzmzk4r\"\n\nNotice that the resulting strings have\n(1) valid checksums;\n(2) have correct indices;\n(3) have the correct threshold values;\n(4) have the correct ids.\n\nThis scheme still enjoys the perfect information hiding property of\nShamir's secret sharing.  Even when you know *k*-1 shares, every possible\nmaster seed value has exactly one set of shares that includes those\nparticular *k*-1 shares, so knowing *k*-1 shares tells you nothing about\nthe secret data value.\n\nOne nice property of Lagrange interpolation is that it is simple enough to\ncompute by hand with the help of a few lookup tables.  Bech32 checksums can\nalso be computed and checked by hand with the help of lookup tables.  While\nthe majority of users wouldn't do hand computations, those motivated users\nwho have a healthy distrust of digital devices can generate and manipulate\nthe secret shares by hand.  The Bech32 checksum property means that after\ngenerating the shares by hand, you can then validate the checksums by hand.\nWith extremely high probability, you will catch any computation error you\nmake.  My SSS32 repository at https://github.com/roconnor-blockstream/SSS32\nhas a postscript file that generates the lookup tables needed for hand\ncomputation, although the document is a bit disorganized at the moment.\n\nThe main deficiency of the scheme presented here is that we want a longer\nchecksum than used in BIP-173 that is more suitable for error correction,\nrather than simply error detection.\n\nThis example scheme was inspired in part by SLIP-32\n<https://github.com/satoshilabs/slips/blob/master/slip-0032.md> with the\nintent to be a hand computable version of the same idea.\n\nP.S. It is possible that this all could be made obsolete by a threshold\nmusig signature scheme.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200803/67e64b4d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "On the compatibility of Bech32 and Shamir's Secret Sharing",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5117
        }
    },
    {
        "title": "[bitcoin-dev] Detailed protocol design for routed multi-transaction CoinSwap",
        "thread_messages": [
            {
                "author": "Chris Belcher",
                "date": "2020-08-11T12:05:57",
                "message_text_only": "I'm currently working on implementing CoinSwap (see my other email\n\"Design for a CoinSwap implementation for massively improving Bitcoin\nprivacy and fungibility\").\n\nCoinSwaps are special because they look just like regular bitcoin\ntransactions, so they improve the privacy even for people who do not use\nthem. Once CoinSwap is deployed, anyone attempting surveillance of\nbitcoin transactions will be forced to ask themselves the question: how\ndo we know this transaction wasn't a CoinSwap?\n\nThis email contains a detailed design of the first protocol version. It\nmakes use of the building blocks of multi-transaction CoinSwaps, routed\nCoinSwaps, liquidity market, private key handover, and fidelity bonds.\nIt does not include PayJoin-with-CoinSwap, but that's in the plan to be\nadded later.\n\n== Routed CoinSwap ==\n\nDiagram of CoinSwaps in the route:\n\n    Alice ====> Bob ====> Charlie ====> Alice\n\nWhere (====>) means one CoinSwap. Alice gives coins to Bob, who gives\ncoins to Charlie, who gives coins to Alice. Alice is the market taker\nand she starts with the hash preimage. She chooses the CoinSwap amount\nand chooses who the makers will be.\n\nThis design has one market taker and two market makers in its route, but\nit can easily be extended to any number of makers.\n\n== Multiple transactions ==\n\nEach single CoinSwap is made up of multiple transactions to avoid amount\ncorrelation\n\n          (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->\n    Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice\n          (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->\n\nThe arrow (--->) represent funding transactions. The money gets paid to\na 2-of-2 multisig but after the CoinSwap protocol and private key\nhandover is done they will be controlled by the next party in the route.\n\nThis example has 6 regular-sized transactions which use approximately\nthe same amount of block space as a single JoinMarket coinjoin with 6\nparties (1 taker, 5 makers). Yet the privacy provided by this one\nCoinSwap would be far far greater. It would not have to be repeated in\nthe way that Equal-Output CoinJoins must be.\n\n== Direct connections to Alice ===\n\nOnly Alice, the taker, knows the entire route, Bob and Charlie just know\ntheir previous and next transactions. Bob and Charlie do not have direct\nconnections with each other, only with Alice.\n\nDiagram of Tor connections:\n\n    Bob      Charlie\n     |       /\n     |      /\n     |     /\n      Alice\n\nWhen Bob and Charlie communicate, they are actually sending and\nreceiving messages via Alice who relays them to Charlie or Bob. This\nhelps hide whether the previous or next counterparty in a CoinSwap route\nis a maker or taker.\n\nThis doesn't have security issues even in the final steps where private\nkeys are handed over, because those private keys are always for 2-of-2\nmultisig and so on their own are never enough to steal money.\n\n\n=== Miner fees ===\n\nMakers have no incentive to pay any miner fees. They only do\ntransactions which earn them an income and are willing to wait a very\nlong time for that to happen. By contrast takers want to create\ntransactions far more urgently. In JoinMarket we coded a protocol where\nthe maker could contribute to miner fees, but the market price offered\nof that trended towards zero. So the reality is that takers will pay all\nthe miner fees. Also because makers don't know the taker's time\npreference they don't know how much they should pay in miner fees.\n\nThe taker will have to set limits on how large the maker's transactions\nare, otherwise makers could abuse this by having the taker consolidate\nmaker's UTXOs for free.\n\n== Funding transaction definitions ==\n\nFunding transactions are those which pay into the 2-of-2 multisig addresses.\n\nDefinitions:\nI = initial coinswap amount sent by Alice = a0 + a1 + a2\n(WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie\n               respectively. Could be called \"wallet Alice\", \"wallet\n               Bob\", etc\n(B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.\n(M1, M2, M3) = Miner fees of the first, second, third, etc sets of\n               funding transactions. Alice will choose what these are\n               since she's paying.\nmultisig(A+B) = A 2of2 multisig output with private keys held by A and B\n\nThe value in square parentheses refers to the bitcoin amount.\n\nAlice funding txes\n  [WA btc] ---> multisig (Alice+Bob) [I btc]\n                change [WA-M1-I btc]\nBob funding txes\n  [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]\n                change [WB-I+B btc]\nCharlie funding txes\n  [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]\n                change [WC-(I-M2-B)+C btc]\n\nHere we've drawn these transactions as single transactions, but they are\nactually multiple transactions where the outputs add up some value (e.g.\nadd up to I in Alice's transactions.)\n\n=== Table of balances before and after a successful CoinSwap ===\n\nIf a CoinSwap is successful then all the multisig outputs in the funding\ntransactions will become controlled unilaterally by one party. We can\ncalculate how the balances of each party change.\n\nParty   | Before | After\n--------|--------|-------------------------------------------\nAlice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C\nBob     | WB     | WB-I+B + I               = WB+B\nCharlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C\n\nAfter a successful coinswap, we see Alice's balance goes down by the\nminer fees and the coinswap fees. Bob's and Charlie's balance goes up by\ntheir coinswap fees.\n\n== Contract transaction definitions ==\n\nContract transactions are those which may spend from the 2-of-2 multisig\noutputs, they transfer the coins into a contract where the coins can be\nspent either by waiting for a timeout or providing a hash preimage\nvalue. Ideally contract transactions will never be broadcast but their\nexistence keeps all parties honest.\n\nM~ is miner fees, which we treat as a random variable, and ultimately\nset by whichever pre-signed RBF tx get mined. When we talk about _the_\ncontract tx, we actually mean perhaps 20-30 transactions which only\ndiffer by the miner fee and have RBF enabled, so they can be broadcasted\nin sequence to get the contract transaction mined regardless of the\ndemand for block space.\n\n(Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n                                 either with Alice's private key\n                                 after waiting for a relative\n                                 timelock_A, or by Bob's private key by\n                                 revealing a hash preimage value\n\nAlice contract tx:\n    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n    [I btc]                   [I-M~ btc]\nBob contract tx:\n    multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n    [I-M2-B btc]                [I-M2-B-M~ btc]\nCharlie contract tx:\n    multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)\n    [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]\n\n\n=== Table of balances before/after CoinSwap using contracts transactions ===\n\nIn this case the parties had to get their money back by broadcasting and\nmining the contract transactions and waiting for timeouts.\n\nParty   | Before | After\n--------|--------|--------------------------------------------\nAlice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~\nBob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~\nCharlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~\n\nIn the timeout failure case, every party pays for their own miner fees.\nAnd nobody earns or spends any coinswap fees. So even for a market maker\nits possible for their wallet balance to go down sometimes, although as\nwe shall see there are anti-DOS features which make this unlikely to\nhappen often.\n\nA possible attack by a malicious Alice is that she chooses M1 to be very\nlow (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\nsat/vb) and then intentionally aborts, forcing the makers to lose much\nmore money in miner fees than the attacker. The attack can be used to\nwaste away Bob's and Charlie's coins on miner fees at little cost to the\nmalicious taker Alice. So to defend against this attack Bob and Charlie\nmust refuse to sign a contract transaction if the corresponding funding\ntransaction pays miner fees greater than Alice's funding transaction.\n\n\nThere can also be a failure case where each party gets their money using\nhash preimage values instead of timeouts. Note that each party has to\nsweep the output before the timeout expires, so that will cost an\nadditional miner fee M~.\n\nParty   | Before | After\n--------|--------|------------------------------------------------------\nAlice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~\nBob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~\nCharlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~\n\nIn this situation the makers Bob and Charlie earn their CoinSwap fees,\nbut they pay an additional miner fee twice. Alice pays for all the\nfunding transaction miner fees, and the CoinSwap fees, and two\nadditional miner fees. And she had her privacy damaged because the\nentire world saw on the blockchain the contract script.\n\nUsing the timelock path is like a refund, everyone's coin just comes\nback to them. Using the preimage is like the CoinSwap transaction\nhappened, with the coins being sent ahead one hop. Again note that if\nthe preimage is used then coinswap fees are paid.\n\n=== Staggered timelocks ===\n\nThe timelocks are staggered so that if Alice uses the preimage to take\ncoins then the right people will also learn the preimage and have enough\ntime to be able to get their coins back too. Alice starts with knowledge\nof the hash preimage so she must have a longest timelock.\n\n== EC tweak to reduce one round trip ==\n\nWhen two parties are agreeing on a 2-of-2 multisig address, they need to\nagree on their public keys. We can avoid one round trip by using the EC\ntweak trick.\n\nWhen Alice, the taker, downloads the entire offer book for the liquidity\nmarket, the offers will also contain a EC public key. Alice can tweak\nthis to generate a brand new public key for which the maker knows the\nprivate key. This public key will be one of the keys in the 2-of-2\nmultisig. This feature removes one round trip from the protocol.\n\n    q = EC privkey generated by maker\n    Q = q.G = EC pubkey published by maker\n\n    p = nonce generated by taker\n    P = p.G = nonce point calculated by taker\n\n    R = Q + P = pubkey used in bitcoin transaction\n      = (q + p).G\n\nTaker sends unsigned transaction which pays to multisig using pubkey Q,\nand also sends nonce p. The maker can use nonce p to calculate (q + p)\nwhich is the private key of pubkey R.\n\nTaker doesnt know the privkey because they are unable to find q because\nof the ECDLP.\n\nAny eavesdropper can see the nonce p and easily calculate the point R\ntoo but Tor communication is encrypted so this isnt a concern.\n\nNone of the makers in the route know each other's Q values, so Alice the\ntaker will generate a nonce p on their behalf and send it over. I\nbelieve this cant be used for any kind of attack, because the signing\nmaker will always check that the nonce results in the public key\nincluded in the transaction they're signing, and they'll never sign a\ntransaction not in their interests.\n\n\n== Protocol ==\n\nThis section is the most important part of this document.\n\nDefinitions:\nfund = all funding txes (remember in this multi-tx protocol there can be\n       multiple txes which together make up the funding)\nA htlc = all htlc contract txes (fully signed) belonging to party A\nA unsign htcl = all unsigned htlc contract txes belonging to party A\n                including the nonce point p used to calculate the\n                maker's pubkey.\np = nonce point p used in the tweak EC protocol for calculating the\n    maker's pubkey\nA htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc\n             contract tx\nprivA(A+B) = private key generated by Alice in the output\n             multisig (Alice+Bob)\n\n\n | Alice           | Bob             | Charlie         |\n |=================|=================|=================|\n0. A unsign htlc ---->               |                 |\n1.               <---- A htlc B/2    |                 |\n2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |\n3. A fund+htlc+p ---->               |                 |\n4.                 | B unsign htlc ---->               |\n5.                 |               <---- B htlc C/2    |\n6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |\n7.                 | B fund+htlc+p ---->               |\n8.               <---------------------- C unsign htlc |\n9.    C htlc A/2 ---------------------->               |\nA. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |\nB.               <---------------------- C fund+htlc+p |\nC. hash preimage ---------------------->               |\nD. hash preimage ---->               |                 |\nE.    privA(A+B) ---->               |                 |\nF.                 |    privB(B+C) ---->               |\nG.               <---------------------- privC(C+A)    |\n\n== Protocol notes ==\n0-2 are the steps which setup Alice's funding tx and her contract tx for\n    possible refund\n4-5 same as 0-2 but for Bob\n8-9 same as 0-2 but for Charlie\n3,7 is proof to the next party that the previous party has already\n    committed miner fees to getting a transaction mined, and therefore\n    this isnt a DOS attack. The step also reveals the fully-signed\n    contract transaction which the party can use to get their money back\n    with a preimage.\nC-G is revealing the hash preimage to all, and handing over the private\n    keys\n\n\n== Analysis of aborts ==\n\nWe will now discuss aborts, which happen when one party halts the\nprotocol and doesnt continue. Perhaps they had a power cut, their\ninternet broke, or they're a malicious attacker wanting to waste time\nand money. The other party may try to reestablish a connection for some\ntime, but eventually must give up.\n\nNumber refers to the step number where the abort happened\ne.g. step 1 means that the party aborted instead of the action happening\non protocol step 1.\n\nThe party name refers to what that party does\ne.g. Party1: aborts, Party2/Party3: does a thing in reaction\n\n0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or\n   money\n1. Bob: aborts. Alice: lost no time or money, try with another Bob.\n   Charlie: do nothing\n2-3. same as 0.\n4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx\n   and waits for the timeout, loses time and money on miner fees, she'll\n   never coinswap with Bob's fidelity bond again.\n5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to\n   coinswap with.\n6. same as 4.\n7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,\n   because Bob will also have to broadcast his contract tx and will also\n   lose time and money.\n8. Charlie: aborts. Bob: broadcast his contract transaction and wait for\n   the timeout to get his money back, also broadcast Alice's contract\n   transaction in retaliation. Alice: waits for the timeout on her htlc\n   tx that Bob broadcasted, will never do a coinswap with Charlie's\n   fidelity bond again.\n9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:\n   broadcast bob contract tx and wait for timeout to get money back,\n   comforted by the knowledge that when Alice comes back online she'll\n   have to do the same thing and waste the same amount of time and\n   money.\nA-B. same as 8.\nC-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and\n     wait for the timeout to get their money back, or if Charlie knows\n     the preimage he uses it to get the money immediately, which Bob can\n     read from the blockchain and also use.\nF. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get\n   money immediately, Alice blacklists Bob's fidelity bond. Charlie:\n   broadcast Bob htlc and use preimage to get money immediately.\nG. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to\n   get money immediately, Alice blacklists Charlie's fidelity bond. Bob:\n   does nothing, already has his privkey.\n\n==== Retaliation as DOS-resistance ====\n\nIn some situations (e.g. step 8.) if one maker in the coinswap route is\nthe victim of a DOS they will retaliate by DOSing the previous maker in\nthe route. This may seem unnecessary and unfair (after all why waste\neven more time and block space) but is actually the best way to resist\nDOS because it produces a concrete cost every time a DOS happens.\n\n\n== Analysis of deviations ==\n\nThis section discusses what happens if one party deviates from the\nprotocol by doing something else, for example broadcasting a htlc\ncontract tx when they shouldnt have.\n\nThe party name refers to what that party does, followed by other party's\nreactions to it.\ne.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n\nIf multiple deviations are possible in a step then they are numbered\ne.g. A1 A2 A2 etc\n\n\n0-2. Alice/Bob/Charlie: nothing else is possible except following the\n     protocol or aborting\n3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n   do nothing, they havent lost any time or money.\n4-6. Bob/Charlie: nothing else is possible except following the protocol\n     or aborting.\n7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n   her own A htlc txes and waits for the timeout to get her money back.\n   Charlie: do nothing\n8. Charlie: nothing else is possible except following the protocol or\n   aborting.\n9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n   his own A htlc txes and waits for the timeout.\nA. same as 8.\nB. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n   broadcasts all their own htlc txes and waits for the timeout to get\n   their money back.\nC-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n      preimage hash to take the money immediately. Charlie: broadcasts\n      all of B htlc txes and reading the hash value from the blockchain,\n      uses it to take the money from B htlc immediately. Bob: broadcasts\n      all of A htlc txes, and reading hash from the blockchain, uses it\n      to take the money from A htlc immediately.\nC-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n      money. Bob: broadcast his own B htlc txes and after the timeout\n      take their money. Charlie: broadcast his own C htlc txes and after\n      the timeout take their money.\nF1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n    to get the money immediately. He already knows both privkeys of the\n    multisig so this is pointless and just damages privacy and wastes\n    miner fees. Alice: blacklist Bob's fidelity bond.\nF2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n    to get his money immediately. Bob's actions were pointless. Alice:\n    cant tell whether Bob or Charlie actually broadcasted, so blacklist\n    both fidelity bonds.\nG1. Charlie: broadcast one or more of B htcl txes and use the hash\n    preimage to get the money immediately. He already knows both\n    privkeys of the multisig so this is pointless and just damages\n    privacy and wastes miner fees. Alice: cant tell whether Bob or\n    Charlie actually broadcasted, so blacklist both fidelity bonds.\nG2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n    the remaining A htlc txes and use preimage to get her money\n    immediately. Charlies's actions were pointless. Alice: blacklist\n    Charlie's fidelity bond.\n\nThe multisig outputs of the funding transactions can stay unspent\nindefinitely. However the parties must always be watching the network\nand ready to respond with their own sweep using a preimage. This is\nbecause the other party still possesses a fully-signed contract tx. The\nparties respond in the same way as in steps C-E1, F2 and G2. Alice's\nreaction of blacklisting both fidelity bonds might not be the right way,\nbecause one maker could use it to get another one blacklisted (as well\nas themselves).\n\n\n== Conclusion ==\n\nThis document describes the first version of the protocol which\nimplements multi-transaction Coinswap, routed Coinswap, fidelity bonds,\na liquidity market and private key handover. I describe the protocol and\nalso analyze aborts of the protocols and deviations from the protocol."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-20T11:17:07",
                "message_text_only": "Good morning Chris,\n\nGreat to see this!\n\nMostly minor comments.\n\n\n\n>\n> == Direct connections to Alice ===\n>\n> Only Alice, the taker, knows the entire route, Bob and Charlie just know\n> their previous and next transactions. Bob and Charlie do not have direct\n> connections with each other, only with Alice.\n>\n> Diagram of Tor connections:\n>\n> Bob Charlie\n> | /\n> | /\n> | /\n> Alice\n>\n> When Bob and Charlie communicate, they are actually sending and\n> receiving messages via Alice who relays them to Charlie or Bob. This\n> helps hide whether the previous or next counterparty in a CoinSwap route\n> is a maker or taker.\n>\n> This doesn't have security issues even in the final steps where private\n> keys are handed over, because those private keys are always for 2-of-2\n> multisig and so on their own are never enough to steal money.\n\nThis has a massive advantage over CoinJoin.\n\nIn CoinJoin, since all participants sign a single transaction, every participant knows the total number of participants.\nThus, in CoinJoin, it is fairly useless to have just one taker and one maker, the maker knows exactly which output belongs to the taker.\nEven if all communications were done via the single paying taker, the maker(s) are shown the final transaction and thus can easily know how many participants there are (by counting the number of equal-valued outputs).\n\nWith CoinSwap, in principle no maker has to know how many other makers are in the swap.\n\nThus it would still be useful to make a single-maker CoinSwap, as that would be difficult, for the maker, to diferentiate from a multi-maker CoinSwap.\n\nThere are still a few potential leaks though:\n\n* If paying through a CoinSwap, the cheapest option for the taker would be to send out a single large UTXO (single-output txes) to the first maker, and then demand the final payment and any change as two separate swaps from the final maker.\n  * Intermediate makers are likely to not have exact amounts, thus is unlikely to create a single-output tx when forwarding.\n  * Thus, the first maker could identify the taker.\n* The makers can try timing the communications lag with the taker.\n  The general assumption would be that more makers == more delay in taker responses.\n\n\n\n>\n> === Miner fees ===\n>\n> Makers have no incentive to pay any miner fees. They only do\n> transactions which earn them an income and are willing to wait a very\n> long time for that to happen. By contrast takers want to create\n> transactions far more urgently. In JoinMarket we coded a protocol where\n> the maker could contribute to miner fees, but the market price offered\n> of that trended towards zero. So the reality is that takers will pay all\n> the miner fees. Also because makers don't know the taker's time\n> preference they don't know how much they should pay in miner fees.\n>\n> The taker will have to set limits on how large the maker's transactions\n> are, otherwise makers could abuse this by having the taker consolidate\n> maker's UTXOs for free.\n\nWhy not have the taker pay for the *first* maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?\ni.e. the taker indicates \"swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC\", and pays for one UTXO spent for each \"bag\" (thus pays for 3 UTXOs).\n\nDisagreements on feerate can be resolved by having the taker set the feerate, i.e. \"the customer is always right\".\nThus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.\nThe maker can always reject the swap attempt if it *has to* spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.\n\n\n> == Contract transaction definitions ==\n>\n> Contract transactions are those which may spend from the 2-of-2 multisig\n> outputs, they transfer the coins into a contract where the coins can be\n> spent either by waiting for a timeout or providing a hash preimage\n> value. Ideally contract transactions will never be broadcast but their\n> existence keeps all parties honest.\n>\n> M~ is miner fees, which we treat as a random variable, and ultimately\n> set by whichever pre-signed RBF tx get mined. When we talk about the\n> contract tx, we actually mean perhaps 20-30 transactions which only\n> differ by the miner fee and have RBF enabled, so they can be broadcasted\n> in sequence to get the contract transaction mined regardless of the\n> demand for block space.\n\nThe highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.\n\nOr not.\nHmm.\n\n\nAnother thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?\n\n>\n> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n> either with Alice's private key\n> after waiting for a relative\n> timelock_A, or by Bob's private key by\n> revealing a hash preimage value\n\nThe rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.\nThis is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.\n\nThe dangers are:\n\n* Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).\n* After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.\n* It is possible to steal from a participant if that participant goes offline longer than the timeout.\n  This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.\n  * The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.\n    * This appears to be riskless for the taker.\n    * Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.\n  * On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.\n    * But the taker can just try on the hope it works; it has nothing to lose.\n  * This attack seems to be possible only for the taker to mount.\n    Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.\n    * On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.\n  * Participants might want to spend from the UTXO to a new address after private key turnover anyway.\n    Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.\n\n\n> A possible attack by a malicious Alice is that she chooses M1 to be very\n> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n> sat/vb) and then intentionally aborts, forcing the makers to lose much\n> more money in miner fees than the attacker. The attack can be used to\n> waste away Bob's and Charlie's coins on miner fees at little cost to the\n> malicious taker Alice. So to defend against this attack Bob and Charlie\n> must refuse to sign a contract transaction if the corresponding funding\n> transaction pays miner fees greater than Alice's funding transaction.\n\nSorry, I do not follow the logic for this...?\n\n> The timelocks are staggered so that if Alice uses the preimage to take\n> coins then the right people will also learn the preimage and have enough\n> time to be able to get their coins back too. Alice starts with knowledge\n> of the hash preimage so she must have a longest timelock.\n\nMore precisely:\n\n* The HTLC outgoing from Alice has the longest timelock.\n* The HTLC incoming into Alice has the shortest timelock.\n\nFor the makers, they only need to ensure that the incoming timelock is much larger than the outgoing timelock.\n\n\n>\n> == EC tweak to reduce one round trip ==\n>\n> When two parties are agreeing on a 2-of-2 multisig address, they need to\n> agree on their public keys. We can avoid one round trip by using the EC\n> tweak trick.\n>\n> When Alice, the taker, downloads the entire offer book for the liquidity\n> market, the offers will also contain a EC public key. Alice can tweak\n> this to generate a brand new public key for which the maker knows the\n> private key. This public key will be one of the keys in the 2-of-2\n> multisig. This feature removes one round trip from the protocol.\n>\n> q = EC privkey generated by maker\n> Q = q.G = EC pubkey published by maker\n>\n> p = nonce generated by taker\n> P = p.G = nonce point calculated by taker\n>\n> R = Q + P = pubkey used in bitcoin transaction\n> = (q + p).G\n\nWhoa whoa whoa whoa.\n\nAll this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.\nIn which case, the private key generated by the taker would be sufficient tweak to blind this.\n\nIn 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.\n\nAre you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?\nNote that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.\n\n>\n> == Protocol ==\n\n> ---8<------\n\nThe protocol looks correct to me.\n\nLOL.\n\nGive me a little more time to check it in detail hahaha.\n\n\n\n>     ==== Retaliation as DOS-resistance ====\n>\n>     In some situations (e.g. step 8.) if one maker in the coinswap route is\n>     the victim of a DOS they will retaliate by DOSing the previous maker in\n>     the route. This may seem unnecessary and unfair (after all why waste\n>     even more time and block space) but is actually the best way to resist\n>     DOS because it produces a concrete cost every time a DOS happens.\n\nI agree.\n\n>\n>     == Analysis of deviations ==\n>\n>     This section discusses what happens if one party deviates from the\n>     protocol by doing something else, for example broadcasting a htlc\n>     contract tx when they shouldnt have.\n>\n>     The party name refers to what that party does, followed by other party's\n>     reactions to it.\n>     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n>\n>     If multiple deviations are possible in a step then they are numbered\n>     e.g. A1 A2 A2 etc\n>\n>     0-2. Alice/Bob/Charlie: nothing else is possible except following the\n>     protocol or aborting\n>\n> 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n>     do nothing, they havent lost any time or money.\n>     4-6. Bob/Charlie: nothing else is possible except following the protocol\n>     or aborting.\n>\n> 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n>     her own A htlc txes and waits for the timeout to get her money back.\n>     Charlie: do nothing\n>\n> 10.  Charlie: nothing else is possible except following the protocol or\n>     aborting.\n>\n> 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n>     his own A htlc txes and waits for the timeout.\n>     A. same as 8.\n>     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n>     broadcasts all their own htlc txes and waits for the timeout to get\n>     their money back.\n>     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n>     preimage hash to take the money immediately. Charlie: broadcasts\n>     all of B htlc txes and reading the hash value from the blockchain,\n>     uses it to take the money from B htlc immediately. Bob: broadcasts\n>     all of A htlc txes, and reading hash from the blockchain, uses it\n>     to take the money from A htlc immediately.\n>     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n>     money. Bob: broadcast his own B htlc txes and after the timeout\n>     take their money. Charlie: broadcast his own C htlc txes and after\n>     the timeout take their money.\n>     F1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n>     to get the money immediately. He already knows both privkeys of the\n>     multisig so this is pointless and just damages privacy and wastes\n>     miner fees. Alice: blacklist Bob's fidelity bond.\n>     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n>     to get his money immediately. Bob's actions were pointless. Alice:\n>     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n>     both fidelity bonds.\n>     G1. Charlie: broadcast one or more of B htcl txes and use the hash\n>     preimage to get the money immediately. He already knows both\n>     privkeys of the multisig so this is pointless and just damages\n>     privacy and wastes miner fees. Alice: cant tell whether Bob or\n>     Charlie actually broadcasted, so blacklist both fidelity bonds.\n>     G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n>     the remaining A htlc txes and use preimage to get her money\n>     immediately. Charlies's actions were pointless. Alice: blacklist\n>     Charlie's fidelity bond.\n>\n>     The multisig outputs of the funding transactions can stay unspent\n>     indefinitely. However the parties must always be watching the network\n>     and ready to respond with their own sweep using a preimage. This is\n>     because the other party still possesses a fully-signed contract tx. The\n>     parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n>     reaction of blacklisting both fidelity bonds might not be the right way,\n>     because one maker could use it to get another one blacklisted (as well\n>     as themselves).\n\nLooks OK, though note that a participant might try to do so (as pointed out above) in the hope that the next participant is offline.\n\nThank you very much for your writeup!\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-08-20T15:28:56",
                "message_text_only": "Hey Chris and all,\n\nLooking good :) I have one major concern though\n\n>    q = EC privkey generated by maker\n>    Q = q.G = EC pubkey published by maker\n>\n>    p = nonce generated by taker\n>    P = p.G = nonce point calculated by taker\n>\n>    R = Q + P = pubkey used in bitcoin transaction\n>      = (q + p).G\n\nIf I'm understanding this correctly (which I'm not sure I ame), it seems\nlike the plan is to put R on-chain as the key to an output? As stated this\nis completely insecure as Q is known in advance so the taker can always\nchoose a nonce p but then claim that their nonce point is p.G - Q so that\nthe key that goes on-chain is (p.G - Q + Q) = p.G allowing them to steal\nthe funds. If the plan is not to use full-fledged 2-ECDSA (which I think is\nactually necessary as I still don't understand how the HTLC signatures are\ngenerated) you have to, at the very least, force the taker to provide a\nZero Knowledge Proof of Knowledge (ZKPoK) of the discrete log to the point\nthey advertise as their nonce point to avoid this. Alternatively, I think\nyou can use the following key as is done in MuSig:\n\nR = H(Q || P || Q)*Q + H(Q || P || P)*P\n\nBut I still don't see how signatures can be generated for HTLCs from this\nkey.\n\nOf course all of this complexity more or less goes away once we have\nSchnorr signatures and can use MuSig with adaptor signatures.\n\nBest,\nNadav\n\nOn Thu, Aug 20, 2020 at 6:17 AM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Chris,\n>\n> Great to see this!\n>\n> Mostly minor comments.\n>\n>\n>\n> >\n> > == Direct connections to Alice ===\n> >\n> > Only Alice, the taker, knows the entire route, Bob and Charlie just know\n> > their previous and next transactions. Bob and Charlie do not have direct\n> > connections with each other, only with Alice.\n> >\n> > Diagram of Tor connections:\n> >\n> > Bob Charlie\n> > | /\n> > | /\n> > | /\n> > Alice\n> >\n> > When Bob and Charlie communicate, they are actually sending and\n> > receiving messages via Alice who relays them to Charlie or Bob. This\n> > helps hide whether the previous or next counterparty in a CoinSwap route\n> > is a maker or taker.\n> >\n> > This doesn't have security issues even in the final steps where private\n> > keys are handed over, because those private keys are always for 2-of-2\n> > multisig and so on their own are never enough to steal money.\n>\n> This has a massive advantage over CoinJoin.\n>\n> In CoinJoin, since all participants sign a single transaction, every\n> participant knows the total number of participants.\n> Thus, in CoinJoin, it is fairly useless to have just one taker and one\n> maker, the maker knows exactly which output belongs to the taker.\n> Even if all communications were done via the single paying taker, the\n> maker(s) are shown the final transaction and thus can easily know how many\n> participants there are (by counting the number of equal-valued outputs).\n>\n> With CoinSwap, in principle no maker has to know how many other makers are\n> in the swap.\n>\n> Thus it would still be useful to make a single-maker CoinSwap, as that\n> would be difficult, for the maker, to diferentiate from a multi-maker\n> CoinSwap.\n>\n> There are still a few potential leaks though:\n>\n> * If paying through a CoinSwap, the cheapest option for the taker would be\n> to send out a single large UTXO (single-output txes) to the first maker,\n> and then demand the final payment and any change as two separate swaps from\n> the final maker.\n>   * Intermediate makers are likely to not have exact amounts, thus is\n> unlikely to create a single-output tx when forwarding.\n>   * Thus, the first maker could identify the taker.\n> * The makers can try timing the communications lag with the taker.\n>   The general assumption would be that more makers == more delay in taker\n> responses.\n>\n>\n>\n> >\n> > === Miner fees ===\n> >\n> > Makers have no incentive to pay any miner fees. They only do\n> > transactions which earn them an income and are willing to wait a very\n> > long time for that to happen. By contrast takers want to create\n> > transactions far more urgently. In JoinMarket we coded a protocol where\n> > the maker could contribute to miner fees, but the market price offered\n> > of that trended towards zero. So the reality is that takers will pay all\n> > the miner fees. Also because makers don't know the taker's time\n> > preference they don't know how much they should pay in miner fees.\n> >\n> > The taker will have to set limits on how large the maker's transactions\n> > are, otherwise makers could abuse this by having the taker consolidate\n> > maker's UTXOs for free.\n>\n> Why not have the taker pay for the *first* maker-spent UTXO and have\n> additional maker-spent UTXOs paid for by the maker?\n> i.e. the taker indicates \"swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4\n> BTC\", and pays for one UTXO spent for each \"bag\" (thus pays for 3 UTXOs).\n>\n> Disagreements on feerate can be resolved by having the taker set the\n> feerate, i.e. \"the customer is always right\".\n> Thus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it\n> pays for the mining fees for that extra UTXO.\n> The maker can always reject the swap attempt if it *has to* spend multiple\n> UTXOs and would lose money doing so if the taker demands a too-high feerate.\n>\n>\n> > == Contract transaction definitions ==\n> >\n> > Contract transactions are those which may spend from the 2-of-2 multisig\n> > outputs, they transfer the coins into a contract where the coins can be\n> > spent either by waiting for a timeout or providing a hash preimage\n> > value. Ideally contract transactions will never be broadcast but their\n> > existence keeps all parties honest.\n> >\n> > M~ is miner fees, which we treat as a random variable, and ultimately\n> > set by whichever pre-signed RBF tx get mined. When we talk about the\n> > contract tx, we actually mean perhaps 20-30 transactions which only\n> > differ by the miner fee and have RBF enabled, so they can be broadcasted\n> > in sequence to get the contract transaction mined regardless of the\n> > demand for block space.\n>\n> The highest-fee version could have, in addition, CPFP-anchor outputs, like\n> those being proposed in Lightning, so even if onchain fees rise above the\n> largest fee reservation, it is possible to add even more fees.\n>\n> Or not.\n> Hmm.\n>\n>\n> Another thought: later you describe that miner fees are paid by Alice by\n> forwarding those fees as well, how does that work when there are multiple\n> versions of the contract transaction?\n>\n> >\n> > (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n> > either with Alice's private key\n> > after waiting for a relative\n> > timelock_A, or by Bob's private key by\n> > revealing a hash preimage value\n>\n> The rationale for relative timelocks is that it makes private key turnover\n> slightly more useable by ensuring that, after private key turnover, it is\n> possible to wait indefinitely to spend the UTXO it received.\n> This is in contrast with absolute timelocks, where after private key\n> turnover, it is required to spend received UTXO before the absolute timeout.\n>\n> The dangers are:\n>\n> * Until it receives the private key, if either of the incoming or outgoing\n> contract transactions are confirmed, every swap participant (taker or\n> maker) should also broadcast the other contract transaction, and resolve by\n> onchain transactions (with loss of privacy).\n> * After receiving the private key, if the incoming contract transaction is\n> confirmed, it should spend the resulting contract output.\n> * It is possible to steal from a participant if that participant goes\n> offline longer than the timeout.\n>   This may imply that there may have to be some minimum timeout that\n> makers indicate in their advertisements.\n>   * The taker can detect if the first maker is offline, then if it is\n> offline, try a contract transaction broadcast, if it confirms, the taker\n> can wait for the timeout; if it times out, the taker can clawback the\n> transaction.\n>     * This appears to be riskless for the taker.\n>     * Against a similar attack, Lightning requires channel reserves, which\n> means the first hop never gains control of the entire value, which is a\n> basic requirement for private key turnover.\n>   * On the other hand, the taker has the largest timeout before it can\n> clawback the funds, so it would wait for a long time, and at any time in\n> between the first maker can come online and spend using the hashlock branch.\n>     * But the taker can just try on the hope it works; it has nothing to\n> lose.\n>   * This attack seems to be possible only for the taker to mount.\n>     Other makers on the route cannot know who the other makers are,\n> without cooperation of the taker, who is the only one who knows all the\n> makers.\n>     * On the other hand, the last maker in the route has an outgoing HTLC\n> with the smallest timelock, so it is the least-risk and therefore a maker\n> who notices its outgoing HTLC has a low timeout might want to just do this\n> anyway even if it is unsure if the taker is offline.\n>   * Participants might want to spend from the UTXO to a new address after\n> private key turnover anyway.\n>     Makers could spend using a low-fee RBF-enabled tx, and when another\n> request comes in for another swap, try to build a new funding tx with a\n> higher-fee bump.\n>\n>\n> > A possible attack by a malicious Alice is that she chooses M1 to be very\n> > low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n> > sat/vb) and then intentionally aborts, forcing the makers to lose much\n> > more money in miner fees than the attacker. The attack can be used to\n> > waste away Bob's and Charlie's coins on miner fees at little cost to the\n> > malicious taker Alice. So to defend against this attack Bob and Charlie\n> > must refuse to sign a contract transaction if the corresponding funding\n> > transaction pays miner fees greater than Alice's funding transaction.\n>\n> Sorry, I do not follow the logic for this...?\n>\n> > The timelocks are staggered so that if Alice uses the preimage to take\n> > coins then the right people will also learn the preimage and have enough\n> > time to be able to get their coins back too. Alice starts with knowledge\n> > of the hash preimage so she must have a longest timelock.\n>\n> More precisely:\n>\n> * The HTLC outgoing from Alice has the longest timelock.\n> * The HTLC incoming into Alice has the shortest timelock.\n>\n> For the makers, they only need to ensure that the incoming timelock is\n> much larger than the outgoing timelock.\n>\n>\n> >\n> > == EC tweak to reduce one round trip ==\n> >\n> > When two parties are agreeing on a 2-of-2 multisig address, they need to\n> > agree on their public keys. We can avoid one round trip by using the EC\n> > tweak trick.\n> >\n> > When Alice, the taker, downloads the entire offer book for the liquidity\n> > market, the offers will also contain a EC public key. Alice can tweak\n> > this to generate a brand new public key for which the maker knows the\n> > private key. This public key will be one of the keys in the 2-of-2\n> > multisig. This feature removes one round trip from the protocol.\n> >\n> > q = EC privkey generated by maker\n> > Q = q.G = EC pubkey published by maker\n> >\n> > p = nonce generated by taker\n> > P = p.G = nonce point calculated by taker\n> >\n> > R = Q + P = pubkey used in bitcoin transaction\n> > = (q + p).G\n>\n> Whoa whoa whoa whoa.\n>\n> All this time I was thinking you were going to use 2p-ECDSA for all\n> 2-of-2s.\n> In which case, the private key generated by the taker would be sufficient\n> tweak to blind this.\n>\n> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m\n> * t * G = m * T = t * M.\n>\n> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?\n> Note that you cannot usefully hide among Lightning mutual closes, because\n> of the reserve; Lightning mutual closes are very very likely to be spent in\n> a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two\n> P2WPKHs) tx.\n>\n> >\n> > == Protocol ==\n>\n> > ---8<------\n>\n> The protocol looks correct to me.\n>\n> LOL.\n>\n> Give me a little more time to check it in detail hahaha.\n>\n>\n>\n> >     ==== Retaliation as DOS-resistance ====\n> >\n> >     In some situations (e.g. step 8.) if one maker in the coinswap route\n> is\n> >     the victim of a DOS they will retaliate by DOSing the previous maker\n> in\n> >     the route. This may seem unnecessary and unfair (after all why waste\n> >     even more time and block space) but is actually the best way to\n> resist\n> >     DOS because it produces a concrete cost every time a DOS happens.\n>\n> I agree.\n>\n> >\n> >     == Analysis of deviations ==\n> >\n> >     This section discusses what happens if one party deviates from the\n> >     protocol by doing something else, for example broadcasting a htlc\n> >     contract tx when they shouldnt have.\n> >\n> >     The party name refers to what that party does, followed by other\n> party's\n> >     reactions to it.\n> >     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n> >\n> >     If multiple deviations are possible in a step then they are numbered\n> >     e.g. A1 A2 A2 etc\n> >\n> >     0-2. Alice/Bob/Charlie: nothing else is possible except following the\n> >     protocol or aborting\n> >\n> > 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n> >     do nothing, they havent lost any time or money.\n> >     4-6. Bob/Charlie: nothing else is possible except following the\n> protocol\n> >     or aborting.\n> >\n> > 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n> >     her own A htlc txes and waits for the timeout to get her money back.\n> >     Charlie: do nothing\n> >\n> > 10.  Charlie: nothing else is possible except following the protocol or\n> >     aborting.\n> >\n> > 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts\n> all\n> >     his own A htlc txes and waits for the timeout.\n> >     A. same as 8.\n> >     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n> >     broadcasts all their own htlc txes and waits for the timeout to get\n> >     their money back.\n> >     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of\n> the\n> >     preimage hash to take the money immediately. Charlie: broadcasts\n> >     all of B htlc txes and reading the hash value from the blockchain,\n> >     uses it to take the money from B htlc immediately. Bob: broadcasts\n> >     all of A htlc txes, and reading hash from the blockchain, uses it\n> >     to take the money from A htlc immediately.\n> >     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take\n> the\n> >     money. Bob: broadcast his own B htlc txes and after the timeout\n> >     take their money. Charlie: broadcast his own C htlc txes and after\n> >     the timeout take their money.\n> >     F1. Bob: broadcast one or more of A htcl txes and use the hash\n> preimage\n> >     to get the money immediately. He already knows both privkeys of the\n> >     multisig so this is pointless and just damages privacy and wastes\n> >     miner fees. Alice: blacklist Bob's fidelity bond.\n> >     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use\n> preimage\n> >     to get his money immediately. Bob's actions were pointless. Alice:\n> >     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n> >     both fidelity bonds.\n> >     G1. Charlie: broadcast one or more of B htcl txes and use the hash\n> >     preimage to get the money immediately. He already knows both\n> >     privkeys of the multisig so this is pointless and just damages\n> >     privacy and wastes miner fees. Alice: cant tell whether Bob or\n> >     Charlie actually broadcasted, so blacklist both fidelity bonds.\n> >     G2. Charlie: broadcast one or more of the A htlc txes. Alice:\n> broadcast\n> >     the remaining A htlc txes and use preimage to get her money\n> >     immediately. Charlies's actions were pointless. Alice: blacklist\n> >     Charlie's fidelity bond.\n> >\n> >     The multisig outputs of the funding transactions can stay unspent\n> >     indefinitely. However the parties must always be watching the network\n> >     and ready to respond with their own sweep using a preimage. This is\n> >     because the other party still possesses a fully-signed contract tx.\n> The\n> >     parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n> >     reaction of blacklisting both fidelity bonds might not be the right\n> way,\n> >     because one maker could use it to get another one blacklisted (as\n> well\n> >     as themselves).\n>\n> Looks OK, though note that a participant might try to do so (as pointed\n> out above) in the hope that the next participant is offline.\n>\n> Thank you very much for your writeup!\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200820/d782e2d1/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-20T21:38:16",
                "message_text_only": "Good morning Nadav,\n\n> Hey Chris and all,\n>\n> Looking good :) I have one major concern though\n>\n> >\u00a0 \u00a0 q = EC privkey generated by maker\n> >\u00a0 \u00a0 Q = q.G = EC pubkey published by maker\n> >\n> >\u00a0 \u00a0 p = nonce generated by taker\n> >\u00a0 \u00a0 P = p.G = nonce point calculated by taker\n> >\n> >\u00a0 \u00a0 R = Q + P = pubkey used in bitcoin transaction\n> >\u00a0 \u00a0 \u00a0 = (q + p).G\n>\n> If I'm understanding this correctly (which I'm not sure I ame), it seems like the plan is to put R on-chain as the key to an output? As stated this is completely\u00a0insecure as Q is known in advance so the taker can always choose a nonce p but then claim that their nonce point is p.G - Q so that the key that goes on-chain is (p.G - Q\u00a0+ Q) = p.G allowing them to steal the funds.\n\nMy reading from this is that nonce `p` has to be given by the taker to the maker outright.\nIn original post:\n\n> Taker sends unsigned transaction which pays to multisig using pubkey Q,\n> and also sends nonce p.\n\nThus, taker provides a proof-of-knowledge, i.e. the actual `p` scalar itself (not zero-knowledge, but what the maker needs is proof-of-knowledge, and could not care less if the proof is zero-knowledge or not).\n\nOn the other hand, I do not see the point of this tweak if you are going to use 2p-ECDSA, since my knowledge is that 2p-ECDSA uses the pubkey that is homomorphic to the product of the private keys.\nAnd that pubkey is already tweaked, by the fresh privkey of the maker (and the maker is buying privacy and wants security of the swap, so is incentivized to generate high-entropy temporary privkeys for the actual swap operation).\n\nNot using 2p-ECDSA of some kind would remove most of the privacy advantages of CoinSwap.\nYou cannot hide among `2 <A> <B> 2 OP_CHECKMULTISIG` scripts of Lightning, because:\n\n* Lightning channel closes tend to be weeks at least after the funding outpoint creation, whereas CoinSwap envisions hours or days.\n* Lightning mutual channel closes have a very high probability of spending to two P2WPKH addresses.\n\nYou need to hide among the much larger singlesig anonymity set, which means using a single signature (created multiparty by both participants), not two signatures (one from each participant).\n\nOr is this intended for HTLCs in open-coded SCRIPTs `OP_DUP OP_IF OP_HASH160 <hash> OP_EQUAL <A> OP_ELSE <time> OP_CHECKSEQUENCEVERIFY OP_DROP <B> OP_ENDIF OP_CHECKSIG`?\nThis provides a slight privacy boost in a case (contract transaction publication) where most of the privacy is lost anyway.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-08-20T22:37:35",
                "message_text_only": "Hello Nadav and ZmnSCPxj,\n\nOn 20/08/2020 22:38, ZmnSCPxj wrote:\n> Good morning Nadav,\n> \n>> Hey Chris and all,\n>>\n>> Looking good :) I have one major concern though\n>>\n>>> \u00a0 \u00a0 q = EC privkey generated by maker\n>>> \u00a0 \u00a0 Q = q.G = EC pubkey published by maker\n>>>\n>>> \u00a0 \u00a0 p = nonce generated by taker\n>>> \u00a0 \u00a0 P = p.G = nonce point calculated by taker\n>>>\n>>> \u00a0 \u00a0 R = Q + P = pubkey used in bitcoin transaction\n>>> \u00a0 \u00a0 \u00a0 = (q + p).G\n>>\n>> If I'm understanding this correctly (which I'm not sure I ame), it seems like the plan is to put R on-chain as the key to an output? As stated this is completely\u00a0insecure as Q is known in advance so the taker can always choose a nonce p but then claim that their nonce point is p.G - Q so that the key that goes on-chain is (p.G - Q\u00a0+ Q) = p.G allowing them to steal the funds.\n> \n> My reading from this is that nonce `p` has to be given by the taker to the maker outright.\n> In original post:\n> \n>> Taker sends unsigned transaction which pays to multisig using pubkey Q,\n>> and also sends nonce p.\n> \n> Thus, taker provides a proof-of-knowledge, i.e. the actual `p` scalar itself (not zero-knowledge, but what the maker needs is proof-of-knowledge, and could not care less if the proof is zero-knowledge or not).\n\nYes this looks right. In hindsight my text could be clarified by\nchanging the relevant lines to:\n\n    p = nonce generated by taker, sent to maker\n    P = p.G = nonce point calculated by taker\n\n    R = Q + P = pubkey used in bitcoin transaction, calculated by taker\n      = (q + p).G = same pubkey, calculated by maker\n\n\nI don't think the key subtraction attack described by Nadav will work\nhere...?\n\n\n> On the other hand, I do not see the point of this tweak if you are going to use 2p-ECDSA, since my knowledge is that 2p-ECDSA uses the pubkey that is homomorphic to the product of the private keys.\n> And that pubkey is already tweaked, by the fresh privkey of the maker (and the maker is buying privacy and wants security of the swap, so is incentivized to generate high-entropy temporary privkeys for the actual swap operation).\n> \n> Not using 2p-ECDSA of some kind would remove most of the privacy advantages of CoinSwap.\n> You cannot hide among `2 <A> <B> 2 OP_CHECKMULTISIG` scripts of Lightning, because:\n> \n> * Lightning channel closes tend to be weeks at least after the funding outpoint creation, whereas CoinSwap envisions hours or days.\n> * Lightning mutual channel closes have a very high probability of spending to two P2WPKH addresses.\n> \n> You need to hide among the much larger singlesig anonymity set, which means using a single signature (created multiparty by both participants), not two signatures (one from each participant).\n> \n> Or is this intended for HTLCs in open-coded SCRIPTs `OP_DUP OP_IF OP_HASH160 <hash> OP_EQUAL <A> OP_ELSE <time> OP_CHECKSEQUENCEVERIFY OP_DROP <B> OP_ENDIF OP_CHECKSIG`?\n> This provides a slight privacy boost in a case (contract transaction publication) where most of the privacy is lost anyway.\n\nI completely agree that 2of2 multisigs made with OP_CHECKMULTISIG are\nlacking in terms of privacy, and that 2p-ECDSA is much better. However\nthis whole protocol is quite complicated and I thought it would be a\ngood move to first implement it with OP_CHECKMULTISIG, to get all the\nother details right (miner fees, coinswap fees, private key handover,\ncontract transactions, tor hidden services, watchtowers, etc etc) and\nthen add 2p-ECDSA later. Of course in that case all this tweaking of\npublic keys would be superseded by the 2p-ECDSA protocol."
            },
            {
                "author": "Chris Belcher",
                "date": "2020-08-20T22:15:34",
                "message_text_only": "Hello ZmnSCPxj,\n\nThanks for the review. My comments are inline.\n\nOn 20/08/2020 12:17, ZmnSCPxj wrote:\n> Good morning Chris,\n> \n> Great to see this!\n> \n> Mostly minor comments.\n> \n> \n> \n>>\n>> == Direct connections to Alice ===\n>>\n>> Only Alice, the taker, knows the entire route, Bob and Charlie just know\n>> their previous and next transactions. Bob and Charlie do not have direct\n>> connections with each other, only with Alice.\n>>\n>> Diagram of Tor connections:\n>>\n>> Bob Charlie\n>> | /\n>> | /\n>> | /\n>> Alice\n>>\n>> When Bob and Charlie communicate, they are actually sending and\n>> receiving messages via Alice who relays them to Charlie or Bob. This\n>> helps hide whether the previous or next counterparty in a CoinSwap route\n>> is a maker or taker.\n>>\n>> This doesn't have security issues even in the final steps where private\n>> keys are handed over, because those private keys are always for 2-of-2\n>> multisig and so on their own are never enough to steal money.\n> \n> This has a massive advantage over CoinJoin.\n> \n> In CoinJoin, since all participants sign a single transaction, every participant knows the total number of participants.\n> Thus, in CoinJoin, it is fairly useless to have just one taker and one maker, the maker knows exactly which output belongs to the taker.\n> Even if all communications were done via the single paying taker, the maker(s) are shown the final transaction and thus can easily know how many participants there are (by counting the number of equal-valued outputs).\n> \n> With CoinSwap, in principle no maker has to know how many other makers are in the swap.\n> \n> Thus it would still be useful to make a single-maker CoinSwap, as that would be difficult, for the maker, to diferentiate from a multi-maker CoinSwap.\n\nYes great point.\n\n> There are still a few potential leaks though:\n> \n> * If paying through a CoinSwap, the cheapest option for the taker would be to send out a single large UTXO (single-output txes) to the first maker, and then demand the final payment and any change as two separate swaps from the final maker.\n>   * Intermediate makers are likely to not have exact amounts, thus is unlikely to create a single-output tx when forwarding.\n>   * Thus, the first maker could identify the taker.\n\nRight, so if the taker uses only a single maker then they must have more\nthan one UTXO.\n\nThis leak in the case of a taker spending a single UTXO also happens\nwhen the taker needs to create a branching route. I described this in my\noriginal email \"Design for a CoinSwap implementation for massively\nimproving Bitcoin privacy and fungibility\" under the section \"Combining\nmulti-transaction with routing\" (the second diagram).\n\nI think this might be unavoidable. If the taker has just one UTXO they'd\nbe much better off using multiple makers for this reason.\n\n\n> * The makers can try timing the communications lag with the taker.\n>   The general assumption would be that more makers == more delay in taker responses.\n\nSounds like adding random delays would fix this. The protocol already\ninvolves waiting for a confirmation (average waiting time 10 minutes, at\nbest) and might involve more confirmations for extra security and\nprivacy. So adding a random delay of up to 0.5-1 minutes shouldnt cause\ntoo many issues.\nAlso the Tor network can be pretty laggy so that might add enough noise\nanyway.\n\n>>\n>> === Miner fees ===\n>>\n>> Makers have no incentive to pay any miner fees. They only do\n>> transactions which earn them an income and are willing to wait a very\n>> long time for that to happen. By contrast takers want to create\n>> transactions far more urgently. In JoinMarket we coded a protocol where\n>> the maker could contribute to miner fees, but the market price offered\n>> of that trended towards zero. So the reality is that takers will pay all\n>> the miner fees. Also because makers don't know the taker's time\n>> preference they don't know how much they should pay in miner fees.\n>>\n>> The taker will have to set limits on how large the maker's transactions\n>> are, otherwise makers could abuse this by having the taker consolidate\n>> maker's UTXOs for free.\n> \n> Why not have the taker pay for the *first* maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?\n> i.e. the taker indicates \"swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC\", and pays for one UTXO spent for each \"bag\" (thus pays for 3 UTXOs).\n> \n> Disagreements on feerate can be resolved by having the taker set the feerate, i.e. \"the customer is always right\".\n> Thus if the maker *has to* spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.\n> The maker can always reject the swap attempt if it *has to* spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.\n\nHaving the taker pay for just one UTXO will have an unfortunate side\neffect of resulting in the maker's money being split up into a large\nnumber of UTXOs, because every CoinSwap they take part in has an\nincentive to increase their UTXO count by one. At the start of\nJoinMarket this was an issue where then a taker wanting to CoinJoin a\nlarge would come along and the result would be a huge CoinJoin\ntransaction with many many small inputs. Perhaps the taker could pay for\n2-3 UTXOs to counteract this. (Of course the exact number would be\nconfigurable by the taker user, but defaults usually don't get changed).\n\nI'm still not convinced with having makers contribute to miner fees. In\nJoinMarket we tried to get makers to contribute a little to miner fees\nand simply they never did in any meaningful way. The market has spoken.\nIn terms of incentives makers are happy to wait a very long time, if we\nassume they're just HODLers then even if they earn a few thousand\nsatoshis that's good.\n\n>> == Contract transaction definitions ==\n>>\n>> Contract transactions are those which may spend from the 2-of-2 multisig\n>> outputs, they transfer the coins into a contract where the coins can be\n>> spent either by waiting for a timeout or providing a hash preimage\n>> value. Ideally contract transactions will never be broadcast but their\n>> existence keeps all parties honest.\n>>\n>> M~ is miner fees, which we treat as a random variable, and ultimately\n>> set by whichever pre-signed RBF tx get mined. When we talk about the\n>> contract tx, we actually mean perhaps 20-30 transactions which only\n>> differ by the miner fee and have RBF enabled, so they can be broadcasted\n>> in sequence to get the contract transaction mined regardless of the\n>> demand for block space.\n> \n> The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.\n> \n> Or not.\n> Hmm.\n\nI think RBF transactions are better because they ultimately use less\nblock space than CPFP.\n\nThere seems to be very little cost in signing many additional\nprecomputed RBF transactions. So the taker and makers could sign\ntransactions all the way up to 10000 sat/vbyte. I think this doesn't\napply to Lightning, because bandwidth seems to be more constrained\nthere: even a tiny micropayment for 1 satoshi would require 10x or 100x\nmore bandwidth if every lightning htlc used precomputed RBF.\n\n> Another thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?\n\nAlice only pays the miner fees for the funding transactions, not the\ncontract transaction. The miner fees for the contract transactions are\ntaken from the contract balance. The contract transactions are 1-input\n1-output, and whoever ends up with the money will be the one who paid\nthe miner fee.\n\n>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n>> either with Alice's private key\n>> after waiting for a relative\n>> timelock_A, or by Bob's private key by\n>> revealing a hash preimage value\n> \n> The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.\n> This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.\n> \n> The dangers are:\n> \n> * Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).\n> * After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.\n> * It is possible to steal from a participant if that participant goes offline longer than the timeout.\n>   This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.\n>   * The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.\n>     * This appears to be riskless for the taker.\n>     * Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.\n>   * On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.\n>     * But the taker can just try on the hope it works; it has nothing to lose.\n>   * This attack seems to be possible only for the taker to mount.\n>     Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.\n>     * On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.\n\nEvery off-chain protocol like this has the livelyness requirement. Each\nparty must always be watching the chain and be ready to broadcast\nsomething in response. I'm not sure how any of this relates to the\nchoice of relative vs absolute time locks.\n\nYou're right that attempting such an move by the taker is riskless, but\nits not costless. The taker sets up the entire CoinSwap protocol because\nthey wanted more privacy; but if the taker broadcasts the Alice contract\ntransaction and waits for the timeout, then all they've achieved is\nspent miner fees, got their own coin back and draw attention to it with\nthe unusual HTLC script. They've achieved no benefit from what I see, so\nthey won't do this. Any taker or maker who attempts anything like this\nwill be spending miner fees.\n\nI also envision that makers will run their own personal \"watchtowers\",\nsimilar to watchtowers in the lightning world, which would watch the\nblockchain and be ready to broadcast a transaction. In terms of\nincentives, makers are HODLers and we can expect them to protect their\nstash very carefully by running perhaps multiple redundant watchtowers\nin multiple locations and multiple networks. Therefore a taker noticing\nthat a maker's .onion is down does not imply that all the maker's\nwatchtowers are down.\n\nOf course we will choose the timelocks to be long enough so that\neveryone has enough time to broadcast a transaction in response, even in\ntimes of congested mempools.\n\n>   * Participants might want to spend from the UTXO to a new address after private key turnover anyway.\n>     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.\n\nI don't think this will happen very often. It's spending money on block\nspace for not much benefit. If the maker ever decides to shut down their\nmaker they can transfer all their coins in HTLCs to single-sig\ntransactions exclusively controlled by them, but in normal operation I\ndoubt it will happen.\n\n\n>> A possible attack by a malicious Alice is that she chooses M1 to be very\n>> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n>> sat/vb) and then intentionally aborts, forcing the makers to lose much\n>> more money in miner fees than the attacker. The attack can be used to\n>> waste away Bob's and Charlie's coins on miner fees at little cost to the\n>> malicious taker Alice. So to defend against this attack Bob and Charlie\n>> must refuse to sign a contract transaction if the corresponding funding\n>> transaction pays miner fees greater than Alice's funding transaction.\n> \n> Sorry, I do not follow the logic for this...?\n\nI'll try to explain again with an example, hopefully it clarifies.\n\nRecall the table of balances before/after CoinSwap using contracts\ntransactions:\n\nParty   | Before | After\n--------|--------|--------------------------------------------\nAlice   | WA     | WA-M1-I + I-MA~                  = WA-M1-MA~\nBob     | WB     | WB-I+B + I-M2-B-MB~              = WB-M2-MB~\n\n\nWhat the table says is that if the CoinSwap results in the HTLC\ntransactions being mined and the locktime branch being used, then both\nAlice and Bob will see their wallet balance fall by two miner fees (in\nAlice's case the miner fee of the Alice funding transaction plus the\nminer fee of the Alice contract transaction).\n\nThe attack I describe works because Alice chooses both MA~ and MB~. The\nattack is that Alice chooses MA~ to be a very low value (e.g. 1 sat/vb)\nand chooses MB~ to be a very high value (e.g. 1000 sat/vb). Then Alice\nintentionally sabotages the CoinSwap and forces it to go to the timeout\ncase, what happens is that Bob's wallet balance falls by much more than\nAlice's, because MB~ > MA~. So this is a DOS attack: Alice can waste\nBob's resources without wasting much of her own.\n\n>> The timelocks are staggered so that if Alice uses the preimage to take\n>> coins then the right people will also learn the preimage and have enough\n>> time to be able to get their coins back too. Alice starts with knowledge\n>> of the hash preimage so she must have a longest timelock.\n> \n> More precisely:\n> \n> * The HTLC outgoing from Alice has the longest timelock.\n> * The HTLC incoming into Alice has the shortest timelock.\n> \n> For the makers, they only need to ensure that the incoming timelock is much larger than the outgoing timelock.\n\nAgreed.\n\nPerhaps I chose confusing terminology, \"Alice contract transaction\"\nmeans the transaction which pays money to Alice after a timeout. The\ntext you quoted is confusingly written, and it would've been better to\nwrite: \"Alice starts with knowledge of the hash preimage so the Alice\ncontract transaction must have a longest timelock.\"\n\n>> == EC tweak to reduce one round trip ==\n>>\n>> When two parties are agreeing on a 2-of-2 multisig address, they need to\n>> agree on their public keys. We can avoid one round trip by using the EC\n>> tweak trick.\n>>\n>> When Alice, the taker, downloads the entire offer book for the liquidity\n>> market, the offers will also contain a EC public key. Alice can tweak\n>> this to generate a brand new public key for which the maker knows the\n>> private key. This public key will be one of the keys in the 2-of-2\n>> multisig. This feature removes one round trip from the protocol.\n>>\n>> q = EC privkey generated by maker\n>> Q = q.G = EC pubkey published by maker\n>>\n>> p = nonce generated by taker\n>> P = p.G = nonce point calculated by taker\n>>\n>> R = Q + P = pubkey used in bitcoin transaction\n>> = (q + p).G\n> \n> Whoa whoa whoa whoa.\n> \n> All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.\n> In which case, the private key generated by the taker would be sufficient tweak to blind this.\n> \n> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.\n> \n> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?\n> Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.\n\nYes, I intend for 2p-ECDSA to be used eventually, but for the first\nversion I'll only implement regular multisigs with OP_CHECKMULTISIG.\nOnce all the other details of this protocol are implemented correctly\nand mostly-bug-free then 2p-ECDSA can be added. It can be added in the\nprotocol steps 0-1, 3-5 and 7-9.\n\nThis document also doesn't talk about PayJoin-with-CoinSwap, but that\ncan be added later too.\n\n>>\n>>     == Analysis of deviations ==\n>>\n>>     This section discusses what happens if one party deviates from the\n>>     protocol by doing something else, for example broadcasting a htlc\n>>     contract tx when they shouldnt have.\n>>\n>>     The party name refers to what that party does, followed by other party's\n>>     reactions to it.\n>>     e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n>>\n>>     If multiple deviations are possible in a step then they are numbered\n>>     e.g. A1 A2 A2 etc\n>>\n>>     0-2. Alice/Bob/Charlie: nothing else is possible except following the\n>>     protocol or aborting\n>>\n>> 8.  Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n>>     do nothing, they havent lost any time or money.\n>>     4-6. Bob/Charlie: nothing else is possible except following the protocol\n>>     or aborting.\n>>\n>> 9.  Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n>>     her own A htlc txes and waits for the timeout to get her money back.\n>>     Charlie: do nothing\n>>\n>> 10.  Charlie: nothing else is possible except following the protocol or\n>>     aborting.\n>>\n>> 11.  Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n>>     his own A htlc txes and waits for the timeout.\n>>     A. same as 8.\n>>     B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n>>     broadcasts all their own htlc txes and waits for the timeout to get\n>>     their money back.\n>>     C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n>>     preimage hash to take the money immediately. Charlie: broadcasts\n>>     all of B htlc txes and reading the hash value from the blockchain,\n>>     uses it to take the money from B htlc immediately. Bob: broadcasts\n>>     all of A htlc txes, and reading hash from the blockchain, uses it\n>>     to take the money from A htlc immediately.\n>>     C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n>>     money. Bob: broadcast his own B htlc txes and after the timeout\n>>     take their money. Charlie: broadcast his own C htlc txes and after\n>>     the timeout take their money.\n>>     F1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n>>     to get the money immediately. He already knows both privkeys of the\n>>     multisig so this is pointless and just damages privacy and wastes\n>>     miner fees. Alice: blacklist Bob's fidelity bond.\n>>     F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n>>     to get his money immediately. Bob's actions were pointless. Alice:\n>>     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n>>     both fidelity bonds.\n>>     G1. Charlie: broadcast one or more of B htcl txes and use the hash\n>>     preimage to get the money immediately. He already knows both\n>>     privkeys of the multisig so this is pointless and just damages\n>>     privacy and wastes miner fees. Alice: cant tell whether Bob or\n>>     Charlie actually broadcasted, so blacklist both fidelity bonds.\n>>     G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n>>     the remaining A htlc txes and use preimage to get her money\n>>     immediately. Charlies's actions were pointless. Alice: blacklist\n>>     Charlie's fidelity bond.\n>>\n>>     The multisig outputs of the funding transactions can stay unspent\n>>     indefinitely. However the parties must always be watching the network\n>>     and ready to respond with their own sweep using a preimage. This is\n>>     because the other party still possesses a fully-signed contract tx. The\n>>     parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n>>     reaction of blacklisting both fidelity bonds might not be the right way,\n>>     because one maker could use it to get another one blacklisted (as well\n>>     as themselves).\n> \n> Looks OK, though note that a participant might try to do so (as pointed out above) in the hope that the next participant is offline.\n\nI really hope that everyone (the makers at least) is running multiple\nredundant watchtowers, so that anyone attempting this attack just wastes\nmoney on miner fees and achieves nothing."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-21T04:20:23",
                "message_text_only": "Good morning,\n\n\n\n> Right, so if the taker uses only a single maker then they must have more\n> than one UTXO.\n\nSpending one UTXO is fine, it is generating a transaction that has one output that is problematic.\n\nWhat needs to happen is that this single UTXO is spent to two outputs: the CoinSwap 2-of-2 and the change output.\nThis is because intermediate makers will have very high likelihood of generating such a pattern (it is unlikely they have an exact amount that a taker would require of them), and the occassional maker might have a very large UTXO that it can use for similar purposes.\n\nOne thing a taker can do would be to multipath its CoinSwap, i.e. it spends any number of UTXOs and creates two outputs, which are actually two separate CoinSwap 2-of-2s to different makers.\nAs each maker is unaware of the other, this should be similar to the case where the maker is an intermediate hop and is getting its incoming HTLC from another maker, which is unlikely to have a precise amount and will thus have a transaction that has two outputs, the 2-of-2 CoinSwap and the change.\n\n>\n> This leak in the case of a taker spending a single UTXO also happens\n> when the taker needs to create a branching route. I described this in my\n> original email \"Design for a CoinSwap implementation for massively\n> improving Bitcoin privacy and fungibility\" under the section \"Combining\n> multi-transaction with routing\" (the second diagram).\n>\n> I think this might be unavoidable. If the taker has just one UTXO they'd\n> be much better off using multiple makers for this reason.\n>\n> > -   The makers can try timing the communications lag with the taker.\n> >     The general assumption would be that more makers == more delay in taker responses.\n> >\n>\n> Sounds like adding random delays would fix this. The protocol already\n> involves waiting for a confirmation (average waiting time 10 minutes, at\n> best) and might involve more confirmations for extra security and\n> privacy. So adding a random delay of up to 0.5-1 minutes shouldnt cause\n> too many issues.\n> Also the Tor network can be pretty laggy so that might add enough noise\n> anyway.\n\nIndeed, this seems a bit of a long shot for the surveilling maker.\n\n> > > === Miner fees ===\n> > > Makers have no incentive to pay any miner fees. They only do\n> > > transactions which earn them an income and are willing to wait a very\n> > > long time for that to happen. By contrast takers want to create\n> > > transactions far more urgently. In JoinMarket we coded a protocol where\n> > > the maker could contribute to miner fees, but the market price offered\n> > > of that trended towards zero. So the reality is that takers will pay all\n> > > the miner fees. Also because makers don't know the taker's time\n> > > preference they don't know how much they should pay in miner fees.\n> > > The taker will have to set limits on how large the maker's transactions\n> > > are, otherwise makers could abuse this by having the taker consolidate\n> > > maker's UTXOs for free.\n> >\n> > Why not have the taker pay for the first maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?\n> > i.e. the taker indicates \"swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC\", and pays for one UTXO spent for each \"bag\" (thus pays for 3 UTXOs).\n> > Disagreements on feerate can be resolved by having the taker set the feerate, i.e. \"the customer is always right\".\n> > Thus if the maker has to spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.\n> > The maker can always reject the swap attempt if it has to spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.\n>\n> Having the taker pay for just one UTXO will have an unfortunate side\n> effect of resulting in the maker's money being split up into a large\n> number of UTXOs, because every CoinSwap they take part in has an\n> incentive to increase their UTXO count by one. At the start of\n> JoinMarket this was an issue where then a taker wanting to CoinJoin a\n> large would come along and the result would be a huge CoinJoin\n> transaction with many many small inputs. Perhaps the taker could pay for\n> 2-3 UTXOs to counteract this. (Of course the exact number would be\n> configurable by the taker user, but defaults usually don't get changed).\n>\n> I'm still not convinced with having makers contribute to miner fees. In\n> JoinMarket we tried to get makers to contribute a little to miner fees\n> and simply they never did in any meaningful way. The market has spoken.\n> In terms of incentives makers are happy to wait a very long time, if we\n> assume they're just HODLers then even if they earn a few thousand\n> satoshis that's good.\n>\n> > > == Contract transaction definitions ==\n> > > Contract transactions are those which may spend from the 2-of-2 multisig\n> > > outputs, they transfer the coins into a contract where the coins can be\n> > > spent either by waiting for a timeout or providing a hash preimage\n> > > value. Ideally contract transactions will never be broadcast but their\n> > > existence keeps all parties honest.\n> > > M~ is miner fees, which we treat as a random variable, and ultimately\n> > > set by whichever pre-signed RBF tx get mined. When we talk about the\n> > > contract tx, we actually mean perhaps 20-30 transactions which only\n> > > differ by the miner fee and have RBF enabled, so they can be broadcasted\n> > > in sequence to get the contract transaction mined regardless of the\n> > > demand for block space.\n> >\n> > The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.\n> > Or not.\n> > Hmm.\n>\n> I think RBF transactions are better because they ultimately use less\n> block space than CPFP.\n>\n> There seems to be very little cost in signing many additional\n> precomputed RBF transactions. So the taker and makers could sign\n> transactions all the way up to 10000 sat/vbyte. I think this doesn't\n> apply to Lightning, because bandwidth seems to be more constrained\n> there: even a tiny micropayment for 1 satoshi would require 10x or 100x\n> more bandwidth if every lightning htlc used precomputed RBF.\n\nI was wondering if it would be a good idea actually if the **largest** fee RBF transaction had additional CPFP anchor outputs, not saying to replace the entire group of RBF transactions entirely.\n\nThis is just in case of a very sudden increase in feerates that goes beyond the largest that was prepared beforehand.\n\"You cannot predict the feerates future\" is becoming something of a mantra over in Lightning, though I guess a \"big enough\" spread of RBF transactions would work in practice >99% of the time.\n\n\n> > Another thought: later you describe that miner fees are paid by Alice by forwarding those fees as well, how does that work when there are multiple versions of the contract transaction?\n>\n> Alice only pays the miner fees for the funding transactions, not the\n> contract transaction. The miner fees for the contract transactions are\n> taken from the contract balance. The contract transactions are 1-input\n> 1-output, and whoever ends up with the money will be the one who paid\n> the miner fee.\n\nOkay, that is much clearer.\n\n> > > (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n> > > either with Alice's private key\n> > > after waiting for a relative\n> > > timelock_A, or by Bob's private key by\n> > > revealing a hash preimage value\n> >\n> > The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.\n> > This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.\n> > The dangers are:\n> >\n> > -   Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).\n> > -   After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.\n> > -   It is possible to steal from a participant if that participant goes offline longer than the timeout.\n> >     This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.\n> >     -   The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.\n> >         -   This appears to be riskless for the taker.\n> >         -   Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.\n> >     -   On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.\n> >         -   But the taker can just try on the hope it works; it has nothing to lose.\n> >     -   This attack seems to be possible only for the taker to mount.\n> >         Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.\n> >         -   On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.\n>\n> Every off-chain protocol like this has the livelyness requirement. Each\n> party must always be watching the chain and be ready to broadcast\n> something in response. I'm not sure how any of this relates to the\n> choice of relative vs absolute time locks.\n\nAbsolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).\nBut I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.\n\n>\n> You're right that attempting such an move by the taker is riskless, but\n> its not costless. The taker sets up the entire CoinSwap protocol because\n> they wanted more privacy; but if the taker broadcasts the Alice contract\n> transaction and waits for the timeout, then all they've achieved is\n> spent miner fees, got their own coin back and draw attention to it with\n> the unusual HTLC script. They've achieved no benefit from what I see, so\n> they won't do this. Any taker or maker who attempts anything like this\n> will be spending miner fees.\n\nThey would be spending miner fees *from the funds being stolen*, thus still costless.\n\nIn particular, let us imagine a simple 1-maker swap.\n\n* The taker and the maker complete the swap.\n* The taker now has possession of:\n  * The private key for its incoming HTLC.\n  * The pre-signed contract transaction for its outgoing HTLC.\n* The taker spends from its incoming HTLC using the private key.\n  * The maker ignores this, because this is just normal operation.\n  * Fees paid for this is not an **additional** cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.\n  * The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.\n* The taker waits for the incoming-HTLC-spend to confirm.\n* The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.\n  * The fees paid for this are from the contract transaction that the taker is trying to steal.\n    Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.\n  * Semantically, the outgoing HTLC is already \"owned\" by the maker (the maker has private key to it).\n    * Thus, the taker commits an action that the maker pays fees for!\n  * The maker cannot react except to spend via the hashlock branch.\n    In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.\n* The theft succeeds (the timelock passes) because the maker happens to be offline for that long.\n  * This is \"free money\" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.\n  * Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.\n\nUsing an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, ***not*** `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key *has to* be used.\nThis is because there is no contract transaction that is share-owned by both participants in the swap.\nInstead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).\n\n> > -   Participants might want to spend from the UTXO to a new address after private key turnover anyway.\n> >     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.\n> >\n>\n> I don't think this will happen very often. It's spending money on block\n> space for not much benefit. If the maker ever decides to shut down their\n> maker they can transfer all their coins in HTLCs to single-sig\n> transactions exclusively controlled by them, but in normal operation I\n> doubt it will happen.\n\nAccidents can happen (e.g. somebody trips over the power cord of the maker hardware), so hedging this somewhat might give a useful safety net.\n\n>\n> The attack I describe works because Alice chooses both MA~ and MB~. The\n> attack is that Alice chooses MA~ to be a very low value (e.g. 1 sat/vb)\n> and chooses MB~ to be a very high value (e.g. 1000 sat/vb). Then Alice\n> intentionally sabotages the CoinSwap and forces it to go to the timeout\n> case, what happens is that Bob's wallet balance falls by much more than\n> Alice's, because MB~ > MA~. So this is a DOS attack: Alice can waste\n> Bob's resources without wasting much of her own.\n\nAh, right, that is clearer.\n\n> > > == EC tweak to reduce one round trip ==\n> > > When two parties are agreeing on a 2-of-2 multisig address, they need to\n> > > agree on their public keys. We can avoid one round trip by using the EC\n> > > tweak trick.\n> > > When Alice, the taker, downloads the entire offer book for the liquidity\n> > > market, the offers will also contain a EC public key. Alice can tweak\n> > > this to generate a brand new public key for which the maker knows the\n> > > private key. This public key will be one of the keys in the 2-of-2\n> > > multisig. This feature removes one round trip from the protocol.\n> > > q = EC privkey generated by maker\n> > > Q = q.G = EC pubkey published by maker\n> > > p = nonce generated by taker\n> > > P = p.G = nonce point calculated by taker\n> > > R = Q + P = pubkey used in bitcoin transaction\n> > > = (q + p).G\n> >\n> > Whoa whoa whoa whoa.\n> > All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.\n> > In which case, the private key generated by the taker would be sufficient tweak to blind this.\n> > In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.\n> > Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?\n> > Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.\n>\n> Yes, I intend for 2p-ECDSA to be used eventually, but for the first\n> version I'll only implement regular multisigs with OP_CHECKMULTISIG.\n> Once all the other details of this protocol are implemented correctly\n> and mostly-bug-free then 2p-ECDSA can be added. It can be added in the\n> protocol steps 0-1, 3-5 and 7-9.\n\nOkay, that is clearer.\n\nI think 2p-ECDSA should be first priority after getting a decent alpha version.\n\n> This document also doesn't talk about PayJoin-with-CoinSwap, but that\n> can be added later too.\n\n2p-ECDSA with Scriptless Script potentially gives a lot more privacy than any PayJoin IMO, due simply to the much larger anonymity set, and there are enough chain-analysis-heuristic-breaking shenanigans we can implement with plain CoinSwap, I think.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-08-21T09:47:31",
                "message_text_only": "Hello,\n\nOn 21/08/2020 05:20, ZmnSCPxj wrote:\n> Good morning,\n> \n> \n> \n>> Right, so if the taker uses only a single maker then they must have more\n>> than one UTXO.\n> \n> Spending one UTXO is fine, it is generating a transaction that has one output that is problematic.\n> \n> What needs to happen is that this single UTXO is spent to two outputs: the CoinSwap 2-of-2 and the change output.\n> This is because intermediate makers will have very high likelihood of generating such a pattern (it is unlikely they have an exact amount that a taker would require of them), and the occassional maker might have a very large UTXO that it can use for similar purposes.\n> \n> One thing a taker can do would be to multipath its CoinSwap, i.e. it spends any number of UTXOs and creates two outputs, which are actually two separate CoinSwap 2-of-2s to different makers.\n> As each maker is unaware of the other, this should be similar to the case where the maker is an intermediate hop and is getting its incoming HTLC from another maker, which is unlikely to have a precise amount and will thus have a transaction that has two outputs, the 2-of-2 CoinSwap and the change.\n\nAgreed.\nI write about multipath CoinSwap routes in the original design document,\nunder \"Combining multi-transaction with routing\"\n\n\n>>>> === Miner fees ===\n>>>> Makers have no incentive to pay any miner fees. They only do\n>>>> transactions which earn them an income and are willing to wait a very\n>>>> long time for that to happen. By contrast takers want to create\n>>>> transactions far more urgently. In JoinMarket we coded a protocol where\n>>>> the maker could contribute to miner fees, but the market price offered\n>>>> of that trended towards zero. So the reality is that takers will pay all\n>>>> the miner fees. Also because makers don't know the taker's time\n>>>> preference they don't know how much they should pay in miner fees.\n>>>> The taker will have to set limits on how large the maker's transactions\n>>>> are, otherwise makers could abuse this by having the taker consolidate\n>>>> maker's UTXOs for free.\n>>>\n>>> Why not have the taker pay for the first maker-spent UTXO and have additional maker-spent UTXOs paid for by the maker?\n>>> i.e. the taker indicates \"swap me 1 BTC in 3 bags of 0.3, 0.3, and 0.4 BTC\", and pays for one UTXO spent for each \"bag\" (thus pays for 3 UTXOs).\n>>> Disagreements on feerate can be resolved by having the taker set the feerate, i.e. \"the customer is always right\".\n>>> Thus if the maker has to spend two UTXOs to make up the 0.4 BTC bag, it pays for the mining fees for that extra UTXO.\n>>> The maker can always reject the swap attempt if it has to spend multiple UTXOs and would lose money doing so if the taker demands a too-high feerate.\n>>\n>> Having the taker pay for just one UTXO will have an unfortunate side\n>> effect of resulting in the maker's money being split up into a large\n>> number of UTXOs, because every CoinSwap they take part in has an\n>> incentive to increase their UTXO count by one. At the start of\n>> JoinMarket this was an issue where then a taker wanting to CoinJoin a\n>> large would come along and the result would be a huge CoinJoin\n>> transaction with many many small inputs. Perhaps the taker could pay for\n>> 2-3 UTXOs to counteract this. (Of course the exact number would be\n>> configurable by the taker user, but defaults usually don't get changed).\n>>\n>> I'm still not convinced with having makers contribute to miner fees. In\n>> JoinMarket we tried to get makers to contribute a little to miner fees\n>> and simply they never did in any meaningful way. The market has spoken.\n>> In terms of incentives makers are happy to wait a very long time, if we\n>> assume they're just HODLers then even if they earn a few thousand\n>> satoshis that's good.\n>>\n>>>> == Contract transaction definitions ==\n>>>> Contract transactions are those which may spend from the 2-of-2 multisig\n>>>> outputs, they transfer the coins into a contract where the coins can be\n>>>> spent either by waiting for a timeout or providing a hash preimage\n>>>> value. Ideally contract transactions will never be broadcast but their\n>>>> existence keeps all parties honest.\n>>>> M~ is miner fees, which we treat as a random variable, and ultimately\n>>>> set by whichever pre-signed RBF tx get mined. When we talk about the\n>>>> contract tx, we actually mean perhaps 20-30 transactions which only\n>>>> differ by the miner fee and have RBF enabled, so they can be broadcasted\n>>>> in sequence to get the contract transaction mined regardless of the\n>>>> demand for block space.\n>>>\n>>> The highest-fee version could have, in addition, CPFP-anchor outputs, like those being proposed in Lightning, so even if onchain fees rise above the largest fee reservation, it is possible to add even more fees.\n>>> Or not.\n>>> Hmm.\n>>\n>> I think RBF transactions are better because they ultimately use less\n>> block space than CPFP.\n>>\n>> There seems to be very little cost in signing many additional\n>> precomputed RBF transactions. So the taker and makers could sign\n>> transactions all the way up to 10000 sat/vbyte. I think this doesn't\n>> apply to Lightning, because bandwidth seems to be more constrained\n>> there: even a tiny micropayment for 1 satoshi would require 10x or 100x\n>> more bandwidth if every lightning htlc used precomputed RBF.\n> \n> I was wondering if it would be a good idea actually if the **largest** fee RBF transaction had additional CPFP anchor outputs, not saying to replace the entire group of RBF transactions entirely.\n> \n> This is just in case of a very sudden increase in feerates that goes beyond the largest that was prepared beforehand.\n> \"You cannot predict the feerates future\" is becoming something of a mantra over in Lightning, though I guess a \"big enough\" spread of RBF transactions would work in practice >99% of the time.\n\nGot it. I agree having a CPFP anchor output on the largest fee RBF is a\ngood idea then.\n\n> \n>>>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n>>>> either with Alice's private key\n>>>> after waiting for a relative\n>>>> timelock_A, or by Bob's private key by\n>>>> revealing a hash preimage value\n>>>\n>>> The rationale for relative timelocks is that it makes private key turnover slightly more useable by ensuring that, after private key turnover, it is possible to wait indefinitely to spend the UTXO it received.\n>>> This is in contrast with absolute timelocks, where after private key turnover, it is required to spend received UTXO before the absolute timeout.\n>>> The dangers are:\n>>>\n>>> -   Until it receives the private key, if either of the incoming or outgoing contract transactions are confirmed, every swap participant (taker or maker) should also broadcast the other contract transaction, and resolve by onchain transactions (with loss of privacy).\n>>> -   After receiving the private key, if the incoming contract transaction is confirmed, it should spend the resulting contract output.\n>>> -   It is possible to steal from a participant if that participant goes offline longer than the timeout.\n>>>     This may imply that there may have to be some minimum timeout that makers indicate in their advertisements.\n>>>     -   The taker can detect if the first maker is offline, then if it is offline, try a contract transaction broadcast, if it confirms, the taker can wait for the timeout; if it times out, the taker can clawback the transaction.\n>>>         -   This appears to be riskless for the taker.\n>>>         -   Against a similar attack, Lightning requires channel reserves, which means the first hop never gains control of the entire value, which is a basic requirement for private key turnover.\n>>>     -   On the other hand, the taker has the largest timeout before it can clawback the funds, so it would wait for a long time, and at any time in between the first maker can come online and spend using the hashlock branch.\n>>>         -   But the taker can just try on the hope it works; it has nothing to lose.\n>>>     -   This attack seems to be possible only for the taker to mount.\n>>>         Other makers on the route cannot know who the other makers are, without cooperation of the taker, who is the only one who knows all the makers.\n>>>         -   On the other hand, the last maker in the route has an outgoing HTLC with the smallest timelock, so it is the least-risk and therefore a maker who notices its outgoing HTLC has a low timeout might want to just do this anyway even if it is unsure if the taker is offline.\n>>\n>> Every off-chain protocol like this has the livelyness requirement. Each\n>> party must always be watching the chain and be ready to broadcast\n>> something in response. I'm not sure how any of this relates to the\n>> choice of relative vs absolute time locks.\n> \n> Absolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).\n> But I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.\n\nYou can always put your node to sleep as a maker, and your watchtowers\nwill protect you.\n\nWhat do you mean by the point about 100% online nodes getting more\nfeasible? Many bitcoin nodes have been always-on for years, I think I\nmissed something.\n\n>> You're right that attempting such an move by the taker is riskless, but\n>> its not costless. The taker sets up the entire CoinSwap protocol because\n>> they wanted more privacy; but if the taker broadcasts the Alice contract\n>> transaction and waits for the timeout, then all they've achieved is\n>> spent miner fees, got their own coin back and draw attention to it with\n>> the unusual HTLC script. They've achieved no benefit from what I see, so\n>> they won't do this. Any taker or maker who attempts anything like this\n>> will be spending miner fees.\n> \n> They would be spending miner fees *from the funds being stolen*, thus still costless.\n> \n> In particular, let us imagine a simple 1-maker swap.\n> \n> * The taker and the maker complete the swap.\n> * The taker now has possession of:\n>   * The private key for its incoming HTLC.\n>   * The pre-signed contract transaction for its outgoing HTLC.\n> * The taker spends from its incoming HTLC using the private key.\n>   * The maker ignores this, because this is just normal operation.\n>   * Fees paid for this is not an **additional** cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.\n>   * The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.\n> * The taker waits for the incoming-HTLC-spend to confirm.\n> * The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.\n>   * The fees paid for this are from the contract transaction that the taker is trying to steal.\n>     Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.\n>   * Semantically, the outgoing HTLC is already \"owned\" by the maker (the maker has private key to it).\n>     * Thus, the taker commits an action that the maker pays fees for!\n>   * The maker cannot react except to spend via the hashlock branch.\n>     In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.\n> * The theft succeeds (the timelock passes) because the maker happens to be offline for that long.\n>   * This is \"free money\" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.\n>   * Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.\n\nYep you're right, I get it.\n\nThe biggest defense against theft will have to be multiple redundant\nwatchtowers. But as you say the attack is riskless and costless for the\ntaker to attempt, so they might try anyway even if the probability of\nsuccess is very low.\n\nIf this attack becomes widespread then it effectively breaks the\nproperty that maker's coins remain unspent indefinitely. It seems like\nthat would lead to makers increasing their CoinSwap fees because they\nknow they'll always have to spend a bit of miner fees afterwards.\n\nHopefully the success rate for this attack can be low enough that\ntaker's human niceness will stop them trying. But for sure this is a\nconcerning problem.\n\n> Using an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, ***not*** `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key *has to* be used.\n> This is because there is no contract transaction that is share-owned by both participants in the swap.\n> Instead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).\n\nA downside of using absolute timelocks is that it combines the two time\nperiods: the time period where a watchtower must respond and the time\nperiod under which private keys must be used.\n\nSo for example if the absolute timelock is set to 3 weeks, that means\nthe maker has 3 weeks to spend their coins using the private keys which\nis a nice long period. However if the CoinSwaps fails with the timeout\ncase then the maker has to wait 3 weeks to get their coins back, which\nis a long time.\n\nWe can go the other extreme and set the absolute timelock to be 2 days.\nThen the maker only has to wait 2 days in the unfortunate event that\ntheir coinswap fails with the timeout case. But it means they must use\ntheir private keys to spend coins within the short period of 2 days(!)\n\nThough this still might be worth it to solve the riskless/costless\nstealing attempts.\n\n\n>>> -   Participants might want to spend from the UTXO to a new address after private key turnover anyway.\n>>>     Makers could spend using a low-fee RBF-enabled tx, and when another request comes in for another swap, try to build a new funding tx with a higher-fee bump.\n>>>\n>>\n>> I don't think this will happen very often. It's spending money on block\n>> space for not much benefit. If the maker ever decides to shut down their\n>> maker they can transfer all their coins in HTLCs to single-sig\n>> transactions exclusively controlled by them, but in normal operation I\n>> doubt it will happen.\n> \n> Accidents can happen (e.g. somebody trips over the power cord of the maker hardware), so hedging this somewhat might give a useful safety net.\n\nRight, but taking out the maker hardware isn't enough for funds to be\nstolen, all the watchtowers would need to be taken out too.\n\n\n>>>> == EC tweak to reduce one round trip ==\n>>>> When two parties are agreeing on a 2-of-2 multisig address, they need to\n>>>> agree on their public keys. We can avoid one round trip by using the EC\n>>>> tweak trick.\n>>>> When Alice, the taker, downloads the entire offer book for the liquidity\n>>>> market, the offers will also contain a EC public key. Alice can tweak\n>>>> this to generate a brand new public key for which the maker knows the\n>>>> private key. This public key will be one of the keys in the 2-of-2\n>>>> multisig. This feature removes one round trip from the protocol.\n>>>> q = EC privkey generated by maker\n>>>> Q = q.G = EC pubkey published by maker\n>>>> p = nonce generated by taker\n>>>> P = p.G = nonce point calculated by taker\n>>>> R = Q + P = pubkey used in bitcoin transaction\n>>>> = (q + p).G\n>>>\n>>> Whoa whoa whoa whoa.\n>>> All this time I was thinking you were going to use 2p-ECDSA for all 2-of-2s.\n>>> In which case, the private key generated by the taker would be sufficient tweak to blind this.\n>>> In 2p-ECDSA, for two participants M = m * G; T = t * G, the total key is m * t * G = m * T = t * M.\n>>> Are you going to use `2 <T> <Q+P> 2 OP_CHECKMULTISIG` instead of 2p-ECDSA?\n>>> Note that you cannot usefully hide among Lightning mutual closes, because of the reserve; Lightning mutual closes are very very likely to be spent in a 1-input (that spends from a 2-of-2 P2WSH), 2-output (that pays to two P2WPKHs) tx.\n>>\n>> Yes, I intend for 2p-ECDSA to be used eventually, but for the first\n>> version I'll only implement regular multisigs with OP_CHECKMULTISIG.\n>> Once all the other details of this protocol are implemented correctly\n>> and mostly-bug-free then 2p-ECDSA can be added. It can be added in the\n>> protocol steps 0-1, 3-5 and 7-9.\n> \n> Okay, that is clearer.\n> \n> I think 2p-ECDSA should be first priority after getting a decent alpha version.\n> \n>> This document also doesn't talk about PayJoin-with-CoinSwap, but that\n>> can be added later too.\n> \n> 2p-ECDSA with Scriptless Script potentially gives a lot more privacy than any PayJoin IMO, due simply to the much larger anonymity set, and there are enough chain-analysis-heuristic-breaking shenanigans we can implement with plain CoinSwap, I think.\n\nI completely agree.\n\n\nRegards\nCB"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-22T01:09:35",
                "message_text_only": "Good morning Chris,\n\n\n> > Absolute timelocks mean that you can set a timer where you put your node to sleep without risk of loss of funds (basically, once the absolute timelocks have resolved, you can forget about CoinSwaps).\n> > But I think the ability to spend at any time would be better, and getting 100% online 144 blocks a day, 2016 blocks a retargeting period is becoming more and more feasible.\n>\n> You can always put your node to sleep as a maker, and your watchtowers\n> will protect you.\n\nAssuming you have multiple watchtowers, yes.\n\nIt would be best if watchtowers for CoinSwap and watchtowers for Lightning could be the same thing, and ideally, a watchtower would not even know if what it was watching were a Lightning channel or a CoinSwap until an attack happens.\n\n>\n> What do you mean by the point about 100% online nodes getting more\n> feasible? Many bitcoin nodes have been always-on for years, I think I\n> missed something.\n\nNot all locations on Earth make it easy to be 100% online.\nHowever, as the technology of you puny humans advance, it becomes more and more possible for a random point on Earth to be 100% online.\n\n> > > You're right that attempting such an move by the taker is riskless, but\n> > > its not costless. The taker sets up the entire CoinSwap protocol because\n> > > they wanted more privacy; but if the taker broadcasts the Alice contract\n> > > transaction and waits for the timeout, then all they've achieved is\n> > > spent miner fees, got their own coin back and draw attention to it with\n> > > the unusual HTLC script. They've achieved no benefit from what I see, so\n> > > they won't do this. Any taker or maker who attempts anything like this\n> > > will be spending miner fees.\n> >\n> > They would be spending miner fees from the funds being stolen, thus still costless.\n> > In particular, let us imagine a simple 1-maker swap.\n> >\n> > -   The taker and the maker complete the swap.\n> > -   The taker now has possession of:\n> >     -   The private key for its incoming HTLC.\n> >     -   The pre-signed contract transaction for its outgoing HTLC.\n> > -   The taker spends from its incoming HTLC using the private key.\n> >     -   The maker ignores this, because this is just normal operation.\n> >     -   Fees paid for this is not an additional cost, because a taker that wants to put its freshly-private funds into cold storage will do this anyway.\n> >     -   The taker gets a fresh, private coin from this incoming HTLC, so it gets the privacy it paid for.\n> > -   The taker waits for the incoming-HTLC-spend to confirm.\n> > -   The taker broadcasts the pre-signed contract transaction, in the hope that the maker is offline.\n> >     -   The fees paid for this are from the contract transaction that the taker is trying to steal.\n> >         Even if the theft attempt fails, the taker has already gotten its private money out, and is thus not risking anything.\n> >\n> >     -   Semantically, the outgoing HTLC is already \"owned\" by the maker (the maker has private key to it).\n> >         -   Thus, the taker commits an action that the maker pays fees for!\n> >     -   The maker cannot react except to spend via the hashlock branch.\n> >         In particular, because the taker-incoming (maker-outgoing) UTXO is already spent, it cannot retaliate by also broadcasting the contract transaction of the taker-incoming (maker-outgoing) HTLC.\n> >\n> > -   The theft succeeds (the timelock passes) because the maker happens to be offline for that long.\n> >     -   This is \"free money\" to the taker, who has already gotten what it paid for --- private money in cold storage --- from the CoinSwap.\n> >     -   Even if the stolen fund reveals the contract, the taker can re-acquire privacy for the funds it stole for free, by paying for --- wait for it --- another CoinSwap for its swag.\n>\n> Yep you're right, I get it.\n>\n> The biggest defense against theft will have to be multiple redundant\n> watchtowers. But as you say the attack is riskless and costless for the\n> taker to attempt, so they might try anyway even if the probability of\n> success is very low.\n>\n> If this attack becomes widespread then it effectively breaks the\n> property that maker's coins remain unspent indefinitely. It seems like\n> that would lead to makers increasing their CoinSwap fees because they\n> know they'll always have to spend a bit of miner fees afterwards.\n>\n> Hopefully the success rate for this attack can be low enough that\n> taker's human niceness will stop them trying. But for sure this is a\n> concerning problem.\n\nIndeed.\n\nWe also cannot use succinct atomic swaps because their asymmetry makes them unroutable --- you can only use it for single-maker swaps.\nThis makes it obvious to the maker that you have only a single maker.\n\n> > Using an absolute timelock (implemented by a `nLockTime` tx directly off the 2-of-2, not `OP_CHECKLOCKTIMEVERIFY`), plus a Scriptless Script 2p-ECDSA (again implemented by a tx directly off the 2-of-2) instead of a hashlock, seems to avoid this, I think, at the cost of reducing the utility of private key turnover by having a deadline where the private key has to be used.\n> > This is because there is no contract transaction that is share-owned by both participants in the swap.\n> > Instead there are two distinct transactions with separate ownerships: a timeout tx (that is owned by the participant paying for the HTLC/PTLC) and a claim tx (that is owned by the participant accepting the HTLC/PTLC).\n>\n> A downside of using absolute timelocks is that it combines the two time\n> periods: the time period where a watchtower must respond and the time\n> period under which private keys must be used.\n>\n> So for example if the absolute timelock is set to 3 weeks, that means\n> the maker has 3 weeks to spend their coins using the private keys which\n> is a nice long period. However if the CoinSwaps fails with the timeout\n> case then the maker has to wait 3 weeks to get their coins back, which\n> is a long time.\n>\n> We can go the other extreme and set the absolute timelock to be 2 days.\n> Then the maker only has to wait 2 days in the unfortunate event that\n> their coinswap fails with the timeout case. But it means they must use\n> their private keys to spend coins within the short period of 2 days(!)\n>\n> Though this still might be worth it to solve the riskless/costless\n> stealing attempts.\n\nYes.\nNote that this only works if you dive into Scriptless Script 2p-ECDSA/Schnorr immediately.\n\nIt also makes watchtowers for Lightning inherently incompatible with watchtowers for CoinSwaps using absolute timelocks.\n\nA watchtower guarding for CoinSwaps using absolute timelocks would:\n\n* Need to know the funding outpoint it is guarding.\n  * Watchtowers for Lightning (and contract-transaction-based CoinSwap) do *not* need to know this, they just need to know a transaction ID that, if confirmed, they will broadcast *another* transaction.\n* Need to watch *blockheight*.\n  * Watchtowers for Lightning (and contract-transaction-based CoinSwap) only check for transactions matching txids they are watching for.\n\nIn particular the first point is a massive privacy lose.\nLightning watchtowers can have the txid they are watching for in the clear, and the transaction they will broadcast in reaction to the watched txid being confirmed is encrypted using a key derived from the transaction with the given txid, and thus do not learn which funding outpoint it is protecting until an attack occurs, which is very good for privacy.\n\n(even if the maker were to run private watchtowers of their own rather than using some public watchtower service, if the private watchtower is hacked it contains information that can be used to identify funding outpoints, thus making them targets.\nThus, it is best if watchtowers, whether public or private, do not contain any privacy-damaging information, to reduce the attack surface on privacy.)\n\nA way to make watchtowers for absolute-timelock CoinSwap also have the same interface (i.e. \"Watch for this txid, if it appears onchain broadcast this transaction\") as Lightning watchtowers would be to have the timeout tx pay out to a `OP_IF <1 day> OP_CHECKSEQUENCEVERIFY OP_DROP <taker> OP_ELSE <revocationkey> OP_ENDIF OP_CHECKSIGVERIFY`.\nThe revocation key would be the same private key that is turned over at the end of the CoinSwap.\nSo, if the absolute timelock expires and the other participant broadcasts the timeout tx, the maker still has an opportunity to revoke that output, for one additional day.\n\nThen, at the end of the CoinSwap where the private key is turned over, the maker can hand the txid of the timeout tx, plus an encrypted transaction that spends from the revocation branch of the timeout tx back to the maker and a tip to the watchtower, to the watchtower, who remains unaware what the funding txo is (it only gets a txid and an encrypted blob, so gets no information).\nThe same interface can be used by Lightning Poon-Dryja (it is sub-optimal, but usable, for Decker-Russell-Osuntokun), and the watchtower would not even learn if it was watching for a Lightning channel or for a CoinSwap.\n\nThen, if the maker were holding on to the funding outpoint of its incoming HTLC in the hope another taker arrives for its services, and then some silly human trips over the maker hardware power cord, and the condition is not fixed by the timeout, it can still be privately protected by watchtowers.\n\nThis comes at the cost of even worse UX if something goes wrong with the swap: an increased timeout.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2020-08-24T19:30:05",
                "message_text_only": "Hello Chris,\n\nI think you might have vulnerability issues with the current design.\n\nWith regards to the fee model for contract transactions, AFAICT timely\nconfirmation is a fund safety matter for an intermediate hop. Between the\noffchain preimage reveal phase and the offchain private key handover phase,\nthe next hop can broadcast your outgoing contract transactions, thus\nforcing you to claim quickly backward as you can't assume previous hop will\nhonestly cooperate to achieve the private key handover. This means that\nyour range of pre-signed RBF-transactions must theoretically have for fee\nupper bound the maximum of the contested balance, as game-theory side, it's\nrational to you to burn your balance instead of letting your counterparty\nclaim it after timelock expiration, in face of mempool congestion. Where\nthe issue dwells is that this fee is pre-committed and not cancelled when\nthe balance change of ownership by the outgoing hop learning the preimage\nof the haslock output. Thus the previous hop is free to broadcast the\nhighest-fee RBF-transactions and burn your balance, as for him, his balance\nis now encoded in the output of the contract transactions on the previous\nlink, for which he knows the preimage.\n\nNote, I think this is independent of picking up either relative or absolute\ntimelocks as what matters is the block delta between two links. Of course\nyou can increase this delta to be week-lengthy and thus decrease the need\nfor a compelling fee but a) you may force quickly close with contract\ntransactions if the private key handover doesn't happen soon, you don't\nwant to be caught by surprise by congestion so you would close far behind\ndelta period expiration like half of it, and b) you increase the time-value\nof makers funds in case of faulty hop, thus logically increasing the maker\nfee and making the cost of the system higher in average. I guess a better\nsolution would be to use dual-anchor outputs has spec'ed out by Lightning,\nit lets the party who has a balance at stake unilaterally increase feerate\nwith a CPFP. The CPFP is obviously a higher blockchain cost but a) it's a\nsafety mechanism for a worst-case scenario, 99% of the time they won't be\ncommitted, b) you might use this CPFP to aggregate change outputs or other\nopportunistically side-usage.\n\nWith regards to the preimage release phase, I think you might have a\npinning scenario. The victim would be an intermediate hop, targeted by a\nmalicious taker. The preimage isn't revealed offchain to this victim hop. A\nlow-feerate version of the outgoing contract transaction is broadcast and\nnot going to confirm, assuming a bit of congestion. As preimage is known,\nthe malicious taker can directly attach a high-fee, low-feerate child\ntransaction and thus prevent any replacement of the pinned parent by a\nhonest broadcast of a high-fee RBF-transaction under BIP 125 rules. At the\nsame time, the malicious taker broadcasts the contract tx on the previous\nlink and gets it confirmed. At relative timelock expiration, malicious\ntaker claims back the funds. When the pinned transaction spending the\noutgoing link gets evicted (either by replacing child by a higher feerate\nor waiting for mempool expiration after 2 weeks), taker gets it confirmed\nthis time and claims output through hashlock. Given the relative timelock\nblocking the victim, there is not even a race.\n\nI guess restraining the contract transaction to one and only one version\nwould overcome this attack. A honest intermediate hop, as soon as seeing a\nrelative timelock triggered backward would immediately broadcast the\noutgoing link contract tx or if it's already in network mempools broadcast\na higher-feerate child. As you don't have valid multiple contract\ntransactions, an attacker can't obstruct you to propagate the correct\nchild, as you are not blind about the parent txid.\n\nLastly, one downside of using relative timelocks, in case of one downstream\nlink failure, it forces every other upstream hops to go onchain to protect\nagainst this kind of pinning scenario. And this would be a privacy\nbreakdown, as a maker would be able to provoke one, thus constraining every\nupstream hops to go onchain with the same hash and revealing the CoinSwap\nroute.\n\nLet me know if I reviewed the correct transactions circuit model or\nmisunderstood associated semantic. I might be completely wrong, coming from\na LN perspective.\n\nCheers,\nAntoine\n\nLe mar. 11 ao\u00fbt 2020 \u00e0 13:06, Chris Belcher via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> I'm currently working on implementing CoinSwap (see my other email\n> \"Design for a CoinSwap implementation for massively improving Bitcoin\n> privacy and fungibility\").\n>\n> CoinSwaps are special because they look just like regular bitcoin\n> transactions, so they improve the privacy even for people who do not use\n> them. Once CoinSwap is deployed, anyone attempting surveillance of\n> bitcoin transactions will be forced to ask themselves the question: how\n> do we know this transaction wasn't a CoinSwap?\n>\n> This email contains a detailed design of the first protocol version. It\n> makes use of the building blocks of multi-transaction CoinSwaps, routed\n> CoinSwaps, liquidity market, private key handover, and fidelity bonds.\n> It does not include PayJoin-with-CoinSwap, but that's in the plan to be\n> added later.\n>\n> == Routed CoinSwap ==\n>\n> Diagram of CoinSwaps in the route:\n>\n>     Alice ====> Bob ====> Charlie ====> Alice\n>\n> Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives\n> coins to Charlie, who gives coins to Alice. Alice is the market taker\n> and she starts with the hash preimage. She chooses the CoinSwap amount\n> and chooses who the makers will be.\n>\n> This design has one market taker and two market makers in its route, but\n> it can easily be extended to any number of makers.\n>\n> == Multiple transactions ==\n>\n> Each single CoinSwap is made up of multiple transactions to avoid amount\n> correlation\n>\n>           (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->\n>     Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice\n>           (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->\n>\n> The arrow (--->) represent funding transactions. The money gets paid to\n> a 2-of-2 multisig but after the CoinSwap protocol and private key\n> handover is done they will be controlled by the next party in the route.\n>\n> This example has 6 regular-sized transactions which use approximately\n> the same amount of block space as a single JoinMarket coinjoin with 6\n> parties (1 taker, 5 makers). Yet the privacy provided by this one\n> CoinSwap would be far far greater. It would not have to be repeated in\n> the way that Equal-Output CoinJoins must be.\n>\n> == Direct connections to Alice ===\n>\n> Only Alice, the taker, knows the entire route, Bob and Charlie just know\n> their previous and next transactions. Bob and Charlie do not have direct\n> connections with each other, only with Alice.\n>\n> Diagram of Tor connections:\n>\n>     Bob      Charlie\n>      |       /\n>      |      /\n>      |     /\n>       Alice\n>\n> When Bob and Charlie communicate, they are actually sending and\n> receiving messages via Alice who relays them to Charlie or Bob. This\n> helps hide whether the previous or next counterparty in a CoinSwap route\n> is a maker or taker.\n>\n> This doesn't have security issues even in the final steps where private\n> keys are handed over, because those private keys are always for 2-of-2\n> multisig and so on their own are never enough to steal money.\n>\n>\n> === Miner fees ===\n>\n> Makers have no incentive to pay any miner fees. They only do\n> transactions which earn them an income and are willing to wait a very\n> long time for that to happen. By contrast takers want to create\n> transactions far more urgently. In JoinMarket we coded a protocol where\n> the maker could contribute to miner fees, but the market price offered\n> of that trended towards zero. So the reality is that takers will pay all\n> the miner fees. Also because makers don't know the taker's time\n> preference they don't know how much they should pay in miner fees.\n>\n> The taker will have to set limits on how large the maker's transactions\n> are, otherwise makers could abuse this by having the taker consolidate\n> maker's UTXOs for free.\n>\n> == Funding transaction definitions ==\n>\n> Funding transactions are those which pay into the 2-of-2 multisig\n> addresses.\n>\n> Definitions:\n> I = initial coinswap amount sent by Alice = a0 + a1 + a2\n> (WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie\n>                respectively. Could be called \"wallet Alice\", \"wallet\n>                Bob\", etc\n> (B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.\n> (M1, M2, M3) = Miner fees of the first, second, third, etc sets of\n>                funding transactions. Alice will choose what these are\n>                since she's paying.\n> multisig(A+B) = A 2of2 multisig output with private keys held by A and B\n>\n> The value in square parentheses refers to the bitcoin amount.\n>\n> Alice funding txes\n>   [WA btc] ---> multisig (Alice+Bob) [I btc]\n>                 change [WA-M1-I btc]\n> Bob funding txes\n>   [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]\n>                 change [WB-I+B btc]\n> Charlie funding txes\n>   [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]\n>                 change [WC-(I-M2-B)+C btc]\n>\n> Here we've drawn these transactions as single transactions, but they are\n> actually multiple transactions where the outputs add up some value (e.g.\n> add up to I in Alice's transactions.)\n>\n> === Table of balances before and after a successful CoinSwap ===\n>\n> If a CoinSwap is successful then all the multisig outputs in the funding\n> transactions will become controlled unilaterally by one party. We can\n> calculate how the balances of each party change.\n>\n> Party   | Before | After\n> --------|--------|-------------------------------------------\n> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C\n> Bob     | WB     | WB-I+B + I               = WB+B\n> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C\n>\n> After a successful coinswap, we see Alice's balance goes down by the\n> miner fees and the coinswap fees. Bob's and Charlie's balance goes up by\n> their coinswap fees.\n>\n> == Contract transaction definitions ==\n>\n> Contract transactions are those which may spend from the 2-of-2 multisig\n> outputs, they transfer the coins into a contract where the coins can be\n> spent either by waiting for a timeout or providing a hash preimage\n> value. Ideally contract transactions will never be broadcast but their\n> existence keeps all parties honest.\n>\n> M~ is miner fees, which we treat as a random variable, and ultimately\n> set by whichever pre-signed RBF tx get mined. When we talk about _the_\n> contract tx, we actually mean perhaps 20-30 transactions which only\n> differ by the miner fee and have RBF enabled, so they can be broadcasted\n> in sequence to get the contract transaction mined regardless of the\n> demand for block space.\n>\n> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n>                                  either with Alice's private key\n>                                  after waiting for a relative\n>                                  timelock_A, or by Bob's private key by\n>                                  revealing a hash preimage value\n>\n> Alice contract tx:\n>     multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n>     [I btc]                   [I-M~ btc]\n> Bob contract tx:\n>     multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n>     [I-M2-B btc]                [I-M2-B-M~ btc]\n> Charlie contract tx:\n>     multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)\n>     [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]\n>\n>\n> === Table of balances before/after CoinSwap using contracts transactions\n> ===\n>\n> In this case the parties had to get their money back by broadcasting and\n> mining the contract transactions and waiting for timeouts.\n>\n> Party   | Before | After\n> --------|--------|--------------------------------------------\n> Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~\n> Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~\n> Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~\n>\n> In the timeout failure case, every party pays for their own miner fees.\n> And nobody earns or spends any coinswap fees. So even for a market maker\n> its possible for their wallet balance to go down sometimes, although as\n> we shall see there are anti-DOS features which make this unlikely to\n> happen often.\n>\n> A possible attack by a malicious Alice is that she chooses M1 to be very\n> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n> sat/vb) and then intentionally aborts, forcing the makers to lose much\n> more money in miner fees than the attacker. The attack can be used to\n> waste away Bob's and Charlie's coins on miner fees at little cost to the\n> malicious taker Alice. So to defend against this attack Bob and Charlie\n> must refuse to sign a contract transaction if the corresponding funding\n> transaction pays miner fees greater than Alice's funding transaction.\n>\n>\n> There can also be a failure case where each party gets their money using\n> hash preimage values instead of timeouts. Note that each party has to\n> sweep the output before the timeout expires, so that will cost an\n> additional miner fee M~.\n>\n> Party   | Before | After\n> --------|--------|------------------------------------------------------\n> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~\n> Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~\n> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~\n>\n> In this situation the makers Bob and Charlie earn their CoinSwap fees,\n> but they pay an additional miner fee twice. Alice pays for all the\n> funding transaction miner fees, and the CoinSwap fees, and two\n> additional miner fees. And she had her privacy damaged because the\n> entire world saw on the blockchain the contract script.\n>\n> Using the timelock path is like a refund, everyone's coin just comes\n> back to them. Using the preimage is like the CoinSwap transaction\n> happened, with the coins being sent ahead one hop. Again note that if\n> the preimage is used then coinswap fees are paid.\n>\n> === Staggered timelocks ===\n>\n> The timelocks are staggered so that if Alice uses the preimage to take\n> coins then the right people will also learn the preimage and have enough\n> time to be able to get their coins back too. Alice starts with knowledge\n> of the hash preimage so she must have a longest timelock.\n>\n> == EC tweak to reduce one round trip ==\n>\n> When two parties are agreeing on a 2-of-2 multisig address, they need to\n> agree on their public keys. We can avoid one round trip by using the EC\n> tweak trick.\n>\n> When Alice, the taker, downloads the entire offer book for the liquidity\n> market, the offers will also contain a EC public key. Alice can tweak\n> this to generate a brand new public key for which the maker knows the\n> private key. This public key will be one of the keys in the 2-of-2\n> multisig. This feature removes one round trip from the protocol.\n>\n>     q = EC privkey generated by maker\n>     Q = q.G = EC pubkey published by maker\n>\n>     p = nonce generated by taker\n>     P = p.G = nonce point calculated by taker\n>\n>     R = Q + P = pubkey used in bitcoin transaction\n>       = (q + p).G\n>\n> Taker sends unsigned transaction which pays to multisig using pubkey Q,\n> and also sends nonce p. The maker can use nonce p to calculate (q + p)\n> which is the private key of pubkey R.\n>\n> Taker doesnt know the privkey because they are unable to find q because\n> of the ECDLP.\n>\n> Any eavesdropper can see the nonce p and easily calculate the point R\n> too but Tor communication is encrypted so this isnt a concern.\n>\n> None of the makers in the route know each other's Q values, so Alice the\n> taker will generate a nonce p on their behalf and send it over. I\n> believe this cant be used for any kind of attack, because the signing\n> maker will always check that the nonce results in the public key\n> included in the transaction they're signing, and they'll never sign a\n> transaction not in their interests.\n>\n>\n> == Protocol ==\n>\n> This section is the most important part of this document.\n>\n> Definitions:\n> fund = all funding txes (remember in this multi-tx protocol there can be\n>        multiple txes which together make up the funding)\n> A htlc = all htlc contract txes (fully signed) belonging to party A\n> A unsign htcl = all unsigned htlc contract txes belonging to party A\n>                 including the nonce point p used to calculate the\n>                 maker's pubkey.\n> p = nonce point p used in the tweak EC protocol for calculating the\n>     maker's pubkey\n> A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc\n>              contract tx\n> privA(A+B) = private key generated by Alice in the output\n>              multisig (Alice+Bob)\n>\n>\n>  | Alice           | Bob             | Charlie         |\n>  |=================|=================|=================|\n> 0. A unsign htlc ---->               |                 |\n> 1.               <---- A htlc B/2    |                 |\n> 2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |\n> 3. A fund+htlc+p ---->               |                 |\n> 4.                 | B unsign htlc ---->               |\n> 5.                 |               <---- B htlc C/2    |\n> 6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |\n> 7.                 | B fund+htlc+p ---->               |\n> 8.               <---------------------- C unsign htlc |\n> 9.    C htlc A/2 ---------------------->               |\n> A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |\n> B.               <---------------------- C fund+htlc+p |\n> C. hash preimage ---------------------->               |\n> D. hash preimage ---->               |                 |\n> E.    privA(A+B) ---->               |                 |\n> F.                 |    privB(B+C) ---->               |\n> G.               <---------------------- privC(C+A)    |\n>\n> == Protocol notes ==\n> 0-2 are the steps which setup Alice's funding tx and her contract tx for\n>     possible refund\n> 4-5 same as 0-2 but for Bob\n> 8-9 same as 0-2 but for Charlie\n> 3,7 is proof to the next party that the previous party has already\n>     committed miner fees to getting a transaction mined, and therefore\n>     this isnt a DOS attack. The step also reveals the fully-signed\n>     contract transaction which the party can use to get their money back\n>     with a preimage.\n> C-G is revealing the hash preimage to all, and handing over the private\n>     keys\n>\n>\n> == Analysis of aborts ==\n>\n> We will now discuss aborts, which happen when one party halts the\n> protocol and doesnt continue. Perhaps they had a power cut, their\n> internet broke, or they're a malicious attacker wanting to waste time\n> and money. The other party may try to reestablish a connection for some\n> time, but eventually must give up.\n>\n> Number refers to the step number where the abort happened\n> e.g. step 1 means that the party aborted instead of the action happening\n> on protocol step 1.\n>\n> The party name refers to what that party does\n> e.g. Party1: aborts, Party2/Party3: does a thing in reaction\n>\n> 0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or\n>    money\n> 1. Bob: aborts. Alice: lost no time or money, try with another Bob.\n>    Charlie: do nothing\n> 2-3. same as 0.\n> 4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx\n>    and waits for the timeout, loses time and money on miner fees, she'll\n>    never coinswap with Bob's fidelity bond again.\n> 5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to\n>    coinswap with.\n> 6. same as 4.\n> 7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,\n>    because Bob will also have to broadcast his contract tx and will also\n>    lose time and money.\n> 8. Charlie: aborts. Bob: broadcast his contract transaction and wait for\n>    the timeout to get his money back, also broadcast Alice's contract\n>    transaction in retaliation. Alice: waits for the timeout on her htlc\n>    tx that Bob broadcasted, will never do a coinswap with Charlie's\n>    fidelity bond again.\n> 9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:\n>    broadcast bob contract tx and wait for timeout to get money back,\n>    comforted by the knowledge that when Alice comes back online she'll\n>    have to do the same thing and waste the same amount of time and\n>    money.\n> A-B. same as 8.\n> C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and\n>      wait for the timeout to get their money back, or if Charlie knows\n>      the preimage he uses it to get the money immediately, which Bob can\n>      read from the blockchain and also use.\n> F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get\n>    money immediately, Alice blacklists Bob's fidelity bond. Charlie:\n>    broadcast Bob htlc and use preimage to get money immediately.\n> G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to\n>    get money immediately, Alice blacklists Charlie's fidelity bond. Bob:\n>    does nothing, already has his privkey.\n>\n> ==== Retaliation as DOS-resistance ====\n>\n> In some situations (e.g. step 8.) if one maker in the coinswap route is\n> the victim of a DOS they will retaliate by DOSing the previous maker in\n> the route. This may seem unnecessary and unfair (after all why waste\n> even more time and block space) but is actually the best way to resist\n> DOS because it produces a concrete cost every time a DOS happens.\n>\n>\n> == Analysis of deviations ==\n>\n> This section discusses what happens if one party deviates from the\n> protocol by doing something else, for example broadcasting a htlc\n> contract tx when they shouldnt have.\n>\n> The party name refers to what that party does, followed by other party's\n> reactions to it.\n> e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n>\n> If multiple deviations are possible in a step then they are numbered\n> e.g. A1 A2 A2 etc\n>\n>\n> 0-2. Alice/Bob/Charlie: nothing else is possible except following the\n>      protocol or aborting\n> 3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n>    do nothing, they havent lost any time or money.\n> 4-6. Bob/Charlie: nothing else is possible except following the protocol\n>      or aborting.\n> 7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n>    her own A htlc txes and waits for the timeout to get her money back.\n>    Charlie: do nothing\n> 8. Charlie: nothing else is possible except following the protocol or\n>    aborting.\n> 9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n>    his own A htlc txes and waits for the timeout.\n> A. same as 8.\n> B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n>    broadcasts all their own htlc txes and waits for the timeout to get\n>    their money back.\n> C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n>       preimage hash to take the money immediately. Charlie: broadcasts\n>       all of B htlc txes and reading the hash value from the blockchain,\n>       uses it to take the money from B htlc immediately. Bob: broadcasts\n>       all of A htlc txes, and reading hash from the blockchain, uses it\n>       to take the money from A htlc immediately.\n> C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n>       money. Bob: broadcast his own B htlc txes and after the timeout\n>       take their money. Charlie: broadcast his own C htlc txes and after\n>       the timeout take their money.\n> F1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n>     to get the money immediately. He already knows both privkeys of the\n>     multisig so this is pointless and just damages privacy and wastes\n>     miner fees. Alice: blacklist Bob's fidelity bond.\n> F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n>     to get his money immediately. Bob's actions were pointless. Alice:\n>     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n>     both fidelity bonds.\n> G1. Charlie: broadcast one or more of B htcl txes and use the hash\n>     preimage to get the money immediately. He already knows both\n>     privkeys of the multisig so this is pointless and just damages\n>     privacy and wastes miner fees. Alice: cant tell whether Bob or\n>     Charlie actually broadcasted, so blacklist both fidelity bonds.\n> G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n>     the remaining A htlc txes and use preimage to get her money\n>     immediately. Charlies's actions were pointless. Alice: blacklist\n>     Charlie's fidelity bond.\n>\n> The multisig outputs of the funding transactions can stay unspent\n> indefinitely. However the parties must always be watching the network\n> and ready to respond with their own sweep using a preimage. This is\n> because the other party still possesses a fully-signed contract tx. The\n> parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n> reaction of blacklisting both fidelity bonds might not be the right way,\n> because one maker could use it to get another one blacklisted (as well\n> as themselves).\n>\n>\n> == Conclusion ==\n>\n> This document describes the first version of the protocol which\n> implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,\n> a liquidity market and private key handover. I describe the protocol and\n> also analyze aborts of the protocols and deviations from the protocol.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/758a5361/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-25T03:16:05",
                "message_text_only": "Good morning Antoine,\n\n\n> Note, I think this is independent of picking up either relative or absolute timelocks as what matters is the block delta between two links.\n\nI believe it is quite dependent on relative locktimes.\nRelative locktimes *require* a contract transaction to kick off the relative locktime period.\nOn the other hand, with Scriptless Script (which we know how to do with 2p-ECDSA only, i.e. doable pre-Taproot), absolute locktimes do not need a contract transaction.\n\nWith absolute locktimes + Scriptless SCript, in a single onchain PTLC, one participant holds a completely-signed timelock transaction while the other participant holds a completely-signed pointlock transaction.\nThis can be arranged by having one side offer partial signatures for the transaction of the other, and once completing the signature, not sharing it with the other until we are ready to actually broadcast the transaction of our own volition.\nThere is no transaction that both participants hold in completely-signed form.\n\nThis should remove most of the shenanigans possible, and makes the 30xRBF safe for any range of fees.\nI think.\n\nSince for each PTLC a participant holds only its \"own\" transaction, it is possible for a participant to define its range of fees for the RBF versions of the transaction it owns, without negotiation with the other participant.\nSince the fee involved is deducted from its own transaction, each participant can define this range of RBFed fees and impose it on the partial signatures it gets from the other participant.\n\n--\n\nPrivate key turnover is still useful even in an absolute-timelock world.\n\nIf we need to bump up the block delta between links, it might be impractical to have the total delta of a multi-hop swap be too long at the taker.\n\nAs a concrete example, suppose A is a taker who wants to route over makers B and C.\nHowever, B and C require a CLTV delta of 1 week.\n\nIf A wants to route \"directly\" A->B->C->A, then if something bad happens, it could be looking at having its funds locked for two weeks.\n\nTo reduce this risk, A can instead first swap A->B->A, then when that completes, A->C->A.\nThis limits its funding lockup to 1 week.\n\nPrivate key turnover is useful since as soon as the A->B->A swap completes, it can directly fund the A->C->A swap from the B-side funding transaction of the A->B->A swap.\n\n         |   A->B->A         |    A->C->A           |\n         :                   :                      :\n      A -:->funding A&B--> B :                      :\n         :                   :                      :\n      B -:->funding A&B -----:--> funding A&C --> C :\n         :                   :                      :\n         :                   :C-> funding A&C ------:-> to-cold  A -->\n         :                   :                      :\n\nThis increases the number of transactions by 1 per swap beyond the first, compared to a direct routing A->B->C->A, but this may be worth it for A if the timelocks involved are too big for A.\n\nWith 2p-ECDSA, a funding A&C looks exactly the same as a to-cold A, so B is unable to reliably determine if it is the last hop in the route.\n\nWithout private key turnover, A would have:\n\n                      **NO** private key turnover!\n\n         |   A->B->A         |    A->C->A                      |\n         :                   :                                 :\n      A -:->funding A&B--> B :                                 :\n         :                   :                                 :\n      B -:->funding A&B -----:--> claim A -> funding A&C --> C :\n         :                   :                                 :\n         :                   :           C-> funding A&C ------:-> to-cold  A -->\n         :                   :                                 :\n\nSo if timelock-deltas are possibly-high (to reduce the probability of the MAD-HTLC argument, and other attacks, succeeding), takers might prefer to route by completing one swap first before starting the next one, and private key turnover is useful by reducing blockspace required by each hop.\n\nFor reference, this is how it looks like with a single A->B->C->A swap with private key turnover:\n\n         |   A->B->C->A      |\n         :                   :\n      A -:->funding A&B--> B :\n         :                   :\n      B -:->funding B&C -> C :\n         :                   :\n      C -:->funding A&C -----:-> to-cold A -->\n         :                   :\n\nThis is still smaller than in the A->B->A, A->C->A with private key turnover, by one funding tx per hop.\nHowever, A risks a much higher timelock (twice the timelock).\nThus, A might prefer a lower timelock in exchange for paying for an additional transaction.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2020-08-29T22:03:09",
                "message_text_only": "Hello Antoine,\n\nThanks for the very useful insights.\n\nIt seems having just one contract transaction which includes anchor\noutputs in the style already used by Lightning is one way to fix both\nthese vulnerabilities.\n\nFor the first attack, the other side cannot burn the entire balance\nbecause they only have access to the small amount of satoshi of the\nanchor output, and to add miner fees they must add their own inputs. So\nthey'd burn their own coins to miner fees, not the coins in the contract.\n\nFor the second attack, the other side cannot do transaction pinning\nbecause there is only one contract transaction, and all the protections\nalready developed for use with Lightning apply here as well, such as\nCPFP carve out.\n\n\nAnother possible fix for both vulnerabilities is to separate the\ntimelock and hashlock cases into two separate transactions as described\nby ZmnSCPxj in a recent email to this list. This comes at the cost of\nbreaking private key handover allowing coins to remain unspent indefinitely.\n\nAnother possible fix for the second attack, is to encumber the output\nwith a `1 OP_CSV` which stops that output being spent while unconfirmed.\nThis seems to be the simplest way if your aim is to only fix the second\nattack.\n\n\nThese are all the possible fixes I can think of.\n\nRegards\nChris\n\nOn 24/08/2020 20:30, Antoine Riard wrote:\n> Hello Chris,\n> \n> I think you might have vulnerability issues with the current design.\n> \n> With regards to the fee model for contract transactions, AFAICT timely\n> confirmation is a fund safety matter for an intermediate hop. Between the\n> offchain preimage reveal phase and the offchain private key handover phase,\n> the next hop can broadcast your outgoing contract transactions, thus\n> forcing you to claim quickly backward as you can't assume previous hop will\n> honestly cooperate to achieve the private key handover. This means that\n> your range of pre-signed RBF-transactions must theoretically have for fee\n> upper bound the maximum of the contested balance, as game-theory side, it's\n> rational to you to burn your balance instead of letting your counterparty\n> claim it after timelock expiration, in face of mempool congestion. Where\n> the issue dwells is that this fee is pre-committed and not cancelled when\n> the balance change of ownership by the outgoing hop learning the preimage\n> of the haslock output. Thus the previous hop is free to broadcast the\n> highest-fee RBF-transactions and burn your balance, as for him, his balance\n> is now encoded in the output of the contract transactions on the previous\n> link, for which he knows the preimage.\n> \n> Note, I think this is independent of picking up either relative or absolute\n> timelocks as what matters is the block delta between two links. Of course\n> you can increase this delta to be week-lengthy and thus decrease the need\n> for a compelling fee but a) you may force quickly close with contract\n> transactions if the private key handover doesn't happen soon, you don't\n> want to be caught by surprise by congestion so you would close far behind\n> delta period expiration like half of it, and b) you increase the time-value\n> of makers funds in case of faulty hop, thus logically increasing the maker\n> fee and making the cost of the system higher in average. I guess a better\n> solution would be to use dual-anchor outputs has spec'ed out by Lightning,\n> it lets the party who has a balance at stake unilaterally increase feerate\n> with a CPFP. The CPFP is obviously a higher blockchain cost but a) it's a\n> safety mechanism for a worst-case scenario, 99% of the time they won't be\n> committed, b) you might use this CPFP to aggregate change outputs or other\n> opportunistically side-usage.\n> \n> With regards to the preimage release phase, I think you might have a\n> pinning scenario. The victim would be an intermediate hop, targeted by a\n> malicious taker. The preimage isn't revealed offchain to this victim hop. A\n> low-feerate version of the outgoing contract transaction is broadcast and\n> not going to confirm, assuming a bit of congestion. As preimage is known,\n> the malicious taker can directly attach a high-fee, low-feerate child\n> transaction and thus prevent any replacement of the pinned parent by a\n> honest broadcast of a high-fee RBF-transaction under BIP 125 rules. At the\n> same time, the malicious taker broadcasts the contract tx on the previous\n> link and gets it confirmed. At relative timelock expiration, malicious\n> taker claims back the funds. When the pinned transaction spending the\n> outgoing link gets evicted (either by replacing child by a higher feerate\n> or waiting for mempool expiration after 2 weeks), taker gets it confirmed\n> this time and claims output through hashlock. Given the relative timelock\n> blocking the victim, there is not even a race.\n> \n> I guess restraining the contract transaction to one and only one version\n> would overcome this attack. A honest intermediate hop, as soon as seeing a\n> relative timelock triggered backward would immediately broadcast the\n> outgoing link contract tx or if it's already in network mempools broadcast\n> a higher-feerate child. As you don't have valid multiple contract\n> transactions, an attacker can't obstruct you to propagate the correct\n> child, as you are not blind about the parent txid.\n> \n> Lastly, one downside of using relative timelocks, in case of one downstream\n> link failure, it forces every other upstream hops to go onchain to protect\n> against this kind of pinning scenario. And this would be a privacy\n> breakdown, as a maker would be able to provoke one, thus constraining every\n> upstream hops to go onchain with the same hash and revealing the CoinSwap\n> route.\n> \n> Let me know if I reviewed the correct transactions circuit model or\n> misunderstood associated semantic. I might be completely wrong, coming from\n> a LN perspective.\n> \n> Cheers,\n> Antoine\n> \n> Le mar. 11 ao\u00fbt 2020 \u00e0 13:06, Chris Belcher via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n> \n>> I'm currently working on implementing CoinSwap (see my other email\n>> \"Design for a CoinSwap implementation for massively improving Bitcoin\n>> privacy and fungibility\").\n>>\n>> CoinSwaps are special because they look just like regular bitcoin\n>> transactions, so they improve the privacy even for people who do not use\n>> them. Once CoinSwap is deployed, anyone attempting surveillance of\n>> bitcoin transactions will be forced to ask themselves the question: how\n>> do we know this transaction wasn't a CoinSwap?\n>>\n>> This email contains a detailed design of the first protocol version. It\n>> makes use of the building blocks of multi-transaction CoinSwaps, routed\n>> CoinSwaps, liquidity market, private key handover, and fidelity bonds.\n>> It does not include PayJoin-with-CoinSwap, but that's in the plan to be\n>> added later.\n>>\n>> == Routed CoinSwap ==\n>>\n>> Diagram of CoinSwaps in the route:\n>>\n>>     Alice ====> Bob ====> Charlie ====> Alice\n>>\n>> Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives\n>> coins to Charlie, who gives coins to Alice. Alice is the market taker\n>> and she starts with the hash preimage. She chooses the CoinSwap amount\n>> and chooses who the makers will be.\n>>\n>> This design has one market taker and two market makers in its route, but\n>> it can easily be extended to any number of makers.\n>>\n>> == Multiple transactions ==\n>>\n>> Each single CoinSwap is made up of multiple transactions to avoid amount\n>> correlation\n>>\n>>           (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->\n>>     Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice\n>>           (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->\n>>\n>> The arrow (--->) represent funding transactions. The money gets paid to\n>> a 2-of-2 multisig but after the CoinSwap protocol and private key\n>> handover is done they will be controlled by the next party in the route.\n>>\n>> This example has 6 regular-sized transactions which use approximately\n>> the same amount of block space as a single JoinMarket coinjoin with 6\n>> parties (1 taker, 5 makers). Yet the privacy provided by this one\n>> CoinSwap would be far far greater. It would not have to be repeated in\n>> the way that Equal-Output CoinJoins must be.\n>>\n>> == Direct connections to Alice ===\n>>\n>> Only Alice, the taker, knows the entire route, Bob and Charlie just know\n>> their previous and next transactions. Bob and Charlie do not have direct\n>> connections with each other, only with Alice.\n>>\n>> Diagram of Tor connections:\n>>\n>>     Bob      Charlie\n>>      |       /\n>>      |      /\n>>      |     /\n>>       Alice\n>>\n>> When Bob and Charlie communicate, they are actually sending and\n>> receiving messages via Alice who relays them to Charlie or Bob. This\n>> helps hide whether the previous or next counterparty in a CoinSwap route\n>> is a maker or taker.\n>>\n>> This doesn't have security issues even in the final steps where private\n>> keys are handed over, because those private keys are always for 2-of-2\n>> multisig and so on their own are never enough to steal money.\n>>\n>>\n>> === Miner fees ===\n>>\n>> Makers have no incentive to pay any miner fees. They only do\n>> transactions which earn them an income and are willing to wait a very\n>> long time for that to happen. By contrast takers want to create\n>> transactions far more urgently. In JoinMarket we coded a protocol where\n>> the maker could contribute to miner fees, but the market price offered\n>> of that trended towards zero. So the reality is that takers will pay all\n>> the miner fees. Also because makers don't know the taker's time\n>> preference they don't know how much they should pay in miner fees.\n>>\n>> The taker will have to set limits on how large the maker's transactions\n>> are, otherwise makers could abuse this by having the taker consolidate\n>> maker's UTXOs for free.\n>>\n>> == Funding transaction definitions ==\n>>\n>> Funding transactions are those which pay into the 2-of-2 multisig\n>> addresses.\n>>\n>> Definitions:\n>> I = initial coinswap amount sent by Alice = a0 + a1 + a2\n>> (WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie\n>>                respectively. Could be called \"wallet Alice\", \"wallet\n>>                Bob\", etc\n>> (B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.\n>> (M1, M2, M3) = Miner fees of the first, second, third, etc sets of\n>>                funding transactions. Alice will choose what these are\n>>                since she's paying.\n>> multisig(A+B) = A 2of2 multisig output with private keys held by A and B\n>>\n>> The value in square parentheses refers to the bitcoin amount.\n>>\n>> Alice funding txes\n>>   [WA btc] ---> multisig (Alice+Bob) [I btc]\n>>                 change [WA-M1-I btc]\n>> Bob funding txes\n>>   [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]\n>>                 change [WB-I+B btc]\n>> Charlie funding txes\n>>   [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]\n>>                 change [WC-(I-M2-B)+C btc]\n>>\n>> Here we've drawn these transactions as single transactions, but they are\n>> actually multiple transactions where the outputs add up some value (e.g.\n>> add up to I in Alice's transactions.)\n>>\n>> === Table of balances before and after a successful CoinSwap ===\n>>\n>> If a CoinSwap is successful then all the multisig outputs in the funding\n>> transactions will become controlled unilaterally by one party. We can\n>> calculate how the balances of each party change.\n>>\n>> Party   | Before | After\n>> --------|--------|-------------------------------------------\n>> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C\n>> Bob     | WB     | WB-I+B + I               = WB+B\n>> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C\n>>\n>> After a successful coinswap, we see Alice's balance goes down by the\n>> miner fees and the coinswap fees. Bob's and Charlie's balance goes up by\n>> their coinswap fees.\n>>\n>> == Contract transaction definitions ==\n>>\n>> Contract transactions are those which may spend from the 2-of-2 multisig\n>> outputs, they transfer the coins into a contract where the coins can be\n>> spent either by waiting for a timeout or providing a hash preimage\n>> value. Ideally contract transactions will never be broadcast but their\n>> existence keeps all parties honest.\n>>\n>> M~ is miner fees, which we treat as a random variable, and ultimately\n>> set by whichever pre-signed RBF tx get mined. When we talk about _the_\n>> contract tx, we actually mean perhaps 20-30 transactions which only\n>> differ by the miner fee and have RBF enabled, so they can be broadcasted\n>> in sequence to get the contract transaction mined regardless of the\n>> demand for block space.\n>>\n>> (Alice+timelock_A OR Bob+hash) = Is an output which can be spent\n>>                                  either with Alice's private key\n>>                                  after waiting for a relative\n>>                                  timelock_A, or by Bob's private key by\n>>                                  revealing a hash preimage value\n>>\n>> Alice contract tx:\n>>     multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)\n>>     [I btc]                   [I-M~ btc]\n>> Bob contract tx:\n>>     multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)\n>>     [I-M2-B btc]                [I-M2-B-M~ btc]\n>> Charlie contract tx:\n>>     multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)\n>>     [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]\n>>\n>>\n>> === Table of balances before/after CoinSwap using contracts transactions\n>> ===\n>>\n>> In this case the parties had to get their money back by broadcasting and\n>> mining the contract transactions and waiting for timeouts.\n>>\n>> Party   | Before | After\n>> --------|--------|--------------------------------------------\n>> Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~\n>> Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~\n>> Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~\n>>\n>> In the timeout failure case, every party pays for their own miner fees.\n>> And nobody earns or spends any coinswap fees. So even for a market maker\n>> its possible for their wallet balance to go down sometimes, although as\n>> we shall see there are anti-DOS features which make this unlikely to\n>> happen often.\n>>\n>> A possible attack by a malicious Alice is that she chooses M1 to be very\n>> low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000\n>> sat/vb) and then intentionally aborts, forcing the makers to lose much\n>> more money in miner fees than the attacker. The attack can be used to\n>> waste away Bob's and Charlie's coins on miner fees at little cost to the\n>> malicious taker Alice. So to defend against this attack Bob and Charlie\n>> must refuse to sign a contract transaction if the corresponding funding\n>> transaction pays miner fees greater than Alice's funding transaction.\n>>\n>>\n>> There can also be a failure case where each party gets their money using\n>> hash preimage values instead of timeouts. Note that each party has to\n>> sweep the output before the timeout expires, so that will cost an\n>> additional miner fee M~.\n>>\n>> Party   | Before | After\n>> --------|--------|------------------------------------------------------\n>> Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~\n>> Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~\n>> Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~\n>>\n>> In this situation the makers Bob and Charlie earn their CoinSwap fees,\n>> but they pay an additional miner fee twice. Alice pays for all the\n>> funding transaction miner fees, and the CoinSwap fees, and two\n>> additional miner fees. And she had her privacy damaged because the\n>> entire world saw on the blockchain the contract script.\n>>\n>> Using the timelock path is like a refund, everyone's coin just comes\n>> back to them. Using the preimage is like the CoinSwap transaction\n>> happened, with the coins being sent ahead one hop. Again note that if\n>> the preimage is used then coinswap fees are paid.\n>>\n>> === Staggered timelocks ===\n>>\n>> The timelocks are staggered so that if Alice uses the preimage to take\n>> coins then the right people will also learn the preimage and have enough\n>> time to be able to get their coins back too. Alice starts with knowledge\n>> of the hash preimage so she must have a longest timelock.\n>>\n>> == EC tweak to reduce one round trip ==\n>>\n>> When two parties are agreeing on a 2-of-2 multisig address, they need to\n>> agree on their public keys. We can avoid one round trip by using the EC\n>> tweak trick.\n>>\n>> When Alice, the taker, downloads the entire offer book for the liquidity\n>> market, the offers will also contain a EC public key. Alice can tweak\n>> this to generate a brand new public key for which the maker knows the\n>> private key. This public key will be one of the keys in the 2-of-2\n>> multisig. This feature removes one round trip from the protocol.\n>>\n>>     q = EC privkey generated by maker\n>>     Q = q.G = EC pubkey published by maker\n>>\n>>     p = nonce generated by taker\n>>     P = p.G = nonce point calculated by taker\n>>\n>>     R = Q + P = pubkey used in bitcoin transaction\n>>       = (q + p).G\n>>\n>> Taker sends unsigned transaction which pays to multisig using pubkey Q,\n>> and also sends nonce p. The maker can use nonce p to calculate (q + p)\n>> which is the private key of pubkey R.\n>>\n>> Taker doesnt know the privkey because they are unable to find q because\n>> of the ECDLP.\n>>\n>> Any eavesdropper can see the nonce p and easily calculate the point R\n>> too but Tor communication is encrypted so this isnt a concern.\n>>\n>> None of the makers in the route know each other's Q values, so Alice the\n>> taker will generate a nonce p on their behalf and send it over. I\n>> believe this cant be used for any kind of attack, because the signing\n>> maker will always check that the nonce results in the public key\n>> included in the transaction they're signing, and they'll never sign a\n>> transaction not in their interests.\n>>\n>>\n>> == Protocol ==\n>>\n>> This section is the most important part of this document.\n>>\n>> Definitions:\n>> fund = all funding txes (remember in this multi-tx protocol there can be\n>>        multiple txes which together make up the funding)\n>> A htlc = all htlc contract txes (fully signed) belonging to party A\n>> A unsign htcl = all unsigned htlc contract txes belonging to party A\n>>                 including the nonce point p used to calculate the\n>>                 maker's pubkey.\n>> p = nonce point p used in the tweak EC protocol for calculating the\n>>     maker's pubkey\n>> A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc\n>>              contract tx\n>> privA(A+B) = private key generated by Alice in the output\n>>              multisig (Alice+Bob)\n>>\n>>\n>>  | Alice           | Bob             | Charlie         |\n>>  |=================|=================|=================|\n>> 0. A unsign htlc ---->               |                 |\n>> 1.               <---- A htlc B/2    |                 |\n>> 2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |\n>> 3. A fund+htlc+p ---->               |                 |\n>> 4.                 | B unsign htlc ---->               |\n>> 5.                 |               <---- B htlc C/2    |\n>> 6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |\n>> 7.                 | B fund+htlc+p ---->               |\n>> 8.               <---------------------- C unsign htlc |\n>> 9.    C htlc A/2 ---------------------->               |\n>> A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |\n>> B.               <---------------------- C fund+htlc+p |\n>> C. hash preimage ---------------------->               |\n>> D. hash preimage ---->               |                 |\n>> E.    privA(A+B) ---->               |                 |\n>> F.                 |    privB(B+C) ---->               |\n>> G.               <---------------------- privC(C+A)    |\n>>\n>> == Protocol notes ==\n>> 0-2 are the steps which setup Alice's funding tx and her contract tx for\n>>     possible refund\n>> 4-5 same as 0-2 but for Bob\n>> 8-9 same as 0-2 but for Charlie\n>> 3,7 is proof to the next party that the previous party has already\n>>     committed miner fees to getting a transaction mined, and therefore\n>>     this isnt a DOS attack. The step also reveals the fully-signed\n>>     contract transaction which the party can use to get their money back\n>>     with a preimage.\n>> C-G is revealing the hash preimage to all, and handing over the private\n>>     keys\n>>\n>>\n>> == Analysis of aborts ==\n>>\n>> We will now discuss aborts, which happen when one party halts the\n>> protocol and doesnt continue. Perhaps they had a power cut, their\n>> internet broke, or they're a malicious attacker wanting to waste time\n>> and money. The other party may try to reestablish a connection for some\n>> time, but eventually must give up.\n>>\n>> Number refers to the step number where the abort happened\n>> e.g. step 1 means that the party aborted instead of the action happening\n>> on protocol step 1.\n>>\n>> The party name refers to what that party does\n>> e.g. Party1: aborts, Party2/Party3: does a thing in reaction\n>>\n>> 0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or\n>>    money\n>> 1. Bob: aborts. Alice: lost no time or money, try with another Bob.\n>>    Charlie: do nothing\n>> 2-3. same as 0.\n>> 4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx\n>>    and waits for the timeout, loses time and money on miner fees, she'll\n>>    never coinswap with Bob's fidelity bond again.\n>> 5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to\n>>    coinswap with.\n>> 6. same as 4.\n>> 7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,\n>>    because Bob will also have to broadcast his contract tx and will also\n>>    lose time and money.\n>> 8. Charlie: aborts. Bob: broadcast his contract transaction and wait for\n>>    the timeout to get his money back, also broadcast Alice's contract\n>>    transaction in retaliation. Alice: waits for the timeout on her htlc\n>>    tx that Bob broadcasted, will never do a coinswap with Charlie's\n>>    fidelity bond again.\n>> 9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:\n>>    broadcast bob contract tx and wait for timeout to get money back,\n>>    comforted by the knowledge that when Alice comes back online she'll\n>>    have to do the same thing and waste the same amount of time and\n>>    money.\n>> A-B. same as 8.\n>> C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and\n>>      wait for the timeout to get their money back, or if Charlie knows\n>>      the preimage he uses it to get the money immediately, which Bob can\n>>      read from the blockchain and also use.\n>> F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get\n>>    money immediately, Alice blacklists Bob's fidelity bond. Charlie:\n>>    broadcast Bob htlc and use preimage to get money immediately.\n>> G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to\n>>    get money immediately, Alice blacklists Charlie's fidelity bond. Bob:\n>>    does nothing, already has his privkey.\n>>\n>> ==== Retaliation as DOS-resistance ====\n>>\n>> In some situations (e.g. step 8.) if one maker in the coinswap route is\n>> the victim of a DOS they will retaliate by DOSing the previous maker in\n>> the route. This may seem unnecessary and unfair (after all why waste\n>> even more time and block space) but is actually the best way to resist\n>> DOS because it produces a concrete cost every time a DOS happens.\n>>\n>>\n>> == Analysis of deviations ==\n>>\n>> This section discusses what happens if one party deviates from the\n>> protocol by doing something else, for example broadcasting a htlc\n>> contract tx when they shouldnt have.\n>>\n>> The party name refers to what that party does, followed by other party's\n>> reactions to it.\n>> e.g. Party1: does a thing, Party2/Party3: does a thing in reaction\n>>\n>> If multiple deviations are possible in a step then they are numbered\n>> e.g. A1 A2 A2 etc\n>>\n>>\n>> 0-2. Alice/Bob/Charlie: nothing else is possible except following the\n>>      protocol or aborting\n>> 3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:\n>>    do nothing, they havent lost any time or money.\n>> 4-6. Bob/Charlie: nothing else is possible except following the protocol\n>>      or aborting.\n>> 7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all\n>>    her own A htlc txes and waits for the timeout to get her money back.\n>>    Charlie: do nothing\n>> 8. Charlie: nothing else is possible except following the protocol or\n>>    aborting.\n>> 9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all\n>>    his own A htlc txes and waits for the timeout.\n>> A. same as 8.\n>> B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:\n>>    broadcasts all their own htlc txes and waits for the timeout to get\n>>    their money back.\n>> C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the\n>>       preimage hash to take the money immediately. Charlie: broadcasts\n>>       all of B htlc txes and reading the hash value from the blockchain,\n>>       uses it to take the money from B htlc immediately. Bob: broadcasts\n>>       all of A htlc txes, and reading hash from the blockchain, uses it\n>>       to take the money from A htlc immediately.\n>> C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the\n>>       money. Bob: broadcast his own B htlc txes and after the timeout\n>>       take their money. Charlie: broadcast his own C htlc txes and after\n>>       the timeout take their money.\n>> F1. Bob: broadcast one or more of A htcl txes and use the hash preimage\n>>     to get the money immediately. He already knows both privkeys of the\n>>     multisig so this is pointless and just damages privacy and wastes\n>>     miner fees. Alice: blacklist Bob's fidelity bond.\n>> F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage\n>>     to get his money immediately. Bob's actions were pointless. Alice:\n>>     cant tell whether Bob or Charlie actually broadcasted, so blacklist\n>>     both fidelity bonds.\n>> G1. Charlie: broadcast one or more of B htcl txes and use the hash\n>>     preimage to get the money immediately. He already knows both\n>>     privkeys of the multisig so this is pointless and just damages\n>>     privacy and wastes miner fees. Alice: cant tell whether Bob or\n>>     Charlie actually broadcasted, so blacklist both fidelity bonds.\n>> G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast\n>>     the remaining A htlc txes and use preimage to get her money\n>>     immediately. Charlies's actions were pointless. Alice: blacklist\n>>     Charlie's fidelity bond.\n>>\n>> The multisig outputs of the funding transactions can stay unspent\n>> indefinitely. However the parties must always be watching the network\n>> and ready to respond with their own sweep using a preimage. This is\n>> because the other party still possesses a fully-signed contract tx. The\n>> parties respond in the same way as in steps C-E1, F2 and G2. Alice's\n>> reaction of blacklisting both fidelity bonds might not be the right way,\n>> because one maker could use it to get another one blacklisted (as well\n>> as themselves).\n>>\n>>\n>> == Conclusion ==\n>>\n>> This document describes the first version of the protocol which\n>> implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,\n>> a liquidity market and private key handover. I describe the protocol and\n>> also analyze aborts of the protocols and deviations from the protocol.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-30T13:38:11",
                "message_text_only": "Good morning Chris,\n\n> It seems having just one contract transaction which includes anchor\n> outputs in the style already used by Lightning is one way to fix both\n> these vulnerabilities.\n>\n> For the first attack, the other side cannot burn the entire balance\n> because they only have access to the small amount of satoshi of the\n> anchor output, and to add miner fees they must add their own inputs. So\n> they'd burn their own coins to miner fees, not the coins in the contract.\n\nMinimum output size is 547 sats, so anchor outputs are that amount at minimum.\nA P2SH-P2WPKH output costs something like ~130 vbytes to spend, at 1.000 sat/vbyte that is only ~130 sats to spend a 547 sat anchor output, an opportunistic camper could collect from a few swaps it would have done anyway (e.g. as a passive popular maker?) and broadcast the contract txes of those swaps and then spend the anchor outputs together to get a few sats in a not-so-dusty UTXO, getting (547 - 130) sat per input minus the cost of creating a new tiny output.\nAssuming the camper has already claimed its side of the swap in order to put it in cold, this is basically a tiny but free amount of extra money, and if small CoinJoins in JoinMarket are any indication, the 547 sats minus fee to spend it minus fee to create (amortized among the multiple contract txes) new UTXO might be comparable to the actual maker fee.\n\nSince this camping attack is done after the CoinSwap, the maker fidelity bond is a weak protection against this.\nThe maker can keep around contract transactions indefinitely, and if standard wallets assume they can leave the coins in the same UTXO indefinitely, the contract transactions remain valid indefinitely, including up to fidelity bond timeout.\nWhen the fidelity bond times out, the maker has to destroy its identity anyway, so it could opportunistically wait for a low-fee period after fidelity-bond timeout (we currently get low fee periods once a week, for example, so the camper can wait for at most a week to do this) to publish all still-valid contract transactions, and spend all the anchor outputs including the fidelity bond at the minimum feerate, getting a slightly larger fidelity bond fund, then CoinSwap it to honest makers to clean it, then make a new fidelity bond.\nAnd if one of the takers happens to not be watching for contract tx timeout, it can potentially get free money, again, from the inattention.\n\n(I call it a \"camper attack\" since the attacking CoinSwap participant waits around in a single place (maker fidelity bond) and snipes passing contract transactions to extract value from them when opportunity (low fee rate) is good, like a camper.)\n\nTo protect against this, we should force contract txes to signal RBF, make contract txes min-relay=feerate (requires CPFP package relay at base layer tho), and during low-fee periods we should collect outputs whose private key have been turned over to us, paying at a feerate slightly higher than 547 sat / 130 vbyte fee rate (at which point it becomes uneconomical for campers to mount their sniping attack as they would lose the anchor output amount to fees anyway).\n\nIn fact the wallet can do that all the time, and if prevailing fees are above the 547 / 130 rate it will not confirm and the wallet that wants to spend its funds *now* can sign a new RBF tx at higher feerate to replace it.\n\nLow fees, who would have thought that would enable an attack vector....\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Detailed protocol design for routed multi-transaction CoinSwap",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "Nadav Kohen",
                "ZmnSCPxj",
                "Antoine Riard"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 185690
        }
    },
    {
        "title": "[bitcoin-dev] Revisiting squaredness tiebreaker for R point in BIP340",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2020-08-12T18:49:56",
                "message_text_only": "Hello all,\n\nThe current BIP340 draft[1] uses two different tiebreakers for conveying the Y coordinate of points: for the R point inside signatures squaredness is used, while for public keys evenness is used. Originally both used squaredness, but it was changed[2] for public keys after observing this results in additional complexity for compatibility with existing systems.\n\nThe reason for choosing squaredness as tiebreaker was performance: in non-batch signature validation, the recomputed R point must be verified to have the correct sign, to guarantee consistency with batch validation. Whether the Y coordinate is square can be computed directly in Jacobian coordinates, while determining evenness requires a conversion to affine coordinates first.\n\nThis argument of course relies on the assumption that determining whether the Y coordinate is square can be done more efficiently than a conversion to affine coordinates. It appears now that this assumption is incorrect, and the justification for picking the squaredness tiebreaking doesn't really exist. As it comes with other trade-offs (it slows down signing, and is a less conventional choice), it would seem that we should reconsider the option of having the R point use the evenness tiebreaker (like public keys).\n\nIt is late in the process, but I feel I owe this explanation so that at least the possibility of changing can be discussed with all information. On the upside, this was discovered in the context of looking into a cool improvement to libsecp256k1[5], which makes things faster in general, but specifically benefits the evenness variant.\n\n\n# 1. What happened?\n\nComputing squaredness is done through the Jacobi symbol (same inventor, but unrelated to Jacobian coordinates). Computing evenness requires converting points to affine coordinates first, and that needs a modular inverse. The assumption that Jacobi symbols are faster to compute than inverses was based on:\n\n* A (possibly) mistaken belief about the theory: fast algorithms for both Jacobi symbols and inverses are internally based on variants of the same extended GCD algorithm[3]. Since an inverse needs to extract a full big integer out of the transition steps made in the extgcd algorithm, while the Jacobi symbol just extracts a single bit, it had seemed that any advances applicable to one would be applicable to the other, but inverses would always need additional work on top. It appears however that a class of extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi calculations without losing efficiency. Recent developments[4] and a proposed implementation in libsecp256k1[5] by Peter Dettman show that using this, inverses in some cases can in fact be faster than Jacobi symbols.\n\n* A broken benchmark. This belief was incorrectly confirmed by a broken benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation and modular inverse. The benchmark was repeatedly testing the same constant input, which apparently was around 2.5x faster than the average speed. It is a variable-time algorithm, so a good variation of inputs matters. This mistake had me (and probably others) convinced for years that Jacobi symbols were amazingly fast, while in reality they were always very close in performance to inverses.\n\n\n# 2. What is the actual impact of picking evenness instead?\n\nIt is hard to make very generic statements here, as BIP340 will hopefully be used for a long time, and hardware advancements and algorithmic improvements may change the balance. That said, performance on current hardware with optimized algorithms is the best approximation we have.\n\nThe numbers below give the expected performance change from squareness to evenness, for single BIP340 validation, and for signing. Positive numbers mean evenness is faster. Batch validation is not impacted at all.\n\nIn the short term, for block validation in Bitcoin Core, the numbers for master-nogmp are probably the most relevant (as Bitcoin Core uses libsecp256k1 without libgmp, to reduce consensus-critical dependencies). If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer time scale, the gmp numbers may be more relevant, as the Jacobi implementation there is certainly closer to the state of the art.\n\n* i7-7820HQ: (verify) (sign)\n  - master-nogmp: -0.3% +16.1%\n  - safegcd-nogmp: +6.7% +17.1%\n  - master-gmp: +0.6% +7.7%\n  - safegcd-gmp: +1.6% +8.6%\n\n* Cortex-A53: (verify) (sign)\n  - master-nogmp: -0.3% +15.7%\n  - safegcd-nogmp: +7.5% +16.9%\n  - master-gmp: +0.3% +4.1%\n  - safegcd-gmp: 0.0% +3.5%\n\n* EPYC 7742: (verify) (sign)\n  - master-nogmp: -0.3% +16.8%\n  - safegcd-nogmp: +8.6% +18.4%\n  - master-gmp: 0.0% +7.4%\n  - safegcd-gmp: +2.3% +7.8%\n\nIn well optimized cryptographic code speedups as large as a couple percent are difficult to come by, so we would usually consider changes of this magnitude relevant. Note however that while the percentages for signing speed are larger, they are not what is unexpected here. The choice for the square tiebreaker was intended to improve verification speed at the cost of signing speed. As it turns out that it doesn't actually benefit verification speed, this is a bad trade-off.\n\n\n# 3. How big a change is it\n\n* In the BIP:\n  - Changing both invocations of `has_square_y` to `has_even_y`.\n  - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.\n  - Applying the same change to the test vector generation code, and the resulting test vectors.\n* In the libsecp256k1:\n  - An 8-line patch to the proposed BIP340 implementation[7]: see [8]\n* In Bitcoin Core:\n  - Similarly small changes to the Python test reimplementation[9]\n* Duplicating these changes in other draft implementations that may already exist.\n* Review for all the above.\n\n\n# 4. Conclusion\n\nWe discovered that the justification for using squaredness tiebreakers in BIP340 is based on a misunderstanding, and recent developments show that it may in fact be a somewhat worse choice than the alternative. It is a relatively simple change to address this, but that has be weighed against the impact of changing the standard at this stage.\n\nThoughts?\n\n\n# 5. References\n\n  [1] https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design\n  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html\n  [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n  [4] https://gcd.cr.yp.to/safegcd-20190413.pdf\n  [5] https://github.com/bitcoin-core/secp256k1/pull/767\n  [6] https://github.com/bitcoin-core/secp256k1/pull/797\n  [7] https://github.com/bitcoin-core/secp256k1/pull/558\n  [8] https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6\n  [9] https://github.com/bitcoin/bitcoin/pull/17977\n\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Nadav Kohen",
                "date": "2020-08-12T20:19:01",
                "message_text_only": "Hello Pieter and all,\n\nI am one of the maintainers of Bitcoin-S[1] and I maintain our secp256k1\nbindings (via JNI) as well as our (inefficient) bouncy castle fallback\nimplementations of all secp256k1 functionality we depend on including\nSchnorr signatures. In light of this new information that there is no real\ndownside to using evenness as the nonce tie-breaker, I am personally very\nin favor of this change as it strictly simplifies things as well as making\ntypes consistent between nonces and persistent signing keys (I can get rid\nof our SchnorrNonce type :). An additional minor benefit not already\nmentioned is that in places in our codebase where deserialized data is just\nbeing passed around and not used, we currently require a computation to go\nfrom a (x-only) SchnorrNonce to an ECPublicKey whereas going from a\nSchnorrPublicKey simply requires pre-pending a 0x02 byte.\n\nI am likely not aware of the entire impact that changing the BIP at this\nstage would have but from my view (of having to update bindings and test\nvectors and my fallback implementation, as well as wanting to get a stable\nbranch on secp256k1-zkp containing both ECDSA adaptor signatures and\nSchnorr signatures for use in Discreet Log Contracts), I think this change\nis totally worth it and it will only become harder to make this\nsimplification in the future. The schnorrsig branch has not yet been merged\ninto secp256k1 (and is nearing this stage I think) and so long as making\nthis change doesn't set us back more than a month (which seems unlikely) I\nam personally in favor of making this change. Glad to hear other's thoughts\non this of course but I figured I'd voice my support :)\n\nBest,\nNadav\n\n[1] https://github.com/bitcoin-s/bitcoin-s/\n\n\n\nOn Wed, Aug 12, 2020 at 2:04 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> The current BIP340 draft[1] uses two different tiebreakers for conveying\n> the Y coordinate of points: for the R point inside signatures squaredness\n> is used, while for public keys evenness is used. Originally both used\n> squaredness, but it was changed[2] for public keys after observing this\n> results in additional complexity for compatibility with existing systems.\n>\n> The reason for choosing squaredness as tiebreaker was performance: in\n> non-batch signature validation, the recomputed R point must be verified to\n> have the correct sign, to guarantee consistency with batch validation.\n> Whether the Y coordinate is square can be computed directly in Jacobian\n> coordinates, while determining evenness requires a conversion to affine\n> coordinates first.\n>\n> This argument of course relies on the assumption that determining whether\n> the Y coordinate is square can be done more efficiently than a conversion\n> to affine coordinates. It appears now that this assumption is incorrect,\n> and the justification for picking the squaredness tiebreaking doesn't\n> really exist. As it comes with other trade-offs (it slows down signing, and\n> is a less conventional choice), it would seem that we should reconsider the\n> option of having the R point use the evenness tiebreaker (like public keys).\n>\n> It is late in the process, but I feel I owe this explanation so that at\n> least the possibility of changing can be discussed with all information. On\n> the upside, this was discovered in the context of looking into a cool\n> improvement to libsecp256k1[5], which makes things faster in general, but\n> specifically benefits the evenness variant.\n>\n>\n> # 1. What happened?\n>\n> Computing squaredness is done through the Jacobi symbol (same inventor,\n> but unrelated to Jacobian coordinates). Computing evenness requires\n> converting points to affine coordinates first, and that needs a modular\n> inverse. The assumption that Jacobi symbols are faster to compute than\n> inverses was based on:\n>\n> * A (possibly) mistaken belief about the theory: fast algorithms for both\n> Jacobi symbols and inverses are internally based on variants of the same\n> extended GCD algorithm[3]. Since an inverse needs to extract a full big\n> integer out of the transition steps made in the extgcd algorithm, while the\n> Jacobi symbol just extracts a single bit, it had seemed that any advances\n> applicable to one would be applicable to the other, but inverses would\n> always need additional work on top. It appears however that a class of\n> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi\n> calculations without losing efficiency. Recent developments[4] and a\n> proposed implementation in libsecp256k1[5] by Peter Dettman show that using\n> this, inverses in some cases can in fact be faster than Jacobi symbols.\n>\n> * A broken benchmark. This belief was incorrectly confirmed by a broken\n> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation\n> and modular inverse. The benchmark was repeatedly testing the same constant\n> input, which apparently was around 2.5x faster than the average speed. It\n> is a variable-time algorithm, so a good variation of inputs matters. This\n> mistake had me (and probably others) convinced for years that Jacobi\n> symbols were amazingly fast, while in reality they were always very close\n> in performance to inverses.\n>\n>\n> # 2. What is the actual impact of picking evenness instead?\n>\n> It is hard to make very generic statements here, as BIP340 will hopefully\n> be used for a long time, and hardware advancements and algorithmic\n> improvements may change the balance. That said, performance on current\n> hardware with optimized algorithms is the best approximation we have.\n>\n> The numbers below give the expected performance change from squareness to\n> evenness, for single BIP340 validation, and for signing. Positive numbers\n> mean evenness is faster. Batch validation is not impacted at all.\n>\n> In the short term, for block validation in Bitcoin Core, the numbers for\n> master-nogmp are probably the most relevant (as Bitcoin Core uses\n> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).\n> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer\n> time scale, the gmp numbers may be more relevant, as the Jacobi\n> implementation there is certainly closer to the state of the art.\n>\n> * i7-7820HQ: (verify) (sign)\n>   - master-nogmp: -0.3% +16.1%\n>   - safegcd-nogmp: +6.7% +17.1%\n>   - master-gmp: +0.6% +7.7%\n>   - safegcd-gmp: +1.6% +8.6%\n>\n> * Cortex-A53: (verify) (sign)\n>   - master-nogmp: -0.3% +15.7%\n>   - safegcd-nogmp: +7.5% +16.9%\n>   - master-gmp: +0.3% +4.1%\n>   - safegcd-gmp: 0.0% +3.5%\n>\n> * EPYC 7742: (verify) (sign)\n>   - master-nogmp: -0.3% +16.8%\n>   - safegcd-nogmp: +8.6% +18.4%\n>   - master-gmp: 0.0% +7.4%\n>   - safegcd-gmp: +2.3% +7.8%\n>\n> In well optimized cryptographic code speedups as large as a couple percent\n> are difficult to come by, so we would usually consider changes of this\n> magnitude relevant. Note however that while the percentages for signing\n> speed are larger, they are not what is unexpected here. The choice for the\n> square tiebreaker was intended to improve verification speed at the cost of\n> signing speed. As it turns out that it doesn't actually benefit\n> verification speed, this is a bad trade-off.\n>\n>\n> # 3. How big a change is it\n>\n> * In the BIP:\n>   - Changing both invocations of `has_square_y` to `has_even_y`.\n>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.\n>   - Applying the same change to the test vector generation code, and the\n> resulting test vectors.\n> * In the libsecp256k1:\n>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]\n> * In Bitcoin Core:\n>   - Similarly small changes to the Python test reimplementation[9]\n> * Duplicating these changes in other draft implementations that may\n> already exist.\n> * Review for all the above.\n>\n>\n> # 4. Conclusion\n>\n> We discovered that the justification for using squaredness tiebreakers in\n> BIP340 is based on a misunderstanding, and recent developments show that it\n> may in fact be a somewhat worse choice than the alternative. It is a\n> relatively simple change to address this, but that has be weighed against\n> the impact of changing the standard at this stage.\n>\n> Thoughts?\n>\n>\n> # 5. References\n>\n>   [1]\n> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design\n>   [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html\n>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf\n>   [5] https://github.com/bitcoin-core/secp256k1/pull/767\n>   [6] https://github.com/bitcoin-core/secp256k1/pull/797\n>   [7] https://github.com/bitcoin-core/secp256k1/pull/558\n>   [8]\n> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6\n>   [9] https://github.com/bitcoin/bitcoin/pull/17977\n>\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200812/e77abbbc/attachment-0001.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2020-08-13T05:31:58",
                "message_text_only": "Thanks for bringing this discovery up and a big thanks to Peter Dettman for\nworking on this.\n\nI second what Nadav said. Removing pointless complexity is worth it even at\nthis stage. I also maintain a non-libsecp implementation of BIP340 etc.\nHaving two ways to convert an xonly to a point is a pain if you are trying\nto maintain type safe apis. If there is no performance penalty (or even a\nsmall one in the short term) to unifying xonly -> point conversion it's\nworth it from my perspective.\n\nLL\n\nOn Thu, Aug 13, 2020 at 6:29 AM Nadav Kohen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Pieter and all,\n>\n> I am one of the maintainers of Bitcoin-S[1] and I maintain our secp256k1\n> bindings (via JNI) as well as our (inefficient) bouncy castle fallback\n> implementations of all secp256k1 functionality we depend on including\n> Schnorr signatures. In light of this new information that there is no real\n> downside to using evenness as the nonce tie-breaker, I am personally very\n> in favor of this change as it strictly simplifies things as well as making\n> types consistent between nonces and persistent signing keys (I can get rid\n> of our SchnorrNonce type :). An additional minor benefit not already\n> mentioned is that in places in our codebase where deserialized data is just\n> being passed around and not used, we currently require a computation to go\n> from a (x-only) SchnorrNonce to an ECPublicKey whereas going from a\n> SchnorrPublicKey simply requires pre-pending a 0x02 byte.\n>\n> I am likely not aware of the entire impact that changing the BIP at this\n> stage would have but from my view (of having to update bindings and test\n> vectors and my fallback implementation, as well as wanting to get a stable\n> branch on secp256k1-zkp containing both ECDSA adaptor signatures and\n> Schnorr signatures for use in Discreet Log Contracts), I think this change\n> is totally worth it and it will only become harder to make this\n> simplification in the future. The schnorrsig branch has not yet been merged\n> into secp256k1 (and is nearing this stage I think) and so long as making\n> this change doesn't set us back more than a month (which seems unlikely) I\n> am personally in favor of making this change. Glad to hear other's thoughts\n> on this of course but I figured I'd voice my support :)\n>\n> Best,\n> Nadav\n>\n> [1] https://github.com/bitcoin-s/bitcoin-s/\n>\n>\n>\n> On Wed, Aug 12, 2020 at 2:04 PM Pieter Wuille via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello all,\n>>\n>> The current BIP340 draft[1] uses two different tiebreakers for conveying\n>> the Y coordinate of points: for the R point inside signatures squaredness\n>> is used, while for public keys evenness is used. Originally both used\n>> squaredness, but it was changed[2] for public keys after observing this\n>> results in additional complexity for compatibility with existing systems.\n>>\n>> The reason for choosing squaredness as tiebreaker was performance: in\n>> non-batch signature validation, the recomputed R point must be verified to\n>> have the correct sign, to guarantee consistency with batch validation.\n>> Whether the Y coordinate is square can be computed directly in Jacobian\n>> coordinates, while determining evenness requires a conversion to affine\n>> coordinates first.\n>>\n>> This argument of course relies on the assumption that determining whether\n>> the Y coordinate is square can be done more efficiently than a conversion\n>> to affine coordinates. It appears now that this assumption is incorrect,\n>> and the justification for picking the squaredness tiebreaking doesn't\n>> really exist. As it comes with other trade-offs (it slows down signing, and\n>> is a less conventional choice), it would seem that we should reconsider the\n>> option of having the R point use the evenness tiebreaker (like public keys).\n>>\n>> It is late in the process, but I feel I owe this explanation so that at\n>> least the possibility of changing can be discussed with all information. On\n>> the upside, this was discovered in the context of looking into a cool\n>> improvement to libsecp256k1[5], which makes things faster in general, but\n>> specifically benefits the evenness variant.\n>>\n>>\n>> # 1. What happened?\n>>\n>> Computing squaredness is done through the Jacobi symbol (same inventor,\n>> but unrelated to Jacobian coordinates). Computing evenness requires\n>> converting points to affine coordinates first, and that needs a modular\n>> inverse. The assumption that Jacobi symbols are faster to compute than\n>> inverses was based on:\n>>\n>> * A (possibly) mistaken belief about the theory: fast algorithms for both\n>> Jacobi symbols and inverses are internally based on variants of the same\n>> extended GCD algorithm[3]. Since an inverse needs to extract a full big\n>> integer out of the transition steps made in the extgcd algorithm, while the\n>> Jacobi symbol just extracts a single bit, it had seemed that any advances\n>> applicable to one would be applicable to the other, but inverses would\n>> always need additional work on top. It appears however that a class of\n>> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi\n>> calculations without losing efficiency. Recent developments[4] and a\n>> proposed implementation in libsecp256k1[5] by Peter Dettman show that using\n>> this, inverses in some cases can in fact be faster than Jacobi symbols.\n>>\n>> * A broken benchmark. This belief was incorrectly confirmed by a broken\n>> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation\n>> and modular inverse. The benchmark was repeatedly testing the same constant\n>> input, which apparently was around 2.5x faster than the average speed. It\n>> is a variable-time algorithm, so a good variation of inputs matters. This\n>> mistake had me (and probably others) convinced for years that Jacobi\n>> symbols were amazingly fast, while in reality they were always very close\n>> in performance to inverses.\n>>\n>>\n>> # 2. What is the actual impact of picking evenness instead?\n>>\n>> It is hard to make very generic statements here, as BIP340 will hopefully\n>> be used for a long time, and hardware advancements and algorithmic\n>> improvements may change the balance. That said, performance on current\n>> hardware with optimized algorithms is the best approximation we have.\n>>\n>> The numbers below give the expected performance change from squareness to\n>> evenness, for single BIP340 validation, and for signing. Positive numbers\n>> mean evenness is faster. Batch validation is not impacted at all.\n>>\n>> In the short term, for block validation in Bitcoin Core, the numbers for\n>> master-nogmp are probably the most relevant (as Bitcoin Core uses\n>> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).\n>> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer\n>> time scale, the gmp numbers may be more relevant, as the Jacobi\n>> implementation there is certainly closer to the state of the art.\n>>\n>> * i7-7820HQ: (verify) (sign)\n>>   - master-nogmp: -0.3% +16.1%\n>>   - safegcd-nogmp: +6.7% +17.1%\n>>   - master-gmp: +0.6% +7.7%\n>>   - safegcd-gmp: +1.6% +8.6%\n>>\n>> * Cortex-A53: (verify) (sign)\n>>   - master-nogmp: -0.3% +15.7%\n>>   - safegcd-nogmp: +7.5% +16.9%\n>>   - master-gmp: +0.3% +4.1%\n>>   - safegcd-gmp: 0.0% +3.5%\n>>\n>> * EPYC 7742: (verify) (sign)\n>>   - master-nogmp: -0.3% +16.8%\n>>   - safegcd-nogmp: +8.6% +18.4%\n>>   - master-gmp: 0.0% +7.4%\n>>   - safegcd-gmp: +2.3% +7.8%\n>>\n>> In well optimized cryptographic code speedups as large as a couple\n>> percent are difficult to come by, so we would usually consider changes of\n>> this magnitude relevant. Note however that while the percentages for\n>> signing speed are larger, they are not what is unexpected here. The choice\n>> for the square tiebreaker was intended to improve verification speed at the\n>> cost of signing speed. As it turns out that it doesn't actually benefit\n>> verification speed, this is a bad trade-off.\n>>\n>>\n>> # 3. How big a change is it\n>>\n>> * In the BIP:\n>>   - Changing both invocations of `has_square_y` to `has_even_y`.\n>>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.\n>>   - Applying the same change to the test vector generation code, and the\n>> resulting test vectors.\n>> * In the libsecp256k1:\n>>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]\n>> * In Bitcoin Core:\n>>   - Similarly small changes to the Python test reimplementation[9]\n>> * Duplicating these changes in other draft implementations that may\n>> already exist.\n>> * Review for all the above.\n>>\n>>\n>> # 4. Conclusion\n>>\n>> We discovered that the justification for using squaredness tiebreakers in\n>> BIP340 is based on a misunderstanding, and recent developments show that it\n>> may in fact be a somewhat worse choice than the alternative. It is a\n>> relatively simple change to address this, but that has be weighed against\n>> the impact of changing the standard at this stage.\n>>\n>> Thoughts?\n>>\n>>\n>> # 5. References\n>>\n>>   [1]\n>> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design\n>>   [2]\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html\n>>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n>>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf\n>>   [5] https://github.com/bitcoin-core/secp256k1/pull/767\n>>   [6] https://github.com/bitcoin-core/secp256k1/pull/797\n>>   [7] https://github.com/bitcoin-core/secp256k1/pull/558\n>>   [8]\n>> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6\n>>   [9] https://github.com/bitcoin/bitcoin/pull/17977\n>>\n>>\n>> Cheers,\n>>\n>> --\n>> Pieter\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200813/45cce79a/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-08-19T23:16:17",
                "message_text_only": "On Wednesday, August 12, 2020 11:49 AM, Pieter Wuille <bitcoin-dev at wuille.net> wrote:\n\n> It is late in the process, but I feel I owe this explanation so that at least the possibility of changing can be discussed with all information.\n\nAs the responses have been pretty positive so far, we've gone ahead and made a patch to implement the change to the even tiebreaker: https://github.com/sipa/bips/pull/210\n\nIf there are no other arguments (against), I'll PR it to the BIPs repo in a week or so.\n\nAll comments/questions/... still welcome.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "John Newbery",
                "date": "2020-08-21T08:50:49",
                "message_text_only": "Pieter,\n\nThanks for the illuminating write-up. There seem to be two questions here,\none technical and one process:\n\n1. Is changing to even tie-breaker for R the correct choice technically? I\ncan't comment on the performance characteristics of using a square/even\ntie-breaker and I'll assume the numbers you give are correct. An enormous\nbenefit that you don't mention (but Nadav and Lloyd do) is that\nstandardizing to a single tie-breaker for R points and public keys is much\nsimpler to explain and much easier for implementers and developers to\nunderstand. I've explained the taproot proposals to many people through the\noptech workshops and bitdevs meetups, and people are invariably confused by\nwhich type of tie-breaker to use where. Absent a large performance benefit\nfor having different tiebreakers, I think this alone is good reason to\nstandardize to one tie-breaker.\n\n2. Is it too late in the process to change? No. We're building things to\nlast years, hopefully decades. We should measure a hundred times and cut\nonce. A benefit of the long lead time of taproot is that as we get more\ninformation, we can improve the proposal. Let's do that here. Nadav and\nLloyd have both written alternative implementations of taproot and are\nhappy to make this change. Presumably if this was going to cause serious\npain for any other implementer/developer they would have raised objections\nby now.\n\nSummary: We should change the proposal and implementation to use even\ntie-breakers everywhere.\n\nJohn #notoquadraticresiduetiebreakers Newbery\n\nOn Wed, Aug 12, 2020 at 7:49 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> The current BIP340 draft[1] uses two different tiebreakers for conveying\n> the Y coordinate of points: for the R point inside signatures squaredness\n> is used, while for public keys evenness is used. Originally both used\n> squaredness, but it was changed[2] for public keys after observing this\n> results in additional complexity for compatibility with existing systems.\n>\n> The reason for choosing squaredness as tiebreaker was performance: in\n> non-batch signature validation, the recomputed R point must be verified to\n> have the correct sign, to guarantee consistency with batch validation.\n> Whether the Y coordinate is square can be computed directly in Jacobian\n> coordinates, while determining evenness requires a conversion to affine\n> coordinates first.\n>\n> This argument of course relies on the assumption that determining whether\n> the Y coordinate is square can be done more efficiently than a conversion\n> to affine coordinates. It appears now that this assumption is incorrect,\n> and the justification for picking the squaredness tiebreaking doesn't\n> really exist. As it comes with other trade-offs (it slows down signing, and\n> is a less conventional choice), it would seem that we should reconsider the\n> option of having the R point use the evenness tiebreaker (like public keys).\n>\n> It is late in the process, but I feel I owe this explanation so that at\n> least the possibility of changing can be discussed with all information. On\n> the upside, this was discovered in the context of looking into a cool\n> improvement to libsecp256k1[5], which makes things faster in general, but\n> specifically benefits the evenness variant.\n>\n>\n> # 1. What happened?\n>\n> Computing squaredness is done through the Jacobi symbol (same inventor,\n> but unrelated to Jacobian coordinates). Computing evenness requires\n> converting points to affine coordinates first, and that needs a modular\n> inverse. The assumption that Jacobi symbols are faster to compute than\n> inverses was based on:\n>\n> * A (possibly) mistaken belief about the theory: fast algorithms for both\n> Jacobi symbols and inverses are internally based on variants of the same\n> extended GCD algorithm[3]. Since an inverse needs to extract a full big\n> integer out of the transition steps made in the extgcd algorithm, while the\n> Jacobi symbol just extracts a single bit, it had seemed that any advances\n> applicable to one would be applicable to the other, but inverses would\n> always need additional work on top. It appears however that a class of\n> extgcd algorithms exists (LSB based ones) that cannot be used for Jacobi\n> calculations without losing efficiency. Recent developments[4] and a\n> proposed implementation in libsecp256k1[5] by Peter Dettman show that using\n> this, inverses in some cases can in fact be faster than Jacobi symbols.\n>\n> * A broken benchmark. This belief was incorrectly confirmed by a broken\n> benchmark[6] in libsecp256k1 for the libgmp-based Jacobi symbol calculation\n> and modular inverse. The benchmark was repeatedly testing the same constant\n> input, which apparently was around 2.5x faster than the average speed. It\n> is a variable-time algorithm, so a good variation of inputs matters. This\n> mistake had me (and probably others) convinced for years that Jacobi\n> symbols were amazingly fast, while in reality they were always very close\n> in performance to inverses.\n>\n>\n> # 2. What is the actual impact of picking evenness instead?\n>\n> It is hard to make very generic statements here, as BIP340 will hopefully\n> be used for a long time, and hardware advancements and algorithmic\n> improvements may change the balance. That said, performance on current\n> hardware with optimized algorithms is the best approximation we have.\n>\n> The numbers below give the expected performance change from squareness to\n> evenness, for single BIP340 validation, and for signing. Positive numbers\n> mean evenness is faster. Batch validation is not impacted at all.\n>\n> In the short term, for block validation in Bitcoin Core, the numbers for\n> master-nogmp are probably the most relevant (as Bitcoin Core uses\n> libsecp256k1 without libgmp, to reduce consensus-critical dependencies).\n> If/when [5] gets merged, safegcd-nogmp will be what matters. On a longer\n> time scale, the gmp numbers may be more relevant, as the Jacobi\n> implementation there is certainly closer to the state of the art.\n>\n> * i7-7820HQ: (verify) (sign)\n>   - master-nogmp: -0.3% +16.1%\n>   - safegcd-nogmp: +6.7% +17.1%\n>   - master-gmp: +0.6% +7.7%\n>   - safegcd-gmp: +1.6% +8.6%\n>\n> * Cortex-A53: (verify) (sign)\n>   - master-nogmp: -0.3% +15.7%\n>   - safegcd-nogmp: +7.5% +16.9%\n>   - master-gmp: +0.3% +4.1%\n>   - safegcd-gmp: 0.0% +3.5%\n>\n> * EPYC 7742: (verify) (sign)\n>   - master-nogmp: -0.3% +16.8%\n>   - safegcd-nogmp: +8.6% +18.4%\n>   - master-gmp: 0.0% +7.4%\n>   - safegcd-gmp: +2.3% +7.8%\n>\n> In well optimized cryptographic code speedups as large as a couple percent\n> are difficult to come by, so we would usually consider changes of this\n> magnitude relevant. Note however that while the percentages for signing\n> speed are larger, they are not what is unexpected here. The choice for the\n> square tiebreaker was intended to improve verification speed at the cost of\n> signing speed. As it turns out that it doesn't actually benefit\n> verification speed, this is a bad trade-off.\n>\n>\n> # 3. How big a change is it\n>\n> * In the BIP:\n>   - Changing both invocations of `has_square_y` to `has_even_y`.\n>   - Changing the `lift_x_square_y` invocation to `lift_x_even_y`.\n>   - Applying the same change to the test vector generation code, and the\n> resulting test vectors.\n> * In the libsecp256k1:\n>   - An 8-line patch to the proposed BIP340 implementation[7]: see [8]\n> * In Bitcoin Core:\n>   - Similarly small changes to the Python test reimplementation[9]\n> * Duplicating these changes in other draft implementations that may\n> already exist.\n> * Review for all the above.\n>\n>\n> # 4. Conclusion\n>\n> We discovered that the justification for using squaredness tiebreakers in\n> BIP340 is based on a misunderstanding, and recent developments show that it\n> may in fact be a somewhat worse choice than the alternative. It is a\n> relatively simple change to address this, but that has be weighed against\n> the impact of changing the standard at this stage.\n>\n> Thoughts?\n>\n>\n> # 5. References\n>\n>   [1]\n> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#design\n>   [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html\n>   [3] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n>   [4] https://gcd.cr.yp.to/safegcd-20190413.pdf\n>   [5] https://github.com/bitcoin-core/secp256k1/pull/767\n>   [6] https://github.com/bitcoin-core/secp256k1/pull/797\n>   [7] https://github.com/bitcoin-core/secp256k1/pull/558\n>   [8]\n> https://github.com/sipa/secp256k1/commit/822311ca230a48d2c373f3e48b91b2a59e1371d6\n>   [9] https://github.com/bitcoin/bitcoin/pull/17977\n>\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/52fd57bc/attachment-0001.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-08-27T01:10:21",
                "message_text_only": "On Friday, August 21, 2020 1:50 AM, John Newbery via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Summary: We should change the proposal and implementation to use even tie-breakers everywhere.\n>\n> John #notoquadraticresiduetiebreakers Newbery\n\nThanks Nadav, Lloyd, John, and those who commented privately,\n\nAs the comments we've received have been unanimously in favor of changing, here is the PR for doing so: https://github.com/bitcoin/bips/pull/982\n\nI'm very happy with this outcome, as it's indeed a significant reduction in the mental overhead needed for explaining the design decisions (the entire optimization section from the BIP can be removed, as those are no longer relevant to inform the decisions).\n\nThere is still some ongoing discussion about another change, namely permitting the use of messages that aren't exactly 32 bytes in length: https://github.com/sipa/bips/issues/207, but that would be a strict superset of what is permitted now, and have no impact on its use in BIP341/BIP342.\n\nCheers,\n\n--\nPieter #thefinalfinalfinalbip340 Wuille\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200827/4f959652/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Revisiting squaredness tiebreaker for R point in BIP340",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "Pieter Wuille",
                "John Newbery",
                "Lloyd Fournier"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 37146
        }
    },
    {
        "title": "[bitcoin-dev] Generalizing feature negotiation when new p2p connections are setup",
        "thread_messages": [
            {
                "author": "Suhas Daftuar",
                "date": "2020-08-14T19:28:41",
                "message_text_only": "Hi,\n\nBack in February I posted a proposal for WTXID-based transaction relay[1]\n(now known as BIP 339), which included a proposal for feature negotiation\nto take place prior to the VERACK message being received by each side.  In\nmy email to this list, I had asked for feedback as to whether that proposal\nwas problematic, and didn't receive any responses.\n\nSince then, the implementation of BIP 339 has been merged into Bitcoin\nCore, though it has not yet been released.\n\nIn thinking about the mechanism used there, I thought it would be helpful\nto codify in a BIP the idea that Bitcoin network clients should ignore\nunknown messages received before a VERACK.  A draft of my proposal is\navailable here[2].\n\nI presume that software upgrading past protocol version 70016 was already\nplanning to either implement BIP 339, or ignore the wtxidrelay message\nproposed in BIP 339 (if not, then this would create network split concerns\nin the future -- so I hope that someone would speak up if this were a\nproblem).  When we propose future protocol upgrades that would benefit from\nfeature negotiation at the time of connection, I think it would be nice to\nbe able to use the same method as proposed in BIP 339, without even needing\nto bump the protocol version.  So having an understanding that this is the\nstandard of how other network clients operate would be helpful.\n\nIf, on the other hand, this is problematic for some reason, I look forward\nto hearing that as well, so that we can be careful about how we deploy\nfuture p2p changes to avoid disruption.\n\nThanks,\nSuhas Daftuar\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html\n\n[2]\nhttps://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200814/6d0b3b0f/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-16T17:24:09",
                "message_text_only": "Concept ack!\n\nIt might be nice to include a few negotiation utility functions either in\nthis bip or at the same time in a separate bip. An example we might want to\ninclude is a \"polite disconnect\", whereby a node can register that you\ndon't want to connect in the future due to incompatibility.\n\nIt also might be nice to standardize some naming convention or negotiation\nmessage type so that we don't end up with different negotiation systems.\nThen we can also limit the bip so that we're only defining negotiation\nmessage types as ignorable v.s. some other message type (which can also be\nignored, but maybe we want to do something else in the future).\n\nThis also makes it easier for old (but newer than this bip) nodes to apply\nsome generic rules around reporting/rejecting/responding to unknown feature\nnegotiation v.s. an untagged message which might be a negotiation or\nsomething else.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/6fb078d1/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-16T19:06:55",
                "message_text_only": "A requirement to ignore unknown (invalid) messages is not only a protocol breaking change but poor protocol design. The purpose of version negotiation is to determine the set of valid messages. Changes to version negotiation itself are very problematic.\n\nThe only limitation presented by versioning is that the system is sequential. As such, clients that do not wish to implement (or operators who do not wish to enable) them are faced with a problem when wanting to support later features. This is resolvable by making such features optional at the new protocol level. This allows each client to limit its communication to the negotiated protocol, and allows ignoring of known but unsupported/disabled features.\n\nSorry I missed your earlier post. Been distracted for a while.\n\ne\n\n\n> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeff\n> Hi,\n> \n> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n> \n> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n> \n> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n> \n> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n> \n> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n> \n> Thanks,\n> Suhas Daftuar\n> \n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html\n> \n> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/1813852d/attachment-0001.html>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2020-08-17T20:40:02",
                "message_text_only": "Hi Eric,\n\nThanks for your response.  If I understand correctly, you're suggesting\nthat in the future we do the same as what was done in BIP 339, of\naccompanying new messages (which are optional) with a protocol version\nbump, so that network clients are never reading unknown messages from a\npeer (and can be free to disconnect a peer for sending an unknown message)?\n\nI think that works fine, so if indeed there will be software that will\nexpect things to operate this way then I can withdraw the suggestion I've\nmade in this thread.  However I wanted to clarify that this is what you\nsuggest, because there is another downside to this approach (beyond the\nsequential nature of sequence numbers that you mention) -- if a software\nimplementation misses a proposed new protocol upgrade, and thus fails to\nparse (and ignore) some proposed new message, the result can be a network\nsplit down the road as incompatible clients get slowly upgraded over time.\n\nI think this coordination cost is something to be concerned about -- for\ninstance, the lack of response to my wtxid-relay proposal made me wonder if\nother software would be implementing something to account for the new\nmessage that proposal introduces (for clients with version >= 70016).  It's\nreasonable for people to be busy and miss things like this, and I think\nit's worth considering whether there's a safer way for us to deploy changes.\n\nThat said, I don't think this coordination cost is unbearable, so as long\nas we have a process for making p2p protocol improvements I'm not too\nworried about what mechanism we use.  So if this concern over coordination\nof changes doesn't sway you, I think we can continue to just bump protocol\nversion at the same time as deploying new messages, as we have been doing,\nand hope that we don't run into problems down the road.\n\nIf I have misunderstood how you think we should be making future protocol\nchanges, please let me know.\n\nThanks,\nSuhas\n\n\n\nOn Sun, Aug 16, 2020 at 3:06 PM Eric Voskuil <eric at voskuil.org> wrote:\n\n> A requirement to ignore unknown (invalid) messages is not only a protocol\n> breaking change but poor protocol design. The purpose of version\n> negotiation is to determine the set of valid messages. Changes to version\n> negotiation itself are very problematic.\n>\n> The only limitation presented by versioning is that the system is\n> sequential. As such, clients that do not wish to implement (or operators\n> who do not wish to enable) them are faced with a problem when wanting to\n> support later features. This is resolvable by making such features optional\n> at the new protocol level. This allows each client to limit its\n> communication to the negotiated protocol, and allows ignoring of known but\n> unsupported/disabled features.\n>\n> Sorry I missed your earlier post. Been distracted for a while.\n>\n> e\n>\n>\n> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> \ufeff\n> Hi,\n>\n> Back in February I posted a proposal for WTXID-based transaction relay[1]\n> (now known as BIP 339), which included a proposal for feature negotiation\n> to take place prior to the VERACK message being received by each side.  In\n> my email to this list, I had asked for feedback as to whether that proposal\n> was problematic, and didn't receive any responses.\n>\n> Since then, the implementation of BIP 339 has been merged into Bitcoin\n> Core, though it has not yet been released.\n>\n> In thinking about the mechanism used there, I thought it would be helpful\n> to codify in a BIP the idea that Bitcoin network clients should ignore\n> unknown messages received before a VERACK.  A draft of my proposal is\n> available here[2].\n>\n> I presume that software upgrading past protocol version 70016 was already\n> planning to either implement BIP 339, or ignore the wtxidrelay message\n> proposed in BIP 339 (if not, then this would create network split concerns\n> in the future -- so I hope that someone would speak up if this were a\n> problem).  When we propose future protocol upgrades that would benefit from\n> feature negotiation at the time of connection, I think it would be nice to\n> be able to use the same method as proposed in BIP 339, without even needing\n> to bump the protocol version.  So having an understanding that this is the\n> standard of how other network clients operate would be helpful.\n>\n> If, on the other hand, this is problematic for some reason, I look forward\n> to hearing that as well, so that we can be careful about how we deploy\n> future p2p changes to avoid disruption.\n>\n> Thanks,\n> Suhas Daftuar\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html\n>\n> [2]\n> https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/f449fb1f/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-17T21:21:53",
                "message_text_only": "Hi Suhas,\n\nIt seems to me that your first two paragraphs contradict each other, so I\u2019m not sure we have understanding. As you say in the first paragraph, a peer would never get messages that it does not understand, so there is no chance that missing a protocol change would matter.\n\nIn case it\u2019s not understood, version negotiation provides each peer with the maximum supported protocol version of the other. Once complete both have negotiated to the highest common version. No message not supported at that version may be sent by either.\n\nIf the protocol was to accept *any* message traffic then it will cease to be a protocol. People will drop in their changes without obtaining broad support, and peers will evolve to the point of no longer being peers. They won\u2019t speak the same language and the \u201cnetwork\u201d will be little more than a broadcast transport, broadcasting all traffic to all peers, whether it\u2019s for them or not.\n\nPeople need to either build support or build a distinct network. That\u2019s the actual coordination issue, which is inherent to protocol development.\n\nBest,\ne\n\n> On Aug 17, 2020, at 13:40, Suhas Daftuar <sdaftuar at gmail.com> wrote:\n> \n> Hi Eric,\n> \n> Thanks for your response.  If I understand correctly, you're suggesting that in the future we do the same as what was done in BIP 339, of accompanying new messages (which are optional) with a protocol version bump, so that network clients are never reading unknown messages from a peer (and can be free to disconnect a peer for sending an unknown message)?\n> \n> I think that works fine, so if indeed there will be software that will expect things to operate this way then I can withdraw the suggestion I've made in this thread.  However I wanted to clarify that this is what you suggest, because there is another downside to this approach (beyond the sequential nature of sequence numbers that you mention) -- if a software implementation misses a proposed new protocol upgrade, and thus fails to parse (and ignore) some proposed new message, the result can be a network split down the road as incompatible clients get slowly upgraded over time. \n> \n> I think this coordination cost is something to be concerned about -- for instance, the lack of response to my wtxid-relay proposal made me wonder if other software would be implementing something to account for the new message that proposal introduces (for clients with version >= 70016).  It's reasonable for people to be busy and miss things like this, and I think it's worth considering whether there's a safer way for us to deploy changes.\n> \n> That said, I don't think this coordination cost is unbearable, so as long as we have a process for making p2p protocol improvements I'm not too worried about what mechanism we use.  So if this concern over coordination of changes doesn't sway you, I think we can continue to just bump protocol version at the same time as deploying new messages, as we have been doing, and hope that we don't run into problems down the road.  \n> \n> If I have misunderstood how you think we should be making future protocol changes, please let me know.\n> \n> Thanks,\n> Suhas\n> \n> \n> \n>> On Sun, Aug 16, 2020 at 3:06 PM Eric Voskuil <eric at voskuil.org> wrote:\n>> A requirement to ignore unknown (invalid) messages is not only a protocol breaking change but poor protocol design. The purpose of version negotiation is to determine the set of valid messages. Changes to version negotiation itself are very problematic.\n>> \n>> The only limitation presented by versioning is that the system is sequential. As such, clients that do not wish to implement (or operators who do not wish to enable) them are faced with a problem when wanting to support later features. This is resolvable by making such features optional at the new protocol level. This allows each client to limit its communication to the negotiated protocol, and allows ignoring of known but unsupported/disabled features.\n>> \n>> Sorry I missed your earlier post. Been distracted for a while.\n>> \n>> e\n>> \n>> \n>>>> On Aug 14, 2020, at 12:28, Suhas Daftuar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>> \n>>> \ufeff\n>>> Hi,\n>>> \n>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>>> \n>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>>> \n>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n>>> \n>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n>>> \n>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n>>> \n>>> Thanks,\n>>> Suhas Daftuar\n>>> \n>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html\n>>> \n>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/e1288ac9/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-08-20T14:13:39",
                "message_text_only": "On Sun, Aug 16, 2020 at 12:06:55PM -0700, Eric Voskuil via bitcoin-dev wrote:\n> A requirement to ignore unknown (invalid) messages is [...] a protocol\n> breaking change \n\nI don't think it is.  The proposed BIP, as currently written, only tells\nnodes to ignore unknown messages during peer negotiation.  The only case\nwhere this will happen so far is BIP339, which says:\n\n    The wtxidrelay message must be sent in response to a VERSION message\n    from a peer whose protocol version is >= 70016, and prior to sending\n    a VERACK\n\nSo unless you signal support for version >=70016, you'll never receive an\nunknown message.  (And, if you do signal, you probably can't claim that\nyou were unaware of this new requirement, unless you were using a\nnon-BIP protocol like xthin[1]).\n\nHowever, perhaps this new proposed BIP could be a bit clearer about its\nexpectations for future protocol upgrades by saying something like:\n\n    Nodes implementing this BIP MUST also not send new negotiation\n    message types to nodes whose protocol version is less than 70017.\n\nThat should promote backwards compatibility.  If you don't want to\nignore unknown negotiation messages between `version` and `verack`, you\ncan just set your protocol version to a max of 70016.\n\n> A requirement to ignore unknown (invalid) messages is [...] poor\n> protocol design. The purpose of version negotiation is to determine\n> the set of valid messages. \n\nTo be clear, the proposed requirement to ignore unknown messages is\nlimited in scope to the brief negotiation phase between `version` and\n`verack`.  If you want to terminate connections (or do whatever) on\nreceipt of an unknown message, you can do that at any other time.\n\n> Changes to version negotiation itself are very problematic.\n\nFor whom?\n\n> The only limitation presented by versioning is that the system is\n> sequential. \n\nThat seems like a pretty significant limitation to decentralized\nprotocol development.\n\nI think there are currently several people who want to run long-term\nexperiements for new protocol features using open source opt-in\ncodebases that anyone can run, and it would be advantageous to them to\nhave a flexible and lightweight feature negotiation system like this\nproposed method.\n\n> As such, clients that do not wish to implement (or operators who do\n> not wish to enable) them are faced with a problem when wanting to\n> support later features. This is resolvable by making such features\n> optional at the new protocol level. This allows each client to limit\n> its communication to the negotiated protocol, and allows ignoring of\n> known but unsupported/disabled features.\n\nI don't understand this.  How do two peers negotiate a set of two or\nmore optional features using only the exchange of single numbers?  For\nexample:\n\n- Node A supports Feature X (implemented in protocol version 70998) and Feature Y (version 70999).\n\n- Node B does not support X but does want to use Y; what does it use for its\n  protocol version number when establishing a connection with node A?\n\n---\n\nOverall, I like the proposed BIP and the negotiation method it\ndescribes.\n\nCheers,\n\n-Dave\n\n[1] This is not a recommendation for xthin, but I do think it's an example\n    of the challenges of using a shared linear version number scheme for\n    protocol negotiation in a decentralized system where different teams\n    don't necessarily get along well with each other.\n    https://github.com/ptschip/bitcoinxt/commit/7ea5854a3599851beffb1323544173f03d45373b#diff-c61070c281aed6ded69036c08bd08addR12\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200820/faec9a70/attachment.sig>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-18T14:59:00",
                "message_text_only": "This sounds like a great idea!\n\nBitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The \nBitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical \nversion field, but that is wholly impractical for any diverse network - some clients may not wish to implement every \npossible new relay mechanic, and why should they have to in order to use other new features?\n\nBitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which take \nadvantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that \npattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of \nfeatures that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter \nmuch, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures \nthe pattern that has been used in several recent network upgrades, keeping consistency.\n\nMatt\n\nOn 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n> Hi,\n> \n> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a \n> proposal for feature negotiation to take place prior to the VERACK message being received by each side.\u00a0 In my email to \n> this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n> \n> Since then, the implementation\u00a0of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n> \n> In thinking about the mechanism used there, I thought it would\u00a0be helpful to codify in a BIP the idea that Bitcoin \n> network clients should ignore unknown messages received before a VERACK.\u00a0 A draft of my proposal is available here[2].\n> \n> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or \n> ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future \n> -- so I hope that someone would speak up if this were a problem).\u00a0 When we propose future protocol upgrades that would \n> benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method \n> as proposed in BIP 339, without even needing to bump the protocol version.\u00a0 So having an understanding that this is the \n> standard of how other network clients operate would be helpful.\n> \n> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be \n> careful about how we deploy future p2p changes to avoid disruption.\n> \n> Thanks,\n> Suhas Daftuar\n> \n> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html \n> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n> \n> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki \n> <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-18T16:54:58",
                "message_text_only": "\u201cBitcoin protocol has always expected clients to ignore unknown messages\u201d\n\nThis is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin\u2019s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.\n\nFeatures can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.\n\nA generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer\u2019s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).\n\nFWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.\n\ne\n\n> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffThis sounds like a great idea!\n> \n> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?\n> \n> Bitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.\n> \n> Matt\n> \n>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n>> Hi,\n>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n>> Thanks,\n>> Suhas Daftuar\n>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200818/bf38200b/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-18T17:26:36",
                "message_text_only": "There are several cases where a new message has been sent as a part of a negotiation without changing the protocol \nversion. You may chose to ignore that, but that doesn't mean that it isn't an understood and even relied upon feature of \nthe Bitcoin P2P protocol. If you wish to fail connections to new nodes (and risk network splits, as Suhas points out), \nthen you may do so, but that doesn't make it a part of the Bitcoin P2P protocol that you must do so. Of course there is \nno \"official document\" by which we can make a formal appeal, but historical precedent suggests otherwise.\n\nStill, I think we're talking pedantics here, and not in a useful way. Ultimately we need some kind of negotiation which \nis flexible in allowing different software to negotiate different features without a global lock-step version number \nincrease. Or, to put it another way, if a feature is fully optional, why should there be a version number increase for \nit - the negotiation of it is independent and a version number only increases confusion over which change \"owns\" a given \nversion number.\n\nI presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on \nthe connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of \none message, which is a bit nicer in that they can be handled more independently or by different subsystems including \neven the message hashing.\n\nMatt\n\nOn 8/18/20 12:54 PM, Eric Voskuil wrote:\n> \u201cBitcoin protocol has always expected clients to ignore unknown messages\u201d\n> \n> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin\u2019s p2p \n> protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The \n> fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.\n> \n> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for \n> optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. \n> There is no reason to force a client to accept unknown message traffic.\n> \n> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc \n> basis. The former is possible as long as the peer\u2019s version is sufficient to be aware of the behavior. This does not \n> imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. \n> There is no reason to complicate negotiation with an additional message(s).\n> \n> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, \n> older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.\n> \n> e\n> \n>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> \ufeffThis sounds like a great idea!\n>>\n>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. \n>> The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple \n>> numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to \n>> implement every possible new relay mechanic, and why should they have to in order to use other new features?\n>>\n>> Bitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which \n>> take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given \n>> that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the \n>> list of features that you support to negotiate what the connection will be capable of. The exact way we do that \n>> doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature \n>> perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.\n>>\n>> Matt\n>>\n>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n>>> Hi,\n>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a \n>>> proposal for feature negotiation to take place prior to the VERACK message being received by each side.\u00a0 In my email \n>>> to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>>> Since then, the implementation\u00a0of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>>> In thinking about the mechanism used there, I thought it would\u00a0be helpful to codify in a BIP the idea that Bitcoin \n>>> network clients should ignore unknown messages received before a VERACK.\u00a0 A draft of my proposal is available here[2].\n>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or \n>>> ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the \n>>> future -- so I hope that someone would speak up if this were a problem).\u00a0 When we propose future protocol upgrades \n>>> that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the \n>>> same method as proposed in BIP 339, without even needing to bump the protocol version.\u00a0 So having an understanding \n>>> that this is the standard of how other network clients operate would be helpful.\n>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be \n>>> careful about how we deploy future p2p changes to avoid disruption.\n>>> Thanks,\n>>> Suhas Daftuar\n>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html \n>>> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n>>> [2] \n>>> https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki \n>>> <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-18T18:11:12",
                "message_text_only": "> On Aug 18, 2020, at 10:26, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n> \n> \ufeffThere are several cases where a new message has been sent as a part of a negotiation without changing the protocol version.\n\nSuch as?\n\n> You may chose to ignore that, but that doesn't mean that it isn't an understood and even relied upon feature of the Bitcoin P2P protocol. If you wish to fail connections to new nodes (and risk network splits, as Suhas points out), then you may do so, but that doesn't make it a part of the Bitcoin P2P protocol that you must do so. Of course there is no \"official document\" by which we can make a formal appeal, but historical precedent suggests otherwise.\n\nYou are misrepresenting \u201chistorical precedent\u201d. I\u2019ve seen several attempts to require arbitrary traffic over the years and none have been realized.\n\n> Still, I think we're talking pedantics here, and not in a useful way.\n\nNot to be pedantic, but I don\u2019t know what that means.\n\n> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.\n\nI have shown below how that already works.\n\n> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it\n\nFor the reasons previously given.\n\n> - the negotiation of it is independent and a version number only increases confusion over which change \"owns\" a given version number.\n\nPresumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).\n\n> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.\n\nThis presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.\n\nI\u2019m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for \u201cmust\u201d implement, and can be used to signal an extension to the verack. The verack can then carry a list of \u201cmay\u201d or \u201cshould\u201d sub-protocols for final negotiation.\n\nThe format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies \u201cownership\u201c of names. In other words, that coordination requirement is not eliminated.\n\ne\n\n> Matt\n> \n>> On 8/18/20 12:54 PM, Eric Voskuil wrote:\n>> \u201cBitcoin protocol has always expected clients to ignore unknown messages\u201d\n>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin\u2019s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.\n>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.\n>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer\u2019s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).\n>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.\n>> e\n>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> \n>>> \ufeffThis sounds like a great idea!\n>>> \n>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?\n>>> \n>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.\n>>> \n>>> Matt\n>>> \n>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n>>>> Hi,\n>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n>>>> Thanks,\n>>>> Suhas Daftuar\n>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-18T18:25:26",
                "message_text_only": "On 8/18/20 2:11 PM, Eric Voskuil wrote:\n  - snip -\n>> Still, I think we're talking pedantics here, and not in a useful way.\n> \n> Not to be pedantic, but I don\u2019t know what that means.\n\nIt means that part of the discussion is not useful, and not worth bothering to go back and figure out what was shipped \nbefore the version increase and what wasn't, lets talk about what makes sense for the future :).\n\n>> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.\n> \n> I have shown below how that already works.\n> \n>> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it\n> \n> For the reasons previously given.\n> \n>> - the negotiation of it is independent and a version number only increases confusion over which change \"owns\" a given version number.\n> \n> Presumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).\n\nI think the point is, this doesn't work today, bumping the protocol version requires everyone agreeing on which features \nmake sense, and as we can see from this email thread alone, that isn't a common result in this community. People happily \nignore BIPs that make no sense, of which there are a lot, and they should totally be able to do that!\n\nYou can say that the current world works, but there's a reason over time we've shifted away from the original \"shove \nanother bit on the end of the version message, and everyone agrees on the order of those bits for new feature \nnegotiation.\" Version bumping is an extension of that, really.\n\n>> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.\n> \n> This presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.\n\nSome things may need further negotiation. eg compact blocks sends multiple redundant messages with different versions \nand then deduces the correct version based on the message ordering and version set supported. Doing this via verack \nlocks you into a very specific possible negotiation protocols. You could extend it further and suggest a verack K-V list \nwhich allows for more flexible negotiation, but I'm not sure that it isn't more complicated than just shoving more \nmessages on the wire.\n\n> I\u2019m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for \u201cmust\u201d implement, and can be used to signal an extension to the verack. The verack can then carry a list of \u201cmay\u201d or \u201cshould\u201d sub-protocols for final negotiation.\n\nI think we agree here - the current method of protocol version bumping isn't scalable and something more flexible is \ndefinitely a better world.\n\n> The format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies \u201cownership\u201c of names. In other words, that coordination requirement is not eliminated.\n\nThis is true, there is some ownership requirement, we could switch to hashes or something of the like, but \nhuman-readable names have shown to be relatively non-colliding in past Bitcoin protocol changes.\n\n> e\n> \n>> Matt\n>>\n>>> On 8/18/20 12:54 PM, Eric Voskuil wrote:\n>>> \u201cBitcoin protocol has always expected clients to ignore unknown messages\u201d\n>>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin\u2019s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.\n>>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.\n>>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer\u2019s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).\n>>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.\n>>> e\n>>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>> \ufeffThis sounds like a great idea!\n>>>>\n>>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?\n>>>>\n>>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.\n>>>>\n>>>> Matt\n>>>>\n>>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n>>>>> Hi,\n>>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n>>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n>>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n>>>>> Thanks,\n>>>>> Suhas Daftuar\n>>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n>>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-18T18:56:13",
                "message_text_only": "> On Aug 18, 2020, at 11:25, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n> \n> On 8/18/20 2:11 PM, Eric Voskuil wrote:\n> - snip -\n>>> Still, I think we're talking pedantics here, and not in a useful way.\n>> Not to be pedantic, but I don\u2019t know what that means.\n> \n> It means that part of the discussion is not useful, and not worth bothering to go back and figure out what was shipped before the version increase and what wasn't, lets talk about what makes sense for the future :).\n\nWhen the discussion centers on backward compatibility, and there is confusion over what that actually implies, this is a central question. You snipped the bit about what actually constitutes the existing protocol. I have implemented every aspect of the protocol that is widely deployed, and I can say without question that the protocol does not require a peer to accept arbitrary messages. In other words, your statement on the subject was a very relevant factual error. Furthermore no reason has been demonstrated here to accept arbitrary traffic.\n\n>>> Ultimately we need some kind of negotiation which is flexible in allowing different software to negotiate different features without a global lock-step version number increase.\n>> I have shown below how that already works.\n>>> Or, to put it another way, if a feature is fully optional, why should there be a version number increase for it\n>> For the reasons previously given.\n>>> - the negotiation of it is independent and a version number only increases confusion over which change \"owns\" a given version number.\n>> Presumably this is why we have a standards process. Any new message implies ownership. Deconflicting that is required, which implies it can easily be version associated (as it has been).\n> \n> I think the point is, this doesn't work today, bumping the protocol version requires everyone agreeing on which features make sense,\n\nAs I have shown, this is not the case. While I have given my support to simplifying the process, we should not proceed based on an incorrect understanding of actual behavior.\n\n> and as we can see from this email thread alone, that isn't a common result in this community. People happily ignore BIPs that make no sense, of which there are a lot, and they should totally be able to do that!\n> \n> You can say that the current world works, but there's a reason over time we've shifted away from the original \"shove another bit on the end of the version message, and everyone agrees on the order of those bits for new feature negotiation.\" Version bumping is an extension of that, really.\n\nActually the protocol has not done this. It has used the version to signal a new sub-protocol, and then in some cases that sub-protocol has been made optional through subsequent negotiation. What is being proposed here is to simplify that process by collapsing the secondary negotiation into the handshake.\n\nIn fact I argued against this secondary ad-hoc negotiation when it began. Now we are coming around to recognizing that it\u2019s a handshake issue, as I said at the time. I\u2019m glad to see that.\n\n>>> I presume you'd support a single message that lists the set of features which a node (optionally) wishes to support on the connection. This proposal is fully equivalent to that, instead opting to list them as individual messages instead of one message, which is a bit nicer in that they can be handled more independently or by different subsystems including even the message hashing.\n>> This presumes an implementation. As part of the handshake, collection of an arbitrary set of messages is a significant and unnecessary complication *of the protocol*. Extension of the verack is not. It is the simplest change possible to implement the desired behavior. Each peer simply supplies the matrix of sub-protocols it supports and only those supported by both are allowed. There is no reason for the protocol to split that matrix up into multiple messages, requiring termination. Independent messages exist because of timing or ordering requirements. Implementing dependent messages as if they were independent is wasteful and complicating.\n> \n> Some things may need further negotiation. eg compact blocks sends multiple redundant messages with different versions and then deduces the correct version based on the message ordering and version set supported. Doing this via verack locks you into a very specific possible negotiation protocols.\n\nThis is a moot point. Whether a list of supported optional sub-protocols is listed in one or multiple messages in the handshake would not change this.\n\n> You could extend it further and suggest a verack K-V list which allows for more flexible negotiation, but I'm not sure that it isn't more complicated than just shoving more messages on the wire.\n\nThere is no difference between a constrained set of key-value pairs and a distinct set of options, so there is no additional complexity here.\n\n>> I\u2019m well aware of the inefficiency produced by version linearity in the face of optional sub-protocols. The protocol must negotiate to the version where it can then negotiate support, which has been done. I support creating a simpler system, eliminating these extra messages. The existing numeric version can be reserved exclusively for \u201cmust\u201d implement, and can be used to signal an extension to the verack. The verack can then carry a list of \u201cmay\u201d or \u201cshould\u201d sub-protocols for final negotiation.\n> \n> I think we agree here - the current method of protocol version bumping isn't scalable and something more flexible is definitely a better world.\n\nTo be clear this does not increase flexibility, it reduces communication and therefore complexity, and allows peers to lock in allowed message semantics by the end of the handshake, as opposed to allowing them to change at any time.\n\n>> The format of the matrix is arbitrary, but the requirement is to list a set of optional sub-protocols. This implies a namespace. This implies \u201cownership\u201c of names. In other words, that coordination requirement is not eliminated.\n> \n> This is true, there is some ownership requirement, we could switch to hashes or something of the like, but human-readable names have shown to be relatively non-colliding in past Bitcoin protocol changes.\n\nHashes don\u2019t prevent collisions. Someone can just use the same hash. Bitcoin uses names (message names) and numbers (version, service, relay...). It\u2019s a protocol, coordination is the whole point.\n\ne\n\n>> e\n>>> Matt\n>>> \n>>>> On 8/18/20 12:54 PM, Eric Voskuil wrote:\n>>>> \u201cBitcoin protocol has always expected clients to ignore unknown messages\u201d\n>>>> This is not true. Bitcoin has long implemented version negotiation, which is the opposite expectation. Libbitcoin\u2019s p2p protocol implementation immediately drops a peer that sends an invalid message according to the negotiated version. The fact that a given client does not validate the protocol does not make it an expectation that the protocol not be validated.\n>>>> Features can clearly be optional within an actual protocol. There have been post-handshake negotiations implemented for optional messages which are valid at the negotiated version. The protocol may be flexible while remaining validateable. There is no reason to force a client to accept unknown message traffic.\n>>>> A generalized versioning change can be implemented in or after the handshake. The latter is already done on an ad-hoc basis. The former is possible as long as the peer\u2019s version is sufficient to be aware of the behavior. This does not imply any need to send invalid messages. The verack itself can simply be extended with a matrix of feature support. There is no reason to complicate negotiation with an additional message(s).\n>>>> FWIW, bip37 did this poorly, adding a feature field to the version message, resulting in bip60. Due to this design, older protocol-validating clients were broken. In this case it was message length that was presumed to not be validated.\n>>>> e\n>>>>>> On Aug 18, 2020, at 07:59, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>> \n>>>>> \ufeffThis sounds like a great idea!\n>>>>> \n>>>>> Bitcoin is no longer a homogeneous network of one client - it is many, with different features implemented in each. The Bitcoin protocol hasn't (fully) evolved to capture that reality. Initially the Bitcoin protocol had a simple numerical version field, but that is wholly impractical for any diverse network - some clients may not wish to implement every possible new relay mechanic, and why should they have to in order to use other new features?\n>>>>> \n>>>>> Bitcoin protocol changes have, many times in recent history, been made via new dummy \"negotiation\" messages, which take advantage of the fact that the Bitcoin protocol has always expected clients to ignore unknown messages. Given that pattern, it makes sense to have an explicit negotiation phase - after version and before verack, just send the list of features that you support to negotiate what the connection will be capable of. The exact way we do that doesn't matter much, and sending it as a stream of messages which each indicate support for a given protocol feature perfectly captures the pattern that has been used in several recent network upgrades, keeping consistency.\n>>>>> \n>>>>> Matt\n>>>>> \n>>>>> On 8/14/20 3:28 PM, Suhas Daftuar via bitcoin-dev wrote:\n>>>>>> Hi,\n>>>>>> Back in February I posted a proposal for WTXID-based transaction relay[1] (now known as BIP 339), which included a proposal for feature negotiation to take place prior to the VERACK message being received by each side.  In my email to this list, I had asked for feedback as to whether that proposal was problematic, and didn't receive any responses.\n>>>>>> Since then, the implementation of BIP 339 has been merged into Bitcoin Core, though it has not yet been released.\n>>>>>> In thinking about the mechanism used there, I thought it would be helpful to codify in a BIP the idea that Bitcoin network clients should ignore unknown messages received before a VERACK.  A draft of my proposal is available here[2].\n>>>>>> I presume that software upgrading past protocol version 70016 was already planning to either implement BIP 339, or ignore the wtxidrelay message proposed in BIP 339 (if not, then this would create network split concerns in the future -- so I hope that someone would speak up if this were a problem).  When we propose future protocol upgrades that would benefit from feature negotiation at the time of connection, I think it would be nice to be able to use the same method as proposed in BIP 339, without even needing to bump the protocol version.  So having an understanding that this is the standard of how other network clients operate would be helpful.\n>>>>>> If, on the other hand, this is problematic for some reason, I look forward to hearing that as well, so that we can be careful about how we deploy future p2p changes to avoid disruption.\n>>>>>> Thanks,\n>>>>>> Suhas Daftuar\n>>>>>> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017648.html>\n>>>>>> [2] https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki <https://github.com/sdaftuar/bips/blob/2020-08-generalized-feature-negotiation/bip-p2p-feature-negotiation.mediawiki>\n>>>>>> _______________________________________________\n>>>>>> bitcoin-dev mailing list\n>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-08-21T02:36:47",
                "message_text_only": "On Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:\n> In thinking about the mechanism used there, I thought it would\u00a0be helpful to\n> codify in a BIP the idea that Bitcoin network clients should ignore unknown\n> messages received before a VERACK.\u00a0 A draft of my proposal is available here\n> [2].\n\nRather than allowing arbitrary messages, maybe it would make sense to\nhave a specific feature negotiation message, eg:\n\n  VERSION ...\n  FEATURE wtxidrelay\n  FEATURE packagerelay\n  VERACK\n\nwith the behaviour being that it's valid only between VERSION and VERACK,\nand it takes a length-prefixed-string giving the feature name, optional\nadditional data, and if the feature name isn't recognised the message\nis ignored.\n\nIf we were to support a \"polite disconnect\" feature like Jeremy suggested,\nit might be easier to do that for a generic FEATURE message, than\nreimplement it for the message proposed by each new feature.\n\nCheers,\naj"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-21T04:25:08",
                "message_text_only": "Hi Anthony,\n\nThis is what I was implying in my last post (the reference to the unnecessary overload of message typing). However, if one imagines a sequence diagram for this communication it becomes obvious that all such messages are 100% redundant with verack.\n\ne\n\n> On Aug 20, 2020, at 19:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffOn Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:\n>> In thinking about the mechanism used there, I thought it would be helpful to\n>> codify in a BIP the idea that Bitcoin network clients should ignore unknown\n>> messages received before a VERACK.  A draft of my proposal is available here\n>> [2].\n> \n> Rather than allowing arbitrary messages, maybe it would make sense to\n> have a specific feature negotiation message, eg:\n> \n>  VERSION ...\n>  FEATURE wtxidrelay\n>  FEATURE packagerelay\n>  VERACK\n> \n> with the behaviour being that it's valid only between VERSION and VERACK,\n> and it takes a length-prefixed-string giving the feature name, optional\n> additional data, and if the feature name isn't recognised the message\n> is ignored.\n> \n> If we were to support a \"polite disconnect\" feature like Jeremy suggested,\n> it might be easier to do that for a generic FEATURE message, than\n> reimplement it for the message proposed by each new feature.\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "lf-lists at mattcorallo.com",
                "date": "2020-08-21T14:15:10",
                "message_text_only": "Sure, we could do a new message for negotiation, but there doesn\u2019t seem to be a lot of reason for it - using the same namespace for negotiation seems fine too. In any case, this is one of those things that doesn\u2019t matter in the slightest, and if one person volunteers to write a BIP and code, no reason they shouldn\u2019t just decide and be allowed to run with it. Rough consensus and running code, as it were :)\n\nMatt\n\n\n> On Aug 20, 2020, at 22:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffOn Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:\n>> In thinking about the mechanism used there, I thought it would be helpful to\n>> codify in a BIP the idea that Bitcoin network clients should ignore unknown\n>> messages received before a VERACK.  A draft of my proposal is available here\n>> [2].\n> \n> Rather than allowing arbitrary messages, maybe it would make sense to\n> have a specific feature negotiation message, eg:\n> \n>  VERSION ...\n>  FEATURE wtxidrelay\n>  FEATURE packagerelay\n>  VERACK\n> \n> with the behaviour being that it's valid only between VERSION and VERACK,\n> and it takes a length-prefixed-string giving the feature name, optional\n> additional data, and if the feature name isn't recognised the message\n> is ignored.\n> \n> If we were to support a \"polite disconnect\" feature like Jeremy suggested,\n> it might be easier to do that for a generic FEATURE message, than\n> reimplement it for the message proposed by each new feature.\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-21T16:42:46",
                "message_text_only": "I\u2019m pretty sure one can run whatever they want even without a BIP. There is nobody here to do any \u201callowing\u201d. On the other hand, standards development is tedious for good reason.\n\nGenerally speaking, overloading is a primary source of complexity (creating more branches in code and human explanation). Nevertheless this is verack payload, no additional messages are necessary or helpful.\n\ne\n\n> On Aug 21, 2020, at 07:15, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffSure, we could do a new message for negotiation, but there doesn\u2019t seem to be a lot of reason for it - using the same namespace for negotiation seems fine too. In any case, this is one of those things that doesn\u2019t matter in the slightest, and if one person volunteers to write a BIP and code, no reason they shouldn\u2019t just decide and be allowed to run with it. Rough consensus and running code, as it were :)\n> \n> Matt\n> \n> \n>>> On Aug 20, 2020, at 22:37, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> \n>>> \ufeffOn Fri, Aug 14, 2020 at 03:28:41PM -0400, Suhas Daftuar via bitcoin-dev wrote:\n>>> In thinking about the mechanism used there, I thought it would be helpful to\n>>> codify in a BIP the idea that Bitcoin network clients should ignore unknown\n>>> messages received before a VERACK.  A draft of my proposal is available here\n>>> [2].\n>> \n>> Rather than allowing arbitrary messages, maybe it would make sense to\n>> have a specific feature negotiation message, eg:\n>> \n>> VERSION ...\n>> FEATURE wtxidrelay\n>> FEATURE packagerelay\n>> VERACK\n>> \n>> with the behaviour being that it's valid only between VERSION and VERACK,\n>> and it takes a length-prefixed-string giving the feature name, optional\n>> additional data, and if the feature name isn't recognised the message\n>> is ignored.\n>> \n>> If we were to support a \"polite disconnect\" feature like Jeremy suggested,\n>> it might be easier to do that for a generic FEATURE message, than\n>> reimplement it for the message proposed by each new feature.\n>> \n>> Cheers,\n>> aj\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-21T19:50:21",
                "message_text_only": "I have a proposal:\n\nProtocol >= 70016 cease to send or process VERACK, and instead use\nHANDSHAKEACK, which is completed after feature negotiation.\n\nThis should make everyone happy/unhappy, as in a new protocol number it's\nfair game to change these semantics to be clear that we're acking more than\nversion.\n\nI don't care about when or where these messages are sequenced overall, it\nseems to have minimal impact. If I had free choice, I slightly agree with\nEric that verack should come before feature negotiation, as we want to\ndivorce the idea that protocol number and feature support are tied.\n\nBut once this is done, we can supplant Verack with HANDSHAKENACK or\nHANDSHAKEACK to signal success or failure to agree on a connection. A NACK\nreason (version too high/low or an important feature missing) could be\noptional. Implicit NACK would be disconnecting, but is discouraged because\na peer doesn't know if it should reconnect or the failure was intentional.\n\n------\n\nAJ: I think I generally do prefer to have a FEATURE wrapper as you\nsuggested, or a rule that all messages in this period are interpreted as\nfeatures (and may be redundant with p2p message types -- so you can\nliterally just use the p2p message name w/o any data).\n\nI think we would want a semantic (which could be based just on message\nnames, but first-class support would be nice) for ACKing that a feature is\nenabled. This is because a transcript of:\n\nNODE0:\nFEATURE A\nFEATURE B\nVERACK\n\nNODE1:\nFEATURE A\nVERACK\n\nIt remains unclear if Node 1 ignored B because it's an unknown feature, or\nbecause it is disabled. A transcript like:\n\nNODE0:\nFEATURE A\nFEATURE B\nFEATURE C\nACK A\nVERACK\n\nNODE1:\nFEATURE A\nACK A\nNACK B\nVERACK\n\nwould make it clear that A and B are known, B is disabled, and C is\nunknown. C has 0 support, B Node 0 should support inbound messages but\nknows not to send to Node 1, and A has full bilateral support. Maybe\ninstead it could a message FEATURE SEND A and FEATURE RECV A, so we can\nmake the split explicit rather than inferred from ACK/NACK.\n\n\n------\n\nI'd also propose that we add a message which is SYNC, which indicates the\nend of a list of FEATURES and a request to send ACKS or NACKS back (which\nare followed by a SYNC). This allows multi-round negotiation where based on\nthe presence of other features, I may expand the set of features I am\noffering. I think you could do without SYNC, but there are more edge cases\nand the explicitness is nice given that this already introduces future\ncomplexity.\n\nThis multi-round makes it an actual negotiation rather than a pure\nannouncement system. I don't think it would be used much in the near term,\nbut it makes sense to define it correctly now. Build for the future and\nall...\n\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/1083efeb/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-21T20:45:26",
                "message_text_only": "This seems to be pretty overengineered. Do you have a specific use-case in mind for anything more than simply continuing \nthe pattern we've been using of sending a message indicating support for a given feature? If we find some in the future, \nwe could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.\n\nThe great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the \nflexibility we need. Even better, the code already exists.\n\nMatt\n\nOn 8/21/20 3:50 PM, Jeremy wrote:\n> I have a proposal:\n> \n> Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature \n> negotiation.\n> \n> This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be \n> clear that we're acking more than version.\n> \n> I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free \n> choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea \n> that protocol number and feature support are tied.\n> \n> But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree \n> on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK \n> would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was \n> intentional.\n> \n> ------\n> \n> AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period \n> are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p \n> message name w/o any data).\n> \n> I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for \n> ACKing that a feature is enabled. This is because a transcript of:\n> \n> NODE0:\n> FEATURE A\n> FEATURE B\n> VERACK\n> \n> NODE1:\n> FEATURE A\n> VERACK\n> \n> It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:\n> \n> NODE0:\n> FEATURE A\n> FEATURE B\n> FEATURE C\n> ACK A\n> VERACK\n> \n> NODE1:\n> FEATURE A\n> ACK A\n> NACK B\n> VERACK\n> \n> would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support \n> inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message \n> FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.\n> \n> \n> ------\n> \n> I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to \n> send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence \n> of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more \n> edge cases and the explicitness is nice given that this already introduces future complexity.\n> \n> This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used \n> much in the near term, but it makes sense to define it correctly now. Build for the future and all...\n> \n> \n> \n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-21T21:08:33",
                "message_text_only": "Actually we already have service bits (which are sadly limited) which allow\nnegotiation of non bilateral feature support, so this would supercede that.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Fri, Aug 21, 2020 at 1:45 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> This seems to be pretty overengineered. Do you have a specific use-case in\n> mind for anything more than simply continuing\n> the pattern we've been using of sending a message indicating support for a\n> given feature? If we find some in the future,\n> we could deploy something like this, though the current proposal makes it\n> possible to do it on a per-feature case.\n>\n> The great thing about Suhas' proposal is the diff is about -1/+1 (not\n> including tests), while still getting all the\n> flexibility we need. Even better, the code already exists.\n>\n> Matt\n>\n> On 8/21/20 3:50 PM, Jeremy wrote:\n> > I have a proposal:\n> >\n> > Protocol >= 70016 cease to send or process VERACK, and instead use\n> HANDSHAKEACK, which is completed after feature\n> > negotiation.\n> >\n> > This should make everyone happy/unhappy, as in a new protocol number\n> it's fair game to change these semantics to be\n> > clear that we're acking more than version.\n> >\n> > I don't care about when or where these messages are sequenced overall,\n> it seems to have minimal impact. If I had free\n> > choice, I slightly agree with Eric that verack should come before\n> feature negotiation, as we want to divorce the idea\n> > that protocol number and feature support are tied.\n> >\n> > But once this is done, we can supplant Verack with HANDSHAKENACK or\n> HANDSHAKEACK to signal success or failure to agree\n> > on a connection. A NACK reason (version too high/low or an important\n> feature missing) could be optional. Implicit NACK\n> > would be disconnecting, but is discouraged because a peer doesn't know\n> if it should reconnect or the failure was\n> > intentional.\n> >\n> > ------\n> >\n> > AJ: I think I generally do prefer to have a FEATURE wrapper as you\n> suggested, or a rule that all messages in this period\n> > are interpreted as features (and may be redundant with p2p message types\n> -- so you can literally just use the p2p\n> > message name w/o any data).\n> >\n> > I think we would want a semantic (which could be based just on message\n> names, but first-class support would be nice) for\n> > ACKing that a feature is enabled. This is because a transcript of:\n> >\n> > NODE0:\n> > FEATURE A\n> > FEATURE B\n> > VERACK\n> >\n> > NODE1:\n> > FEATURE A\n> > VERACK\n> >\n> > It remains unclear if Node 1 ignored B because it's an unknown feature,\n> or because it is disabled. A transcript like:\n> >\n> > NODE0:\n> > FEATURE A\n> > FEATURE B\n> > FEATURE C\n> > ACK A\n> > VERACK\n> >\n> > NODE1:\n> > FEATURE A\n> > ACK A\n> > NACK B\n> > VERACK\n> >\n> > would make it clear that A and B are known, B is disabled, and C is\n> unknown. C has 0 support, B Node 0 should support\n> > inbound messages but knows not to send to Node 1, and A has full\n> bilateral support. Maybe instead it could a message\n> > FEATURE SEND A and FEATURE RECV A, so we can make the split explicit\n> rather than inferred from ACK/NACK.\n> >\n> >\n> > ------\n> >\n> > I'd also propose that we add a message which is SYNC, which indicates\n> the end of a list of FEATURES and a request to\n> > send ACKS or NACKS back (which are followed by a SYNC). This allows\n> multi-round negotiation where based on the presence\n> > of other features, I may expand the set of features I am offering. I\n> think you could do without SYNC, but there are more\n> > edge cases and the explicitness is nice given that this already\n> introduces future complexity.\n> >\n> > This multi-round makes it an actual negotiation rather than a pure\n> announcement system. I don't think it would be used\n> > much in the near term, but it makes sense to define it correctly now.\n> Build for the future and all...\n> >\n> >\n> >\n> > --\n> > @JeremyRubin <https://twitter.com/JeremyRubin><\n> https://twitter.com/JeremyRubin>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/4814eb47/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-21T21:17:32",
                "message_text_only": "As for an example of where you'd want multi-round, you could imagine a\nscenario where you have a feature A which gets bugfixed by the introduction\nof feature B, and you don't want to expose that you support A unless you\nfirst negotiate B. Or if you can negotiate B you should never expose A, but\nfor old nodes you'll still do it if B is unknown to them. An example of\nthis would be (were it not already out without a feature negotiation\nexisting) WTXID/TXID relay.\n\nThe SYNC primitve simply codifies what order messages should be in and when\nyou're done for a phase of negotiation offering something. It can be done\nwithout, but then you have to be more careful to broadcast in the correct\norder and it's not clear when/if you should wait for more time before\nresponding.\n\n\nOn Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Actually we already have service bits (which are sadly limited) which\n> allow negotiation of non bilateral feature support, so this would supercede\n> that.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/2517650e/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-08-21T22:16:02",
                "message_text_only": "Hmm, could that not be accomplished by simply building this into new messages? eg, send \"betterprotocol\", if you see a \nverack and no \"betterprotocol\" from your peer, send \"worseprotocol\" before you send a \"verack\".\n\nMatt\n\nOn 8/21/20 5:17 PM, Jeremy wrote:\n> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets \n> bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. \n> Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them. An \n> example of this would be (were it not already out without a feature negotiation existing) WTXID/TXID relay.\n> \n> The SYNC primitve simply codifies what order messages should be in and when you're done for a phase of negotiation \n> offering something. It can be done without, but then you have to be more careful to broadcast in the correct order and \n> it's not clear when/if you should wait for more time before responding.\n> \n> \n> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:jlrubin at mit.edu>> wrote:\n> \n>     Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature\n>     support, so this would supercede that.\n>     --\n>     @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>\n>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-23T17:49:35",
                "message_text_only": "> On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n> \n> \ufeffHmm, could that not be accomplished by simply building this into new messages? eg, send \"betterprotocol\", if you see a verack and no \"betterprotocol\" from your peer, send \"worseprotocol\" before you send a \"verack\".\n> \n> Matt\n> \n>> On 8/21/20 5:17 PM, Jeremy wrote:\n>> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them.\n\nThis seems to imply a security benefit (I can\u2019t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.\n\n>> An example of this would be (were it not already out without a feature negotiation existing) WTXID/TXID relay.\n>> The SYNC primitve simply codifies what order messages should be in and when you're done for a phase of negotiation offering something. It can be done without, but then you have to be more careful to broadcast in the correct order and it's not clear when/if you should wait for more time before responding.\n>> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:jlrubin at mit.edu>> wrote:\n>>    Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature\n>>    support, so this would supercede that.\n>>    --\n>>    @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2020-08-24T09:44:07",
                "message_text_only": "Hi all,\n\nThanks for the helpful discussion.\n\nMy primary motivation in starting this thread was to establish what the\nexpectations are for new feature deployment (particularly whether the\nprotocol version should continue to be bumped or not), and I think I have\nthat answer -- different from what I proposed when I started this thread,\nbut not in a way that I think meaningfully hinders future work.  So I'm\nhappy to leave it at that and withdraw my suggestion.\n\nCheers,\nSuhas\n\n\nOn Sun, Aug 23, 2020 at 1:51 PM Eric Voskuil via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> > On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n> >\n> > \ufeffHmm, could that not be accomplished by simply building this into new\n> messages? eg, send \"betterprotocol\", if you see a verack and no\n> \"betterprotocol\" from your peer, send \"worseprotocol\" before you send a\n> \"verack\".\n> >\n> > Matt\n> >\n> >> On 8/21/20 5:17 PM, Jeremy wrote:\n> >> As for an example of where you'd want multi-round, you could imagine a\n> scenario where you have a feature A which gets bugfixed by the introduction\n> of feature B, and you don't want to expose that you support A unless you\n> first negotiate B. Or if you can negotiate B you should never expose A, but\n> for old nodes you'll still do it if B is unknown to them.\n>\n> This seems to imply a security benefit (I can\u2019t discern any other\n> rationale for this complexity). It should be clear that this is no more\n> than trivially weak obfuscation and not worth complicating the protocol to\n> achieve.\n>\n> >> An example of this would be (were it not already out without a feature\n> negotiation existing) WTXID/TXID relay.\n> >> The SYNC primitve simply codifies what order messages should be in and\n> when you're done for a phase of negotiation offering something. It can be\n> done without, but then you have to be more careful to broadcast in the\n> correct order and it's not clear when/if you should wait for more time\n> before responding.\n> >> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:\n> jlrubin at mit.edu>> wrote:\n> >>    Actually we already have service bits (which are sadly limited)\n> which allow negotiation of non bilateral feature\n> >>    support, so this would supercede that.\n> >>    --\n> >>    @JeremyRubin <https://twitter.com/JeremyRubin><\n> https://twitter.com/JeremyRubin>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/895e4c0a/attachment-0001.html>"
            },
            {
                "author": "G. Andrew Stone",
                "date": "2020-08-24T13:59:26",
                "message_text_only": "Since discussion around allowing unknown messages or not allowing them\nseems contentious, I'd like to offer up another possibility: create a\nsingle new message, XVERSION, (and bump the protocol rev) which is a\nkey-value array of arbitrary data.  Any protocol extension can then choose\na new key (with a 32 or 64 bit keyspace you can basically hand out prefixes\nto any implementation that wants one)  and publish custom data via this\nmessage without needing to bump the protocol rev field.  Typical \"custom\ndata\" would be the min and max supported version of some specific extended\nprotocol, but any data is possible since the \"value\" field can be\nserialized via the same network serialization format.  It therefore doubles\nas a \"configuration\" message as well as protocol extension negotiation.\nFor example, we use it to communicate the maximum unconfirmed chain a node\nwill commit to the mempool, and peers don't bother to send transactions\nthat exceed this limit.\n\nYou can find a specification here:\nhttps://gitlab.com/bitcoinunlimited/BCHUnlimited/-/blob/dev/doc/xversionmessage.md\n\nCode has been deployed for a long time.\n\nRegards,\nAndrew\n\n\nOn Mon, Aug 24, 2020 at 5:44 AM Suhas Daftuar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Thanks for the helpful discussion.\n>\n> My primary motivation in starting this thread was to establish what the\n> expectations are for new feature deployment (particularly whether the\n> protocol version should continue to be bumped or not), and I think I have\n> that answer -- different from what I proposed when I started this thread,\n> but not in a way that I think meaningfully hinders future work.  So I'm\n> happy to leave it at that and withdraw my suggestion.\n>\n> Cheers,\n> Suhas\n>\n>\n> On Sun, Aug 23, 2020 at 1:51 PM Eric Voskuil via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> > On Aug 21, 2020, at 15:16, Matt Corallo <lf-lists at mattcorallo.com>\n>> wrote:\n>> >\n>> > \ufeffHmm, could that not be accomplished by simply building this into new\n>> messages? eg, send \"betterprotocol\", if you see a verack and no\n>> \"betterprotocol\" from your peer, send \"worseprotocol\" before you send a\n>> \"verack\".\n>> >\n>> > Matt\n>> >\n>> >> On 8/21/20 5:17 PM, Jeremy wrote:\n>> >> As for an example of where you'd want multi-round, you could imagine a\n>> scenario where you have a feature A which gets bugfixed by the introduction\n>> of feature B, and you don't want to expose that you support A unless you\n>> first negotiate B. Or if you can negotiate B you should never expose A, but\n>> for old nodes you'll still do it if B is unknown to them.\n>>\n>> This seems to imply a security benefit (I can\u2019t discern any other\n>> rationale for this complexity). It should be clear that this is no more\n>> than trivially weak obfuscation and not worth complicating the protocol to\n>> achieve.\n>>\n>> >> An example of this would be (were it not already out without a feature\n>> negotiation existing) WTXID/TXID relay.\n>> >> The SYNC primitve simply codifies what order messages should be in and\n>> when you're done for a phase of negotiation offering something. It can be\n>> done without, but then you have to be more careful to broadcast in the\n>> correct order and it's not clear when/if you should wait for more time\n>> before responding.\n>> >> On Fri, Aug 21, 2020 at 2:08 PM Jeremy <jlrubin at mit.edu <mailto:\n>> jlrubin at mit.edu>> wrote:\n>> >>    Actually we already have service bits (which are sadly limited)\n>> which allow negotiation of non bilateral feature\n>> >>    support, so this would supercede that.\n>> >>    --\n>> >>    @JeremyRubin <https://twitter.com/JeremyRubin><\n>> https://twitter.com/JeremyRubin>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/3991406e/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-24T19:58:56",
                "message_text_only": ">\n>\n>\n>\n>\n>\n> * >> On 8/21/20 5:17 PM, Jeremy wrote: >> As for an example of where you'd\n> want multi-round, you could imagine a scenario where you have a feature A\n> which gets bugfixed by the introduction of feature B, and you don't want to\n> expose that you support A unless you first negotiate B. Or if you can\n> negotiate B you should never expose A, but for old nodes you'll still do it\n> if B is unknown to them. This seems to imply a security benefit (I can\u2019t\n> discern any other rationale for this complexity). It should be clear that\n> this is no more than trivially weak obfuscation and not worth complicating\n> the protocol to achieve.*\n\n\nThe benefit is not privacy oriented and I didn't intend to imply as such.\nThe benefit is that you may only wish to expose functionality to peers\nwhich support some other set of features. For example, with wtxid relay, I\nmight want to expose some additional functionality after establishing my\npeer supports it, that peers which do not have wtxid relay should not be\nallowed to use. The benefit over just exposing all functions is then a node\nmight be programmed to support the new feature but not wtxid relay, which\ncan lead to some incompatibilities.\n\nYou cannot implement this logic as a purely post-hoc \"advertise all and\nthen figure out what is allowed\" because then you require strict\nconsistency between peers of that post-hoc feature availability implication\nmap.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/f26112b9/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-24T20:17:17",
                "message_text_only": "I said security, not privacy. You are in fact exposing the feature to any node that wants to negotiate for it. if you don\u2019t want to expose the buggy feature, then disable it. Otherwise you cannot prevent peers from accessing it. Presumably peers prefer the new feature if they support it, so there is no need for this complexity.\n\ne\n\n> On Aug 24, 2020, at 12:59, Jeremy <jlrubin at mit.edu> wrote:\n> \n> \ufeff\n>> \n>> >> On 8/21/20 5:17 PM, Jeremy wrote:\n>> >> As for an example of where you'd want multi-round, you could imagine a scenario where you have a feature A which gets bugfixed by the introduction of feature B, and you don't want to expose that you support A unless you first negotiate B. Or if you can negotiate B you should never expose A, but for old nodes you'll still do it if B is unknown to them.\n>> \n>> This seems to imply a security benefit (I can\u2019t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.\n> \n> \n> The benefit is not privacy oriented and I didn't intend to imply as such. The benefit is that you may only wish to expose functionality to peers which support some other set of features. For example, with wtxid relay, I might want to expose some additional functionality after establishing my peer supports it, that peers which do not have wtxid relay should not be allowed to use. The benefit over just exposing all functions is then a node might be programmed to support the new feature but not wtxid relay, which can lead to some incompatibilities.\n> \n> You cannot implement this logic as a purely post-hoc \"advertise all and then figure out what is allowed\" because then you require strict consistency between peers of that post-hoc feature availability implication map.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/edfe09fb/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-24T20:21:52",
                "message_text_only": "On Mon, Aug 24, 2020 at 1:17 PM Eric Voskuil <eric at voskuil.org> wrote:\n\n> I said security, not privacy. You are in fact exposing the feature to any\n> node that wants to negotiate for it. if you don\u2019t want to expose the buggy\n> feature, then disable it. Otherwise you cannot prevent peers from accessing\n> it. Presumably peers prefer the new feature if they support it, so there is\n> no need for this complexity.\n>\n>\n>\nI interpreted* \" This seems to imply a security benefit (I can\u2019t discern\nany other rationale for this complexity). It should be clear that this is\nno more than trivially weak obfuscation and not worth complicating the\nprotocol to achieve.\", *to be about obfuscation and therefore privacy.\n\nThe functionality that I'm mentioning might not be buggy, it might just not\nsupport peers who don't support another feature. You can always disconnect\na peer who sends a message that you didn't handshake on (or maybe we should\nelbow bump given the times).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/27b10d97/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-24T20:33:46",
                "message_text_only": "I see no requirement for anything here apart from exchanging a list of supported \u201cfeatures\u201d. Conditionally hiding a feature provides no benefit. Any peer that wants it can get it (obfuscation being weak security), and otherwise it\u2019s a non-issue.\n\ne\n\n> On Aug 24, 2020, at 13:22, Jeremy <jlrubin at mit.edu> wrote:\n> \n>> On Mon, Aug 24, 2020 at 1:17 PM Eric Voskuil <eric at voskuil.org> wrote:\n>> I said security, not privacy. You are in fact exposing the feature to any node that wants to negotiate for it. if you don\u2019t want to expose the buggy feature, then disable it. Otherwise you cannot prevent peers from accessing it. Presumably peers prefer the new feature if they support it, so there is no need for this complexity.\n> \n> I interpreted \" This seems to imply a security benefit (I can\u2019t discern any other rationale for this complexity). It should be clear that this is no more than trivially weak obfuscation and not worth complicating the protocol to achieve.\", to be about obfuscation and therefore privacy.\n> \n> The functionality that I'm mentioning might not be buggy, it might just not support peers who don't support another feature. You can always disconnect a peer who sends a message that you didn't handshake on (or maybe we should elbow bump given the times).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200824/e5e1facc/attachment-0001.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-21T21:17:55",
                "message_text_only": "Service bits are advertised, protocol support is not.\n\nhttps://en.bitcoin.it/wiki/Protocol_documentation#Network_address\n\ne\n\n> On Aug 21, 2020, at 14:08, Jeremy <jlrubin at mit.edu> wrote:\n> \n> \ufeff\n> Actually we already have service bits (which are sadly limited) which allow negotiation of non bilateral feature support, so this would supercede that.\n> --\n> @JeremyRubin\n> \n> \n>> On Fri, Aug 21, 2020 at 1:45 PM Matt Corallo <lf-lists at mattcorallo.com> wrote:\n>> This seems to be pretty overengineered. Do you have a specific use-case in mind for anything more than simply continuing \n>> the pattern we've been using of sending a message indicating support for a given feature? If we find some in the future, \n>> we could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.\n>> \n>> The great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the \n>> flexibility we need. Even better, the code already exists.\n>> \n>> Matt\n>> \n>> On 8/21/20 3:50 PM, Jeremy wrote:\n>> > I have a proposal:\n>> > \n>> > Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature \n>> > negotiation.\n>> > \n>> > This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be \n>> > clear that we're acking more than version.\n>> > \n>> > I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free \n>> > choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea \n>> > that protocol number and feature support are tied.\n>> > \n>> > But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree \n>> > on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK \n>> > would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was \n>> > intentional.\n>> > \n>> > ------\n>> > \n>> > AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period \n>> > are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p \n>> > message name w/o any data).\n>> > \n>> > I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for \n>> > ACKing that a feature is enabled. This is because a transcript of:\n>> > \n>> > NODE0:\n>> > FEATURE A\n>> > FEATURE B\n>> > VERACK\n>> > \n>> > NODE1:\n>> > FEATURE A\n>> > VERACK\n>> > \n>> > It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:\n>> > \n>> > NODE0:\n>> > FEATURE A\n>> > FEATURE B\n>> > FEATURE C\n>> > ACK A\n>> > VERACK\n>> > \n>> > NODE1:\n>> > FEATURE A\n>> > ACK A\n>> > NACK B\n>> > VERACK\n>> > \n>> > would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support \n>> > inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message \n>> > FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.\n>> > \n>> > \n>> > ------\n>> > \n>> > I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to \n>> > send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence \n>> > of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more \n>> > edge cases and the explicitness is nice given that this already introduces future complexity.\n>> > \n>> > This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used \n>> > much in the near term, but it makes sense to define it correctly now. Build for the future and all...\n>> > \n>> > \n>> > \n>> > --\n>> > @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/f8dbf6e4/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2020-08-23T17:45:45",
                "message_text_only": "> On Aug 21, 2020, at 13:45, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n> \n> \ufeffThis seems to be pretty overengineered.\n\nI agree. In fact all proposals I\u2019ve seen on this are over engineered.\n\n> Do you have a specific use-case in mind for anything more than simply continuing the pattern we've been using of sending a message indicating support for a given feature?\n\nCorrect me if I\u2019m wrong, but this pattern is what the proposal aims to eliminate. There is no reason whatsoever for a message per indication. The appropriate pattern is already established in the implementation of service bits. In fact in this discussion it has been pointed out that the problem with service bits is simply too few bits.\n\n> If we find some in the future,\n\n> we could deploy something like this, though the current proposal makes it possible to do it on a per-feature case.\n\nAs does any other proposal, including passage of the full set of optional sub-protocols in the verack.\n\n> The great thing about Suhas' proposal is the diff is about -1/+1 (not including tests), while still getting all the flexibility we need.\n\n> Even better, the code already exists.\n\nThis is neither true nor relevant. Maybe the Segwit 2X guys should have used this argument.\n\ne\n\n\n> Matt\n> \n>> On 8/21/20 3:50 PM, Jeremy wrote:\n>> I have a proposal:\n>> Protocol >= 70016 cease to send or process VERACK, and instead use HANDSHAKEACK, which is completed after feature negotiation.\n>> This should make everyone happy/unhappy, as in a new protocol number it's fair game to change these semantics to be clear that we're acking more than version.\n>> I don't care about when or where these messages are sequenced overall, it seems to have minimal impact. If I had free choice, I slightly agree with Eric that verack should come before feature negotiation, as we want to divorce the idea that protocol number and feature support are tied.\n>> But once this is done, we can supplant Verack with HANDSHAKENACK or HANDSHAKEACK to signal success or failure to agree on a connection. A NACK reason (version too high/low or an important feature missing) could be optional. Implicit NACK would be disconnecting, but is discouraged because a peer doesn't know if it should reconnect or the failure was intentional.\n>> ------\n>> AJ: I think I generally do prefer to have a FEATURE wrapper as you suggested, or a rule that all messages in this period are interpreted as features (and may be redundant with p2p message types -- so you can literally just use the p2p message name w/o any data).\n>> I think we would want a semantic (which could be based just on message names, but first-class support would be nice) for ACKing that a feature is enabled. This is because a transcript of:\n>> NODE0:\n>> FEATURE A\n>> FEATURE B\n>> VERACK\n>> NODE1:\n>> FEATURE A\n>> VERACK\n>> It remains unclear if Node 1 ignored B because it's an unknown feature, or because it is disabled. A transcript like:\n>> NODE0:\n>> FEATURE A\n>> FEATURE B\n>> FEATURE C\n>> ACK A\n>> VERACK\n>> NODE1:\n>> FEATURE A\n>> ACK A\n>> NACK B\n>> VERACK\n>> would make it clear that A and B are known, B is disabled, and C is unknown. C has 0 support, B Node 0 should support inbound messages but knows not to send to Node 1, and A has full bilateral support. Maybe instead it could a message FEATURE SEND A and FEATURE RECV A, so we can make the split explicit rather than inferred from ACK/NACK.\n>> ------\n>> I'd also propose that we add a message which is SYNC, which indicates the end of a list of FEATURES and a request to send ACKS or NACKS back (which are followed by a SYNC). This allows multi-round negotiation where based on the presence of other features, I may expand the set of features I am offering. I think you could do without SYNC, but there are more edge cases and the explicitness is nice given that this already introduces future complexity.\n>> This multi-round makes it an actual negotiation rather than a pure announcement system. I don't think it would be used much in the near term, but it makes sense to define it correctly now. Build for the future and all...\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin><https://twitter.com/JeremyRubin>"
            }
        ],
        "thread_summary": {
            "title": "Generalizing feature negotiation when new p2p connections are setup",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Jeremy",
                "David A. Harding",
                "Suhas Daftuar",
                "Anthony Towns",
                "lf-lists at mattcorallo.com",
                "Matt Corallo",
                "G. Andrew Stone"
            ],
            "messages_count": 30,
            "total_messages_chars_count": 110947
        }
    },
    {
        "title": "[bitcoin-dev] reviving op_difficulty",
        "thread_messages": [
            {
                "author": "Thomas Hartman",
                "date": "2020-08-16T15:41:30",
                "message_text_only": "First, I would like to pay respects to tamas blummer, RIP.\n\nhttps://bitcoinmagazine.com/articles/remembering-tamas-blummer-pioneering-bitcoin-developer\n\nTamas proposed an additional opcode for enabling bitcoin difficulty\nfutures, on this list at\n\nhttps://www.mail-archive.com/bitcoin-dev@lists.linuxfoundation.org/msg07991.html\n\nI really like this idea.\n\n1) Trusted third parties are security holes\n\nhttps://nakamotoinstitute.org/trusted-third-parties/\n\nand oracles (eg discreet log contracts) are really just trusted third\nparties in a blockchain's clothing. So truly ttp-free oracle-free on\nchain contracts are good.\n\n2) Difficulty is a proxy for energy, which is a proxy for usd, which\nis what everyone currently cares about, which is bad. Energy is real.\nBitcoin traders should care about future difficulty, not future usd\nprice.\n\nSo in sum I think this is a very good idea, and I would like to\ncontinue this work. Ideally I would like to see to completion the BIP\nthat Tamas was unable to produce.\n\nSome initial thoughts on the technical merits.\n\nMy understanding is that adding a single op_difficulty operation as\nproposed would enable not true difficulty futures but binary options\non difficulty.\n\nhttps://en.wikipedia.org/wiki/Binary_option\n\nAs the wikipedia article notes, \"While binary options may be used in\ntheoretical asset pricing, they are prone to fraud in their\napplications and hence banned by regulators in many jurisdictions as a\nform of gambling.\" The trouble is that because of the all or nothing\nnature binary options are more of a gamble than a hedge. They are\npopular with scammers, and even licensed binary options exchanges such\nas nadex are under constant scrutiny by regulators.\n\nBecause any form of trusted third party-free / oracle free speculation\nwould encourage economic use of blockchain space and support the\ntransaction fee market, perhaps an economic case can be made for naive\nop_difficulty as above even it has more of a flavor of gambling than\nhedging. I think at a psychological level it would be good for a\nttp-free difficulty speculation tool to capture mindshare.\n\nThat being said, true difficulty futures -- real hedging and not just\ngambling --  would be far healthier for bitcoin than binary options. I\nam trying to wrangle what additional opcodes and protocol changes\nwould be required beyond just op_difficulty, to get true difficulty\nfutures on chain.\n\nI envision something like this. To give some context: Current\ndifficulty is 16.9 Trillion. We're a week in to the current difficulty\nregime so there's aboout 1000 blocks to retarget, and predicted next\ndifficuly is 18.5 Trillion. So let's pretend we sell a difficulty\nfuture that pays out in sats, of the next difficulty divided by a\ntrillion. A reasonable price for this would be, say, 17.4 sats.\n\nSo in our op_difficulty utxo, one address (the futures buyer) would\nget current difficulty / trillion, and the other address (the seller)\nwould get however much value is locked in the utxo, minus that amount\nand miner fee. The payout would be limited by however much value is\nlocked in the utxo. Since difficulty adjusts very slowly I don't think\noverflowing the locked up value would be much of a problem in\npractice. We also want a mechanism to enable on-chain purchase of such\na contract, say for 17.4 sats.\n\nOne additional opcode that apparently would be required is division.\nSome version of rshift could also do.\n\nI am not clear if there is a way to solve the accounting for the\npayouts, but perhaps there is a way to do this with covenants.\n\nI'm somewhat new to protocol and script. I would appreciate if anyone\nhas any further advice on this.\n\nCheers, Thomas."
            },
            {
                "author": "Tier Nolan",
                "date": "2020-08-16T18:59:25",
                "message_text_only": "On Sun, Aug 16, 2020 at 4:50 PM Thomas Hartman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> My understanding is that adding a single op_difficulty operation as\n> proposed would enable not true difficulty futures but binary options\n> on difficulty.\n>\n> https://en.wikipedia.org/wiki/Binary_option\n\n\nAny kind of opcode is a binary option.  Either the output can be spent or\nit can't.\n\nYou could get a pseudo-continuous future by having lots of outputs with\ndifferent thresholds.\n\nAlice and Bob create a transaction with 100 outputs and each having 1% of\nthe future's value.\n\nOutput 0:  Pay Alice if diff < 1.00 trillion else Bob\nOutput 1:  Pay Alice if diff < 1.01 trillion else Bob\n....\nOutput 98:  Pay Alice if diff < 1.98 trillion else Bob\nOutput 99:  Pay Alice if diff < 1.99 trillion else Bob\n\nIf the difficulty is 1.25 trillion, then Alice gets outputs 0-24 and Bob\ngets outputs 25-99.  The future has a tick size of 1%.  It isn't very\nefficient though\n\nIt would be good to have the option to specify a block height for the\nfuture too.  If it triggered on block time, then miners have an incentive\nto give false block times.\n\nI am not clear if there is a way to solve the accounting for the\n> payouts, but perhaps there is a way to do this with covenants.\n>\n\nI agree you would need covenants or something similar.\n\nThere needs to be a way to check the outputs (value and script) of the\nspending transaction.  You also need a way for Alice and Bob to create\ntheir spending transaction in sequence.\n\nOutput 0: Pay Alice if [output value 0] <= Diff / 1 trillion AND [output\nvalue 1] >= (2 trillion - diff)  / (1 trillion) AND [output 1 pays to Bob]\n\nTo spend her output, Alice has to create a transaction which pays Bob and\nassigns the coins in the right ratio.  [output value x] means the output\nvalue of the spending transaction for output x.\n\nTo get it to work Alice creates a transaction with these restrictions\n\nOutput 0:\nScript: Anything (Alice gets it to pay herself)\nValue: <= Diff / 1 trillion\n\nOutput 1:\nScript: Must pay to Bob\nValue: >= (2 trillion - Diff) / 1 trillion\n\nYou also need to handle overflows with the calculations.\n\nBob can then spend output 1 and get his money.\n\nThere is a hold-up risk if Alice doesn't spend her money.  You can make the\noutput script so either of them can spend their coins to avoid that.\n\nOutput 0:\n    Pay Alice if [output value 0] <= Diff / 1 trillion AND [output value 1]\n>= (2 trillion - diff)  / (1 trillion) AND [output 1 pays to Bob]\n      OR\n    Pay Bob if [output value 0] <= (2 trillion - Diff) / 1 trillion AND\n[output value 1] >= Diff / (1 trillion) AND [output 1 pays to Alice]\n\nYou would need a covenant-like instruction to check the output values and\nscripts and the diff opcode to get the difficulty.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200816/63df27eb/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-17T05:04:42",
                "message_text_only": "Good morning Tier, Thomas, and aj,\n\n> On Sun, Aug 16, 2020 at 4:50 PM Thomas Hartman via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > My understanding is that adding a single op_difficulty operation as\n> > proposed would enable not true difficulty futures but binary options\n> > on difficulty.\n> >\n> > https://en.wikipedia.org/wiki/Binary_option\n>\n> Any kind of opcode is a binary option.\u00a0 Either the output can be spent or it can't.\n>\n> You could get a pseudo-continuous future by having lots of outputs with different thresholds.\n>\n> Alice and Bob create a transaction with 100 outputs and each having 1% of the future's value.\n>\n> Output 0:\u00a0 Pay Alice if diff < 1.00 trillion else Bob\n> Output 1:\u00a0 Pay Alice if diff < 1.01 trillion else Bob\n> ....\n> Output 98:\u00a0 Pay Alice if diff < 1.98 trillion else Bob\n> Output 99:\u00a0 Pay Alice if diff < 1.99 trillion else Bob\n>\n> If the difficulty is 1.25 trillion, then Alice gets outputs 0-24 and Bob gets outputs 25-99.\u00a0 The future has a tick size of 1%.\u00a0 It isn't very efficient though\n\nTaproot MAST to the rescue.\n\n* Alice and Bob agree on the number of ticks N and payout schedule.\n* Alice and Bob generate N fresh keypairs and share them.\n* Alice and Bob generate tapleaf scripts of the form:\n  * script[i] = Alice[i] && Bob[i] && diff < 1.00 trillion + i * tick_size && CLTV(deadline)\n* Alice and Bob generate the taproot MAST for the above scripts.\n* Alice and Bob generate, but do ***NOT*** sign, a funding transaction paying out to the generated taproot MAST.\n* Bob generates partial signatures for N payout transactions, with lower-difficulty-targets paying out less to Alice and more to Bob, and higher-difficulty-targets paying out more to Alice and less to Bob.\n  * This requires spending the [i]th tapleaf script with the appropriate difficulty target.\n* Alice saves all the Bob signatures.\n* At deadline, Alice rationally selects the highest-paying version that is still acceptable, based on the actual difficulty target at the time.\n\nThis requires publishing only O(log N) data (the merkle path to the selected tapleaf).\nThis translates to the 100-tick example requiring only one TXO, 1 scripthash, and 7 or so Merkle-tree-path hashes, compared to the above example which requires 100 TXOs and 100 script hashes.\n\nThe same scheme can be used with `OP_CTV` and without keypairs being involved, but basically anything `OP_CTV` can do, signing keypairs with pre-generated signatures from all participants can do just as well, with higher storage and setup costs.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Thomas Hartman",
                "date": "2020-08-17T19:48:27",
                "message_text_only": "Tier, AJ, ZmnSCPxj, thanks! \n\n> On Aug 17, 2020, at 1:04 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Taproot MAST to the rescue.\n\nOK. So, using the tick scheme described by Tier a difficulty futures instrument is possible with current script + op_diff; and with taproot + op_diff (ZmnSCPxj) it may even be economical. (I will set aside covenants for now.)\n\nTo do it all on-chain, we need a mechanism for selling such an instrument in a trustless way.\n\nThat is to say (using ZmnSCPxj's construction), we have now a future where Bob pays Alice a pico-difficulty at next adjustment. \n\nBut how does Alice pay Bob his 17.4 sat?\n\nI am trying to figure out a way to do this naively using the base layer. (I really want this with lightning, and eventually hft, but first things first.)\n\nMy thinking so far is, Alice and Bob collaborate to create partial versions of\n\n** the difficulty future funded by Bob, spendable by Alice in 1000 blocks\n** and a 17.4 sat payment from Alice to Bob, spendable by Bob immediately\n\nWhen Bob completes and broadcasts the payment from Alice, it should enable Alice to complete and broadcast the difficulty future funded by Bob. \n\nI am thinking a hash lock on the payment, with a preimage secret generated by Bob, could be used to accomplish this. When Bob unlocks and broadcasts the payment, this reveals the preimage, and with the preimage Alice can unlock and broadcast the difficulty future funded by Bob. \n\nAm I correct in thinking something like this could work?  \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/444a999a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-08-17T23:14:00",
                "message_text_only": "Good morning Thomas,\n\n> Tier, AJ, ZmnSCPxj, thanks!\u00a0\n>\n> > On Aug 17, 2020, at 1:04 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > Taproot MAST to the rescue.\n>\n> OK. So, using the tick scheme described by Tier a difficulty futures instrument is possible with current script + op_diff; and with taproot + op_diff (ZmnSCPxj) it may even be economical. (I will set aside covenants for now.)\n>\n> To do it all on-chain, we need a mechanism for selling such an instrument in a trustless way.\n>\n> That is to say (using ZmnSCPxj's construction), we have now a future where Bob pays Alice a pico-difficulty at next adjustment.\u00a0\n>\n> But how does Alice pay Bob his 17.4 sat?\n>\n> I am trying to figure out a way to do this naively using the base layer. (I really want this with lightning, and eventually hft, but first things first.)\n>\n> My thinking so far is, Alice and Bob collaborate to create partial versions of\n>\n> ** the difficulty future funded by Bob, spendable by Alice in 1000 blocks\n> ** and a 17.4 sat payment from Alice to Bob, spendable by Bob immediately\n>\n> When Bob completes and broadcasts the payment from Alice, it should enable Alice to complete and broadcast the difficulty future funded by Bob.\u00a0\n>\n> I am thinking a hash lock on the payment, with a preimage secret generated by Bob, could be used to accomplish this. When Bob unlocks and broadcasts the payment, this reveals the preimage, and with the preimage Alice can unlock and broadcast the difficulty future funded by Bob.\u00a0\n>\n> Am I correct in thinking something like this could work?\n\nBitcoin transactions on the blockchain layer are atomic, so it would be far simpler to make the purchase output and the options output in the same transaction, in a sort of PayJoin-like cooperatively-signed transaction.\n\nThat said, the construction you are imagining is indeed going to work.\nThe only requirement is that the hash-branch needs two signatures in order to ensure that it pays out to a transaction with a very specific contract.\nXref.  how Lightning *really* creates its HTLCs.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tier Nolan",
                "date": "2020-08-17T21:55:04",
                "message_text_only": "On Mon, Aug 17, 2020 at 6:04 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Taproot MAST to the rescue.\n>\n\nAnother option would be a binary payout\n\nYou pay 64 + 32 + 16 + 8 + 4 + 2 + 1 as outputs.  The outputs are\nenabled/disabled based on the diff value.  This would require division and\nalso binary operators.\n\nD = (int) ((100 * diff) / (1 trillion))\n\nOutput 0: 1.28:  If (D & 128) then pay Alice otherwise Bob\nOutput 0: 0.64:  If (D & 64) then pay Alice otherwise Bob\nOutput 0: 0.32:  If (D & 32) then pay Alice otherwise Bob\nOutput 0: 0.16:  If (D & 16) then pay Alice otherwise Bob\nOutput 0: 0.8:  If (D & 8) then pay Alice otherwise Bob\nOutput 0: 0.4:  If (D & 4) then pay Alice otherwise Bob\nOutput 0: 0.4:  If (D & 4) then pay Alice otherwise Bob\nOutput 0: 0.4:  If (D & 4) then pay Alice otherwise Bob\n\nThis has log performance in terms of the number of ticks like the MAST\nsolution.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200817/a3fd8bd8/attachment.html>"
            },
            {
                "author": "Thomas Hartman",
                "date": "2020-08-19T21:15:08",
                "message_text_only": "> On Aug 16, 2020, at 2:59 PM, Tier Nolan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Output 0:  Pay Alice if diff < 1.00 trillion else Bob\n\nWhat is included in blocks is a packed representation of the difficulty target, not the difficulty per se as typically reported on blockchain explorer. \n\nhttps://en.bitcoin.it/wiki/Difficulty <https://en.bitcoin.it/wiki/Difficulty>\n\nPerhaps what is best for speculation contracts is not the difficulty per se, but the ratio between some unknown future difficulty and the current difficulty. That is easily obtained from the packed representations already included in blocks. IE\n\nCurrent difficulty / last difficulty = 1 / ( current target / last target )\n\nTo give a worked example, current difficulty is 16.94T, and last difficulty was 16.84T. \nCurrent packed target is 0x17109bac, last packed target is  0x1710b4f8\t\n16.94 / 16.84 is same as 1 / ( 0x109ba / 0x10b4f8  )  (the 17 is an exponent in both cases so leaving it out for clarity). \n\nSo perhaps the way op_diff should work is take 2 packed targets, 1 known and 1 unknown at time of contract, and return the ratio. \n\nThe contract could then work as previously described, except using the ratio for ticks instead of the difficulty.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200819/4a4b1a9f/attachment.html>"
            },
            {
                "author": "Thomas Hartman",
                "date": "2020-08-19T23:32:25",
                "message_text_only": "> \n> So perhaps the way op_diff should work is take 2 packed targets, 1 known and 1 unknown at time of contract, and return the ratio. \n\nOn second thought, I don\u2019t think this is a good idea. The 32-bit packed difficulty target is equivalent to difficulty, and this is probably what should get pushed onto the stack. No division is needed, just the arithmetic less than operator, which is already live in script, using the tick strategy described by Tier. So it seems to me these contracts could truly be done with the addition of the single op_diff opcode. It\u2019s probably less human readable to be using difficulty target instead of difficulty, but no one reads script anyway. \n\nIt was also bothering me that difficulty was a floating point number (I have floating point phobia), so it is great not to have to think about floats anymore!"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-08-16T22:29:23",
                "message_text_only": "On Sun, Aug 16, 2020 at 11:41:30AM -0400, Thomas Hartman via bitcoin-dev wrote:\n> My understanding is that adding a single op_difficulty operation as\n> proposed would enable not true difficulty futures but binary options\n> on difficulty.\n\nAn alternative approach for this might be to use taproot's annex concept.\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-5\n\nThe idea would be to add an annex restriction that's only valid if the\ndifficulty is a given value (or within a given range). Protocol design\ncould be:\n\n  Alice, Bob, Carol, Dave want to make bets on difficulty futures\n  They each deposit a,b,c,d into a UTXO of value a+b+c+d payable to\n    a 4-4 of multisig of their keys (eg MuSig(A,B,c,D))\n  They construct signed payouts spending that UTXO, all timelocked\n    for the future date; one spending to Alice with the annex locking\n    in the difficulty to Alice's predicted range, one spending to Bob\n    with the annex locking in the difficulty to Bob's predicted range,\n    etc\n\nWhen the future date arrives, whoever was right can immediately\nbroadcast their payout transaction. (If they don't, then someone else\nmight be able to when the difficulty next retargets)\n\n(Specifying an exact value for the difficulty rather than a range might\nbe better; it's smaller/simpler on the blockchain, and doesn't reveal\nthe ranges of your predictions giving traders slightly better privacy.\nThe cost to doing that is if Alice predicts difficulty could be any of 100\ndifferent values, she needs 100 different signatures for her pre-signed\npayout, one for each possible difficulty value that would be encoded in\nthe annex)\n\nCheers,\naj"
            },
            {
                "author": "David A. Harding",
                "date": "2020-08-22T16:46:20",
                "message_text_only": "On Sun, Aug 16, 2020 at 11:41:30AM -0400, Thomas Hartman via bitcoin-dev wrote:\n> First, I would like to pay respects to tamas blummer, RIP.\n> \n> https://bitcoinmagazine.com/articles/remembering-tamas-blummer-pioneering-bitcoin-developer\n\nRIP, Tamas.\n\n> Tamas proposed an additional opcode for enabling bitcoin difficulty\n> futures, on this list at\n> \n> https://www.mail-archive.com/bitcoin-dev@lists.linuxfoundation.org/msg07991.html\n\nSubsequent to Blummer's post, I heard from Jeremy Rubin about a\nscheme[1] that allows difficulty futures without requiring any changes\nto Bitcoin.  In short, it takes advantage of the fact that changes in\ndifficulty also cause a difference in maturation time between timelocks\nand height-locks.  As an simple example:\n\n1. Alice and Bob create an unsigned transaction that deposits their\n   money into a 2-of-2 multisig.\n\n2. They cooperate to create and sign two conflicting spends from the multisig:\n\n    a. Pays Alice with an nLockTime(height) of CURRENT_HEIGHT + 2016 blocks\n\n    b. Pays Bob with an nLockTime(time) of CURRENT_TIME + 2016 * 10 * 60 seconds\n\n3. After both conflicting spends are signed, Alice and Bob sign and\n   broadcast the deposit transaction from #1.\n\n4. If hashrate increases during the subsequent period, the spend that\n   pays Alice will mature first, so she broadcasts it and receives that\n   money.  If hashrate decreases, the spend to Bob matures first, so he\n   receives the money.\n\nOf course, this basic formula can be tweaked to create other contracts,\ne.g. a contract that only pays if hashrate goes down more than 25%.\n\nAs far as I can tell, this method should be compatible with offchain\ncommitments (e.g. payments within channels) and could be embedded in a\ntaproot commitment using OP_CLTV or OP_CSV instead of nLockTime.\n\n-Dave\n\n[1] https://powswap.com/\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200822/d044fb7d/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "reviving op_difficulty",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Hartman",
                "David A. Harding",
                "Anthony Towns",
                "ZmnSCPxj",
                "Tier Nolan"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 20133
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.20.1.knots20200815 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2020-08-18T04:03:54",
                "message_text_only": "Bitcoin Knots version 0.20.1.knots20200815 is now available from:\n\n  https://bitcoinknots.org/files/0.20.x/0.20.1.knots20200815/\n\nThis release includes new features, various bug fixes and performance\nimprovements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  https://github.com/bitcoinknots/bitcoin/issues\n\nTo receive security and update notifications, please subscribe to:\n\n  https://bitcoinknots.org/list/announcements/join/\n\nFor the full release notes and change log, see:\n\nhttps://github.com/bitcoinknots/bitcoin/blob/v0.20.1.knots20200815/doc/release-notes.md\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200818/13a10f73/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.20.1.knots20200815 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 911
        }
    },
    {
        "title": "[bitcoin-dev] Time to lower minrelaytxfee ?",
        "thread_messages": [
            {
                "author": "Dan Bryant",
                "date": "2020-08-21T05:55:59",
                "message_text_only": "It's been 5 years since minrealytxfee was lowered.  At the time\nbitcoin was trading for $255 and it was agreed that the fee of 5000\nsat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to\nhow much anti-DoS protection that provided, it comes out to $0.00255 /\nvkB in USD terms.  To have parity with the last reduction, we would\nneed to reduce minrealytxfee to 22 sat/vKB, though an even more\nconservative reduction to 100 or 50 sat/vKB would be welcome.\n\nWith the growing adoption of LN, there is a need for ultra-low-fee\non-chain TXNs.  Having these queue and confirm overnight, or even\nwaiting until the Sunday lull would still probably be welcome to many\nusers.  The fact that the mempool is going empty at least every week\nindicates that miners have not reached the floor of what they are\nwilling to mine.\n\nAbout 2 years ago there was a PR (#13922) to try to make a reduction\nfrom 1000 to 200 sat/vkB.  It was widely accepted but the submitter\neventually closed it in favor of PR #13990.\n\nIf minrelaytxfee is already parameterized and configurable in\nbitcoin.conf, how could it be detrimental to operation of a node to\nchange the default?\n\nReferences:\n\n* https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4\n* https://github.com/bitcoin/bitcoin/pull/13922\n* https://github.com/bitcoin/bitcoin/pull/13990"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2020-08-21T16:36:30",
                "message_text_only": "Having large portions of the network using a different minrelayfee could\nmake it easier to reliably get different parts of the network to accept\ndifferent conflicting transactions into their mempools, which could\npotentially be used to double-spend unconfirmed non-rbf transactions with\nmore ease. Node operators that accept unconfirmed payments with a\nminrelayfee that's higher than what other nodes/miners are typically\naccepting would be at risk.\n\nRelying on unconfirmed transactions is of course discouraged so I'm not\nsure how much weight this should be given if at all, but I thought it was\nat least worth bringing up.\n\nNadav\n\n\nOn Fri, Aug 21, 2020 at 11:00 AM Dan Bryant via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It's been 5 years since minrealytxfee was lowered.  At the time\n> bitcoin was trading for $255 and it was agreed that the fee of 5000\n> sat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to\n> how much anti-DoS protection that provided, it comes out to $0.00255 /\n> vkB in USD terms.  To have parity with the last reduction, we would\n> need to reduce minrealytxfee to 22 sat/vKB, though an even more\n> conservative reduction to 100 or 50 sat/vKB would be welcome.\n>\n> With the growing adoption of LN, there is a need for ultra-low-fee\n> on-chain TXNs.  Having these queue and confirm overnight, or even\n> waiting until the Sunday lull would still probably be welcome to many\n> users.  The fact that the mempool is going empty at least every week\n> indicates that miners have not reached the floor of what they are\n> willing to mine.\n>\n> About 2 years ago there was a PR (#13922) to try to make a reduction\n> from 1000 to 200 sat/vkB.  It was widely accepted but the submitter\n> eventually closed it in favor of PR #13990.\n>\n> If minrelaytxfee is already parameterized and configurable in\n> bitcoin.conf, how could it be detrimental to operation of a node to\n> change the default?\n>\n> References:\n>\n> *\n> https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4\n> * https://github.com/bitcoin/bitcoin/pull/13922\n> * https://github.com/bitcoin/bitcoin/pull/13990\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/fb241441/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2020-08-21T16:57:32",
                "message_text_only": "No strong opinions but:\n\nDenial of service attacks can become 5x cheaper.\n\nIf you don't thoroughly test\nhttps://github.com/bitcoin/bitcoin/issues/16499 these\nchanges you can end up with bugs that can cause issues on p2p network.\n\nOn Fri, Aug 21, 2020 at 4:00 AM Dan Bryant via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It's been 5 years since minrealytxfee was lowered.  At the time\n> bitcoin was trading for $255 and it was agreed that the fee of 5000\n> sat/vkB was too high.  It was lowered to 1000 sat/vkB.  In regards to\n> how much anti-DoS protection that provided, it comes out to $0.00255 /\n> vkB in USD terms.  To have parity with the last reduction, we would\n> need to reduce minrealytxfee to 22 sat/vKB, though an even more\n> conservative reduction to 100 or 50 sat/vKB would be welcome.\n>\n> With the growing adoption of LN, there is a need for ultra-low-fee\n> on-chain TXNs.  Having these queue and confirm overnight, or even\n> waiting until the Sunday lull would still probably be welcome to many\n> users.  The fact that the mempool is going empty at least every week\n> indicates that miners have not reached the floor of what they are\n> willing to mine.\n>\n> About 2 years ago there was a PR (#13922) to try to make a reduction\n> from 1000 to 200 sat/vkB.  It was widely accepted but the submitter\n> eventually closed it in favor of PR #13990.\n>\n> If minrelaytxfee is already parameterized and configurable in\n> bitcoin.conf, how could it be detrimental to operation of a node to\n> change the default?\n>\n> References:\n>\n> *\n> https://github.com/bitcoin/bitcoin/commit/9e93640be6c49fa1505ba5c5df8c89210da5a6e4\n> * https://github.com/bitcoin/bitcoin/pull/13922\n> * https://github.com/bitcoin/bitcoin/pull/13990\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200821/53f9cfde/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Time to lower minrelaytxfee ?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dan Bryant",
                "Greg Sanders",
                "Nadav Ivgi"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5983
        }
    },
    {
        "title": "[bitcoin-dev] PSBT Security Standard",
        "thread_messages": [
            {
                "author": "Robert Spigler",
                "date": "2020-08-23T22:07:38",
                "message_text_only": "Hello All,\n\nIn the past, discussions around how to securely store/use/setup PSBT's have been decided as out of scope for BIP 174 - \"it is not a specification of how hardware wallets should behave, it is a description of a data structure and the abstract workflow around it\"\n\nFor example, Nicolas Dorier had many concerns around a year ago during the global xpub field discussions, and Electrum Wallet devs and Sjors Provoost have had various discussions on how to coordinate multisig wallets and represent cosigners securely (1. what do cosigners need: xfp, derivation prefix, xpub, script type; 2. needs to be forward thinking: work with Musig, Lightning, Taproot, Native Descriptor Wallets, etc; 3. how do we authenticate across devices, ensure PSBT's haven't been changed en route, defend against change attacks, etc - Bob McElrath had some interesting ideas on these).\n\nJonathan Underwood's PSBT_GLOBAL_XPUB_SIGNATURE addition to BIP174 helps with some of these, but it is not a finalized BIP yet, and while the global xpub field is, it is not pulled into Core yet.\n\nWhat do people think of the idea of expanding or creating a new, more descriptive BIP on how to securely use PSBT's?\n\nIMO, especially since Core has been merging more PR's on the work around offline/multisig use, this has become more important.\n\nLast time I discussed this, Glenn Willen and Luke Dashjr thought this was a good idea, with Luke offering a Bitcoin Wiki page for the short term, but that was a few months ago and I thought I would open this idea to the general community.\n\n-Robert Spigler\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200823/41254548/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PSBT Security Standard",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Robert Spigler"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1755
        }
    },
    {
        "title": "[bitcoin-dev] New tipe of outputs that saves space and give more privacy",
        "thread_messages": [
            {
                "author": "Jule.Adka",
                "date": "2020-08-25T13:42:05",
                "message_text_only": "Hey, there! I have a new proposal to help Bitcoin\u2019s scalability, while helping privacy.\n\nMotivation\n\nAll transactions in the Bitcoin\u2019s network have a header, an input list and an output list. Every transaction must consume some previous outputs and create new ones, this creates huge amounts of data through the years, and creates scalability problems. With segwit we solved some problems by moving part of the data to a separate structure that stores data useful to verify the transaction itself, but not its state and the state of the whole blockchain[1]. But we still have a problem with the outputs list, some transactions create various outputs, generating munch data and increasing the size of the unspent transactions outputs(UTXOs) that are held for every full node into the network.\n\nAnother problem with this approach is the fact that all outputs are recorded, disclosed and accessible to everyone that looks at the transaction. This creates various privacy problems that are exploited for the chain analize companies and governments to track individuals and link it to their own personality.\n\nDescription\n\nI propose a new type of output, called Mekelized Output Set and the p2mos(pay to Mekelized Output Set) standard. Instead of listing all the output set, as in an ordinary transaction, Alice only specifies a Markle root, and only when she tries to spend the coin, she may to show a path into the Merkle from her transaction to the recorded root (a.k.a Merkle Path), and proof that her output really exists.\n\nThe extra data (the path) are stored into the witness structure, and can be striped after verification. Once the size of the witness structure is ignored/discounted when calculating the block size, it gives more space for transactions in a unique block, without increasing it\u2019s actual size. As well, decrease the UTXO\u2019s size, taking less resource from validators node.\n\nAn ordinary(the current standard) p2wpkh transaction with one output have 8 bytes to amount, 1-9 varInt for the locking-script size and 22 bytes (OP_0 OP_PUSHBYTES_20 <20-bytes-hash>), at most 39 bytes for each output[2]. If we use sha256 to encode the merkle, we need only 32 of script data, 49 in the total. 10 bytes more than an ordinary transaction with one output. But usually the transactions have 2 outputs (the actual payment and a change) or more. If the transaction have 2 outputs, we only record one commitment and the two outputs keep hidden until it has been spent (also the UTXO set is have one transaction instead of 2), the 2 outputs would require 78 bytes to record, we can do it with the same 49 bytes. For a 12 outputs[3] transaction, it would require 468 bytes, and so on\u2026\n\nBy using p2mos saves space by reducing any transaction to a 49 bytes-wide output set, no matter how many outputs actually exist. Also, once only the peers are able to know the number and the value of the outputs, a third party has no way to know the ownership of the remaining coins, many of the privacy troubles associated with outputs, like Equal-output CoinJoin and different outputs types[4] are solved.\n\nAn example\n\nWhen Alice\u2019s wallet create a transaction, sending 5 bitcoins to Bob and spending from a 10 bitcoins output (forget the fees, for a while), Alice must send 5 bitcoins to Bob and 5 back to she as change, when Bob\u2019s wallet create the invoice to be paid by Alice, he gives an output to Alice and she adds it together into a Merkle Tree, takes the root and build a transaction paying to this hash. Alice\u2019s wallet then sends a path into the tree to prove to Bob that his output is really into a transaction and is fully expendable from Bob\u2019s wallet. Bob now looks for the mempool (and the chain, of course) to find transactions that pay to the given Markle Root.\n\nNow let\u2019s see how Bob spends from this UTXO. His wallet knows the path that has taken from his transaction to the top, and the wallet reveals it to the network, before evaluating the output. Bob sends the actual output, the path to the root of the tree as well the data to solve the lockscript on it(note that \u201cactual output\u201d means the output that keeps hidden from the world until Bob spends it). After checking if Bob\u2019s output really exists, an node can evaluate it exactly in the same way as ordinary transactions, the output will look like any other.\n\nAlice\u2019s wallet does the same to spend her 5 BTC, but presenting a totally different output, that she spends from a script that only she has a way to do, if they use p2wpkh she must present the public key and a valid signature. After evaluation, the node can discard all this data and keeps only with the 1-input-1-output transaction.\n\nThis new transaction has the same fields of an ordinary one, amount, script size and script. Probably we will need an opcode to make reference to p2mos (pay toMerkelized output set), instructing the node to look at the witness data in order to find the actual output. So, we have 1 byte of opcode and32 bytes of the Merkle Root. The amount is preserved for compatibility as well for calculating mining fees, once the miner has no idea of the actual value locked into the output. The fee calculus doesn't change.\n\nThe amount also is helpful to determine whether the UTXO still have any locked coins, if the total \u201cremoved\u201d outputs value (i.e the outputs that has been revealed and spent) are equal to the locked value, the output is now totally spend and may be removed from the UTXO\u2019s set. If one tries to retrieve more than it\u2019s actually locked in, it fails.\n\nLet\u2019s say that Alice locks her 10 BTC, but creates two outputs: 6 BTC to she and 5 BTC to Bob, if she spends from this output, now Bob have no way to spend from this, because if he broadcast his 5 BTC he will exceed the total value, and the evaluation will fall. The 5 BTC will be locked up forever, and he can\u2019t create an alternative transaction, because it will never mech with the Merkle path and hence the root. To prevent this, some kind of verification of the values may be made by the wallets, all wallets must verify the values.\n\nTo one wallet verify all the outputs, without revealing the sigscript, we can hash the other 2 fields and exchange the hashes, the leafs of the tree are made by the hash(sigscript || scriptSize) || amount. Only the amounts are disclosed, keeping the privacy, after verifying the process of hashing can be done by all the parties, reaching the same root, at the end.\n\nPros\n\nUsing the p2mos, one keeps private the information about the outputs until it has been spent, as well saving space into the block and makes the transactions (without taking in account the witness data) smaller, decreasing the data used for SPV nodes. We still have an input and an output with explicit given values, that is useful for verifying the state of the chain.\n\nCons\n\nNeeds more coordination between the wallets (this is a problem, especially with scenarios that one part is offline), is a bit more hard to compute for a validator, and would require some extra bandwidth for downloading the witness data.\n\nRetro Compatibility\n\nOn one hand, old nodes that don\u2019t follow the new consensus rule can accept this kind of transaction if it\u2019s made as a anyone can spend in the current consensus, but with other meanings in the new one(as segwit), but on the other hand, at a second spend, the node will interpret it as double spend, hence invalidating it. So the main problem with this approach is to implement it as a soft-fork.\n\nI would like to receive any thoughts and considerations about this proposal. At the most, thank you very much. Sincerely, Jule Adka (Jule.Adka at protonmail.com)\n\n[1][BIP141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), Segregated Witness\n\n[2] ANTONOPOLOS, Andres. Mastering Bitcoin\n\n[3] A 12-output transaction in[blockstream.info](https://blockstream.info/tx/1bdde4ec3486ac67018727cfb4aa7fd84011db29bc0fdb525a810ad2ab1eb24d).\n\n[4] Privacy on[Bitcoin wiki](https://en.bitcoin.it/wiki/Privacy)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200825/aa27a927/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2020-08-25T15:24:46",
                "message_text_only": "You may wish to review bip-119 ChecktemplateVerify, as it is designed to\nsupport something very similar to what you've described. You can see more\nat https://utxos.org\n\nOn Tue, Aug 25, 2020, 6:48 AM Jule.Adka via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hey, there! I have a new proposal to help Bitcoin\u2019s scalability, while\n> helping privacy.\n>\n> *Motivation*\n>\n> All transactions in the Bitcoin\u2019s network have a header, an input list and\n> an output list. Every transaction must consume some previous outputs and\n> create new ones, this creates huge amounts of data through the years, and\n> creates scalability problems. With segwit we solved some problems by moving\n> part of the data to a separate structure that stores data useful to verify\n> the transaction itself, but not its state and the state of the whole\n> blockchain[1]. But we still have a problem with the outputs list, some\n> transactions create various outputs, generating munch data and increasing\n> the size of the unspent transactions outputs(UTXOs) that are held for every\n> full node into the network.\n>\n> Another problem with this approach is the fact that all outputs are\n> recorded, disclosed and accessible to everyone that looks at the\n> transaction. This creates various privacy problems that are exploited for\n> the chain analize companies and governments to track individuals and link\n> it to their own personality.\n>\n> *Description*\n>\n> I propose a new type of output, called Mekelized Output Set and the\n> p2mos(pay to Mekelized Output Set) standard. Instead of listing all the\n> output set, as in an ordinary transaction, Alice only specifies a Markle\n> root, and only when she tries to spend the coin, she may to show a path\n> into the Merkle from her transaction to the recorded root (a.k.a Merkle\n> Path), and proof that her output really exists.\n>\n> The extra data (the path) are stored into the witness structure, and can\n> be striped after verification. Once the size of the witness structure is\n> ignored/discounted when calculating the block size, it gives more space for\n> transactions in a unique block, without increasing it\u2019s actual size. As\n> well, decrease the UTXO\u2019s size, taking less resource from validators node.\n>\n>  An ordinary(the current standard) p2wpkh transaction with one output have\n> 8 bytes to amount, 1-9 varInt for the locking-script size and 22 bytes\n> (OP_0 OP_PUSHBYTES_20 <20-bytes-hash>), at most 39 bytes for each\n> output[2]. If we use sha256 to encode the merkle, we need only 32 of script\n> data, 49 in the total. 10 bytes more than an ordinary transaction with one\n> output. But usually the transactions have 2 outputs (the actual payment and\n> a change) or more. If the transaction have 2 outputs, we only record one\n> commitment and the two outputs keep hidden until it has been spent (also\n> the UTXO set is have one transaction instead of 2), the 2 outputs would\n> require 78 bytes to record, we can do it with the same 49 bytes. For a 12\n> outputs[3] transaction, it would require 468 bytes, and so on\u2026\n>\n> By using p2mos saves space by reducing any transaction to a 49 bytes-wide\n> output set, no matter how many outputs actually exist. Also, once only the\n> peers are able to know the number and the value of the outputs, a third\n> party has no way to know the ownership of the remaining coins, many of the\n> privacy troubles associated with outputs, like Equal-output CoinJoin and\n> different outputs types[4] are solved.\n>\n> *An example*\n>\n> When Alice\u2019s wallet create a transaction, sending 5 bitcoins to Bob and\n> spending from a 10 bitcoins output (forget the fees, for a while), Alice\n> must send 5 bitcoins to Bob and 5 back to she as change, when Bob\u2019s wallet\n> create the invoice to be paid by Alice, he gives an output to Alice and she\n> adds it together into a Merkle Tree, takes the root and build a transaction\n> paying to this hash. Alice\u2019s wallet then sends a path into the tree to\n> prove to Bob that his output is really into a transaction and is fully\n> expendable from Bob\u2019s wallet. Bob now looks for the mempool (and the\n> chain, of course) to find transactions that pay to the given Markle Root.\n>\n> Now let\u2019s see how Bob spends from this UTXO. His wallet knows the path\n> that has taken from his transaction to the top, and the wallet reveals it\n> to the network, before evaluating the output. Bob sends the actual output,\n> the path to the root of the tree as well the data to solve the lockscript\n> on it(note that \u201cactual output\u201d means the output that keeps hidden from the\n> world until Bob spends it). After checking if Bob\u2019s output really exists,\n> an node can evaluate it exactly in the same way as ordinary transactions,\n> the output will look like any other.\n>\n> Alice\u2019s wallet does the same to spend her 5 BTC, but presenting a totally\n> different output, that she spends from a script that only she has a way to\n> do, if they use p2wpkh she must present the public key and a valid\n> signature. After evaluation, the node can discard all this data and keeps\n> only with the 1-input-1-output transaction.\n>\n> This new transaction has the same fields of an ordinary one, amount,\n> script size and script. Probably we will need an opcode to make reference\n> to p2mos (pay to Merkelized output set), instructing the node to look at\n> the witness data in order to find the actual output. So, we have 1 byte of\n> opcode and 32 bytes of the Merkle Root. The amount is preserved for\n> compatibility as well for calculating mining fees, once the miner has no\n> idea of the actual value locked into the output. The fee calculus doesn't\n> change.\n>\n> The amount also is helpful to determine whether the UTXO still have any\n> locked coins, if the total \u201cremoved\u201d outputs value (i.e the outputs that\n> has been revealed and spent) are equal to the locked value, the output is\n> now totally spend and may be removed from the UTXO\u2019s set. If one tries to\n> retrieve more than it\u2019s actually locked in, it fails.\n>\n> Let\u2019s say that Alice locks her 10 BTC, but creates two outputs: 6 BTC to\n> she and 5 BTC to Bob, if she spends from this output, now Bob have no way\n> to spend from this, because if he broadcast his 5 BTC he will  exceed the\n> total value, and the evaluation will fall. The 5 BTC will be locked up\n> forever, and he can\u2019t create an alternative transaction, because it will\n> never mech with the Merkle path and hence the root. To prevent this, some\n> kind of verification of the values may be made by the wallets, all wallets\n> must verify the values.\n>\n> To one wallet verify all the outputs, without revealing the sigscript, we\n> can hash the other 2 fields and exchange the hashes, the leafs of the tree\n> are made by the hash(sigscript || scriptSize) || amount. Only the amounts\n> are disclosed, keeping the privacy, after verifying the process of hashing\n> can be done by all the parties, reaching the same root, at the end.\n>\n> *Pros*\n>\n> Using the p2mos, one keeps private the information about the outputs until\n> it has been spent, as well saving space into the block and makes the\n> transactions (without taking in account the witness data) smaller,\n> decreasing the data used for SPV nodes. We still have an input and an\n> output with explicit given values, that is useful for verifying the state\n> of the chain.\n>\n> *                                                          Cons*\n>\n> Needs more coordination between the wallets (this is a problem, especially\n> with scenarios that one part is offline), is a bit more hard to compute for\n> a validator, and would require some extra bandwidth for downloading the\n> witness data.\n>\n> *Retro Compatibility*\n>\n> On one hand, old nodes that don\u2019t follow the new consensus rule can accept\n> this kind of transaction if it\u2019s made as a anyone can spend in the current\n> consensus, but with other meanings in the new one(as segwit), but on the\n> other hand, at a second spend, the node will interpret it as double spend,\n> hence invalidating it. So the main problem with this approach is to\n> implement it as a soft-fork.\n>\n> I would like to receive any thoughts and considerations about this\n> proposal. At the most, thank you very much. Sincerely, Jule Adka (\n> Jule.Adka at protonmail.com)\n>\n> [1] *BIP141*\n> <https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki>,\n> Segregated Witness\n>\n> [2] ANTONOPOLOS, Andres. Mastering Bitcoin\n>             [3] A 12-output transaction in *blockstream.info*\n> <https://blockstream.info/tx/1bdde4ec3486ac67018727cfb4aa7fd84011db29bc0fdb525a810ad2ab1eb24d>\n> .\n>\n> [4] Privacy on *Bitcoin wiki* <https://en.bitcoin.it/wiki/Privacy>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200825/24854a15/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "New tipe of outputs that saves space and give more privacy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jule.Adka",
                "Jeremy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 17159
        }
    },
    {
        "title": "[bitcoin-dev] Default Signet, Custom Signets and Resetting Testnet",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2020-08-29T10:14:50",
                "message_text_only": "Hi all\n\nSignet has been announced and discussed previously on the mailing list so I\nwon't repeat what Signet is and its motivation.\n\n(For more background we recently had a Socratic Seminar with Kalle Alm and\nAJ Towns on Signet. Transcript, reading list and video are available.)\n\nhttps://diyhpl.us/wiki/transcripts/london-bitcoin-devs/2020-08-19-socratic-seminar-signet/\n\nThe first (of multiple) Signet PR 18267 in Bitcoin Core is at an advanced\nstage of review and certainly additional code review and testing of that PR\nis encouraged.\n\nhttps://github.com/bitcoin/bitcoin/pull/18267\n\nHowever there are some meta questions around Signet(s) that are best\ndiscussed outside of the Bitcoin Core repo and it would be good to ensure\neveryone's testing needs are being met. I will put forward my initial\nthoughts on some of these questions. These thoughts seem to be aligned with\nKalle's and AJ's initial views but they have not reviewed this post and\nthey can chime in if they feel I am misrepresenting their perspectives.\n\n1) Should there be one \"default\" Signet that we use for specific purpose(s)\nor should we \"let a thousand ships sail\"?\n\nTo be clear there will be multiple custom Signets. Even if we wanted to\nprevent them we couldn't. But is there an argument for having a \"default\"\nSignet with a network effect? A Signet that a large proportion of the\ncommunity is drawn to using with tooling and support? I would say yes.\nEspecially if we see Signet as a staging ground for testing proposed soft\nfork(s). Otherwise there will be lots of splintered Signet networks all\nwith different combinations of proposed soft forks enabled and no network\neffect around a particular Signet. I think this would be bewildering for\nsay Taproot testers to have to choose between Person A's Signet with\nTaproot enabled and Person B's Signet with Taproot enabled. For this to\nwork there would have to be a formal understanding of at what stage a\nproposed soft fork should be enabled on \"default\" Signet. It would have to\nbe at a sufficiently mature stage (e.g. BIP number allocated, BIP drafted\nand under review, PR open in Bitcoin Core repo under review etc) but early\nenough so that it can be tested on Signet well in advance of being\nconsidered for activation on mainnet. This does present challenges if soft\nforks are enabled on Signet and then change/get updated. However there are\napproaches that AJ in particular is working on to deal with this, one of\nwhich I have described below.\n\nhttps://bitcoin.stackexchange.com/questions/98642/can-we-experiment-on-signet-with-multiple-proposed-soft-forks-whilst-maintaining\n\n2) Assuming there is a \"default\" Signet how many people and who should have\nkeys to sign each new \"default\" Signet block? If one of these keys is lost\nor stolen should we reset Signet? Should we plan to reset \"default\" Signet\nat regular intervals anyway (say every two years)?\n\nCurrently it is a 1-of-2 multisig with Kalle Alm and AJ Towns having keys.\nIt was suggested on IRC that there should be at least one additional key\npresent in the EU/US timezone so blocks can continue to be mined during an\nAsia-Pacific outage. (Kalle and AJ are both in the Asia-Pacific region).\nKalle believes we should keep Signet running indefinitely unless we\nencounter specific problems and personally I think this makes sense.\n\nhttps://github.com/bitcoin/bitcoin/issues/19787#issuecomment-679160691\n\n3) Kalle has also experienced concern from some in the community that\ntestnet will somehow be replaced by Signet. This is not the case. As long\nas someone out there is mining testnet blocks testnet will continue.\nHowever, there is the question of whether testnet needs to be reset. It was\nlast reset in 2012 and there are differing accounts on whether this is\npresenting a problem for users of testnet. Assuming Signet is successful\nthere will be less testing on testnet but what testing use cases will still\nprefer testnet? It has been argued that testnet should be a large chain to\nstress test certain IBD, P2P scenarios in which case it may be the case\nthat we don't want to reset testnet. All other testing use cases would not\nbe impacted by the downsides of a large chain as they would gravitate\ntowards Signet regardless.\n\nhttps://bitcoin.stackexchange.com/questions/98579/will-there-be-a-testnet4-or-do-we-not-need-a-testnet-reset-once-we-have-signet/\n\nIf you have thoughts, feedback, questions it would be great to hear them.\nCertainly we should seek to make sure everybody's testing needs are being\nconsidered.\n\nThere is a closed issue on the Bitcoin Core repo if you seek to review some\nof the prior conversation. Ideally though we would have discussion that\nisn't directly impacting Bitcoin Core here on the mailing list or on IRC\nrather than in the Bitcoin Core repo.\n\nhttps://github.com/bitcoin/bitcoin/issues/19787\n\nThanks\nMichael\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200829/852eb2b5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Default Signet, Custom Signets and Resetting Testnet",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Michael Folkson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5152
        }
    }
]