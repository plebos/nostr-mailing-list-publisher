[
    {
        "title": "[bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol",
        "thread_messages": [
            {
                "author": "Kenshiro []",
                "date": "2019-08-01T10:17:56",
                "message_text_only": "mm you are right, then the \"moving checkpoint\" rule needs to have some limits to allow the network self-heal instead of requiring humans detecting the splits or stopping nodes.\n\nLet's suppose than a 51% attack can be detected and the developers can release a new version of the software with a new mining protocol in about 3 days. Then the complementary rule could be something like this:\n\n- If 2 forks have a block height difference of 432 blocks (about 3 days) or more, then the moving checkpoint rule is ignored and everything works as with the current protocol. With this rule, the network can self-heal in a 100% automated way.\n\nThis would prevent a history rewrite of more than 24 hours during a 51% attack during 3 days, which should give enough time to change the protocol. If instead of a 51% attack what happens is a network split, then nodes should converge to the longest chain in a few days.\n\nBut maybe I'm missing something here, I'm still learning.\n\nRegards,\n\n\n\n________________________________\nFrom: Alistair Mann <al at pectw.net>\nSent: Thursday, August 1, 2019 1:28\nTo: Kenshiro [] <tensiam at hotmail.com>\nCc: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nOn Wednesday 31 Jul 2019 14:53:25 Kenshiro [] wrote:\n>> How would a (potentially, state-sponsored) netsplit lasting longer than\n>> N be handled?\n>\n> It would be detected by the community much before reaching the reorg limit\n> of N blocks (it's 24 hours) so nodes could stop until the netsplit is\n> fixed.\n\nA netsplit cannot be detected but merely be suspected where the p2p protocol\ndoes allow arbitrary connecting/disconnecting of any peer: there's no\ndifference between a remote net being split off, that net having nothing to\nsay, and that net choosing to disconnect. Detection then mandates manual, out-\nof-band communications, which is error prone and centralising.\n\nI also observe 'stopping nodes' during netsplits introduces several attack\nvectors. Among them: create a netsplit, which stops the nodes, turn off the\nnetsplit, repeat. A sequence of 365 actors causing their own small netsplits\ncould effectively stop Bitcoin at the cost (to them) of no Internet for one\nday a year as the rolling netsplit could never be fixed.\n\n> In the extreme case no one notice the network split during more than N\n> blocks (24 hours) and there are 2 permanent forks longer than N, nodes from\n> one branch could delete their local history so they would join the other\n> branch.\n>\n> P.S.: To be clearer, in this example I set an N value of 144 blocks, which\n> is approximately 24 hours.\n\nI've seen estimates of China hosting more than 51% of hashpower. Say they\nconduct a netsplit. Does your suggestion mean that it's the rest of the world\nthat has to delete their local history because they lack the hashpower to\nassert themselves as the proper branch? If so, I think having to delete actual\nhistory everywhere across the globe but China is not a price worth paying to\nlimit reorgs to 24 hours.\n\nI am unconvinced that the moving checkpoint you describe would improve\nBitcoin.\n--\nAlistair Mann\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/c201578b/attachment.html>"
            },
            {
                "author": "Ethan Heilman",
                "date": "2019-08-02T12:19:03",
                "message_text_only": "Attack 1:\nI partition (i.e. eclipse) a bunch of nodes from the network this partition\ncontains no mining power . I then mine 145 blocks for this partition. I\ndon't even need 51% of the mining power because I'm not competing with any\nother miners. Under this rule this partition will hardfork from the network\npermanently. Under current rules this partition will be able to rejoin the\nnetwork as the least weight chain will be orphaned.\n\nAttack 2:\nI pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I\nfeed it 145 blocks which fork off from the consensus chain. I have 24+24\nhours to mine these 145 blocks so I should be able to do this with 25% of\nthe current hash rate at the time the node went offline. Under your rule\neach of these offline-->online nodes I attack this way will hardfork\nthemselves from the rest of the network.\n\nI believe a moving-checkpoint rule as describe above would make Bitcoin\nmore vulnerable to 51% attacks.\n\nA safer rule would be if a node detects a fork with both sides of the split\nhaving  length > 144 blocks, it halts and requests user intervention to\ndetermine which chain to follow.  I don't think 144 blocks is a great\nnumber to use here as 24 hours is very short. I suspect you could improve\nthe security of the rule by making the number of blocks a fork most reach\nto halt the network proportional to the difference in time between the\ntimestamp in the block prior to the fork and the current time. I am **NOT**\nproposing Bitcoin adopt such a rule.\n\nNXT has a fundamentally different security model as it uses Proof-of-stake\nrather than Proof-of-Work.\n\nOn Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> P.S.: To be clearer, in this example I set an N value of 144 blocks, which\n> is approximately 24 hours.\n>\n> ------------------------------\n> *From:* Kenshiro [] <tensiam at hotmail.com>\n> *Sent:* Wednesday, July 31, 2019 16:40\n> *To:* Alistair Mann <al at pectw.net>; Bitcoin Protocol Discussion <\n> bitcoin-dev at lists.linuxfoundation.org>\n> *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin\n> protocol\n>\n> >>> How would a (potentially, state-sponsored) netsplit lasting longer\n> than N be\n> handled?\n>\n> It would be detected by the community much before reaching the reorg limit\n> of N blocks (it's 24 hours) so nodes could stop until the netsplit is\n> fixed.\n>\n> In the extreme case no one notice the network split during more than N\n> blocks (24 hours) and there are 2 permanent forks longer than N, nodes\n> from one branch could delete their local history so they would join the\n> other branch.\n>\n> Regards,\n>\n>\n> ------------------------------\n> *From:* Alistair Mann <al at pectw.net>\n> *Sent:* Wednesday, July 31, 2019 15:59\n> *To:* Kenshiro [] <tensiam at hotmail.com>; Bitcoin Protocol Discussion <\n> bitcoin-dev at lists.linuxfoundation.org>\n> *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin\n> protocol\n>\n> On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:\n>\n> > I would like to propose that a \"moving checkpoint\" is added to the\n> Bitcoin\n> > protocol. It's a very simple rule already implemented in NXT coin:\n> >\n> > - A node will ignore any new block under nodeBlockHeight - N, so the\n> > blockchain becomes truly immutable after N blocks, even during a 51%\n> attack\n> > which thanks to the moving checkpoint can't rewrite history older than\n> the\n> > last N blocks.\n>\n> How would a (potentially, state-sponsored) netsplit lasting longer than N\n> be\n> handled?\n> --\n> Alistair Mann\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/9071fcc3/attachment-0001.html>"
            },
            {
                "author": "Kenshiro []",
                "date": "2019-08-02T13:08:44",
                "message_text_only": "Hi all,\n\nVery good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:\n\nWith the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:\n\nIf a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.\n\nSo as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.\n\nSo we have 2 possible situations to consider:\n\n- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.\n\n- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.\n\nIt could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.\n\nRegards,\n\n\n\n________________________________\nFrom: Ethan Heilman <eth3rs at gmail.com>\nSent: Friday, August 2, 2019 14:19\nTo: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nCc: Alistair Mann <al at pectw.net>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nAttack 1:\nI partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.\n\nAttack 2:\nI pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.\n\nI believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.\n\nA safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.\n\nNXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.\n\nOn Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nP.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.\n\n________________________________\nFrom: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>\nSent: Wednesday, July 31, 2019 16:40\nTo: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\n>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n\nIt would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.\n\nIn the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.\n\nRegards,\n\n\n________________________________\nFrom: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>\nSent: Wednesday, July 31, 2019 15:59\nTo: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nOn Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:\n\n> I would like to propose that a \"moving checkpoint\" is added to the Bitcoin\n> protocol. It's a very simple rule already implemented in NXT coin:\n>\n> - A node will ignore any new block under nodeBlockHeight - N, so the\n> blockchain becomes truly immutable after N blocks, even during a 51% attack\n> which thanks to the moving checkpoint can't rewrite history older than the\n> last N blocks.\n\nHow would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n--\nAlistair Mann\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/98a6f15e/attachment.html>"
            },
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2019-08-03T00:51:12",
                "message_text_only": "I have but one point to make in a brief catch-up read over.\n\nWith the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:\n\nIt is not to be considered the longest chain, it is to be considered the longest chain with the most proof of work.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n<https://earn.com/willtech>\n\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Friday, 2 August 2019 11:08 PM\nTo: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nHi all,\n\nVery good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:\n\nWith the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:\n\nIf a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.\n\nSo as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.\n\nSo we have 2 possible situations to consider:\n\n- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.\n\n- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.\n\nIt could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.\n\nRegards,\n\n\n\n________________________________\nFrom: Ethan Heilman <eth3rs at gmail.com>\nSent: Friday, August 2, 2019 14:19\nTo: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nCc: Alistair Mann <al at pectw.net>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nAttack 1:\nI partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.\n\nAttack 2:\nI pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.\n\nI believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.\n\nA safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.\n\nNXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.\n\nOn Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nP.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.\n\n________________________________\nFrom: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>\nSent: Wednesday, July 31, 2019 16:40\nTo: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\n>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n\nIt would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.\n\nIn the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.\n\nRegards,\n\n\n________________________________\nFrom: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>\nSent: Wednesday, July 31, 2019 15:59\nTo: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nOn Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:\n\n> I would like to propose that a \"moving checkpoint\" is added to the Bitcoin\n> protocol. It's a very simple rule already implemented in NXT coin:\n>\n> - A node will ignore any new block under nodeBlockHeight - N, so the\n> blockchain becomes truly immutable after N blocks, even during a 51% attack\n> which thanks to the moving checkpoint can't rewrite history older than the\n> last N blocks.\n\nHow would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n--\nAlistair Mann\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190803/8720e865/attachment.html>"
            },
            {
                "author": "Kenshiro []",
                "date": "2019-08-03T10:35:51",
                "message_text_only": "Good point, for the moving checkpoint a number of blocks (or maybe a timestamp) could be enough, but for the block limit of X blocks to decide if the moving checkpoint is ignored or not, as we have to compare two chains (main chain and fork) maybe is much better to measure the blockchain lengths as numberOfBlocks * averageBlockDifficulty, so if a difficulty adjustment happens in that time interval, it's taken into account.\n\nRegards\n\n________________________________\nFrom: LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>\nSent: Saturday, August 3, 2019 2:51\nTo: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>; Kenshiro [] <tensiam at hotmail.com>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nI have but one point to make in a brief catch-up read over.\n\nWith the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:\n\nIt is not to be considered the longest chain, it is to be considered the longest chain with the most proof of work.\n\nRegards,\nLORD HIS EXCELLENCY JAMES HRMH\n<https://earn.com/willtech>\n\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Friday, 2 August 2019 11:08 PM\nTo: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nHi all,\n\nVery good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:\n\nWith the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:\n\nIf a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.\n\nSo as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.\n\nSo we have 2 possible situations to consider:\n\n- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.\n\n- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.\n\nIt could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.\n\nRegards,\n\n\n\n________________________________\nFrom: Ethan Heilman <eth3rs at gmail.com>\nSent: Friday, August 2, 2019 14:19\nTo: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nCc: Alistair Mann <al at pectw.net>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nAttack 1:\nI partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.\n\nAttack 2:\nI pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.\n\nI believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.\n\nA safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.\n\nNXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.\n\nOn Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\nP.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.\n\n________________________________\nFrom: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>\nSent: Wednesday, July 31, 2019 16:40\nTo: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\n>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n\nIt would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.\n\nIn the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.\n\nRegards,\n\n\n________________________________\nFrom: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>\nSent: Wednesday, July 31, 2019 15:59\nTo: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>\nSubject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol\n\nOn Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:\n\n> I would like to propose that a \"moving checkpoint\" is added to the Bitcoin\n> protocol. It's a very simple rule already implemented in NXT coin:\n>\n> - A node will ignore any new block under nodeBlockHeight - N, so the\n> blockchain becomes truly immutable after N blocks, even during a 51% attack\n> which thanks to the moving checkpoint can't rewrite history older than the\n> last N blocks.\n\nHow would a (potentially, state-sponsored) netsplit lasting longer than N be\nhandled?\n--\nAlistair Mann\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190803/954f387d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Add a moving checkpoint to the Bitcoin protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Kenshiro []",
                "Ethan Heilman"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 28643
        }
    },
    {
        "title": "[bitcoin-dev] Proposed Extensions to BIP 174 for Future Extensibility",
        "thread_messages": [
            {
                "author": "Stepan Snigirev",
                "date": "2019-08-01T13:50:47",
                "message_text_only": "> why not use Bitcoin compact uint, which most PSBT consumers already\nimplement?\n\nI totally agree with that, compact int parsing is already implemented in\nall bitcoin applications, wallets and libraries. Also, for certain (mb\nproprietary) applications I will be willing to use multi-byte keys where\nthe first byte defines the application type and next bytes define\napplication-specific fields.\n\nI would suggest to set proprietary bytes to 0xF0-0xFC or to 0xE0-0xEF then\n(E for Enterprise?).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/ce1e063c/attachment.html>"
            },
            {
                "author": "Andrew Chow",
                "date": "2019-08-01T17:57:26",
                "message_text_only": "It seems like the consensus is that we should use Compact Size Unsigned\nIntegers for the field types, so we will do that. The types will be\nminimally encoded CSUints.\n\nFor the proprietary types, I will use Dimitry's and Andrew Poelstra's\n(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016713.html)\nsuggestion. There will be one proprietary type, 0xFC. This will be\nfollowed by a variable length string that is a vendor specific prefix\nthat serves as a unique identifier to help with preventing usage of\nproprietary types outside of private contexts. This will then be\nfollowed by the actual type for the data, as defined by the user of the\nproprietary type.\n\nThe prefix will just be a string, prefixed with a compact size unsigned\ninteger. If no prefix is wanted, then a single 0x00 byte can be used.\n\nFor public software, there is no need to handle these proprietary types\nat all so they do not need to check the string or the data type. It is\nnot necessary to enforce the above rules about proprietary types except\nthat they use the proprietary type value.\n\n\nAndrew Chow"
            },
            {
                "author": "Andrew Chow",
                "date": "2019-08-01T19:01:06",
                "message_text_only": "I spoke to some people OOB and they said that they didn't really like\nthe idea of having a prefix string (partially because they've already\nimplemented some proprietary types by simply squatting on unused types).\nMatching the prefix string adds additional complexity to the parser\ncode. The main concern is that people won't want to actually follow the\nspec for proprietary types and instead just use some unused type value.\nSo I think instead we should do:\n\n{0xFC}|{private_type}\n\nand the prefix string can be optional (and strongly recommended) after that.\n\nSince public parsers won't really be enforcing the rules for proprietary\ntypes, I don't think it really makes sense to specify and enforce how\nthey should be. After all, the key is really just an opaque data blob.\n\nIn the same vein, it would probably be useful to allow multiple types\nfor proprietary use as originally proposed to make implementation of\nthese easier. If more type are needed, then the private type\nconstruction can be used.\n\n\nAndrew\n\nOn 8/1/19 1:57 PM, Andrew Chow wrote:\n> \n> It seems like the consensus is that we should use Compact Size Unsigned\n> Integers for the field types, so we will do that. The types will be\n> minimally encoded CSUints.\n> \n> For the proprietary types, I will use Dimitry's and Andrew Poelstra's\n> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016713.html)\n> suggestion. There will be one proprietary type, 0xFC. This will be\n> followed by a variable length string that is a vendor specific prefix\n> that serves as a unique identifier to help with preventing usage of\n> proprietary types outside of private contexts. This will then be\n> followed by the actual type for the data, as defined by the user of the\n> proprietary type.\n> \n> The prefix will just be a string, prefixed with a compact size unsigned\n> integer. If no prefix is wanted, then a single 0x00 byte can be used.\n> \n> For public software, there is no need to handle these proprietary types\n> at all so they do not need to check the string or the data type. It is\n> not necessary to enforce the above rules about proprietary types except\n> that they use the proprietary type value.\n> \n> \n> Andrew Chow\n>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-02T09:18:36",
                "message_text_only": "\u0412 Thu, 01 Aug 2019 19:01:06 +0000\nAndrew Chow <achow101-lists at achow101.com> wrote:\n\n> I spoke to some people OOB and they said that they didn't really like\n> the idea of having a prefix string (partially because they've already\n> implemented some proprietary types by simply squatting on unused\n> types). Matching the prefix string adds additional complexity to the\n> parser code.\n\nI do not oppose the idea of \"{0xFC}|{private_type}\" strongly, but I\nwould like to note that for those who do not want to deal with\nadditional complexity of handling a prefixed string, they can simply\nnot use it at all. Since this is a private construction, and their\nprivate format specifies 'no prefix', they can just ignore everything\nthat does not start with \"{0xFC}|{0x00}\", thus any further complexity\nregarding the prefix is also ignored. The only added complexity is one\ncondition check: second_byte_of_the_key != 0 \n\nMy other argument for conflict-avoidance prefix as a first thing after\n0xFC is that the set of future users of PSBT and private types is\nmost likely much larger than the current set of those who already\nimplemented proprietary types on their own, and thus the overall benefit\nfor the whole industry will likely be bigger when 'i do not want\nconflict avoidance' decision have to be explicit, by setting the prefix\nto 0x00, and the set of possible conflicting types are limited only to\nthose entities that made this explicit decision.\n\nRegarding the 'squatted' types, it seems to me that this only matters\nin the discussed context if they squatted on 0xFC type in particular.\nIn other cases, they will need to implement changes anyway, to be\ncompatible with the BIP. Maybe they could consider that one additional\ncondition check is a small burden, and maybe they can tolerate that,\nfor the benefit of reducing possibility of interoperability problems\nbetween other future PSBT/private types implementors."
            },
            {
                "author": "Jonathan Underwood",
                "date": "2019-08-04T00:15:17",
                "message_text_only": "My two cents:\n\n1. Reserved types are awesome.\n2. Varint for type is awesome.\n3. BIP174 should specify a specific type for all (global, input, and\noutput) which means \"see the BIP numbered in the next byte\" so we can have\nsome sort of BIP43-ish system for BIP174... POR COMMITMENT and my current\nsignature protocol proposal should go in there.\n\nMore like three cents, but you get the idea.\n\nI'll keep an eye on the bips repo. If someone wants to ping me once things\nsettle down I'll implement it.\n\nThanks,\nJon\n\n2019\u5e748\u67082\u65e5(\u91d1) 20:34 Dmitry Petukhov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> \u0412 Thu, 01 Aug 2019 19:01:06 +0000\n> Andrew Chow <achow101-lists at achow101.com> wrote:\n>\n> > I spoke to some people OOB and they said that they didn't really like\n> > the idea of having a prefix string (partially because they've already\n> > implemented some proprietary types by simply squatting on unused\n> > types). Matching the prefix string adds additional complexity to the\n> > parser code.\n>\n> I do not oppose the idea of \"{0xFC}|{private_type}\" strongly, but I\n> would like to note that for those who do not want to deal with\n> additional complexity of handling a prefixed string, they can simply\n> not use it at all. Since this is a private construction, and their\n> private format specifies 'no prefix', they can just ignore everything\n> that does not start with \"{0xFC}|{0x00}\", thus any further complexity\n> regarding the prefix is also ignored. The only added complexity is one\n> condition check: second_byte_of_the_key != 0\n>\n> My other argument for conflict-avoidance prefix as a first thing after\n> 0xFC is that the set of future users of PSBT and private types is\n> most likely much larger than the current set of those who already\n> implemented proprietary types on their own, and thus the overall benefit\n> for the whole industry will likely be bigger when 'i do not want\n> conflict avoidance' decision have to be explicit, by setting the prefix\n> to 0x00, and the set of possible conflicting types are limited only to\n> those entities that made this explicit decision.\n>\n> Regarding the 'squatted' types, it seems to me that this only matters\n> in the discussed context if they squatted on 0xFC type in particular.\n> In other cases, they will need to implement changes anyway, to be\n> compatible with the BIP. Maybe they could consider that one additional\n> condition check is a small burden, and maybe they can tolerate that,\n> for the benefit of reducing possibility of interoperability problems\n> between other future PSBT/private types implementors.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190804/52748714/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposed Extensions to BIP 174 for Future Extensibility",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Stepan Snigirev",
                "Jonathan Underwood",
                "Andrew Chow",
                "Dmitry Petukhov"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 8990
        }
    },
    {
        "title": "[bitcoin-dev] [Meta] bitcoin-dev moderation",
        "thread_messages": [
            {
                "author": "Emil Engler",
                "date": "2019-08-01T19:47:40",
                "message_text_only": "In the last #bitcoin-core-dev IRC meeting, the mailing list moderation\nwas slightly discussed. It was decided to do this discussion mainly on\nthis mailing list (which makes sense).\n\nThe current situation is that the moderation is slow and takes around\n>24h for a E-Mail to be on the mailing list.\n\nJonas Schnelli proposed: \"I propose that we add more moderators to\nshorten the moderation lag which has been between >24h, thus makes\ndebates cumbersome\"\n\nBeside this I had the idea of people who already contributed n e-mails\nto the mailing list don't need an approval for any e-mail anymore (Where\nn is the number of previous e-mails). Does this exists already?\n\nGreetings,\nEmil Engler\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: pEpkey.asc\nType: application/pgp-keys\nSize: 3147 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/a78795b7/attachment.bin>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-08-02T11:43:27",
                "message_text_only": "On Thu, Aug 1, 2019 at 10:50 PM Emil Engler via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> The current situation is that the moderation is slow and takes around\n> >24h for a E-Mail to be on the mailing list\n\nIt really shouldn't be 24 hours. Our strategy was to have a few\nmoderators in different timezones to cover sleep shifts or other\ndisruptions of service. Evidently this has not been adequate.\n\n> Jonas Schnelli proposed: \"I propose that we add more moderators to\n> shorten the moderation lag which has been between >24h, thus makes\n> debates cumbersome\"\n\nMakes sense. I'll go find a few people.\n\n> Beside this I had the idea of people who already contributed n e-mails\n> to the mailing list don't need an approval for any e-mail anymore (Where\n> n is the number of previous e-mails). Does this exists already?\n\nThere is an active software vulnerability which requires moderation to\nbe enabled. This version of mailman is unmaintained, and Linux\nFoundation is migrating away from or abandoning the email protocol so\nthey are less willing to do backend infrastructure work. This\nmanifests in other ways, like downtime, but also weird situations like\nmissing emails that never hit the moderation queue. I get pings from\ndifferent people about two times a year where they report an email\nthat they think I missed, but in fact it never hit the moderation\nqueue at all. Email clearly isn't the greatest protocol.\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev moderation",
            "categories": [
                "bitcoin-dev",
                "Meta"
            ],
            "authors": [
                "Emil Engler",
                "Bryan Bishop"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2428
        }
    },
    {
        "title": "[bitcoin-dev] Improving JoinMarket's resistance to sybil attacks using fidelity bonds",
        "thread_messages": [
            {
                "author": "Chris Belcher",
                "date": "2019-08-02T09:21:57",
                "message_text_only": "On 31/07/2019 16:50, Dmitry Petukhov wrote:\n> \u0412 Tue, 30 Jul 2019 22:39:14 +0100\n> Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> wrote:\n> \n>> This is where a sacrifice of V bitcoins creates a\n>> bond of value V^2. The formula provides a strong incentive for\n>> profit-motivated makers to use all their fidelity bond coins with just\n>> one maker, not spread them out over many makers.\n> \n> The attacker derives additional value from the use of\n> locked utxo - the deanonimyzation capabilities.\n> \n> An entity M can use all of its locked coins to run a maker, and then\n> earn value X. It will also incur some operational expenses in the course\n> of running the maker, so the profit will be less than X.\n> \n> If these locked coins are given to the attacker A as a package, an\n> attacker can derive a value of X+D where D is a value of increased\n> deanonymization capabilities for an attacker. Operational expenses\n> for an attacker are the same as before (without timelocked bonds),\n> because they need to operate a lot of makers either way.\n> \n> If M is profit-driven and non-ideological, it can rent out all of its\n> coins to A as a package, for the price X, and get the same value without\n> running a maker and dedicating any resources and time to it, not\n> incurring any operatinal expenses (thus having a bigger profit in the\n> end).\n> \n> Attacker A will run a maker with M's coins, get profit X, pay X to M,\n> get increased deanonymization capabilities. \n> \n> If renting out of utxo is done in a way that the owner always gets X\n> after the lock expires, the operation will be riskless for the owner.\n> The attacker will need to lock amount X along with owner's coins, but\n> hopefully makes X back by running a maker operation. \n> \n> The price for renting out the coins will be determined on the size of\n> the 'coin package', so it will not be feasible for the owners of the\n> coins to rent them out separately.\n> \n> An attacker can even rent coins from several entities and combine them\n> to create a more 'powerful' maker. If I understand correctly, such\n> 'powerful' maker can have bigger profit than two less 'powerful'\n> makers. It seems like a centralization risk to me.\n> \n\nThere's a few different issues here.\n\nYes TXO fidelity bonds can be rented out, but that doesn't make a sybil\nattack cheaper. The aim of the fidelity bond scheme is to require makers\nto sacrifice value, renting out their fidelity bond coins doesn't avoid\nthat sacrifice because the sacrifice is the paid rent. Because of the\nmaths and market forces the rent paid by the attacker should be about\nthe same as the cost of just buying the bitcoins and locking them.\n\nCentralization and decentralization are not ends in themselves, the main\naim in JoinMarket is to improve privacy while keeping the other\nproperties of bitcoin (e.g. censorship resistance). A single maker can\nnever deanonoymize coinjoins no matter how valuable their bond is,\nbecause takers always choose multiple makers, and all of them need to be\ncontrolled by the sybil attacker for the attack to succeed. If a sybil\nattacker splits up their fidelity bonds (rented or not) amongst multiple\nmaker bots then they reduce the value of their bonds because of the V^2\nterm.\n\nRented TXOs does destroy the effect of \"A long-term holder probably\nwon't want to attack a system like JoinMarket which makes his own\ninvestment coins more private and more fungible\". However this is not\nthe main effect which would protect JoinMarket's privacy. The main\neffect is the cost which for real-life numbers would be about 45-120\nbitcoin sent to burner outputs.\n\nPerhaps then rented TXOs is an argument against using coin age as a way\nto create fidelity bonds. Hodlers would be far less likely to rent out\ntheir coins if they have to specifically move them to a special\ntime-locked address. Another point is that for privacy reasons creators\nof fidelity bonds should mix their coins before and after using them,\nbecause those TXOs are revealed to the world. So it's likely that\nfidelity bonds creators will need to install and run JoinMarket anyway."
            },
            {
                "author": "Adam Gibson",
                "date": "2019-08-02T14:24:11",
                "message_text_only": "reposted due to wrong email address:\n\nI'd just like to repeat something I said years ago but is undoubtedly lost\nnow:\n\n>\n> ### Today's low cost for sybil attacks\n>\n> A paper on JoinMarket [M\u00f6ser, Malte and Rainer B\u00f6hme. \u201cJoin Me on a\n> Market for Anonymity.\u201d (2016).] calculates the requirement of such a\n> sybil attack in 2016 to be just 32,000 USD. According to the paper such\n> an attack would succeed 90% of the time and the investment is\n> recoverable afterwards so that figure for the requirement isn't even a\n> true cost.\n>\n> JoinMarket has been improved since 2016 and more makers have joined, so\n> the true requirement is perhaps 2x or 3x higher today, but it is still\n> relatively low.\n>\n> Even with future improvements like fixing issue #693 [2] the requirement\n> of a sybil attack would probably only rise another 2x.\n>\n\nI criticised this point from the Moser paper at the time, in particular\nbecause it was the headline grabbing result and in my opinion was only half\nthe truth, at best:\n\nThe $32K figure came from the assumption that swamping the bottom of the\norder book (in other words, making lots of bots offering prices lower than\nall the other bots) would lead to taking most of the join volume.\n\nAt the time, this was true and false to some extent: it was true that the\ndefault order choosing algorithm was exponentially weighted to lower fees.\nBut it was also true even then that Takers could simply manually choose any\ncounterparty bots they liked (-P).\n\nAlso at the time I complained that it was trivial to implement other order\nchoosing algorithms, in particular I advocated (for its simplicity) \"choose\nrandomly under a user specified maximum fee\", and indeed since the paper we\nhave implemented that algorithm and it's now the default.\n\nNote that this algorithm is the crudest variant of what was loosely called\n\"quantization\" in this discussion between belcher and gmaxwell on the topic\nsome years ago:\n\nhttps://github.com/JoinMarket-Org/joinmarket/issues/14#issuecomment-143509788\n\nTo me the crucial point is that the Taker's price sensitivity should not be\ntoo large, although of course it cannot be zero!\n\nSo independent of changes in the makeup of the users of Joinmarket, that\nanalysis from 2016 was in my opinion a bit skewed at the time, and\ncompletely wrong today.\n\nNone of this is a critique of the fidelity bonds idea, since the Sybil\nthreat is real in any case (see issue 693 as mentioned), but price-based\nSybilling is less effective than it seems based on that.\n\nI'll continue my thoughts on fidelity bonds, for what they're worth, in the\nactive thread:\nhttps://github.com/JoinMarket-Org/joinmarket-clientserver/issues/371\n\n(for those not in the know, Joinmarket-Org/joinmarket-clientserver is the\nactive repo, not Joinmarket-Org/joinmarket).\n\nAdam Gibson / waxwing / AdamISZ\n\nOn Thu, Jul 25, 2019 at 3:18 PM Chris Belcher via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> JoinMarket[1] can be sybil attacked today at relatively low cost which\n> can destroy its privacy. Bitcoins can be sacrificed with burner outputs\n> and time-locked addresses (also called fidelity bonds), and this can be\n> used to greatly improve JoinMarket's resistance to sybil attacks.\n>\n> With real-world data and realistic assumptions we calculate that under\n> such a fidelity bond system an adversary would need to lock up\n> 30,000-80,000 bitcoins for months, or send 45-120 bitcoins to burner\n> addresses to have a good chance of sybil attacking the system if it were\n> added to JoinMarket.\n>\n> This increased resistance to sybil attacks would most likely cause\n> coinjoin fees to rise. I think the added cost is worth it for the\n> greatly improved privacy, because today miner fees are the biggest cost\n> to JoinMarket takers not coinjoin fees which are very low. Users should\n> definitely share their opinion on fees after reading the document.\n>\n> ## Introduction\n>\n> JoinMarket creates a market for coinjoins, allowing anyone to create\n> equal-amount coinjoins for any amount they want at any time they want.\n> In return they pay a fee for the liquidity made available to them. The\n> project has existed since 2015 and has probably created hundreds of\n> thousands of coinjoins since then. Today there is available liquidity\n> for creating coinjoins with amounts up to about 400 btc per coinjoin\n> output.\n>\n> ### Sybil attacks\n>\n> JoinMarket, like many other schemes where participants are free to\n> anonymously enter, can be targetted by sybil attacks. In JoinMarket this\n> would work by an attacker running lots of maker bots which attempt to be\n> all the makers in every coinjoin. If successful the attacker would have\n> enough information unmix every coinjoin.\n>\n> One way to solve the problem of sybil attacks is centralization. For\n> example coinjoins could be constructed on a centralized server. Then\n> random anonymous participants cant sybil attack because they can't\n> control the coinjoin construction, but this comes at the cost that the\n> server can sybil attack very easily. So this solution is probably a bad\n> tradeoff.\n>\n> In general, sybil attacks are solved by making them expensive. For\n> example, bitcoin mining resists sybil attacks because it requires a\n> provable sacrifice of electricity to mine. A bitcoin user can calculate\n> the actual monetary value that an attacker must spend in order to\n> reverse their transaction.\n>\n> Likewise in JoinMarket such a sybil attack is not free either as the\n> attacker needs to own enough bitcoins to run enough maker bots for all\n> the coinjoins.\n>\n> ### Today's low cost for sybil attacks\n>\n> A paper on JoinMarket [M\u00f6ser, Malte and Rainer B\u00f6hme. \u201cJoin Me on a\n> Market for Anonymity.\u201d (2016).] calculates the requirement of such a\n> sybil attack in 2016 to be just 32,000 USD. According to the paper such\n> an attack would succeed 90% of the time and the investment is\n> recoverable afterwards so that figure for the requirement isn't even a\n> true cost.\n>\n> JoinMarket has been improved since 2016 and more makers have joined, so\n> the true requirement is perhaps 2x or 3x higher today, but it is still\n> relatively low.\n>\n> Even with future improvements like fixing issue #693 [2] the requirement\n> of a sybil attack would probably only rise another 2x.\n>\n> Apart from the cost to sybil attack being low, there is also the odd\n> situation that smaller coinjoin amounts receive less sybil protection\n> than large ones. It costs 100x less to sybil attack a transaction of 0.1\n> btc than one of 10 btc. Why should smaller amounts receive less\n> sybil-resistance and therefore less privacy?\n>\n> ### Liquidity\n>\n> When creating this project, it was expected that many more people would\n> enter the market as makers and so the cost of a sybil attack would be\n> very high. That has not happened. One reason is that everyone who wants\n> to create a coinjoin is able to even for large amounts. The fundamental\n> problem is that takers are paying-for and getting liquidity, but not\n> necessarily sybil-resistance.\n>\n> Another smaller reason for the low cost of sybil attacks is that many\n> people don't want to store too many bitcoins on an computer connected to\n> the internet.\n>\n> What is needed is a way to increase the cost of running in a maker in a\n> way that retains the anonymity and is attractive to long-term holders of\n> bitcoin. This can be done using time-locked addresses.\n>\n> ## Fidelity bonds\n>\n> In bitcoin, a fidelity bond [3] is a mechanism where bitcoin value is\n> deliberately sacrificed to make a cryptographic identity expensive to\n> obtain. The sacrifice is done in a way that can be proven to a third party.\n>\n> A way to create a fidelity bond is to burn an amount of bitcoins by\n> sending to a OP_RETURN output. Another kind is time-locked addresses\n> created using OP_CHECKLOCKTIMEVERIFY where the valuable thing being\n> sacrificed is time rather than money, but the two are related because of\n> the time-value-of-money.\n>\n> Under this system, makers would sacrifice an amount of bitcoins and\n> publish a proof along with their coinjoin offers. Takers would choose\n> maker offers based on the sacrificed amount (as well as other factors),\n> knowing that a sybil attacker would also have to sacrifice a certain\n> amount of coins in order to unmix the taker's coinjoins. The sacrifice\n> would be an objective measurement that can't be faked and which can be\n> verified by anybody (just like, for example PoW mining)\n>\n> Note that a long-term holder (or hodler) of bitcoins can buy time-locked\n> fidelity bonds essentially for free, assuming they never intended to\n> transact with their coins much anyway. A long-term holder probably won't\n> want to attack a system like JoinMarket which makes his own investment\n> coins more private and more fungible.\n>\n> ### Fidelity bonds in cold storage\n>\n> The private keys of fidelity bonds can be kept offline. Signatures\n> potentially only need to be made when the timelock expires (every 6\n> months for example), or only once in the case of OP_RETURN burned coins.\n> This allows JoinMarket's sybil resistance to increase without the hot\n> wallet risk.\n>\n> Burned coin signatures should still have a lifetime, in case the private\n> key associated with the IRC nick (which is online) is stolen, so that\n> the thief of that privkey can't impersonate the maker indefinitely. The\n> signature linking the burned coins and IRC nick could expire after\n> perhaps 6 months.\n>\n> ### Anonymity\n>\n> Under this scheme makers would need to publish the transactions of their\n> fidelity bonds to the entire world. Those transactions could be subject\n> to blockchain analysis. So before makers do this they should make sure\n> their coins are anonymous (possibly by mixing with JoinMarket). Also if\n> they ever want to use their coins for something else apart from fidelity\n> bonds they should mix them.\n>\n> ### Value of a fidelity bond\n>\n> See the other document (Financial mathematics of joinmarket fidelity\n> bonds)[4] for a formula expressing the value of a fidelity bond.\n>\n> The value of a fidelity bond made by sending V bitcoins to a burner\n> address is:\n>\n>     V^2\n>\n> The amount of bitcoins is squared to get the fidelity bond value. This\n> has the effect that economic-rational makers have a strong incentive to\n> lump up all their coin sacrifices together into one maker bot, not to\n> split it up over several bots.\n>\n> The value of a fidelity bond made by locking up V bitcoins in a\n> time-locked address for time period T is:\n>\n>     V^2 (exp(rT) - 1)^2\n>\n> To get an idea of the numbers, if we burn 2 btc then the value of the\n> fidelity bond is 4 BTC^2. If we lock up 100 BTC for one year, and have a\n> bitcoin interest rate r = 0.001 (0.1%) per year, then the value of that\n> fidelity bond is 0.01 BTC^2 which is the same as burning 0.1 BTC. That\n> is a relatively small valued bond. It can be increased by locking up\n> more bitcoins for longer (up to and including permanant locking via a\n> burner transaction).\n>\n> ## Taker algorithm for choosing makers\n>\n> I suggest the following taker peer choosing algorithm: obtain the list\n> of offers and discard offers which the taker's user deems are too\n> expensive. One of the remaining offers is randomly chosen with weighting\n> determined by the fidelity bond value. Once an offer is chosen it is\n> removed from the list, and another offer is again randomly chosen, this\n> is repeated until the taker has chosen the desired number of\n> fidelity-bonded maker's offers.\n>\n> Some people run makers not for profit but for their own privacy.\n> Therefore not all makers should be required to have bonds, because such\n> privacy-makers are useful to include in coinjoins too. We could have\n> taker allow say, an eighth (12.5%), of their coinjoin peers to be makers\n> without bonds. They can be chosen randomly from the orderbook without\n> any weighting based on fidelity bond values. Of course these are easy to\n> fake by an adversary so they dont contribute much to sybil resistance.\n>\n> ### Cost of sybil attacks\n>\n> See the other document (Cost of sybil attacks) for discussion and\n> calculations on the sybil resistance given by the above maker-choosing\n> algorithm.\n>\n> It can be calculated that the fidelity bond system dramatically\n> increases the cost of a sybil attack. With real-world data and realistic\n> assumptions we can calculate that a sybil attacker would need to lock up\n> 30,000-80,000 bitcoins for 6 months, or send 45-120 bitcoins to burner\n> addresses to have a good chance of attacking the system by being all the\n> counterparties in everyone's coinjoin.\n>\n> ## Effect of fidelity bonds on CoinJoin fees\n>\n> Someone might ask \"why would anyone lock up coins for months or more,\n> let alone burn coins forever, just to run a maker bot\". The only way\n> this would even happen is if makers can generate a higher income that\n> justifies the fidelity bond sacrifice. That higher income can only come\n> from taker's coinjoin fees (or possibly coinswap fees one day). We can\n> expect that makers with higher valued fidelity bonds will demand higher\n> coinjoin fees. So a big question is whether takers will accept paying\n> higher coinjoin fees. I think they will, because right now coinjoin fees\n> are only 10-1000 satoshi, and a far biggest cost of coinjoins is the\n> miner fee not the coinjoin fee. I'm pretty sure takers will recognize\n> that they get what they pay for, and that additional privacy is well\n> worth the cost. Any other takers reading this should definitely let me\n> know what they think.\n>\n> ## Technical ideas\n>\n> JoinMarket's wallet could also create time-locked addresses. Locktimes\n> should be fixed to be midnight on the first day of each month, then each\n> public key corresponds to 12 addresses per year (1200 addresses per\n> century) which is very practical to all be monitored as watch-only\n> addresses. These wallets can be created offline and could safely hold\n> time-locked bitcoins.\n>\n> The timelocked addresses public key can be used to sign an IRC nickname\n> proving that the nickname is the real owner of the TXO. OP_RETURN\n> outputs used for burning coins can include a pubkey hash used for the\n> same thing.\n>\n> We don't want the cold storage keypairs to be held online. We can design\n> the system that the time-locked address keypair is held offline but it\n> signs another key pair which is held online. Every time the IRC bot\n> connects it can use this intermediate keypair to sign the IRC nickname\n> proving ownership. The signature from the time-locked address to the\n> intermediate keypair can be made to have an expiry date (for example 6\n> months). This all means that the time-locked bitcoins can be held\n> offline but still be used to prove ownership of an IRC nickname.\n>\n> The existance of the UTXO of a time-locked coin can be proved by\n> revealing the TXID and vout, which full nodes can use to query the UTXO\n> set to check that the coin exists. SPV clients would need a merkle proof\n> as well. Burned coins and spent time-locked coins could have their\n> existence proved by sharing the transaction which created them along\n> with a block height and transaction position for an unpruned node, or a\n> merkle proof for a pruned node or SPV client. Note that from the point\n> of view of a pruned node, a merkle proof is a fully-verified proof of\n> existance of a transaction. It is not a proof with just SPV-security.\n>\n> ## Links / References\n> [1] https://github.com/JoinMarket-Org/joinmarket-clientserver\n> [2] https://github.com/JoinMarket-Org/joinmarket/issues/693\n> [3] https://en.bitcoin.it/wiki/Fidelity_bonds\n> [4] https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b\n> [5]\n>\n> https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b#cost-of-sybil-attacks\n> [6] First ever mention of fidelity bonds I found. The idea is basically\n> invented by Peter Todd: https://bitcointalk.org/index.php?topic=134827.0\n> [7] Old idea for combining fidelity bonds with mixers:\n> https://bitcointalk.org/index.php?topic=172047.0\n> [8] Suggestion that is very close to the fidelity bonds idea. He talks\n> about requiring a deposit from makers, but nobody is able to come up\n> with a way to make such a deposit decentralized and trustless:\n>\n> https://www.reddit.com/r/Bitcoin/comments/2zc5tc/joinmarket_increase_the_privacy_of_bitcoin_and/ctk37hn/?context=1\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/ccfbca83/attachment-0001.html>"
            },
            {
                "author": "Chris Belcher",
                "date": "2019-08-05T19:04:26",
                "message_text_only": "On 02/08/2019 10:50, Dmitry Petukhov wrote:\n> \u0412 Fri, 2 Aug 2019 10:21:57 +0100\n> Chris Belcher <belcher at riseup.net> wrote:\n> \n>> The aim of the fidelity bond scheme is to require makers\n>> to sacrifice value, renting out their fidelity bond coins doesn't\n>> avoid that sacrifice because the sacrifice is the paid rent\n> \n> But if the entity that rented the coins, makes a profit using this coins\n> from the maker opertion, and it makes the same or higher amount than\n> it paid in rent, is it a sacrifice ? Given that the aim was to not make\n> a profit in the first place, just increase deanonymization\n> capabilities ?\n\nYes you're right. I should correct myself: Running a maker under the\nproposal doesn't require a sacrifice of value, in fact you actually make\nmoney doing it.\n\nHowever, there _is_ a cost to being a sybil attacker. If we define\nhonest makers as entities who run just one maker bot, and dishonest\nmakers as entities who run multiple maker bots, then we can say that\nrunning a dishonest maker operation requires a sacrifice of fee income,\nbecause someone doing that would earn more money if they ran an honest\nmaker instead. This happens because of the quadratic V^2 term in the\nformula calculating the fidelity bond value, which provides this\nincentive for lumping together fidelity bonds. This V^2 is probably the\nmost important part for privacy.\n\nThe V^2 term also creates a bad incentive where multiple people might\nchoose to pool together their bitcoin hoard into one maker bot so that\neach can earn a higher fee income. This can be done by renting out TXOs\nsignatures as you've said.\n\nSo what's needed is a way to make renting out TXOs impossible or very\ndifficult. We can note that fidelity bonds made of rented TXOs will be\nmade up of a large number of relatively small valued TXOs, so one\namelioration is to cap the number of TXOs that can be used in one\nfidelity bond. This could be worked around by honest makers because they\ncan consolidate TXOs on the blockchain, which rented TXO owners can't do\nbecause the TXOs are owned by different people.\n\nAnother way is to require the bond signature proofs to involve the\none-time taker identifier, and so be different every time. This\nbasically requires fidelity bond privkeys to be online in hot wallets,\nand so should massively increase the difficulty of renting TXOs because\nthe maker and the TXO owner need to be in constant real-time communication.\n\nThoughts?\n\nCB"
            },
            {
                "author": "Leo Wandersleb",
                "date": "2019-08-06T01:51:02",
                "message_text_only": "On 8/6/19 7:04 AM, Chris Belcher via bitcoin-dev wrote:\n> However, there _is_ a cost to being a sybil attacker. If we define\n> honest makers as entities who run just one maker bot, and dishonest\n> makers as entities who run multiple maker bots, then we can say that\n> running a dishonest maker operation requires a sacrifice of fee income,\n> because someone doing that would earn more money if they ran an honest\n> maker instead. This happens because of the quadratic V^2 term in the\n> formula calculating the fidelity bond value, which provides this\n> incentive for lumping together fidelity bonds. This V^2 is probably the\n> most important part for privacy.\n\nAs established above, there will emerge a market to lock coins, so these locks\nwill be readily available without having to buy them. Even with V^2 there is no\nreason to amass more coins beyond a certain point. Running the biggest 5 V^2\nscores should be pretty solid to get in on many coin joins.\n\n> Another way is to require the bond signature proofs to involve the\n> one-time taker identifier, and so be different every time. This\n> basically requires fidelity bond privkeys to be online in hot wallets,\n> and so should massively increase the difficulty of renting TXOs because\n> the maker and the TXO owner need to be in constant real-time communication.\n\nRequiring the bond to reside on a hot wallet would be a massive disadvantage.\n\nNo matter how you look at the whole problem of sibyl attacks, the honest maker\nwill have operational costs and gain fees and the sibyl attacker will have the\nsame plus profit from the deanonymization. As long as makers hunt marginal\nprofits, the sibyl attacker having the higher margin from deanonymization will\nalways win. The fidelity bonds would make this even worse, as increased\ncomplexity and entry cost would not favor more makers but less even before the\ncentralization incentive mentioned above (V^2). To say that old holders have\nbitcoins laying around that they can use for such bonds is a fallacy as they\ncould just as well rent them out on a bonds market.\n\nHow about turning this upside down and shift the incentives from being taker to\nbeing maker by introducing a mandatory fee? If each join costs 1% per maker,\npeople would initially gasp and reject to update to that version but those who\ndo, will do to become makers, increasing the maker count massively and\neventually most people in frequent need of joining will also become makers to\noffset the costs of being takers.\n\nWith these changed rules again the sibyl attackers would still have their\ncompetitive edge and would flood the market with even more cheap offers but now\neverybody would have an incentive to do the same and as makers have to have the\nUTXOs, it's not free to sibyl attack already.\n\nLW"
            },
            {
                "author": "Chris Belcher",
                "date": "2019-08-06T10:27:17",
                "message_text_only": "On 06/08/2019 02:51, Leo Wandersleb via bitcoin-dev wrote:\n> On 8/6/19 7:04 AM, Chris Belcher via bitcoin-dev wrote:\n>> However, there _is_ a cost to being a sybil attacker. If we define\n>> honest makers as entities who run just one maker bot, and dishonest\n>> makers as entities who run multiple maker bots, then we can say that\n>> running a dishonest maker operation requires a sacrifice of fee income,\n>> because someone doing that would earn more money if they ran an honest\n>> maker instead. This happens because of the quadratic V^2 term in the\n>> formula calculating the fidelity bond value, which provides this\n>> incentive for lumping together fidelity bonds. This V^2 is probably the\n>> most important part for privacy.\n> \n> As established above, there will emerge a market to lock coins, so these locks\n> will be readily available without having to buy them. Even with V^2 there is no\n> reason to amass more coins beyond a certain point. Running the biggest 5 V^2\n> scores should be pretty solid to get in on many coin joins.\n\nWe can be much more exact than saying makers get in on \"many\" coins. The\nsupporting document \"Financial mathematics of JoinMarket fidelity bonds\"\ncontains calculations for exactly this:\nhttps://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b#sybil-attacks-from-enemies-within\n\nThe document finds that with realistic real-world data, the makers with\nthe top 5 most valuable bonds will be chosen 48% of the time. So\napproximately half:half success for one coinjoin. This isn't enough to\ndeanonymize every single coinjoin. For example, the tumbler script by\ndefault makes around 16 transactions so the odds of a successful sybil\nattack is (0.48)^16 = 8 parts per million, with the success probability\nreducing exponentially after each additional coinjoin.\n\n>> Another way is to require the bond signature proofs to involve the\n>> one-time taker identifier, and so be different every time. This\n>> basically requires fidelity bond privkeys to be online in hot wallets,\n>> and so should massively increase the difficulty of renting TXOs because\n>> the maker and the TXO owner need to be in constant real-time communication.\n> \n> Requiring the bond to reside on a hot wallet would be a massive disadvantage.\n\nHopefully it won't come to that and we can invent some other way to stop\nrenting TXOs. But if that's the only way then we'd have to code it in\norder to protect the interests of takers.\n\nThe most dangerous source of rented TXOs seems to be the coin age form\nof fidelity bond. Hodlers could have coins already in a hardware wallet\nor cold storage and just sign proofs renting their UTXOs to earn an\nextra income without changing their setup at all. Bonds from OP_CLTV and\nOP_RETURN burned coins seems to me a much less likely source of rented TXOs.\n\nBecause of that, it seems to me only coin age fidelity bonds would be\nrequired to be on hot wallets.\n\nAnother option worth considering is the have a separate lower interest\nrate for coin age bonds compared to OP_CLTV bonds, this would reflect\nthe lower sacrifice for coin age (past sacrifices must be worth less\nthan future sacrifices, because of risk and uncertainty of the unknown\nfuture, as well as the risk of rented UTXOs)\n\n> No matter how you look at the whole problem of sibyl attacks, the honest maker\n> will have operational costs and gain fees and the sibyl attacker will have the\n> same plus profit from the deanonymization. As long as makers hunt marginal\n> profits, the sibyl attacker having the higher margin from deanonymization will\n> always win. The fidelity bonds would make this even worse, as increased\n> complexity and entry cost would not favor more makers but less even before the\n> centralization incentive mentioned above (V^2). To say that old holders have\n> bitcoins laying around that they can use for such bonds is a fallacy as they\n> could just as well rent them out on a bonds market.\n\nI think this is absolutely wrong, because sybil attackers give up some\nfee income. Here is a worked example:\n\nLet's say the sybil attacker is operating the top 5 most valuable maker\nbots. If this attacker has X coins they would split them equally into 5,\nso each maker has X/5 coins and their bond is worth (X^5)^2 = X^2/25,\nwith a total of 5 bots the fee income would be proportional to 5*X^2/25\n= X^2/5. However if an honest maker had X coins they could create a\nsingle bond which would be worth simply X^2 with a fee income\nproportional to X^2. So the honest maker has a fee income higher by a\nfactor of 5 than the sybil attacker. The sybil attacker must take a 5x\nhit to their fee income in order to sybil attack. This is the crucial\neffect of the V^2 term.\n\nThe V^2 term is important, it just has the downside of incentivizing\nrenting of coins. If we can make that impossible then the problem would\ngo away.\n\n> How about turning this upside down and shift the incentives from being taker to\n> being maker by introducing a mandatory fee? If each join costs 1% per maker,\n> people would initially gasp and reject to update to that version but those who\n> do, will do to become makers, increasing the maker count massively and\n> eventually most people in frequent need of joining will also become makers to\n> offset the costs of being takers.\n> \n> With these changed rules again the sibyl attackers would still have their\n> competitive edge and would flood the market with even more cheap offers but now\n> everybody would have an incentive to do the same and as makers have to have the\n> UTXOs, it's not free to sibyl attack already.\n> \n\nApart from the inability of developers to enforce any kind of price, I\ndon't think this scheme would fix the sybil attack problem, because a\nsybil attacker still gets a higher gain (deanonymization + fees)\ncompared to honest makers (who earn just fees)"
            },
            {
                "author": "Leo Wandersleb",
                "date": "2019-08-06T13:07:19",
                "message_text_only": "On 8/6/19 10:27 PM, Chris Belcher via bitcoin-dev wrote:\n> I think this is absolutely wrong, because sybil attackers give up some\n> fee income. Here is a worked example:\n>\n> Let's say the sybil attacker is operating the top 5 most valuable maker\n> bots. If this attacker has X coins they would split them equally into 5,\n> so each maker has X/5 coins and their bond is worth (X^5)^2 = X^2/25,\n> with a total of 5 bots the fee income would be proportional to 5*X^2/25\n> = X^2/5. However if an honest maker had X coins they could create a\n> single bond which would be worth simply X^2 with a fee income\n> proportional to X^2. So the honest maker has a fee income higher by a\n> factor of 5 than the sybil attacker. The sybil attacker must take a 5x\n> hit to their fee income in order to sybil attack. This is the crucial\n> effect of the V^2 term.\n>\n> The V^2 term is important, it just has the downside of incentivizing\n> renting of coins. If we can make that impossible then the problem would\n> go away.\n\nTo show how this argument is wrong, think about the market being split between\n100 makers, each making 1% of the fees. By your argument, by colluding, they\ncould make far more than 100% of the fees.\n\nEvery cartel of makers pooling their bonds beating the odds can't be the goal.\n\nAnd again, bonds are just a cost of business. If a $10/month in bonds (paid to a\nguy to sign with his UTXOs or interest for BTCs lent or ...) leaves me with zero\nfees, a $100/month with $1k in fees and $10k/month with $40k in fees, then there\nmight be a $1000/month barrier to entry for this market but there are enough\npeople with $10k available to enter the market and drive the fees (earned per\nmaker) down such that the barrier to entry increases even further. In the end,\nonly the holders of the 20 biggest bonds will get meaningful business and the\nrest will lose their investment or just not bother being makers. And the sibyl\nattackers again are the ones that put up the necessary funds with most ease of\nthem all."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-06T02:54:14",
                "message_text_only": "Good morning Chris,\n\n\n> This could be worked around by honest makers because they\n> can consolidate TXOs on the blockchain, which rented TXO owners can't do\n> because the TXOs are owned by different people.\n\nWould it not be possible the below?\n\n* I rent some funds from Dmitry.\n  I agree to pay him 0.5 BTC for this service of putting up 50BTC from Dmitry UTXO.\n* I also own 50BTC myself in a separate UTXO.\n* We create a funding transaction paying out to a Schnorr MuSig output that is 2-of-2 between us.\n  This spends Dmitry UTXO 50 BTC and my UTXO 50BTC.\n  We only create this yet and do not sign.\n* We create a backout transaction, probably with `nLockTime`, paying out 50.5BTC to Dmitry and 49.5BTC to me.\n  This spends the funding transaction.\n  We sign this using MuSig.\n* After we exchange the signatures of the backout transaction, we exchange signatures for the funding transaction.\n* Now we have a common 100BTC UTXO (indistinguishable from other Schnorr single-sig UTXOs) that can be used as fidelity bond for me.\n  This is the output of the funding transaction.\n\nThe above can be scaled up so I can rent arbitrary amounts of coin from many different people, who are assured of getting their funds back, in exchange for a fidelity bond / advertisement, and thus greatly destroying the properties of the V^2 tweak.\n\n(The ability to have shared ownership of UTXOs is a powerful feature of Bitcoin, and backs its ability to scale, as witnessed with Lightning Network and channel factories.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-06T20:55:41",
                "message_text_only": "\u0412 Mon, 5 Aug 2019 20:04:26 +0100\nChris Belcher <belcher at riseup.net> wrote:\n\n> So what's needed is a way to make renting out TXOs impossible or very\n> difficult.\n\nYou can make renting the TXOs risky for the attacker. Make it so that\nthe entity that rented out the TXO can revoke the participation of said\nTXO in the market, by publishing some special signature. That act of\nrevocation can also mean revocation of all other TXOs that were used in\na bond alongside it. This way, any entity that wants to spoil an\nattacker's consolidation via rent, can rent out its TXO to the\nattacker, and then revoke it, spoiling the whole package the attacker\nhave consolidated.\n\nThere may be other way to impose penalties.\n\nFor example, all locked TXO may be required to be spendable by *any*\nkey that controls any TXO in the 'bond TXO package'. I think this\nshould be possible with taproot - you will have to publish a taproot\ntrees for your locked TXOs (say, N of them), and the tree for each TXO\nwill have N leaves, each leaf will specify a condition \"spendable by\nthe key N\". This way, if I give you my TXO to include it in a bond by\nlocking it, you also need to make your other TXOs in a bond spendable\nby me.\n\nFor both scenarios to work for the attacker, there's need to be an\noff-chain contractual relationship between the parties. Otherwise the\nentity that rents out the TXOs can spoil or just confiscate the bond of\nthe entity that rented them, without reprecussions."
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-06T21:37:42",
                "message_text_only": "Unfortunately, both described schemes fail the same way as\n'require TXOs to be consolidated by the owner', by the fact that with\nmuSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in\n[1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban\nmusig for the bonds' is not the answer, I believe.\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html\n\n\u0412 Wed, 7 Aug 2019 01:55:41 +0500\nDmitry Petukhov <dp at simplexum.com> wrote:\n\n> \u0412 Mon, 5 Aug 2019 20:04:26 +0100\n> Chris Belcher <belcher at riseup.net> wrote:\n> \n> > So what's needed is a way to make renting out TXOs impossible or\n> > very difficult.  \n> \n> You can make renting the TXOs risky for the attacker. Make it so that\n> the entity that rented out the TXO can revoke the participation of\n> said TXO in the market, by publishing some special signature. That\n> act of revocation can also mean revocation of all other TXOs that\n> were used in a bond alongside it. This way, any entity that wants to\n> spoil an attacker's consolidation via rent, can rent out its TXO to\n> the attacker, and then revoke it, spoiling the whole package the\n> attacker have consolidated.\n> \n> There may be other way to impose penalties.\n> \n> For example, all locked TXO may be required to be spendable by *any*\n> key that controls any TXO in the 'bond TXO package'. I think this\n> should be possible with taproot - you will have to publish a taproot\n> trees for your locked TXOs (say, N of them), and the tree for each TXO\n> will have N leaves, each leaf will specify a condition \"spendable by\n> the key N\". This way, if I give you my TXO to include it in a bond by\n> locking it, you also need to make your other TXOs in a bond spendable\n> by me.\n> \n> For both scenarios to work for the attacker, there's need to be an\n> off-chain contractual relationship between the parties. Otherwise the\n> entity that rents out the TXOs can spoil or just confiscate the bond\n> of the entity that rented them, without reprecussions."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-06T23:33:19",
                "message_text_only": "Good morning all,\n\nIt might be useful to remember that there exists pressure to pool proof-of-work due to tiny non-linearities caused by Proximity Premium and Variance Discount flaws.\nSimilarly, any non-linearity in any fidelity bond scheme exerts the same pooling pressure.\nDeliberately increasing the non-linearity to V^2 worsens the pooling pressure, not lessens it.\n\n(I wonder if instead going the opposite way and doing V^0.999 might work better; I have not figured all the implications of such a scheme and leave it to the reader.)\n\n> Unfortunately, both described schemes fail the same way as\n> 'require TXOs to be consolidated by the owner', by the fact that with\n> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in\n> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban\n> musig for the bonds' is not the answer, I believe.\n\nIf my understanding is correct, efforts to expand ECDSA to more than two-party n-of-n \"true\" multisignatures already are ongoing.\n\nOne might attempt to use transaction malleability as a protection, and require that transactions that put up bond TXOs should spend from at least one ***non***-SegWit output, so that the scheme as described fails (as the funding txid is malleable after-the-fact).\n\nBut the scheme as described only considers ways to securely aggregate *within* the Bitcoin universe.\n\nI have recently learned of a spacce called the \"real world\", wherein apparently there exist things as \"contract law\".\nIt seems to me this \"contract law\" is a half-baked implementation of Bitcoin cryptographic smart contracts.\nBy what little I understand of this \"contract law\", it would be possible for an aggregator to accept some amount of money, with a promise to return that money in the future with some additional funds.\nIf the aggregator fails to uphold its promise, then some (admittedly centralized) authority entity within the \"real world\" then imposes punishments (apparently inspired by similar mechanisms in Lightning Network) on the aggregator.\nSuch arrangements (accepting some money now with a promise to return the money, plus some interest earned, in the future) apparently already exist in this \"real world\", under the name of \"time deposits\".\n\n\nRegards,\nZmnSCPxj\n\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html\n>\n> \u0412 Wed, 7 Aug 2019 01:55:41 +0500\n> Dmitry Petukhov dp at simplexum.com wrote:\n>\n> > \u0412 Mon, 5 Aug 2019 20:04:26 +0100\n> > Chris Belcher belcher at riseup.net wrote:\n> >\n> > > So what's needed is a way to make renting out TXOs impossible or\n> > > very difficult.\n> >\n> > You can make renting the TXOs risky for the attacker. Make it so that\n> > the entity that rented out the TXO can revoke the participation of\n> > said TXO in the market, by publishing some special signature. That\n> > act of revocation can also mean revocation of all other TXOs that\n> > were used in a bond alongside it. This way, any entity that wants to\n> > spoil an attacker's consolidation via rent, can rent out its TXO to\n> > the attacker, and then revoke it, spoiling the whole package the\n> > attacker have consolidated.\n> > There may be other way to impose penalties.\n> > For example, all locked TXO may be required to be spendable by any\n> > key that controls any TXO in the 'bond TXO package'. I think this\n> > should be possible with taproot - you will have to publish a taproot\n> > trees for your locked TXOs (say, N of them), and the tree for each TXO\n> > will have N leaves, each leaf will specify a condition \"spendable by\n> > the key N\". This way, if I give you my TXO to include it in a bond by\n> > locking it, you also need to make your other TXOs in a bond spendable\n> > by me.\n> > For both scenarios to work for the attacker, there's need to be an\n> > off-chain contractual relationship between the parties. Otherwise the\n> > entity that rents out the TXOs can spoil or just confiscate the bond\n> > of the entity that rented them, without reprecussions.\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Chris Belcher",
                "date": "2019-08-07T10:05:41",
                "message_text_only": "These are very creative schemes. At the very least they would stop the\neasy mindless renting TXO method, where someone with coins on a hardware\nwallet simply creates a signature and copypastes it into a website to\nget free money. The workaround scheme with shared ownership of TXOs\nrequires brand new wallets to be created and hodlers must trust the\nwallets enough to move their coins and hold them there for a long time.\n\nRequiring fidelity bond TXOs to be held in hot wallets can also be\nbeaten as a scheme for stopping renting, because the rentee can put\ntheir coin private keys on an always-on raspberry pi which is connected\nto the maker's computer and constantly ready to give out signatures. The\ncoins would be in hot wallets yet still be rented out. As above the\nraspberry pi setup would be much more of a hassle than copypasting a\nsignature into a website, so it could still be worth doing.\n\nI wonder if there's a cryptographic way to prove that muSig and 2P-ECDSA\nhave not been used to create a certain pubkey/signature.\n\nOn 06/08/2019 22:37, Dmitry Petukhov wrote:\n> Unfortunately, both described schemes fail the same way as\n> 'require TXOs to be consolidated by the owner', by the fact that with\n> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in\n> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban\n> musig for the bonds' is not the answer, I believe.\n> \n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html\n> \n> \u0412 Wed, 7 Aug 2019 01:55:41 +0500\n> Dmitry Petukhov <dp at simplexum.com> wrote:\n> \n>> \u0412 Mon, 5 Aug 2019 20:04:26 +0100\n>> Chris Belcher <belcher at riseup.net> wrote:\n>>\n>>> So what's needed is a way to make renting out TXOs impossible or\n>>> very difficult.  \n>>\n>> You can make renting the TXOs risky for the attacker. Make it so that\n>> the entity that rented out the TXO can revoke the participation of\n>> said TXO in the market, by publishing some special signature. That\n>> act of revocation can also mean revocation of all other TXOs that\n>> were used in a bond alongside it. This way, any entity that wants to\n>> spoil an attacker's consolidation via rent, can rent out its TXO to\n>> the attacker, and then revoke it, spoiling the whole package the\n>> attacker have consolidated.\n>>\n>> There may be other way to impose penalties.\n>>\n>> For example, all locked TXO may be required to be spendable by *any*\n>> key that controls any TXO in the 'bond TXO package'. I think this\n>> should be possible with taproot - you will have to publish a taproot\n>> trees for your locked TXOs (say, N of them), and the tree for each TXO\n>> will have N leaves, each leaf will specify a condition \"spendable by\n>> the key N\". This way, if I give you my TXO to include it in a bond by\n>> locking it, you also need to make your other TXOs in a bond spendable\n>> by me.\n>>\n>> For both scenarios to work for the attacker, there's need to be an\n>> off-chain contractual relationship between the parties. Otherwise the\n>> entity that rents out the TXOs can spoil or just confiscate the bond\n>> of the entity that rented them, without reprecussions.\n> \n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-07T11:35:34",
                "message_text_only": "Good morning Dmitry,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, August 7, 2019 6:05 PM, Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> These are very creative schemes. At the very least they would stop the\n> easy mindless renting TXO method, where someone with coins on a hardware\n> wallet simply creates a signature and copypastes it into a website to\n> get free money. The workaround scheme with shared ownership of TXOs\n> requires brand new wallets to be created and hodlers must trust the\n> wallets enough to move their coins and hold them there for a long time.\n\nPossibly not so much?\nThe wallet need only sign two things:\n\n1.  The fidelity bond itself.\n2.  The backout transaction.\n\nBoth can be done in a single session, then the private key involved can be erased permanently from memory.\nOnly the signature for the backout needs to be stored, and this can be safely stored without encryption by publishing to any cloud service --- others getting a copy of the signature does not let them change the signature to authorize a different transaction.\nIt would be enough to write the signing code in C and use special OS calls (which most languages higher than C do not expose) to allocate memory that will never be put in swap.\nThen generate the private key using that memory, then clear it after usage before deallocating to the OS.\nI believe `libsecp256k1` makes this easy.\n\nUnless part of the bond process requires that the taker do a challenge \"sign this random nonce for me\", but of note is that it would have to impose this on all makers.\nBut if so, consider again this:\n\n1.  There exists two non-spying makers with nearly-equal bond values.\n2.  These makers need to keep their bond private keys in hot storage.\n3.  I approach both makers and offer to aggregate their bond values, forming a new bond with 4x the weight of their individual bonds, and split up the increased earnings between us.\n    This can be made noncustodial by use of smart contracts on Bitcoin.\n4.  It is no different from the point of view of both makers: they still need to keep their bond private keys in hot storage.\n    But this way earns them more money than operating as non-spying makers.\n5.  I earn not only the fees for JoinMarket, I also earn additional fees for spying on CoinJoins.\n\nIt still seems to me that adding the V^2 tweak weakens the bond system, not strengthens it.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-07T15:10:17",
                "message_text_only": "\u0412 Wed, 7 Aug 2019 11:05:41 +0100\nChris Belcher <belcher at riseup.net> wrote:\n\n> These are very creative schemes. At the very least they would stop the\n> easy mindless renting TXO method, where someone with coins on a\n> hardware wallet simply creates a signature and copypastes it into a\n> website to get free money.\n\nThe second scheme (\"all locked TXO may be required to be spendable\nby *any* key that controls any TXO in the 'bond TXO package'\") is in\nalmost all regards the same as simple \"require TXO to be consolidated\",\nand looks like it is not in any way better than simple consolidation.\n\nThe first scheme - 'allow revocation of the whole bond by the key\ncontrolling even a single TXO in a bond' - might be more promising.\n\n> I wonder if there's a cryptographic way to prove that muSig and\n> 2P-ECDSA have not been used to create a certain pubkey/signature.\n\nIn the second scheme, to revoke/spoil the bond, the entity that\ncontrols one TXO participating in this bond needs to simply prove that\nit somehow controls/have the ability to spend that TXO.\n\nIn shared ownership rent scheme that ZmnSCPxj described in [1],\nthe 'TXO rentier' has a signed timelocked 'backout' transaction that\nspends the locked TXO, and assigns the reward to rentier.\n\nIf we say that any transaction that spends any TXO in the bond\n(ignoring the timelock), invalidates the bond when presented to\ntakers, then TXO rentier can revoke the bond by simply\npublishing this transaction (not to the blockchain, but by some other\nmeans so that takers can receive it).\n\nThe transaction validity can be verified, with the relaxed rules that\nignores the timelock. After it is verified, takers mark the whole\nbond as revoked and will not consider it when chosing makers.\n\nOne inconvenience here is that takers need to store the\ndata about revoked bonds. But it seems to me that there's no need\nfor that information to be synchronized between the participants\ninstantly. It is enougth for takers to get the revoked-set eventually.\n\nThe rentier are still incentivized to not spoil the bond, to receive\nthe profit. Their funds are locked anyway.\n\nBut if the goal of the 'rentier' is to attack the attacker, the\nopportunity cost of these locked funds is the cost of the attack.\n\nIf the renter rents TXOs from several entities to include in one bond,\nrevocation by one rentier spoils whole bond, and the total loss for all\nparticipants is bigger than the oportunity cost of locked funds of a\nsingle rentier that made the revocation. \n\nThe possibility of such revocation increases risk for the renter and\nwould-be co-rentiers, and is likely limit the possible scale of such\nTXO-renting operation.\n \n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-08T00:09:11",
                "message_text_only": "Good morning Dmitry,\n\n> The first scheme - 'allow revocation of the whole bond by the key\n> controlling even a single TXO in a bond' - might be more promising.\n\nIs it?\nI imagine any key can secretly be a MuSig or aggregated ECDSA key, with the aggregator being a signatory.\n\n>\n> > I wonder if there's a cryptographic way to prove that muSig and\n> > 2P-ECDSA have not been used to create a certain pubkey/signature.\n>\n> In the second scheme, to revoke/spoil the bond, the entity that\n> controls one TXO participating in this bond needs to simply prove that\n> it somehow controls/have the ability to spend that TXO.\n>\n> In shared ownership rent scheme that ZmnSCPxj described in [1],\n> the 'TXO rentier' has a signed timelocked 'backout' transaction that\n> spends the locked TXO, and assigns the reward to rentier.\n>\n> If we say that any transaction that spends any TXO in the bond\n> (ignoring the timelock), invalidates the bond when presented to\n> takers, then TXO rentier can revoke the bond by simply\n> publishing this transaction (not to the blockchain, but by some other\n> means so that takers can receive it).\n>\n> The transaction validity can be verified, with the relaxed rules that\n> ignores the timelock. After it is verified, takers mark the whole\n> bond as revoked and will not consider it when chosing makers.\n>\n> One inconvenience here is that takers need to store the\n> data about revoked bonds. But it seems to me that there's no need\n> for that information to be synchronized between the participants\n> instantly. It is enougth for takers to get the revoked-set eventually.\n>\n> The rentier are still incentivized to not spoil the bond, to receive\n> the profit. Their funds are locked anyway.\n>\n> But if the goal of the 'rentier' is to attack the attacker, the\n> opportunity cost of these locked funds is the cost of the attack.\n>\n> If the renter rents TXOs from several entities to include in one bond,\n> revocation by one rentier spoils whole bond, and the total loss for all\n> participants is bigger than the oportunity cost of locked funds of a\n> single rentier that made the revocation.\n>\n> The possibility of such revocation increases risk for the renter and\n> would-be co-rentiers, and is likely limit the possible scale of such\n> TXO-renting operation.\n\nThis is quite a clever solution.\n\nLet me then attempt to break it.\n\nIt is possible to encrypt data in such a way that it requires sequential operations in order to decrypt.\nhttps://www.gwern.net/Self-decrypting-files\n\nThis basically allows us to encrypt some data in such a way that its decryption is timelocked, by requiring a large number of sequential operations to decrypt.\n\nIt also seems to me (I am not a cryptographer) that it may be possible to present a ZKP that an encrypted text, encrypted using the above timelock decryption, is a signature of a particular message with a particular public key.\n\nThus, we can change the ritual to this:\n\n1.  I contact two lessors to aggregate their coins into a larger UTXO and thus break V^2.\n2.  We create a funding transaction that pays to a locked bond address, with a pubkey equal to a MuSig among us.\n    This spends the TXOs they want to lease out, as well as some of my funds to be used for paying for rent.\n    We do not sign this yet.\n3.  We create a backout transaction that returns the bond to both lessors, plus their rent.\n    We partly perform the MuSig ritual to sign this transaction, with me as the last step.\n4.  Instead of providing the completed signature to the lessors, I encrypt it using the above timelocked encryption.\n    I provide this encryption and a zero-knowledge proof that I have actually completed the signature ritual correctly and that the timelocked-encrypted text has the signature as plaintext.\n5.  The lessors now know they can acquire the signature by simply grinding the timelocked encryption.\n    This allows them to recover their money by the appointed time.\n6.  We then exchange signatures for the funding transaction and broadcast and confirm it.\n\nNow, the lessors cannot provide a valid timelocked transaction, as they do *not* yet have a complete signature; thus they cannot snitch about my aggregation of their funds.\nAt the same time, they know that the timelocked encryption allows them to eventually get a complete signature and recover their funds.\nI can defray this cost of processing by increasing my rent slightly.\n\nNow of course we can just go one step further and also allow bonds to be snitched by presenting the timelocked-encrypted text and the ZKP that it contains the signature for a timelocked transactions.\nBut it seems to me that there is more than one way to skin this particular cat, thus unless all ways to create provable timelocked encryptions are enumerable, it would be possible to get around.\n\n(though of course it is dependent on a ZKP being possible for a timelocked encryption)\n\nFinally, aggregation is still possible to insure by off-blockchain agreements, possibly with legal consequences, and thus entities like exchanges might still be able to aggregate funds and acquire an undeservedly large weight in the fidelity bond system.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-08T09:35:24",
                "message_text_only": "Good morning Dmitry, and list,\n\n> > > I wonder if there's a cryptographic way to prove that muSig and\n> > > 2P-ECDSA have not been used to create a certain pubkey/signature.\n> >\n> > In the second scheme, to revoke/spoil the bond, the entity that\n> > controls one TXO participating in this bond needs to simply prove that\n> > it somehow controls/have the ability to spend that TXO.\n> > In shared ownership rent scheme that ZmnSCPxj described in [1],\n> > the 'TXO rentier' has a signed timelocked 'backout' transaction that\n> > spends the locked TXO, and assigns the reward to rentier.\n> > If we say that any transaction that spends any TXO in the bond\n> > (ignoring the timelock), invalidates the bond when presented to\n> > takers, then TXO rentier can revoke the bond by simply\n> > publishing this transaction (not to the blockchain, but by some other\n> > means so that takers can receive it).\n> > The transaction validity can be verified, with the relaxed rules that\n> > ignores the timelock. After it is verified, takers mark the whole\n> > bond as revoked and will not consider it when chosing makers.\n> > One inconvenience here is that takers need to store the\n> > data about revoked bonds. But it seems to me that there's no need\n> > for that information to be synchronized between the participants\n> > instantly. It is enougth for takers to get the revoked-set eventually.\n> > The rentier are still incentivized to not spoil the bond, to receive\n> > the profit. Their funds are locked anyway.\n> > But if the goal of the 'rentier' is to attack the attacker, the\n> > opportunity cost of these locked funds is the cost of the attack.\n> > If the renter rents TXOs from several entities to include in one bond,\n> > revocation by one rentier spoils whole bond, and the total loss for all\n> > participants is bigger than the oportunity cost of locked funds of a\n> > single rentier that made the revocation.\n> > The possibility of such revocation increases risk for the renter and\n> > would-be co-rentiers, and is likely limit the possible scale of such\n> > TXO-renting operation.\n>\n> This is quite a clever solution.\n>\n> Let me then attempt to break it.\n>\n> It is possible to encrypt data in such a way that it requires sequential operations in order to decrypt.\n> https://www.gwern.net/Self-decrypting-files\n\nI apologize, I was being daft.\nThere is a simpler way to break this, involving such Lightning Network tropes as revocation and punishment schemes.\nTruly, Lightning Network is a great great thing.\n\nFirst, we should always consider, that due to the V^2, consolidated bonds are always higher weight than unconsolidated bonds.\nThus, even without considering motives to spy on CoinJoins, the existence of the V^2 tweak implies that there will be fewer larger makers and thus easier to take over the JoinMarket system.\n\nSo, let us focus on the backout transaction.\nUnder a consolidated bond, this requires an n-of-n.\n\nNow, suppose we want to identify the snitch who reports our consolidation scheme to the takers.\nThis can be done easily by performing n MuSig n-of-n rituals, with each ritual using different `r` nonces.\nWe arrange this by having each of the n consolidators be the last signers in the second round of the MuSig, and have each signer keep their own unique version of the signature for the backout, with their own unique `r` nonce.\n\nEach participant will want to keep its own version of the signature private, because if it gives out this signature to another participant in the consolidated bond scheme, the other participant can frame them for snitching.\n\nWe can now identify the snitch, by recognizing which signature was used in the transaction that was reported to the takers.\nBut we have not yet identified how we can punish the snitch.\n\nAs it happens, MuSig allows Scriptless Script.\nThis means, it is possible for one participant in the MuSig to provide an adaptor signature.\nThis adaptor signature commits to a particular point.\nWhen the MuSig is completed and the participant (who is the last signer in the second round of MuSig) reveals the completed signature, the scalar that generates the commited point can be computed by anyone who knows the adaptor signature.\n\nThis is our next step in our scheme to identify and punish snitches.\nIn addition to putting up their funds in a consolidated bond, each of the participants in the consolidation scheme put up a fraction of the value into revocable bonds.\n\nThis revocable bond is a Taproot with a known-NUMS point as internal Taproot key, and the script alternatives below:\n\n    <bond_time - 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <participant_key> OP_CHECKSIG\n\nand\n\n    <MuSig(all participants *except* this participant)> OP_CHECKSIGVERIFY <participant_snitch_key> OP_CHECKSIG\n\nA punishment transaction spends from the revocable bond via the second alternative above, and divides it equally among the *other* participants.\nTHis is signed using the MuSig above (where all participants except the owner of this revocable bond are part of).\n\nThen, before starting the n rituals to sign the backoff transaction, the participants provide adaptor signatures to their own `participant_snitch_key`, such that if they publish the backoff transaction to the takers, any of their co-participants that masquerades as a taker can find out about this and derive the private key to the `participant_snitch_key`.\n\nSo:\n\n1.  In case all the participants cooperate with the other consolidators, then just before the bond expires, each participant can recover their revocable bond via the first alternative shown above.\n    Once the revocable bond is spent back to an address they solely control, the `participant_snitch_key` is worthless.\n    Then any participant can publish onchain the backoff transaction without repercussion.\n2.  In case a participant snitches and reveals a pre-signed backoff to the takers before the end of the bond period, they can only reveal their own version of the signature of the backoff transaction.\n    In that case, their previously-shown adaptor signature can be used to reveal the private key behind their `participant_snitch_key`.\n    Then any one of the other participants in the consolidation scheme can complete the punishment transaction.\n\nWe can even ensure that setup of the whole system is atomic, by unironically CoinJoining the creation of the consolidated JoinMarket V^2 fidelity bond, in the same transaction that creates the revocable bonds that can be used to ensure that snitches are punishable.\n\nNow you might say, \"well now the bond they can put into the JoinMarket fidelity bond is smaller because of the need to put a revocable bond\".\nAnd that is right.\nIt also shows that the V^2 tweak is broken.\n\nSuppose there are two makers with 1.0 BTC each.\nThey decide to consolidate their bond in order to increase their consolidated weight in the JoinMarket fidelity bond system.\nThey decide to put up 0.25BTC each for the revocable bonds, and 0.75BTC each into the consolidated JoinMarket V^2 fidelity bond.\nThe total consolidated bond is 1.5BTC, which has a weight 2.25x the weight of one 1.0BTC bond, or 1.125x the weight of 2x 1.0BTC bonds.\nThus consolidation pressure still exists strongly (and I would think that losing as little as 5% of your total bondable funds would be enough to discourage snitches: this example is 25%).\n\nThe scheme would not be broken if there was no V^2 tweak, and would have worked perfectly to disable consolidation, if not for the V^2 tweak.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-08T11:37:50",
                "message_text_only": "\u0412 Thu, 08 Aug 2019 09:35:24 +0000\nZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> <MuSig(all participants *except* this participant)> OP_CHECKSIGVERIFY\n> <participant_snitch_key> OP_CHECKSIG\n\nThis anti-snitch protection won't work if there are two snitches, which\nis concievable in the case of a large-scale consolidated bonds (one\nentity can pretend to be two independent entities with two different\nTXO). The snitch co-conspirator will refuse to sign the punishment\ntransaction.\n\nIf you change the MuSig(all_except_snitch) to 1-of-n multisig\nconstruction so that anyone other than the actual 'snitch' can\nconfiscate the snitch-bond, then there's possibility that that a\nco-conspirator can get that bond before others - even before\nthe sntich transaction is distributed to takers.\n\nIt seems that to reasonably protect from more than one snitch with this\npunishment scheme, you want to make a multitude of taproot leaves where\neach leaf can be spent by cooperation of N entities, where N is the\nsize of expected non-snitch participant set.\n\n> Finally, aggregation is still possible to insure by off-blockchain\n> agreements, possibly with legal consequences, and thus entities like\n> exchanges might still be able to aggregate funds and acquire an\n> undeservedly large weight in the fidelity bond system.\n\nThis seems to me like the most immediate problem for the discussed\nsystem.\n\nSince the centralized exchanges or other custodial services already\ncontrol TXOs of their customers who sent their funds there, they can\nuse them to make extra profit with joinmarket, and create fidelity\nbonds out of these TXO with (or without) consent of the customers, and\npay them (or not) the amount according to their UTXO, while getting the\nconsolidation benefit of V^2 for themselves. It is also more probable\nthat such centralized custodial services would be willing to\nparticipate in a deanonymization efforts, so that they can explain\ntheir participation in coinjoins to regulators."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-08T13:59:13",
                "message_text_only": "Good morning Dmitry,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, August 8, 2019 7:37 PM, Dmitry Petukhov <dp at simplexum.com> wrote:\n\n> \u0412 Thu, 08 Aug 2019 09:35:24 +0000\n> ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n>\n> > <MuSig(all participants except this participant)> OP_CHECKSIGVERIFY\n> > <participant_snitch_key> OP_CHECKSIG\n>\n> This anti-snitch protection won't work if there are two snitches, which\n> is concievable in the case of a large-scale consolidated bonds (one\n> entity can pretend to be two independent entities with two different\n> TXO). The snitch co-conspirator will refuse to sign the punishment\n> transaction.\n>\n> If you change the MuSig(all_except_snitch) to 1-of-n multisig\n> construction so that anyone other than the actual 'snitch' can\n> confiscate the snitch-bond, then there's possibility that that a\n> co-conspirator can get that bond before others - even before\n> the sntich transaction is distributed to takers.\n\nThe correct way to do this, as with any offchain technique, is to have the punishment transactions signed by the MuSig-of-everyone-other-than-punishment-target before you even sign the funding transaction.\nIf consolidation is subsidized by paying rent out to the consolidators, then the lessee of the UTXOs adds its rent payment in the same transaction that atomically instantiates the fidelity bond and all revocable bonds as a single CoinJoined transaction.\nIf any participant refuses to sign the punishment transactions of their co-consolidators, then the lessee refuses to sign the funding transaction and nobody earns any rent and the lessee goes look for another set of UTXO owners (or just kicks out the participant who refuses to sign and lives with the smaller fidelity bond, no big deal).\n\nOf course, anyone renting consolidated bonds can themselves be unironic victims of sybil attackers who split up their funds to smaller parts so that their liability when later snitching is reduced, possibly to a level that is comfortable to them.\nThe sybil attacker then pretends to be lessors of UTXOs.\n\n>\n> It seems that to reasonably protect from more than one snitch with this\n> punishment scheme, you want to make a multitude of taproot leaves where\n> each leaf can be spent by cooperation of N entities, where N is the\n> size of expected non-snitch participant set.\n>\n> > Finally, aggregation is still possible to insure by off-blockchain\n> > agreements, possibly with legal consequences, and thus entities like\n> > exchanges might still be able to aggregate funds and acquire an\n> > undeservedly large weight in the fidelity bond system.\n>\n> This seems to me like the most immediate problem for the discussed\n> system.\n>\n> Since the centralized exchanges or other custodial services already\n> control TXOs of their customers who sent their funds there, they can\n> use them to make extra profit with joinmarket, and create fidelity\n> bonds out of these TXO with (or without) consent of the customers, and\n> pay them (or not) the amount according to their UTXO, while getting the\n> consolidation benefit of V^2 for themselves. It is also more probable\n> that such centralized custodial services would be willing to\n> participate in a deanonymization efforts, so that they can explain\n> their participation in coinjoins to regulators.\n\nYes, down with the V^2 superlinearity, it is too strongly centralizing.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Chris Belcher",
                "date": "2019-08-08T20:06:07",
                "message_text_only": "Hello list,\n\nTwo points:\n\n* The V^2 term is the only thing in the whole scheme that provides any\nsybil protection. I've already gone through the reasoning in an earlier\nemail and the maths is clear; in a scheme with linear V honest makers\nhave no economic advantage over sybil attackers. This is because only a\nsybil attacker needs to split up their money into multiple fidelity\nbonds, and that comes with a penalty under the V^2 rule.\n\nIt's worth reiterating that including a single evil maker in a\nJoinMarket coinjoin does not ruin it's privacy. Privacy is only ruined\nif *all* makers in a coinjoin are controlled by the same entity. So if\ntakers use one maker who has rented TXOs, then its no big deal as long\nas the other included makers are controlled by other people. Therefore\nwhen balancing the harms, consolidation into fewer makers is not as bad\nas having no sybil protection (which as a reminder means that *all*\nmakers are controlled by one entity), and so the V^2 term does more good\nthan harm.\n\nWe can't condemn the V^2 rule because of consolidation without\nacknowledging the good it does in penalizing sybil attacks.\n\n* Regarding entities like exchanges running makers. They can also do\nthis today with JoinMarket, the proposed fidelity bond scheme doesn't\nmake that worse. It's an underlying assumption of JoinMarket that\ncoinjoining power is proportional to bitcoin ownership (in a similar way\nthat an underlying assumption of bitcoin is that transaction\nconfirmation power is proportional to hashpower). If those big exchanges\nfind that coinjoins involving them included just one maker controlled by\nsomeone else then their aim of deanonymization will have failed. And\nthen those exchanges have to explain to their regulators why they helped\nhide the origin and destination of some black market money."
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-08-08T12:05:05",
                "message_text_only": "\u0412 Wed, 7 Aug 2019 20:10:17 +0500\nDmitry Petukhov via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrote:\n\n> In shared ownership rent scheme that ZmnSCPxj described in [1],\n> the 'TXO rentier' has a signed timelocked 'backout' transaction that\n> spends the locked TXO, and assigns the reward to rentier.\n> \n> If we say that any transaction that spends any TXO in the bond\n> (ignoring the timelock), invalidates the bond when presented to\n> takers, then TXO rentier can revoke the bond by simply\n> publishing this transaction (not to the blockchain, but by some other\n> means so that takers can receive it).\n> \n> The transaction validity can be verified, with the relaxed rules that\n> ignores the timelock. After it is verified, takers mark the whole\n> bond as revoked and will not consider it when chosing makers.\n\nThe backout transaction might not be timelocked itself, but can depend\non another timelocked transaction (made specifically to avoid the\nbackout transaction be timelocked). That extra transaction will need to\nbe broadcast before the backout transaction.\n\nTo account for that possibility, takers would need to either use more\nrelaxed verification rules (do not check if the inputs of the 'snitch\ntransaction' exist), or would need to check the whole package of\ndependent transactions in which the last one spends the bond."
            },
            {
                "author": "Chris Belcher",
                "date": "2019-08-07T09:38:43",
                "message_text_only": "On 07/08/2019 00:33, ZmnSCPxj wrote:\n> Good morning all,\n> \n> It might be useful to remember that there exists pressure to pool proof-of-work due to tiny non-linearities caused by Proximity Premium and Variance Discount flaws.\n> Similarly, any non-linearity in any fidelity bond scheme exerts the same pooling pressure.\n> Deliberately increasing the non-linearity to V^2 worsens the pooling pressure, not lessens it.\n> \n> (I wonder if instead going the opposite way and doing V^0.999 might work better; I have not figured all the implications of such a scheme and leave it to the reader.)\n> \n>> Unfortunately, both described schemes fail the same way as\n>> 'require TXOs to be consolidated by the owner', by the fact that with\n>> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in\n>> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban\n>> musig for the bonds' is not the answer, I believe.\n> \n> If my understanding is correct, efforts to expand ECDSA to more than two-party n-of-n \"true\" multisignatures already are ongoing.\n> \n> One might attempt to use transaction malleability as a protection, and require that transactions that put up bond TXOs should spend from at least one ***non***-SegWit output, so that the scheme as described fails (as the funding txid is malleable after-the-fact).\n> \n> But the scheme as described only considers ways to securely aggregate *within* the Bitcoin universe.\n> \n> I have recently learned of a spacce called the \"real world\", wherein apparently there exist things as \"contract law\".\n> It seems to me this \"contract law\" is a half-baked implementation of Bitcoin cryptographic smart contracts.\n> By what little I understand of this \"contract law\", it would be possible for an aggregator to accept some amount of money, with a promise to return that money in the future with some additional funds.\n> If the aggregator fails to uphold its promise, then some (admittedly centralized) authority entity within the \"real world\" then imposes punishments (apparently inspired by similar mechanisms in Lightning Network) on the aggregator.\n> Such arrangements (accepting some money now with a promise to return the money, plus some interest earned, in the future) apparently already exist in this \"real world\", under the name of \"time deposits\".\n> \n> \n> Regards,\n> ZmnSCPxj\n> \n\nGood morning all,\n\nCustodial solutions are much less worrying because they introduce so\nmuch counterparty risk.\n\nIt's more risky to give bitcoins in custody than for fiat money because\nthere's no lender of last resort. People using JoinMarket in a\nnon-custodial way will always have a larger risk-adjusted return; The\nreturn for running a JoinMarket yield generator isn't that big anyway to\nstart with. The non-custodial renting of TXO signatures is far more\nworrying.\n\nAlso, as described in my other email\n(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017218.html\nstarting \"\nLet's say the sybil attacker...\") the superlinear V^2 term is essential\nto the resistance of the fidelity bond system to sybil attacks. All\nthings considered the consolidation of makers due to renting TXOs is not\nas bad as sybil attacks. Consolidation of makers means that the\nprivacy-relevant information is shared amongst fewer people than\notherwise, but at least those people are independent (otherwise they'd\nmerge together). In a sybil attack the privacy-relevant information is\nnot shared at all, but entirely known by just one person which is much\nworse.\n\nCB"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-07T11:20:38",
                "message_text_only": "Good morning Chris,\n\n> Also, as described in my other email\n> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017218.html\n> starting \"\n> Let's say the sybil attacker...\") the superlinear V^2 term is essential\n> to the resistance of the fidelity bond system to sybil attacks.\n\nAt the cost of *greatly* strengthening aggregation.\n\nSuppose there is currently many makers, all with roughly-equal bonds.\nSuppose I were to approach two of these makers, and offer to aggregate their bonds.\nThe combined bond would, because of the V^2 term, have 4 times the weight of the other makers.\nThus, approximately I can earn a little below 4 times what one other maker does.\nI offer 1.5x what one maker does to both of those makers and keep a little below 0.5x to myself.\nSo:\n\n1.  I earn without putting any of my money into bonds.\n    I just need starting capital to pre-pay for the rents.\n2.  I get to learn a little below 4x more CoinJoins than other makers.\n    This increases my earnings further since I can sell this privacy information, and I also get an advantage compared to other non-aggregating spies.\n\nIt seems to me not to fix the root issue, i.e. makers who make for the purpose of gathering privacy information, even if it might fix sybil attackers.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Improving JoinMarket's resistance to sybil attacks using fidelity bonds",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "ZmnSCPxj",
                "Leo Wandersleb",
                "Dmitry Petukhov",
                "Adam Gibson"
            ],
            "messages_count": 21,
            "total_messages_chars_count": 77334
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-dev Digest, Vol 51, Issue 3",
        "thread_messages": [
            {
                "author": "Steven Blinn",
                "date": "2019-08-02T16:44:01",
                "message_text_only": "Emil,\n\nRe: [Meta] bitcoin-dev moderation (Emil Engler)\n\nSince my coding skills are in the infancy stage and I can't contribute much\nin that area, at least not yet, I'm looking for other ways to get involved\nand moderating the mailing list sounds like an ideal situation.  If you\nneed help in this area I'm more than happy to volunteer and pick up the\nslack.\n\nSteven\n\nOn Fri, Aug 2, 2019 at 8:50 AM <\nbitcoin-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send bitcoin-dev mailing list submissions to\n>         bitcoin-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n>         bitcoin-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         bitcoin-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. [Meta] bitcoin-dev moderation (Emil Engler)\n>    2. Re: Improving JoinMarket's resistance to sybil attacks using\n>       fidelity bonds (Chris Belcher)\n>    3. Re: Proposed Extensions to BIP 174 for Future Extensibility\n>       (Dmitry Petukhov)\n>    4. Re: [Meta] bitcoin-dev moderation (Bryan Bishop)\n>    5. Re: Add a moving checkpoint to the Bitcoin protocol\n>       (Ethan Heilman)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Thu, 1 Aug 2019 21:47:40 +0200\n> From: Emil Engler <me at emilengler.com>\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: [bitcoin-dev] [Meta] bitcoin-dev moderation\n> Message-ID: <53b75074-59ff-9890-419d-d5e6fcb44a7c at emilengler.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> In the last #bitcoin-core-dev IRC meeting, the mailing list moderation\n> was slightly discussed. It was decided to do this discussion mainly on\n> this mailing list (which makes sense).\n>\n> The current situation is that the moderation is slow and takes around\n> >24h for a E-Mail to be on the mailing list.\n>\n> Jonas Schnelli proposed: \"I propose that we add more moderators to\n> shorten the moderation lag which has been between >24h, thus makes\n> debates cumbersome\"\n>\n> Beside this I had the idea of people who already contributed n e-mails\n> to the mailing list don't need an approval for any e-mail anymore (Where\n> n is the number of previous e-mails). Does this exists already?\n>\n> Greetings,\n> Emil Engler\n> -------------- next part --------------\n> A non-text attachment was scrubbed...\n> Name: pEpkey.asc\n> Type: application/pgp-keys\n> Size: 3147 bytes\n> Desc: not available\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/a78795b7/attachment-0001.bin\n> >\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Fri, 2 Aug 2019 10:21:57 +0100\n> From: Chris Belcher <belcher at riseup.net>\n> To: Dmitry Petukhov <dp at simplexum.com>,\n>         bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] Improving JoinMarket's resistance to sybil\n>         attacks using fidelity bonds\n> Message-ID: <ae32dcbb-c950-3b3f-22b9-d152d6b221cb at riseup.net>\n> Content-Type: text/plain; charset=utf-8\n>\n> On 31/07/2019 16:50, Dmitry Petukhov wrote:\n> > ? Tue, 30 Jul 2019 22:39:14 +0100\n> > Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> > wrote:\n> >\n> >> This is where a sacrifice of V bitcoins creates a\n> >> bond of value V^2. The formula provides a strong incentive for\n> >> profit-motivated makers to use all their fidelity bond coins with just\n> >> one maker, not spread them out over many makers.\n> >\n> > The attacker derives additional value from the use of\n> > locked utxo - the deanonimyzation capabilities.\n> >\n> > An entity M can use all of its locked coins to run a maker, and then\n> > earn value X. It will also incur some operational expenses in the course\n> > of running the maker, so the profit will be less than X.\n> >\n> > If these locked coins are given to the attacker A as a package, an\n> > attacker can derive a value of X+D where D is a value of increased\n> > deanonymization capabilities for an attacker. Operational expenses\n> > for an attacker are the same as before (without timelocked bonds),\n> > because they need to operate a lot of makers either way.\n> >\n> > If M is profit-driven and non-ideological, it can rent out all of its\n> > coins to A as a package, for the price X, and get the same value without\n> > running a maker and dedicating any resources and time to it, not\n> > incurring any operatinal expenses (thus having a bigger profit in the\n> > end).\n> >\n> > Attacker A will run a maker with M's coins, get profit X, pay X to M,\n> > get increased deanonymization capabilities.\n> >\n> > If renting out of utxo is done in a way that the owner always gets X\n> > after the lock expires, the operation will be riskless for the owner.\n> > The attacker will need to lock amount X along with owner's coins, but\n> > hopefully makes X back by running a maker operation.\n> >\n> > The price for renting out the coins will be determined on the size of\n> > the 'coin package', so it will not be feasible for the owners of the\n> > coins to rent them out separately.\n> >\n> > An attacker can even rent coins from several entities and combine them\n> > to create a more 'powerful' maker. If I understand correctly, such\n> > 'powerful' maker can have bigger profit than two less 'powerful'\n> > makers. It seems like a centralization risk to me.\n> >\n>\n> There's a few different issues here.\n>\n> Yes TXO fidelity bonds can be rented out, but that doesn't make a sybil\n> attack cheaper. The aim of the fidelity bond scheme is to require makers\n> to sacrifice value, renting out their fidelity bond coins doesn't avoid\n> that sacrifice because the sacrifice is the paid rent. Because of the\n> maths and market forces the rent paid by the attacker should be about\n> the same as the cost of just buying the bitcoins and locking them.\n>\n> Centralization and decentralization are not ends in themselves, the main\n> aim in JoinMarket is to improve privacy while keeping the other\n> properties of bitcoin (e.g. censorship resistance). A single maker can\n> never deanonoymize coinjoins no matter how valuable their bond is,\n> because takers always choose multiple makers, and all of them need to be\n> controlled by the sybil attacker for the attack to succeed. If a sybil\n> attacker splits up their fidelity bonds (rented or not) amongst multiple\n> maker bots then they reduce the value of their bonds because of the V^2\n> term.\n>\n> Rented TXOs does destroy the effect of \"A long-term holder probably\n> won't want to attack a system like JoinMarket which makes his own\n> investment coins more private and more fungible\". However this is not\n> the main effect which would protect JoinMarket's privacy. The main\n> effect is the cost which for real-life numbers would be about 45-120\n> bitcoin sent to burner outputs.\n>\n> Perhaps then rented TXOs is an argument against using coin age as a way\n> to create fidelity bonds. Hodlers would be far less likely to rent out\n> their coins if they have to specifically move them to a special\n> time-locked address. Another point is that for privacy reasons creators\n> of fidelity bonds should mix their coins before and after using them,\n> because those TXOs are revealed to the world. So it's likely that\n> fidelity bonds creators will need to install and run JoinMarket anyway.\n>\n>\n>\n> ------------------------------\n>\n> Message: 3\n> Date: Fri, 2 Aug 2019 14:18:36 +0500\n> From: Dmitry Petukhov <dp at simplexum.com>\n> To: Andrew Chow <achow101-lists at achow101.com>\n> Cc: bitcoin-dev at lists.linuxfoundation.org\n> Subject: Re: [bitcoin-dev] Proposed Extensions to BIP 174 for Future\n>         Extensibility\n> Message-ID: <20190802141836.15771ad6 at simplexum.com>\n> Content-Type: text/plain; charset=UTF-8\n>\n> ? Thu, 01 Aug 2019 19:01:06 +0000\n> Andrew Chow <achow101-lists at achow101.com> wrote:\n>\n> > I spoke to some people OOB and they said that they didn't really like\n> > the idea of having a prefix string (partially because they've already\n> > implemented some proprietary types by simply squatting on unused\n> > types). Matching the prefix string adds additional complexity to the\n> > parser code.\n>\n> I do not oppose the idea of \"{0xFC}|{private_type}\" strongly, but I\n> would like to note that for those who do not want to deal with\n> additional complexity of handling a prefixed string, they can simply\n> not use it at all. Since this is a private construction, and their\n> private format specifies 'no prefix', they can just ignore everything\n> that does not start with \"{0xFC}|{0x00}\", thus any further complexity\n> regarding the prefix is also ignored. The only added complexity is one\n> condition check: second_byte_of_the_key != 0\n>\n> My other argument for conflict-avoidance prefix as a first thing after\n> 0xFC is that the set of future users of PSBT and private types is\n> most likely much larger than the current set of those who already\n> implemented proprietary types on their own, and thus the overall benefit\n> for the whole industry will likely be bigger when 'i do not want\n> conflict avoidance' decision have to be explicit, by setting the prefix\n> to 0x00, and the set of possible conflicting types are limited only to\n> those entities that made this explicit decision.\n>\n> Regarding the 'squatted' types, it seems to me that this only matters\n> in the discussed context if they squatted on 0xFC type in particular.\n> In other cases, they will need to implement changes anyway, to be\n> compatible with the BIP. Maybe they could consider that one additional\n> condition check is a small burden, and maybe they can tolerate that,\n> for the benefit of reducing possibility of interoperability problems\n> between other future PSBT/private types implementors.\n>\n>\n>\n> ------------------------------\n>\n> Message: 4\n> Date: Fri, 2 Aug 2019 06:43:27 -0500\n> From: Bryan Bishop <kanzure at gmail.com>\n> To: Emil Engler <me at emilengler.com>,    Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>,        Bryan Bishop\n>         <kanzure at gmail.com>\n> Subject: Re: [bitcoin-dev] [Meta] bitcoin-dev moderation\n> Message-ID:\n>         <CABaSBay1w6ncJX2wVKWotp-FkzkDH4Nkve=\n> QBz90S1G_-SzpZA at mail.gmail.com>\n> Content-Type: text/plain; charset=\"UTF-8\"\n>\n> On Thu, Aug 1, 2019 at 10:50 PM Emil Engler via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > The current situation is that the moderation is slow and takes around\n> > >24h for a E-Mail to be on the mailing list\n>\n> It really shouldn't be 24 hours. Our strategy was to have a few\n> moderators in different timezones to cover sleep shifts or other\n> disruptions of service. Evidently this has not been adequate.\n>\n> > Jonas Schnelli proposed: \"I propose that we add more moderators to\n> > shorten the moderation lag which has been between >24h, thus makes\n> > debates cumbersome\"\n>\n> Makes sense. I'll go find a few people.\n>\n> > Beside this I had the idea of people who already contributed n e-mails\n> > to the mailing list don't need an approval for any e-mail anymore (Where\n> > n is the number of previous e-mails). Does this exists already?\n>\n> There is an active software vulnerability which requires moderation to\n> be enabled. This version of mailman is unmaintained, and Linux\n> Foundation is migrating away from or abandoning the email protocol so\n> they are less willing to do backend infrastructure work. This\n> manifests in other ways, like downtime, but also weird situations like\n> missing emails that never hit the moderation queue. I get pings from\n> different people about two times a year where they report an email\n> that they think I missed, but in fact it never hit the moderation\n> queue at all. Email clearly isn't the greatest protocol.\n>\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507\n>\n>\n> ------------------------------\n>\n> Message: 5\n> Date: Fri, 2 Aug 2019 08:19:03 -0400\n> From: Ethan Heilman <eth3rs at gmail.com>\n> To: \"Kenshiro []\" <tensiam at hotmail.com>,        Bitcoin Dev\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin\n>         protocol\n> Message-ID:\n>         <CAEM=\n> y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Attack 1:\n> I partition (i.e. eclipse) a bunch of nodes from the network this partition\n> contains no mining power . I then mine 145 blocks for this partition. I\n> don't even need 51% of the mining power because I'm not competing with any\n> other miners. Under this rule this partition will hardfork from the network\n> permanently. Under current rules this partition will be able to rejoin the\n> network as the least weight chain will be orphaned.\n>\n> Attack 2:\n> I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I\n> feed it 145 blocks which fork off from the consensus chain. I have 24+24\n> hours to mine these 145 blocks so I should be able to do this with 25% of\n> the current hash rate at the time the node went offline. Under your rule\n> each of these offline-->online nodes I attack this way will hardfork\n> themselves from the rest of the network.\n>\n> I believe a moving-checkpoint rule as describe above would make Bitcoin\n> more vulnerable to 51% attacks.\n>\n> A safer rule would be if a node detects a fork with both sides of the split\n> having  length > 144 blocks, it halts and requests user intervention to\n> determine which chain to follow.  I don't think 144 blocks is a great\n> number to use here as 24 hours is very short. I suspect you could improve\n> the security of the rule by making the number of blocks a fork most reach\n> to halt the network proportional to the difference in time between the\n> timestamp in the block prior to the fork and the current time. I am **NOT**\n> proposing Bitcoin adopt such a rule.\n>\n> NXT has a fundamentally different security model as it uses Proof-of-stake\n> rather than Proof-of-Work.\n>\n> On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > P.S.: To be clearer, in this example I set an N value of 144 blocks,\n> which\n> > is approximately 24 hours.\n> >\n> > ------------------------------\n> > *From:* Kenshiro [] <tensiam at hotmail.com>\n> > *Sent:* Wednesday, July 31, 2019 16:40\n> > *To:* Alistair Mann <al at pectw.net>; Bitcoin Protocol Discussion <\n> > bitcoin-dev at lists.linuxfoundation.org>\n> > *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin\n> > protocol\n> >\n> > >>> How would a (potentially, state-sponsored) netsplit lasting longer\n> > than N be\n> > handled?\n> >\n> > It would be detected by the community much before reaching the reorg\n> limit\n> > of N blocks (it's 24 hours) so nodes could stop until the netsplit is\n> > fixed.\n> >\n> > In the extreme case no one notice the network split during more than N\n> > blocks (24 hours) and there are 2 permanent forks longer than N, nodes\n> > from one branch could delete their local history so they would join the\n> > other branch.\n> >\n> > Regards,\n> >\n> >\n> > ------------------------------\n> > *From:* Alistair Mann <al at pectw.net>\n> > *Sent:* Wednesday, July 31, 2019 15:59\n> > *To:* Kenshiro [] <tensiam at hotmail.com>; Bitcoin Protocol Discussion <\n> > bitcoin-dev at lists.linuxfoundation.org>\n> > *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin\n> > protocol\n> >\n> > On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:\n> >\n> > > I would like to propose that a \"moving checkpoint\" is added to the\n> > Bitcoin\n> > > protocol. It's a very simple rule already implemented in NXT coin:\n> > >\n> > > - A node will ignore any new block under nodeBlockHeight - N, so the\n> > > blockchain becomes truly immutable after N blocks, even during a 51%\n> > attack\n> > > which thanks to the moving checkpoint can't rewrite history older than\n> > the\n> > > last N blocks.\n> >\n> > How would a (potentially, state-sponsored) netsplit lasting longer than N\n> > be\n> > handled?\n> > --\n> > Alistair Mann\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/9071fcc3/attachment.html\n> >\n>\n> ------------------------------\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> End of bitcoin-dev Digest, Vol 51, Issue 3\n> ******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/97a230b4/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-dev Digest, Vol 51, Issue 3",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Steven Blinn"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 17164
        }
    },
    {
        "title": "[bitcoin-dev] CoinVault - Secure Cryptocurrency Exchange - Technology Overview",
        "thread_messages": [
            {
                "author": "Praveen Baratam",
                "date": "2019-08-05T15:36:49",
                "message_text_only": "Hello Devs,\n\nI am Praveen and I am the inventor of CoinVault, a new second layer\nprotocol and technology that makes Bitcoin and other similar altcoins\n`Unstealable\nand Unlosable` for all practical purposes. Tall claim, but I will get to\nthe details in a bit.\n\nBefore that, here is a little context to set the perspective\u2026\n\nI was introduced to Bitcoin by a friend in 2017 and realized how late I was\nto the party.\n\nBitcoin Cash's block size debate was a hot topic then and so were many\nhacks and heists affecting various cryptocurrency exchanges across the\nworld.\n\nI personally did not like the idea of increasing block size to accommodate\nmore transactions and also thought that Cold Storage and Multi-Sig security\nfor Hot Wallets (BitGo) is just the beginning.\n\nWe thought micro and high frequency transactions should ideally be handled\nby intermediaries who settle balances periodically, while larger\ntransactions and settlements happen directly on Blockchain. Even if\nLightning Network handles all micro-transactions, we cannot completely rule\nout all intermediaries and we still need exchanges, etc. to interface with\nthe offline world. This felt like a healthy compromise while preserving the\nspirit of Bitcoin.\n\nBut given the security requirements and concerns surrounding Bitcoin and\nother cryptocurrencies, any kind of pooling in the hands of any\nintermediary such as an exchange, wallet, escrow, etc., makes it a hot\ntarget for hackers.\n\nTo mitigate this problem, me and my fellow compatriots set out to create a\nsafer way to store cryptocurrencies both for individuals and enterprises.\n\nAfter nearly two years of brainstorming and toiling we have come up with\nCoinVault, a second layer technology, that can ensure the safety and\nsecurity of Bitcoin and other cryptocurrencies for both large and small\nentities.\n\nBelow is an overview of CoinVault technology specifically adopted to secure\nCryptocurrency Exchanges and Wallets. Please find the figures referred to\nin the below text in the PDF attached. The complete draft is also attached\nas a PDF if you prefer printing and reading it. A video overview\n<https://www.youtube.com/watch?v=yDvLqTv1FDg> is also attached for those\nwho prefer a video over text.\n\nAny and every feedback will help us iterate and serve the ecosystem better.\nWe are all ears for your comments and suggestions.\n\n\n\n-----------------~~~~~~~~~~~~~~~-----------------\n\n\nSecure Cryptocurrency Exchange & Wallet\n\nDr. Praveen Baratam\n\nBackground:\n\nCryptocurrencies in general are both acquired and traded on an electronic\nexchange that lists different cryptocurrencies/crypto-assets often with\nother assets such as fiat currencies issued by central banks of various\ncountries and enables trading between them. Most of these exchanges are\ncustodial in nature and act as trusted third parties where trading parties\ntransfer both cryptocurrencies and other assets in their control/possession\nto the exchange controlled addresses/accounts and get notional limits on\nthe exchange to trade. All this works well as long as there is no security\nbreach on the exchange.\n\nSince most cryptocurrencies are secured by public-key encryption which is\nknowledge based, any security breach on the exchange\u2019s systems can be\ndisastrous. And any adversary gaining access to exchange\u2019s private-keys can\nirreversibly steal the cryptocurrencies in its custody leading to huge loss\nof wealth for trading parties and loss of trust within the ecosystem. We\nhave seen this scenario playout with many cryptocurrency exchanges all over\nthe world at some point or the other and approximately 15 Billion USD worth\ncryptocurrencies were stolen from them as of Dec 2017. This has become the\nAchilles heel of the cryptocurrency world off late.\n\nOver time cryptocurrency exchanges have evolved several strategies such as\nHot-Wallets coupled with Cold/Offline Storage, Multi-Signature arrangements\nwith third-parties that serve as gatekeepers to enforce limits on\ntransactions, insurance for hot funds, etc. But most of these strategies\nhave proved inadequate and/or were circumvented over the past few years by\nincreasingly sophisticated attacks. eg: BitFinex lost $71 Million USD worth\nof Bitcoin in spite of Multi-Signature arrangements with BitGo.\n\nThe same is true for Custodial Cryptocurrency Wallet Services, hereafter\nreferred to as Cryptocurrency Wallets, that store users\u2019 funds/tokens with\nthem and allow their users to make transactions like a bank. They then\nsettle these transactions on their users\u2019 behalf. Most Cryptocurrency\nExchanges also double up as Cryptocurrency Wallets for their users allowing\ntransacting parties to pay/accept in cryptocurrencies/assets of their\nchoice and managing the conversion for them when necessary.\n\nThere is an urgent need for securing cryptocurrency exchanges and wallets\nto prevent further losses and bolster general faith in the cryptocurrency\necosystem.\n\nSolution:\n\nThe following describes an arrangement and method, in its simplest form,\nbetween two parties (First Party and Second Party where the Second Party is\nacting as Secure Cryptocurrency Exchange and/or Wallet for the First Party)\nparticipating in a cryptocurrency network/system to effectively reduce the\nprobability of loss or theft of the First Party\u2019s funds/tokens while\nguaranteeing settlement between trading/transacting parties by the Second\nParty. Hereafter, the term Cryptocurrency Exchange, shall also imply\nCryptocurrency Wallet wherever relevant.\n\nThe method presumes that unrecoverable hardware wallets (or rendered\nunrecoverable by not-recording / discarding the backup/seed) without any\nprovision for recovery of the private-keys/secrets stored inside it in case\nof loss or malfunction of the device, hereafter referred to as hardware\ntokens, and time-locks for transaction outputs are available for the\ncrypto-currency system of interest. Relative time-locks\n(CheckSequenceVerify) similar to the one described in Bitcoin Improvement\nProposal 112 are more desirable than absolute time-locks\n(CheckLockTimeVerify) similar to the one described in Bitcoin Improvement\nProposal 65. The subsequent discussion assumes relative time-locks are\navailable for the cryptocurrency of interest even though similar\nfunctionality can be devised using absolute time-locks too.\n\nThe method and arrangement proceeds as follows:\n\n\n   1.\n\n   At inception, the First Party creates a transaction similar to the one\n   depicted in Figure 1, hereafter called the Deposit Transaction, in which\n   the First Party transfers an arbitrary sum of funds/tokens in its control\n   to a multi-signature address but does not yet sign or broadcast it. The\n   multi-signature address in the Deposit Transaction requires the following\n   signatures to authenticate and spend/transfer from it:\n\n   1.\n\n      First Party\u2019s Private Key generated Signature\n      2.\n\n      First Party\u2019s Hardware Token generated Signature\n      3.\n\n      Second Party\u2019s Private Key generated Signature\n\n      2.\n\n   Then, the First Party creates a second transaction, hereafter referred\n   to as Provisional Transaction, as depicted in Figure 2, spending all the\n   funds/tokens sent to the multi-signature address in the Deposit\n   Transaction, and sends a copy of the Provisional Transaction without any\n   signed inputs or signatures, to the Second Party. Please note that the\n   Provisional transaction is spending from an unconfirmed Deposit Transaction.\n\n   3.\n\n   Then, the Second Party adds its  Private Key generated signature to the\n   unsigned Provisional Transaction received from the First Party and then\n   sends the partially signed Provisional Transaction back to the First Party.\n\n   4.\n\n   In the meantime, the First Party also adds its Private Key generated\n   signature and the signature generated by the hardware token in its\n   possession to the unsigned copy of the Provisional Transaction it created\n   and sends the partially signed Provisional Transaction to the Second Party.\n\n   Note: The signatures used in this scheme sign the transaction similar to\n   SIGHASH_ALL or SIGHASH_SINGLE in BitCoin protocol where the corresponding\n   output of the transaction cannot be modified once signed.\n\n   5.\n\n   At this point in time, the First Party is in possession of the partially\n   signed Provisional Transaction with Second Party\u2019s Private Key generated\n   signature added to it and the Second Party is in possession of the\n   partially signed Provisional Transaction with First Party\u2019s Private Key\n   generated signature and the signature generated by the hardware token in\n   First Party\u2019s possession added to it.\n\n   6.\n\n   Then, the First Party signs and broadcasts the Deposit Transaction it\n   created to the cryptocurrency network/system completing the setup process.\n   The whole process in outlined in Figure 3.\n\n   7.\n\n   Once the Deposit Transaction is confirmed, both First Party and Second\n   Party start monitoring the Cryptocurrency network directly and/or using\n   third party services for transactions referencing the Multi-Signature\n   output address described above from the Deposit Transaction to detect any\n   breach of security or foul play.\n\n   8.\n\n   Subsequently, the First Party, at its discretion, can add its Private\n   Key generated signature and the signature generated by the hardware token\n   in its possession to the partially signed Provisional Transaction with the\n   Second Party\u2019s Private Key generated signature and broadcast the fully\n   signed Provisional Transaction to the cryptocurrency network/system when\n   necessary.\n\n   9.\n\n   Similarly, the Second Party can add its Private Key generated signature\n   to the partially signed Provisional Transaction with the First Party\u2019s\n   Private Key generated signature and the signature generated by the hardware\n   token in possession of the First Party and broadcast the fully signed\n   Provisional Transaction to the cryptocurrency network/system when necessary.\n\n   10.\n\n   To sum it up, either parties can add missing signatures to the partially\n   signed Provisional Transaction in their possession and broadcast them when\n   necessary.\n\n   11.\n\n   As soon as the Provisional Transaction is broadcasted, the\n   cryptocurrency monitoring systems prompt both parties to initiate recovery\n   if it is not broadcasted by them to begin with. Either ways First Party or\n   the Second Party in coordination with the other or optionally unilaterally\n   create and broadcast a transaction using the respective options of the\n   Provisional Transaction transferring the funds/tokens to a desired address\n   terminating the arrangement.\n\n\nDescription\n\nCryptocurrency Exchanges act as custodial escrow agents for the trading\nentities participating on their platforms to minimize counter party risk\nand guarantee settlement. However, this escrow mechanism, with respect to\ncryptocurrencies, creates a new problem of keeping third party funds/tokens\nin their custody safe and secure. A security breach on the respective\nCryptocurrency Exchanges\u2019 systems can compromise the private-keys securing\nthe funds in its custody and lead to loss/theft of respective funds/tokens.\n\nIn the proposed scheme/arrangement a Cryptocurrency Exchange can enforce\nsettlement albeit with a predefined delay and does not need exclusive\ncustody of the said funds/tokens beforehand to guarantee settlement.\nMoreover, in the event of a security breach on one or both sides, there are\nremedial steps that the Cryptocurrency Exchange and/or First Party can take\nto prevent loss or theft of respective funds/tokens.\n\nGenerally, First Party will cooperate with Second Party in the settlement\nprocess and in situations where it disagrees or refuses to cooperate, the\nCryptocurrency Exchange (Second Party) can get exclusive custody of the\nrespective funds/tokens and enforce settlements as per the terms of the\ncontractual service agreement with the First Party.\n\nFor instance, when the First Party is in disagreement with a proposed\nsettlement for a trade, the Cryptocurrency Exchange (Second Party) can use\nthe Option 2 as depicted in Figure 2 and take exclusive custody of the\nrespective funds/tokens to enforce settlement. This option allows the\nCryptocurrency Exchange to function as a regular custodial escrow between\ntrading parties as is the case with most exchanges and in general.\n\nIn another instance, if a Cryptocurrency Exchange suffers a security breach\nand its private-keys are compromised/stolen, it can use Option 1, 2, 3, 7\nor 8 depicted in Figure 2 to transfer the funds/tokens to another secure\naddress or back to the First Party as may be desired. Cryptocurrency\nExchanges can even prevent loss/theft using Option 7 depicted in Figure 2\nand transfer the respective funds/tokens away from the compromised address\neven when its hardware tokens are lost/stolen in the above described\nsituation.\n\nAlso, the Cryptocurrency Exchange (Second Party) can use Option 2 depicted\nin Figure 2 and transfer the respective funds/tokens to a secure address\nwhen First Party\u2019s private-key and/or hardware token are\ncompromised/lost/stolen.\n\nThe Confusion Matrix in Figure 4 enumerates the options available and\noutcomes of situations where private-keys and/or hardware tokens of First\nParty and/or Second Party are compromised or stolen. It also enumerates\nsituations where respective private-keys are lost by First Party but not\nSecond Party.\n\nSince Second Party is an organized entity that can employ data-safety\nmeasures such as multi-site replication, offline storage, etc. this method\ndoes not explicitly specify the process and enumerate options available\nwhen Second Party\u2019s private-keys are lost for simplicity and brevity. This\nmethod can be analogously extended to this scenario and more or simplified\nif desired by reordering,adding or removing options in the Provisional\nTransaction accordingly when planning and accounting for certain\ncontingencies are deemed necessary or unnecessary. Also the timelocks\nmentioned in the Provisional Transaction are one of the many possible\nvalues for them exemplifying a particular order and can be adjusted as\nnecessary to suit a particular arrangement.\n\nIt should be noted here that the Second Party always gets first claim on\nthe respective funds/tokens as it is accepting a liability on First Party\u2019s\nbehalf and can steal First Party\u2019s funds/tokens but will not do so because\nsuch unilateral actions will result in loss of trust/business from other\nparties as well as legal proceedings by the First Party. Hence, the\nincentive and motive to cheat the First Party of its funds/tokens by Second\nParty is non-existent. But if First Party and/or Second Party are\ncompromised either by an internal or external adversary, they still have\nrecourse and can reconcile the situation by taking remedial steps available.\n\nFinally, even if Hardware Tokens are not available and we have to rely on\nrelative/absolute timelocks only, the method and scheme described above can\nbe scaled down as depicted in Figure 5 and still offer better protection\nthan currently practiced multi-signature arrangements.\n\n\nhttps://www.youtube.com/watch?v=yDvLqTv1FDg\n\n\n\u1427\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Figures - CoinVault - Secure Cryptocurrency Exchange.pdf\nType: application/pdf\nSize: 915042 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0002.pdf>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: CoinVault - Secure Cryptocurrency Exchange.pdf\nType: application/pdf\nSize: 985589 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0003.pdf>"
            }
        ],
        "thread_summary": {
            "title": "CoinVault - Secure Cryptocurrency Exchange - Technology Overview",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Praveen Baratam"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 15933
        }
    },
    {
        "title": "[bitcoin-dev] testing bitcoin nodes",
        "thread_messages": [
            {
                "author": "Niels Thijssen",
                "date": "2019-08-06T10:36:18",
                "message_text_only": "Hi,\n\nI'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).\nI've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.\nIs there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.\nI'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.\n\nWho would be able to join me or share information that guides me.\nThanks in advance,\n\nNiels.\n\n\n\n-------- Disclaimer --------\nThis email and any files transmitted may contain proprietary and confidential information of Improve Quality Services B.V. (\u2018Improve QS\u2019) and is intended only for the (use of the) named recipient(s) above. If you have received this message in error or are not the intended or named recipient(s) of this message, please immediately notify the sender by return and delete this email message from your computer. Any views or opinions presented are solely those of its author and do not necessarily represent those of Improve QS. You are hereby notified that unauthorized disclosure, use, dissemination, forwarding, printing or copying of this e-mail and its attachments either whole or partial of its contents is strictly prohibited. Improve QS cannot guarantee that email communications are secured and error-free and does not accept any liability for damages resulting from the use of email. The general terms and conditions of purchase respectively sale and delivery of Improve QS are applicable to all transactions and undertakings resulting therefrom."
            },
            {
                "author": "Niels Thijssen",
                "date": "2019-08-21T12:35:45",
                "message_text_only": "As no one was able to respond, a gentle reminder : \ud83d\ude0a\n\nHi,\n\nI'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).\nI've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.\nIs there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.\nI'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.\n\nWho would be able to join me or share information that guides me.\nThanks in advance,\n\nNiels.\n\n\n\n-------- Disclaimer --------\nThis email and any files transmitted may contain proprietary and confidential information of Improve Quality Services B.V. (\u2018Improve QS\u2019) and is intended only for the (use of the) named recipient(s) above. If you have received this message in error or are not the intended or named recipient(s) of this message, please immediately notify the sender by return and delete this email message from your computer. Any views or opinions presented are solely those of its author and do not necessarily represent those of Improve QS. You are hereby notified that unauthorized disclosure, use, dissemination, forwarding, printing or copying of this e-mail and its attachments either whole or partial of its contents is strictly prohibited. Improve QS cannot guarantee that email communications are secured and error-free and does not accept any liability for damages resulting from the use of email. The general terms and conditions of purchase respectively sale and delivery of Improve QS are applicable to all transactions and undertakings resulting therefrom."
            },
            {
                "author": "Alexander Leishman",
                "date": "2019-08-21T17:33:28",
                "message_text_only": "Hey Niels,\n\n\nI'm no expert on bitcoind tests, but maybe these bits of information can\nhelp you get started:\n\n\nThe steps to build bitcoind typically involve running:\n\n\n./autogen.sh\n\n./configure\n\nmake\n\nmake install\n\n\nWhen you run autogen, the autoreconf\n<https://www.gnu.org/software/autoconf/manual/autoconf-2.68/html_node/autoreconf-Invocation.html>\ntool\nis invoked which creates the configure script that gets run next. The\nconfigure script is generated based on the configure.ac\n<https://github.com/bitcoin/bitcoin/blob/master/configure.ac> file, which\nperforms a number of compatibility checks for the compiler and other\ntooling. You can see these checks being performed with\nthe AX_CHECK_COMPILE_FLAG calls.\n\n\nMy understanding is that running configure does a lot of system\ncompatibility checks. When you run \"make\", I do not think any tests get run\nby default, but I could be wrong about this. If you want to run unit tests\nyou need to run \"make check\". You can read more about this here\n<https://github.com/bitcoin/bitcoin/blob/master/src/test/README.md>\n\n\nThere are unit tests for bitcoind written in C++ and a lot of integration\nand higher level tests written in python.\n\n\nHopefully this information was useful and accurate. Again, I could be wrong\nabout exactly how the build process works as it's not super obvious.\nHopefully someone else more knowledgeable than me can chime in here if I\ngot anything wrong.\n\n\nBest,\n\nAlex\n\n\n\nOn Wed, Aug 21, 2019 at 10:06 AM Niels Thijssen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> As no one was able to respond, a gentle reminder : \ud83d\ude0a\n>\n> Hi,\n>\n> I'm working as (software) test specialist and run private a full bitcoin\n> node (based upon Raspberry Pi 4).\n> I've been trying to figure out the tests performed during\n> installation/upgrade/compilation of the software for the node.\n> Is there any overview on what's the (common) test approach, or other\n> stuff. Because the tests on GitHub don't help me that much.\n> I'd like to figure out what/how is tested, maybe refine test cases, and\n> try some manual test also, as part of learning.\n>\n> Who would be able to join me or share information that guides me.\n> Thanks in advance,\n>\n> Niels.\n>\n>\n>\n> -------- Disclaimer --------\n> This email and any files transmitted may contain proprietary and\n> confidential information of Improve Quality Services B.V. (\u2018Improve QS\u2019)\n> and is intended only for the (use of the) named recipient(s) above. If you\n> have received this message in error or are not the intended or named\n> recipient(s) of this message, please immediately notify the sender by\n> return and delete this email message from your computer. Any views or\n> opinions presented are solely those of its author and do not necessarily\n> represent those of Improve QS. You are hereby notified that unauthorized\n> disclosure, use, dissemination, forwarding, printing or copying of this\n> e-mail and its attachments either whole or partial of its contents is\n> strictly prohibited. Improve QS cannot guarantee that email communications\n> are secured and error-free and does not accept any liability for damages\n> resulting from the use of email. The general terms and conditions of\n> purchase respectively sale and delivery of Improve QS are applicable to all\n> transactions and undertakings resulting therefrom.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190821/2d435f7f/attachment-0001.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-08-21T18:33:03",
                "message_text_only": "On Tue, 6 Aug 2019 at 09:57, Niels Thijssen via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi,\n>\n> I'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).\n> I've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.\n> Is there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.\n> I'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.\n\nHi Niels,\n\nYou're probably not getting many answers because this isn't the right\nplace to ask. The mailinglist is about development of the Bitcoin\nprotocol and conventions about its usage across multiple applications.\nIf you want to learn about the Bitcoin Core software and its testing\ninfrastructure, see https://bitcoincore.org/en/contribute/\n\nCheers,\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "testing bitcoin nodes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Niels Thijssen",
                "Pieter Wuille",
                "Alexander Leishman"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 8059
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Discover and move your coins by yourself",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2019-08-07T10:54:10",
                "message_text_only": "FYI Phase 3 is released https://github.com/Ayms/bitcoin-transactions,\nfeatures:\n\n- create transactions\n\n- decode transactions\n\n- verify transactions\n\n- convert/map addresses (including bech32)\n\n- create/map wallets (bip32,39,44, etc), wallets recovery (missing/wrong\nwords) and check\n\n- decode/create multisig redeem scripts\n\n- pubkey/privkey mapping , conversion and formats\n\n- sign/verify messages\n\nBrowserifying everything now for the end of the month\n\n\n\n-------- Message transf\u00e9r\u00e9 --------\nSujet\u00a0: \tDiscover and move your coins by yourself\nDate\u00a0: \tFri, 12 Jul 2019 20:35:00 +0200\nDe\u00a0: \tAymeric Vitte <vitteaymeric at gmail.com>\nPour\u00a0: \tBitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n\n\n\n\nPlease see https://github.com/Ayms/bitcoin-transactions this is a merge\nof former bitcoin-transactions and bitcoin-wallets nodejs modules with\nadditional features to be implemented as described in the README\n\nIt is financed by NLnet via EU Horizon 2020 Next Generation Internet\nSearch and Discovery call\n\nSo the initial dev fees have been removed and the code is now open\nsource and provided in clear under a MIT license\n\nThe intent is to provide all the necessary tools for anybody to discover\nand manage their coins, as well as making transactions by themselves,\nwithout having to sync a full node or as an alternative to wallets when\npeople don't understand where their coins are (we saw quite a lot of\nconfusion for people not understanding at all how to find their coins\nand to what keys their addresses did relate in case of multisig, segwit\nand now bech32)\n\nIt's somewhere bitcoin-cli outside of bitcoin core more easy to use and\nnot restricted to its own wallet, available for any bitcoin based coins\n\nAt the end it will be a secure standalone offline js webapp inside\nbrowsers (like https://peersm.com/wallet but the app does not reflect\nthe current state of the nodejs repo)\n\nIt's not a remake of iancoleman's tool but of course some features\noverlap, as well as for other existing tools, we will also extend all of\nthis inside one tool with no limitations (for example some tools do not\naccept \"invalid\" bip39 seeds, or bip32 seeds, etc)\n\nComments/suggestions welcome\n\nPS: initially sent to bitcoin-discuss but the list seems to be dead\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/57f7489c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Discover and move your coins by yourself",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Aymeric Vitte"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3089
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback mechanisms",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2019-08-07T13:48:06",
                "message_text_only": "Hi,\n\nI have a proposal for implementing bitcoin vaults in a way that does not\nrequire any soft-forks or other software upgrades, although it could benefit\nfrom SIGHASH_NOINPUT which I'll describe later.\n\nI call them pre-signed vaults.\n\nVault definition\n================\n\nHere, a vault is defined as a transaction setup scheme that binds both the user\nand the attacker to always using a public observation and delay period before a\nweakly-secured hot key is allowed to arbitrarily spend coins. This is the same\ndefinition previously used[1]. During the delay period, there is an opportunity\nto initiate recovery/clawback which can either trigger deeper cold storage\nparameters or at least reset the delay period to start over again for the same\nkeys.\n\nOne of the important components of this is the delete-the-key pre-signed\ntransaction concept, where only a single transaction is (pre)signed before\ndeleting the key. This is basically an emulation of a covenant and enforces a\ncertain outcome.\n\nBackground and motivation\n=========================\n\nI was looking at Eyal and Sirer's 2016 vaults paper [1], and I saw this\nheadscratcher:\n\n> Vault transactions use a delay mechanism. We note that vault transactions\n> cannot be implemented with existing timing mechanisms such as\n> CHECKLOCKTIMEVERIFY opcode or transaction locktime.\n\nThis was probably written before the introduction of OP_CHECKSEQUENCEVERIFY.\nStill, a viable construction would have more steps than just using OP_CSV. They\nwere probably not thinking about what those steps might be, because in the\ncontext of the paper they were proposing a bitcoin vault implemented using\nrecursive consensus-enforced covenants via a new opcode, which obviously cannot\nbe deployed without an upgrade fork. Covenants have been discussed for years,\nbut require new opcodes or other consensus-enforcement changes.\n\nRelative locktimes are useful here because there is no knowledge as to when the\ntransactions might be broadcasted in the future. The delays need to be relative\nto after the transaction is included in the blockchain, not to setup\ninitialization time.\n\nAlso, from [2]:\n\n> We show that a [vault transaction] mechanism is currently not possible in all\n> cryptocurrencies [...] Bitcoin's scripting language requires support for\n> covenants.\n\nI haven't seen any previous proposal for how to implement recursive bitcoin\nvaults without a fork and without a covenant. After asking around, I am pretty\nsure this is somewhat novel. The closest I guess is [3].\n\nVaults are particularly interesting as a bitcoin cold storage security\nmechanism because they enable a publicly observable delay period during which\ntime a user could be alerted by a watchtower that a thief might be in the\nprocess of stealing their coins, and then the user may take some actions to\nplace the coins back into the vault before the relative timelock expires. There\nseems to be no way to get this notification or observation period without a\nvault construction. It might have been assumed it required a covenant.\n\nHaving a vault construction might go a long way to discourage would-be\nattackers, on principle that the attacker might be incapable of recovering\ntheir cost-of-attack because the recovery mechanism can lock up the coins\nindefinitely. Griefing or denial-of-service would still be possible, of course,\nbut with multisig there might be some ways to put a halt to that as well. I am\nworking under the assumption that the attacker knows that the user is a vault\nuser.\n\nVaults\n======\n\nThe idea is to have a sequence of pre-generated pre-signed transactions that\nare generated in a certain way. The basic components are a vaulting transaction\nthat locks coins into a vault, a delayed-spend transaction which is the only\nway to spend from a vault, and a re-vaulting transaction which can\nrecover/clawback coins from the delayed-spend transaction. The security of this\nscheme is enforced by pre-signing transactions and deleting private keys, or\nwith the help of SIGHASH_NOINPUT then there's another scheme where private keys\nare provably never known. This enforces that there's only a specific set of\npossible outcomes at every step of the vault.\n\nSome examples of what the set of broadcasted transactions might look like in\nregular usage:\n\n    coins -> VT -> DST -> exit via hot wallet key\n    coins -> VT -> DST -> RVT\n    coins -> VT -> DST -> RVT -> DST -> ...\n    coins -> VT -> ... -> RVT998 -> nuclear abort\n\nwhere:\n    VT = vault transaction\n    DST = delayed-spend transaction\n    RVT = re-vaulting transaction\n\nThe delayed-spending transaction would have a single output with a script like:\n(\n    30 days AND hot wallet key\n OR 10 days AND re-vaulting public key\n OR 1 day AND 4-of-7 multisig\n OR 0 days and super-secure nuclear abort ragequit key\n)\n\nAnother diagram:\n\n    VT_100 -> DST -> (optionally) RVT -> coins are now in VT_99\n    VT_99 -> DST -> (optionally) RVT -> coins are now in VT_98\n    ...\n    VT_1 -> burn-all-coins nuclear abort ragequit (final)\n\nDefinitions\n===========\n\nTransactions and components:\n\n* Commitment/funding vault setup transaction. Signed after setting up the\ntransaction tree, and it is broadcasted whenever funds are to be placed into\nthe vault.\n\n* Delayed-spend transaction. Signed during the vault transaction tree setup,\nand it is broadcasted when the user wants to withdraw coins from cold storage\nor otherwise manipulate the coins. The output script template used by the\ndelayed-spend transaction was defined earlier.\n\n* Hot wallet key: Somewhat insecure key. This can also be multisig using\nmultiple hot keys.\n\n* Re-vaulting key: It is important to note that the private key either never\nexisted (SIGHASH_NOINPUT + P2WPK for the re-vaulting transaction) or the\nprivate key was deleted after pre-signing the re-vaulting transaction.\n\n* 4-of-7 multisig: This is a group of differently-motivated individuals who are\nresponsible for signing transactions. This multisig group is not necessry to\ndescribe the technique, I just think it's a useful feature for a vault to\ninclude.\n\n* Nuclear abort key: Also unnecessary. This is a key for which only a single\nsigned transaction will ever exist, and that single transaction will spend to a\nproof-of-burn key like 0x00. This key must be extremely secure, and if there\nis any doubt about the ability to keep such a key secured, then it is better to\nnot include this in the protocol. Alternatively, maybe include it as an option\n50 layers down in the revaulting sequence.\n\n* Nuclear-abort pre-signed transaction. This is signed during transaction tree\nsetup, before constructing the delayed-spend transaction. It is broadcasted\nonly if the user wants to provably relinquish coins forever without giving the\nattacker any coins.\n\n* Re-vaulting transaction. This is where the magic happens. The re-vaulting\ntransaction is signed during transaction tree setup, before constructing the\ndelayed-spend transaction for the parent vault. The re-vaulting transaction is\nbroadcasted when someone wants to prevent a coin withdrawal during the public\nobservation delay period. The re-vaulting transaction spends the delayed-spend\ntransaction outputs. It has a single output with a script created by running\nthe entire vault setup function again. Hence, when the re-vaulting transaction\nis confirmed, all of the coins go back into a new identically-configured vault\ninstead of being relinquished through the delayed-spend transaction timeout for\nhot wallet key signing.\n\n* Special case: final transaction. This is the very first pre-signed\ntransaction during setup, and the transaction spends the coins using any\nprovable burn technique. This is broadcasted only at the end of the game, as an\nultimate abort and forfeiture of coins without giving in to an adversary. It's\nsimilar to the nuclear-abort ragequit transaction but it sits at the same place\nthat a delayed-spend transaction would, at the very end of the rainbow or\nyellow brick road.\n\nExample log during vault setup\n==============================\n\nWhen running the recursive vault setup function, the created artifacts (in\norder) will look like:\n\n1) choose one of:\n   (first iteration) pre-signed burn-all-coins nuclear abort ragequit (final)\n   (all others) a new vault setup transaction spendable only by its\n                delayed-spend transaction\n\n2) pre-signed re-vaulting transaction sending to vault setup or final\ntransaction, with a unique private key\n\n3) pre-signed delayed-spend transaction, with a unique private key\n\n4) vault transaction spendable only by the delayed-spend public key\n\nPseudocode\n==========\n\nIn pseudocode (where PTX is a pre-signed transaction function with\nprivate key deletion):\n\n    VT(counter, *args, **kwargs) =\n        if counter == 0:\n            DST = PTX(\"burn-all-coins\")\n        else:\n            next_vault = VT(counter-1, *args, **kwargs)\n            revaulting = PTX(\"only spendable by next_vault public key\")\n            DST = PTX(\"DST policy including revaulting and other conditions\")\n        vault = PTX(\"spendable only by this DST\")\n        return vault\n\nPre-signed transactions\n=======================\n\nWhat has been known for a while is that a covenant can be somewhat emulated\nusing a pre-signed transaction where the user then deletes the private key,\nenforcing that the user's chosen policy must be enforced since there is only\none existing option and there will only ever be one option.\n\nSuch a scheme has been previously described for simple one-time and chained\nvaults [3]. I have learned that the author has an implementation that is in\npreparation, for a non-recursive version.\n\nNote that a series of pre-signed transactions can be considered to be an\nemulation of a covenant. Imagine a linear chain of pre-signed transactions\nwhere each hop has a relative locktime before being able to broadcast the next\ntransaction. To recover the coins at the end of the rainbow, one would need to\nbroadcast each sequential transaction in order and wait for the relative\ntimelocks to expire each time. Here, covenants provide something like an undo\nfor bitcoin, but only between pre-determined addresses and scripts.\n\nFees for pre-signed transactions\n================================\n\nThere's a few different techniques to talk about:\n\n1) SIGHASH_SINGLE|SIGHASH_ANYONECANPAY to let someone add inputs and outputs.\nThis can get pretty complex though.\n\n2) Add a zero-value OP_TRUE output and let anyone spend the zero-value output\nand attach a child-pays-for-parent (CPFP) transaction to pay for everything.\n\n3) Pre-sign a variety of different possible fee rates. Unfortunately this\ninvolves an explosive blow-up in the amount of transaction data to generate. It\nmight actually be a reasonable blow-up amount, only resulting in a few hundred\nmegabytes of additional data. But given the other options, this is unnecessary.\n\nDelete the key (for pre-signed transactions)\n============================================\n\nThe delete-the-key trick is simple. The idea is to pre-sign at least one\ntransaction and then delete the private key, thus locking in that course of\naction.\n\nUnfortunately, delete-the-key doesn't really work for multisig scenarios\nbecause nobody would trust that anyone else in the scheme has actually deleted\nthe secret. If they haven't deleted the secret, then they have full unilateral\ncontrol to sign anything in that branch of the transaction tree. The only time\nthat delete-the-key might be appropriate would be where the user who deletes\nthe key and controls the key during the setup process is also the sole\nbeneficiary of the entire setup with the multisig participants.\n\nAlternative fee rates are easier to deal with using delete-the-key, compared to\na technique where the private key never existed which can only be used to sign\none fee rate per public key, requiring an entirely new vault subtree for each\nalternative fee rate. With delete-the-key, the alternative fee rates are signed\nwith the private key before the private key is deleted.\n\nMultisig gated by ECDSA pubkey recovery for provably-unknown keys\n=================================================================\n\nA group can participate in a multisig scheme with provably-unknown ECDSA keys.\nInstead of deleting the key, the idea is to agree on a blockheight and then\nselect the blockhash (or some function of the chosen blockhash like\nH(H(H(blockhash)))) as the signature. Next, the group agrees on a transaction\nand they recover the public key from the signature using ECDSA pubkey recovery.\nA pre-signed transaction is created, which will trigger the start of the public\nobservation period described earlier and also start the clock for the bip112\nrelative timelock on its output. In the output script, an OR branch\nis added that enables the use of a re-vaulting key which could also be its own\nseparate multisig construction.\n\nThis is incompatible with P2WPKH because the P2WPKH spending scriptSig needs to\nhave the pubkey (to check the hash of the pubkey against the pubkeyhash in the\nscriptPubKey), which in turn makes it incompatible with ECDSA pubkey recovery\nwhich requires a hash of the message. However, with P2WPK and SIGHASH_NOINPUT\ninstead of P2WPKH it could conceivably work. SIGHASH_NOINPUT is required because\notherwise the input includes a txid which references the public key. With P2WPK,\nthe scriptSig only needs a signature and not a public key. Note that what would\nbe required is a version of SIGHASH_NOINPUT that does not commit to the public\nkey, and I think a few of the NOINPUT proposals are committing to the public\nkey.\n\nAlternatively, there may be some constructions using the 2-party ECDSA\ntechniques or m-n party ECDSA techniques.\n\nDeploying exceedingly large scripts\n===================================\n\nA brief interlude to share a somewhat obvious construction. I haven't seen this\nwritten down yet.\n\nSuppose there is a bitcoin script that someone is interested in using, but it\nfar exceeds the size limits and sigop limits. To fix this, they would split up\nthe script into usable chunks, and then use the delete-the-key mechanism (or\nthe other one) to create an OR branch that is signable by a single key for\nwhich only a single signature is known. That new pre-signed transaction would\nspend to a script that has the output with the remainder of the script of\ninterest. Re-vaulting or clawback clauses can be added to that output as well,\nbut spending back to the original root script will only work by generating new\nscripts and keys (since the final hash isn't known until the whole tree is\nconstructed, it's a dependency loop).\n\nRecursively-enforced multi-party multisig bitcoin vaults\n========================================================\n\nIdeally, to enforce a covenant with impossible fairy dust magic, we would ask\nfor a bitcoin transaction that could be self-referential because the\nonly-one-signature-ever trick requires that the signed message be known before\nproducing the signature, and the signature has to be known before the public\nkey can be known, and the public key would have to be included in the\nself-referential message/transaction hash value. So, that's a dependency loop\nand it doesn't work. It would be interesting to explore a variation of this\nidea with masking, such that a value X can be replaced by a hash over the whole\nscript with the X value, even though the real script will have the hash.\nSomeone else can figure that one out for me :-).\n\nInstead of the self-referential values attempting to reference the same\nscript that is in the process of being constructed, an alternative is to use\nthe same script template but populate it with different parameters. The script\ntemplate gets reused over and over again, all the way down the tree, until the\nfinal transaction which could be >100 years into the future once done adding up\nall the relative locktimes. In fact, to create and populate this terrifying\nrecursive script tree, the final transaction needs to be created first, and\nthen it is given as input to the script template function and that output is\nthen given to the script template function itself-- and so on. At each stage,\nthere are additional pre-signed transactions and values to remember.\n\nThis can be written as:\n\n    final_transaction = TX(spend to 0x0000 to burn the coins)\n    initial_transaction = F(F(...F(final_transaction))\n\n    (This is missing parameters to indicate to the function what the spending\n    keys requirements are to be.)\n\nSee earlier explanation for more details.\n\nEach call to the template populating function produces values that each must be\npreserved for a very long time. It is less safe to store all of the pre-signed\ntransactions together at the same time, but more convenient. With less\nredundancy, there is an increased chance of losing data over time, which could\nrender the coins completely frozen. This doesn't particularly worry me because\nforgetting a key has that property already, and this could be likened to\nhundreds of megabytes of extra key data or something. Unlike the much smaller\ncovenant-based (opcode-based covenant) vault construction, the multiple layers\nhere can be separately stored and protected, which might be able to protect\nagainst an adversary that has stolen some of the re-vaulting keys but not all\nof them.\n\nOptimizations can be made to store parameters for generating the remainder of\nthe tree, such as using deterministic key derivation, such that megabytes of\ndata wouldn't need to be long-term stored. Only the initial parameters would\nneed to be stored.\n\nFinancial privacy for custody\n=============================\n\nOne of the concerns raised in [2] is that if all coins at an exchange are\nstored together in the same vault, then attackers would be able to learn about\naccess control policies by observing scripts and keys. Some privacy can be\nrecovered by using segregated vaults, at the cost of additional setup\ncomplexity and keeping more data in long-term storage.\n\nHowever, note that I think vaults are also useful for personal cold storage\nsolutions.\n\nFail-deadly mechanism\n=====================\n\nAn early nuclear abort option can be added to these scripts. This idea was\nexplored in [2]. This would be a very cold very secret key that would abort the\nre-vaulting procedure and send all coins to a (provably) nonsense key. This\nallows a vault user to destroy the coins instead of continuously monitoring the\nbitcoin blockchain for the rest of his life. The attacker can't recover their\ncost of attack if they never get the coins, and this eliminates an entire class\nof potential attackers who are directly interested only in financial gain. The\ndisadvantage is that if the attacker finds the secret key for the fail-deadly\nmechanism and uses it, then all of the coins are gone forever.\n\nMultisig variations\n===================\n\nThe re-vaulting key could be the same key at each layer, or only sometimes the\nsame key, or always a unique key stored separately in another secure location.\n\nAdditionally, these re-vaulting keys could be subjected to multisig schemes, as\nwell as Shamir secret sharing schemes or other secret sharing schemes.\n\nThe idea of adding the 4-of-7 multisig component is to avoid griefing\nsituations, at the cost of the additional security requirements for the 4-of-7\nmultisig group.\n\nKey rotation for vaults\n=======================\n\nKeeping the same hot wallet key for 100 years is not advisable. Rotate the keys\nby setting up a new vault construction and initiating a withdrawal transaction\nfrom the old vault to the new vault.\n\nSingle-use seals\n================\n\nThis proposal may have inadvertedly demonstrated a practical way to implement\nPeter Todd's single-use seals concept [4]. I am hesitant to say so, though,\nbecause I think he would ask for a more sophisticated way to verify seal\nclosure.\n\nPaid defection\n==============\n\nIt might be advisable to add small rewards for evidence of defection amongst\nmultiparty multisig setups. Besides amounts spendable by individual keys from a\nmultisig setup, it may be possible to use a zero-knowledge contingent payment\nfor a zero-knowledge statement like: I have a signature s over some message m\nwhich validates for pubkey pk where pk is a member of the multisig group. Then\nthe zkcp transaction would pay for knowledge of defectors. The zkcp procedure\nwould require interaction with the defector, while the direct pubkey method\nwould not. This is similar to companies paying employees to quit when they\nvalue the payment over the value of continued employment.\n\nHandling change\n===============\n\nIt is important to note that this vault setup is one-time and once-only. There\nmust only ever be one deposit into one vault. Also, spending some coins would\nrequire sending the change amount back into a new vault.  Alternatively,\nupfront work can be done to set a regular withdrawal stipend or assumption\nabout how many coins are left, such that the transaction tree can be\npre-generated for those possibilities, hence cutting down on future vault\nreinitializations. It would also be possible to commit upfront to only ever\nworking in some minimum increment number of bitcoin or something.\n\nIt is very important to only fund the vault once, and only with the amount that\nwas configured when setting up the vault.\n\nReferences\n==========\n\n[1] https://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n\n[2] http://www0.cs.ucl.ac.uk/staff/P.McCorry/preventing-cryptocurrency-exchange.pdf\n\n[3] http://web.archive.org/web/20180503151920/https://blog.sldx.com/re-imagining-cold-storage-with-timelocks-1f293bfe421f?gi=da99a4a00f67\n\n[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015350.html\nor https://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/single-use-seals/\nor https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n\nAcknowledgements\n================\n\n* Jeremy Rubin for pointing out something embarrassingly broken in an earlier\ndraft.\n\n* Bob McElrath for telling me to use SIGHASH_NOINPUT which I proceeded to\npromptly forget about.\n\n* Andrew Poelstra for the OP_TRUE trick.\n\n* Joe Rayhawk for paid defection.\n\n* Tadge Dryja for pointing out a few differences between SIGHASH_NOINPUT\nproposals.\n\n\n\nThank you,\n\n- Bryan\nhttp://heybryan.org/"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-08-07T20:32:47",
                "message_text_only": "Hi,\n\nOne of the biggest problems with the vault scheme (besides all of the\nsetup data that has to be stored for a long time) is an attacker that\nsilently steals the hot wallet private key and waits for the vault's\nowner to make a delayed-spend transaction to initiate a withdrawal\nfrom the vault. If the user was unaware of the theft of the key, then\nthe attacker could steal the funds after the delay period.\n\nTo mitigate this, it is important to choose a stipend or withdrawal\namount per withdrawal period like x% of the funds. This limits the\ntotal stolen funds to x% because once the funds are stolen the user\nwould know their hot key is compromised, and the user would know to\ninstead use one of the other clawback paths during all of the future\nwithdrawal delay periods instead of letting the delay timeout all the\nway to the (stolen) default/hot key.\n\nThe reason why a loss limiter is the way to go is because there's\ncurrently no way (that I am aware of, without an upgrade) to force an\nattacker to reveal his key on the blockchain while also forcing the\nattacker to use a timelock before the key can spend the coins. I am\ncurious about what the smallest least invasive soft-fork would be for\nenabling this kind of timelock. There are so many covenant proposals\nat this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,\n....). Or there's crazy things like a fork that enables a transaction\nmode where the (timelock...) script of the first output is\nautomatically prefixed to any of the other scripts on any of the other\noutputs when an input tries to spend in the future. A thief could add\nhis key to a new output on the transaction and try to spend (just like\na user would with a fresh/rotated key), but the OP_CSV would be\nautomatically added to his script to implement the public observation\ndelay window.\n\nAlso, there was other previous work that I was only informed about\ntoday after posting my proposal, so I should mention these as related\nwork:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html\nhttps://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better\nhttps://www.youtube.com/watch?v=diNxp3ZTquo\nhttps://bitcointalk.org/index.php?topic=5111656\n\n- Bryan\nhttp://heybryan.org/"
            },
            {
                "author": "Dustin Dettmer",
                "date": "2019-08-07T21:19:05",
                "message_text_only": "Does revaulting vault up with the same keys, or new ones?\n\nAre they new derivation paths on the same key?\n\nWould love some expanded explanation on how you\u2019re proposing this would\nwork.\n\nThanks,\nDustin\n\nOn Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> One of the biggest problems with the vault scheme (besides all of the\n> setup data that has to be stored for a long time) is an attacker that\n> silently steals the hot wallet private key and waits for the vault's\n> owner to make a delayed-spend transaction to initiate a withdrawal\n> from the vault. If the user was unaware of the theft of the key, then\n> the attacker could steal the funds after the delay period.\n>\n> To mitigate this, it is important to choose a stipend or withdrawal\n> amount per withdrawal period like x% of the funds. This limits the\n> total stolen funds to x% because once the funds are stolen the user\n> would know their hot key is compromised, and the user would know to\n> instead use one of the other clawback paths during all of the future\n> withdrawal delay periods instead of letting the delay timeout all the\n> way to the (stolen) default/hot key.\n>\n> The reason why a loss limiter is the way to go is because there's\n> currently no way (that I am aware of, without an upgrade) to force an\n> attacker to reveal his key on the blockchain while also forcing the\n> attacker to use a timelock before the key can spend the coins. I am\n> curious about what the smallest least invasive soft-fork would be for\n> enabling this kind of timelock. There are so many covenant proposals\n> at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,\n> ....). Or there's crazy things like a fork that enables a transaction\n> mode where the (timelock...) script of the first output is\n> automatically prefixed to any of the other scripts on any of the other\n> outputs when an input tries to spend in the future. A thief could add\n> his key to a new output on the transaction and try to spend (just like\n> a user would with a fresh/rotated key), but the OP_CSV would be\n> automatically added to his script to implement the public observation\n> delay window.\n>\n> Also, there was other previous work that I was only informed about\n> today after posting my proposal, so I should mention these as related\n> work:\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html\n>\n> https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better\n> https://www.youtube.com/watch?v=diNxp3ZTquo\n> https://bitcointalk.org/index.php?topic=5111656\n>\n> - Bryan\n> http://heybryan.org/\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/eb1c27d9/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2019-08-08T02:09:20",
                "message_text_only": "Seems to be comparable to the proposed \"Tick Method\" from 2013:\nhttps://bitcointalk.org/index.php?topic=307211.msg3308565#msg3308565\n\nHowever I remember that someone told me the tick method had a flaw..\n\n\n\nOn Wed, Aug 7, 2019 at 6:28 PM Dustin Dettmer via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Does revaulting vault up with the same keys, or new ones?\n>\n> Are they new derivation paths on the same key?\n>\n> Would love some expanded explanation on how you\u2019re proposing this would\n> work.\n>\n> Thanks,\n> Dustin\n>\n> On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi,\n>>\n>> One of the biggest problems with the vault scheme (besides all of the\n>> setup data that has to be stored for a long time) is an attacker that\n>> silently steals the hot wallet private key and waits for the vault's\n>> owner to make a delayed-spend transaction to initiate a withdrawal\n>> from the vault. If the user was unaware of the theft of the key, then\n>> the attacker could steal the funds after the delay period.\n>>\n>> To mitigate this, it is important to choose a stipend or withdrawal\n>> amount per withdrawal period like x% of the funds. This limits the\n>> total stolen funds to x% because once the funds are stolen the user\n>> would know their hot key is compromised, and the user would know to\n>> instead use one of the other clawback paths during all of the future\n>> withdrawal delay periods instead of letting the delay timeout all the\n>> way to the (stolen) default/hot key.\n>>\n>> The reason why a loss limiter is the way to go is because there's\n>> currently no way (that I am aware of, without an upgrade) to force an\n>> attacker to reveal his key on the blockchain while also forcing the\n>> attacker to use a timelock before the key can spend the coins. I am\n>> curious about what the smallest least invasive soft-fork would be for\n>> enabling this kind of timelock. There are so many covenant proposals\n>> at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,\n>> ....). Or there's crazy things like a fork that enables a transaction\n>> mode where the (timelock...) script of the first output is\n>> automatically prefixed to any of the other scripts on any of the other\n>> outputs when an input tries to spend in the future. A thief could add\n>> his key to a new output on the transaction and try to spend (just like\n>> a user would with a fresh/rotated key), but the OP_CSV would be\n>> automatically added to his script to implement the public observation\n>> delay window.\n>>\n>> Also, there was other previous work that I was only informed about\n>> today after posting my proposal, so I should mention these as related\n>> work:\n>>\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html\n>>\n>> https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better\n>> https://www.youtube.com/watch?v=diNxp3ZTquo\n>> https://bitcointalk.org/index.php?topic=5111656\n>>\n>> - Bryan\n>> http://heybryan.org/\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/881ebc3d/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-08T03:03:04",
                "message_text_only": "Good morning Sergio,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, August 8, 2019 10:09 AM, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Seems to be comparable to the proposed \"Tick Method\" from 2013:\n> https://bitcointalk.org/index.php?topic=307211.msg3308565#msg3308565\u00a0\n>\n> However I remember that someone told me the tick method had a flaw..\n\n\nMaybe the use of `SIGHASH_NONE` for both inputs of the TxOut transactions?\nAlso txid malleability.\n\nThe first can be fixed by not using `SIGHASH_NONE` for one of the inputs and requiring a hot privkey to sign with that.\nThe second can be fixed by using SegWit outputs.\n\nRegards,\nZmnSCPxj\n\n> \u00a0\n>\n> On Wed, Aug 7, 2019 at 6:28 PM Dustin Dettmer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Does revaulting vault up with the same keys, or new ones?\n> >\n> > Are they new derivation paths on the same key?\n> >\n> > Would love some expanded explanation on how you\u2019re proposing this would work.\n> >\n> > Thanks,\n> > Dustin\n> >\n> > On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > Hi,\n> > >\n> > > One of the biggest problems with the vault scheme (besides all of the\n> > > setup data that has to be stored for a long time) is an attacker that\n> > > silently steals the hot wallet private key and waits for the vault's\n> > > owner to make a delayed-spend transaction to initiate a withdrawal\n> > > from the vault. If the user was unaware of the theft of the key, then\n> > > the attacker could steal the funds after the delay period.\n> > >\n> > > To mitigate this, it is important to choose a stipend or withdrawal\n> > > amount per withdrawal period like x% of the funds. This limits the\n> > > total stolen funds to x% because once the funds are stolen the user\n> > > would know their hot key is compromised, and the user would know to\n> > > instead use one of the other clawback paths during all of the future\n> > > withdrawal delay periods instead of letting the delay timeout all the\n> > > way to the (stolen) default/hot key.\n> > >\n> > > The reason why a loss limiter is the way to go is because there's\n> > > currently no way (that I am aware of, without an upgrade) to force an\n> > > attacker to reveal his key on the blockchain while also forcing the\n> > > attacker to use a timelock before the key can spend the coins. I am\n> > > curious about what the smallest least invasive soft-fork would be for\n> > > enabling this kind of timelock. There are so many covenant proposals\n> > > at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,\n> > > ....). Or there's crazy things like a fork that enables a transaction\n> > > mode where the (timelock...) script of the first output is\n> > > automatically prefixed to any of the other scripts on any of the other\n> > > outputs when an input tries to spend in the future. A thief could add\n> > > his key to a new output on the transaction and try to spend (just like\n> > > a user would with a fresh/rotated key), but the OP_CSV would be\n> > > automatically added to his script to implement the public observation\n> > > delay window.\n> > >\n> > > Also, there was other previous work that I was only informed about\n> > > today after posting my proposal, so I should mention these as related\n> > > work:\n> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html\n> > > https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better\n> > > https://www.youtube.com/watch?v=diNxp3ZTquo\n> > > https://bitcointalk.org/index.php?topic=5111656\n> > >\n> > > - Bryan\n> > > http://heybryan.org/\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-08T00:27:32",
                "message_text_only": "Good morning Bryan,\n\n> -   Re-vaulting transaction. This is where the magic happens. The re-vaulting\n>     transaction is signed during transaction tree setup, before constructing the\n>     delayed-spend transaction for the parent vault. The re-vaulting transaction is\n>     broadcasted when someone wants to prevent a coin withdrawal during the public\n>     observation delay period. The re-vaulting transaction spends the delayed-spend\n>     transaction outputs. It has a single output with a script created by running\n>     the entire vault setup function again. Hence, when the re-vaulting transaction\n>     is confirmed, all of the coins go back into a new identically-configured vault\n>     instead of being relinquished through the delayed-spend transaction timeout for\n>     hot wallet key signing.\n\nAs transactions need to be signed in reverse order, it seems to me that there is a practical limit in the number of times a vault can be used.\nBasically, the number of times we run the vault setup function is the limit on number of re-vaultings possible.\n\nIs my understanding correct?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-08-08T01:16:42",
                "message_text_only": "Replying to two emails below.\n\nOn Wed, Aug 7, 2019 at 7:27 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> > -   Re-vaulting transaction. This is where the magic happens. The\n> re-vaulting\n> >     transaction is signed during transaction tree setup, before\n> constructing the\n> >     delayed-spend transaction for the parent vault. The re-vaulting\n> transaction is\n> >     broadcasted when someone wants to prevent a coin withdrawal during\n> the public\n> >     observation delay period. The re-vaulting transaction spends the\n> delayed-spend\n> >     transaction outputs. It has a single output with a script created by\n> running\n> >     the entire vault setup function again. Hence, when the re-vaulting\n> transaction\n> >     is confirmed, all of the coins go back into a new\n> identically-configured vault\n> >     instead of being relinquished through the delayed-spend transaction\n> timeout for\n> >     hot wallet key signing.\n>\n> As transactions need to be signed in reverse order, it seems to me that\n> there is a practical limit in the number of times a vault can be used.\n> Basically, the number of times we run the vault setup function is the\n> limit on number of re-vaultings possible.\n>\n> Is my understanding correct?\n>\n\nYes, that is correct. When setting up the vault, plan it \"all the way to\nthe end\" like next 100+ years. With exponential backoff on the relative\ntimelock values, the total number of pre-signed transactions isn't really\nthat high. With a few thousand pre-signed transactions (more than enough),\nyou can have high resolution timelocks well into the future.\n\nOn Wed, Aug 7, 2019 at 4:19 PM Dustin Dettmer <dustinpaystaxes at gmail.com>\nwrote:\n\n> Does revaulting vault up with the same keys, or new ones?\n> Are they new derivation paths on the same key?\n>\n\nHonestly, no idea. The answer to that might depend on each individual vault\nuser. If the user doesn't want to deal with the expense of managing a bunch\nof unique keys and other data, then it might make more sense to use the\nsame values and have a small blob that has to be stored for a long time,\nrather than many different blobs stored in different places to deal with.\n\n- Bryan\nhttp://heybryan.org/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/8b220b88/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-08-12T15:01:10",
                "message_text_only": "On Wed, Aug 07, 2019 at 08:48:06AM -0500, Bryan Bishop via bitcoin-dev wrote:\n> Hi,\n> \n> I have a proposal for implementing bitcoin vaults in a way that does not\n> require any soft-forks or other software upgrades, although it could benefit\n> from SIGHASH_NOINPUT which I'll describe later.\n> \n> I call them pre-signed vaults.\n> \n> Vault definition\n> ================\n> \n> Here, a vault is defined as a transaction setup scheme that binds both the user\n> and the attacker to always using a public observation and delay period before a\n> weakly-secured hot key is allowed to arbitrarily spend coins. This is the same\n> definition previously used[1]. During the delay period, there is an opportunity\n> to initiate recovery/clawback which can either trigger deeper cold storage\n> parameters or at least reset the delay period to start over again for the same\n> keys.\n\nSo, I'll point out that I'd describe this a little bit differently:\n\n    The vault is a tx setup scheme that binds coins in such a way that they can\n    only be spent via a proof-of-publication *notification*, followed by a delay\n    period, during which coins can be recovered/clawed back.\n\nThe key difference being it's not important that this be a *public*\nnotification: that the public can see just happens to be an (unfortunate)\nimplementation detail. For example, you could imagine a system where the\n\"prepare to spend\" tx is indistinguishable from any other transaction.\n\n> One of the important components of this is the delete-the-key pre-signed\n> transaction concept, where only a single transaction is (pre)signed before\n> deleting the key. This is basically an emulation of a covenant and enforces a\n> certain outcome.\n\nIt's important to note the reason this is possible is because any coin bound by\na convenant simply isn't a coin in the normal sense of the word, and is only\nacceptable as payment directly if the receiver chooses to accept it.\n\nTo use an analogy many others have used, if you owe me $100, it's not\nacceptable for you to pay me that $100 by dumping a time-locked safe on my\nfront lawn containing that $100 unless I've agreed to accept payment that way.\n\n> * Nuclear abort key: Also unnecessary. This is a key for which only a single\n> signed transaction will ever exist, and that single transaction will spend to a\n> proof-of-burn key like 0x00. This key must be extremely secure, and if there\n\nSo to be clear, you're spending to a proof-of-burn _key_ because of the use of\nadapter signatures for multisig? I'm not sure where the 0x00 is coming from\nhere.\n\nObviously normally to provably destroy coins you'd spend to an OP_RETURN\noutput, or if miner censorship was an issue, a pay-to-script-hash of an\nOP_RETURN <nonce> script.\n\n> Delete the key (for pre-signed transactions)\n> ============================================\n> \n> The delete-the-key trick is simple. The idea is to pre-sign at least one\n> transaction and then delete the private key, thus locking in that course of\n> action.\n> \n> Unfortunately, delete-the-key doesn't really work for multisig scenarios\n> because nobody would trust that anyone else in the scheme has actually deleted\n> the secret. If they haven't deleted the secret, then they have full unilateral\n> control to sign anything in that branch of the transaction tree. The only time\n> that delete-the-key might be appropriate would be where the user who deletes\n> the key and controls the key during the setup process is also the sole\n> beneficiary of the entire setup with the multisig participants.\n> \n> Alternative fee rates are easier to deal with using delete-the-key, compared to\n> a technique where the private key never existed which can only be used to sign\n> one fee rate per public key, requiring an entirely new vault subtree for each\n> alternative fee rate. With delete-the-key, the alternative fee rates are signed\n> with the private key before the private key is deleted.\n\nI think this could use a bit more analysis here: why can't delete the *keys*\nwork, with each party deleting a separate private key that's used in an m-of-n\nfashion? So long as at least n-m+1 parties actually deleted their keys IIUC it\nshould be secure.\n\n> Multisig gated by ECDSA pubkey recovery for provably-unknown keys\n> =================================================================\n> \n> A group can participate in a multisig scheme with provably-unknown ECDSA keys.\n> Instead of deleting the key, the idea is to agree on a blockheight and then\n> select the blockhash (or some function of the chosen blockhash like\n> H(H(H(blockhash)))) as the signature. Next, the group agrees on a transaction\n> and they recover the public key from the signature using ECDSA pubkey recovery.\n\nCould you explain in more detail why you're deriving this from a blockhash?\n\n> Deploying exceedingly large scripts\n> ===================================\n> \n> A brief interlude to share a somewhat obvious construction. I haven't seen this\n> written down yet.\n> \n> Suppose there is a bitcoin script that someone is interested in using, but it\n> far exceeds the size limits and sigop limits. To fix this, they would split up\n> the script into usable chunks, and then use the delete-the-key mechanism (or\n> the other one) to create an OR branch that is signable by a single key for\n> which only a single signature is known. That new pre-signed transaction would\n> spend to a script that has the output with the remainder of the script of\n> interest. Re-vaulting or clawback clauses can be added to that output as well,\n> but spending back to the original root script will only work by generating new\n> scripts and keys (since the final hash isn't known until the whole tree is\n> constructed, it's a dependency loop).\n\nClever!\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/804c7e86/attachment.sig>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2019-08-13T02:09:43",
                "message_text_only": "On Mon, Aug 12, 2019 at 10:01 AM Peter Todd <pete at petertodd.org> wrote:\n\n> The key difference being it's not important that this be a *public*\n> notification: that the public can see just happens to be an (unfortunate)\n> implementation detail. For example, you could imagine a system where the\n> \"prepare to spend\" tx is indistinguishable from any other transaction.\n>\n\nTrue, I did not intend for everyone to know the meaning of the observed\ntransaction. It turns out to not be too useful to the scheme anyway, unless\nyou're interested in protecting against an adversary dumb enough to tell\nyou he has stolen your key before spending your coins. To reiterate my\nother follow-up email, the best you can do (... or the best I can do right\nnow) is limit losses to k% where k is selected by the user, e.g. 1 input\n100 outputs each with succesively increasing timeouts allowing the rotten\nnon-rotated(pre-inserted) key to spend, and instant spending by a recovery\nflow. Once the attacker steals any one of the k% outputs, you know to not\nlet the outputs timeout to that key in the future. Unfortunately, without\nan opcode-style covenant, the only way to know if a stale hot key is stolen\nis to observe an unexpected spend or, if you're lucky, observe an\nunexpected signature otherwise unassociated with a transaction.\n\n\n> > * Nuclear abort key: Also unnecessary. This is a key for which only a\n> single\n\n\n>\nObviously normally to provably destroy coins you'd spend to an OP_RETURN\n> output, or if miner censorship was an issue, a pay-to-script-hash of an\n> OP_RETURN <nonce> script.\n>\n\nOh, right. Well, that works.\n\n\n> > Delete the key (for pre-signed transactions)\n> > ============================================\n> >\n> > The delete-the-key trick is simple. The idea is to pre-sign at least one\n> > transaction and then delete the private key, thus locking in that course\n> of\n> > action.\n> >\n> > Unfortunately, delete-the-key doesn't really work for multisig scenarios\n> > because nobody would trust that anyone else in the scheme has actually\n> deleted\n> > the secret. If they haven't deleted the secret, then they have full\n> unilateral\n> > control to sign anything in that branch of the transaction tree. The\n> only time\n> > that delete-the-key might be appropriate would be where the user who\n> deletes\n> > the key and controls the key during the setup process is also the sole\n> > beneficiary of the entire setup with the multisig participants.\n> >\n> > Alternative fee rates are easier to deal with using delete-the-key,\n> compared to\n> > a technique where the private key never existed which can only be used\n> to sign\n> > one fee rate per public key, requiring an entirely new vault subtree for\n> each\n> > alternative fee rate. With delete-the-key, the alternative fee rates are\n> signed\n> > with the private key before the private key is deleted.\n>\n> I think this could use a bit more analysis here: why can't delete the\n> *keys*\n> work, with each party deleting a separate private key that's used in an\n> m-of-n\n> fashion? So long as at least n-m+1 parties actually deleted their keys\n> IIUC it\n> should be secure.\n>\n\nI was thinking about another construction where you pick a key as a group\n(separate from the multisig setup) and sign with that. But in practice, as\nyou have pointed out, you would do the delete-the-key trick on the multisig\nconstruction itself with each party contributing their own pubkey,\nrequiring 1/n honest deletes.\n\n\n> > Multisig gated by ECDSA pubkey recovery for provably-unknown keys\n> > =================================================================\n> >\n> > A group can participate in a multisig scheme with provably-unknown ECDSA\n> keys.\n> > Instead of deleting the key, the idea is to agree on a blockheight and\n> then\n> > select the blockhash (or some function of the chosen blockhash like\n> > H(H(H(blockhash)))) as the signature. Next, the group agrees on a\n> transaction\n> > and they recover the public key from the signature using ECDSA pubkey\n> recovery.\n>\n> Could you explain in more detail why you're deriving this from a blockhash?\n>\n\nWell you need to pick an entropy source, and I wouldn't want to tell people\nto just trust the first party to tell you a good sequence of bytes.\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/457a9f30/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-08-13T14:15:32",
                "message_text_only": "On Mon, Aug 12, 2019 at 09:09:43PM -0500, Bryan Bishop wrote:\n> > > Multisig gated by ECDSA pubkey recovery for provably-unknown keys\n> > > =================================================================\n> > >\n> > > A group can participate in a multisig scheme with provably-unknown ECDSA\n> > keys.\n> > > Instead of deleting the key, the idea is to agree on a blockheight and\n> > then\n> > > select the blockhash (or some function of the chosen blockhash like\n> > > H(H(H(blockhash)))) as the signature. Next, the group agrees on a\n> > transaction\n> > > and they recover the public key from the signature using ECDSA pubkey\n> > recovery.\n> >\n> > Could you explain in more detail why you're deriving this from a blockhash?\n> >\n> \n> Well you need to pick an entropy source, and I wouldn't want to tell people\n> to just trust the first party to tell you a good sequence of bytes.\n\nBut why does this specifically need to be entropy?\n\nIf I understand the scheme correctly, the important thing is for the ECDSA\nprivate key to be unknown. Under the standard assumption that hash functions\nare random oracles, hashing anything should be sufficient to create a pubkey\nwhose private key is unknown.\n\nSecondly, there's probably better slightly privacy if a random nonce is chosen\n(perhaps by concatenating a nonce from each party) rather than picking pubkeys\nunique to this use-case.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190813/686185e5/attachment.sig>"
            },
            {
                "author": "Praveen Baratam",
                "date": "2019-08-13T02:44:03",
                "message_text_only": "Bryan,\n\nThis is very similar to *CoinVault - Secure Depository and Secure Exchange*\ntechnologies that I have shared with you all.\n\u1427\n\nOn Wed, Aug 7, 2019 at 7:23 PM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I have a proposal for implementing bitcoin vaults in a way that does not\n> require any soft-forks or other software upgrades, although it could\n> benefit\n> from SIGHASH_NOINPUT which I'll describe later.\n>\n> I call them pre-signed vaults.\n>\n> Vault definition\n> ================\n>\n> Here, a vault is defined as a transaction setup scheme that binds both the\n> user\n> and the attacker to always using a public observation and delay period\n> before a\n> weakly-secured hot key is allowed to arbitrarily spend coins. This is the\n> same\n> definition previously used[1]. During the delay period, there is an\n> opportunity\n> to initiate recovery/clawback which can either trigger deeper cold storage\n> parameters or at least reset the delay period to start over again for the\n> same\n> keys.\n>\n> One of the important components of this is the delete-the-key pre-signed\n> transaction concept, where only a single transaction is (pre)signed before\n> deleting the key. This is basically an emulation of a covenant and\n> enforces a\n> certain outcome.\n>\n> Background and motivation\n> =========================\n>\n> I was looking at Eyal and Sirer's 2016 vaults paper [1], and I saw this\n> headscratcher:\n>\n> > Vault transactions use a delay mechanism. We note that vault transactions\n> > cannot be implemented with existing timing mechanisms such as\n> > CHECKLOCKTIMEVERIFY opcode or transaction locktime.\n>\n> This was probably written before the introduction of\n> OP_CHECKSEQUENCEVERIFY.\n> Still, a viable construction would have more steps than just using OP_CSV.\n> They\n> were probably not thinking about what those steps might be, because in the\n> context of the paper they were proposing a bitcoin vault implemented using\n> recursive consensus-enforced covenants via a new opcode, which obviously\n> cannot\n> be deployed without an upgrade fork. Covenants have been discussed for\n> years,\n> but require new opcodes or other consensus-enforcement changes.\n>\n> Relative locktimes are useful here because there is no knowledge as to\n> when the\n> transactions might be broadcasted in the future. The delays need to be\n> relative\n> to after the transaction is included in the blockchain, not to setup\n> initialization time.\n>\n> Also, from [2]:\n>\n> > We show that a [vault transaction] mechanism is currently not possible\n> in all\n> > cryptocurrencies [...] Bitcoin's scripting language requires support for\n> > covenants.\n>\n> I haven't seen any previous proposal for how to implement recursive bitcoin\n> vaults without a fork and without a covenant. After asking around, I am\n> pretty\n> sure this is somewhat novel. The closest I guess is [3].\n>\n> Vaults are particularly interesting as a bitcoin cold storage security\n> mechanism because they enable a publicly observable delay period during\n> which\n> time a user could be alerted by a watchtower that a thief might be in the\n> process of stealing their coins, and then the user may take some actions to\n> place the coins back into the vault before the relative timelock expires.\n> There\n> seems to be no way to get this notification or observation period without a\n> vault construction. It might have been assumed it required a covenant.\n>\n> Having a vault construction might go a long way to discourage would-be\n> attackers, on principle that the attacker might be incapable of recovering\n> their cost-of-attack because the recovery mechanism can lock up the coins\n> indefinitely. Griefing or denial-of-service would still be possible, of\n> course,\n> but with multisig there might be some ways to put a halt to that as well.\n> I am\n> working under the assumption that the attacker knows that the user is a\n> vault\n> user.\n>\n> Vaults\n> ======\n>\n> The idea is to have a sequence of pre-generated pre-signed transactions\n> that\n> are generated in a certain way. The basic components are a vaulting\n> transaction\n> that locks coins into a vault, a delayed-spend transaction which is the\n> only\n> way to spend from a vault, and a re-vaulting transaction which can\n> recover/clawback coins from the delayed-spend transaction. The security of\n> this\n> scheme is enforced by pre-signing transactions and deleting private keys,\n> or\n> with the help of SIGHASH_NOINPUT then there's another scheme where private\n> keys\n> are provably never known. This enforces that there's only a specific set of\n> possible outcomes at every step of the vault.\n>\n> Some examples of what the set of broadcasted transactions might look like\n> in\n> regular usage:\n>\n>     coins -> VT -> DST -> exit via hot wallet key\n>     coins -> VT -> DST -> RVT\n>     coins -> VT -> DST -> RVT -> DST -> ...\n>     coins -> VT -> ... -> RVT998 -> nuclear abort\n>\n> where:\n>     VT = vault transaction\n>     DST = delayed-spend transaction\n>     RVT = re-vaulting transaction\n>\n> The delayed-spending transaction would have a single output with a script\n> like:\n> (\n>     30 days AND hot wallet key\n>  OR 10 days AND re-vaulting public key\n>  OR 1 day AND 4-of-7 multisig\n>  OR 0 days and super-secure nuclear abort ragequit key\n> )\n>\n> Another diagram:\n>\n>     VT_100 -> DST -> (optionally) RVT -> coins are now in VT_99\n>     VT_99 -> DST -> (optionally) RVT -> coins are now in VT_98\n>     ...\n>     VT_1 -> burn-all-coins nuclear abort ragequit (final)\n>\n> Definitions\n> ===========\n>\n> Transactions and components:\n>\n> * Commitment/funding vault setup transaction. Signed after setting up the\n> transaction tree, and it is broadcasted whenever funds are to be placed\n> into\n> the vault.\n>\n> * Delayed-spend transaction. Signed during the vault transaction tree\n> setup,\n> and it is broadcasted when the user wants to withdraw coins from cold\n> storage\n> or otherwise manipulate the coins. The output script template used by the\n> delayed-spend transaction was defined earlier.\n>\n> * Hot wallet key: Somewhat insecure key. This can also be multisig using\n> multiple hot keys.\n>\n> * Re-vaulting key: It is important to note that the private key either\n> never\n> existed (SIGHASH_NOINPUT + P2WPK for the re-vaulting transaction) or the\n> private key was deleted after pre-signing the re-vaulting transaction.\n>\n> * 4-of-7 multisig: This is a group of differently-motivated individuals\n> who are\n> responsible for signing transactions. This multisig group is not necessry\n> to\n> describe the technique, I just think it's a useful feature for a vault to\n> include.\n>\n> * Nuclear abort key: Also unnecessary. This is a key for which only a\n> single\n> signed transaction will ever exist, and that single transaction will spend\n> to a\n> proof-of-burn key like 0x00. This key must be extremely secure, and if\n> there\n> is any doubt about the ability to keep such a key secured, then it is\n> better to\n> not include this in the protocol. Alternatively, maybe include it as an\n> option\n> 50 layers down in the revaulting sequence.\n>\n> * Nuclear-abort pre-signed transaction. This is signed during transaction\n> tree\n> setup, before constructing the delayed-spend transaction. It is broadcasted\n> only if the user wants to provably relinquish coins forever without giving\n> the\n> attacker any coins.\n>\n> * Re-vaulting transaction. This is where the magic happens. The re-vaulting\n> transaction is signed during transaction tree setup, before constructing\n> the\n> delayed-spend transaction for the parent vault. The re-vaulting\n> transaction is\n> broadcasted when someone wants to prevent a coin withdrawal during the\n> public\n> observation delay period. The re-vaulting transaction spends the\n> delayed-spend\n> transaction outputs. It has a single output with a script created by\n> running\n> the entire vault setup function again. Hence, when the re-vaulting\n> transaction\n> is confirmed, all of the coins go back into a new identically-configured\n> vault\n> instead of being relinquished through the delayed-spend transaction\n> timeout for\n> hot wallet key signing.\n>\n> * Special case: final transaction. This is the very first pre-signed\n> transaction during setup, and the transaction spends the coins using any\n> provable burn technique. This is broadcasted only at the end of the game,\n> as an\n> ultimate abort and forfeiture of coins without giving in to an adversary.\n> It's\n> similar to the nuclear-abort ragequit transaction but it sits at the same\n> place\n> that a delayed-spend transaction would, at the very end of the rainbow or\n> yellow brick road.\n>\n> Example log during vault setup\n> ==============================\n>\n> When running the recursive vault setup function, the created artifacts (in\n> order) will look like:\n>\n> 1) choose one of:\n>    (first iteration) pre-signed burn-all-coins nuclear abort ragequit\n> (final)\n>    (all others) a new vault setup transaction spendable only by its\n>                 delayed-spend transaction\n>\n> 2) pre-signed re-vaulting transaction sending to vault setup or final\n> transaction, with a unique private key\n>\n> 3) pre-signed delayed-spend transaction, with a unique private key\n>\n> 4) vault transaction spendable only by the delayed-spend public key\n>\n> Pseudocode\n> ==========\n>\n> In pseudocode (where PTX is a pre-signed transaction function with\n> private key deletion):\n>\n>     VT(counter, *args, **kwargs) =\n>         if counter == 0:\n>             DST = PTX(\"burn-all-coins\")\n>         else:\n>             next_vault = VT(counter-1, *args, **kwargs)\n>             revaulting = PTX(\"only spendable by next_vault public key\")\n>             DST = PTX(\"DST policy including revaulting and other\n> conditions\")\n>         vault = PTX(\"spendable only by this DST\")\n>         return vault\n>\n> Pre-signed transactions\n> =======================\n>\n> What has been known for a while is that a covenant can be somewhat emulated\n> using a pre-signed transaction where the user then deletes the private key,\n> enforcing that the user's chosen policy must be enforced since there is\n> only\n> one existing option and there will only ever be one option.\n>\n> Such a scheme has been previously described for simple one-time and chained\n> vaults [3]. I have learned that the author has an implementation that is in\n> preparation, for a non-recursive version.\n>\n> Note that a series of pre-signed transactions can be considered to be an\n> emulation of a covenant. Imagine a linear chain of pre-signed transactions\n> where each hop has a relative locktime before being able to broadcast the\n> next\n> transaction. To recover the coins at the end of the rainbow, one would\n> need to\n> broadcast each sequential transaction in order and wait for the relative\n> timelocks to expire each time. Here, covenants provide something like an\n> undo\n> for bitcoin, but only between pre-determined addresses and scripts.\n>\n> Fees for pre-signed transactions\n> ================================\n>\n> There's a few different techniques to talk about:\n>\n> 1) SIGHASH_SINGLE|SIGHASH_ANYONECANPAY to let someone add inputs and\n> outputs.\n> This can get pretty complex though.\n>\n> 2) Add a zero-value OP_TRUE output and let anyone spend the zero-value\n> output\n> and attach a child-pays-for-parent (CPFP) transaction to pay for\n> everything.\n>\n> 3) Pre-sign a variety of different possible fee rates. Unfortunately this\n> involves an explosive blow-up in the amount of transaction data to\n> generate. It\n> might actually be a reasonable blow-up amount, only resulting in a few\n> hundred\n> megabytes of additional data. But given the other options, this is\n> unnecessary.\n>\n> Delete the key (for pre-signed transactions)\n> ============================================\n>\n> The delete-the-key trick is simple. The idea is to pre-sign at least one\n> transaction and then delete the private key, thus locking in that course of\n> action.\n>\n> Unfortunately, delete-the-key doesn't really work for multisig scenarios\n> because nobody would trust that anyone else in the scheme has actually\n> deleted\n> the secret. If they haven't deleted the secret, then they have full\n> unilateral\n> control to sign anything in that branch of the transaction tree. The only\n> time\n> that delete-the-key might be appropriate would be where the user who\n> deletes\n> the key and controls the key during the setup process is also the sole\n> beneficiary of the entire setup with the multisig participants.\n>\n> Alternative fee rates are easier to deal with using delete-the-key,\n> compared to\n> a technique where the private key never existed which can only be used to\n> sign\n> one fee rate per public key, requiring an entirely new vault subtree for\n> each\n> alternative fee rate. With delete-the-key, the alternative fee rates are\n> signed\n> with the private key before the private key is deleted.\n>\n> Multisig gated by ECDSA pubkey recovery for provably-unknown keys\n> =================================================================\n>\n> A group can participate in a multisig scheme with provably-unknown ECDSA\n> keys.\n> Instead of deleting the key, the idea is to agree on a blockheight and then\n> select the blockhash (or some function of the chosen blockhash like\n> H(H(H(blockhash)))) as the signature. Next, the group agrees on a\n> transaction\n> and they recover the public key from the signature using ECDSA pubkey\n> recovery.\n> A pre-signed transaction is created, which will trigger the start of the\n> public\n> observation period described earlier and also start the clock for the\n> bip112\n> relative timelock on its output. In the output script, an OR branch\n> is added that enables the use of a re-vaulting key which could also be its\n> own\n> separate multisig construction.\n>\n> This is incompatible with P2WPKH because the P2WPKH spending scriptSig\n> needs to\n> have the pubkey (to check the hash of the pubkey against the pubkeyhash in\n> the\n> scriptPubKey), which in turn makes it incompatible with ECDSA pubkey\n> recovery\n> which requires a hash of the message. However, with P2WPK and\n> SIGHASH_NOINPUT\n> instead of P2WPKH it could conceivably work. SIGHASH_NOINPUT is required\n> because\n> otherwise the input includes a txid which references the public key. With\n> P2WPK,\n> the scriptSig only needs a signature and not a public key. Note that what\n> would\n> be required is a version of SIGHASH_NOINPUT that does not commit to the\n> public\n> key, and I think a few of the NOINPUT proposals are committing to the\n> public\n> key.\n>\n> Alternatively, there may be some constructions using the 2-party ECDSA\n> techniques or m-n party ECDSA techniques.\n>\n> Deploying exceedingly large scripts\n> ===================================\n>\n> A brief interlude to share a somewhat obvious construction. I haven't seen\n> this\n> written down yet.\n>\n> Suppose there is a bitcoin script that someone is interested in using, but\n> it\n> far exceeds the size limits and sigop limits. To fix this, they would\n> split up\n> the script into usable chunks, and then use the delete-the-key mechanism\n> (or\n> the other one) to create an OR branch that is signable by a single key for\n> which only a single signature is known. That new pre-signed transaction\n> would\n> spend to a script that has the output with the remainder of the script of\n> interest. Re-vaulting or clawback clauses can be added to that output as\n> well,\n> but spending back to the original root script will only work by generating\n> new\n> scripts and keys (since the final hash isn't known until the whole tree is\n> constructed, it's a dependency loop).\n>\n> Recursively-enforced multi-party multisig bitcoin vaults\n> ========================================================\n>\n> Ideally, to enforce a covenant with impossible fairy dust magic, we would\n> ask\n> for a bitcoin transaction that could be self-referential because the\n> only-one-signature-ever trick requires that the signed message be known\n> before\n> producing the signature, and the signature has to be known before the\n> public\n> key can be known, and the public key would have to be included in the\n> self-referential message/transaction hash value. So, that's a dependency\n> loop\n> and it doesn't work. It would be interesting to explore a variation of this\n> idea with masking, such that a value X can be replaced by a hash over the\n> whole\n> script with the X value, even though the real script will have the hash.\n> Someone else can figure that one out for me :-).\n>\n> Instead of the self-referential values attempting to reference the same\n> script that is in the process of being constructed, an alternative is to\n> use\n> the same script template but populate it with different parameters. The\n> script\n> template gets reused over and over again, all the way down the tree, until\n> the\n> final transaction which could be >100 years into the future once done\n> adding up\n> all the relative locktimes. In fact, to create and populate this terrifying\n> recursive script tree, the final transaction needs to be created first, and\n> then it is given as input to the script template function and that output\n> is\n> then given to the script template function itself-- and so on. At each\n> stage,\n> there are additional pre-signed transactions and values to remember.\n>\n> This can be written as:\n>\n>     final_transaction = TX(spend to 0x0000 to burn the coins)\n>     initial_transaction = F(F(...F(final_transaction))\n>\n>     (This is missing parameters to indicate to the function what the\n> spending\n>     keys requirements are to be.)\n>\n> See earlier explanation for more details.\n>\n> Each call to the template populating function produces values that each\n> must be\n> preserved for a very long time. It is less safe to store all of the\n> pre-signed\n> transactions together at the same time, but more convenient. With less\n> redundancy, there is an increased chance of losing data over time, which\n> could\n> render the coins completely frozen. This doesn't particularly worry me\n> because\n> forgetting a key has that property already, and this could be likened to\n> hundreds of megabytes of extra key data or something. Unlike the much\n> smaller\n> covenant-based (opcode-based covenant) vault construction, the multiple\n> layers\n> here can be separately stored and protected, which might be able to protect\n> against an adversary that has stolen some of the re-vaulting keys but not\n> all\n> of them.\n>\n> Optimizations can be made to store parameters for generating the remainder\n> of\n> the tree, such as using deterministic key derivation, such that megabytes\n> of\n> data wouldn't need to be long-term stored. Only the initial parameters\n> would\n> need to be stored.\n>\n> Financial privacy for custody\n> =============================\n>\n> One of the concerns raised in [2] is that if all coins at an exchange are\n> stored together in the same vault, then attackers would be able to learn\n> about\n> access control policies by observing scripts and keys. Some privacy can be\n> recovered by using segregated vaults, at the cost of additional setup\n> complexity and keeping more data in long-term storage.\n>\n> However, note that I think vaults are also useful for personal cold storage\n> solutions.\n>\n> Fail-deadly mechanism\n> =====================\n>\n> An early nuclear abort option can be added to these scripts. This idea was\n> explored in [2]. This would be a very cold very secret key that would\n> abort the\n> re-vaulting procedure and send all coins to a (provably) nonsense key. This\n> allows a vault user to destroy the coins instead of continuously\n> monitoring the\n> bitcoin blockchain for the rest of his life. The attacker can't recover\n> their\n> cost of attack if they never get the coins, and this eliminates an entire\n> class\n> of potential attackers who are directly interested only in financial gain.\n> The\n> disadvantage is that if the attacker finds the secret key for the\n> fail-deadly\n> mechanism and uses it, then all of the coins are gone forever.\n>\n> Multisig variations\n> ===================\n>\n> The re-vaulting key could be the same key at each layer, or only sometimes\n> the\n> same key, or always a unique key stored separately in another secure\n> location.\n>\n> Additionally, these re-vaulting keys could be subjected to multisig\n> schemes, as\n> well as Shamir secret sharing schemes or other secret sharing schemes.\n>\n> The idea of adding the 4-of-7 multisig component is to avoid griefing\n> situations, at the cost of the additional security requirements for the\n> 4-of-7\n> multisig group.\n>\n> Key rotation for vaults\n> =======================\n>\n> Keeping the same hot wallet key for 100 years is not advisable. Rotate the\n> keys\n> by setting up a new vault construction and initiating a withdrawal\n> transaction\n> from the old vault to the new vault.\n>\n> Single-use seals\n> ================\n>\n> This proposal may have inadvertedly demonstrated a practical way to\n> implement\n> Peter Todd's single-use seals concept [4]. I am hesitant to say so, though,\n> because I think he would ask for a more sophisticated way to verify seal\n> closure.\n>\n> Paid defection\n> ==============\n>\n> It might be advisable to add small rewards for evidence of defection\n> amongst\n> multiparty multisig setups. Besides amounts spendable by individual keys\n> from a\n> multisig setup, it may be possible to use a zero-knowledge contingent\n> payment\n> for a zero-knowledge statement like: I have a signature s over some\n> message m\n> which validates for pubkey pk where pk is a member of the multisig group.\n> Then\n> the zkcp transaction would pay for knowledge of defectors. The zkcp\n> procedure\n> would require interaction with the defector, while the direct pubkey method\n> would not. This is similar to companies paying employees to quit when they\n> value the payment over the value of continued employment.\n>\n> Handling change\n> ===============\n>\n> It is important to note that this vault setup is one-time and once-only.\n> There\n> must only ever be one deposit into one vault. Also, spending some coins\n> would\n> require sending the change amount back into a new vault.  Alternatively,\n> upfront work can be done to set a regular withdrawal stipend or assumption\n> about how many coins are left, such that the transaction tree can be\n> pre-generated for those possibilities, hence cutting down on future vault\n> reinitializations. It would also be possible to commit upfront to only ever\n> working in some minimum increment number of bitcoin or something.\n>\n> It is very important to only fund the vault once, and only with the amount\n> that\n> was configured when setting up the vault.\n>\n> References\n> ==========\n>\n> [1] https://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n>\n> [2]\n> http://www0.cs.ucl.ac.uk/staff/P.McCorry/preventing-cryptocurrency-exchange.pdf\n>\n> [3]\n> http://web.archive.org/web/20180503151920/https://blog.sldx.com/re-imagining-cold-storage-with-timelocks-1f293bfe421f?gi=da99a4a00f67\n>\n> [4]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015350.html\n> or\n> https://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/single-use-seals/\n> or https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n>\n> Acknowledgements\n> ================\n>\n> * Jeremy Rubin for pointing out something embarrassingly broken in an\n> earlier\n> draft.\n>\n> * Bob McElrath for telling me to use SIGHASH_NOINPUT which I proceeded to\n> promptly forget about.\n>\n> * Andrew Poelstra for the OP_TRUE trick.\n>\n> * Joe Rayhawk for paid defection.\n>\n> * Tadge Dryja for pointing out a few differences between SIGHASH_NOINPUT\n> proposals.\n>\n>\n>\n> Thank you,\n>\n> - Bryan\n> http://heybryan.org/\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nDr. Praveen Baratam\n\nabout.me <http://about.me/praveen.baratam>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190813/55b63aec/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin vaults with anti-theft recovery/clawback mechanisms",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Praveen Baratam",
                "Peter Todd",
                "ZmnSCPxj",
                "Sergio Demian Lerner",
                "Dustin Dettmer"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 74884
        }
    },
    {
        "title": "[bitcoin-dev] Single-use-Seal Implementation",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2019-08-12T14:40:23",
                "message_text_only": "On Wed, Aug 07, 2019 at 08:48:06AM -0500, Bryan Bishop via bitcoin-dev wrote:\n> Single-use seals\n> ================\n> \n> This proposal may have inadvertedly demonstrated a practical way to implement\n> Peter Todd's single-use seals concept [4]. I am hesitant to say so, though,\n> because I think he would ask for a more sophisticated way to verify seal\n> closure.\n\nI'm not sure what you're getting at here; single-use-seals are really boring\nand simple. To recap, they're akin to a pubkey that has the \"magical\" property\nthat it can only be signed once. This of course is impossible with math alone,\nbut can be implemented with beyond-math mechanisms like trust or PoW (physics).\n\nThus you have a globally unique seal, which can be closed over a message,\nproducing a witness attesting to the fact that the seal was closed over that\nmessage. A single-use-seal protocol is secure if it is impossible (in your\nchosen security model) to trick the validation function into thinking a single\nseal was closed over two different messages.\n\nThe obvious implementation with Bitcoin is to define the seal to be a specified\ntxout, and the witness to be a transaction (and lite client proof) that spends\nthat txout in a transation with an OP_RETURN output committing to the hash of\nthe message as the first output. A fancier implementation could use a\npay-to-pubkey-style commitment (RGB\u00b9 uses something along these lines).\n\n\nFor applications requiring a chain of single-use-seals, you can easily keep two\ntxouts for seals in your wallet, and alternate them as the chain is extended.\n\n\nDo you mean to say there didn't previously exist a practical way to implement\nthem? Or that you've found another way? I'm curious what you mean here.\n\n\n1) https://github.com/rgb-org/spec\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/c7c319b2/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Single-use-Seal Implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2085
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.18.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2019-08-09T10:30:43",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.18.1 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.18.1/>\n\nOr through BitTorrent:\n\n    magnet:?xt=urn:btih:c3ba0cfee3ef8413098ac5e81db08a2670e9da8c&dn=bitcoin-core-0.18.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n    \nThis is a new minor version release, including new features, various bug\nfixes and performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has\ncompletely shut down (which might take a few minutes for older\nversions), then run the installer (on Windows) or just copy over\n`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on\nLinux).\n\nThe first time you run version 0.15.0 or newer, your chainstate database\nwill be converted to a new format, which will take anywhere from a few\nminutes to half an hour, depending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and\nthere is no automatic upgrade code from before version 0.8 to version\n0.15.0 or later. Upgrading directly from 0.7.x and earlier without\nredownloading the blockchain is not supported.  However, as usual, old\nwallet versions are still supported.\n\nCompatibility\n==============\n\nBitcoin Core is supported and extensively tested on operating systems\nusing the Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not\nrecommended to use Bitcoin Core on unsupported systems.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nas frequently tested on them.\n\n- From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is\nbuilt using Qt 5.9.x, which doesn't support versions of macOS older than\n10.10. Additionally, Bitcoin Core does not yet change appearance when\nmacOS \"dark mode\" is activated.\n\nKnown issues\n============\n\nWallet GUI\n- ----------\n\nFor advanced users who have both (1) enabled coin control features, and\n(2) are using multiple wallets loaded at the same time: The coin control\ninput selection dialog can erroneously retain wrong-wallet state when\nswitching wallets using the dropdown menu. For now, it is recommended\nnot to use coin control features with multiple wallets loaded.\n\n0.18.1 change log\n=================\n\n### P2P protocol and network code\n- - #15990 Add tests and documentation for blocksonly (MarcoFalke)\n- - #16021 Avoid logging transaction decode errors to stderr (MarcoFalke)\n- - #16405 fix: tor: Call `event_base_loopbreak` from the event's callback (promag)\n- - #16412 Make poll in InterruptibleRecv only filter for POLLIN events (tecnovert)\n\n### Wallet\n- - #15913 Add -ignorepartialspends to list of ignored wallet options (luke-jr)\n\n### RPC and other APIs\n- - #15991 Bugfix: fix pruneblockchain returned prune height (jonasschnelli)\n- - #15899 Document iswitness flag and fix bug in converttopsbt (MarcoFalke)\n- - #16026 Ensure that uncompressed public keys in a multisig always returns a legacy address (achow101)\n- - #14039 Disallow extended encoding for non-witness transactions (sipa)\n- - #16210 add 2nd arg to signrawtransactionwithkey examples (dooglus)\n- - #16250 signrawtransactionwithkey: report error when missing redeemScript/witnessScript (ajtowns)\n\n### GUI\n- - #16044 fix the bug of OPEN CONFIGURATION FILE on Mac (shannon1916)\n- - #15957 Show \"No wallets available\" in open menu instead of nothing (meshcollider)\n- - #16118 Enable open wallet menu on setWalletController (promag)\n- - #16135 Set progressDialog to nullptr (promag)\n- - #16231 Fix open wallet menu initialization order (promag) \n- - #16254 Set `AA_EnableHighDpiScaling` attribute early (hebasto) \n- - #16122 Enable console line edit on setClientModel (promag) \n- - #16348 Assert QMetaObject::invokeMethod result (promag)\n\n### Build system\n- - #15985 Add test for GCC bug 90348 (sipa)\n- - #15947 Install bitcoin-wallet manpage (domob1812)\n- - #15983 build with -fstack-reuse=none (MarcoFalke)\n\n### Tests and QA\n- - #15826 Pure python EC (sipa)\n- - #15893 Add test for superfluous witness record in deserialization (instagibbs)\n- - #14818 Bugfix: test/functional/rpc_psbt: Remove check for specific error message that depends on uncertain assumptions (luke-jr)\n- - #15831 Add test that addmultisigaddress fails for watchonly addresses (MarcoFalke)\n\n### Documentation\n- - #15890 Remove text about txes always relayed from -whitelist (harding)\n\n### Miscellaneous\n- - #16095 Catch by reference not value in wallettool (kristapsk)\n- - #16205 Replace fprintf with tfm::format (MarcoFalke)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - Andrew Chow\n- - Anthony Towns\n- - Chris Moore\n- - Daniel Kraft\n- - David A. Harding\n- - fanquake\n- - Gregory Sanders\n- - Hennadii Stepanov\n- - John Newbery\n- - Jonas Schnelli\n- - Jo\u00e3o Barbosa\n- - Kristaps Kaupe\n- - Luke Dashjr\n- - MarcoFalke\n- - MeshCollider\n- - Pieter Wuille\n- - shannon1916\n- - tecnovert\n- - Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl1NSt4ACgkQHkrtYphs\n0l0IEQf+PwMCgx93D/O2E3mbEXA/+CoIkqLHWGSsEUv0imtu/cS4HOVtG21EpBUK\n6cbjjfnCQ+Cof3qiSdavStbIsGkLoeErx2RgmJXTSjNB8SSQbKGEAlQClged5vyz\nCwmmuK/ZoSe2pxLPvO7C08nVdvtW9zvICMmSQt6kwpzEM5IePHC0SJV1akGmupWh\n/d1B9LaCjtJvNZC8R0PxXoIci2Yy6JiqBjDY0UE8oATOA226cwSX/0JVccJnhL/O\n4UepBnAqWoeKDNsFecuiyW08aZZlKg7oUmkNV6iFawUKW/YsYSnJmoK6t87S//h3\nNy5gdddWLY7HSRS3YcKMlq1GYefV0A==\n=Ue9Z\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.18.1 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6027
        }
    },
    {
        "title": "[bitcoin-dev] OP_LOOKUP_OUTPUT proposal",
        "thread_messages": [
            {
                "author": "Haoyu LIN",
                "date": "2019-08-09T13:35:19",
                "message_text_only": "Hi everybody!\n\nRunchao, Jiangshan (both CC'ed) and I bring up a BIP draft that describes a\nnew opcode OP_LOOKUP_OUTPUT, which is used for mitigating the arbitrage\nrisk in a HTLC-based Atomic Swap.\n\nThe problem is called the \"free premium problem\", where the initiator can\nabort the deal (i.e. have optionality) without any penalty. See\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001292.html\nand\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-December/001752.html\nfor detail.\n\nWe have investigated this problem in very detail. We analysed how\nprofitable the arbitrage can be given the default timelock setting (24/48\nhrs). Our result shows that the profit can be approximately 1% ~ 2.3%,\nwhich is non-negligible compared with 0.3% for stock market. This can be\nattractive as it's totally risk-free. Please refer to our paper\nhttps://eprint.iacr.org/2019/896, and the related code\nhttps://github.com/HAOYUatHZ/fair-atomic-swap if interested.\n\nSeveral studies have proposed for solving this problem e.g.,\nhttp://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/\nand https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is\nthat, the transaction for the premium needs to be locked with the same\nsecret hash but with a flipped payout, i.e. when redeemed with the secret,\nthe money goes back to Alice and after timelock, the premium goes to Bob as\na compensation for Alice not revealing the secret. However, this introduces\na new problem: Bob can get the premium without paying anything, by never\nparticipating in.\n\nTo solve this, the transaction verifier needs to know the status of an\ndependent transaction. Unfortunately, Bitcoin does not support the stateful\ntransaction functionalities. Therefore, we propose the new opcode:\nOP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of\nthe output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide\nwhether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT\n<pubkeyhash> OP_EQUALVERIFY`.\n\nAssume that Alice and Bob exchange asset1 and asset2, and using premium\n(same asset type as asset2) as the collateral.\n\nA sample premium transaction implementation of Atmoic Swap for Spot based\non this opcode is:\n\n```\nScriptSig:\n    Redeem: <Bob_sig> <Bob_pubkey> 1\n    Refund: <Alice_sig> <Alice_pubkey> 0\nScriptPubKey:\n    OP_IF // Normal redeem path\n        // the owner of <asset2_output> should be Alice\n        // which means Alice has redeemed asset2\n        <asset2_output> OP_LOOKUP_OUTPUT <Alice_pubkeyhash> OP_EQUALVERIFY\n        OP_DUP OP_HASH160 <Bob_pubkeyhash>\n    OP_ELSE // Refund path\n        // the premium timelock should be expired\n        <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP\n        OP_DUP OP_HASH160 <Alice pubkey hash>\n    OP_ENDIF\n    OP_EQUALVERIFY\n    OP_CHECKSIG\n```\n\nWe also explore the Atomic Swaps in American Call Options scenario, which\nis different from the Spot scenario. Alice should pay for the premium\nbesides the underlying asset, regardless of whether the swap is successful\nor not. In reality, the option sellers are trustworthy - the option sellers\nnever abort the contract. However, in Atomic Swaps, Bob can abort the\ncontracts like Alice. To keep the Atomic Swap consistent with the American\nCall Options, the premium should follow that: Alice pays the premium to Bob\nif 1) Alice redeems Bob\u2019s asset before Bob\u2019s timelock, or 2) Bob refunds\nhis asset after Bob\u2019s timelock but before Alice\u2019s timelock. If Alice\u2019s\ntimelock expires, Alice can refund her premium back.\n\nA sample premium transaction implementation of Atmoic Swap for Option based\non this opcode is:\n\n```\nScriptSig:\n    Redeem: <Bob_sig> <Bob_pubkey> 1\n    Refund: <Alice_sig> <Alice_pubkey> 0\nScriptPubKey:\n    OP_IF // Normal redeem path\n        // the owner of the asset2 should not be the contract\n        // it should be either (redeemde by) Alice or (refunded by) Bob\n        // which means Alice has redeemed asset2\n        <asset2_output> OP_LOOKUP_OUTPUT <Alice_pubkeyhash> OP_NUMEQUAL\n        <asset2_output> OP_LOOKUP_OUTPUT <Bob_pubkeyhash> OP_NUMEQUAL\n        OP_ADD 1 OP_NUMEQUALVERIFY\n        OP_DUP OP_HASH160 <Bob_pubkeyhash>\n    OP_ELSE // Refund path\n        // the premium timelock should be expired\n        <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP\n        OP_DUP OP_HASH160 <Alice pubkey hash>\n    OP_ENDIF\n    OP_EQUALVERIFY\n    OP_CHECKSIG\n```\n\nAgain, please refer to https://eprint.iacr.org/2019/896 if you need more\ndetail. The BIP draft can be found at\nhttps://github.com/HAOYUatHZ/bips/blob/bip-lookup_output/bip-lookup_output.mediawiki\n\nTo conclude, in order to avoid the risk-free optionality in Atomic Swap, we\npropose a new opcode OP_LOOKUP_OUTPUT, using premium to mitigate the risk\nof Atomic Swap both in Spot and in Option.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/ae4a89c7/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-09T14:29:25",
                "message_text_only": "Good morning Haoyu LIN et al.,\n\n\n> We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.\n>\n> Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n>\n> To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.\n\nI believe an unsaid principle of SCRIPT opcode design is this:\n\n* No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.\n\nThis issue underlies the previous `OP_PUBREF` proposal also.\n\nThe reason for this is:\n\n* We support a pruning mode, where in only the UTXO set is retained.\n  If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.\n* The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.\n  Thus it cannot get information about the block it is in.\n  Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.\n\nIn any case:\n\n> However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n\nPremium payment can be made contingent on Bob participating.\nOf course, it does mean the premium is paid using the destination coin.\nIt also requires the destination coin to support SegWit.\n\nLet me explain by this:\n\n1.  Alice and Bob agree on swap parameters:\n    * Alice will exchange 1 BTC for 1,000,000 WJT from Bob.\n    * Alice will pay 10,000 WJT as premium to Bob.\n    * Alice will lock BTC for 48 hours.\n    * Bob will lock WJT for 24 hours.\n    * The protocol will start at particular time T.\n2.  Alice generates a preimage+hash.\n3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.\n4.  Alice presents above UTXO to Bob.\n5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.\n6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.\n    This pays out to 1,010,000 WJT (the value plus the premium) HTLC.\n    The hashlock branch requires not just Alice, but also Bob.\n    The timelock branch at T+24 just requires Bob.\n7.  Alice and Bob generate the claim transaction.\n    This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.\n8.  Alice and Bob sign the claim transaction.\n    This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.\n9.  Alice and Bob sign the funding transaction and broadcast it.\n10.  Alice completes the claim transaction by adding the preimage and broadcasts it.\n11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.\n\nIf Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.\nAfter step 9, Bob has been forced to participate and cannot back out and claim the premium only.\n\nThis is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html\n\n\nIn addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html\nThe described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.\n\n\nThus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Runchao Han",
                "date": "2019-08-10T05:46:35",
                "message_text_only": "Hi ZmnSCPxj,\n\nThanks for your reply.\n\nI agree with your opinions about OP_LOOKUP_OUTPUT.\nIndeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx. \n\nHowever, I\u2019m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).\nIf I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that \u201cAlice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT\u201d, where the time lock is T+24.\nHere, Bob is responsible for broadcasting this tx after confirming Alice\u2019s funding transaction on BTC blockchain.\nIn this case, Bob can arbitrage by broadcasting this tx *after T+24*. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.\nIf the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.\n\nIn the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice\u2019s asset.\nAlso, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.\nHowever, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice\u2019s premium.\n\nWhat is implied here is that, where the premium should go strictly depends on where Bob\u2019s asset goes.\nIf the Bitcoin\u2019s timelock can be \u201crelative\u201d (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.\nUnfortunately, the \u201cx\u201d here is also an external state according to your definition.\n\nIn conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.\n\nThanks,\nRunchao\n\n> On 10 Aug 2019, at 12:29 am, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Haoyu LIN et al.,\n> \n> \n>> We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.\n>> \n>> Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n>> \n>> To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.\n> \n> I believe an unsaid principle of SCRIPT opcode design is this:\n> \n> * No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.\n> \n> This issue underlies the previous `OP_PUBREF` proposal also.\n> \n> The reason for this is:\n> \n> * We support a pruning mode, where in only the UTXO set is retained.\n>  If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.\n> * The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.\n>  Thus it cannot get information about the block it is in.\n>  Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.\n> \n> In any case:\n> \n>> However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n> \n> Premium payment can be made contingent on Bob participating.\n> Of course, it does mean the premium is paid using the destination coin.\n> It also requires the destination coin to support SegWit.\n> \n> Let me explain by this:\n> \n> 1.  Alice and Bob agree on swap parameters:\n>    * Alice will exchange 1 BTC for 1,000,000 WJT from Bob.\n>    * Alice will pay 10,000 WJT as premium to Bob.\n>    * Alice will lock BTC for 48 hours.\n>    * Bob will lock WJT for 24 hours.\n>    * The protocol will start at particular time T.\n> 2.  Alice generates a preimage+hash.\n> 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.\n> 4.  Alice presents above UTXO to Bob.\n> 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.\n> 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.\n>    This pays out to 1,010,000 WJT (the value plus the premium) HTLC.\n>    The hashlock branch requires not just Alice, but also Bob.\n>    The timelock branch at T+24 just requires Bob.\n> 7.  Alice and Bob generate the claim transaction.\n>    This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.\n> 8.  Alice and Bob sign the claim transaction.\n>    This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.\n> 9.  Alice and Bob sign the funding transaction and broadcast it.\n> 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.\n> 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.\n> \n> If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.\n> After step 9, Bob has been forced to participate and cannot back out and claim the premium only.\n> \n> This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html\n> \n> \n> In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html\n> The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.\n> \n> \n> Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.\n> \n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-10T12:50:18",
                "message_text_only": "Good morning Runchao,\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu> wrote:\n\n> Hi ZmnSCPxj,\n>\n> Thanks for your reply.\n>\n> I agree with your opinions about OP_LOOKUP_OUTPUT.\n> Indeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx.\n>\n> However, I\u2019m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).\n> If I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that \u201cAlice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT\u201d, where the time lock is T+24.\n> Here, Bob is responsible for broadcasting this tx after confirming Alice\u2019s funding transaction on BTC blockchain.\n\nNo, Bob is not.\n\nThe signature exchange for the WJT-side funding tx is done by:\n\n1. Alice waits for Bob to provide all its signatures for inputs that will fund the 1,000,000 WJT payout.\n2. Alice signs its inputs that will fund the 10,000 WJT premium.\n3. Alice broadacasts the completely signed funding tx.\n\nAlice is the one responsible for broadcasting the funding tx.\n\nIf Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then continue the protocol when the exchange rate moves to its favor) as Alice can refuse to sign and broadcast the funding tx once it has decided Bob is trolling it, thus Bob cannot force Alice to perform.\n\nIf Alice stalls, Bob can double-spend one of its inputs at a low feerate.\nThis either aborts the protocol, or if Alice then broadcasts the funding tx at the pre-agreed feerate and it is confirmed, the premium is now already paid to Bob.\n\nRegards,\nZmnSCPxj\n\n> In this case, Bob can arbitrage by broadcasting this tx after T+24. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.\n> If the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.\n>\n> In the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice\u2019s asset.\n> Also, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.\n> However, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice\u2019s premium.\n>\n> What is implied here is that, where the premium should go strictly depends on where Bob\u2019s asset goes.\n> If the Bitcoin\u2019s timelock can be \u201crelative\u201d (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.\n> Unfortunately, the \u201cx\u201d here is also an external state according to your definition.\n>\n> In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.\n>\n> Thanks,\n> Runchao\n>\n> > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > Good morning Haoyu LIN et al.,\n> >\n> > > We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.\n> > > Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n> > > To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.\n> >\n> > I believe an unsaid principle of SCRIPT opcode design is this:\n> >\n> > -   No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.\n> >\n> > This issue underlies the previous `OP_PUBREF` proposal also.\n> > The reason for this is:\n> >\n> > -   We support a pruning mode, where in only the UTXO set is retained.\n> >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.\n> >\n> > -   The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.\n> >     Thus it cannot get information about the block it is in.\n> >     Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.\n> >\n> >\n> > In any case:\n> >\n> > > However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n> >\n> > Premium payment can be made contingent on Bob participating.\n> > Of course, it does mean the premium is paid using the destination coin.\n> > It also requires the destination coin to support SegWit.\n> > Let me explain by this:\n> >\n> > 1.  Alice and Bob agree on swap parameters:\n> >\n> > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.\n> > -   Alice will pay 10,000 WJT as premium to Bob.\n> > -   Alice will lock BTC for 48 hours.\n> > -   Bob will lock WJT for 24 hours.\n> > -   The protocol will start at particular time T.\n> >\n> > 2.  Alice generates a preimage+hash.\n> > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.\n> > 4.  Alice presents above UTXO to Bob.\n> > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.\n> > 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.\n> >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.\n> >     The hashlock branch requires not just Alice, but also Bob.\n> >     The timelock branch at T+24 just requires Bob.\n> >\n> > 7.  Alice and Bob generate the claim transaction.\n> >     This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.\n> >\n> > 8.  Alice and Bob sign the claim transaction.\n> >     This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.\n> >\n> > 9.  Alice and Bob sign the funding transaction and broadcast it.\n> > 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.\n> > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.\n> >\n> > If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.\n> > After step 9, Bob has been forced to participate and cannot back out and claim the premium only.\n> > This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html\n> > In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html\n> > The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.\n> > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Runchao Han",
                "date": "2019-08-10T13:01:41",
                "message_text_only": "If I remember it right, Alice first signs the WJT transaction, sends it to\nBob, then Bob signs it and makes this transaction valid.\n\nIf so, there are two problems.\nFirst, Bob gets the valid tx first, and he can choose not to send it to\nAlice.\nSecond, even if Bob honestly sends Alice this tx, Alice cannot fully\ncontrol when to broadcast this to, as Bob also has this transaction.\n\nIf Bob first signs then Alice signs, Alice still has optionality, as she\ncan choose whether to publish this tx and preimage.\n\nRunchao\n\nOn Sat, Aug 10, 2019 at 10:50 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Runchao,\n>\n>\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu>\n> wrote:\n>\n> > Hi ZmnSCPxj,\n> >\n> > Thanks for your reply.\n> >\n> > I agree with your opinions about OP_LOOKUP_OUTPUT.\n> > Indeed, the pruning mechanism renders this opcode unrealistic for some\n> nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of\n> verifying this tx.\n> >\n> > However, I\u2019m concerning of some security issues of your mentioned\n> protocol (Alice pays the premium contingently on Bob participating).\n> > If I understand it right, Alice and Bob should create a payment channel,\n> and mutually construct the funding transaction that \u201cAlice pays Bob 10,000\n> WJT; Bob hash-timelocked pays Alice 1,000,000WJT\u201d, where the time lock is\n> T+24.\n> > Here, Bob is responsible for broadcasting this tx after confirming\n> Alice\u2019s funding transaction on BTC blockchain.\n>\n> No, Bob is not.\n>\n> The signature exchange for the WJT-side funding tx is done by:\n>\n> 1. Alice waits for Bob to provide all its signatures for inputs that will\n> fund the 1,000,000 WJT payout.\n> 2. Alice signs its inputs that will fund the 10,000 WJT premium.\n> 3. Alice broadacasts the completely signed funding tx.\n>\n> Alice is the one responsible for broadcasting the funding tx.\n>\n> If Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then\n> continue the protocol when the exchange rate moves to its favor) as Alice\n> can refuse to sign and broadcast the funding tx once it has decided Bob is\n> trolling it, thus Bob cannot force Alice to perform.\n>\n> If Alice stalls, Bob can double-spend one of its inputs at a low feerate.\n> This either aborts the protocol, or if Alice then broadcasts the funding\n> tx at the pre-agreed feerate and it is confirmed, the premium is now\n> already paid to Bob.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > In this case, Bob can arbitrage by broadcasting this tx after T+24. In\n> this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT\n> anymore.\n> > If the premium (10,000WJT) is also hash-timelocked, Alice can keep\n> unraveling the preimage, which makes the atomic swap still premium-free.\n> >\n> > In the original atomic swap, Bob is incentivised to broadcast his\n> funding transaction, otherwise he may miss the opportunity to redeem\n> Alice\u2019s asset.\n> > Also, Alice will lose nothing regardless of how Bob behaves, because\n> Alice locks all her money by hashlock.\n> > However, Alice cannot lock the premium using hashlock. This gives Bob\n> opportunity to arbitrage Alice\u2019s premium.\n> >\n> > What is implied here is that, where the premium should go strictly\n> depends on where Bob\u2019s asset goes.\n> > If the Bitcoin\u2019s timelock can be \u201crelative\u201d (e.g. the timestamp can be\n> x+24 where x is the timestamp of the block with this transaction), I think\n> this protocol works.\n> > Unfortunately, the \u201cx\u201d here is also an external state according to your\n> definition.\n> >\n> > In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable,\n> but cannot make sure if the premium mechanism can be implemented by using\n> HTLCs.\n> >\n> > Thanks,\n> > Runchao\n> >\n> > > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:\n> > > Good morning Haoyu LIN et al.,\n> > >\n> > > > We have investigated this problem in very detail. We analysed how\n> profitable the arbitrage can be given the default timelock setting (24/48\n> hrs). Our result shows that the profit can be approximately 1% ~ 2.3%,\n> which is non-negligible compared with 0.3% for stock market. This can be\n> attractive as it's totally risk-free. Please refer to our paper\n> https://eprint.iacr.org/2019/896, and the related code\n> https://github.com/HAOYUatHZ/fair-atomic-swap if interested.\n> > > > Several studies have proposed for solving this problem e.g.,\n> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/\n> and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is\n> that, the transaction for the premium needs to be locked with the same\n> secret hash but with a flipped payout, i.e. when redeemed with the secret,\n> the money goes back to Alice and after timelock, the premium goes to Bob as\n> a compensation for Alice not revealing the secret. However, this introduces\n> a new problem: Bob can get the premium without paying anything, by never\n> participating in.\n> > > > To solve this, the transaction verifier needs to know the status of\n> an dependent transaction. Unfortunately, Bitcoin does not support the\n> stateful transaction functionalities. Therefore, we propose the new opcode:\n> OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of\n> the output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide\n> whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT\n> <pubkeyhash> OP_EQUALVERIFY`.\n> > >\n> > > I believe an unsaid principle of SCRIPT opcode design is this:\n> > >\n> > > -   No SCRIPT opcode can look at anything that is not in the\n> transaction spending from the SCRIPT.\n> > >\n> > > This issue underlies the previous `OP_PUBREF` proposal also.\n> > > The reason for this is:\n> > >\n> > > -   We support a pruning mode, where in only the UTXO set is retained.\n> > >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as\n> `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early\n> historical blocks.\n> > >\n> > > -   The SCRIPT interpreter is run only once, at the time the\n> transaction enters the mempool.\n> > >     Thus it cannot get information about the block it is in.\n> > >     Instead, the SCRIPT interpreter can have as input only the\n> transaction that is attempting to spend the SCRIPT.\n> > >\n> > >\n> > > In any case:\n> > >\n> > > > However, this introduces a new problem: Bob can get the premium\n> without paying anything, by never participating in.\n> > >\n> > > Premium payment can be made contingent on Bob participating.\n> > > Of course, it does mean the premium is paid using the destination coin.\n> > > It also requires the destination coin to support SegWit.\n> > > Let me explain by this:\n> > >\n> > > 1.  Alice and Bob agree on swap parameters:\n> > >\n> > > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.\n> > > -   Alice will pay 10,000 WJT as premium to Bob.\n> > > -   Alice will lock BTC for 48 hours.\n> > > -   Bob will lock WJT for 24 hours.\n> > > -   The protocol will start at particular time T.\n> > >\n> > > 2.  Alice generates a preimage+hash.\n> > > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and\n> timelocked at T+48 going to Alice.\n> > > 4.  Alice presents above UTXO to Bob.\n> > > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT\n> premium to Bob.\n> > > 6.  Alice and Bob generate, but do not sign, a funding transaction\n> spending some of Bob coin as well as the premium coin from Alice.\n> > >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.\n> > >     The hashlock branch requires not just Alice, but also Bob.\n> > >     The timelock branch at T+24 just requires Bob.\n> > >\n> > > 7.  Alice and Bob generate the claim transaction.\n> > >     This spends the funding transaction HTLC output and pays out\n> 1,000,000 WJT to Alice and 10,000 WJT to Bob.\n> > >\n> > > 8.  Alice and Bob sign the claim transaction.\n> > >     This does not allow Bob to make the claim transaction valid by\n> itself as it still requires the preimage, and at this point, only Alice\n> knows the preimage.\n> > >\n> > > 9.  Alice and Bob sign the funding transaction and broadcast it.\n> > > 10.  Alice completes the claim transaction by adding the preimage and\n> broadcasts it.\n> > > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC\n> using the preimage.\n> > >\n> > > If Bob stalls at step 8, then there is no way to claim the premium, as\n> the funding transaction (which is the source of the claim transaction that\n> pays the premium) is not valid yet.\n> > > After step 9, Bob has been forced to participate and cannot back out\n> and claim the premium only.\n> > > This is basically this proposal:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html\n> > > In addition, if you really want the premium to be denominated in BTC,\n> I have a more complicated ritual:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html\n> > > The described ritual only sets up the American Call Option, but by the\n> time it has been set up, the premium has been paid already and the rest of\n> the execution is claiming the American Call Option.\n> > > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.\n> > > Regards,\n> > > ZmnSCPxj\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190810/7ea46c36/attachment-0001.html>"
            },
            {
                "author": "Runchao Han",
                "date": "2019-08-12T03:19:53",
                "message_text_only": "Good morning ZmnSCPxj,\n\nSorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.\n\n\n\n## Analysis on the protocol from Fournier et al.\n\nIn this protocol, Bob participates in the swap following the steps below:\n\n1. Alice and Bob creates a payment channel on WJT blockchain.\n2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice\u2019s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.\n3. Bob signs the WJT transaction and sends the WJT transaction to Alice.\n4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.\n5. Alice broadcasts both the BTC transaction and the WJT transaction.\n\nIn a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.\n\nHere, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice\u2019s signature.\nIf Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.\n\nI have 3 questions on this scheme.\n\nFirst, I\u2019m not sure how do you define \u201cAlice stalls\u201d. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.\nIf 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.\n\nSecond, I\u2019m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.\nIn Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.\n\nThird, let\u2019s optimistically assume Bob can close this payment channel without Alice\u2019s consent.\nNow he decides to close this channel if Alice does not broadcast the WJT tx all the time.\nAlice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.\n\nIn conclusion, Alice\u2019s optionality is not free when she exercises this option, but is free when she aborts this option.\n\n\n\n## What will happen if Alice is responsible for broadcasting both funding txs\n\nIf Alice is responsible for broadcasting both txs, Alice can always abort the swap for free, regardless of how the protocol is designed.\nBasically, Bob officially participates in the swap by signing the WJT tx.\nAfter Bob participating, if Alice hopes to abort the swap, she can just withhold the WJT tx.\n\nIn the original Atomic Swap, Bob participates in the swap by signing and broadcasting the WJT tx, and Alice cannot withhold Bob\u2019s participation.\nHowever, if Alice is responsible for broadcasting Bob\u2019s WJT tx, Alice can withhold Bob\u2019s participation by withholding the WJT tx.\n\nTherefore, I think for Atomic Swap protocol design, Bob should be responsible for broadcasting the WJT tx, otherwise the protocol is impossible to be fair to Bob.\n\n\n\nAgain, sorry for the ambiguity introduced in our last email, and we look forward to hearing from you.\n\nThanks,\nRunchao\n\n\n> On 10 Aug 2019, at 11:01 pm, Runchao Han <runchao.han at monash.edu> wrote:\n> \n> If I remember it right, Alice first signs the WJT transaction, sends it to Bob, then Bob signs it and makes this transaction valid.\n> \n> If so, there are two problems.\n> First, Bob gets the valid tx first, and he can choose not to send it to Alice.\n> Second, even if Bob honestly sends Alice this tx, Alice cannot fully control when to broadcast this to, as Bob also has this transaction.\n> \n> If Bob first signs then Alice signs, Alice still has optionality, as she can choose whether to publish this tx and preimage.\n> \n> Runchao\n> \n> On Sat, Aug 10, 2019 at 10:50 PM ZmnSCPxj <ZmnSCPxj at protonmail.com <mailto:ZmnSCPxj at protonmail.com>> wrote:\n> Good morning Runchao,\n> \n> \n> \n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu <mailto:runchao.han at monash.edu>> wrote:\n> \n> > Hi ZmnSCPxj,\n> >\n> > Thanks for your reply.\n> >\n> > I agree with your opinions about OP_LOOKUP_OUTPUT.\n> > Indeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx.\n> >\n> > However, I\u2019m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).\n> > If I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that \u201cAlice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT\u201d, where the time lock is T+24.\n> > Here, Bob is responsible for broadcasting this tx after confirming Alice\u2019s funding transaction on BTC blockchain.\n> \n> No, Bob is not.\n> \n> The signature exchange for the WJT-side funding tx is done by:\n> \n> 1. Alice waits for Bob to provide all its signatures for inputs that will fund the 1,000,000 WJT payout.\n> 2. Alice signs its inputs that will fund the 10,000 WJT premium.\n> 3. Alice broadacasts the completely signed funding tx.\n> \n> Alice is the one responsible for broadcasting the funding tx.\n> \n> If Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then continue the protocol when the exchange rate moves to its favor) as Alice can refuse to sign and broadcast the funding tx once it has decided Bob is trolling it, thus Bob cannot force Alice to perform.\n> \n> If Alice stalls, Bob can double-spend one of its inputs at a low feerate.\n> This either aborts the protocol, or if Alice then broadcasts the funding tx at the pre-agreed feerate and it is confirmed, the premium is now already paid to Bob.\n> \n> Regards,\n> ZmnSCPxj\n> \n> > In this case, Bob can arbitrage by broadcasting this tx after T+24. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.\n> > If the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.\n> >\n> > In the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice\u2019s asset.\n> > Also, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.\n> > However, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice\u2019s premium.\n> >\n> > What is implied here is that, where the premium should go strictly depends on where Bob\u2019s asset goes.\n> > If the Bitcoin\u2019s timelock can be \u201crelative\u201d (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.\n> > Unfortunately, the \u201cx\u201d here is also an external state according to your definition.\n> >\n> > In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.\n> >\n> > Thanks,\n> > Runchao\n> >\n> > > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com <mailto:ZmnSCPxj at protonmail.com> wrote:\n> > > Good morning Haoyu LIN et al.,\n> > >\n> > > > We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896 <https://eprint.iacr.org/2019/896>, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap <https://github.com/HAOYUatHZ/fair-atomic-swap> if interested.\n> > > > Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ <http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/> and https://coblox.tech/docs/financial_crypto19.pdf <https://coblox.tech/docs/financial_crypto19.pdf>. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n> > > > To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output\u2019s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.\n> > >\n> > > I believe an unsaid principle of SCRIPT opcode design is this:\n> > >\n> > > -   No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.\n> > >\n> > > This issue underlies the previous `OP_PUBREF` proposal also.\n> > > The reason for this is:\n> > >\n> > > -   We support a pruning mode, where in only the UTXO set is retained.\n> > >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.\n> > >\n> > > -   The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.\n> > >     Thus it cannot get information about the block it is in.\n> > >     Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.\n> > >\n> > >\n> > > In any case:\n> > >\n> > > > However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.\n> > >\n> > > Premium payment can be made contingent on Bob participating.\n> > > Of course, it does mean the premium is paid using the destination coin.\n> > > It also requires the destination coin to support SegWit.\n> > > Let me explain by this:\n> > >\n> > > 1.  Alice and Bob agree on swap parameters:\n> > >\n> > > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.\n> > > -   Alice will pay 10,000 WJT as premium to Bob.\n> > > -   Alice will lock BTC for 48 hours.\n> > > -   Bob will lock WJT for 24 hours.\n> > > -   The protocol will start at particular time T.\n> > >\n> > > 2.  Alice generates a preimage+hash.\n> > > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.\n> > > 4.  Alice presents above UTXO to Bob.\n> > > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.\n> > > 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.\n> > >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.\n> > >     The hashlock branch requires not just Alice, but also Bob.\n> > >     The timelock branch at T+24 just requires Bob.\n> > >\n> > > 7.  Alice and Bob generate the claim transaction.\n> > >     This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.\n> > >\n> > > 8.  Alice and Bob sign the claim transaction.\n> > >     This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.\n> > >\n> > > 9.  Alice and Bob sign the funding transaction and broadcast it.\n> > > 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.\n> > > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.\n> > >\n> > > If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.\n> > > After step 9, Bob has been forced to participate and cannot back out and claim the premium only.\n> > > This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html>\n> > > In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html>\n> > > The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.\n> > > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.\n> > > Regards,\n> > > ZmnSCPxj\n> \n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/c4e1a6bd/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-12T08:05:53",
                "message_text_only": "Good morning Runchao,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu> wrote:\n\n> Good morning ZmnSCPxj,\n>\n> Sorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.\n>\n> ## Analysis on the protocol from Fournier et al.\n>\n> In this protocol, Bob participates in the swap following the steps below:\n>\n> 1. Alice and Bob creates a payment channel on WJT blockchain.\n> 2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice\u2019s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.\n> 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.\n> 4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.\n> 5. Alice broadcasts both the BTC transaction and the WJT transaction.\n\nIncorrect.\n\nThe order is below.\nI add also the behavior when the protocol is stalled such that a step is not completed.\n\n1.  Alice broadcasts and confirms a BTC transaction paying an HTLC, hashlock Bob, Timelock Alice.\n    * Alice is initiating the protocol via this step, thus non-completion of this step is simply not performing the protocol.\n2.  Alice informs the BTC transaction to Bob.\n    * If Alice does not perform this, Bob does not know it and Alice locked her own money for no reason.\n3.  Alice and Bob indicate their inputs for the WJT-side funding transaction.\n    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.\n    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n4.  Alice and Bob exchange signatures for the WJT-side claim transaction which spends the funding transaction via the hashlock side and gives 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.\n    Order does not matter as funding  tx is still unsigned.\n    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.\n    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n5.  Bob provides signatures for the WJT funding tx,\n    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n6.  Alice signs WJT funding tx and broacasts and confirms.\n    * If Alice does not perform this, Bob invalidates the transaction by spending any of his inputs.\n      * Alice has an option here, but a very short option: up until Bob grows tired of waiting.\n        Bob can make this timeout arbitrarily small, without requiring input from Alice.\n        What value would there be in a 1-second option, even gotten for free, when Alice has spent fees on the BTC-side transaction in the first place?\n7.  Alice completes the claim transaction and broadcasts.\n    * If Alice does not perform this, Bob simply waits out the timelock and recovers his funds plus premium.\n8.  Bob spends the BTC HTLC via the hashlock path.\n    * If Bob does not perform this, Bob has given money for free to Alice.\n\nThus I do not believe this is needed for blockchain-layer atomic swaps.\n\nFor Lightning-layer atomic swaps, the solution requires that two hashes be used on the WJT side, and is largely the above protocol in very broad strokes.\nUnfortunately, using two hashes instead of one leaks to intermediate hops that the payment involved a cross-currency swap, thus undesirable.\n\n\n\n>\n> In a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.\n>\n> Here, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice\u2019s signature.\n> If Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.\n>\n> I have 3 questions on this scheme.\n>\n> First, I\u2019m not sure how do you define \u201cAlice stalls\u201d. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.\n> If 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.\n\nYes.\n\n>\n> Second, I\u2019m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.\n> In Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.\n\nDepends on how the payment channel is implemented.\nIf you do something like send transactions spending the internal state outputs, then ratifying this later by performing a transaction cut-through to derive the next state update, then it is no different from blockchain layer.\nOf course, if you postulate the non-cooperation of Alice in this, there is indeed a need to close unilaterally.\nBut this is the same as any non-cooperation in any channel system: that is the entire point why you have unilateral closes.\n\n>\n> Third, let\u2019s optimistically assume Bob can close this payment channel without Alice\u2019s consent.\n\nEvery payment channel system worth consideration today has a unilateral close.\nThere is no need for optimism.\n\n> Now he decides to close this channel if Alice does not broadcast the WJT tx all the time.\n> Alice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.\n\nAnd this time frame can be made arbitarily small by Bob by simple threat of unilateral close, thus not making it an option for Alice.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2019-08-12T09:22:29",
                "message_text_only": "Hello Runchao and ZmnSCPxj,\n\nI think we can simplify the explanation here by not using joint signatures\nand payment channel like constructions. ZmnSCPxj's more complex\nconstruction could be more dynamic and practical in some settings but at\nleast for me it gets in the way of capturing how this relatively simple\nidea works.\nHere's my attempt at distilling the idea:\n\nStep 0: Alice and Bob negotiate the parameters (timeouts, refund/redeem\npubkeys, the collateral amounts and inputs/outputs for the WTJ-HTLC)\n\n=== Step 1 ===\n Alice signs and broadcasts the BTC-HTLC and sends signature(s) on her\ninput(s) to the WJT-HLTC to Bob.\nNote:\n1. She does not need to wait for the BTC-HTLC to confirm before she sends\nher signature(s).\n2. There is no benefit to Alice in delaying at this point\n\n=== Step 2 ===\nUpon receiving Alice's input signature(s) and seeing the BTC-HTLC with\nsufficient confirmations, Bob completes the transaction by supplying his\nown signature(s) and broadcasts it.\n\nNote:\n1. Bob's ability to delay at this point shouldn't be considered an option.\nAlice may withdraw her offer by double spending her one of her inputs to\nthe WTJ-HTLC. Alice's ability to cancel the offer and take back BTC after\nthe timeout proves there is no option (options cannot be cancelled)\n2. In this plain construction Alice should cancel promptly (if she doesn't\nsee the WTJ-HTLC within the next 1 or 2 blocks for example)\n3. You could even extend this protocol  to specify that Bob send signatures\non his inputs the WTJ-HTLC immediately to Alice. If he refuses Alice can\ncancel within a second or two.\n\n=== Step 3 ===\nUpon seeing the WTJ-HTLC get sufficient confirmations, Alice takes the\nfunds (including her collateral back) by revealing the secret.\n\nNote:\n1. If she doesn't redeem the HTLC she loses her collateral. Assuming the\nloss of the collateral overwhelms any gain she could experience from the\ndelaying her decision and she operates in her own financial interest she\nredeems it immediately.\n\nStep 4 is as usual.\n\nAt each step there is no unfair advantage to either party (at least if we\nidealise the blockchains somewhat and assume that neither party can\ninfluence which transactions get into which block etc etc).\n\nZmnSCPxj,\n\nThanks for continuing to spread this idea!\nI'm still not sure about your \"two hashes\" approach to lightning but I hope\nto get to the bottom of it soon by describing how I think it should work\nmore formally somewhere. Will post to lightning-dev when I do :)\n\nLL\n\nOn Mon, Aug 12, 2019 at 4:06 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Runchao,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu>\n> wrote:\n>\n> > Good morning ZmnSCPxj,\n> >\n> > Sorry for the ambiguity of my last email. It was Sunday and I wrote it\n> in 1 min on my bed. Let me elaborate what we are thinking of here.\n> >\n> > ## Analysis on the protocol from Fournier et al.\n> >\n> > In this protocol, Bob participates in the swap following the steps below:\n> >\n> > 1. Alice and Bob creates a payment channel on WJT blockchain.\n> > 2. Bob creates the WJT transaction using the joint account of Alice and\n> Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice\u2019s input for the\n> 10,000 WJT premium. This transaction should be signed by both Alice and Bob\n> in order to be valid.\n> > 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.\n> > 4. Alice signs this WJT transaction. At this stage, Alice has both the\n> valid BTC transaction and the valid WJT transaction.\n> > 5. Alice broadcasts both the BTC transaction and the WJT transaction.\n>\n> Incorrect.\n>\n> The order is below.\n> I add also the behavior when the protocol is stalled such that a step is\n> not completed.\n>\n> 1.  Alice broadcasts and confirms a BTC transaction paying an HTLC,\n> hashlock Bob, Timelock Alice.\n>     * Alice is initiating the protocol via this step, thus non-completion\n> of this step is simply not performing the protocol.\n> 2.  Alice informs the BTC transaction to Bob.\n>     * If Alice does not perform this, Bob does not know it and Alice\n> locked her own money for no reason.\n> 3.  Alice and Bob indicate their inputs for the WJT-side funding\n> transaction.\n>     * If Alice does not perform this, it aborts the protocol and Alice\n> locked her own money for no reason.\n>     * If Bob does not perform this, it aborts the protocol and Bob turns\n> down the opportunity to earn 10,000 WJT (opportunity cost).\n> 4.  Alice and Bob exchange signatures for the WJT-side claim transaction\n> which spends the funding transaction via the hashlock side and gives\n> 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.\n>     Order does not matter as funding  tx is still unsigned.\n>     * If Alice does not perform this, it aborts the protocol and Alice\n> locked her own money for no reason.\n>     * If Bob does not perform this, it aborts the protocol and Bob turns\n> down the opportunity to earn 10,000 WJT (opportunity cost).\n> 5.  Bob provides signatures for the WJT funding tx,\n>     * If Bob does not perform this, it aborts the protocol and Bob turns\n> down the opportunity to earn 10,000 WJT (opportunity cost).\n> 6.  Alice signs WJT funding tx and broacasts and confirms.\n>     * If Alice does not perform this, Bob invalidates the transaction by\n> spending any of his inputs.\n>       * Alice has an option here, but a very short option: up until Bob\n> grows tired of waiting.\n>         Bob can make this timeout arbitrarily small, without requiring\n> input from Alice.\n>         What value would there be in a 1-second option, even gotten for\n> free, when Alice has spent fees on the BTC-side transaction in the first\n> place?\n> 7.  Alice completes the claim transaction and broadcasts.\n>     * If Alice does not perform this, Bob simply waits out the timelock\n> and recovers his funds plus premium.\n> 8.  Bob spends the BTC HTLC via the hashlock path.\n>     * If Bob does not perform this, Bob has given money for free to Alice.\n>\n> Thus I do not believe this is needed for blockchain-layer atomic swaps.\n>\n> For Lightning-layer atomic swaps, the solution requires that two hashes be\n> used on the WJT side, and is largely the above protocol in very broad\n> strokes.\n> Unfortunately, using two hashes instead of one leaks to intermediate hops\n> that the payment involved a cross-currency swap, thus undesirable.\n>\n>\n>\n> >\n> > In a word, Bob is responsible for preparing the WJT transaction, while\n> Alice is responsible for preparing the BTC transaction and broadcasting\n> both transactions.\n> >\n> > Here, if Bob stalls, nothing will happen, because Bob cannot spend the\n> 10,000 WJT premium without Alice\u2019s signature.\n> > If Alice stalls, you are saying that Bob can spend the input of\n> 1,000,000 WJT so he does not lose any money.\n> >\n> > I have 3 questions on this scheme.\n> >\n> > First, I\u2019m not sure how do you define \u201cAlice stalls\u201d. In this case,\n> Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding\n> txs but withhold the preimage.\n> > If 2), this protocol is okay. But what about 1) i.e. Alice withholds the\n> WJT tx? Here, Bob cannot do anything except for closing the payment channel\n> and quit.\n>\n> Yes.\n>\n> >\n> > Second, I\u2019m not sure whether Bob can spend his money in this payment\n> channel while the payment channel is still valid.\n> > In Bitcoin, Bob needs to close the payment channel and get back his\n> money first, then he can spend the money.\n>\n> Depends on how the payment channel is implemented.\n> If you do something like send transactions spending the internal state\n> outputs, then ratifying this later by performing a transaction cut-through\n> to derive the next state update, then it is no different from blockchain\n> layer.\n> Of course, if you postulate the non-cooperation of Alice in this, there is\n> indeed a need to close unilaterally.\n> But this is the same as any non-cooperation in any channel system: that is\n> the entire point why you have unilateral closes.\n>\n> >\n> > Third, let\u2019s optimistically assume Bob can close this payment channel\n> without Alice\u2019s consent.\n>\n> Every payment channel system worth consideration today has a unilateral\n> close.\n> There is no need for optimism.\n>\n> > Now he decides to close this channel if Alice does not broadcast the WJT\n> tx all the time.\n> > Alice does not need to pay for the premium if she withholds the WJT tx.\n> If Alice decides not to proceed this swap, Bob should close this channel\n> and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.\n>\n> And this time frame can be made arbitarily small by Bob by simple threat\n> of unilateral close, thus not making it an option for Alice.\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/d3532b48/attachment.html>"
            },
            {
                "author": "Runchao Han",
                "date": "2019-08-12T10:02:33",
                "message_text_only": "Hi ZmnSCPxj,\n\nThanks for your explanation. It\u2019s comprehensive.\n\nI think our disagreement is on the step 6.\nIn step 6,\n\n- Alice can publish or withhold the WJT tx\n- Bob can wait or unilaterally close the WJT payment channel\n\nI see the following things:\n\nFirst, both Alice and Bob can do something on the WJT blockchain at this stage. What will happen if they publish txs simultaneously?\nFor example, Alice publishes WJT tx while Bob publishes the tx closing the channel.\n\nSecond, will the concurrent txs introduce some attacks?  I guess concurrent-while-conflicting txs lead to highly unpredictable behaviours.\nFor example, Alice or Bob uses high tx fee to bribe miners to accept her/his tx, in order to gain some advantage on the concurrent txs?\nAlso, the \u201cwhale transaction\u201d works here. Will this introduce some double-spending variants?\n\nThird, assume Bob doesn\u2019t wait any more and closes the channel. In this case, Bob cannot get the premium.\nThis is not consistent with the original American Call Option, in which Bob should still get the premium.\n\nTo conclude, I find this protocol highly depends on the implementation of the payment channel as well as the expertise of participants (Alice and Bob) c.f. relatively low usability.\nWe may need a suitable payment channel implementation here. What\u2019s your opinion on the payment channel suitable for this scenario?\n\nSincerely,\nRunchao\n\n> On 12 Aug 2019, at 6:05 pm, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Runchao,\n> \n> \n> Sent with ProtonMail Secure Email.\n> \n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu <mailto:runchao.han at monash.edu>> wrote:\n> \n>> Good morning ZmnSCPxj,\n>> \n>> Sorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.\n>> \n>> ## Analysis on the protocol from Fournier et al.\n>> \n>> In this protocol, Bob participates in the swap following the steps below:\n>> \n>> 1. Alice and Bob creates a payment channel on WJT blockchain.\n>> 2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice\u2019s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.\n>> 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.\n>> 4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.\n>> 5. Alice broadcasts both the BTC transaction and the WJT transaction.\n> \n> Incorrect.\n> \n> The order is below.\n> I add also the behavior when the protocol is stalled such that a step is not completed.\n> \n> 1.  Alice broadcasts and confirms a BTC transaction paying an HTLC, hashlock Bob, Timelock Alice.\n>    * Alice is initiating the protocol via this step, thus non-completion of this step is simply not performing the protocol.\n> 2.  Alice informs the BTC transaction to Bob.\n>    * If Alice does not perform this, Bob does not know it and Alice locked her own money for no reason.\n> 3.  Alice and Bob indicate their inputs for the WJT-side funding transaction.\n>    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.\n>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n> 4.  Alice and Bob exchange signatures for the WJT-side claim transaction which spends the funding transaction via the hashlock side and gives 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.\n>    Order does not matter as funding  tx is still unsigned.\n>    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.\n>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n> 5.  Bob provides signatures for the WJT funding tx,\n>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).\n> 6.  Alice signs WJT funding tx and broacasts and confirms.\n>    * If Alice does not perform this, Bob invalidates the transaction by spending any of his inputs.\n>      * Alice has an option here, but a very short option: up until Bob grows tired of waiting.\n>        Bob can make this timeout arbitrarily small, without requiring input from Alice.\n>        What value would there be in a 1-second option, even gotten for free, when Alice has spent fees on the BTC-side transaction in the first place?\n> 7.  Alice completes the claim transaction and broadcasts.\n>    * If Alice does not perform this, Bob simply waits out the timelock and recovers his funds plus premium.\n> 8.  Bob spends the BTC HTLC via the hashlock path.\n>    * If Bob does not perform this, Bob has given money for free to Alice.\n> \n> Thus I do not believe this is needed for blockchain-layer atomic swaps.\n> \n> For Lightning-layer atomic swaps, the solution requires that two hashes be used on the WJT side, and is largely the above protocol in very broad strokes.\n> Unfortunately, using two hashes instead of one leaks to intermediate hops that the payment involved a cross-currency swap, thus undesirable.\n> \n> \n> \n>> \n>> In a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.\n>> \n>> Here, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice\u2019s signature.\n>> If Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.\n>> \n>> I have 3 questions on this scheme.\n>> \n>> First, I\u2019m not sure how do you define \u201cAlice stalls\u201d. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.\n>> If 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.\n> \n> Yes.\n> \n>> \n>> Second, I\u2019m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.\n>> In Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.\n> \n> Depends on how the payment channel is implemented.\n> If you do something like send transactions spending the internal state outputs, then ratifying this later by performing a transaction cut-through to derive the next state update, then it is no different from blockchain layer.\n> Of course, if you postulate the non-cooperation of Alice in this, there is indeed a need to close unilaterally.\n> But this is the same as any non-cooperation in any channel system: that is the entire point why you have unilateral closes.\n> \n>> \n>> Third, let\u2019s optimistically assume Bob can close this payment channel without Alice\u2019s consent.\n> \n> Every payment channel system worth consideration today has a unilateral close.\n> There is no need for optimism.\n> \n>> Now he decides to close this channel if Alice does not broadcast the WJT tx all the time.\n>> Alice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.\n> \n> And this time frame can be made arbitarily small by Bob by simple threat of unilateral close, thus not making it an option for Alice.\n> \n> Regards,\n> ZmnSCPxj\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/260ad41c/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-12T13:15:04",
                "message_text_only": "Good morning Runchao,\n\n> Thanks for your explanation. It\u2019s comprehensive.\n>\n> I think our disagreement is on the step 6.\n> In step 6,\n>\n> - Alice can publish or withhold the WJT tx\n> - Bob can wait or unilaterally close the WJT payment channel\n>\n> I see the following things:\n>\n> First, both Alice and Bob can do something on the WJT blockchain at this stage. What will happen if they publish txs simultaneously?\n> For example, Alice publishes WJT tx while Bob publishes the tx closing the channel.\n\nI am uncertain what you refer to by the \"WJT payment channel\".\nWhat I am proposing here is there is a single funding transaction that will output to a modified HTLC where hashlock is Alice+Bob while Timelock is Bob, spending inputs from both Alice (10,000 WJT) and Bob (1,000,000 WJT).\n\nSo let me rephrase the nearest question as I understand it:\n\n* What happens when Alice broadcasts the funding tx at the same time as Bob double-spends his 1,000,000 WJT input?\n\nAs both transactions spend the same input (the 1,000,000 WJT from Bob) then what happens depends on the miners.\nThe miners decide which transaction is valid and gets confirmed onchain.\n\nThat is the reason why we need large timeouts in the HTLC constructions: we need to give enough time, not only to react to transactions being published, but also to have transactions become deeply confirmed.\nOtherwise we could have made the timelocks so small as to be practically worthless as an option.\n\n>\n> Second, will the concurrent txs introduce some attacks? \u00a0I guess concurrent-while-conflicting txs lead to highly unpredictable behaviours.\n> For example, Alice or Bob uses high tx fee to bribe miners to accept her/his tx, in order to gain some advantage on the concurrent txs?\n> Also, the \u201cwhale transaction\u201d works here. Will this introduce some double-spending variants?\n\nYes, that is why Alice and Bob need to wait for deep confirmations of the transactions involved.\nOnce deeply confirmed, they now know which way the protocol went and can safely perform the next step (or abort the protocol).\n\n>\n> Third, assume Bob doesn\u2019t wait any more and closes the channel. In this case, Bob cannot get the premium.\n> This is not consistent with the original American Call Option, in which Bob should still get the premium.\n\nIt does not matter, because Bob doing so *prevents* the option.\n\nThink of it this way:\n\nSuppose we were to meet face-to-face, in order for you to sell me an options contract.\nNow, suppose I agree to buy the options contract.\nBut, while filling up the paperwork, you change your mind.\n\nUntil the paperwork is properly filled up, the option does not exist.\nThus, until the paperwork is properly filled,, the option is not exerciseable (and I should not pay anything to you since you did not push through with completing the option).\n\nThis is similar in effect.\n\n\n>\n> To conclude, I find this protocol highly depends on the implementation of the payment channel as well as the expertise of participants (Alice and Bob) c.f. relatively low usability.\n> We may need a suitable payment channel implementation here. What\u2019s your opinion on the payment channel suitable for this scenario?\n\nAny payment channel has the problem of non-cooperation by the other side.\nI already mentioned this before.\nAgain, this is always an issue regardless of the existence or non-existence of an `OP_LOOKUP_OUTPUT`: you have to execute onchain activity anyway in order to enforce anything offchain in case of non-cooperation, and adding in the possibility of various attacks makes it more likely that non-cooperation occurs.\nIt is the main reason why I think it is difficult to make Lightning support multiple currencies on the same network.\n\nUsability can always be improved by proper software design; you do not worry about what voltage levels need to be transmitted over the wires in order to transmit your email to me, yet you probably consider your email client quite usable.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "OP_LOOKUP_OUTPUT proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Haoyu LIN",
                "Lloyd Fournier",
                "Runchao Han"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 75034
        }
    },
    {
        "title": "[bitcoin-dev] Taproot proposal",
        "thread_messages": [
            {
                "author": "Elichai Turkel",
                "date": "2019-08-09T14:58:58",
                "message_text_only": "Hi,\nI want to add to John Newbery's suggestion of using implicit even/odd only\npublic keys and tweaked public keys in taproot and suggest the following:\n\nIf everything is implicit then the only reason for the first byte of the\ncontrol block(`c[0]`) is the tapscript leaf version.\nI suggest that this is moved to be the first OP_CODE of the tapscript\nitself (i.e. OP_0/OP_1 etc.)\nThat way having the script *tells* you what does it mean without needing to\ncheck the control block.\nThat way there's a separation between the tapscript+leaf version and the\ncontrol block being the merkle path to the script.\n-- \nPGP: 5607C93B5F86650C\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/8b965583/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-08-09T18:29:55",
                "message_text_only": "On Fri, 9 Aug 2019 at 08:02, Elichai Turkel via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi,\n\nSince the idea of implicitly even pubkeys has potentially more general\nimplications, I've started a separate thread [1] about that idea.\n\n> I want to add to John Newbery's suggestion of using implicit even/odd only public keys and tweaked public keys in taproot and suggest the following:\n> If everything is implicit then the only reason for the first byte of the control block(`c[0]`) is the tapscript leaf version.\n\nThat's unfortunately not correct. If we want to maintain\nbatch-verifiability of the taproot tweaking (the Q = P + H(P,m)G\nrelation), we still need a bit in the control block to convey whether\na negation was necessary to make P+H(P,m)G even, even if P and Q both\nhave implied-even Y coordinates. Not doing that would require\nexploring 2^n combinations to batch verify n relations, obviously\ndestroying any performance savings the batch verification had in the\nfirst place.\n\n> I suggest that this is moved to be the first OP_CODE of the tapscript itself (i.e. OP_0/OP_1 etc.)\n> That way having the script *tells* you what does it mean without needing to check the control block.\n> That way there's a separation between the tapscript+leaf version and the control block being the merkle path to the script.\n\nIf we keep the leaf version idea (it's possible to instead just rely\nentirely on OP_SUCCESSx, and drop leaf versions), my preference is to\nstill keep it separate from script, though just for a fairly banal\nreason: that way the script consists entirely of opcodes and can be\ntreated uniformly by debug tools, rather than needing to treat the\nfirst byte special. I do understand your preference too, but I don't\nknow how it weighs up.\n\n  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017247.html\n\nCheers,\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Taproot proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Elichai Turkel"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2693
        }
    },
    {
        "title": "[bitcoin-dev] 32-byte public keys in Schnorr and Taproot",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2019-08-09T18:16:29",
                "message_text_only": "Hello all,\n\nIt has been suggested [1] to drop the Y oddness bit in the witness\nprogram for Taproot outputs. This seems like a worthwhile change, as:\n* The bit doesn't actually contribute to security.\n* It avoids Taproot outputs from being more expensive to create than v0 P2WSH.\n* It doesn't preclude future changes that would still need the\nadditional byte anyway.\n\nIn exploring that option, Jonas Nick found that it seems cleanest [2]\nto actually introduce a type of 32-byte public keys (which implicitly\nhave an even Y coordinate) in bip-schnorr, with associated signing and\nverification logic that are distinct from the 33-byte variant.\n\nThis makes me wonder if we need 33-byte public keys at all.\n\nSo I'd like to hear opinions about modifying bip-schnorr to only\ndefine 32-byte public keys. The implications of that would be:\n* bip-schnorr public keys wouldn't be exactly the same as ECDSA public\nkeys, however all derivation logic would still apply (BIP32,\nmnemonics, xpubs, ... would still exist and be compatible - just the\nfirst pubkey byte would be dropped at the end).\n* The Q point in bip-taproot (the one going in the scriptPubKey) would\njust follow the 32-byte pubkey encoding, rather than needing a 33rd\nbyte.\n* The P point in bip-taproot (the internal key revealed during script\npath) would become just a 32-byte public key (and we can drop the one\nbit in the control block to transmit the oddness of the Y coordinate\nof P).\n* In order to permit batch verification of the P to Q tweaking for\nscript-path spending, another control block bit is now needed, namely\none that indicates whether a negation was needed to make P+H(P||m)*G's\nY coordinate even.\n* All public keys inside bip-tapscript would also become 32-bytes. If\ndesired, the \"upgradable public key\" construction in bip-tapscript can\nbe kept, by triggering based on the length of public keys (rather than\nbased on their first byte).\n\nOne question is whether it's worth such a change to bip-schnorr at\nthis point. We've purposefully never progressed it past draft since\npublishing [3], but it has been a while. If necessary, it's possible\nto keep verification compatible by still hashing the implied \"even\"\nbyte inside the scheme (which commits to the pubkey), but if we're\ngoing to change things, it's perhaps best to do it as cleanly as\npossible and also drop that byte.\n\nOpinions?\n\n  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016943.html\n  [2] https://github.com/sipa/bips/pull/52\n  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Christopher Allen",
                "date": "2019-08-09T18:37:13",
                "message_text_only": "On Fri, Aug 9, 2019 at 11:17 AM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> if we're going to change things, it's perhaps best to do it as cleanly as\n> possible and also drop that byte.\n>\n\nI personally lean toward just dropping the byte. I like the simplicity and\nI really like 32 bytes. 33 seems so over the edge and so odd ;-)\n\nYes, there may be some prototype implementations out there that did some\nextra work, and will need to be revised, but that is always the risk\ndevelopers take when writing code when the spec hasn't fully been\nimplemented yet.\n\nIf you do revise the spec, would you consider proposing a format for\nsharing public keys in a non-binary form, maybe using bech32? Given some of\nthe protocols emerging that may use Schnorr public keys in novel ways,\nhaving a single encoding format for them would be useful.\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/663436d5/attachment.html>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2019-08-11T06:08:48",
                "message_text_only": "Hello,\n\nIt makes no sense to me to not switch to 32-byte keys. There are\nliterally no (or very mild) disadvantages to this, from what it\nappears like. I don't think refraining from updating a proposal just\nbecause it's been out there for awhile is a valid reason, personally.\n\nOn Sat, Aug 10, 2019 at 3:17 AM Pieter Wuille via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hello all,\n>\n> It has been suggested [1] to drop the Y oddness bit in the witness\n> program for Taproot outputs. This seems like a worthwhile change, as:\n> * The bit doesn't actually contribute to security.\n> * It avoids Taproot outputs from being more expensive to create than v0 P2WSH.\n> * It doesn't preclude future changes that would still need the\n> additional byte anyway.\n>\n> In exploring that option, Jonas Nick found that it seems cleanest [2]\n> to actually introduce a type of 32-byte public keys (which implicitly\n> have an even Y coordinate) in bip-schnorr, with associated signing and\n> verification logic that are distinct from the 33-byte variant.\n>\n> This makes me wonder if we need 33-byte public keys at all.\n>\n> So I'd like to hear opinions about modifying bip-schnorr to only\n> define 32-byte public keys. The implications of that would be:\n> * bip-schnorr public keys wouldn't be exactly the same as ECDSA public\n> keys, however all derivation logic would still apply (BIP32,\n> mnemonics, xpubs, ... would still exist and be compatible - just the\n> first pubkey byte would be dropped at the end).\n> * The Q point in bip-taproot (the one going in the scriptPubKey) would\n> just follow the 32-byte pubkey encoding, rather than needing a 33rd\n> byte.\n> * The P point in bip-taproot (the internal key revealed during script\n> path) would become just a 32-byte public key (and we can drop the one\n> bit in the control block to transmit the oddness of the Y coordinate\n> of P).\n> * In order to permit batch verification of the P to Q tweaking for\n> script-path spending, another control block bit is now needed, namely\n> one that indicates whether a negation was needed to make P+H(P||m)*G's\n> Y coordinate even.\n> * All public keys inside bip-tapscript would also become 32-bytes. If\n> desired, the \"upgradable public key\" construction in bip-tapscript can\n> be kept, by triggering based on the length of public keys (rather than\n> based on their first byte).\n>\n> One question is whether it's worth such a change to bip-schnorr at\n> this point. We've purposefully never progressed it past draft since\n> publishing [3], but it has been a while. If necessary, it's possible\n> to keep verification compatible by still hashing the implied \"even\"\n> byte inside the scheme (which commits to the pubkey), but if we're\n> going to change things, it's perhaps best to do it as cleanly as\n> possible and also drop that byte.\n>\n> Opinions?\n>\n>   [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016943.html\n>   [2] https://github.com/sipa/bips/pull/52\n>   [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "32-byte public keys in Schnorr and Taproot",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Christopher Allen",
                "Karl-Johan Alm"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6930
        }
    },
    {
        "title": "[bitcoin-dev] side memory - Transient memory of an other peer to peer network controlled through the bitcoin utxo set",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-08-14T02:32:40",
                "message_text_only": "It appears to me that there is a generic design pattern for peer to peer networks,\nthat we might call side memory.\n\nThe name is justified with some similarity to side chains. Side memory is however\nnot about a persistent store, but some transient memory of an other peer to peer network.\n\nThe UTXO set is the shared transient memory of the bitcoin network.\n\nJust like we can link the bitcoin block chain with a side chain, we can link\nthe transient memory of an other network with the UTXO set of bitcoin.\n\nThe other network\u2019s transient memory would hold an item until a uniquelly associated\na coin in the UTXO set is unspent. There are many ways to associate data with\nan UTXO. How this is done is not a concern here. The method must however allow\nthe coin to be spent again, so the UTXO set can also trigger eviction of the associated\ndata from the other network\u2019s memory.\n\nThe utility of such association is to impose control and the scarcity of bitcoin to\nsome other network\u2019s transient memory.\n\nSince the number of possible UTXOs is huge (21 million * 100million) an\nassociated peer to peer network will want to raise the bar for UTXOs eligible\nto enter its store.\n\nAn obvious choice for raising the bar is requiring more satoshis to be committed.\nThe other network may dynamically tailor this requirement or let users compete\nfor a fixed capacity by committing higher amounts.\n\nObserving the UTXO set is however not a cheap operation. Nodes of the other\nnetwork would have to also run a bitcoin node to be sure they do not miss\nchanges of the UTXO.\n\nThere is however a way to significantly simplify this task by using time locks and\nSPV validation as follows:\n\nThe UTXO committing to associated data would have a relative timelock, such that\nit can not be spent within n blocks after it entered the UTXO set. (with OP_CSV)\n\nA network node that originally publishes the data would also send an SPV proof\nof the inclusion of associated commitment into the bitcoin blockchain to its peers.\n\nOther network nodes would therefore only need to observe the progress of\nbitcoin\u2019s header chain to validate the proof, which is the commitment transaction\nand the path to merkle root, before accepting data into their transient store.\n\nThe commitment transaction also tells them how long the output can not be spent,\ntherefore they are relived the burden of watching for UTXO spends. Instead they\ncan evict the associated data from their transient store as soon as the header\nchain they oberve is progressed past the relative locktime.\n\nNodes that publish new data would have to listen to all blocks after they\nbroadcast the commitment, until they see it confirmed and can extract the proof.\nThis could be further optimized if BIP158 filters were available and committed.\n\nThe network nodes could use IBLTs (Invertible Bloom Lookup Tables) to distribute\nassociated data.\n\nSuch an associated network would be lightweight since only observing and\nstoring bitcoin\u2019s header chain and its own peer to peer network.\n\nI will soon release the code of a network that implements this design pattern,\nwith the SPV optimization and IBLTs, and am looking for help to test it in a\nlimited deployment, before letting it out into the wild.\n\nPlease drop me a mail if you\u2019d like to help there.\n\nPrior art that I summed up as side memory:\n\nThe idea of linking names with UTXO goes back to the first fork of Bitcoin and\nwas significantly upgraded in the numerifides proposal[1] of tyzbit\n\nZmnSCPxj proposed an advertizement network in which the network's content\nis controlled by associated UTXOs in [2].\n\nI observed that time locked commitments would uncover to bitcoin\u2019s internal\nriskless interest rate [3].\n\nThe pattern is useful as sybill attack protection of coinjoin networks as time locked\ncommitments can act as fidelity bonds [4]\n\nRegards,\n\nTamas Blummer\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001207.html\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017083.html\n[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html\n[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017169.html\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190814/fc771022/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "side memory - Transient memory of an other peer to peer network controlled through the bitcoin utxo set",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tamas Blummer"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4455
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by default",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2019-08-14T15:07:19",
                "message_text_only": "You very clearly didn't bother to read other mails in this thread. To make it easy for you, here's a few links:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017147.html\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017175.html\n\nMatt\n\n> On Aug 13, 2019, at 23:05, Will Madden <will.madden at bridge21.com> wrote:\n> \n> For the record, strong NACK. My understanding is that this breaks several established SPV implementations (such as early breadwallet for sure and possibly current BRD wallets) and I have yet to see quantitative prioritization or even a rational justification for this change.\n> \n> Requiring SPV wallets to communicate with trusted nodes is centralization, and breaking functionality and implementations that enable this without a thoroughly researched rationale is highly suspect.\n> \n>> On Jul 20, 2019, at 1:46 PM, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Just a quick heads-up for those watching the list who may be using it -\n>> in the next Bitcoin Core release bloom filter serving will be turned off\n>> by default. This has been a long time coming, it's been an option for\n>> many releases and has been a well-known DoS vector for some time.\n>> As other DoS vectors have slowly been closed, this has become\n>> increasingly an obvious low-hanging fruit. Those who are using it should\n>> already have long been filtering for NODE_BLOOM-signaling nodes, and I\n>> don't anticipate those being gone any time particularly soon.\n>> \n>> See-also PR at https://github.com/bitcoin/bitcoin/pull/16152\n>> \n>> The release notes will liekly read:\n>> \n>> P2P Changes\n>> -----------\n>> - The default value for the -peerbloomfilters configuration option (and,\n>> thus, NODE_BLOOM support) has been changed to false.\n>> This resolves well-known DoS vectors in Bitcoin Core, especially for\n>> nodes with spinning disks. It is not anticipated that\n>> this will result in a significant lack of availability of\n>> NODE_BLOOM-enabled nodes in the coming years, however, clients\n>> which rely on the availability of NODE_BLOOM-supporting nodes on the\n>> P2P network should consider the process of migrating\n>> to a more modern (and less trustful and privacy-violating) alternative\n>> over the coming years.\n>> \n>> Matt\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190814/bfe67a7a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core to disable Bloom-based Filtering by default",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Matt Corallo"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2674
        }
    },
    {
        "title": "[bitcoin-dev] Burying CSV and segwit soft fork activations",
        "thread_messages": [
            {
                "author": "John Newbery",
                "date": "2019-08-16T15:23:37",
                "message_text_only": "Once a consensus change has been activated and buried by sufficient work,\nwe consider the height of that change to be historic fact. The exact\nactivation method is no longer of practical interest. In some cases the\ncause of activation is not even decidable. For example, we know that segwit\nactivated at height 481,824 but it's debatable whether that was due to BIP\n9 version bits signaling, BIP 148 UASF, or a combination of the two.\n\nIn such cases, we can significantly simplify the implementation by\nhard-coding the activation height. This was done for the 3 ISM soft forks\n(BIPs 34, 66 and 65) in BIP 90 [1] [2]. P2SH and segwit script enforcement\nwere backdated to the genesis block (with the exception of for one block)\nfor similar code simplification reasons [3] [4].\n\n'Burying' deployments in this way provides a number of benefits:\n\n1. consensus code is simplified and implementers can avoid writing and\ntesting code paths that are no longer relevant.\n2. a hard-coded activation height is far easier to review and re-implement\nthan complex deployment activation logic.\n3. using a non-contextual check (in this case a hard-coded constant) can\nprovide performance and code structure benefits (eg reducing lock\ncontention on blockchain data).\n\nBitcoin Core PR 16060 [5] was recently merged, which buries the CSV and\nsegwit activation heights to 419328 and 481824 respectively.\n\nIt is technically possible for this to be a non-backwards compatible\nchange. In the event of a re-org below the BIP9 segwit LOCKED_IN height,\nthis change _could_ cause a chainsplit between pre-0.19 nodes and 0.19\nnodes. Such a re-org would require re-doing over 93% of the total work ever\ncommitted to Bitcoin mining (chainwork is 0x7eb6a652531c5ad6a4b8e9 at\nheight 481824 compared to 0x07d75b9d25fb6602be2b51c6 at height 590393). To\nquote from BIP90:\n\n> The occurrence of such a reorg that would cause the activating block to\nbe disconnected would raise fundamental concerns about the security\nassumptions of Bitcoin, a far bigger issue than any non-backwards\ncompatible change.\n\n> So while this proposal could theoretically result in a consensus split,\nit is extremely unlikely, and in particular any such circumstances would be\nsufficiently damaging to the Bitcoin network to dwarf any concerns about\nthe effects of this proposed change.\n\n(See the 'Considerations' section of BIP 90 for more details).\n\nCheers,\nJohn\n\n[1] https://github.com/bitcoin/bips/blob/master/bip-0090.mediawiki\n[2] https://github.com/bitcoin/bitcoin/pull/8391\n[3]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015588.html\n[4] https://github.com/bitcoin/bitcoin/pull/11739\n[5] https://github.com/bitcoin/bitcoin/pull/16060\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190816/c439614c/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2019-08-16T16:06:50",
                "message_text_only": "On Fri, Aug 16, 2019 at 11:23:37AM -0400, John Newbery via bitcoin-dev wrote:\n> Once a consensus change has been activated and buried by sufficient work,\n> we consider the height of that change to be historic fact. The exact\n> activation method is no longer of practical interest. In some cases the\n> cause of activation is not even decidable. For example, we know that segwit\n> activated at height 481,824 but it's debatable whether that was due to BIP\n> 9 version bits signaling, BIP 148 UASF, or a combination of the two.\n\nI just wanted to elaborate on this excellent point:\n\nThis is debatable because Bitcoin is a decentralized, soft-forks are backwards\ncompatible, and it's very difficult if not impossible to measure the\npreferences of economically significant nodes. Both the BIP9 version bits\nsignalling and the BIP 148 UASF had the same basic effect: enforce segwit.\nFurthermore, the BIP 148 UASF rejected blocks that didn't signal via the BIP9\nversion bits.\n\nWe can observe the fact that 100% of known blocks produced after Aug 1st 2017\nhave complied with segwit rules, and the BIP9 signalling protocol for segwit.\nBut strictly speaking we don't really know why that happened. It's possible\nthat miners were running the BIP9 signalling Bitcoin Core release around that\ntime. It's also possible that miners were running UASF enforcing software.\nIt's possible there was a combination of both. Or even entirely different\nsoftware - remember that some miners produced segwit-valid blocks, but didn't\nactually mine segwit transactions. Each scenario leads to the same externally\nobservable outcome.\n\nFurthermore there's the question as to why miners were producing\nsegwit-compliant blocks: perhaps they thought the vast majority of economically\nsignificant nodes would reject their blocks? Perhaps they just wanted to\nenforce segwit?\n\nThese are all questions that have plausible answers, backed by evidence and\nargument. But because Bitcoin is a decentralized network no authority can tell\nyou what the answers are.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190816/88afef25/attachment.sig>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2019-08-16T17:44:47",
                "message_text_only": "Thanks for adding this to the record.\n\nAnd for the record I\u2019ll reiterate here, as I did with BIP90, that this is a hard fork.\n\ne\n\n> On Aug 16, 2019, at 12:06, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> On Fri, Aug 16, 2019 at 11:23:37AM -0400, John Newbery via bitcoin-dev wrote:\n>> Once a consensus change has been activated and buried by sufficient work,\n>> we consider the height of that change to be historic fact. The exact\n>> activation method is no longer of practical interest. In some cases the\n>> cause of activation is not even decidable. For example, we know that segwit\n>> activated at height 481,824 but it's debatable whether that was due to BIP\n>> 9 version bits signaling, BIP 148 UASF, or a combination of the two.\n> \n> I just wanted to elaborate on this excellent point:\n> \n> This is debatable because Bitcoin is a decentralized, soft-forks are backwards\n> compatible, and it's very difficult if not impossible to measure the\n> preferences of economically significant nodes. Both the BIP9 version bits\n> signalling and the BIP 148 UASF had the same basic effect: enforce segwit.\n> Furthermore, the BIP 148 UASF rejected blocks that didn't signal via the BIP9\n> version bits.\n> \n> We can observe the fact that 100% of known blocks produced after Aug 1st 2017\n> have complied with segwit rules, and the BIP9 signalling protocol for segwit.\n> But strictly speaking we don't really know why that happened. It's possible\n> that miners were running the BIP9 signalling Bitcoin Core release around that\n> time. It's also possible that miners were running UASF enforcing software.\n> It's possible there was a combination of both. Or even entirely different\n> software - remember that some miners produced segwit-valid blocks, but didn't\n> actually mine segwit transactions. Each scenario leads to the same externally\n> observable outcome.\n> \n> Furthermore there's the question as to why miners were producing\n> segwit-compliant blocks: perhaps they thought the vast majority of economically\n> significant nodes would reject their blocks? Perhaps they just wanted to\n> enforce segwit?\n> \n> These are all questions that have plausible answers, backed by evidence and\n> argument. But because Bitcoin is a decentralized network no authority can tell\n> you what the answers are.\n> \n> -- \n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Burying CSV and segwit soft fork activations",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "John Newbery",
                "Peter Todd"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7803
        }
    },
    {
        "title": "[bitcoin-dev] Storm: escrowed storage and messaging at L2/L3",
        "thread_messages": [
            {
                "author": "Dr Maxim Orlovsky",
                "date": "2019-08-19T22:08:09",
                "message_text_only": "Hi,\n\nI'd like to propose a design for distributed storage and messaging with escrow/economic incentivization leveraging LNP/BP ecosystem and working at Layer 2 and 3. It is described in details here: https://github.com/storm-org/storm-spec [1]\n\nBriefly, it allows to construct special type of payment channels guaranteeing remote data storage and retrieval with counterparty risks mitigated by economic stimulus (stakes etc). Next, it can be combined with Lightning Network, i.e. operate completely off-chain (\"Storm with Lightning\" :).\n\nThis proposal came as a side-effect of our joint work on RGB and single-use seals technologies (recently mentioned by Peter Todd here [2]). In the nearest future I will be busy with finalizing and implementing these protocols, but don't want this idea to be missed/forgotten, since it can be very useful for other L2/L3 technologies requiring client-stored data, like guaranteeing external storage of script data for Taproot, scriptless scripts or Prometheus (technology for scalable computing [3]). So I'd welcome any possible comments, critics, or interest in driving Storm development forward.\n\n[1] https://github.com/storm-org/storm-spec\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017257.html\n[3] https://github.com/pandoracore/prometheus-spec/blob/master/prometheus.pdf\n\n------\n\nDr Maxim Orlovsky\nPandora Core AG\nhttps://twitter.com/dr_orlovsky\nhttps://github.com/dr-orlovsky\nxorlovsky[1..]@pandoracore.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190819/31c10a56/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-21T04:14:13",
                "message_text_only": "Good morning Maxim,\n\nInsufficient/unclear Description of Probabilistic Proof\n=======================================================\n\nIt seems to me that the probabilistic checkable proof, whose description I read naively, is not sufficient to prove the statement:\n\n* The source data is the same as the source data originally stored by Alice.\n\nWhen generating the proof, Bob can use the output of any PRNG as the \"source data\".\nIf Alice only checks validity of this proof, then it will accept the output of the PRNG as the actual stored data, which from what I understand is not your goal.\n\nThe probabilistic checkable proof by itself just proves the statement:\n\n* The encrypted data corresponds to the given plaintext.\n\nSo, before Alice sends its local copy of the data to Bob for storage and deletes it, Alice must first compute a Merkle Tree of the data chunks and store the Merkle Tree root (a small 32-byte data).\nAnd the probabilistic checkable proof has to include the Merkle Tree Path proofs of the selected *source* data chunks together with the source chunks.\n\nSimilar problems arise in the pay-for-data scheme proposed in Lightning:https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002035.html\nThe data provider is trusted to give actual data instead of the output of a PRNG.\n\nIn the case of paid storage, Alice had access to the data originally stored (presumably) and can keep a short \"checksum\" of the original data.\n\nIt might be that you imply this in your step 1 for Alice validation of the probabilistic checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:\n\n> With this data Alice will be able to check with this zero-knowledge argument by:\n> 1. Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them\n\nWill the Real Decryption Key Please Stand Up?\n=============================================\n\nAlso, it seems to me that the encryption used must be an asymmetrical encryption.\nThat is, the encryption and decryption keys must be different, with the encryption key being a \"public\" key Bob can safely share with Alice and the decryption key being a \"private\" key that Bob can share only once it has acquired its funds.\n\nAn issue that arises is: while an HTLC is used to atomically transfer the decryption key in exchange for payment, what is the assurance given to Alice that the hash of the decryption key is indeed the hash of the decryption key and not, say, the output of a PRNG?\n\nThat is, Bob must prove:\n\n* The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e\n\n...while revealing only h and e to Alice.\n\nIf there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.\nInstead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.\n\nTransporting Storm Over Lightning\n=================================\n\nOf note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.\nThis is because intermediate nodes potentially become subject to attack in case of routing failure.\n(Though it *may* be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)\n\nThis is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.\nAvoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).\n\nIt may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.\nBut the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-21T07:32:25",
                "message_text_only": "Good morning Maxim,\n\nThe Deaf Bob Attack\n===================\n\nIt seems to me that Bob can promote the N3 problem to the N2 problem.\n\nSuppose Alice contacts Bob to get the data.\nHowever, Bob happens to have lost the data in a tragic boating accident.\n\nNow, supposedly what Alice does in this case would be to broadcast the HTLC settlement transaction, whose signature was provided by Bob during protocol setup.\n\nBut this seems unworkable.\n\n* If Bob managed to sign the HTLC settlement transaction, what `SIGHASH` flags did Bob sign with?\n  * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected the decryption key at setup time.\n  * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including `<Alice> OP_CHECKSIG`.\n\nIf Bob already selected the decryption key at setup time, then Bob can ignore Alice.\n\n* If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.\n* If Alice *does* publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.\n  * The decryption key is useless without the encrypted data!\n\nIt seems this part is not workable?\nAs the decryption key is embedded in the HTLC, Alice cannot get a signature from Bob without the decryption key already being selected by Bob (and thus already claimable even without any data being returned by Bob).\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stefan Richter",
                "date": "2019-08-21T09:33:24",
                "message_text_only": "Please see the github issues and the twitter discussion (e.g. here:\nhttps://twitter.com/stefanwouldgo/status/1163801056423403520) for similar\npoints other people including me have made. At this point I feel there are\nquite a few unclear points in the presentation and it is not clear to me if\nthey can be salvaged.\n\nAm Mi., 21. Aug. 2019 um 09:32 Uhr schrieb ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Good morning Maxim,\n>\n> The Deaf Bob Attack\n> ===================\n>\n> It seems to me that Bob can promote the N3 problem to the N2 problem.\n>\n> Suppose Alice contacts Bob to get the data.\n> However, Bob happens to have lost the data in a tragic boating accident.\n>\n> Now, supposedly what Alice does in this case would be to broadcast the\n> HTLC settlement transaction, whose signature was provided by Bob during\n> protocol setup.\n>\n> But this seems unworkable.\n>\n> * If Bob managed to sign the HTLC settlement transaction, what `SIGHASH`\n> flags did Bob sign with?\n>   * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected\n> the decryption key at setup time.\n>   * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including\n> `<Alice> OP_CHECKSIG`.\n>\n> If Bob already selected the decryption key at setup time, then Bob can\n> ignore Alice.\n>\n> * If Alice does not publish the HTLC settlement transaction, then Bob will\n> eventually enter the N2 state and get the stake+reward.\n> * If Alice *does* publish the HTLC settlement transaction, without Bob\n> giving the encrypted data, then Bob can just use the hashlock and reveal\n> the decryption key.\n>   * The decryption key is useless without the encrypted data!\n>\n> It seems this part is not workable?\n> As the decryption key is embedded in the HTLC, Alice cannot get a\n> signature from Bob without the decryption key already being selected by Bob\n> (and thus already claimable even without any data being returned by Bob).\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190821/25a4c8a0/attachment-0001.html>"
            },
            {
                "author": "Dr Maxim Orlovsky",
                "date": "2019-08-21T17:04:35",
                "message_text_only": "Hi ZmnSCPxj,\n\n> The Deaf Bob Attack\n> =============================================\n\n> -   If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.\n> -   If Alice does publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.\n>     -   The decryption key is useless without the encrypted data!\n\nThat is the main attack already addressed by couple of other guys in different forms; and you have provided the most detailed explanation of it, thank you. I was working for its solution over the last day and I'd like to propose the following update: https://github.com/storm-org/storm-spec/issues/6#issuecomment-523497555\n\nBriefly, I introduce two new intermediary HTLC transactions (called confirmation and fallbacks). Alice has now a choice to sign HTLC fallback tx if she didn't get the data, and in that case she will get her money (reward) back and Bob's stake as a compensation. Bob can \"appeal\" to this by confirming that he had hold the data for Alice. Bob does this by providing a \"preimage\" to the secret hashed by Alice.\n\nThis secret is composed at setup time by Alice, and she uses her newly-derived public key for both funding transaction output and deterministically definition of some small portion of the source data. This portion is double-hashed to 160-bit hash and included into HTLC fallback tx by Alice as a hash lock. Later, when Bob wants to prove that he still has the data available, he see the published HTLC transaction, extracts Alice public key and uses it to get the same deterministic piece of the source data as Alice. Bob computes a single hash on the date, which gives him a preimage to unlock the hash lock from HTLC transaction output before Alice will spend it (Alice's output is timelocked).\n\nThis solution requires Bob to select decription key at setup time, when he pre-signs the transaction, as you correctly have pointed out:\n> If Bob already selected the decryption key at setup time, then Bob can ignore Alice.\n\nNow, we need to aviod situation where by selecting the encryption/decryption pair Bob knows which part of the data he needs to provide Alice in PCP proof, and can discard the rest of the data. This can be mitigated by requiring that the data have to be encrypted using EC multiplication with some factor provided by Alice at the request time.\n\nThe only case for possible cheating now is Alice not needing data anymore and avoiding paying the full amount for the storage. However, this can be a part of the Bob business risk and may be covered by some insurance + Alice's reputation & taken into account by Bob at setup time.\n\nKind regards,\nMaxim Orlovsky"
            },
            {
                "author": "Dr Maxim Orlovsky",
                "date": "2019-08-21T10:51:58",
                "message_text_only": "Hi ZmnSCPxj,\n\nThank you very much for spending your time on analysing my idea at such a deep level \u2013 and writing the detailed review proposing possible solutions to the main found issues.\n\n\n> Insufficient/unclear Description of Probabilistic Proof\n> =======================================================\n>\n> <...>\n> It might be that you imply this in your step 1 for Alice validation of the probabilistically checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:\n>\n>> With these data, Alice will be able to check with this zero-knowledge argument by:\n>> 1. Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them\n\nCorrect, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a \"shot\" from the data in a form of Merkle tree and keep its root for herself, and Bob has to provide her with\n* \"PCP-selected\" blocks of source\n* \"PCP-selected\" blocks of encrypted data\n* siblings of the Merkle root \"leafs\" for the selected source data (required for Alice to check source data paths up to the Merkle root which she had kept for herself)\n* Merkle paths for both of them\n* public key used for the encryption, so Alice can re-encrypt received source data blocks and make sure they are equal to the provided encrypted blocks, so this public key is true\n\n\n> Will the Real Decryption Key Please Stand Up?\n> =============================================\n>\n> Also, it seems to me that the encryption used must be an asymmetrical encryption.\n> That is, the encryption and decryption keys must be different, with the encryption key being a \"public\" key Bob can safely share with Alice and the decryption key being a \"private\" key that Bob can share only once it has acquired its funds.\n\nCorrect, it should be working like in PGP/GPG\n\n\n> That is, Bob must prove:\n>\n> * The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e\n>\n> ...while revealing only h and e to Alice.\n\nYes, that is an important point, I've missed that out.\n\n\n> If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.\n> Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.\n\nA very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC: https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution to the proposal.\n\nIt also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr\u2019s signature features and benefits.\nOne may check https://github.com/KZen-networks/multi-party-ecdsa and papers:\n* https://eprint.iacr.org/2019/114.pdf\n* https://link.springer.com/chapter/10.1007/978-3-319-39555-5_9 https://twitter.com/alexbosworth/status/1163116574238056448\n\nI will investigate that in more details.\n\n\n> Transporting Storm Over Lightning\n> =================================\n>\n> Of note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.\n> This is because intermediate nodes potentially become subject to attack in case of routing failure.\n> (Though it *may* be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs:  https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)\n>\n> This is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.\n> Avoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).\n\n> It may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.\n> But the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.\n\nYou are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.\n\nYour solution to the transporting problem is indeed very interesting, however, I need some time to analyze it in more details. Meanwhile, if you don't mind, I will open an issue on GitHub and will be copying the discussion to there as well, so others from outside of this mail list can also join.\n\nKind regards,\nMaxim Orlovsky\nhttps://github.com/dr-orlovsky"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-21T12:12:30",
                "message_text_only": "Good morning Maxim,\n\nI also sent another email with the below text, it seems to have gotten missed somehow or not sent properly or some other problem.\n\nThe Deaf Bob Attack\n===================\n\nIt seems to me that Bob can promote the N3 problem to the N2 problem.\n\nSuppose Alice contacts Bob to get the data.\nHowever, Bob happens to have lost the data in a tragic boating accident.\n\nNow, supposedly what Alice does in this case would be to broadcast the HTLC settlement transaction, whose signature was provided by Bob during protocol setup.\n\nBut this seems unworkable.\n\n* If Bob managed to sign the HTLC settlement transaction, what `SIGHASH` flags did Bob sign with?\n  * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected the decryption key at setup time.\n  * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including `<Alice> OP_CHECKSIG`.\n\nIf Bob already selected the decryption key at setup time, then Bob can ignore Alice.\n\n* If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.\n* If Alice *does* publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.\n  * The decryption key is useless without the encrypted data!\n\nIt seems this part is not workable?\nAs the decryption key is embedded in the HTLC, Alice cannot get a signature from Bob without the decryption key already being selected by Bob (and thus already claimable even without any data being returned by Bob).\n\nRegards,\nZmnSCPxj\n\n> Hi ZmnSCPxj,\n>\n> Thank you very much for spending your time on analysing my idea at such deep level \u2013 and writing the detailed review proposing possible solutions to the main found issues.\n>\n> > Insufficient/unclear Description of Probabilistic Proof\n> >\n> > ========================================================\n> >\n> > <...>\n> > It might be that you imply this in your step 1 for Alice validation of the probabilistic checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:\n> >\n> > > With this data Alice will be able to check with this zero-knowledge argument by:\n> > >\n> > > 1.  Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them\n>\n> Correct, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a \"shot\" from the data in a form of Merkle tree and keep its root for herself, and Bob has to provide her with\n>\n> -   \"PCP-selected\" blocks of source\n> -   \"PCP-selected\" blocks of encrypted data\n> -   siblings of the Merkle root \"leafs\" for the selected source data (required for Alice to check source data paths up to the Merkle root which she had kept for herself)\n> -   Merkle paths for both of them\n> -   public key used for the encryption, so Alice can re-encrypt received source data blocks and make sure they are equal to the provided encrypted blocks, so this public key is true\n>\n>\n> > Will the Real Decryption Key Please Stand Up?\n> >\n> > ==============================================\n> >\n> > Also, it seems to me that the encryption used must be an asymmetrical encryption.\n> > That is, the encryption and decryption keys must be different, with the encryption key being a \"public\" key Bob can safely share with Alice and the decryption key being a \"private\" key that Bob can share only once it has acquired its funds.\n>\n> Correct, it should be working like in PGP/GPG\n>\n> > That is, Bob must prove:\n> >\n> > -   The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e\n> >\n> > ...while revealing only h and e to Alice.\n>\n> Yes, that is an important point, I've missed that out.\n>\n> > If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.\n> > Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.\n>\n> Very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC:https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution into the proposal.\n>\n> It also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr\u2019s signature features and benefits.\n> One may check https://github.com/KZen-networks/multi-party-ecdsa and papers:\n>\n> -   https://eprint.iacr.org/2019/114.pdf\n> -   https://link.springer.com/chapter/10.1007/978-3-319-39555-5_9 https://twitter.com/alexbosworth/status/1163116574238056448\n>\n>     I will investigate that in more details.\n>\n>\n> > Transporting Storm Over Lightning\n> >\n> > ==================================\n> >\n> > Of note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.\n> > This is because intermediate nodes potentially become subject to attack in case of routing failure.\n> > (Though it may be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)\n> > This is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.\n> > Avoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).\n> > It may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.\n> > But the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.\n>\n> You are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.\n>\n> Your solution to the transporting problem is indeed very interesting, however I need some time to analyze it in more details. Meanwhile, if you don't mind, I will open an issue in GitHub and will be copying the discussion to there as well, so others from outside of this mail list can also join.\n>\n> Kind regards,\n> Maxim Orlovsky\n> https://github.com/dr-orlovsky"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-21T12:48:16",
                "message_text_only": "Good morning Maxim,\n\n> > <...>\n> > It might be that you imply this in your step 1 for Alice validation of the probabilistically checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:\n> >\n> > > With these data, Alice will be able to check with this zero-knowledge argument by:\n> > >\n> > > 1.  Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them\n>\n> Correct, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a \"shot\" from the data in a form of Merkle tree and keep its root for herself\n\nThank you for the clarification, indeed it is better to explicit this step.\n\n> > If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.\n> > Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.\n>\n> A very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC:https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution to the proposal.\n>\n> It also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr\u2019s signature features and benefits.\n> One may check https://github.com/KZen-networks/multi-party-ecdsa and papers\n\nI did mention 2p-ECDSA, which the last time I checked, was the \"best\" available multiparty ECDSA.\nI have not checked in detail the relative security details of 2p-ECDSA compared to the various multiparty ECDSAs.\n\nIn this particular case this is only between two parties, thus 2p-ECDSA should be sufficient.\n\nhttps://eprint.iacr.org/2011/494.pdf\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html\n\nI have not checked your links and it is possible we are referring to the exact same thing, or your t-ECDSA is a strict improvement over 2p-ECDSA.\n\n\n> You are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.\n\nStrictly speaking, dual-funding is completely and totally unnecessary.\nAs submarine swaps / off-to-onchain swaps are already possible, a simple ritual like the below can emulate dual-funding (at the cost that one side must own the total they agree on onchain):\n\n1.  Alice and Bob agree to each put 10mBTC each to form 20mBTC channel.\n2.  Alice happens to have 20mBTC onchain in her pocket, while Bob has 10mBTC.\n3.  Bob puts his 10mBTC into an onchain 10mBTC HTLC with locktime 2*L paying to Bob, hashlock paying to Alice (with a preimage known only by Bob).\n4.  Alice sets up the 20mBTC channel using her 20mBTC onchain.\n5.  After the channel funding tx is deeply confirmed, Alice forwards a 10mBTC HTLC over that channel with locktime L paying to Alice, hashlock paying to Bob (with the same hash as the above).\n6.  Bob claims the payment offchain.\n7.  Alice can now claim the onchain payment.\n8.  Alice and Bob now have a perfectly balanced channel (as all channels should be), while Alice is now in possession of an extra 10mBTC onchain.\n    So Alice has 10mBTC offchain, 10mBTC onchain, while Bob has 10mBTC offchain on the same channel.\n\nDual-funding simply makes the above *much* more efficient, but is not strictly necessary in a world where atomic cross-system swaps are already possible.\n>From this point of view, every distinct channel is a unique cryptocurrency system, and if atomic cross-system swaps are possible at all, it is immaterial if one system is a blockchain and the other is a payment channel, etc.\n\nYou may also be interested in Fulgurite.\nThis is a project to \"split\" a channel into Lightning part and DLC (discreet log contract) part.\nThe reason for splitting is because LN is expected to have much more state updates than DLC (you forward payments all the time, but set up only a few DLCs with direct counterparties).\nDLCs require a lot of signatures if they are reanchored to a new state update transaction, so splitting the channel into an LN part with many updates and a DLC part with few updates is sensible to reduce processing and bandwidth.\nSimilar reasoning may hold for Storm.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Storm: escrowed storage and messaging at L2/L3",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Stefan Richter",
                "Dr Maxim Orlovsky"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 31100
        }
    },
    {
        "title": "[bitcoin-dev] Miniscript",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2019-08-19T23:17:21",
                "message_text_only": "Hi all,\n\nMiniscript is a project we've been working on for the past year or so,\nand is now at a stage where I'd like to get it some more attention. It is joint\nwork with Andrew Poelstra and Sanket Sanjalkar.\n\nIt's a language for writing (a subset of) Bitcoin Scripts in a structured way,\nenabling analysis, composition, generic signing and more.\n\nFor example the script\n\n  <A> OP_CHECKSIG OP_IFDUP OP_NOTIF OP_DUP OP_HASH160 <hash160(B)>\n  OP_EQUALVERIFY OP_CHECKSIGVERIFY <144> OP_CSV OP_ENDIF\n\nin Miniscript notation would be\n\n  or_d(c:pk(A),and_v(vc:pk_h(B),older(144)))\n\nmaking it human (engineer?) readable that this is a script that permits A to\ntake the coins at any time, and B after 1 day. A full description of the\nlanguage can be found on the project website http://bitcoin.sipa.be/miniscript\n\nUsing Miniscript it's possible to:\n* Write descriptors for addresses for scripts that implement things more\n  complicated than multisig.\n* Make software that can deal with composition of policies (e.g. have funds\n  in a 2-of-3 setup where one of the 3 \"keys\" is itself a policy that involves\n  perhaps multiple devices and timeouts).\n* Compile complex spending policies to efficient scripts.\n* Figure out under what necessary and/or sufficient conditions a script can be\n  satisfied.\n* Given signatures for a sufficient set of keys (and hash preimages, if needed),\n  generically construct a witness for arbitrary scripts, without metadata\n  apart from the script itself and public keys appearing in it. This means\n  generic PSBT signers are possible for this class of scripts.\n* Compute the bounds on the size of a witness for arbitrary scripts.\n* Perform static analysis to see if any of Script's resource limitations\n  (ops limit, stack size, ...) might interfere with the ability to spend.\n* Who knows what else...\n\nWe have two implementations:\n* a C++ one (https://github.com/sipa/miniscript)\n* a Rust library (https://github.com/apoelstra/rust-miniscript).\n\nThe implementations are a work in progress, but through large scale randomized\ntests we have confidence that the language design and associated witnesses are\ncompatible with the existing consensus and standardness rules.\n\nTo be clear: Miniscript is designed for Bitcoin as it exists today (primarily\nP2WSH), and does not need any consensus changes. That said, we plan to extend\nthe design to support future script changes Bitcoin may include.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "David Vorick",
                "date": "2019-08-20T07:15:24",
                "message_text_only": "Glad to see this post. I have been following Miniscript for some time, and\nthe static\nanalysis that is possible with Miniscript is particularly interesting to me.\n\nToday, new Bitcoin applications such as JoinMarket, Wasabi wallet, and\nArwen all\nsuffer from a problem of having novel bitcoin scripts. Bitcoin script is\nnot easy to\nanalyze, and historically it has been difficult for me to get comfortable\nusing these\napplications because I have been unable to convince myself to have complete\nconfidence in the integrity of the transactions these applications want me\nto sign.\n\nWell established applications can eventually overcome this issue for users\nby\ngetting sufficient expert review and commentary, however this proves as a\nsubstantial barrier to entry in an ecosystem that is ideally as open as\npossible.\n\nMiniscript can make a huge difference here. With Miniscript, it possible to\ncreate\nhardware wallets that can perform static analysis on novel miniscripts and\nprovide\nthe user with assurances about the nature of the transactions. A hardware\nwallet\nwith a Miniscript analyzer may not be able to tell you that a transaction\nis a\nCoinJoin transaction, but it will be able to tell you that under all\npossible scenarios,\nyou end up with just as many coins in your addresses that you started with,\nmodulo\nsome transaction fee.\n\nThis is a big deal for novel application writers, as it significantly\nreduces the barrier\nfor them to convince both themselves and others that the code they wrote\ndoes not\nrisk user funds being lost, especially if all transactions are being\nexternally analyzed\nand signed.\n\nMiniscript is not of course a complete solution, for example it cannot\nsolve all of the\nhigh-risk edge cases that are present in the lightning network, but it is a\nbig step\nforward and I believe that widespread use of Miniscript would be a huge\nboon to the\nBitcoin ecosystem.\n\nOn Mon, Aug 19, 2019 at 7:18 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Miniscript is a project we've been working on for the past year or so,\n> and is now at a stage where I'd like to get it some more attention. It is\n> joint\n> work with Andrew Poelstra and Sanket Sanjalkar.\n>\n> It's a language for writing (a subset of) Bitcoin Scripts in a structured\n> way,\n> enabling analysis, composition, generic signing and more.\n>\n> For example the script\n>\n>   <A> OP_CHECKSIG OP_IFDUP OP_NOTIF OP_DUP OP_HASH160 <hash160(B)>\n>   OP_EQUALVERIFY OP_CHECKSIGVERIFY <144> OP_CSV OP_ENDIF\n>\n> in Miniscript notation would be\n>\n>   or_d(c:pk(A),and_v(vc:pk_h(B),older(144)))\n>\n> making it human (engineer?) readable that this is a script that permits A\n> to\n> take the coins at any time, and B after 1 day. A full description of the\n> language can be found on the project website\n> http://bitcoin.sipa.be/miniscript\n>\n> Using Miniscript it's possible to:\n> * Write descriptors for addresses for scripts that implement things more\n>   complicated than multisig.\n> * Make software that can deal with composition of policies (e.g. have funds\n>   in a 2-of-3 setup where one of the 3 \"keys\" is itself a policy that\n> involves\n>   perhaps multiple devices and timeouts).\n> * Compile complex spending policies to efficient scripts.\n> * Figure out under what necessary and/or sufficient conditions a script\n> can be\n>   satisfied.\n> * Given signatures for a sufficient set of keys (and hash preimages, if\n> needed),\n>   generically construct a witness for arbitrary scripts, without metadata\n>   apart from the script itself and public keys appearing in it. This means\n>   generic PSBT signers are possible for this class of scripts.\n> * Compute the bounds on the size of a witness for arbitrary scripts.\n> * Perform static analysis to see if any of Script's resource limitations\n>   (ops limit, stack size, ...) might interfere with the ability to spend.\n> * Who knows what else...\n>\n> We have two implementations:\n> * a C++ one (https://github.com/sipa/miniscript)\n> * a Rust library (https://github.com/apoelstra/rust-miniscript).\n>\n> The implementations are a work in progress, but through large scale\n> randomized\n> tests we have confidence that the language design and associated witnesses\n> are\n> compatible with the existing consensus and standardness rules.\n>\n> To be clear: Miniscript is designed for Bitcoin as it exists today\n> (primarily\n> P2WSH), and does not need any consensus changes. That said, we plan to\n> extend\n> the design to support future script changes Bitcoin may include.\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190820/7f2e5916/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-08-20T08:14:13",
                "message_text_only": "Good morning David,\n\n> Today, new Bitcoin applications such as JoinMarket, Wasabi wallet, and Arwen all\n> suffer from a problem of having novel bitcoin scripts.\n\nFor CoinJoin (JoinMarket, Wasabi) at least, I believe there is no need of novel Bitcoin SCRIPTs.\nIndeed, from what I can tell they use only P2WPKH `SIGHASH_ALL` signatures and P2WPKH outputs: there seems to be nothing to analyze there.\n\nI do not believe Miniscript would benefit those in particular.\n(though miniscript does have other benefits as well: in particular sufficiently-advanced miniscript compilers will be able to write shorter SCRIPTs than mere unaided humans can)\n\nI have not investigated much of Arwen yet but it seems to me to be a sort of exchange-specific payment-channel implementation.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Miniscript",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Pieter Wuille",
                "David Vorick"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8136
        }
    }
]