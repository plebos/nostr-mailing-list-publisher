[
    {
        "title": "[bitcoin-dev] bitcoin-transactions",
        "thread_messages": [
            {
                "author": "Marcel Jamin",
                "date": "2018-08-01T05:45:54",
                "message_text_only": "IMHO you should almost never publish a service that asks users for private\nkeys.\n\nA warning isn't enough. Your server might get compromised.\n\n\"Move your coins by yourself\" isn't even correct if your server is involved.\n\nOn Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I know this list is not to advertise personal projects but\n> https://peersm.com/wallet might be of some interest, this is the web\n> interface for https://github.com/Ayms/bitcoin-transactions since\n> apparently quasi nobody succeeds to use it\n>\n> As far as I know (and surprisingly) this is the only online tool that\n> converts bech32 addresses (Sipa's one does not output something\n> understandable by everybody, the tool is using his code), the only one\n> that converts from any address to any address, maybe the only one that\n> decodes simply redeem scripts and probably the only one that allows to\n> create transactions by its own (the advanced mode is not implemented for\n> now but will be soon)\n>\n> Ideally it should be an offline tool if there is some incentive to do\n> so, so of course it is not advised to use his private keys for now\n>\n> Maybe they are mistaken but some users are reporting invalid bech32\n> addresses from their Electrum wallet, after segwit, bech32 confusion\n> seems to be the topic of the moment\n>\n> Regards\n>\n> Aymeric\n>\n> --\n> Bitcoin transactions made simple:\n> https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist:\n> http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/7f4e4e8f/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-08-01T09:58:43",
                "message_text_only": "You are right, that's what I have been saying for online services that\nask for private keys, and even the seeds\n\nThe problem is that people can't refrain to put their keys for example\nto get \"free\" coins, typically they try to use bitcoin-transactions,\ndon't succeed and go put their seeds in an online service\n\nAt least it gives an alternative, private keys are optional and the tool\nwill output the command to use with bitcoin-transactions, and if they\nwant to put directly their keys, then...\n\n\"Move your coins by yourself\" refers more to \"don't get trapped by your\nwallet(s) or things that you don't master like multisig, segwit, bech32,\netc\"\n\nAs I said the idea would be to end up with an offline tool should some\npeople support/finance the effort\n\n\nLe 01/08/2018 \u00e0 07:45, Marcel Jamin a \u00e9crit\u00a0:\n> IMHO you should almost never publish a service that asks users for\n> private keys.\n>\n> A warning isn't enough. Your server might get compromised.\n>\n> \"Move your coins by yourself\" isn't even correct if your server is\n> involved.\n>\n> On Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     I know this list is not to advertise personal projects but\n>     https://peersm.com/wallet might be of some interest, this is the web\n>     interface for https://github.com/Ayms/bitcoin-transactions since\n>     apparently quasi nobody succeeds to use it\n>\n>     As far as I know (and surprisingly) this is the only online tool that\n>     converts bech32 addresses (Sipa's one does not output something\n>     understandable by everybody, the tool is using his code), the only one\n>     that converts from any address to any address, maybe the only one that\n>     decodes simply redeem scripts and probably the only one that allows to\n>     create transactions by its own (the advanced mode is not\n>     implemented for\n>     now but will be soon)\n>\n>     Ideally it should be an offline tool if there is some incentive to do\n>     so, so of course it is not advised to use his private keys for now\n>\n>     Maybe they are mistaken but some users are reporting invalid bech32\n>     addresses from their Electrum wallet, after segwit, bech32 confusion\n>     seems to be the topic of the moment\n>\n>     Regards\n>\n>     Aymeric\n>\n>     -- \n>     Bitcoin transactions made simple:\n>     https://github.com/Ayms/bitcoin-transactions\n>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n>     Check the 10 M passwords list: http://peersm.com/findmyass\n>     Anti-spies and private torrents, dynamic blocklist:\n>     http://torrent-live.org\n>     Peersm : http://www.peersm.com\n>     torrent-live: https://github.com/Ayms/torrent-live\n>     node-Tor : https://www.github.com/Ayms/node-Tor\n>     GitHub : https://www.github.com/Ayms\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/b5b352ad/attachment.html>"
            },
            {
                "author": "hth lipsch",
                "date": "2018-08-09T08:38:09",
                "message_text_only": "private-key WEF WIF online/offline transaction services, without a fee are\nnot in the interest of mainstream bitcoin users.(gaius germanicus)\nBitcoin has grown into a Christmas tree fancy dress in the last 9 years\nwhere efficiency and simplicity should be mandatory and hardcoded.\n\non the other hand, a safe and secure tool would be a welcome step in the\nright direction\n\nlipsch hth\n\n\n\n\n\nOp wo 1 aug. 2018 11:59 schreef Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> You are right, that's what I have been saying for online services that ask\n> for private keys, and even the seeds\n>\n> The problem is that people can't refrain to put their keys for example to\n> get \"free\" coins, typically they try to use bitcoin-transactions, don't\n> succeed and go put their seeds in an online service\n>\n> At least it gives an alternative, private keys are optional and the tool\n> will output the command to use with bitcoin-transactions, and if they want\n> to put directly their keys, then...\n>\n> \"Move your coins by yourself\" refers more to \"don't get trapped by your\n> wallet(s) or things that you don't master like multisig, segwit, bech32,\n> etc\"\n>\n> As I said the idea would be to end up with an offline tool should some\n> people support/finance the effort\n>\n> Le 01/08/2018 \u00e0 07:45, Marcel Jamin a \u00e9crit :\n>\n> IMHO you should almost never publish a service that asks users for private\n> keys.\n>\n> A warning isn't enough. Your server might get compromised.\n>\n> \"Move your coins by yourself\" isn't even correct if your server is\n> involved.\n>\n> On Tue, 31 Jul 2018 at 13:26, Aymeric Vitte via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I know this list is not to advertise personal projects but\n>> https://peersm.com/wallet might be of some interest, this is the web\n>> interface for https://github.com/Ayms/bitcoin-transactions since\n>> apparently quasi nobody succeeds to use it\n>>\n>> As far as I know (and surprisingly) this is the only online tool that\n>> converts bech32 addresses (Sipa's one does not output something\n>> understandable by everybody, the tool is using his code), the only one\n>> that converts from any address to any address, maybe the only one that\n>> decodes simply redeem scripts and probably the only one that allows to\n>> create transactions by its own (the advanced mode is not implemented for\n>> now but will be soon)\n>>\n>> Ideally it should be an offline tool if there is some incentive to do\n>> so, so of course it is not advised to use his private keys for now\n>>\n>> Maybe they are mistaken but some users are reporting invalid bech32\n>> addresses from their Electrum wallet, after segwit, bech32 confusion\n>> seems to be the topic of the moment\n>>\n>> Regards\n>>\n>> Aymeric\n>>\n>> --\n>> Bitcoin transactions made simple:\n>> https://github.com/Ayms/bitcoin-transactions\n>> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n>> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n>> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n>> Check the 10 M passwords list: http://peersm.com/findmyass\n>> Anti-spies and private torrents, dynamic blocklist:\n>> http://torrent-live.org\n>> Peersm : http://www.peersm.com\n>> torrent-live: https://github.com/Ayms/torrent-live\n>> node-Tor : https://www.github.com/Ayms/node-Tor\n>> GitHub : https://www.github.com/Ayms\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n> --\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180809/222cfc52/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Marcel Jamin",
                "hth lipsch",
                "Aymeric Vitte"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10944
        }
    },
    {
        "title": "[bitcoin-dev] BIP171 - Mocked implementation, generated specs, live API and 16 clients libs",
        "thread_messages": [
            {
                "author": "St\u00e9phane Traumat",
                "date": "2018-08-01T08:08:55",
                "message_text_only": "I just released CERISE (website <http://www.cerise.tech/> & github\n<https://github.com/straumat/cerise>) a project with the following\nartifacts :\n\n   -\n\n   A mocked server implementation to start developing clients :\n   https://github.com/straumat/cerise.\n   -\n\n   A live & documented API to understand and directly calls the methods :\n   http://api.cerise.tech/docs.\n   -\n\n   Specifications of the four methods : Enumerating supported currency-pair\n   tokens\n   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/supportedCurrencyPairTokensAPI.html>\n   , Currency-pair information\n   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/currencyPairInformationAPI.html>\n   , Current exchange rate\n   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/currentExchangeRateAPI.html>\n    & Historical exchange rates\n   <http://www.cerise.tech/specifications/0.3-SNAPSHOT/historicalExchangeRatesAPI.html>\n   .\n   -\n\n   16 client librairies for various langages (Java, PHP, c++, Rusty,\n   Ruby\u2026.) : http://www.cerise.tech/#clients.\n   -\n\n   and i\u2019m working on a template project to allow developers to quickly\n   build a BIP171 compliant server without having to worrying about parameters\n   validation, security, rest mechanics\u2026 will be done in september.\n\n-- \n*St\u00e9phane Traumat*\nhttps://about.me/straumat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180801/2b0e5d4a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP171 - Mocked implementation, generated specs, live API and 16 clients libs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "St\u00e9phane Traumat"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1485
        }
    },
    {
        "title": "[bitcoin-dev] BLS library released",
        "thread_messages": [
            {
                "author": "Bram Cohen",
                "date": "2018-08-03T18:22:48",
                "message_text_only": "BLS signatures have the same aggregation feature as Schnorr signatures but\neven better because the aggregation can be done non-interactively, at the\nexpense of being a bit slower. We just released a first draft (but fully\nfunctional) library for doing BLS signatures based on a construction based\non musig. Feedback, discussion, and usage is very welcome.\n\nhttps://github.com/Chia-Network/bls-signatures\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/64cf8b43/attachment.html>"
            },
            {
                "author": "M Bz",
                "date": "2018-08-03T23:28:02",
                "message_text_only": "nice! how does it compare to Shigeo's implementation?\nhttps://github.com/herumi/bls\n\nOn Fri, Aug 3, 2018 at 7:10 PM Bram Cohen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> BLS signatures have the same aggregation feature as Schnorr signatures but\n> even better because the aggregation can be done non-interactively, at the\n> expense of being a bit slower. We just released a first draft (but fully\n> functional) library for doing BLS signatures based on a construction based\n> on musig. Feedback, discussion, and usage is very welcome.\n>\n> https://github.com/Chia-Network/bls-signatures\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/591ffaf8/attachment.html>"
            },
            {
                "author": "Alexander Leishman",
                "date": "2018-08-03T23:53:29",
                "message_text_only": "Awesome! Haven\u2019t had the chance to run it myself yet, so curious what benchmarks you are getting?\n\nBest,\nAlex \n\n> On Aug 3, 2018, at 14:22, Bram Cohen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> BLS signatures have the same aggregation feature as Schnorr signatures but even better because the aggregation can be done non-interactively, at the expense of being a bit slower. We just released a first draft (but fully functional) library for doing BLS signatures based on a construction based on musig. Feedback, discussion, and usage is very welcome.\n> \n> https://github.com/Chia-Network/bls-signatures\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180803/4f4dc17d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BLS library released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bram Cohen",
                "M Bz",
                "Alexander Leishman"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2569
        }
    },
    {
        "title": "[bitcoin-dev] Schnorr signatures BIP",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2018-08-04T12:22:28",
                "message_text_only": "I propose changing the verification equation from \"Let *R = sG - eP*\" to\n\n    Let *R = sG + eP*\n\nThis allows faster verification by avoiding negating a point (or a\ncoefficient).\n\n\nIf, instead of directly following the literal verification specification,\none is instead reconstructing R from r by finding a y coordinate that is a\nquadratic residue, under the existing scheme one would verify\n\n\n*sG - eP = R*\n\nwhich is effectively verifying\n\n  0 = *sG - eP* - R  or 0 = R - *sG + eP*\n\nEither way one needs to negate at least one point (or one coefficient)\nbecause of the opposite signs between sG and eP.\n\n\nUnder my proposed revised verification scheme, one would instead verify\n\n  0 = sG + eP + (-R).\n\nWhile it seems that this requires negating R, it does not.  Rather (-R) can\nbe directly constructed from r by finding a y coordinate that is *not* a\nquadratic residue, which is precisely the same amount of work that\nconstruction R from r was.\n\nIn either verification procedure, changing the verification equation to my\nproposal removes one negation operation from the cost of doing verification.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180804/2fc635e5/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-08-05T14:33:52",
                "message_text_only": "Over chat it has been pointed out to me that computing the non-quadratic\nresidue is not the same cost as computing a quadratic residue.  As pointed\nout in footnote 7 of the the proposed BIP, c^((p+1)/4) is always a\nquadratic residue and must be negated to find the non-quadratic residue.\n\nIn light of this, I revise my proposed change to make the verification\nequation\n\nR + sG + eP = 0.\n\n(by 0 in the equation above I mean the identity element for the (+)\noperation, which is the point at infinity.)\n\nThis equation is suitable for batch verification.  This equation is clearly\nwritten as a linear combination that doesn't use negation.  In most\nimplementations, equality comparison tests are implemented by subtraction\nand a comparison with zero. By writing the verification equation this way,\nwe clearly see that only the comparison with zero test is needed.\n\nFor single signature verification the check becomes, compute Q := sG + eP.\nVerify that Q isn't the point at infinity and Q.x = r.  Verify that Q.y is\n*not* a quadratic residue. (While I was incorrect earlier about the costs\nof computing a non-residue, it is the case the *verifying* a value is a\nquadratic residue is the same cost as verifying a value is a non-residue.)\n\nEffectively in my first email I was suggesting that the 'e' value in a\nsignature be negated from the current BIP proposal.  In this revision I am\neffectively suggesting that the 's' value in a signature should be the one\nthat is negated instead.\n\nOn Sat, Aug 4, 2018 at 8:22 AM, Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> I propose changing the verification equation from \"Let *R = sG - eP*\" to\n>\n>     Let *R = sG + eP*\n>\n> This allows faster verification by avoiding negating a point (or a\n> coefficient).\n>\n>\n> If, instead of directly following the literal verification specification,\n> one is instead reconstructing R from r by finding a y coordinate that is a\n> quadratic residue, under the existing scheme one would verify\n>\n>\n> *sG - eP = R*\n>\n> which is effectively verifying\n>\n>   0 = *sG - eP* - R  or 0 = R - *sG + eP*\n>\n> Either way one needs to negate at least one point (or one coefficient)\n> because of the opposite signs between sG and eP.\n>\n>\n> Under my proposed revised verification scheme, one would instead verify\n>\n>   0 = sG + eP + (-R).\n>\n> While it seems that this requires negating R, it does not.  Rather (-R)\n> can be directly constructed from r by finding a y coordinate that is *not*\n> a quadratic residue, which is precisely the same amount of work that\n> construction R from r was.\n>\n> In either verification procedure, changing the verification equation to my\n> proposal removes one negation operation from the cost of doing verification.\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/08b47da6/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2018-08-06T08:39:25",
                "message_text_only": "On Sun, Aug 05, 2018 at 10:33:52AM -0400, Russell O'Connor via bitcoin-dev wrote:\n> In light of this, I revise my proposed change to make the verification\n> equation\n> \n> R + sG + eP = 0.\n\nIsn't the verification equation \"R + s(-G) + eP = 0\" equally good, then,\nsince -G is a constant? (ie, at worst it's a matter of optimising the\nverifier for -G as well as G)\n\nIf not, what's the actual performance impact of having to negate \"s\"\nas part of batch verifying ~10000 signatures? It seems like it should\nbe trivially small to me? (scalar_negate benchmarks at 0.00359us, while\necdsa_verify benchmarks at 66us, which I believe then reduces by a factor\nof ~3 for batches of 10k schnorr sigs?)\n\nFWIW, I'm a fan of the formulation \"s = r + H(R,P,m)p\" mostly because\nit seems like the simplest possible way of describing the setup, and I'm\nall for optimising for people being able to understand what's going on.\n\nCheers,\naj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-08-06T14:00:59",
                "message_text_only": "On Mon, Aug 6, 2018 at 4:39 AM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Sun, Aug 05, 2018 at 10:33:52AM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> > In light of this, I revise my proposed change to make the verification\n> > equation\n> >\n> > R + sG + eP = 0.\n>\n> Isn't the verification equation \"R + s(-G) + eP = 0\" equally good, then,\n> since -G is a constant? (ie, at worst it's a matter of optimising the\n> verifier for -G as well as G)\n>\n\nYes you are right.\n\nThanks, I withdraw my proposal.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180806/223ea8f3/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-08-06T21:12:48",
                "message_text_only": "Is it intentional that the encoding of public (and private) keys is\nunspecified? I'd consider at least the encoding of the public key to be\npart of the signature scheme, so ideally it should be specified already\nin this BIP. On the other hand, there may be good arguments against it,\nbut I'm not aware of any.\n\nThis issue leads to a discrepancy between the specification and the\ntest vectors because the data fields of test vectors \"are given as byte\narrays\", including public and secret key. As a consequence, even the\nPython reference implementation in the BIP draft doesn't work on test\nvectors (in a strict sense).\n\nBest,\nTim\n\n\nOn Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:\n> Hello everyone,\n> \n> Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,\n> over the same curve as is currently used in ECDSA:\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> \n> It is simply a draft specification of the signature scheme itself. It\n> does not concern consensus rules, aggregation, or any other\n> integration into Bitcoin - those things are left for other proposals,\n> which can refer to this scheme if desirable. Standardizing the\n> signature scheme is a first step towards that, and as it may be\n> useful\n> in other contexts to have a common Schnorr scheme available, it is\n> its\n> own informational BIP.\n> \n> If accepted, we'll work on more production-ready reference\n> implementations and tests.\n> \n> This is joint work with several people listed in the document.\n> \n> Cheers,\n>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2018-08-12T16:37:35",
                "message_text_only": "I think it's just an oversight. We should specify that we use the standard\nencoding from section 2.3 of http://www.secg.org/sec1-v2.pdf except that\nwe allow only compressed public keys.\n\nAndrew\n\n\nOn Mon, Aug 06, 2018 at 11:12:48PM +0200, Tim Ruffing via bitcoin-dev wrote:\n> Is it intentional that the encoding of public (and private) keys is\n> unspecified? I'd consider at least the encoding of the public key to be\n> part of the signature scheme, so ideally it should be specified already\n> in this BIP. On the other hand, there may be good arguments against it,\n> but I'm not aware of any.\n> \n> This issue leads to a discrepancy between the specification and the\n> test vectors because the data fields of test vectors \"are given as byte\n> arrays\", including public and secret key. As a consequence, even the\n> Python reference implementation in the BIP draft doesn't work on test\n> vectors (in a strict sense).\n> \n> Best,\n> Tim\n> \n> \n> On Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:\n> > Hello everyone,\n> > \n> > Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,\n> > over the same curve as is currently used in ECDSA:\n> > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> > \n> > It is simply a draft specification of the signature scheme itself. It\n> > does not concern consensus rules, aggregation, or any other\n> > integration into Bitcoin - those things are left for other proposals,\n> > which can refer to this scheme if desirable. Standardizing the\n> > signature scheme is a first step towards that, and as it may be\n> > useful\n> > in other contexts to have a common Schnorr scheme available, it is\n> > its\n> > own informational BIP.\n> > \n> > If accepted, we'll work on more production-ready reference\n> > implementations and tests.\n> > \n> > This is joint work with several people listed in the document.\n> > \n> > Cheers,\n> > \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> \n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180812/1a5026a0/attachment.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-08-29T12:09:36",
                "message_text_only": "Note:\n\nThis spec cannot be used directly with a shamir scheme to produce\nsingle-round threshold multisigs, because shares of point R would need to\nbe broadcast to share participants in order to produce valid single\nsignatures.\n\n(R, s) schemes can still be used \"online\", if share participants publish\nthe R(share).... but, not sure if it matter much, this choice eliminates\noffline multiparty signing in exchange for batch validation.\n\n\n\n\n\n\n\n\nOn Sun, Aug 12, 2018 at 12:47 PM Andrew Poelstra via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> I think it's just an oversight. We should specify that we use the standard\n> encoding from section 2.3 of http://www.secg.org/sec1-v2.pdf except that\n> we allow only compressed public keys.\n>\n> Andrew\n>\n>\n> On Mon, Aug 06, 2018 at 11:12:48PM +0200, Tim Ruffing via bitcoin-dev\n> wrote:\n> > Is it intentional that the encoding of public (and private) keys is\n> > unspecified? I'd consider at least the encoding of the public key to be\n> > part of the signature scheme, so ideally it should be specified already\n> > in this BIP. On the other hand, there may be good arguments against it,\n> > but I'm not aware of any.\n> >\n> > This issue leads to a discrepancy between the specification and the\n> > test vectors because the data fields of test vectors \"are given as byte\n> > arrays\", including public and secret key. As a consequence, even the\n> > Python reference implementation in the BIP draft doesn't work on test\n> > vectors (in a strict sense).\n> >\n> > Best,\n> > Tim\n> >\n> >\n> > On Fri, 2018-07-06 at 11:08 -0700, Pieter Wuille via bitcoin-dev wrote:\n> > > Hello everyone,\n> > >\n> > > Here is a proposed BIP for 64-byte elliptic curve Schnorr signatures,\n> > > over the same curve as is currently used in ECDSA:\n> > > https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> > >\n> > > It is simply a draft specification of the signature scheme itself. It\n> > > does not concern consensus rules, aggregation, or any other\n> > > integration into Bitcoin - those things are left for other proposals,\n> > > which can refer to this scheme if desirable. Standardizing the\n> > > signature scheme is a first step towards that, and as it may be\n> > > useful\n> > > in other contexts to have a common Schnorr scheme available, it is\n> > > its\n> > > own informational BIP.\n> > >\n> > > If accepted, we'll work on more production-ready reference\n> > > implementations and tests.\n> > >\n> > > This is joint work with several people listed in the document.\n> > >\n> > > Cheers,\n> > >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n>\n> --\n> Andrew Poelstra\n> Mathematics Department, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> \"A goose alone, I suppose, can know the loneliness of geese\n>  who can never find their peace,\n>  whether north or south or west or east\"\n>        --Joanna Newsom\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/6070f716/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Schnorr signatures BIP",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Russell O'Connor",
                "Tim Ruffing",
                "Andrew Poelstra",
                "Erik Aronesty"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 13426
        }
    },
    {
        "title": "[bitcoin-dev] Claiming an OP_RETURN Prefix",
        "thread_messages": [
            {
                "author": "Lautaro Dragan",
                "date": "2018-08-05T21:11:26",
                "message_text_only": "Hi everyone,\n\nMy name's Lautaro and I'm currently acting as Tech Lead of Po.et\n<https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we use\ncolored coins\n<https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110>\nto\nstore data on the Bitcoin blockchain with prefix \"POET\".\n\nI've read in an old version of the OP_RETURN entry of the bitcoin wiki\n<https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that *protocols\nwishing to claim OP_RETURN prefixes should use the standard Bitcoin\nImprovement Proposals process*.\n\nThat entry seems to have changed recently\n<https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\nstating that we should follow the BIP process, and I haven't been able to\nfind any existing BIP claiming an OP_RETURN prexif, but for the sake of\nthoroughness I'd like to ask for your help or confirmation here.\n\nShould we actually be using the BIP process to claim a prefix?\n\nThanks in advance,\n\nLautaro\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/c445b874/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-05T23:57:55",
                "message_text_only": "On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Hi everyone,\n>\n>My name's Lautaro and I'm currently acting as Tech Lead of Po.et\n><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we\n>use\n>colored coins\n><https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110>\n>to\n>store data on the Bitcoin blockchain with prefix \"POET\".\n>\n>I've read in an old version of the OP_RETURN entry of the bitcoin wiki\n><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that\n>*protocols\n>wishing to claim OP_RETURN prefixes should use the standard Bitcoin\n>Improvement Proposals process*.\n>\n>That entry seems to have changed recently\n><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\n>stating that we should follow the BIP process, and I haven't been able\n>to\n>find any existing BIP claiming an OP_RETURN prexif, but for the sake of\n>thoroughness I'd like to ask for your help or confirmation here.\n>\n>Should we actually be using the BIP process to claim a prefix?\n\nIt's better if you don't use a prefix at all from a censorship resistance and anonymity perspective; you're application should not require a prefix for technical reasons.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org"
            },
            {
                "author": "Lautaro Dragan",
                "date": "2018-08-06T00:55:59",
                "message_text_only": "Thanks Peter for your prompt reply.\n\nAnd now that I think of it you're right - as easy as it is for us to\ndifferentiate OP_RETURN outputs that contain the Po.et prefix it would be\nfor miners to block those transactions altogether. Is this what you mean?\n\nStill, a prefix is something we may have to live with for a little while\nuntil we can address that issue.\n\nIs there a formal / standard process to claim it we should follow?\n\n\n\n\nEl dom., 5 de ago. de 2018 a la(s) 20:58, Peter Todd <pete at petertodd.org>\nescribi\u00f3:\n\n>\n>\n> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >Hi everyone,\n> >\n> >My name's Lautaro and I'm currently acting as Tech Lead of Po.et\n> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we\n> >use\n> >colored coins\n> ><\n> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110\n> >\n> >to\n> >store data on the Bitcoin blockchain with prefix \"POET\".\n> >\n> >I've read in an old version of the OP_RETURN entry of the bitcoin wiki\n> ><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that\n> >*protocols\n> >wishing to claim OP_RETURN prefixes should use the standard Bitcoin\n> >Improvement Proposals process*.\n> >\n> >That entry seems to have changed recently\n> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\n> >stating that we should follow the BIP process, and I haven't been able\n> >to\n> >find any existing BIP claiming an OP_RETURN prexif, but for the sake of\n> >thoroughness I'd like to ask for your help or confirmation here.\n> >\n> >Should we actually be using the BIP process to claim a prefix?\n>\n> It's better if you don't use a prefix at all from a censorship resistance\n> and anonymity perspective; you're application should not require a prefix\n> for technical reasons.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/e3265ebe/attachment-0001.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2018-08-06T01:54:50",
                "message_text_only": "Don't worry about claiming it. There are no reserved prefixes enforced by\nthe software. For example anyone could create an output that uses the\nwitness coinbase commitment prefix bytes. It would just be ignored (unless\nit was in the coinbase, in which case it would also need to be valid).\n\nOn Sun, Aug 5, 2018, 6:47 PM Lautaro Dragan via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks Peter for your prompt reply.\n>\n> And now that I think of it you're right - as easy as it is for us to\n> differentiate OP_RETURN outputs that contain the Po.et prefix it would be\n> for miners to block those transactions altogether. Is this what you mean?\n>\n> Still, a prefix is something we may have to live with for a little while\n> until we can address that issue.\n>\n> Is there a formal / standard process to claim it we should follow?\n>\n>\n>\n>\n> El dom., 5 de ago. de 2018 a la(s) 20:58, Peter Todd <pete at petertodd.org>\n> escribi\u00f3:\n>\n>>\n>>\n>> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >Hi everyone,\n>> >\n>> >My name's Lautaro and I'm currently acting as Tech Lead of Po.et\n>> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we\n>> >use\n>> >colored coins\n>> ><\n>> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e84c/src/BlockchainWriter/ClaimController.ts#L101-L110\n>> >\n>> >to\n>> >store data on the Bitcoin blockchain with prefix \"POET\".\n>> >\n>> >I've read in an old version of the OP_RETURN entry of the bitcoin wiki\n>> ><https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that\n>> >*protocols\n>> >wishing to claim OP_RETURN prefixes should use the standard Bitcoin\n>> >Improvement Proposals process*.\n>> >\n>> >That entry seems to have changed recently\n>> ><https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\n>> >stating that we should follow the BIP process, and I haven't been able\n>> >to\n>> >find any existing BIP claiming an OP_RETURN prexif, but for the sake of\n>> >thoroughness I'd like to ask for your help or confirmation here.\n>> >\n>> >Should we actually be using the BIP process to claim a prefix?\n>>\n>> It's better if you don't use a prefix at all from a censorship resistance\n>> and anonymity perspective; you're application should not require a prefix\n>> for technical reasons.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/616dd36b/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-08-06T02:04:18",
                "message_text_only": "Are you doing coloured coins or storing data?\n\nIf the former, you should probably collaborate with the authors of BIP 160 \n(yet to be added to the main repo), and/or write a new BIP if BIP 160 is \ninsufficient for some reason.\n\nIf the latter, you just shouldn't do it at all.\n\nNote that BIPs need to specify an actual protocol, not just claim a prefix.\n\n\nOn Sunday 05 August 2018 21:11:26 Lautaro Dragan via bitcoin-dev wrote:\n> Hi everyone,\n>\n> My name's Lautaro and I'm currently acting as Tech Lead of Po.et\n> <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we use\n> colored coins\n> <https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e\n>84c/src/BlockchainWriter/ClaimController.ts#L101-L110> to\n> store data on the Bitcoin blockchain with prefix \"POET\".\n>\n> I've read in an old version of the OP_RETURN entry of the bitcoin wiki\n> <https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that\n> *protocols wishing to claim OP_RETURN prefixes should use the standard\n> Bitcoin Improvement Proposals process*.\n>\n> That entry seems to have changed recently\n> <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\n> stating that we should follow the BIP process, and I haven't been able to\n> find any existing BIP claiming an OP_RETURN prexif, but for the sake of\n> thoroughness I'd like to ask for your help or confirmation here.\n>\n> Should we actually be using the BIP process to claim a prefix?\n>\n> Thanks in advance,\n>\n> Lautaro"
            },
            {
                "author": "Lautaro Dragan",
                "date": "2018-08-06T02:19:44",
                "message_text_only": "Sorry for the confusion. We're doing coloured coins \u2014 storing the \"POET\"\nprefix followed by an IPFS hash in the output and storing the full data in\nIPFS.\n\nWould you point me to the current work on BIP 160 or the authors?\n\nEl dom., 5 de ago. de 2018 a la(s) 23:05, Luke Dashjr <luke at dashjr.org>\nescribi\u00f3:\n\n> Are you doing coloured coins or storing data?\n>\n> If the former, you should probably collaborate with the authors of BIP 160\n> (yet to be added to the main repo), and/or write a new BIP if BIP 160 is\n> insufficient for some reason.\n>\n> If the latter, you just shouldn't do it at all.\n>\n> Note that BIPs need to specify an actual protocol, not just claim a prefix.\n>\n>\n> On Sunday 05 August 2018 21:11:26 Lautaro Dragan via bitcoin-dev wrote:\n> > Hi everyone,\n> >\n> > My name's Lautaro and I'm currently acting as Tech Lead of Po.et\n> > <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>. At Po.et we\n> use\n> > colored coins\n> > <\n> https://github.com/poetapp/node/blob/3c905bc5dbd3722ad39ac68041d9f2a099e5e\n> >84c/src/BlockchainWriter/ClaimController.ts#L101-L110> to\n> > store data on the Bitcoin blockchain with prefix \"POET\".\n> >\n> > I've read in an old version of the OP_RETURN entry of the bitcoin wiki\n> > <https://en.bitcoin.it/w/index.php?title=OP_RETURN&oldid=62560> that\n> > *protocols wishing to claim OP_RETURN prefixes should use the standard\n> > Bitcoin Improvement Proposals process*.\n> >\n> > That entry seems to have changed recently\n> > <https://en.bitcoin.it/wiki/OP_RETURN#OP_RETURN_prefixes>, no longer\n> > stating that we should follow the BIP process, and I haven't been able to\n> > find any existing BIP claiming an OP_RETURN prexif, but for the sake of\n> > thoroughness I'd like to ask for your help or confirmation here.\n> >\n> > Should we actually be using the BIP process to claim a prefix?\n> >\n> > Thanks in advance,\n> >\n> > Lautaro\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/ed0fdefe/attachment-0001.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2018-08-14T18:34:13",
                "message_text_only": "On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Should we actually be using the BIP process to claim a prefix?\n\nI recommend against using an op_return prefix, as they allow for\ntransaction censorship.\n\nIn fact, in our case, where we use an IPFS hash in an op_return, we remove\nthe IPFS multihash prefix information to post a \u201cbare\u201d SHA256 hash to look\nlike many other hashes being posted in op_returns, to minimize any ability\nfor a miner to identify our transaction. The more projects that do this the\nbetter \u2014 a form of herd immunity.\n\nLonger term I\u2019m looking for more responsible ways to publish this hash, for\ninstance have the hash be in the witness script data, so that it can be\neasily purged from nodes that do not wish to preserve it and prevent block\nsize bloat. However, to do so everyone has to do it the same way, ideally\nhave it look like any other transaction. I\u2019ve not quite seen a solid\nproposal for best practices here.\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180814/5c7a9e75/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2018-08-15T20:33:43",
                "message_text_only": "op_return outputs can be pruned because they are not spendable.\nputting a hash on in the witness script data won't make things better\n(it would actually make them worse) and it definitely doesn't help\n\"block size bloat\".\nI think I'm missing some context, but if you're using op_return purely\nfor timestamping I would recommend using pay 2 contract  instead.\n\nOn Tue, Aug 14, 2018 at 8:34 PM, Christopher Allen via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>Should we actually be using the BIP process to claim a prefix?\n>\n> I recommend against using an op_return prefix, as they allow for transaction\n> censorship.\n>\n> In fact, in our case, where we use an IPFS hash in an op_return, we remove\n> the IPFS multihash prefix information to post a \u201cbare\u201d SHA256 hash to look\n> like many other hashes being posted in op_returns, to minimize any ability\n> for a miner to identify our transaction. The more projects that do this the\n> better \u2014 a form of herd immunity.\n>\n> Longer term I\u2019m looking for more responsible ways to publish this hash, for\n> instance have the hash be in the witness script data, so that it can be\n> easily purged from nodes that do not wish to preserve it and prevent block\n> size bloat. However, to do so everyone has to do it the same way, ideally\n> have it look like any other transaction. I\u2019ve not quite seen a solid\n> proposal for best practices here.\n>\n> \u2014 Christopher Allen\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Jude Nelson",
                "date": "2018-08-15T20:40:02",
                "message_text_only": "> I recommend against using an op_return prefix,\n> as they allow for transaction censorship.\n\n> In fact, in our case, where we use an IPFS hash in\n> an op_return, we remove the IPFS multihash prefix\n> information to post a \u201cbare\u201d SHA256 hash to look like\n> many other hashes being posted in op_returns, to\n> minimize any ability for a miner to identify our transaction.\n> The more projects that do this the better \u2014 a form of herd\n> immunity.\n\nCan a miner identify which transactions came from your software simply by\nrunning a copy themselves?  If so, then they can censor your transactions\nno matter how you encode them.\n\nOn Wed, Aug 15, 2018 at 8:34 PM Jorge Tim\u00f3n via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> op_return outputs can be pruned because they are not spendable.\n> putting a hash on in the witness script data won't make things better\n> (it would actually make them worse) and it definitely doesn't help\n> \"block size bloat\".\n> I think I'm missing some context, but if you're using op_return purely\n> for timestamping I would recommend using pay 2 contract  instead.\n>\n> On Tue, Aug 14, 2018 at 8:34 PM, Christopher Allen via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > On August 5, 2018 9:11:26 PM UTC, Lautaro Dragan via bitcoin-dev\n> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>Should we actually be using the BIP process to claim a prefix?\n> >\n> > I recommend against using an op_return prefix, as they allow for\n> transaction\n> > censorship.\n> >\n> > In fact, in our case, where we use an IPFS hash in an op_return, we\n> remove\n> > the IPFS multihash prefix information to post a \u201cbare\u201d SHA256 hash to\n> look\n> > like many other hashes being posted in op_returns, to minimize any\n> ability\n> > for a miner to identify our transaction. The more projects that do this\n> the\n> > better \u2014 a form of herd immunity.\n> >\n> > Longer term I\u2019m looking for more responsible ways to publish this hash,\n> for\n> > instance have the hash be in the witness script data, so that it can be\n> > easily purged from nodes that do not wish to preserve it and prevent\n> block\n> > size bloat. However, to do so everyone has to do it the same way, ideally\n> > have it look like any other transaction. I\u2019ve not quite seen a solid\n> > proposal for best practices here.\n> >\n> > \u2014 Christopher Allen\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/e8fe75f4/attachment-0001.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2018-08-15T21:54:50",
                "message_text_only": "On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Can a miner identify which transactions came from your software simply by\n> running a copy themselves?  If so, then they can censor your transactions\n> no matter how you encode them.\n>\n\nPossibly, but in the IPFS case I suspect the latency required to inspect\nall hashes would likely  impact the ability of the miner to succeed in the\nblock. (True? I don\u2019t touch mining software.)\n\nThus as long as all hashes look the same, and there are multiple content\naddressable schemes that use hashes that have to be searched in order to\nknow to censor, you have to censor all or none.\n\n\u2014 Christopher Allen\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/de4d77d3/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-08-16T01:06:53",
                "message_text_only": "On Wednesday 15 August 2018 21:54:50 Christopher Allen via bitcoin-dev wrote:\n> On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Can a miner identify which transactions came from your software simply by\n> > running a copy themselves?  If so, then they can censor your transactions\n> > no matter how you encode them.\n>\n> Possibly, but in the IPFS case I suspect the latency required to inspect\n> all hashes would likely  impact the ability of the miner to succeed in the\n> block. (True? I don\u2019t touch mining software.)\n\nNot true at all.\n\n> Thus as long as all hashes look the same, and there are multiple content\n> addressable schemes that use hashes that have to be searched in order to\n> know to censor, you have to censor all or none.\n\nChoosing not to mine transactions is not censorship.\n\nLuke"
            },
            {
                "author": "Lautaro Dragan",
                "date": "2018-08-16T02:22:21",
                "message_text_only": "Thanks Christopher.\n\n> op_return outputs can be pruned because they are not spendable.\nputting a hash on in the witness script data won't make things better\n(it would actually make them worse) and it definitely doesn't help\n\"block size bloat\".\n\nAgreed\n\n> I think I'm missing some context, but if you're using op_return purely\nfor timestamping I would recommend using pay 2 contract  instead.\n\nAnd\n\n> If you're *actually* just doing timestamping you're better off using\nOpenTimestamps. But many times people think they're just doing timestamping\nin reality mere timestamps are insufficient for the task.\n\nNo, it's not only timestamping. Think of it as storing the URL of something\nin the OP_RETURN, only that instead of a URL it's a hash. But it's not just\nthe hash of the work \u2014 IPFS adds a few other elements that affect this\nhash, so calculating it out of the file being added won't do. Also, the\nbatching OTS uses and the batching we use (using IPFS directories) are\nincompatible.\n\n> Can a miner identify which transactions came from your software simply by\nrunning a copy themselves?  If so, then they can censor your transactions\nno matter how you encode them.\n\nMiners would have to try and `ipfs cat` every OP_RETURN of every\ntransaction (maybe filtering by byte length), which is a relatively high\ncost operation. But such a script is straight forward to write and can be\nhosted in a cheap AWS machine. We're talking about less than a week of\ncoding and less than a hundred bucks of hosting, so if they're out to get\nyou it won't make a difference.\n\n> Choosing not to mine transactions is not censorship.\n\nIs it not, if for political rather than economical reasons? These\ntransactions pay fees like any other.\n\n\n\nEl mi\u00e9., 15 de ago. de 2018 a la(s) 22:08, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> escribi\u00f3:\n\n> On Wednesday 15 August 2018 21:54:50 Christopher Allen via bitcoin-dev\n> wrote:\n> > On Wed, Aug 15, 2018 at 2:24 PM Jude Nelson via bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > Can a miner identify which transactions came from your software simply\n> by\n> > > running a copy themselves?  If so, then they can censor your\n> transactions\n> > > no matter how you encode them.\n> >\n> > Possibly, but in the IPFS case I suspect the latency required to inspect\n> > all hashes would likely  impact the ability of the miner to succeed in\n> the\n> > block. (True? I don\u2019t touch mining software.)\n>\n> Not true at all.\n>\n> > Thus as long as all hashes look the same, and there are multiple content\n> > addressable schemes that use hashes that have to be searched in order to\n> > know to censor, you have to censor all or none.\n>\n> Choosing not to mine transactions is not censorship.\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180815/ae997542/attachment-0001.html>"
            },
            {
                "author": "Ryan Grant",
                "date": "2018-08-16T17:32:25",
                "message_text_only": "On Wed, Aug 15, 2018 at 8:40 PM, Jude Nelson via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Can a miner identify which transactions came from your software simply by\n> running a copy themselves?  If so, then they can censor your transactions no\n> matter how you encode them.\n\nThe hash of the file is deterministic and `ipfs add` tells us what it\nis whether the network is connected or disconnected.  We don't upload\nfiles to IPFS until the transaction has settled with several\nconfirmations."
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-15T21:46:18",
                "message_text_only": "On August 15, 2018 8:33:43 PM UTC, \"Jorge Tim\u00f3n via bitcoin-dev\" <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>op_return outputs can be pruned because they are not spendable.\n>putting a hash on in the witness script data won't make things better\n>(it would actually make them worse) and it definitely doesn't help\n>\"block size bloat\".\n>I think I'm missing some context, but if you're using op_return purely\n>for timestamping I would recommend using pay 2 contract  instead.\n\nIf you're *actually* just doing timestamping you're better off using OpenTimestamps. But many times people think they're just doing timestamping in reality mere timestamps are insufficient for the task.\n\nNotably, this is something the Satoshi Bitcoin white paper gets wrong, incorrectly describing Bitcoin as a timestamping system: timestamping is insufficient to prevent double-spends.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org"
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-08-16T02:37:11",
                "message_text_only": "On Thursday 16 August 2018 02:22:21 Lautaro Dragan wrote:\n> > Choosing not to mine transactions is not censorship.\n>\n> Is it not, if for political rather than economical reasons? These\n> transactions pay fees like any other.\n\nMiners have always chosen transaction on \"political\" basises, and doing such \nis their right. That's why the system is supposed to be comprised of many \nminers, all with their own policies - so the choices of one do not impact the \noverall ability to spend (presumably only spam should be rejected by all \nminers).\n\nFor fees to themselves justify the cost of a transaction, they would need to \nbe magnitudes higher than we've ever seen on Bitcoin. But even then, nobody \nhas an obligation to accept payment, no matter how reasonable it is, for a \nservice they don't want to provide.\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "Claiming an OP_RETURN Prefix",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "CryptAxe",
                "Christopher Allen",
                "Peter Todd",
                "Jorge Tim\u00f3n",
                "Luke Dashjr",
                "Jude Nelson",
                "Lautaro Dragan"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 24069
        }
    },
    {
        "title": "[bitcoin-dev] Capping the size of locators [trivial protocol change BIP]",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2018-08-06T02:15:22",
                "message_text_only": "Coinr8d posted on bct that the node software would process large\nlocators limited only by the maximum message size yet sensible usage\nof locators only results in messages of log2(n_blocks) size. He was\nconcerned that it might be a DOS vulnerability but quick measurements\nindicated to me that it likely wasn't worse than many other protocol\nmessages.  It still seems silly to allow absurd locators. So I propose\nthat the size of locators be limited.\n\nHowever, capping them is a P2P change that could potentially result in\nnetwork splits if older nodes would potentially produce larger\nlocators (esp if triggered to produce unexpectedly large ones by\nforks).  A quick survey of node software indicated that no software I\ncould find would ever produce a locator with more than 42 hashes\nbefore encountering other limits, so I think a limit of 64 will be\nautomatically compatible with all or virtually all nodes on the\nnetwork.\n\nI'm bothering writing a BIP because there might be some naive\nimplementation lurking out there that sends a crazy number due to\nsub-exponential backoff that would be broken by nodes enforcing a\nlimit... particularly since the correct use of locators was never\npreviously mandated and might not be obvious to all developers.\n\nI take the opportunity to also specify that the locators be correctly\nordered in terms of total work, but  don't specify that they all come\nfrom the same chain.\n\nCheers,\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes limiting the locator messages used in the getblocks\nand getheaders to 64 entries and requiring that be ordered by total\nwork.\n\n===Copyright===\n\nThis document is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nThe Bitcoin P2P protocol uses a simple and efficient data structure\nto reconcile blockchains between nodes called a locator.  A locator\ncommunicates a list of known hashes which allows a peer to find a\nrecent common ancestor between the best chains on two nodes.  By\nexponentially increasing the space between each entry, the locator\nallows a log() sized message to find the difference between two nodes\nwith only a constant factor overhead.\n\nBecause short forks are much more common than long forks the typical\nusage of the locator includes a small number of topmost hashes before\nswitching to exponential spacing.\n\nThe original Bitcoin implementation provided no explicit limit to the\nnumber of hashes in a locator message, allowing for absurd and\nwasteful uses like including\nall hashes in a chain.\n\nAlthough locators are very inexpensive for existing node software to\nprocess there is no known utility for sending very large locators.\nTo reduce the worst case cost of processing a locator message it would\nbe useful if the size of locator messages were strictly\nbounded to sensible levels.\n\nCommon implementations have implicit limitations of 2^32 blocks and an\nexponent of 2 after the first 10 locators and so could never request\nmore than 42 hashes in any case.\n\n== Specification ==\n\nA locator included in a getblock or getheaders message may include no more\nthan 64 hashes, including the final hash_stop hash. Additionally, the blocks\nreferenced by the locator must be in order of equal or decreasing total\nwork.\n\nSending a locator that violates these requirements may result in normal\nprocessing, the message being ignored, a disconnection, or a ban.\n\nImplementations that seek to handle larger numbers of blocks than afforded\nby this limit with an exponent of 2 can adaptively switch to a larger\nexponent as required to stay within the limit.\n\n== Acknowledgements ==\n\nThanks to Coinr8d on bitcointalk for pointing out that node software would\nprocess and respond to locators with about 125,000 hashes in them."
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-08-06T05:29:31",
                "message_text_only": "Libbitcoin has implemented a 11 + log2(height) limit since version3 for\nthis reason. This message can be very costly if not constrained.\n\nThe presumed protocol inherently limits valid locator size for a given\nrecipient. IMO it's worth considering instead describing the expected\nsemantics of the message and thereby its *inherent* limits. Doing so\ngives the recipient an upper bound on valid locator size, eliminating\nthe need to introduce an arbitrary limit.\n\nI have commonly seen locators with 100 elements, I believe from\nBitcoinJ. I recall posting a query on the issue to their IRC but got no\nresponse. So it would seem that a quick survey and a limit of 64 would\nnot have prevented the issue of concern.\n\nBut in any case, I agree that implementations should enforce a limit.\n\ne\n\nOn 08/05/2018 07:15 PM, Gregory Maxwell via bitcoin-dev wrote:\n> Coinr8d posted on bct that the node software would process large\n> locators limited only by the maximum message size yet sensible usage\n> of locators only results in messages of log2(n_blocks) size. He was\n> concerned that it might be a DOS vulnerability but quick measurements\n> indicated to me that it likely wasn't worse than many other protocol\n> messages.  It still seems silly to allow absurd locators. So I propose\n> that the size of locators be limited.\n> \n> However, capping them is a P2P change that could potentially result in\n> network splits if older nodes would potentially produce larger\n> locators (esp if triggered to produce unexpectedly large ones by\n> forks).  A quick survey of node software indicated that no software I\n> could find would ever produce a locator with more than 42 hashes\n> before encountering other limits, so I think a limit of 64 will be\n> automatically compatible with all or virtually all nodes on the\n> network.\n> \n> I'm bothering writing a BIP because there might be some naive\n> implementation lurking out there that sends a crazy number due to\n> sub-exponential backoff that would be broken by nodes enforcing a\n> limit... particularly since the correct use of locators was never\n> previously mandated and might not be obvious to all developers.\n> \n> I take the opportunity to also specify that the locators be correctly\n> ordered in terms of total work, but  don't specify that they all come\n> from the same chain.\n> \n> Cheers,\n> \n> ==Introduction==\n> \n> ===Abstract===\n> \n> This document proposes limiting the locator messages used in the getblocks\n> and getheaders to 64 entries and requiring that be ordered by total\n> work.\n> \n> ===Copyright===\n> \n> This document is licensed under the 2-clause BSD license.\n> \n> ==Motivation==\n> \n> The Bitcoin P2P protocol uses a simple and efficient data structure\n> to reconcile blockchains between nodes called a locator.  A locator\n> communicates a list of known hashes which allows a peer to find a\n> recent common ancestor between the best chains on two nodes.  By\n> exponentially increasing the space between each entry, the locator\n> allows a log() sized message to find the difference between two nodes\n> with only a constant factor overhead.\n> \n> Because short forks are much more common than long forks the typical\n> usage of the locator includes a small number of topmost hashes before\n> switching to exponential spacing.\n> \n> The original Bitcoin implementation provided no explicit limit to the\n> number of hashes in a locator message, allowing for absurd and\n> wasteful uses like including\n> all hashes in a chain.\n> \n> Although locators are very inexpensive for existing node software to\n> process there is no known utility for sending very large locators.\n> To reduce the worst case cost of processing a locator message it would\n> be useful if the size of locator messages were strictly\n> bounded to sensible levels.\n> \n> Common implementations have implicit limitations of 2^32 blocks and an\n> exponent of 2 after the first 10 locators and so could never request\n> more than 42 hashes in any case.\n> \n> == Specification ==\n> \n> A locator included in a getblock or getheaders message may include no more\n> than 64 hashes, including the final hash_stop hash. Additionally, the blocks\n> referenced by the locator must be in order of equal or decreasing total\n> work.\n> \n> Sending a locator that violates these requirements may result in normal\n> processing, the message being ignored, a disconnection, or a ban.\n> \n> Implementations that seek to handle larger numbers of blocks than afforded\n> by this limit with an exponent of 2 can adaptively switch to a larger\n> exponent as required to stay within the limit.\n> \n> == Acknowledgements ==\n> \n> Thanks to Coinr8d on bitcointalk for pointing out that node software would\n> process and respond to locators with about 125,000 hashes in them.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180805/645df6f7/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Capping the size of locators ",
            "categories": [
                "bitcoin-dev",
                "trivial protocol change BIP"
            ],
            "authors": [
                "Eric Voskuil",
                "Gregory Maxwell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8929
        }
    },
    {
        "title": "[bitcoin-dev] Multisignature for bip-schnorr",
        "thread_messages": [
            {
                "author": "nakagat",
                "date": "2018-08-07T06:35:58",
                "message_text_only": "Hi all,\n\nI wrote a multisignature procedure using bip-schnorr.\n\nIf you have time to review and give feedback, I\u2019d really appreciate it.\nThanks in advance!\n\nMultisignature\nhttps://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b\n\nOriginal\nhttps://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n\n-- \nnakagawa"
            },
            {
                "author": "Erik Aronesty",
                "date": "2018-08-29T11:28:56",
                "message_text_only": "It's cool but\n\n- there's a lot of online steps.\n- it's not a threshold system\n\nUsing a shamir scheme solves this and isn't subject to birthday attacks:\n\nhttps://medium.com/@simulx/an-m-of-n-bitcoin-multisig-scheme-e7860ab34e7f\n\n\n\nOn Mon, Aug 13, 2018 at 7:08 AM nakagat via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> I wrote a multisignature procedure using bip-schnorr.\n>\n> If you have time to review and give feedback, I\u2019d really appreciate it.\n> Thanks in advance!\n>\n> Multisignature\n> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b\n>\n> Original\n>\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n>\n> --\n> nakagawa\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/dd3fa3cf/attachment-0001.html>"
            },
            {
                "author": "nakagat",
                "date": "2018-08-31T05:22:54",
                "message_text_only": "Hi all,\n\nI wrote t-of-k threshold signature procedure using bip-schnorr.\n\nIf you have time to review and give feedback, I\u2019d really appreciate it.\nThanks in advance!\n\nThreshold Signatures\nhttps://gist.github.com/tnakagawa/e6cec9a89f698997dc58a09db541e1eb\n\nOriginal\nhttps://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n\n-- \nnakagawa\n\n2018\u5e748\u67087\u65e5(\u706b) 15:35 nakagat <nakagat at gmail.com>:\n>\n> Hi all,\n>\n> I wrote a multisignature procedure using bip-schnorr.\n>\n> If you have time to review and give feedback, I\u2019d really appreciate it.\n> Thanks in advance!\n>\n> Multisignature\n> https://gist.github.com/tnakagawa/0c3bc74a9a44bd26af9b9248dfbe598b\n>\n> Original\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki#Multisignatures_and_Threshold_Signatures\n>\n> --\n> nakagawa"
            }
        ],
        "thread_summary": {
            "title": "Multisignature for bip-schnorr",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "nakagat",
                "Erik Aronesty"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2314
        }
    },
    {
        "title": "[bitcoin-dev] Simple change to the \"merkleblock\" command to protect from SPV proof extension attacks",
        "thread_messages": [
            {
                "author": "Sergio Demian Lerner",
                "date": "2018-08-10T00:21:17",
                "message_text_only": "Hi,\n While fixing RSK's SPV bridge I came up with an idea to fix the\nMERKLEBLOCK command to prevent rogue peers from attacking SPV peers using\nBitcoin's Merkle tree structure flaws. The most annoying attack is the one\nthat tries to confuse a victim peer into thinking a transaction is an inner\nnode, extending such node with a new right-sided branch with a fake\ntransaction (*) .\n\nThe old idea to soft-fork Bitcoin to make invalid 64-byte transactions is\nattractive, but also a coordination problem that could be avoided with this\nnew proposal.\n\nThe idea is simple, and it's not a fork, but a network protocol improvement.\nLet A be the hash digest that must be combined with the hash digest B, such\nthat the upper node hash is SHA256(SHA256(A | B)).\nTherefore A = SHA256(SHA256(X)) and B = SHA256(SHA256(Y)), and X and Y are\neither Bitcoin transactions or other inner nodes.\nInstead of storing A, the merkleblock structure should store a pre-image of\nA, or SHA256(X).\nIf the block only has the coinbase, nothing is done.\nThe pre-image change could be done to both left and right hashes, but it's\nenough to do it to all left-side hashes that do not have children in the\npartial merkle tree structure (let's call them terminal hahes. to avoid\nconfusion with leaf hashes).\n\nVerifiers (SPV nodes) would apply a single SHA256() operation to the\nleft-sided terminal hashes before combining them. The cost to the verifier\nis in the worse case only 33% more.\n\nThis basically limits the attacker's ability to supply chosen-hash digests\nin order to build a transaction. Because the left side contains most of the\nprevin hash, the attacker would need to bruteforce a huge space (about 208\nbits) in order to come up with a pre-image that maps to a owned previn.\nMeet-in-the-middle attacks would be expensive as UTXOs are not free.\n\nTo implement this change, a new command MERKLEBLOCK2 could be implemented\nor the protocol version could be used to differentiate between the two\nmodes of the MERKLEBLOCK command.\n\nIf the idea gets community support, I may write the BIP/code or invite\nanyone to do it.\n\nregards\n\n (*)\nhttps://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180809/c747d596/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Simple change to the \"merkleblock\" command to protect from SPV proof extension attacks",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sergio Demian Lerner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2381
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Simple change to the \"merkleblock\" command to protect from SPV proof extension attacks",
        "thread_messages": [
            {
                "author": "Sergio Demian Lerner",
                "date": "2018-08-14T15:26:25",
                "message_text_only": "Hi,\n While fixing RSK's SPV bridge I came up with an idea to fix the\nMERKLEBLOCK command to prevent rogue peers from attacking SPV peers using\nBitcoin's Merkle tree structure flaws. The most annoying attack is the one\nthat tries to confuse a victim peer into thinking a transaction is an inner\nnode, extending such node with a new right-sided branch with a fake\ntransaction (*) .\n\nThe old idea to soft-fork Bitcoin to make invalid 64-byte transactions is\nattractive, but also a coordination problem that could be avoided with this\nnew proposal.\n\nThe idea is simple, and it's not a fork, but a network protocol improvement.\nLet A be the hash digest that must be combined with the hash digest B, such\nthat the upper node hash is SHA256(SHA256(A | B)).\nTherefore A = SHA256(SHA256(X)) and B = SHA256(SHA256(Y)), and X and Y are\neither Bitcoin transactions or other inner nodes.\nInstead of storing A, the merkleblock structure should store a pre-image of\nA, or SHA256(X).\nIf the block only has the coinbase, nothing is done.\nThe pre-image change could be done to both left and right hashes, but it's\nenough to do it to all left-side hashes that do not have children in the\npartial merkle tree structure (let's call them terminal hahes. to avoid\nconfusion with leaf hashes).\n\nVerifiers (SPV nodes) would apply a single SHA256() operation to the\nleft-sided terminal hashes before combining them. The cost to the verifier\nis in the worse case only 33% more.\n\nThis basically limits the attacker's ability to supply chosen-hash digests\nin order to build a transaction. Because the left side contains most of the\nprevin hash, the attacker would need to bruteforce a huge space (about 208\nbits) in order to come up with a pre-image that maps to a owned previn.\nMeet-in-the-middle attacks would be expensive as UTXOs are not free.\n\nTo implement this change, a new command MERKLEBLOCK2 could be implemented\nor the protocol version could be used to differentiate between the two\nmodes of the MERKLEBLOCK command.\n\nIf the idea gets community support, I may write the BIP/code or invite\nanyone to do it.\n\nregards\n\n (*)\nhttps://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180814/51d0f150/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Simple change to the \"merkleblock\" command to protect from SPV proof extension attacks",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sergio Demian Lerner"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2376
        }
    },
    {
        "title": "[bitcoin-dev] Witness serialization in PSBT non-witness UTXOs",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2018-08-13T18:56:41",
                "message_text_only": "Hello all,\n\nBIP174 currently specifies that non-witness UTXOs (the transactions\nbeing spent by non-witness inputs) should be serialized in network\nformat.\n\nI believe there are two issues with this.\n\n1. Even in case the transaction whose output being spent itself has a\nwitness, this witness is immaterial to PSBT. It's only there to be\nable to verify the txid commits to the output/amount being spent,\nwhich can be done without witness.\n\n2. \"Network format\" is a bit ambiguous. We can imagine a future\nsoftfork that introduces a new type of witness. Network format could\nbe interpreted as including that new witness type, which is clearly\nunnecessary (by the above argument), and would gratuitously break\ncompatibility with existing signers if implemented pedantically.\n\nSo my suggestion is to update the specification to state that\nnon-witness UTXOs must be serialized without witness. If it's too late\nfor that, it should instead be updated to explicitly specify with or\nwitnout witness, but it's safe to drop the witness.\n\nOpinions?\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Achow101",
                "date": "2018-08-13T20:32:33",
                "message_text_only": "Hi,\n\nSince the BIP is already in proposed status, I think that we should specify the non-witness utxo to just be \"witness or non-witness\" serialization. This maintains compatibility with things that have already implemented but also maintains the forwards compatibility that is needed.\n\nAndrew\n\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn August 13, 2018 11:56 AM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> BIP174 currently specifies that non-witness UTXOs (the transactions\n> being spent by non-witness inputs) should be serialized in network\n> format.\n>\n> I believe there are two issues with this.\n>\n> 1.  Even in case the transaction whose output being spent itself has a\n>     witness, this witness is immaterial to PSBT. It's only there to be\n>     able to verify the txid commits to the output/amount being spent,\n>     which can be done without witness.\n>\n> 2.  \"Network format\" is a bit ambiguous. We can imagine a future\n>     softfork that introduces a new type of witness. Network format could\n>     be interpreted as including that new witness type, which is clearly\n>     unnecessary (by the above argument), and would gratuitously break\n>     compatibility with existing signers if implemented pedantically.\n>\n>     So my suggestion is to update the specification to state that\n>     non-witness UTXOs must be serialized without witness. If it's too late\n>     for that, it should instead be updated to explicitly specify with or\n>     witnout witness, but it's safe to drop the witness.\n>\n>     Opinions?\n>\n>     Cheers,\n>\n>     --\n>     Pieter\n>\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-08-13T20:39:38",
                "message_text_only": "An alternative is to require reading either or but also require\nwriting without the witness.  It's likely that two years from now,\nnothing will write the witnesses, and the requirement to support\nreading them could be dropped.\nOn Mon, Aug 13, 2018 at 8:32 PM Achow101 via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi,\n>\n> Since the BIP is already in proposed status, I think that we should specify the non-witness utxo to just be \"witness or non-witness\" serialization. This maintains compatibility with things that have already implemented but also maintains the forwards compatibility that is needed.\n>\n> Andrew\n>\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On August 13, 2018 11:56 AM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hello all,\n> >\n> > BIP174 currently specifies that non-witness UTXOs (the transactions\n> > being spent by non-witness inputs) should be serialized in network\n> > format.\n> >\n> > I believe there are two issues with this.\n> >\n> > 1.  Even in case the transaction whose output being spent itself has a\n> >     witness, this witness is immaterial to PSBT. It's only there to be\n> >     able to verify the txid commits to the output/amount being spent,\n> >     which can be done without witness.\n> >\n> > 2.  \"Network format\" is a bit ambiguous. We can imagine a future\n> >     softfork that introduces a new type of witness. Network format could\n> >     be interpreted as including that new witness type, which is clearly\n> >     unnecessary (by the above argument), and would gratuitously break\n> >     compatibility with existing signers if implemented pedantically.\n> >\n> >     So my suggestion is to update the specification to state that\n> >     non-witness UTXOs must be serialized without witness. If it's too late\n> >     for that, it should instead be updated to explicitly specify with or\n> >     witnout witness, but it's safe to drop the witness.\n> >\n> >     Opinions?\n> >\n> >     Cheers,\n> >\n> >     --\n> >     Pieter\n> >\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Witness serialization in PSBT non-witness UTXOs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Gregory Maxwell",
                "Achow101"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5160
        }
    },
    {
        "title": "[bitcoin-dev] [announce] LNvis alpha - A Lightning Network Visualizer",
        "thread_messages": [
            {
                "author": "William Casarin",
                "date": "2018-08-17T15:51:31",
                "message_text_only": "Hello lightning/bitcoin devs,\n\nI've been working on an OpenGL Lighting Network visualizer written in C\n+ nanovg with no dependencies except for glfw. I thought I would release\nthe alpha here first for testing.\n\nRight now it only parses c-lightning channels and node json, but I'm\ncurrently adding support for LND. I've only tested on linux, so it would\nbe great if we could get this working on macos/windows as well.\n\nPicture: https://jb55.com/s/abe49a248360d41c.png\nCode: https://github.com/jb55/lnvis\n\n\nHow it works\n------------\n\nLNvis renders the Lightning Network channel gossip, which include nodes\nand the edges (channels) between those nodes.\n\n- Channels are colored by the node that opened the channel\n- Channel widths are rendered proportional to the capacity\n- Right clicking a node filters the view to that node and its neighbors\n- Dragging a node in any view will focus that node and its neihbors\n\nThat's about it for now. Next things that I think would be fun to have:\n\n- Filter by alias/id in the UI\n- \"Google Maps\" mode for highlighting potential routes between nodes\n- Realtime channel updates from network gossip\n\nAny other ideas and suggesstions would be great.\n\nContributors welcome!\n\nCheers,\nWill"
            }
        ],
        "thread_summary": {
            "title": "LNvis alpha - A Lightning Network Visualizer",
            "categories": [
                "bitcoin-dev",
                "announce"
            ],
            "authors": [
                "William Casarin"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1216
        }
    },
    {
        "title": "[bitcoin-dev] Brock Pierce?",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2018-08-17T18:57:13",
                "message_text_only": ">From a censorship resistance point of view, I don't see EOS as a viable solution period. And anything supported by a pedo like Brock is just begging for failure."
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-17T18:58:50",
                "message_text_only": ">From a censorship resistance point of view, I don't see EOS as a viable solution period. And anything supported by a pedo like Brock is just begging for failure."
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-17T19:15:49",
                "message_text_only": "-----BEGIN PGP MESSAGE-----\n\nhQEMA8xUMVQPvvGFAQf9HMeq6x4tXQlQEOeVj6IHlY7JRBREjSbmz9vPp9UyZs/v\nxCZ4vE6J0AHJBIri8o96Sqfl4JV81DwEg17ex5WgVzrh+7F33o6fEMwm0dnH1Zl+\nyyhbJZzequgZIUHySUanmZMR2k+tPiuUEMXkWKQ0iKOv/mttUnN5M5kL/qMX0dlV\noN1u3l5B1XRjLZA6ZZzhMNDztFsUh4RxrIJmKMyZEgZP0ouhLwPvOIP8bXC6VyED\nY3oIy7eDxr6Dydypg1ajxuKF5sqCZOSpdCGaiS0npz/a8rqLz8SCo2UvZijabYpx\nRvZqArXJwH1jZ68ak7q2NlGM7w/bVzV1LvuQDqA+OtLCkQEjH5txfrszBDz5HIsZ\nT5QEEDs9FeEd317o05BLv5aD7pOaoGQ+7sMOgWqVUB4DLi8pyYTdz4knEU2SLgcq\nCVcuJYm2fEoQRVJ+JMmf97kiw00A2RvuKYkYK2FzNGKH9PMWgm5xmGrzkPGULnMW\n76ID5XQHE6qCae5ZqP2cthn3CDmVf7+GRQ5Snyw0Bg4drxKFo1W3RN4Hi70fDAk5\nnBZv5Epdex23yqG7BQh/glT5V3Xsta9j3k1S4YR5TyOrOkgYM8uDj5EQ2Eh+XcLZ\nsoXMa64ROl87VGRTpjp+sSjd5hvr8VTiXHGSnbSrJes3H6Vt156507zmQOvqI/Bv\nfgoPEFc+rMBL/iuf2/dWh5gbEm4qIy3X5DjmPZszpVUoEktFsaqN+A4fjBaeH3cv\ns/NPVMWL7nwg5r8+icrZ9FOv58WnLljL/T7M29eanS9Ktc5+WuH4w6vgn73HTUPX\nIV6IKl7QbrFrDf9FuSGHf7i7w6RAgwX0FKDaAra5hx5VEOUeSTAUZAzSqdcXgxIJ\noJzfPxrvEh9Eu6uzTF2fBtX6QrQ9qbAr++R8Bre+003/x/QtIlk0Cp14vVOljr7o\ndnt+VwB0p5UCXWcPdK/tVdbv3D1+9gYaMZbYs9NJiDT/oeX4V1oHTBH+WXf+DaDQ\nWb5bhmr32oEngl78IF7n0hXVpcF1qzikw2jWwI4oVRe6swcEEOUOj6w+3MVqZZuN\n+hrLU4CkxC38pHzBPGOGKcAD3ceUeUZUx+YIG3yy9gn4dJ/ZdUEFbywIOtOgpatc\nM17OkJY7vxENKKzu9lib38NVL32lpmFbvd5epONyfka0pN4r5mj698KuvS3gl3/E\nSvkd/8itfYTIuCyoriLup+ohmIiib1XZysEeN1Iv22VLak6cvzg6L3cFgsGPUasw\nKzwyqTBVukF+07tl06M6VjFHp9WFx1gRN0SospSZYrtn4GpoK3rxELBy0gB2xCdk\ndWy5oTFZrVtMD1oX6UQ1w88wXJzheY7sw32deEbE/vbCyTg4wXt05qauCKJy+Tsc\nHLM9r6j5Jel3uCvnWia4EcPI2Kg7/C+/gLPGq12JaNGFwG1VIHpW9pr04CMOEr+3\nEtszVbl9V5h0MZ3/nHTv8RINtQ==\n=t7vZ\n-----END PGP MESSAGE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-17T19:18:19",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\n<try that afain, stupid k9mail>\n\nFake.\n\nNote how this message isn't PGP signed, and the headers show it coming from a different server than my usual one.\n\nNot at a computer to check, but likely the SPF filtering on the list mail server isn't working.\n\nOn August 17, 2018 7:15:49 PM UTC, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>-----BEGIN PGP MESSAGE-----\n>\n>hQEMA8xUMVQPvvGFAQf9HMeq6x4tXQlQEOeVj6IHlY7JRBREjSbmz9vPp9UyZs/v\n>xCZ4vE6J0AHJBIri8o96Sqfl4JV81DwEg17ex5WgVzrh+7F33o6fEMwm0dnH1Zl+\n>yyhbJZzequgZIUHySUanmZMR2k+tPiuUEMXkWKQ0iKOv/mttUnN5M5kL/qMX0dlV\n>oN1u3l5B1XRjLZA6ZZzhMNDztFsUh4RxrIJmKMyZEgZP0ouhLwPvOIP8bXC6VyED\n>Y3oIy7eDxr6Dydypg1ajxuKF5sqCZOSpdCGaiS0npz/a8rqLz8SCo2UvZijabYpx\n>RvZqArXJwH1jZ68ak7q2NlGM7w/bVzV1LvuQDqA+OtLCkQEjH5txfrszBDz5HIsZ\n>T5QEEDs9FeEd317o05BLv5aD7pOaoGQ+7sMOgWqVUB4DLi8pyYTdz4knEU2SLgcq\n>CVcuJYm2fEoQRVJ+JMmf97kiw00A2RvuKYkYK2FzNGKH9PMWgm5xmGrzkPGULnMW\n>76ID5XQHE6qCae5ZqP2cthn3CDmVf7+GRQ5Snyw0Bg4drxKFo1W3RN4Hi70fDAk5\n>nBZv5Epdex23yqG7BQh/glT5V3Xsta9j3k1S4YR5TyOrOkgYM8uDj5EQ2Eh+XcLZ\n>soXMa64ROl87VGRTpjp+sSjd5hvr8VTiXHGSnbSrJes3H6Vt156507zmQOvqI/Bv\n>fgoPEFc+rMBL/iuf2/dWh5gbEm4qIy3X5DjmPZszpVUoEktFsaqN+A4fjBaeH3cv\n>s/NPVMWL7nwg5r8+icrZ9FOv58WnLljL/T7M29eanS9Ktc5+WuH4w6vgn73HTUPX\n>IV6IKl7QbrFrDf9FuSGHf7i7w6RAgwX0FKDaAra5hx5VEOUeSTAUZAzSqdcXgxIJ\n>oJzfPxrvEh9Eu6uzTF2fBtX6QrQ9qbAr++R8Bre+003/x/QtIlk0Cp14vVOljr7o\n>dnt+VwB0p5UCXWcPdK/tVdbv3D1+9gYaMZbYs9NJiDT/oeX4V1oHTBH+WXf+DaDQ\n>Wb5bhmr32oEngl78IF7n0hXVpcF1qzikw2jWwI4oVRe6swcEEOUOj6w+3MVqZZuN\n>+hrLU4CkxC38pHzBPGOGKcAD3ceUeUZUx+YIG3yy9gn4dJ/ZdUEFbywIOtOgpatc\n>M17OkJY7vxENKKzu9lib38NVL32lpmFbvd5epONyfka0pN4r5mj698KuvS3gl3/E\n>Svkd/8itfYTIuCyoriLup+ohmIiib1XZysEeN1Iv22VLak6cvzg6L3cFgsGPUasw\n>KzwyqTBVukF+07tl06M6VjFHp9WFx1gRN0SospSZYrtn4GpoK3rxELBy0gB2xCdk\n>dWy5oTFZrVtMD1oX6UQ1w88wXJzheY7sw32deEbE/vbCyTg4wXt05qauCKJy+Tsc\n>HLM9r6j5Jel3uCvnWia4EcPI2Kg7/C+/gLPGq12JaNGFwG1VIHpW9pr04CMOEr+3\n>EtszVbl9V5h0MZ3/nHTv8RINtQ==\n>=t7vZ\n>-----END PGP MESSAGE-----\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n- --\nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-----BEGIN PGP SIGNATURE-----\n\niQE9BAEBCgAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJbdx97\nAAoJEGOZARBE6K+yz4MH/iNVDolc3WhC6/eF5P9EVfGbVfvS5hgvqa+9pxQHq8Wt\nBcdey7E0gTMAO8o/yPsYWcUJoj7zqILiHWnpO+qop065hql3AsCocx9ePLH3pZ+D\n+bY0th9brMpF6sR4PyFXvvgwlnXMJaMGbujnzHrMtdx29Ll254idOOaq2n+FMPdM\nrgkV8EYCH7xs2LCkGu4hkseqFgrbupXQ/X/RlLCB351Jbf6KlCol/Po7sqCg9Wlj\nwVatmkp5eDMfFH3cUnrNC+tJY+OEiGf6rg3+Vu2CDex2Bf7PbIMJYuTiN3ZQB6Ak\nOqbPcLpIiSjbry/cA1j+gWgD9YuuElB+1mFtxt1B+KE=\n=ggZJ\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Brock Pierce?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 4669
        }
    },
    {
        "title": "[bitcoin-dev] Suggestion for a universal bitcoin value scale",
        "thread_messages": [
            {
                "author": "damgaard.martin at gmail.com",
                "date": "2018-08-18T20:10:04",
                "message_text_only": "Hi bitcoin-dev at lists.linuxfoundation.org\nHere is my humble attempt to make a contribution to the impressive work that you all are doing. \nI am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\nI have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n\nThank you and all the best \nMartin Damgaard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Universal bitcoin value color scale.rtf\nType: application/rtf\nSize: 236624 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.rtf>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Universal bitcoin value color scale.pdf\nType: application/pdf\nSize: 606867 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.pdf>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Universal bitcoin value color scale.docx\nType: application/vnd.openxmlformats-officedocument.wordprocessingml.document\nSize: 44130 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180818/38605387/attachment-0001.docx>"
            },
            {
                "author": "Rodolfo Novak",
                "date": "2018-08-19T11:42:13",
                "message_text_only": "This is not a good solution. In UX colors have expected meaning. Red often means error, yellow cation, green possible, etc... \n\nText doesn\u2019t have good legibility in colors, monochrome high contrast being the best.\n\nYou will also have issues with colorblind people.\n\nRodolfo \n\n\u211d.\n\n> On Aug 18, 2018, at 16:10, Martin Damgaard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hi bitcoin-dev at lists.linuxfoundation.org\n> Here is my humble attempt to make a contribution to the impressive work that you all are doing.\n> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\n> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n>  \n> Thank you and all the best\n> Martin Damgaard\n> <Universal bitcoin value color scale.rtf>\n> <Universal bitcoin value color scale.pdf>\n> <Universal bitcoin value color scale.docx>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180819/50ffe6d6/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-08-20T23:36:14",
                "message_text_only": "I think you have correctly identified dealing with small amounts while working in the \"bitcoin\" denomination as a major pain point, and I will go as far as agreeing that a standard color coding would help people eyeball what 0.000011 BTC means if they were used to seeing the same color pallet.\n\nHowever, I don't think it's a good solution. I strongly suspect very few services or wallets are going to be willing to adopt such a thing as it'll make their design look ridiculous and it's cumbersome to type.\n\nFurthermore, my experience in using BIP76 (Bits Denomination) in several services with people of varying levels of familiarity to be entirely positive, and in my strong believe a vastly superior solution that should be advocated and used more.\n\nAnd BTW i think what would help the readability of the \"bitcoin\" denomination more than colors if it was standard to always write it to 8 decimal places (e.g. 0.00001100 BTC) which I think is a bit more useful in allowing people to eyeball the size.\n\n-Ryan\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn August 18, 2018 1:10 PM, Martin Damgaard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi bitcoin-dev at lists.linuxfoundation.org\n>\n> Here is my humble attempt to make a contribution to the impressive work that you all are doing.\n>\n> I am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\n>\n> I have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n>\n> Thank you and all the best\n>\n> Martin Damgaard\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180820/3650a9b1/attachment.html>"
            },
            {
                "author": "damgaard.martin at gmail.com",
                "date": "2018-08-19T14:21:55",
                "message_text_only": "Hi \nI have made a GitHub version of the suggestion:\n\nhttps://github.com/damse0045/Universal-bitcoin-value-color-scale./tree/master\n\nwhere I have collected the commons made to the first version in a remarks-file. \nI will try to make a new version incorporation the different commons, and if anyone would like to help they will be more than welcome to join.\n\nAll kind of suggestions are more than welcome, and thank you for the good points made so far. \n\nAll the best \nMartin\n\nFra: Ad\u00e1n S\u00e1nchez de Pedro Crespo\nSendt: 19. august 2018 11:11\nTil: damgaard.martin at gmail.com; bitcoin-dev at lists.linuxfoundation.org\nEmne: Re: [bitcoin-dev] Suggestion for a universal bitcoin value scale\n\nIt would be great if you could submit this as a markdown document published somewhere with version control, such as GitHub. That'd make life easier for anyone willing to contribute to your proposal.\n\nOn Sat, 18 Aug 2018 22:26 Martin Damgaard via bitcoin-dev, <bitcoin-dev at lists.linuxfoundation.org> wrote:\nHi bitcoin-dev at lists.linuxfoundation.org\nHere is my humble attempt to make a contribution to the impressive work that you all are doing. \nI am unfamiliar with the normal BIP procedures. I have therefore just tried to follow the example of BIP 176 by Jimmy Song, in order make something similar. I suggest a universal bitcoin value color scale, for tackling the same decimal problem, as identified by the BIP 176 proposal.\nI have attached the document in three different formats (*.rtf, *.pdf and *.docx) as I do not know your preferred format. I hope you will find my suggestion useful.\n\u00a0\nThank you and all the best \nMartin Damgaard\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180819/43cbc940/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Suggestion for a universal bitcoin value scale",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rodolfo Novak",
                "damgaard.martin at gmail.com",
                "rhavar at protonmail.com"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7294
        }
    },
    {
        "title": "[bitcoin-dev] Getting around to fixing the timewarp attack.",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2018-08-20T20:14:50",
                "message_text_only": "Since 2012 (IIRC) we've known that Bitcoin's non-overlapping\ndifficulty calculation was vulnerable to gaming with inaccurate\ntimestamps to massively increase the rate of block production beyond\nthe system's intentional design. It can be fixed with a soft-fork that\nfurther constraints block timestamps, and a couple of proposals have\nbeen floated along these lines.\n\nI put a demonstration of timewarp early in the testnet3 chain to also\nlet people test mitigations against that.  It pegs the difficulty way\ndown and then churned out blocks at the maximum rate that the median\ntime protocol rule allows.\n\nI, and I assume others, haven't put a big priority into fixing this\nvulnerability because it requires a majority hashrate and could easily\nbe blocked if someone started using it.\n\nBut there haven't been too many other network consensus rules going on\nright now, and I believe at least several of the proposals suggested\nare fully compatible with existing behaviour and only trigger in the\npresence of exceptional circumstances-- e.g. a timewarp attack.  So\nthe risk of deploying these mitigations would be minimal.\n\nBefore I dust off my old fix and perhaps prematurely cause fixation on\na particular approach, I thought it would be useful to ask the list if\nanyone else was aware of a favourite backwards compatible timewarp fix\nproposal they wanted to point out.\n\nCheers."
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2018-08-22T13:48:16",
                "message_text_only": "I only knew about ArtForz's fix, which isn't backwards compatible.\n\nhttps://github.com/bitcoin/bitcoin/compare/0.11...jtimon:hardfork-timewarp-0.11\nhttps://github.com/bitcoin/bips/blob/master/bip-0099.mediawiki#code\n\n\nOn Mon, Aug 20, 2018 at 10:14 PM, Gregory Maxwell via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Since 2012 (IIRC) we've known that Bitcoin's non-overlapping\n> difficulty calculation was vulnerable to gaming with inaccurate\n> timestamps to massively increase the rate of block production beyond\n> the system's intentional design. It can be fixed with a soft-fork that\n> further constraints block timestamps, and a couple of proposals have\n> been floated along these lines.\n>\n> I put a demonstration of timewarp early in the testnet3 chain to also\n> let people test mitigations against that.  It pegs the difficulty way\n> down and then churned out blocks at the maximum rate that the median\n> time protocol rule allows.\n>\n> I, and I assume others, haven't put a big priority into fixing this\n> vulnerability because it requires a majority hashrate and could easily\n> be blocked if someone started using it.\n>\n> But there haven't been too many other network consensus rules going on\n> right now, and I believe at least several of the proposals suggested\n> are fully compatible with existing behaviour and only trigger in the\n> presence of exceptional circumstances-- e.g. a timewarp attack.  So\n> the risk of deploying these mitigations would be minimal.\n>\n> Before I dust off my old fix and perhaps prematurely cause fixation on\n> a particular approach, I thought it would be useful to ask the list if\n> anyone else was aware of a favourite backwards compatible timewarp fix\n> proposal they wanted to point out.\n>\n> Cheers.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-08-24T09:35:11",
                "message_text_only": "To determine the new difficulty, it is supposed to compare the timestamps of block (2016n - 1) with block (2016n - 2017). However, an off-by-one bug makes it compares with block (2016n - 2016) instead.\n\nA naive but perfect fix is to require every block (2016x) to have a timestamp not smaller than that of its parent block. However, a chain-split would happen even without any attack, unless super-majority of miners are enforcing the new rules. This also involves mandatory upgrade of pool software (cf. pool software upgrade is not mandatory for segwit). The best way is to do it with something like BIP34, which also requires new pool software. \n\nWe could have a weaker version of this, to require the timestamp of block (2016x) not smaller than its parent block by t-seconds, with 0 <= t <= infinity. With a bigger t, the fix is less effective but also less likely to cause intentional/unintentional split. Status quo is t = infinity.\n\nReducing the value of t is a softfork. The aim is to find a t which is small-enough-to-prohibit-time-wrap-attack but also big-enough-to-avoid-split. With t=86400 (one day), a time-wrap attacker may bring down the difficulty by about 1/14 = 7.1% per round. Unless new blocks were coming incredibly slow, the attacker needs to manipulate the MTP for at least 24 hours, or try to rewrite 24 hours of history. Such scale of 51% attack is already above the 100-block coinbase maturity safety theshold and we are facing a much bigger problem.\n\nWith t=86400, a non-majority, opportunistic attacker may split the chain only if we have no new block for at least 24 - 2 = 22 hours (2-hours is the protocol limit for using a future timestamp) at the exact moment of retarget. That means no retarget is possible in the next 2016 blocks. Doing a time-wrap attack at this point is not quite interesting as the coin is probably already worthless. Again, this is a much bigger problem than the potential chain spilt. People will yell for a difficulty (and time wrap fix, maybe) hardfork to resuscitate the chain.\n\n \n\n\n> On 21 Aug 2018, at 4:14 AM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Since 2012 (IIRC) we've known that Bitcoin's non-overlapping\n> difficulty calculation was vulnerable to gaming with inaccurate\n> timestamps to massively increase the rate of block production beyond\n> the system's intentional design. It can be fixed with a soft-fork that\n> further constraints block timestamps, and a couple of proposals have\n> been floated along these lines.\n> \n> I put a demonstration of timewarp early in the testnet3 chain to also\n> let people test mitigations against that.  It pegs the difficulty way\n> down and then churned out blocks at the maximum rate that the median\n> time protocol rule allows.\n> \n> I, and I assume others, haven't put a big priority into fixing this\n> vulnerability because it requires a majority hashrate and could easily\n> be blocked if someone started using it.\n> \n> But there haven't been too many other network consensus rules going on\n> right now, and I believe at least several of the proposals suggested\n> are fully compatible with existing behaviour and only trigger in the\n> presence of exceptional circumstances-- e.g. a timewarp attack.  So\n> the risk of deploying these mitigations would be minimal.\n> \n> Before I dust off my old fix and perhaps prematurely cause fixation on\n> a particular approach, I thought it would be useful to ask the list if\n> anyone else was aware of a favourite backwards compatible timewarp fix\n> proposal they wanted to point out.\n> \n> Cheers.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Bram Cohen",
                "date": "2018-08-30T20:55:17",
                "message_text_only": "This seems like a case where a distinction should be made between soft\nforks which are likely to cause non-upgraded miners to get orphaned and\nones where they are. Of course in this case it's only 1/2016 of all blocks\nso it doesn't really matter, but it's worth thinking about the principle.\nIn general soft forks are better when they don't cause orphaning on\nnon-upgraded miners.\n\nThe whole problem seems to be caused by the difference between the\ntimestamps at the end of a period and the block right after it. Soft\nforking to force those to be 'close enough' together sounds like a solid\napproach. Given that blocks are generally send around fairly quickly, and\nthat blocks more than two hours in the future are ignored, it seems\nreasonable to not allow a backwards jump of that plus some safety\nparameter. Let's say three hours. It also feels like a good idea to not\nallow a jump of more than three hours forwards either, just on principle.\n\nThat should result in minimal code changes, and rarely any orphaning of\nnon-upgraded miners at all, and still only 1/2016 blocks when they do. And\nno trace of a hard fork. It suffers from still allowing the attack a little\nbit, but three hours out of every two weeks seems like no big deal.\n\nOn Sat, Aug 25, 2018 at 5:10 AM Johnson Lau via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> To determine the new difficulty, it is supposed to compare the timestamps\n> of block (2016n - 1) with block (2016n - 2017). However, an off-by-one bug\n> makes it compares with block (2016n - 2016) instead.\n>\n> A naive but perfect fix is to require every block (2016x) to have a\n> timestamp not smaller than that of its parent block. However, a chain-split\n> would happen even without any attack, unless super-majority of miners are\n> enforcing the new rules. This also involves mandatory upgrade of pool\n> software (cf. pool software upgrade is not mandatory for segwit). The best\n> way is to do it with something like BIP34, which also requires new pool\n> software.\n>\n> We could have a weaker version of this, to require the timestamp of block\n> (2016x) not smaller than its parent block by t-seconds, with 0 <= t <=\n> infinity. With a bigger t, the fix is less effective but also less likely\n> to cause intentional/unintentional split. Status quo is t = infinity.\n>\n> Reducing the value of t is a softfork. The aim is to find a t which is\n> small-enough-to-prohibit-time-wrap-attack but also\n> big-enough-to-avoid-split. With t=86400 (one day), a time-wrap attacker may\n> bring down the difficulty by about 1/14 = 7.1% per round. Unless new blocks\n> were coming incredibly slow, the attacker needs to manipulate the MTP for\n> at least 24 hours, or try to rewrite 24 hours of history. Such scale of 51%\n> attack is already above the 100-block coinbase maturity safety theshold and\n> we are facing a much bigger problem.\n>\n> With t=86400, a non-majority, opportunistic attacker may split the chain\n> only if we have no new block for at least 24 - 2 = 22 hours (2-hours is the\n> protocol limit for using a future timestamp) at the exact moment of\n> retarget. That means no retarget is possible in the next 2016 blocks. Doing\n> a time-wrap attack at this point is not quite interesting as the coin is\n> probably already worthless. Again, this is a much bigger problem than the\n> potential chain spilt. People will yell for a difficulty (and time wrap\n> fix, maybe) hardfork to resuscitate the chain.\n>\n>\n>\n>\n> > On 21 Aug 2018, at 4:14 AM, Gregory Maxwell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > Since 2012 (IIRC) we've known that Bitcoin's non-overlapping\n> > difficulty calculation was vulnerable to gaming with inaccurate\n> > timestamps to massively increase the rate of block production beyond\n> > the system's intentional design. It can be fixed with a soft-fork that\n> > further constraints block timestamps, and a couple of proposals have\n> > been floated along these lines.\n> >\n> > I put a demonstration of timewarp early in the testnet3 chain to also\n> > let people test mitigations against that.  It pegs the difficulty way\n> > down and then churned out blocks at the maximum rate that the median\n> > time protocol rule allows.\n> >\n> > I, and I assume others, haven't put a big priority into fixing this\n> > vulnerability because it requires a majority hashrate and could easily\n> > be blocked if someone started using it.\n> >\n> > But there haven't been too many other network consensus rules going on\n> > right now, and I believe at least several of the proposals suggested\n> > are fully compatible with existing behaviour and only trigger in the\n> > presence of exceptional circumstances-- e.g. a timewarp attack.  So\n> > the risk of deploying these mitigations would be minimal.\n> >\n> > Before I dust off my old fix and perhaps prematurely cause fixation on\n> > a particular approach, I thought it would be useful to ask the list if\n> > anyone else was aware of a favourite backwards compatible timewarp fix\n> > proposal they wanted to point out.\n> >\n> > Cheers.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/579ee190/attachment-0001.html>"
            },
            {
                "author": "Zawy",
                "date": "2018-08-29T09:54:17",
                "message_text_only": "Rather than restricting every timestamp (or just the 2016*N+1\ntimestamps) to >= 1+ the previous timestamp as recorded on the\nblockchain, the difficulty calculation could have the same restriction\nbut only in how the timestamps are used. I don't know about backwards\ncompatibility.  Either way, this would also prevent the powLimit\nattack that is also capable of getting \"unlimited\" blocks in less than\n4 weeks of > 50% selfish mining.  LTC, BCH, and LTC fixed to the\n\"Zeitgeist\" or \"timewarp\" attack on GeistGeld in 2011 described by\nArtforz in different ways, but all are still vulnerable by the\npowLimit attack that I described here:\nhttps://github.com/zawy12/difficulty-algorithms/issues/30\n\nOther solutions may not prevent this other attack."
            }
        ],
        "thread_summary": {
            "title": "Getting around to fixing the timewarp attack.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zawy",
                "Johnson Lau",
                "Jorge Tim\u00f3n",
                "Gregory Maxwell",
                "Bram Cohen"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13475
        }
    },
    {
        "title": "[bitcoin-dev] BIP171 - Specs, Mock server, template project and client librairies",
        "thread_messages": [
            {
                "author": "St\u00e9phane Traumat",
                "date": "2018-08-21T21:12:47",
                "message_text_only": "Hello,\n\nI worked on the BIP 171\n<https://github.com/bitcoin/bips/blob/master/bip-0171.mediawiki> and I\ncreated Cerise <http://www.cerise.tech/> (github\n<https://github.com/straumat/cerise>) that provides the following artifacts\n:\n\n\n   - BIP-0171 specifications <http://www.cerise.tech/#specifications>.\n   - A mocked BIP-0171 compliant server available online\n   <http://api.cerise.tech/swagger-ui.html> you can use to understand the\n   API and make calls.\n   - A mocked BIP-0171 compliant server as a Java application\n   <https://github.com/straumat/cerise-server-mock/> you can use to develop\n   your client application.\n   - A mocked BIP-0171 compliant server as a Docker image\n   <https://hub.docker.com/r/straumat/cerise-server-mock/> you can use to\n   develop your client application.\n   - A BIP-0171 library <https://github.com/straumat/cerise/> to transform\n   your application in a BIP-0171 server.\n   - A server template project\n   <https://github.com/straumat/cerise-server-template> to quickly write\n   your implementation and automatically produce your BIP-0171 server.\n   - A collection of client libraries <http://www.cerise.tech/#clients> to\n   call any BIP-0171 compliant server with your favorite language.\n\nI made some proposal of evolutions here :\nhttps://github.com/bitcoin/bips/wiki/Comments:BIP-0171\n\nI hope it helps and if you have any suggestion on how I could help more,\nlet me know.\n-- \n*St\u00e9phane Traumat*\nhttps://about.me/straumat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180821/5c88e22d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP171 - Specs, Mock server, template project and client librairies",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "St\u00e9phane Traumat"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1641
        }
    },
    {
        "title": "[bitcoin-dev] Building a Bitcoin API and query system.",
        "thread_messages": [
            {
                "author": "Blockchain Group",
                "date": "2018-08-26T19:58:50",
                "message_text_only": "Hello everyone,\n\nI am C++ & Node.js developer. I want to propose making a new Bitcoin API\nthat supports fast quering of Bitcoin blocks and transactions without the\nneed for syncing with all previous nodes.\n\nIn a typical case where I want to build a full fleged Bitcoin explorer cum\nwallet system on my end with external APIs, I need to sync my node and then\nquery for the information I need to show separately. I am proposing a\nunified method of finding/quering the blockchain data with a standardized\ntemplate containing minimal information about the actual mined block or\ntransaction yet satify the need of what I want to query.\n\nI am working on making a template and a support mechanism on Node.js. I\nwant to propose it as an improvement (BIP). It will be a great help to\nfuture web developers who want to make something similar.\n\nThanks\nSumit Lahiri.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180827/65f05e9a/attachment.html>"
            },
            {
                "author": "Joseph Gleason \u2448",
                "date": "2018-08-28T15:15:06",
                "message_text_only": "For what it is worth, electrum has a lot or possibly all of what you are\ntalking about since the electrum servers are designed to quickly answer the\nqueries of light clients.  So right now, you could sync up an electrum\nserver or use an existing public one and send queries to it with json-rpc.\n\nhttps://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst\n\n\nOn Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> I am C++ & Node.js developer. I want to propose making a new Bitcoin API\n> that supports fast quering of Bitcoin blocks and transactions without the\n> need for syncing with all previous nodes.\n>\n> In a typical case where I want to build a full fleged Bitcoin explorer cum\n> wallet system on my end with external APIs, I need to sync my node and then\n> query for the information I need to show separately. I am proposing a\n> unified method of finding/quering the blockchain data with a standardized\n> template containing minimal information about the actual mined block or\n> transaction yet satify the need of what I want to query.\n>\n> I am working on making a template and a support mechanism on Node.js. I\n> want to propose it as an improvement (BIP). It will be a great help to\n> future web developers who want to make something similar.\n>\n> Thanks\n> Sumit Lahiri.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/241a010d/attachment.html>"
            },
            {
                "author": "Matias Alejo Garcia",
                "date": "2018-08-28T15:47:10",
                "message_text_only": "Hi Sumit,\n\nTake a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a\nbitcoin indexing API server, with several modules, like a block explorer, a\nwallet module, etc. It is built using Node.js.\n\nmat\u00edas\n\nOn Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason \u2448 via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> For what it is worth, electrum has a lot or possibly all of what you are\n> talking about since the electrum servers are designed to quickly answer the\n> queries of light clients.  So right now, you could sync up an electrum\n> server or use an existing public one and send queries to it with json-rpc.\n>\n>\n> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst\n>\n>\n> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello everyone,\n>>\n>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API\n>> that supports fast quering of Bitcoin blocks and transactions without the\n>> need for syncing with all previous nodes.\n>>\n>> In a typical case where I want to build a full fleged Bitcoin explorer\n>> cum wallet system on my end with external APIs, I need to sync my node and\n>> then query for the information I need to show separately. I am proposing a\n>> unified method of finding/quering the blockchain data with a standardized\n>> template containing minimal information about the actual mined block or\n>> transaction yet satify the need of what I want to query.\n>>\n>> I am working on making a template and a support mechanism on Node.js. I\n>> want to propose it as an improvement (BIP). It will be a great help to\n>> future web developers who want to make something similar.\n>>\n>> Thanks\n>> Sumit Lahiri.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nMat\u00edas Alejo Garcia\n@ematiu\nRoads? Where we're going, we don't need roads!\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/b50caacc/attachment.html>"
            },
            {
                "author": "Blockchain Group",
                "date": "2018-08-28T17:34:04",
                "message_text_only": "Thanks, I'll check it out.\n\nOn Tue, Aug 28, 2018, 9:17 PM Matias Alejo Garcia <ematiu at gmail.com> wrote:\n\n> Hi Sumit,\n>\n> Take a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a\n> bitcoin indexing API server, with several modules, like a block explorer, a\n> wallet module, etc. It is built using Node.js.\n>\n> mat\u00edas\n>\n> On Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason \u2448 via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> For what it is worth, electrum has a lot or possibly all of what you are\n>> talking about since the electrum servers are designed to quickly answer the\n>> queries of light clients.  So right now, you could sync up an electrum\n>> server or use an existing public one and send queries to it with json-rpc.\n>>\n>>\n>> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst\n>>\n>>\n>> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hello everyone,\n>>>\n>>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API\n>>> that supports fast quering of Bitcoin blocks and transactions without the\n>>> need for syncing with all previous nodes.\n>>>\n>>> In a typical case where I want to build a full fleged Bitcoin explorer\n>>> cum wallet system on my end with external APIs, I need to sync my node and\n>>> then query for the information I need to show separately. I am proposing a\n>>> unified method of finding/quering the blockchain data with a standardized\n>>> template containing minimal information about the actual mined block or\n>>> transaction yet satify the need of what I want to query.\n>>>\n>>> I am working on making a template and a support mechanism on Node.js. I\n>>> want to propose it as an improvement (BIP). It will be a great help to\n>>> future web developers who want to make something similar.\n>>>\n>>> Thanks\n>>> Sumit Lahiri.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> --\n> Mat\u00edas Alejo Garcia\n> @ematiu\n> Roads? Where we're going, we don't need roads!\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/7527bd24/attachment-0001.html>"
            },
            {
                "author": "Guido Dassori",
                "date": "2018-08-28T17:51:11",
                "message_text_only": "Hi Sumit,\n\nThere's no protocol api to fetch a single transaction over the p2p network.\nYou can query peers for mempool transactions, but once there are into a\nblock, no way to obtain them without fetching the entire block.\n\nAlso, you may want to take a look to spruned (\nhttps://github.com/gdassori/spruned), it uses both the electrum & the p2p\nnetwork to do the same job you are researching on. It serves the data by\nemulating some of the bitcoind rpc api, to be suitable by bitcoind backed\napplications.\n\nGuido\n\nIl giorno mar 28 ago 2018 alle ore 19:41 Blockchain Group via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> ha scritto:\n\n> Thanks, I'll check it out.\n>\n> On Tue, Aug 28, 2018, 9:17 PM Matias Alejo Garcia <ematiu at gmail.com>\n> wrote:\n>\n>> Hi Sumit,\n>>\n>> Take a look at https://github.com/bitpay/bitcore/tree/v8.0.0, it is a\n>> bitcoin indexing API server, with several modules, like a block explorer, a\n>> wallet module, etc. It is built using Node.js.\n>>\n>> mat\u00edas\n>>\n>> On Tue, Aug 28, 2018 at 12:43 PM Joseph Gleason \u2448 via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> For what it is worth, electrum has a lot or possibly all of what you are\n>>> talking about since the electrum servers are designed to quickly answer the\n>>> queries of light clients.  So right now, you could sync up an electrum\n>>> server or use an existing public one and send queries to it with json-rpc.\n>>>\n>>>\n>>> https://github.com/kyuupichan/electrumx/blob/master/docs/protocol-methods.rst\n>>>\n>>>\n>>> On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Hello everyone,\n>>>>\n>>>> I am C++ & Node.js developer. I want to propose making a new Bitcoin\n>>>> API that supports fast quering of Bitcoin blocks and transactions without\n>>>> the need for syncing with all previous nodes.\n>>>>\n>>>> In a typical case where I want to build a full fleged Bitcoin explorer\n>>>> cum wallet system on my end with external APIs, I need to sync my node and\n>>>> then query for the information I need to show separately. I am proposing a\n>>>> unified method of finding/quering the blockchain data with a standardized\n>>>> template containing minimal information about the actual mined block or\n>>>> transaction yet satify the need of what I want to query.\n>>>>\n>>>> I am working on making a template and a support mechanism on Node.js. I\n>>>> want to propose it as an improvement (BIP). It will be a great help to\n>>>> future web developers who want to make something similar.\n>>>>\n>>>> Thanks\n>>>> Sumit Lahiri.\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>>\n>> --\n>> Mat\u00edas Alejo Garcia\n>> @ematiu\n>> Roads? Where we're going, we don't need roads!\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/85af1390/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-08-28T18:14:46",
                "message_text_only": "https://libbitcoin.org\n\n> On Aug 28, 2018, at 10:34, Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Thanks, I'll check it out.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/33f15001/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2018-08-28T18:36:21",
                "message_text_only": "Hi\n\nTo give a critical viewpoint on a such API:\n\nSuch APIs usually result in central validation, meaning that users trust API services rather the validating their own data. It break some of the fundamental properties of Bitcoin (avoid trusted third parties).\nSystems or applications depending on a full indexed blockchain (a thus such API) do usually scale pretty bad.\n\nI\u2019d like to hear some concrete use-cases for a such block explorer(ish) API.\n\nThanks\n\u2014\nJonas\n\n> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:\n> \n> Hello everyone,\n> \n> I am C++ & Node.js developer. I want to propose making a new Bitcoin API that supports fast quering of Bitcoin blocks and transactions without the need for syncing with all previous nodes.\n> \n> In a typical case where I want to build a full fleged Bitcoin explorer cum wallet system on my end with external APIs, I need to sync my node and then query for the information I need to show separately. I am proposing a unified method of finding/quering the blockchain data with a standardized template containing minimal information about the actual mined block or transaction yet satify the need of what I want to query.\n> \n> I am working on making a template and a support mechanism on Node.js. I want to propose it as an improvement (BIP). It will be a great help to future web developers who want to make something similar.\n> \n> Thanks\n> Sumit Lahiri.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180828/15fc887c/attachment.sig>"
            },
            {
                "author": "Blockchain Group",
                "date": "2018-08-29T12:25:57",
                "message_text_only": "Thanks, I'll check it out.\n\nOn Wed, Aug 29, 2018, 12:06 AM Jonas Schnelli <dev at jonasschnelli.ch> wrote:\n\n> Hi\n>\n> To give a critical viewpoint on a such API:\n>\n> Such APIs usually result in central validation, meaning that users trust\n> API services rather the validating their own data. It break some of the\n> fundamental properties of Bitcoin (avoid trusted third parties).\n> Systems or applications depending on a full indexed blockchain (a thus\n> such API) do usually scale pretty bad.\n>\n> I\u2019d like to hear some concrete use-cases for a such block explorer(ish)\n> API.\n>\n> Thanks\n> \u2014\n> Jonas\n>\n> > Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n> >\n> > Hello everyone,\n> >\n> > I am C++ & Node.js developer. I want to propose making a new Bitcoin API\n> that supports fast quering of Bitcoin blocks and transactions without the\n> need for syncing with all previous nodes.\n> >\n> > In a typical case where I want to build a full fleged Bitcoin explorer\n> cum wallet system on my end with external APIs, I need to sync my node and\n> then query for the information I need to show separately. I am proposing a\n> unified method of finding/quering the blockchain data with a standardized\n> template containing minimal information about the actual mined block or\n> transaction yet satify the need of what I want to query.\n> >\n> > I am working on making a template and a support mechanism on Node.js. I\n> want to propose it as an improvement (BIP). It will be a great help to\n> future web developers who want to make something similar.\n> >\n> > Thanks\n> > Sumit Lahiri.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/2e8fa3d5/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-08-29T14:40:16",
                "message_text_only": "The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, \u201cwithout the need for syncing\u201d. In other words it is the deployment cost of the node that is centralizing.\n\nYet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.\n\nBlock explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.\n\ne\n\n\n> On Aug 28, 2018, at 11:36, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hi\n> \n> To give a critical viewpoint on a such API:\n> \n> Such APIs usually result in central validation, meaning that users trust API services rather the validating their own data. It break some of the fundamental properties of Bitcoin (avoid trusted third parties).\n> Systems or applications depending on a full indexed blockchain (a thus such API) do usually scale pretty bad.\n> \n> I\u2019d like to hear some concrete use-cases for a such block explorer(ish) API.\n> \n> Thanks\n> \u2014\n> Jonas\n> \n>> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:\n>> \n>> Hello everyone,\n>> \n>> I am C++ & Node.js developer. I want to propose making a new Bitcoin API that supports fast quering of Bitcoin blocks and transactions without the need for syncing with all previous nodes.\n>> \n>> In a typical case where I want to build a full fleged Bitcoin explorer cum wallet system on my end with external APIs, I need to sync my node and then query for the information I need to show separately. I am proposing a unified method of finding/quering the blockchain data with a standardized template containing minimal information about the actual mined block or transaction yet satify the need of what I want to query.\n>> \n>> I am working on making a template and a support mechanism on Node.js. I want to propose it as an improvement (BIP). It will be a great help to future web developers who want to make something similar.\n>> \n>> Thanks\n>> Sumit Lahiri.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Blockchain Group",
                "date": "2018-08-29T16:06:43",
                "message_text_only": "Thanks! That is what my main point is.\n\nOn Wed, Aug 29, 2018, 8:10 PM Eric Voskuil <eric at voskuil.org> wrote:\n\n> The API implementation is not what is centralizing, nor is full indexation\n> non-scalable. The centralization is in not running the API from a node\n> under your own control. This is of course implied by the comment, \u201cwithout\n> the need for syncing\u201d. In other words it is the deployment cost of the node\n> that is centralizing.\n>\n> Yet if people relied only on bitcoind and never centralized services there\n> would be *no* block explorers (and no secure light wallets), because it\n> does not provide remote query and does not fully index.\n>\n> Block explorers and light wallets are pretty useful, so presumably some\n> API must provide these features (ideally with reduced deployment cost).\n> That will either be centralized or decentralized services. As such it seems\n> wise to encourage the latter, as opposed to questioning whether there is\n> any valid block explorer use case.\n>\n> e\n>\n>\n> > On Aug 28, 2018, at 11:36, Jonas Schnelli via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > Hi\n> >\n> > To give a critical viewpoint on a such API:\n> >\n> > Such APIs usually result in central validation, meaning that users trust\n> API services rather the validating their own data. It break some of the\n> fundamental properties of Bitcoin (avoid trusted third parties).\n> > Systems or applications depending on a full indexed blockchain (a thus\n> such API) do usually scale pretty bad.\n> >\n> > I\u2019d like to hear some concrete use-cases for a such block explorer(ish)\n> API.\n> >\n> > Thanks\n> > \u2014\n> > Jonas\n> >\n> >> Am 26.08.2018 um 21:58 schrieb Blockchain Group via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n> >>\n> >> Hello everyone,\n> >>\n> >> I am C++ & Node.js developer. I want to propose making a new Bitcoin\n> API that supports fast quering of Bitcoin blocks and transactions without\n> the need for syncing with all previous nodes.\n> >>\n> >> In a typical case where I want to build a full fleged Bitcoin explorer\n> cum wallet system on my end with external APIs, I need to sync my node and\n> then query for the information I need to show separately. I am proposing a\n> unified method of finding/quering the blockchain data with a standardized\n> template containing minimal information about the actual mined block or\n> transaction yet satify the need of what I want to query.\n> >>\n> >> I am working on making a template and a support mechanism on Node.js. I\n> want to propose it as an improvement (BIP). It will be a great help to\n> future web developers who want to make something similar.\n> >>\n> >> Thanks\n> >> Sumit Lahiri.\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/4a0ea125/attachment-0001.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2018-08-29T18:27:51",
                "message_text_only": "> The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, \u201cwithout the need for syncing\u201d. In other words it is the deployment cost of the node that is centralizing.\n\nIMO an API that serves non verifiable data is supporting centralised validation. The \u201eAPI\" which supports one of the most important properties in Bitcoin \u2013 the ability to self-validate \u2013 is the data available via the p2p network.\n\n> \n> Yet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.\n> \n> Block explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.\n\nBitcoin-Core has all required features to partially \u201eindex\u201c data (called the wallet) and provides them via the RPC API. If you don\u2019t need to serve thousands of wallets (which smells after centralised validation), selective indexing (wallets) are the right choice. Also, if you have a proper light client architecture, you can use Bitcoin Core in pruned mode (<10GB of data) to serve an endless amount of wallets (client/server mode, I guess that is what you are referring to with \"light clients\").\n\nI fail to see the use-cases where a fully index blockchain makes sense (the only one I can come up with is instant backup recovery where the transaction history needs to be preserved rather then recovering the UTXOs only).\n\nAlso, the p2p protocol has built in light client support with BIP37 (bloom filters) and soon BIP158 will be available on the network which does allow privacy-preserving \"light clients\" in a way where no trusted layer is required (client <-> p2p network rather then client <-> API provider <-> p2p network).\n\nI don\u2019t want to advocate against a full-index blockexplorer-like API. I just think its important to define the use case and be aware of the consequences and downsides.\n\n/jonas\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/f991e201/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-08-30T10:03:41",
                "message_text_only": "Le 28/08/2018 \u00e0 20:36, Jonas Schnelli via bitcoin-dev a \u00e9crit\u00a0:\n> I\u2019d like to hear some concrete use-cases for a such block explorer(ish) API.\n\nhttps://github.com/Ayms/bitcoin-transactions which is somewhere\nbitcoin-cli outside of bitcoin core with no wallet, which implies that\nyou don't want to mix/provide your wallet with/to the app creating your\ntransactions and/or you don't want to use wallet sw\n\nProblem: quasi nobody succeeds to use it (and probably this trend is\nunlikely to revert), that's why there is https://peersm.com/wallet which\nis querying the info outside and output the right command to use with\nthe tool (or output the transaction if people put their keys, which is\nof course not advised unless they are sure that the corresponding\naddresses are dead ones)\n\nIt is planned to put the app for the advanced mode (ie people must know\nall the parameters) as an offline one inside browsers, then back to the\nabove problem...\n\nSo probably the offline mode should include a phase where the tool\nconnects to some APIs/explorers like the one suggested here before\nswitching to the offline mode to enter the keys, this will always be not\nvery secure for the query phase unless it can become something\ndecentralized (and usable the same way on different networks), which as\nfar as I understand is envisioned here\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Blockchain Group",
                "date": "2018-08-30T11:40:51",
                "message_text_only": "Thanks, I'll check it out.\n\nOn Thu, Aug 30, 2018, 3:33 PM Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n\n>\n>\n> Le 28/08/2018 \u00e0 20:36, Jonas Schnelli via bitcoin-dev a \u00e9crit :\n> > I\u2019d like to hear some concrete use-cases for a such block explorer(ish)\n> API.\n>\n> https://github.com/Ayms/bitcoin-transactions which is somewhere\n> bitcoin-cli outside of bitcoin core with no wallet, which implies that\n> you don't want to mix/provide your wallet with/to the app creating your\n> transactions and/or you don't want to use wallet sw\n>\n> Problem: quasi nobody succeeds to use it (and probably this trend is\n> unlikely to revert), that's why there is https://peersm.com/wallet which\n> is querying the info outside and output the right command to use with\n> the tool (or output the transaction if people put their keys, which is\n> of course not advised unless they are sure that the corresponding\n> addresses are dead ones)\n>\n> It is planned to put the app for the advanced mode (ie people must know\n> all the parameters) as an offline one inside browsers, then back to the\n> above problem...\n>\n> So probably the offline mode should include a phase where the tool\n> connects to some APIs/explorers like the one suggested here before\n> switching to the offline mode to enter the keys, this will always be not\n> very secure for the query phase unless it can become something\n> decentralized (and usable the same way on different networks), which as\n> far as I understand is envisioned here\n>\n> --\n> Bitcoin transactions made simple:\n> https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist:\n> http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/4892d85a/attachment.html>"
            },
            {
                "author": "Blockchain Group",
                "date": "2018-08-29T18:29:18",
                "message_text_only": "Awesome, thanks for the information. I will work on it and keep it in mind.\n\nOn Wed, Aug 29, 2018, 11:57 PM Jonas Schnelli <dev at jonasschnelli.ch> wrote:\n\n>\n> > The API implementation is not what is centralizing, nor is full\n> indexation non-scalable. The centralization is in not running the API from\n> a node under your own control. This is of course implied by the comment,\n> \u201cwithout the need for syncing\u201d. In other words it is the deployment cost of\n> the node that is centralizing.\n>\n> IMO an API that serves non verifiable data is supporting centralised\n> validation. The \u201eAPI\" which supports one of the most important properties\n> in Bitcoin \u2013 the ability to self-validate \u2013 is the data available via the\n> p2p network.\n>\n> >\n> > Yet if people relied only on bitcoind and never centralized services\n> there would be *no* block explorers (and no secure light wallets), because\n> it does not provide remote query and does not fully index.\n> >\n> > Block explorers and light wallets are pretty useful, so presumably some\n> API must provide these features (ideally with reduced deployment cost).\n> That will either be centralized or decentralized services. As such it seems\n> wise to encourage the latter, as opposed to questioning whether there is\n> any valid block explorer use case.\n>\n> Bitcoin-Core has all required features to partially \u201eindex\u201c data (called\n> the wallet) and provides them via the RPC API. If you don\u2019t need to serve\n> thousands of wallets (which smells after centralised validation), selective\n> indexing (wallets) are the right choice. Also, if you have a proper light\n> client architecture, you can use Bitcoin Core in pruned mode (<10GB of\n> data) to serve an endless amount of wallets (client/server mode, I guess\n> that is what you are referring to with \"light clients\").\n>\n> I fail to see the use-cases where a fully index blockchain makes sense\n> (the only one I can come up with is instant backup recovery where the\n> transaction history needs to be preserved rather then recovering the UTXOs\n> only).\n>\n> Also, the p2p protocol has built in light client support with BIP37 (bloom\n> filters) and soon BIP158 will be available on the network which does allow\n> privacy-preserving \"light clients\" in a way where no trusted layer is\n> required (client <-> p2p network rather then client <-> API provider <->\n> p2p network).\n>\n> I don\u2019t want to advocate against a full-index blockexplorer-like API. I\n> just think its important to define the use case and be aware of the\n> consequences and downsides.\n>\n> /jonas\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180829/95a5e31d/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-08-29T18:45:56",
                "message_text_only": "You have created a straw man.\n\nAnd light clients working against the P2P network (anonymous nodes) implies they are not fully validating, so you are contradicting yourself.\n\ne\n\n> On Aug 29, 2018, at 11:27, Jonas Schnelli <dev at jonasschnelli.ch> wrote:\n> \n> \n>> The API implementation is not what is centralizing, nor is full indexation non-scalable. The centralization is in not running the API from a node under your own control. This is of course implied by the comment, \u201cwithout the need for syncing\u201d. In other words it is the deployment cost of the node that is centralizing.\n> \n> IMO an API that serves non verifiable data is supporting centralised validation. The \u201eAPI\" which supports one of the most important properties in Bitcoin \u2013 the ability to self-validate \u2013 is the data available via the p2p network.\n> \n>> \n>> Yet if people relied only on bitcoind and never centralized services there would be *no* block explorers (and no secure light wallets), because it does not provide remote query and does not fully index.\n>> \n>> Block explorers and light wallets are pretty useful, so presumably some API must provide these features (ideally with reduced deployment cost). That will either be centralized or decentralized services. As such it seems wise to encourage the latter, as opposed to questioning whether there is any valid block explorer use case.\n> \n> Bitcoin-Core has all required features to partially \u201eindex\u201c data (called the wallet) and provides them via the RPC API. If you don\u2019t need to serve thousands of wallets (which smells after centralised validation), selective indexing (wallets) are the right choice. Also, if you have a proper light client architecture, you can use Bitcoin Core in pruned mode (<10GB of data) to serve an endless amount of wallets (client/server mode, I guess that is what you are referring to with \"light clients\").\n> \n> I fail to see the use-cases where a fully index blockchain makes sense (the only one I can come up with is instant backup recovery where the transaction history needs to be preserved rather then recovering the UTXOs only).\n> \n> Also, the p2p protocol has built in light client support with BIP37 (bloom filters) and soon BIP158 will be available on the network which does allow privacy-preserving \"light clients\" in a way where no trusted layer is required (client <-> p2p network rather then client <-> API provider <-> p2p network).\n> \n> I don\u2019t want to advocate against a full-index blockexplorer-like API. I just think its important to define the use case and be aware of the consequences and downsides.\n> \n> /jonas"
            }
        ],
        "thread_summary": {
            "title": "Building a Bitcoin API and query system.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Matias Alejo Garcia",
                "Eric Voskuil",
                "Aymeric Vitte",
                "Guido Dassori",
                "Blockchain Group",
                "Jonas Schnelli",
                "Joseph Gleason \u2448"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 33709
        }
    },
    {
        "title": "[bitcoin-dev] Testnet3 Reest",
        "thread_messages": [
            {
                "author": "shiva sitamraju",
                "date": "2018-08-30T07:28:42",
                "message_text_only": "Hi,\n\nTestnet is now 1411795 blocks and a full sync is taking atleast 48 hours.\n\nIs a testnet reset scheduled in the next release or any reason not to do a\nreset ?\n\nFast onboarding/lower disk overheads would be  very much appreicated for\ntesting purposes\n\nRegards\n\n\n-- \nShiva S\nCEO @ Blockonomics <https://www.blockonomics.co>\nDecentralized and Permissionless Payments\nJoin us on Telegram <https://t.me/BlockonomicsCo>\nView our Welcome Guide\n<https://www.blockonomics.co/docs/blockonomics-brochure.pdf>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/29db618f/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-08-30T20:02:39",
                "message_text_only": "On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev wrote:\n> Hi,\n> \n> Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.\n> \n> Is a testnet reset scheduled in the next release or any reason not to do a\n> reset ?\n> \n> Fast onboarding/lower disk overheads would be  very much appreicated for\n> testing purposes\n\nActually I'd advocate the opposite: I'd want testnet to be a *larger*\nblockchain than mainnet to find size-related issues first.\n\nNote that for testing regtest is often a better alternative, and you can setup\nprivate regtest blockchains fairly easily and with good control over exactly\nwhen and how blocks are created.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/1e4ab762/attachment.sig>"
            },
            {
                "author": "Jimmy Song",
                "date": "2018-08-30T20:36:16",
                "message_text_only": "Stupid question time:\n\nWhy don't we have multiple testnets?\n\nOn Thu, Aug 30, 2018 at 3:31 PM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev\n> wrote:\n> > Hi,\n> >\n> > Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.\n> >\n> > Is a testnet reset scheduled in the next release or any reason not to do\n> a\n> > reset ?\n> >\n> > Fast onboarding/lower disk overheads would be  very much appreicated for\n> > testing purposes\n>\n> Actually I'd advocate the opposite: I'd want testnet to be a *larger*\n> blockchain than mainnet to find size-related issues first.\n>\n> Note that for testing regtest is often a better alternative, and you can\n> setup\n> private regtest blockchains fairly easily and with good control over\n> exactly\n> when and how blocks are created.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/33139c8d/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-08-30T20:44:25",
                "message_text_only": "A public testnet is still useful so in articles people could make references to these transactions.\n\nMaybe we could have 2 testnets at the same time, with one having a smaller block size?\n\n> On 31 Aug 2018, at 4:02 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Signed PGP part\n> On Thu, Aug 30, 2018 at 12:58:42PM +0530, shiva sitamraju via bitcoin-dev wrote:\n>> Hi,\n>> \n>> Testnet is now 1411795 blocks and a full sync is taking atleast 48 hours.\n>> \n>> Is a testnet reset scheduled in the next release or any reason not to do a\n>> reset ?\n>> \n>> Fast onboarding/lower disk overheads would be  very much appreicated for\n>> testing purposes\n> \n> Actually I'd advocate the opposite: I'd want testnet to be a *larger*\n> blockchain than mainnet to find size-related issues first.\n> \n> Note that for testing regtest is often a better alternative, and you can setup\n> private regtest blockchains fairly easily and with good control over exactly\n> when and how blocks are created.\n> \n> -- \n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> \n>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-08-31T00:06:06",
                "message_text_only": "On Thu, Aug 30, 2018 at 11:21 PM Johnson Lau via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> A public testnet is still useful so in articles people could make references to these transactions.\n> Maybe we could have 2 testnets at the same time, with one having a smaller block size?\n\nI would much rather have a signed blocks testnet, with a predictable\nstructured reorg pattern* (and a config flag so you can make your node\nignore all blocks that are going to get reorged out in a reorg of nth\nor larger).  There are many applications where the mined testnet just\ndoesn't give you anything useful... it's too stable when you want it\nto be a bit unstable and too wildly unstable when you want a bit of\nstability-- e.g. there are very few test cases where a 20,000 block\nreorg does anything useful for you; yet they happen on testnet.\n\nWe looked at doing this previously in Bitcoin core and jtimon had some\npatches,  but the existing approach increased the size of the\nblockindex objects in memory  while not in signed testnet mode.   This\ncould probably have been fixed by turning one of the fields like the\nmerkel root into a union of it's normal value and a pointer a\nlook-aside block index that is used only in signed block testnet mode.\n\nObviously such a mode wouldn't be a replacement for an ordinary\ntestnet, but it would be a useful middle ground between regtest (that\nnever sees anything remotely surprising and can't easily be used for\ncollaborative testing) and full on testnet where your attempts to test\nagainst ordinary noise require you cope your entirely universe being\nremoved from existence and replaced by something almost but not quite\nentirely different at the whim of some cthulhuian blind idiot god."
            }
        ],
        "thread_summary": {
            "title": "Testnet3 Reest",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "Peter Todd",
                "shiva sitamraju",
                "Gregory Maxwell",
                "Jimmy Song"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 5810
        }
    },
    {
        "title": "[bitcoin-dev] bustapay BIP :: a practical sender/receiver coinjoin protocol",
        "thread_messages": [
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-08-30T20:24:58",
                "message_text_only": "I've just finished writing an implementing of this, and extremely happy with how it turned out. So I'd like to go and try go down the path of more formally describing it and getting some comments and ultimately encourage its wide-spread use.\n\n==Abstract==\n\nThe way bitcoin transactions are overwhelming used is known to leak more\ninformation than desirable. This has lead to fungibility concerns in bitcoin\nand a raise of unreasonably effective blockchain analysis.\n\nBustapay proposes a simple, practical way to bust these assumptions to immediate\nbenefit of the sender and recievers. Furthermore it does so in such a way that\nhelps recievers avoid utxo bloat, a constant problem for bitcoin merchants.\n\n==Copyright==\n\nThis BIP is in the public domain.\n\n==Motivation==\n\nOne of the most powerful heuristic's employed by those whose goal is to undermine\nbitcoin's fungiblity has been to assume all inputs of a transaction are signed by\na single party. In the few cases this assumption does not hold, it is generally\nreadibly recognizable (e.g. traditional coinjoins have a very obvious structure,\nor multisig outputs are most frequently validated onchain).\n\nBustapay requires no changes to bitcoin and creates bitcoin transactions that are\nindistinguishable from normal ones.\n\nIt is worth noting that this specification has been intentionally kept as simple\nas possible to encourage adoption. There are almost an endless amount of extensions\npossible but the harder the implementation of clients/server the less likely it\nwill ever be done. Should bustapay enjoy widespread adoption, a \"v2\" specification\nwill be created with desired extensions.\n\n==Specification==\n\nA bustapay payment is made from a sender to a receiver.\n\nStep 1. Sender creates a bitcoin transaction paying the receiver\n\nThis transaction must be fully valid, signed and all inputs must use segwit. This transaction is known as the \"template transaction\". This transaction must not be propagated on the bitcoin network.\n\nStep 2. Sender gives the \"template transaction\" to the receiver\n\nThis would generally be done as an HTTP POST. The exact URL to submit it to could be specified with a bip21 encoded address. Such as bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bustapay=https://bp.bustabit.com/submit and the HTTP body should be the raw transaction hex encoded as text.\n\nStep 3. Receiver processes the transaction and returns a partially signed coinjoin\n\nThe receiver validates the transaction is valid, pays himself and is eligible for propation. The receiver then adds one of his own inputs (known as the \"contributed input\") and increase the output that pays himself by the contributed input amount. Doing so will invalidate the \"template transaction\"'s original input signatures, so the sender needs to return this \"partial transaction\" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.\n\nStep 4. Receiver validates, re-signs, and propagates on the bitcoin network\n\nThe receiver is responsible in making sure the \"partial transaction\" returned by the sender was changed correctly (it should assume the connection has been MITM'd and act accordingly), resign its original inputs and propagates this transaction over the bitcoin network. The client must be aware that the server can reorder inputs and outputs.\n\nStep 5. Receiver observes the finalized transaction on the bitcoin network\n\nOnce the receiver has seen the finalized transactions on the network (and has enough confirmations) it can process it like a normal payment for the sent amount (as opposed to the amount that it looks like on the network). If the receiver does not see the finalized transaction after a timeout will propagate the original \"template transaction\" to ensure the payment happens and function a strong anti-DoS mechanism.\n\n=== Implementation Notes ===\nFor anyone wanting to implement bustapay payments, here are some notes for receivers:\n\n* A transaction can easily be checked if it's suitable for the mempool with testmempoolaccept in bitcoin core 0.17\n* Tracking transactions by txid is precarious. To keep your sanity make sure all inputs are segwit. But remember segwit does not prevent txid malleability unless you validate the transaction. So really make sure you're using testmempoolaccept at the very least\n* Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address\n* You will need to keep a mapping of which utxos people have showed you and which you revealed. So if you see them again, you can reveal the same one of your own\n* Check if the transaction was already sorted according to BIP69, if so ensure the result stays that way. Otherwise probably just shuffle the inputs/outpus\n\nNotes for sending applications:\n\n* The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.\n* The sender should be aware the original \"template transaction\" may be propagated at any time, and in fact can intentionally be\n  done so for the purpose of RBF as it should have a slightly higher fee rate.\n\n== Credits ==\nThe idea is obviously based upon Dr. Maxwell's seminal CoinJoin proposal, and reduced scope inspired by a simplification of the \"pay 2 endpoint\" (now offline) blog post by blockstream.\n\n-Ryan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180830/29c49730/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bustapay BIP :: a practical sender/receiver coinjoin protocol",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "rhavar at protonmail.com"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5599
        }
    },
    {
        "title": "[bitcoin-dev] SIGHASH2 for version 1 witness programme",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2018-08-30T20:38:06",
                "message_text_only": "After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.\n\nFormatted BIP and sample code at:\nhttps://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\nhttps://github.com/jl2012/bitcoin/commits/sighash2\n\nThe major new features compared with BIP143:\n\n1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.\n2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).\n3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.\n4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.\n5. SIGHASH2_LASTOUTPUT: signs only the highest index output.\n6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>\n7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.\n8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.\n\nAny suggestions are welcomed. But I have the following questions:\n\n1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I\u2019m not missing something here.\n2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.\n3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won\u2019t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult\n4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.\n\n\n> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.\n> \n> A formatted version and example code could be found here:\n> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\n> https://github.com/jl2012/bitcoin/commits/sighash2\n> \n> \n> ========\n> \n> BIP: YYY\n>  Layer: Consensus (soft fork)\n>  Title: Signature checking operations in version 1 witness program\n>  Author: Johnson Lau <jl2012 at xbt.hk>\n>  Comments-Summary: No comments yet.\n>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY\n>  Status: Draft\n>  Type: Standards Track\n>  Created: 2017-07-19\n>  License: BSD-3-Clause\n> \n> \n> *Abstract\n> \n> This BIP defines signature checking operations in version 1 witness program.\n> \n> *Motivation\n> \n> Use of compact signatures to save space.\n> \n> More SIGHASH options, more flexibility\n> \n> *Specification\n> \n> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.\n> \n> **Public Key Format\n> \n> The pubic key MUST be exactly 33 bytes.\n> \n> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)\n> \n> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.\n> \n> **Signature Format\n> \n> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.\n> \n> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).\n> \n> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.\n> \n> If the signature size is zero, it is accepted as the \"valid failing\" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)\n> \n> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.\n> \n> **New hashtype definitions\n> \n> hashtype and the SignatureHash function are re-defined:\n> \n>  Double SHA256 of the serialization of:\n>     1. nVersion (4-byte little endian)\n>     2. hashPrevouts (32-byte hash)\n>     3. hashSequence (32-byte hash)\n>     4. outpoint (32-byte hash + 4-byte little endian)\n>     5. scriptCode (serialized as scripts inside CTxOuts)\n>     6. nAmount (8-byte little endian)\n>     7. nSequence (4-byte little endian)\n>     8. hashOutputs (32-byte hash)\n>     9. nLocktime (4-byte little endian)\n>    10. nInputIndex (4-byte little endian)\n>    11. nFees (8-byte little endian)\n>    12. hashtype (4-byte little endian)\n>    13. sigversion (4-byte little endian for the fixed value 0x01000000)\n> \n> The bit 0 to 3 of hashtype denotes a value between 0 and 15:\n> \n> \t\u2022 If the value is 1, the signature is invalid.\n> \t\u2022 If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n> \t\u2022 If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.\n> \t\u2022 If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n> \t\u2022 If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.\n> \t\u2022 If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.\n> \t\u2022 If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.\n> \n> The bit 4 and 5 of hashtype denotes a value between 0 and 3:\n> \n> \t\u2022 If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.\n> \t\u2022 If the value is 1, the signature is invalid.\n> \t\u2022 If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.\n> \t\u2022 If the value is 3, hashOutputs is 32-byte of 0x0000......0000.\n> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.\n> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.\n> \n> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.\n> \n> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.\n> \n> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.\n> \n> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.\n> \n> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.\n> \n> *Rationale\n> \n> **Signature Format\n> \n> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.\n> \n> **New hashtype definitions\n> \n> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)\n> \n> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?\n> \n> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.\n> \n> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.\n> \n> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.\n> \n> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.\n> \n> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:\n> \n> \t\u2022 NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.\n> \t\u2022 NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.\n> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.\n> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).\n> \n> *Examples\n> \n> Equivalent SIGHASH2 value for other SIGHASH schemes:\n> Legacy/BIP143 ALL: 0 (commit to everything)\n> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)\n> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both \"wildcard\" signatures that allow anyone to spend any related UTXO)\n> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)\n> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)\n> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)\n> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)\n> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)\n> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)\n> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)\n> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)\n> \n> Notes:\n> \n> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.\n> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.\n> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true \"wildcard signature\" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.\n> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.\n> \n> *Backward compatibility\n> \n> This is a soft-fork.\n> \n> *Deployment\n> \n> Exact details TBD.\n> \n> *Reference Implementation\n> \n> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)\n> \n> *Copyright\n> \n> This document is licensed as BSD 3-clause.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180831/134e94ee/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-08-30T20:51:15",
                "message_text_only": "Thanks for the update Johnson, just wanted to give a really quick NACK\non the SIGHASH_NOINPUT variant: the whole idea of BIP 118 is to have\nfloating transactions that can be bound to predecessors, and still\nenforce some application logic. In eltoo's case this is the fact that\nthe state number needs to be smaller than the state number of the\ntransaction that is being rewritten. The state number that we bind to is\npart of the `scriptPubKey`, so we can't commit to the `scriptPubKey` in\nthe signature since we don't know which output (and thus it's\nscriptPubKey`) is at the time we sign.\n\nIf we are committing to `scriptPubKey` this whole way of enforcing order\nin updates is no longer possible, and the only thing we actually get\nfrom this change is a (very weak) malleability fix. The same argument\ngoes for `scriptCode`.\n\nCheers,\nChristian\n\nJohnson Lau <jl2012 at xbt.hk> writes:\n> After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.\n>\n> Formatted BIP and sample code at:\n> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\n> https://github.com/jl2012/bitcoin/commits/sighash2\n>\n> The major new features compared with BIP143:\n>\n> 1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.\n> 2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).\n> 3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.\n> 4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.\n> 5. SIGHASH2_LASTOUTPUT: signs only the highest index output.\n> 6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>\n> 7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.\n> 8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.\n>\n> Any suggestions are welcomed. But I have the following questions:\n>\n> 1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I\u2019m not missing something here.\n> 2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.\n> 3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won\u2019t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult\n> 4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.\n>\n>\n>> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.\n>> \n>> A formatted version and example code could be found here:\n>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\n>> https://github.com/jl2012/bitcoin/commits/sighash2\n>> \n>> \n>> ========\n>> \n>> BIP: YYY\n>>  Layer: Consensus (soft fork)\n>>  Title: Signature checking operations in version 1 witness program\n>>  Author: Johnson Lau <jl2012 at xbt.hk>\n>>  Comments-Summary: No comments yet.\n>>  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY\n>>  Status: Draft\n>>  Type: Standards Track\n>>  Created: 2017-07-19\n>>  License: BSD-3-Clause\n>> \n>> \n>> *Abstract\n>> \n>> This BIP defines signature checking operations in version 1 witness program.\n>> \n>> *Motivation\n>> \n>> Use of compact signatures to save space.\n>> \n>> More SIGHASH options, more flexibility\n>> \n>> *Specification\n>> \n>> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.\n>> \n>> **Public Key Format\n>> \n>> The pubic key MUST be exactly 33 bytes.\n>> \n>> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)\n>> \n>> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.\n>> \n>> **Signature Format\n>> \n>> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.\n>> \n>> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).\n>> \n>> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.\n>> \n>> If the signature size is zero, it is accepted as the \"valid failing\" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)\n>> \n>> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.\n>> \n>> **New hashtype definitions\n>> \n>> hashtype and the SignatureHash function are re-defined:\n>> \n>>  Double SHA256 of the serialization of:\n>>     1. nVersion (4-byte little endian)\n>>     2. hashPrevouts (32-byte hash)\n>>     3. hashSequence (32-byte hash)\n>>     4. outpoint (32-byte hash + 4-byte little endian)\n>>     5. scriptCode (serialized as scripts inside CTxOuts)\n>>     6. nAmount (8-byte little endian)\n>>     7. nSequence (4-byte little endian)\n>>     8. hashOutputs (32-byte hash)\n>>     9. nLocktime (4-byte little endian)\n>>    10. nInputIndex (4-byte little endian)\n>>    11. nFees (8-byte little endian)\n>>    12. hashtype (4-byte little endian)\n>>    13. sigversion (4-byte little endian for the fixed value 0x01000000)\n>> \n>> The bit 0 to 3 of hashtype denotes a value between 0 and 15:\n>> \n>> \t\u2022 If the value is 1, the signature is invalid.\n>> \t\u2022 If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n>> \t\u2022 If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.\n>> \t\u2022 If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n>> \t\u2022 If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.\n>> \t\u2022 If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.\n>> \t\u2022 If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.\n>> \n>> The bit 4 and 5 of hashtype denotes a value between 0 and 3:\n>> \n>> \t\u2022 If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.\n>> \t\u2022 If the value is 1, the signature is invalid.\n>> \t\u2022 If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.\n>> \t\u2022 If the value is 3, hashOutputs is 32-byte of 0x0000......0000.\n>> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.\n>> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.\n>> \n>> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.\n>> \n>> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.\n>> \n>> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.\n>> \n>> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.\n>> \n>> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.\n>> \n>> *Rationale\n>> \n>> **Signature Format\n>> \n>> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.\n>> \n>> **New hashtype definitions\n>> \n>> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)\n>> \n>> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?\n>> \n>> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.\n>> \n>> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.\n>> \n>> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.\n>> \n>> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.\n>> \n>> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:\n>> \n>> \t\u2022 NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.\n>> \t\u2022 NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.\n>> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.\n>> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).\n>> \n>> *Examples\n>> \n>> Equivalent SIGHASH2 value for other SIGHASH schemes:\n>> Legacy/BIP143 ALL: 0 (commit to everything)\n>> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)\n>> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both \"wildcard\" signatures that allow anyone to spend any related UTXO)\n>> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)\n>> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)\n>> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)\n>> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)\n>> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)\n>> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)\n>> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)\n>> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)\n>> \n>> Notes:\n>> \n>> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.\n>> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.\n>> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true \"wildcard signature\" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.\n>> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.\n>> \n>> *Backward compatibility\n>> \n>> This is a soft-fork.\n>> \n>> *Deployment\n>> \n>> Exact details TBD.\n>> \n>> *Reference Implementation\n>> \n>> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)\n>> \n>> *Copyright\n>> \n>> This document is licensed as BSD 3-clause.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Johnson Lau",
                "date": "2018-08-31T07:42:07",
                "message_text_only": "Great, I\u2019ll revise it.\n\nFollow-up questions:\n\n1. Is there any useful case which one would like to use NOINPUT with scriptCode and/or scriptPubKey committed? (Note that with taproot/MAST, scriptCode and scriptPubKey are not interchangeable. scriptPubKey commits to all branches, and scriptCode is just one script branch). If yes, we could make this configurable.\n\n2. Which of the following approaches is better?\nA) sign scriptPubKey in every cases except NOINPUT\nB) sign the type (P2SH-segwit vs. Native-segwit) of scriptPubKey in every cases, including NOINPUT\nC) all of the above\nD) none of the above\n\nOption B is very easy to implement as SignatureHash() could distinguish the type by the size of scriptSig in TxTo. Option A is more complicated as GenericTransactionSignatureChecker needs to know the scriptPubKey.\n\nIf the only reason for doing this is to allow hardware wallet to distinguish the segwit type, option B is probably enough. This is also compatible with eltoo.\n\nOption A is useful when a hardware wallet reuses the same public key in different scripts, but it couldn\u2019t be applied to NOINPUT\n\n3. Is the proposed DUALOUTPUT somehow useful for eltoo? Eltoo use NOINPUT|SINGLE to allow fee pumping, since it is an one-input-one-output tx. This is not possible with the existing LN as the tx is one-input-two-output. If we had DUALOUTPUT which signs the matched and last output, fee-pumping would be possible in the existing LN.\n\n\n\n\n> On 31 Aug 2018, at 4:51 AM, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Thanks for the update Johnson, just wanted to give a really quick NACK\n> on the SIGHASH_NOINPUT variant: the whole idea of BIP 118 is to have\n> floating transactions that can be bound to predecessors, and still\n> enforce some application logic. In eltoo's case this is the fact that\n> the state number needs to be smaller than the state number of the\n> transaction that is being rewritten. The state number that we bind to is\n> part of the `scriptPubKey`, so we can't commit to the `scriptPubKey` in\n> the signature since we don't know which output (and thus it's\n> scriptPubKey`) is at the time we sign.\n> \n> If we are committing to `scriptPubKey` this whole way of enforcing order\n> in updates is no longer possible, and the only thing we actually get\n> from this change is a (very weak) malleability fix. The same argument\n> goes for `scriptCode`.\n> \n> Cheers,\n> Christian\n> \n> Johnson Lau <jl2012 at xbt.hk> writes:\n>> After gathering some feedbacks I substantially revised the proposal. This version focus on improving security, and reduces the number of optional features.\n>> \n>> Formatted BIP and sample code at:\n>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\n>> https://github.com/jl2012/bitcoin/commits/sighash2\n>> \n>> The major new features compared with BIP143:\n>> \n>> 1. If signing all inputs, also sign all input value. BIP143 signature only covers the value of the same input. In some cases this may not be adequate for hardware wallet to determine the right amount of fees. Signing all input values will secure any possible case.\n>> 2. Sign both scriptCode and previous scriptPubKey. In the original bitcoin design, previous scriptPubKey is signed as the scriptCode. However, this is not the case with P2SH and segwit. Explicitly committing to the scriptPubKey allows hardware wallet to confirm what it is actually signing (e.g. P2SH-segwit vs. Native-segwit).\n>> 3. SIGHASH2_NOINPUT: basically same as BIP118, but the signature commits to both scriptCode and scriptPubKey. This prevents signature replay if the same public key is used in different scripts.\n>> 4. SIGHASH2_MATCHOUTPUT (previously SIGHASH_SINGLE) disallows out-of-range case.\n>> 5. SIGHASH2_LASTOUTPUT: signs only the highest index output.\n>> 6. SIGHASH2_DUALOUTPUT: signs the matched output and the highest index output. Described by gmaxwell at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016188.html>\n>> 7. Signing the amount of fees (optional, yes by default). In case of not signing all inputs or outputs, users may still want to commit to a specific fee amount.\n>> 8. Signing the witness size (optional, yes by default). While segwit fixed txid malleability, it is not a fix of script malleability. It may cause some trouble if an attacker could bloat the witness and reduce the fee priority of a transaction. Although the witness size is not malleable for most simple scripts, this is not guaranteed for more complex ones. Such kind of size malleability could be avoided if signatures commit to the size of witness.\n>> \n>> Any suggestions are welcomed. But I have the following questions:\n>> \n>> 1. Should NOINPUT commit to scriptCode and/or scriptPubKey? I think it should, because that helps avoid signature replay in some cases, and also lets hardware wallets know what they are signing. I am asking this because BIP118 proposes the opposite. I want to make sure I\u2019m not missing something here.\n>> 2. Do we want to add LASTOUTPUT and DUALOUTPUT? Suggested by gmaxwell, an example use case is kickstarter, where individual supporters send money to the last output for a kickstarter project, and send change to the matched output. However, I doubt if this would be actually used this way, because the kickstarter organiser could always take the money before the target is met, by making up the difference with his own input. This is an inherent problem for any anonymous kickstarter scheme. If these new SIGHASHs are not useful in other applications, I am not sure if we should add them.\n>> 3. Instead of these restrictive MATCH/LAST/DUALOUTPUT, do we want a fully flexible way to sign a subset of outputs? The indexes of signed outputs are put at the end of the signature, and the signature won\u2019t commit to these index values. Therefore, a third party could collect all transactions of this kind and merge them into one transaction. To limit the sighash cost, number of signed outputs might not be more than 2 or 3. Some potential problems: a) code complexity; b) 1-byte or 2-byte index: 1-byte will limit the number of outputs to 256. 2-byte will use more space even for smaller txs; c) highly variable signature size makes witness size estimation more difficult\n>> 4. Should we sign the exact witness size (as proposed), or an upper size limit? Signing an upper limit will take up more space, as the limit has to be explicitly shown in the witness. The overhead could be avoided by showing the limit only if the actual witness size is not equal to the committed limit. However, I tend to keep it simple and sign the exact value. If in a multi-sig setup some signers are unable to accurately estimate the witness size, they should leave this responsibility to the last signer who should know the exact size.\n>> \n>> \n>>> On 1 Jun 2018, at 2:35 AM, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> \n>>> Since 2016, I have made a number of proposals for the next generation of script. Since then, there has been a lot of exciting development on this topic. The most notable ones are Taproot and Graftroot proposed by Maxwell. It seems the most logical way is to implement MAST and other new script functions inside Taproot and/or Graftroot. Therefore, I substantially simplified my earlier proposal on SIGHASH2. It is a superset of the existing SIGHASH and the BIP118 SIGHASH_NOINPUT, with further flexibility but not being too complicated. It also fixes some minor problems that we found in the late stage of BIP143 review. For example, the theoretical (but not statistical) possibility of having same SignatureHash() results for a legacy and a witness transaction. This is fixed by padding a constant at the end of the message so collision would not be possible.\n>>> \n>>> A formatted version and example code could be found here:\n>>> https://github.com/jl2012/bips/blob/sighash2/bip-sighash2.mediawiki\n>>> https://github.com/jl2012/bitcoin/commits/sighash2\n>>> \n>>> \n>>> ========\n>>> \n>>> BIP: YYY\n>>> Layer: Consensus (soft fork)\n>>> Title: Signature checking operations in version 1 witness program\n>>> Author: Johnson Lau <jl2012 at xbt.hk>\n>>> Comments-Summary: No comments yet.\n>>> Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0YYY\n>>> Status: Draft\n>>> Type: Standards Track\n>>> Created: 2017-07-19\n>>> License: BSD-3-Clause\n>>> \n>>> \n>>> *Abstract\n>>> \n>>> This BIP defines signature checking operations in version 1 witness program.\n>>> \n>>> *Motivation\n>>> \n>>> Use of compact signatures to save space.\n>>> \n>>> More SIGHASH options, more flexibility\n>>> \n>>> *Specification\n>>> \n>>> The following specification is applicable to OP_CHECKSIG and OP_CHECKSIGVERIFY in version 1 witness program.\n>>> \n>>> **Public Key Format\n>>> \n>>> The pubic key MUST be exactly 33 bytes.\n>>> \n>>> If the first byte of the public key is a 0x02 or 0x03, it MUST be a compressed public key. The signature is a Schnorr signature (To be defined separately)\n>>> \n>>> If the first byte of the public key is neither 0x02 nor 0x03, the signature is assumed valid. This is for future upgrade.\n>>> \n>>> **Signature Format\n>>> \n>>> The following rules apply only if the first byte of the public key is a 0x02 or 0x03.\n>>> \n>>> If the signature size is 64 to 66 byte, it MUST be a valid Schnorr signature or the script execution MUST fail (cf. BIP146 NULLFAIL). The first 32-byte is the R value in big-endian. The next 32-byte is the S value in big-endian. The remaining data, if any, denotes the hashtype in little-endian (0 to 0xffff).\n>>> \n>>> hashtype MUST be minimally encoded. Any trailing zero MUST be removed.\n>>> \n>>> If the signature size is zero, it is accepted as the \"valid failing\" signature for OP_CHECKSIG to return a FALSE value to the stack. (cf. BIP66)\n>>> \n>>> The script execution MUST fail with a signature size not 0, 64, 65, or 66-byte.\n>>> \n>>> **New hashtype definitions\n>>> \n>>> hashtype and the SignatureHash function are re-defined:\n>>> \n>>> Double SHA256 of the serialization of:\n>>>    1. nVersion (4-byte little endian)\n>>>    2. hashPrevouts (32-byte hash)\n>>>    3. hashSequence (32-byte hash)\n>>>    4. outpoint (32-byte hash + 4-byte little endian)\n>>>    5. scriptCode (serialized as scripts inside CTxOuts)\n>>>    6. nAmount (8-byte little endian)\n>>>    7. nSequence (4-byte little endian)\n>>>    8. hashOutputs (32-byte hash)\n>>>    9. nLocktime (4-byte little endian)\n>>>   10. nInputIndex (4-byte little endian)\n>>>   11. nFees (8-byte little endian)\n>>>   12. hashtype (4-byte little endian)\n>>>   13. sigversion (4-byte little endian for the fixed value 0x01000000)\n>>> \n>>> The bit 0 to 3 of hashtype denotes a value between 0 and 15:\n>>> \n>>> \t\u2022 If the value is 1, the signature is invalid.\n>>> \t\u2022 If the value is 3 or below, hashPrevouts is the hash of all input, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n>>> \t\u2022 If the value is 7 or below, outpoint is the COutPoint of the current input. Otherwise, it is 36-byte of 0x0000......0000.\n>>> \t\u2022 If the value is 0, hashSequence is the hash of all sequence, same as defined in BIP143. Otherwise, it is 32-byte of 0x0000......0000.\n>>> \t\u2022 If the value is even (including 0), nSequence is the nSequence of the current input. Otherwise, it is 0x00000000.\n>>> \t\u2022 If the value is 6, 7, 10, 11, 14, or 15, nInputIndex is 0x00000000. Otherwise, it is the index of the current input.\n>>> \t\u2022 If the value is 11 or below, nAmount is the value of the current input (same as BIP143). Otherwise, it is 0x0000000000000000.\n>>> \n>>> The bit 4 and 5 of hashtype denotes a value between 0 and 3:\n>>> \n>>> \t\u2022 If the value is 0, hashOutputs is same as the SIGHASH_ALL case in BIP143 as a hash of all outputs.\n>>> \t\u2022 If the value is 1, the signature is invalid.\n>>> \t\u2022 If the value is 2, hashOutputs is same as the SIGHASH_SINGLE case in BIP143 as a hash of the matching output. If a matching output does not exist, hashOutputs is 32-byte of 0x0000......0000.\n>>> \t\u2022 If the value is 3, hashOutputs is 32-byte of 0x0000......0000.\n>>> If bit 6 is set (SIGHASH2_NOFEE), nFees is 0x0000000000000000. Otherwise, it is the fee paid by the transaction.\n>>> If bit 7 is set (SIGHASH2_NOLOCKTIME), nLockTime is 0x00000000. Otherwise, it is the transaction nLockTime.\n>>> \n>>> If bit 8 is set (SIGHASH2_NOVERSION), nVersion is 0x00000000. Otherwise, it is the transaction nVersion.\n>>> \n>>> If bit 9 is set (SIGHASH2_NOSCRIPTCODE), scriptCode is an empty script. Otherwise, it is same as described in BIP143.\n>>> \n>>> Bits 10 to 15 are reserved and ignored, but the signature still commits to their value as hashtype.\n>>> \n>>> hashtype of 0 is also known as SIGHASH2_ALL, which covers all the available options. In this case the singnature MUST be exactly 64-byte.\n>>> \n>>> hashtype of 0x3ff is also known as SIGHASH2_NONE, which covers nothing and is effectively forfeiting the right related to this public key to anyone.\n>>> \n>>> *Rationale\n>>> \n>>> **Signature Format\n>>> \n>>> The current DER format is a complete waste of block space. The new format saves ~8 bytes per signature.\n>>> \n>>> **New hashtype definitions\n>>> \n>>> The default and most commonly used case is SIGHASH2_ALL. Making it zero size to save space. As a result, the bit flags are defined in a negative way (e.g. NOLOCKTIME)\n>>> \n>>> Why decouple INPUT and SEQUENCE? Maybe you want NOINPUT but still have a relative lock-time?\n>>> \n>>> Why some combinations are missing? To save some bits for useless flags. If you sign all inputs, you must know its index and value. If you sign only this input, you must know its value, but probably don't know its index in the input vector.\n>>> \n>>> Why only allow signing all SEQUENCE if all INPUT are signed? It doesn't make much sense if you care about their sequence without even knowing what they are.\n>>> \n>>> Why signing INPUTINDEX? Legacy and BIP143 SINGLE|ANYONECANPAY behaves differently for input index. Better make it explicit and optional.\n>>> \n>>> Why signing FEE? Sometimes you don't sign all inputs / outputs but still want to make sure the fees amount is correct.\n>>> \n>>> Putting NOVERSION and NOSCRIPTCODE in the second byte makes most signatures below 66 bytes:\n>>> \n>>> \t\u2022 NOVERSION: Currently the only use of transaction version is to enforce BIP68. It could be safely assumed that version 2 is used. The only case one would like to use NOVERSION is to make the signature compatible with some unknown new features that use a different transaction version.\n>>> \t\u2022 NOSCRIPTCODE: It would be very rare if one could make a signature without knowing what the script is (at least they know the public key). The only scenario that a NOSCRIPTCODE is really needed is the public key being reused in different scripts, and the user wants to use a single signature to cover all these scripts.\n>>> Reserved bits: These bits are ignored but should normally be unset. Users MUST NOT set these bits until they are defined by a future proposal, or they might lose money.\n>>> Why sigversion? Make sure the message digest won't collide with SIGHASH schemes in the past (legacy and BIP143) and future (which will use a different sigversion).\n>>> \n>>> *Examples\n>>> \n>>> Equivalent SIGHASH2 value for other SIGHASH schemes:\n>>> Legacy/BIP143 ALL: 0 (commit to everything)\n>>> Legacy/BIP143 SINGLE with matching output: 0x62 (all input, one sequence, one output, no fee)\n>>> Legacy SINGLE without matching output: 0x3ff (Not exactly. Both signatures commit to nothing, but the legacy one is valid only without a matched output. Practically, they are both \"wildcard\" signatures that allow anyone to spend any related UTXO)\n>>> Legacy/BIP143 NONE: 0x72 (all input, one sequence, no output, no fee)\n>>> Legacy/BIP143 ANYONECANPAY|ALL: 0x46 (one input without index, one sequence, all output, no fee)\n>>> Legacy ANYONECANPAY|SINGLE with matching output: 0x64 (one input with index, one sequence, one output, no fee)\n>>> Legacy/BIP143 ANYONECANPAY|NONE: 0x76 (one input without index, one sequence, no output, no fee)\n>>> BIP143 SINGLE without matching output: 0x62 (all input, one sequence, no output, no fee)\n>>> BIP143 ANYONECANPAY|SINGLE with matching output: 0x66 (one input without index, one sequence, one output, no fee)\n>>> BIP143 ANYONECANPAY|SINGLE without matching output: 0x66 (one input without index, one sequence, no output, no fee)\n>>> BIP118 NOINPUT: 0x14b (no input but with value, no index, no sequence, no fee, no scriptcode)\n>>> \n>>> Notes:\n>>> \n>>> 1. In legacy and BIP143 SIGHASH, only ALL but not other types implicitly commits to the fee paid.\n>>> 2. Legacy SIGHASH always implicitly commits to the input value. BIP143 and BIP118 commits to that explicitly.\n>>> 3. Legacy and BIP143 SIGHASH behaves differently in the case of SINGLE without matching output. In legacy SIGHASH it is a true \"wildcard signature\" that allows anyone to spend any related UTXO. In BIP143 such signature applies only to a specific UTXO.\n>>> 4. BIP143 ANYONECANPAY never commits to the input index. Legacy ANYONECANPAY|SINGLE implicitly commits to the input index.\n>>> \n>>> *Backward compatibility\n>>> \n>>> This is a soft-fork.\n>>> \n>>> *Deployment\n>>> \n>>> Exact details TBD.\n>>> \n>>> *Reference Implementation\n>>> \n>>> https://github.com/jl2012/bitcoin/commits/sighash2 (To be updated)\n>>> \n>>> *Copyright\n>>> \n>>> This document is licensed as BSD 3-clause.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "SIGHASH2 for version 1 witness programme",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "Christian Decker"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 48476
        }
    }
]