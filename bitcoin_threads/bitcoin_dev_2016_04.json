[
    {
        "title": "[bitcoin-dev] AsicBoost",
        "thread_messages": [
            {
                "author": "Timo Hanke",
                "date": "2016-04-01T04:41:40",
                "message_text_only": "Hi.\n\nI'd like to announce a white paper that describes a very new and\nsignificant algorithmic improvement to the Bitcoin mining process which has\nnever been discussed in public before. The white paper can be found here:\n\nhttp://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n\nRegards,\n\nTimo\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160331/00d287f0/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-04-01T09:00:50",
                "message_text_only": "On Thu, Mar 31, 2016 at 09:41:40PM -0700, Timo Hanke via bitcoin-dev wrote:\n> Hi.\n> \n> I'd like to announce a white paper that describes a very new and\n> significant algorithmic improvement to the Bitcoin mining process which has\n> never been discussed in public before. The white paper can be found here:\n> \n> http://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n\nWhat steps are you going to take to make sure that this improvement is\navailable to all ASIC designers/mfgs on a equal opportunity basis?\n\nThe fact that you've chosen to patent this improvement could be a\ncentralization concern depending on the licensing model used. For example, one\ncould imagine a licensing model that gave one manufacture exclusive rights.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160401/62b71047/attachment.sig>"
            },
            {
                "author": "Mustafa Al-Bassam",
                "date": "2016-04-04T23:01:43",
                "message_text_only": "Alternatively scenario: it will cause a sudden increase of Bitcoin mines\nin countries where the algorithm is not patented, possibly causing a\ngeographical decentralization of miners from countries that already have\na lot of miners like China (if it is patented in China).\n\nOn 01/04/16 10:00, Peter Todd via bitcoin-dev wrote:\n> On Thu, Mar 31, 2016 at 09:41:40PM -0700, Timo Hanke via bitcoin-dev wrote:\n>> Hi.\n>>\n>> I'd like to announce a white paper that describes a very new and\n>> significant algorithmic improvement to the Bitcoin mining process which has\n>> never been discussed in public before. The white paper can be found here:\n>>\n>> http://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n> What steps are you going to take to make sure that this improvement is\n> available to all ASIC designers/mfgs on a equal opportunity basis?\n>\n> The fact that you've chosen to patent this improvement could be a\n> centralization concern depending on the licensing model used. For example, one\n> could imagine a licensing model that gave one manufacture exclusive rights.\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160405/41cbbc99/attachment.html>"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-04-06T11:57:31",
                "message_text_only": "To my understanding it is purely software thing. It cannot be detected from\noutside if miner uses this improvement or not. So patenting it is worthless.\n\nslush\n\nOn Tue, Apr 5, 2016 at 1:01 AM, Mustafa Al-Bassam via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Alternatively scenario: it will cause a sudden increase of Bitcoin mines\n> in countries where the algorithm is not patented, possibly causing a\n> geographical decentralization of miners from countries that already have a\n> lot of miners like China (if it is patented in China).\n>\n> On 01/04/16 10:00, Peter Todd via bitcoin-dev wrote:\n>\n> On Thu, Mar 31, 2016 at 09:41:40PM -0700, Timo Hanke via bitcoin-dev wrote:\n>\n> Hi.\n>\n> I'd like to announce a white paper that describes a very new and\n> significant algorithmic improvement to the Bitcoin mining process which has\n> never been discussed in public before. The white paper can be found here:\n> http://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n>\n> What steps are you going to take to make sure that this improvement is\n> available to all ASIC designers/mfgs on a equal opportunity basis?\n>\n> The fact that you've chosen to patent this improvement could be a\n> centralization concern depending on the licensing model used. For example, one\n> could imagine a licensing model that gave one manufacture exclusive rights.\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160406/06ef680b/attachment.html>"
            },
            {
                "author": "Mustafa Al-Bassam",
                "date": "2016-04-06T12:09:33",
                "message_text_only": "It will prevent companies from legally selling mining rigs with the\nimprovement, which stems access to the improvement in patented\ncountries. Or miners can export rigs with the improvement from companies\nthat sell it in non-patented countries.\n\nIt is not purely a software thing - it is intended to be used by\nmodifying hardware. From the paper: \"The performance gain is achieved\nthrough a high-\u00adlevel optimization of the Bitcoin mining algorithm which\nallows for drastic reduction in gate count on the mining chip. AsicBoost\nis applicable to all types of mining hardware and chip designs.\"\n\nUltimately though, I think you're right in that Bitcoin's mining and\ndecentralized design combined with an international economy makes\npatenting mining algorithms effectively pointless.\n\nMustafa\n\nOn 06/04/16 12:57, Marek Palatinus wrote:\n> To my understanding it is purely software thing. It cannot be detected\n> from outside if miner uses this improvement or not. So patenting it is\n> worthless.\n>\n> slush\n>\n> On Tue, Apr 5, 2016 at 1:01 AM, Mustafa Al-Bassam via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Alternatively scenario: it will cause a sudden increase of Bitcoin\n>     mines in countries where the algorithm is not patented, possibly\n>     causing a geographical decentralization of miners from countries\n>     that already have a lot of miners like China (if it is patented in\n>     China).\n>\n>     On 01/04/16 10:00, Peter Todd via bitcoin-dev wrote:\n>>     On Thu, Mar 31, 2016 at 09:41:40PM -0700, Timo Hanke via bitcoin-dev wrote:\n>>>     Hi.\n>>>\n>>>     I'd like to announce a white paper that describes a very new and\n>>>     significant algorithmic improvement to the Bitcoin mining process which has\n>>>     never been discussed in public before. The white paper can be found here:\n>>>\n>>>     http://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n>>>     <http://www.math.rwth-aachen.de/%7ETimo.Hanke/AsicBoostWhitepaperrev5.pdf>\n>>     What steps are you going to take to make sure that this improvement is\n>>     available to all ASIC designers/mfgs on a equal opportunity basis?\n>>\n>>     The fact that you've chosen to patent this improvement could be a\n>>     centralization concern depending on the licensing model used. For example, one\n>>     could imagine a licensing model that gave one manufacture exclusive rights.\n>>\n>>\n>>\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160406/479b0423/attachment.html>"
            },
            {
                "author": "Timo Hanke",
                "date": "2016-04-08T20:58:57",
                "message_text_only": "Slush,\n\nYou can actually detect the use of this improvement by looking at the I/O\nof the chip, the I/O of an on-board micro-controller or even at the system\nI/O because all the communication including the mining pool protocol is\ndifferent.\n\nTimo\n\nOn Wed, Apr 6, 2016 at 1:57 AM, Marek Palatinus <marek at palatinus.cz> wrote:\n\n> To my understanding it is purely software thing. It cannot be detected\n> from outside if miner uses this improvement or not. So patenting it is\n> worthless.\n>\n> slush\n>\n> On Tue, Apr 5, 2016 at 1:01 AM, Mustafa Al-Bassam via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Alternatively scenario: it will cause a sudden increase of Bitcoin mines\n>> in countries where the algorithm is not patented, possibly causing a\n>> geographical decentralization of miners from countries that already have a\n>> lot of miners like China (if it is patented in China).\n>>\n>> On 01/04/16 10:00, Peter Todd via bitcoin-dev wrote:\n>>\n>> On Thu, Mar 31, 2016 at 09:41:40PM -0700, Timo Hanke via bitcoin-dev wrote:\n>>\n>> Hi.\n>>\n>> I'd like to announce a white paper that describes a very new and\n>> significant algorithmic improvement to the Bitcoin mining process which has\n>> never been discussed in public before. The white paper can be found here:\n>> http://www.math.rwth-aachen.de/~Timo.Hanke/AsicBoostWhitepaperrev5.pdf\n>>\n>> What steps are you going to take to make sure that this improvement is\n>> available to all ASIC designers/mfgs on a equal opportunity basis?\n>>\n>> The fact that you've chosen to patent this improvement could be a\n>> centralization concern depending on the licensing model used. For example, one\n>> could imagine a licensing model that gave one manufacture exclusive rights.\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160408/f3c8386d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "AsicBoost",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mustafa Al-Bassam",
                "Timo Hanke",
                "Marek Palatinus",
                "Peter Todd"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 10436
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: Merkelized Abstract Syntax Tree",
        "thread_messages": [
            {
                "author": "jl2012 at xbt.hk",
                "date": "2016-04-01T17:19:53",
                "message_text_only": "BIP draft: https://github.com/jl2012/bips/blob/mast/bip-mast.mediawiki\nReference implementation:\nhttps://github.com/jl2012/bitcoin/commit/f335cab76eb95d4f7754a718df201216a49\n75d8c\n\nThis BIP defines a new witness program type that uses a Merkle tree to\nencode mutually exclusive branches in a script. This enables complicated\nredemption conditions that are currently not possible, improves privacy by\nhiding unexecuted scripts, and allows inclusion of non-consensus enforced\ndata with very low or no additional cost.\n\nThe reference implementation is a small and simple patch on top of BIP141\n(segwit), however, I have no intention to push this before segwit is\nenforced. Instead, I hope the MAST will come with many new op codes,\nparticularly Schnorr signature."
            }
        ],
        "thread_summary": {
            "title": "BIP draft: Merkelized Abstract Syntax Tree",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "jl2012 at xbt.hk"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 760
        }
    },
    {
        "title": "[bitcoin-dev] p2p authentication and encryption BIPs",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2016-04-01T21:09:47",
                "message_text_only": "> I have just PRed a draft version of two BIPs I recently wrote.\n> https://github.com/bitcoin/bips/pull/362\n\nHi.\nI just updated the PR above with another overhaul of the BIP.\nIt's still under heavy review/work, nevertheless \u2013 at this point \u2013 any\nfeedback is highly welcome.\n\nChanges since last update:\n-> Removed AES256-GCM as cipher suite\n-> Focusing on Chacha20-Poly1305 (implementation size ~300L)\n-> Two symmetric cipher keys must be calculated by HMAC_SHA512 from the\necdh secret\n-> A session-ID (both directions) must be calculated (HMAC_SHA256) for\nlinking an identity authentication (ecdsa sig of the session-ID) with\nthe encryption\n-> Re-Keying ('=hash(old_key)') can be announced by the responding peer\n(after x minutes and/or after x GB, local peer policy but not shorter\nthen 10mins).\n-> AEAD tag is now the last element in the new message format\n\nIt is very likely that the encrypted message format performs slightly\nbetter than the current message format (removing the SHA256 checksum).\n\n---\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160401/39552c3c/attachment.sig>"
            },
            {
                "author": "Lee Clagett",
                "date": "2016-04-09T19:40:38",
                "message_text_only": "On Fri, 1 Apr 2016 23:09:47 +0200\nJonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrote:\n> > I have just PRed a draft version of two BIPs I recently wrote.\n> > https://github.com/bitcoin/bips/pull/362  \n> \n> Hi.\n> I just updated the PR above with another overhaul of the BIP.\n> It's still under heavy review/work, nevertheless \u2013 at this point \u2013 any\n> feedback is highly welcome.\n> \n> Changes since last update:\n> -> Removed AES256-GCM as cipher suite\n> -> Focusing on Chacha20-Poly1305 (implementation size ~300L)\n> -> Two symmetric cipher keys must be calculated by HMAC_SHA512 from\n> the ecdh secret\n> -> A session-ID (both directions) must be calculated (HMAC_SHA256)\n> for linking an identity authentication (ecdsa sig of the session-ID)\n> with the encryption\n> -> Re-Keying ('=hash(old_key)') can be announced by the responding\n> peer (after x minutes and/or after x GB, local peer policy but not\n> shorter then 10mins).\n> -> AEAD tag is now the last element in the new message format  \n> \n> It is very likely that the encrypted message format performs slightly\n> better than the current message format (removing the SHA256 checksum).\n> \n> ---\n> </jonas>\n> \n\n\nThe quotes below are from the BIPs and not the email chain ...\n\n> Rejecting the <code>auth</code> request will not reveal the\n> responding peers identity that could lead to fingerprinting the node,\n> however this BIP does not cover protection against fingerprinting the\n> requesting node from the perspective of the responding node.\n\nIn many use cases the requesting node will want to make a connection to\na peer with a specific identity. After encryption initialization, the\nrequesting node could generate an ECDH secret from the long-term public\nkey of the expected peer and its own session private-key to encrypt (no\nMAC) the signature with the same symmetric cipher agreed upon\npreviously. The requesting node will not reveal its identity if the\nconnection has been MitM'ed, while still being the first to provide\nauthentication. And since this would be \"inside\" the session-key\ncrypto, it still has forward-secrecy if the responding-peers longterm\nprivate-key is later compromised.\n\n*Key Revocation*\nThis is probably too complicated, but an additional public key would\nallow for cold-storage key revocation. Spreading the knowledge of such\nan event is always painful, but it could be stored in the blockchain. I\nthink this is likely too complicated, but having these long-term keys\nconstantly in memory/disk is unfortunate.\n\n\n> Responding peers must ignore the requesting peer after a\n> unsuccessfully authentication initialization to avoid resource\n> attacks (banning would lead to fingerprinting of peers that support\n> authentication). \n\nOnce the responding peer has read the `auth` message, a TCP ACK can be\nsent. From the requesting peer perspective, a TCP ACK of the `auth`\nrequest indicates that it was read by the process or some\nintermediary buffer (TOE, proxy, etc) has successfully forwarded it to\nthe next step. If the requesting peer waits RTT * some constant from\nthe ACK and gets no response, then either: a failed `auth` occurred,\n`auth` is not supported, or the machine was suddenly overloaded. The\nrequesting peer can then send another message; a response message\nindicates the responding peer does not support `auth`, and another no\nresponse wait period indicates an overloaded peer or an `auth` enabled\npeer. Initiating a new connection (no banning has occurred) indicates\neither `auth` is enabled or a load-balancer re-directed the new\nconnection to another machine under less load. I think the latter case\nis going to be rare, so you should be able to identify with high\nprobability nodes that support `auth` and what message types require\n`auth`. And if this is process repeated multiple times, it will increase\nthe chances of a correct fingerprint.\n\nShould encryption enabled peers who do _not_ support `auth` ignore all\nsubsequent messages after an `auth` attempt too? Fingerprinting on\n`auth` required message types would still be possible. I do not see a\nreliable way to prevent this from occurring.\n\n\n> To request encrypted communication, the requesting peer generates an\n> EC ephemeral-session-keypair and sends an <code>encinit</code>\n> message to the responding peer and waits for a <code>encack</code>\n> message. The responding node must do the same\n> <code>encinit</code>/<code>encack</code> interaction for the opposite\n> communication direction.\n\nWhy are there two key exchanges? A single shared-secret could be used\nto generate keys for each direction. And it would reinforce the single\nsymmetric cipher rule.\n\n\n> Possible symmetric key ciphers types\n> {|class=\"wikitable\"\n> ! Number !! symmetric key ciphers type !! Comments\n> |-\n> | 0 || Chacha20-Poly1305 [3] || encrypted message length must be used\n> as AAD. |}\n>\n\nChacha20-Poly1305 defined in an IETF draft [0] and RFC 7539 both\ninclude the ciphertext length in the authentication tag generation. Is\nthis a unique authentication construction? Or one of the previously\nmentioned designs?\n\n*Symmetric Cipher Negotiation*\nShould the symmetric cipher choices be removed? I am mainly asking for\nthe intended use-case. If the intent is to replace a weakened cipher\nthen leave the cipher negotiation. If the intent is to give\nimplementations multiple options, then I would remove this negotiation.\n\n\n> <code>K_1</code> must be used to only encrypt the payload size of the\n> encrypted message to avoid leaking information by revealing the\n> message size. \n> \n> <code>K_2</code> must be used in conjunction with poly1305 to build\n> an AEAD.\n\nChacha20 is a stream cipher, so only a single encryption key is needed.\nThe first 32 bytes of the keystream would be used for the Poly1305 key,\nthe next 4 bytes would be used to encrypt the length field, and the\nremaining keystream would be used to encrypt the payload. Poly1305\nwould then generate a tag over the length and payload. The receiver\nwould generate the same keystream to decrypt the length which\nidentifies the length of the message and the MAC offset, then\nauthenticate the length and payload, then decypt with the remaining\nkeystream.\n\nIs it safer to define two keys to prevent implementations from screwing\nthis up? You have to split the decryption and authentication, so the\nbasic modes of libsodium cannot be used for instance. If a custom tag\ngeneration scheme is being used, then the basic modes are already\nunusable ...\n\n*Failed Authentication*\nWhat happens on a failed MAC attempt? Connection closure is the\neasiest way to handle the situation.\n\n\n> After a successful <code>encinit</code>/<code>encack</code>\n> interaction from both sides, the messages format must use the\n> \"encrypted messages structure\". Non-encrypted messages from the\n> requesting peer must lead to a connection termination (can be\n> detected by the 4 byte network magic in the unencrypted message\n> structure).\n\nThe magic bytes are at the same offset and size as the encrypted length\nfield in the encrypted messages structure. So the magic bytes are not a\nreliable way to identify unencrypted messages, although the probability\nof collision is low.\n\n\n> {|class=\"wikitable\"\n> ! Field Size !! Description !! Data type !! Comments\n> |-\n> | 4 || length || uint32_t || Length of ciphertext payload in number\n> of bytes\n> |-\n> | ? || ciphertext payload || ? || One or many ciphertext command &\n> message data\n> |-\n> | 8 || MAC tag || ? || MAC-tag truncated to 8 bytes\n> |}\n\nWhy have a fixed MAC length? I think the MAC length should be inferred\nfrom the cipher + authentication mode. And the Poly1305 tag is 16 bytes.\n\n*Unauthenticated Buffering*\nImplementations are unlikely to (i.e. should not) process the payload\nuntil authentication succeeds. Since the length field is 4 bytes, this\nmeans an implementation may have to buffer up to 4 GiB of data _per\nconnection_ before it can authenticate the length field. If the outter\nlength field were reduced to 2 or 3 bytes, the unauthenticated\nbuffering requirements drop to 64 KiB and 16 MiB respectively. Inner\nmessages already have their own length, so they can span multiple\nencrypted blocks without other changes. This will increase the\nbandwidth requirements when the size of a single message exceeds 64 KiB\nor 16 MiB, since it will require multiple authentication tags for that\nmessage. I think an additional 16 bytes per 16 MiB seems like a good\ntradeoff.\n\n\n> A responding peer can inform the requesting peer over a re-keying\n> with a <code>encack</code> message containing 33byte of zeros to\n> indicate that all encrypted message following after this\n> <code>encack</code> message will be encrypted with ''the next\n> symmetric cipher key''.\n>\n> The new symmetric cipher key will be calculated by\n> <code>SHA256(SHA256(old_symetric_cipher_key))</code>.\n>\n> Re-Keying interval is a peer policy with a minimum timespan of 600\n> seconds.\n\nShould the int64_t message count be reset to 0 on a re-key? Or should\nthe value reset to zero after 2^63-1? Hopefully the peer re-keys before\nthat rollover, or keystream reusage will occur. Unlikely that many\nmessages are sent on a single connection though. And presumably this\nonly re-keys the senders side? Bi-directional re-keying would be racy.\n\n\n\nLee\n\n[0]https://tools.ietf.org/html/draft-ietf-tls-chacha20-poly1305-04"
            }
        ],
        "thread_summary": {
            "title": "p2p authentication and encryption BIPs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Lee Clagett",
                "Jonas Schnelli"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 10621
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.12.1 release candidate 1 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-04-11T07:37:06",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBinaries for bitcoin Core version 0.12.1rc1 are available from:\n\n    https://bitcoin.org/bin/bitcoin-core-0.12.1/test.rc2/\n\nSource code can be found on github under the signed tag\n\n    https://github.com/bitcoin/bitcoin/tree/v0.12.1rc1\n\nThis is a release candidate for a new minor version release, including the\nBIP9, BIP68 and BIP112 softfork, various bugfixes and updated translations.\n\nPreliminary release notes for the release can be found here:\n\n    https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md\n\nRelease candidates are test versions for releases. When no critical problems\nare found, this release candidate will be tagged as 0.12.1.\n\nPlease report bugs using the issue tracker at github:\n\n    https://github.com/bitcoin/bitcoin/issues\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXC1QSAAoJEHSBCwEjRsmmtk4H/1C74eLLVwzOhrrWNx34ANcz\nuiyIlkXnMmX+iHWaSC8XdcBOEc4/+YOgDK0KU+FRG6bNDengPKqf8mPDEvyXU/H+\n/ed2W9Q0DQ/jxyeKOOVlMWhKCZWQRisxhadB0LAiny2QLsBojTrJtziGIOYXp4Qt\nxI3GstbUr42da8kL8NoKxQt6na5FrGiuRAQeucwcoHi1QQodd7R7vA2b84N1ECrr\nKWbCfw6a9qHDmk2Vy+9CqGtESHuVW04B+79ui+Dgsh6frG9UH5G7WP4ziUcwm625\nCEEbi/cIrpzEOSo4S5ukFhYK6I3o67uxvV8Nc3ocI1UmC4d2BUvAMalBGMgjENg=\n=oPfq\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-04-11T09:12:13",
                "message_text_only": "That's rc2, not rc1 (thanks btcdrak for noticing).\nrc1 was DOA - see meeting minutes from Thursday.\nLink for the tag:\n\nhttps://github.com/bitcoin/bitcoin/tree/v0.12.1rc2\n\nThe other links and downloads are correct.\n\nWladimir\n\nOn Mon, Apr 11, 2016 at 09:37:06AM +0200, Wladimir J. van der Laan wrote:\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA512\n> \n> Binaries for bitcoin Core version 0.12.1rc1 are available from:\n> \n>     https://bitcoin.org/bin/bitcoin-core-0.12.1/test.rc2/\n> \n> Source code can be found on github under the signed tag\n> \n>     https://github.com/bitcoin/bitcoin/tree/v0.12.1rc1\n> \n> This is a release candidate for a new minor version release, including the\n> BIP9, BIP68 and BIP112 softfork, various bugfixes and updated translations.\n> \n> Preliminary release notes for the release can be found here:\n> \n>     https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md\n> \n> Release candidates are test versions for releases. When no critical problems\n> are found, this release candidate will be tagged as 0.12.1.\n> \n> Please report bugs using the issue tracker at github:\n> \n>     https://github.com/bitcoin/bitcoin/issues\n> -----BEGIN PGP SIGNATURE-----\n> Version: GnuPG v1\n> \n> iQEcBAEBCgAGBQJXC1QSAAoJEHSBCwEjRsmmtk4H/1C74eLLVwzOhrrWNx34ANcz\n> uiyIlkXnMmX+iHWaSC8XdcBOEc4/+YOgDK0KU+FRG6bNDengPKqf8mPDEvyXU/H+\n> /ed2W9Q0DQ/jxyeKOOVlMWhKCZWQRisxhadB0LAiny2QLsBojTrJtziGIOYXp4Qt\n> xI3GstbUr42da8kL8NoKxQt6na5FrGiuRAQeucwcoHi1QQodd7R7vA2b84N1ECrr\n> KWbCfw6a9qHDmk2Vy+9CqGtESHuVW04B+79ui+Dgsh6frG9UH5G7WP4ziUcwm625\n> CEEbi/cIrpzEOSo4S5ukFhYK6I3o67uxvV8Nc3ocI1UmC4d2BUvAMalBGMgjENg=\n> =oPfq\n> -----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.12.1 release candidate 1 available",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2933
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.12.1 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-04-15T09:56:48",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.12.1 is now available from:\n\n  <https://bitcoin.org/bin/bitcoin-core-0.12.1/>\n\nOr through bittorrent:\n\n  magnet:?xt=urn:btih:25c4df2a822e840e972a50a31095632d87efadab&dn=bitcoin-core-0.12.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F \n\nThis is a new minor version release, including the BIP9, BIP68 and BIP112\nsoftfork, various bugfixes and updated translations.\n\nPlease report bugs using the issue tracker at github:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to\nhttps://bitcoincore.org/en/list/announcements/join/.\n\nUpgrading and downgrading\n=========================\n\nHow to Upgrade\n- --------------\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\nbitcoind/bitcoin-qt (on Linux).\n\nDowngrade warning\n- -----------------\n\n### Downgrade to a version < 0.12.0\n\nBecause release 0.12.0 and later will obfuscate the chainstate on every\nfresh sync or reindex, the chainstate is not backwards-compatible with\npre-0.12 versions of Bitcoin Core or other software.\n\nIf you want to downgrade after you have done a reindex with 0.12.0 or later,\nyou will need to reindex when you first start Bitcoin Core version 0.11 or\nearlier.\n\nNotable changes\n===============\n\nFirst version bits BIP9 softfork deployment\n- -------------------------------------------\n\nThis release includes a soft fork deployment to enforce [BIP68][],\n[BIP112][] and [BIP113][] using the [BIP9][] deployment mechanism.\n\nThe deployment sets the block version number to 0x20000001 between\nmidnight 1st May 2016 and midnight 1st May 2017 to signal readiness for \ndeployment. The version number consists of 0x20000000 to indicate version\nbits together with setting bit 0 to indicate support for this combined\ndeployment, shown as \"csv\" in the `getblockchaininfo` RPC call.\n\nFor more information about the soft forking change, please see\n<https://github.com/bitcoin/bitcoin/pull/7648>\n\nThis specific backport pull-request can be viewed at\n<https://github.com/bitcoin/bitcoin/pull/7543>\n\n[BIP9]: https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki\n[BIP68]: https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\n[BIP112]: https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki\n[BIP113]: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki\n\nBIP68 soft fork to enforce sequence locks for relative locktime\n- ---------------------------------------------------------------\n\n[BIP68][] introduces relative lock-time consensus-enforced semantics of\nthe sequence number field to enable a signed transaction input to remain\ninvalid for a defined period of time after confirmation of its corresponding\noutpoint.\n\nFor more information about the implementation, see\n<https://github.com/bitcoin/bitcoin/pull/7184>\n\nBIP112 soft fork to enforce OP_CHECKSEQUENCEVERIFY\n- --------------------------------------------------\n\n[BIP112][] redefines the existing OP_NOP3 as OP_CHECKSEQUENCEVERIFY (CSV)\nfor a new opcode in the Bitcoin scripting system that in combination with\n[BIP68][] allows execution pathways of a script to be restricted based\non the age of the output being spent.\n\nFor more information about the implementation, see\n<https://github.com/bitcoin/bitcoin/pull/7524>\n\nBIP113 locktime enforcement soft fork\n- -------------------------------------\n\nBitcoin Core 0.11.2 previously introduced mempool-only locktime\nenforcement using GetMedianTimePast(). This release seeks to\nconsensus enforce the rule.\n\nBitcoin transactions currently may specify a locktime indicating when\nthey may be added to a valid block.  Current consensus rules require\nthat blocks have a block header time greater than the locktime specified\nin any transaction in that block.\n\nMiners get to choose what time they use for their header time, with the\nconsensus rule being that no node will accept a block whose time is more\nthan two hours in the future.  This creates a incentive for miners to\nset their header times to future values in order to include locktimed\ntransactions which weren't supposed to be included for up to two more\nhours.\n\nThe consensus rules also specify that valid blocks may have a header\ntime greater than that of the median of the 11 previous blocks.  This\nGetMedianTimePast() time has a key feature we generally associate with\ntime: it can't go backwards.\n\n[BIP113][] specifies a soft fork enforced in this release that\nweakens this perverse incentive for individual miners to use a future\ntime by requiring that valid blocks have a computed GetMedianTimePast()\ngreater than the locktime specified in any transaction in that block.\n\nMempool inclusion rules currently require transactions to be valid for\nimmediate inclusion in a block in order to be accepted into the mempool.\nThis release begins applying the BIP113 rule to received transactions,\nso transaction whose time is greater than the GetMedianTimePast() will\nno longer be accepted into the mempool.\n\n**Implication for miners:** you will begin rejecting transactions that\nwould not be valid under BIP113, which will prevent you from producing\ninvalid blocks when BIP113 is enforced on the network. Any\ntransactions which are valid under the current rules but not yet valid\nunder the BIP113 rules will either be mined by other miners or delayed\nuntil they are valid under BIP113. Note, however, that time-based\nlocktime transactions are more or less unseen on the network currently.\n\n**Implication for users:** GetMedianTimePast() always trails behind the\ncurrent time, so a transaction locktime set to the present time will be\nrejected by nodes running this release until the median time moves\nforward. To compensate, subtract one hour (3,600 seconds) from your\nlocktimes to allow those transactions to be included in mempools at\napproximately the expected time.\n\nFor more information about the implementation, see\n<https://github.com/bitcoin/bitcoin/pull/6566>\n\nMiscellaneous\n- -------------\n\nThe p2p alert system is off by default. To turn on, use `-alert` with\nstartup configuration.\n\n0.12.1 Change log\n=================\n\nDetailed release notes follow. This overview includes changes that affect\nbehavior, not code moves, refactors and string updates. For convenience in locating\nthe code changes and accompanying discussion, both the pull request and\ngit merge commit are mentioned.\n\n### RPC and other APIs\n- - #7739 `7ffc2bd` Add abandoned status to listtransactions (jonasschnelli)\n\n### Block and transaction handling\n- - #7543 `834aaef` Backport BIP9, BIP68 and BIP112 with softfork (btcdrak)\n\n### P2P protocol and network code\n- - #7804 `90f1d24` Track block download times per individual block (sipa)\n- - #7832 `4c3a00d` Reduce block timeout to 10 minutes (laanwj)\n\n### Validation\n- - #7821 `4226aac` init: allow shutdown during 'Activating best chain...' (laanwj)\n- - #7835 `46898e7` Version 2 transactions remain non-standard until CSV activates (sdaftuar)\n\n### Build system\n- - #7487 `00d57b4` Workaround Travis-side CI issues (luke-jr)\n- - #7606 `a10da9a` No need to set -L and --location for curl (MarcoFalke)\n- - #7614 `ca8f160` Add curl to packages (now needed for depends) (luke-jr)\n- - #7776 `a784675` Remove unnecessary executables from gitian release (laanwj)\n\n### Wallet\n- - #7715 `19866c1` Fix calculation of balances and available coins. (morcos)\n\n### Miscellaneous\n- - #7617 `f04f4fd` Fix markdown syntax and line terminate LogPrint (MarcoFalke)\n- - #7747 `4d035bc` added depends cross compile info (accraze)\n- - #7741 `a0cea89` Mark p2p alert system as deprecated (btcdrak)\n- - #7780 `c5f94f6` Disable bad-chain alert (btcdrak)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - accraze\n- - Alex Morcos\n- - BtcDrak\n- - Jonas Schnelli\n- - Luke Dashjr\n- - MarcoFalke\n- - Mark Friedenbach\n- - NicolasDorier\n- - Pieter Wuille\n- - Suhas Daftuar\n- - Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXELrMAAoJEHSBCwEjRsmm75EH/0iyqFxXuJDbfzMmBbMTkXD2\n/CXEeyMvs62F2ZeODE0SSqo9sXo4foiT9WI5Dq7BwAiF6jh/XE4QwBvc91BbPyGZ\n1nOGEab+oe37xEOkn8MyGbHfCutsUldyKltVQjA3y685MxlSgTjl/nX6Pbpbxped\nvZRog3KHRrpWAMrHdi6p/xgqX0ajxE6K1P16JMOx4W/gE9QgOPyy7+l/4WT6SyBj\nk/pOLqJc+yQIOa9szS4pjLUqaSOirhsjXfro9FYjHqiTWQwAdvuK4xXgo1GrGIW1\nPWs419uLmGl4bhg9jdY6v+PyPz4iUilRzoixVi8op1Rt9/AoNN1ViJ/LT15Hagw=\n=h4Wp\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.12.1 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8922
        }
    },
    {
        "title": "[bitcoin-dev] Simple Bitcoin Payment Channel Protocol v0.1 draft (request for comments)",
        "thread_messages": [
            {
                "author": "Rune Kj\u00e6r Svendsen",
                "date": "2016-04-17T14:03:47",
                "message_text_only": "Dear list\n\nI've spent the past couple of months developing a simple protocol for\nworking with payment channels. I've written up a specification of how\nit operates, in an attempt to standardize the operations of opening,\npaying and closing.\n\nThis specification was derived from a mostly-working implementation\nwhich will be open sourced in a short while (after a clean-up). It's\nwritten in Haskell.\n\nI'm sharing the specification now because I think it has value in\nitself to have everything documented, especially since I've chosen to\nwrite the implementation in Haskell, and for people to point out any\nerrors or basically anything I haven't thought of.\n\nLink:\n\nhttps://raw.githubusercontent.com/runeksvendsen/simple-bitcoin-payment-channel-protocol/master/simple-bitcoin-payment-channel-protocol-v0.1.txt\n\n\n\n\nRegards\nRune"
            }
        ],
        "thread_summary": {
            "title": "Simple Bitcoin Payment Channel Protocol v0.1 draft (request for comments)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rune Kj\u00e6r Svendsen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 823
        }
    },
    {
        "title": "[bitcoin-dev] BIP CPRKV: Check private key verify",
        "thread_messages": [
            {
                "author": "jl2012 at xbt.hk",
                "date": "2016-04-18T19:03:07",
                "message_text_only": "I just realize that if we have OP_CAT, OP_CHECKPRIVATEKEYVERIFY (aka OP_CHECKPRIVPUBPAIR) is not needed (and is probably better for privacy)\n\n \n\nBob has the prikey-x for pubkey-x. Alice and Bob will agree to a random secret nonce, k. They calculate r, in the same way as signing a transaction.\n\n \n\nThe script is:\n\n \n\nSIZE <r-length + 1> ADD <0x30> SWAP CAT <0x02|r-length|r> CAT SWAP CAT <pubkey-x> CECHKSIGVERIFY <Bob pubkey hash> CHECKSIG\n\n \n\nTo redeem, Bob has to provide:\n\n \n\n<Bob sig> <0x02|s-length|s|sighashtype>\n\n \n\nWith k, s and sighash, Alice (and only Alice) can recover the prikey-x with the well-known k-reuse exploit\n\n( https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm )\n\n \n\nThe script will be much cleaner if we remove the DER encoding in the next generation of CHECKSIG\n\n \n\nThe benefit is prikey-x remains a secret among Alice and Bob. If they don\u2019t mind exposing the prikey-x, they could use r = x coordinate of pubkey-x, which means k = prikey-x (https://bitcointalk.org/index.php?topic=291092.0) This would reduce the witness size a little bit as a DUP may be used\n\n \n\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org [mailto:bitcoin-dev-bounces at lists.linuxfoundation.org] On Behalf Of Tier Nolan via bitcoin-dev\nSent: Monday, 29 February, 2016 19:53\nCc: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nSubject: Re: [bitcoin-dev] BIP CPRKV: Check private key verify\n\n \n\nOn Mon, Feb 29, 2016 at 10:58 AM, Mats Jerratsch <matsjj at gmail.com <mailto:matsjj at gmail.com> > wrote:\n\nThis is actually very useful for LN too, see relevant discussion here\n\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-November/011827.html\n\n \n\nIs there much demand for trying to code up a patch to the reference client?  I did a basic one, but it would need tests etc. added.\n\nI think that segregated witness is going to be using up any potential soft-fork slot for the time being anyway.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160419/232ba8d8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP CPRKV: Check private key verify",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "jl2012 at xbt.hk"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2122
        }
    },
    {
        "title": "[bitcoin-dev] Sidechains pre-BIP Discussion",
        "thread_messages": [
            {
                "author": "Paul Sztorc",
                "date": "2016-04-20T15:56:57",
                "message_text_only": "Dear list,\n\nThis message concerns pegged \"sidechains\", namely the Two Way Peg [1].\nSpecifically, it is to introduce a new OP Code (perhaps called\n\"OP_CheckVotesVerify\"). This OP code can be deployed by soft fork, and\nhas (as we all probably know) many benefits, including:\n\n1. (\"Optional hard forks\") Sidechains allow 'opt in' adoption of new\nfeatures. As a result, Bitcoin (the bearer asset, not the software) will\nnever need to worry about competing with an alternate system. This\nincludes competitors such as Ripple or Ethereum (supposedly\n\"innovative\"), as well as BitcoinXT and Bitcoin Classic (supposedly\n\"popular\").\n\n2. (\"Staging Upgrades\") SCs allow complex updates to Bitcoin to be\ntested, in a realistic environment (where actual BTC are at risk, and\nutilizing actual network mining resources). If these updates fail, they\ncan be revised; if they succeed, they can be incorporated into the\nmainchain.\n\n3. Directing \"blockchain resources\" to Bitcoin. This includes money,\ndeveloper talent, public attention, etc.\n\n4. Less time spent debating controversial features. Instead, we return\nto a culture of \"permissionless innovation\".\n\nAgain, as we all know, the concept has generally received high interest\nand favorable appraisal.\n\n--\n\nHowever, this feature has highly complex effects on the Bitcoin\necosystem, and so the details should command our full attention.\n\nFirst, the deployment of this OP Code involves new block validation\nrules (\"Drivechain\") which are described on my blog [2].\n\nIn addition to that post, I intend to release short presentations:\n\n1. On the overall design justification.\n2. On \"Enforcing Limits on Shared Resources\". This explores the\npotential for SCs to have a detrimental effect on users of vanilla BTC,\nand how this proposal confronts these problems.\n3. On the governance of SCs-- aka the degree of 'coupling',\ninter-relatedness, and/or hierarchy --- and how Drivechain's design acts\nto maximize the total value of the \"chain portfolio\".\n\nMy purpose, in emailing today, is to begin the conversation. The scope\nof the concept is simply too large, to draft a readable BIP without\nknowing what the actual points of interest are. Please express your\nreactions!\n\nThank you for reading,\nPaul\n\nP.S. In assessing the proposal, you may find a recent technical paper\n[3] by Sergio Demian Lerner to be of interest.\n\n--\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-March/004724.html\n[2] http://www.truthcoin.info/blog/drivechain/\n[3] http://www.rootstock.io/#resources   (\nhttps://uploads.strikinglycdn.com/files/27311e59-0832-49b5-ab0e-2b0a73899561/Drivechains_Sidechains_and_Hybrid_2-way_peg_Designs_R9.pdf\n)"
            }
        ],
        "thread_summary": {
            "title": "Sidechains pre-BIP Discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Paul Sztorc"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2658
        }
    },
    {
        "title": "[bitcoin-dev] Proposal to update BIP-32",
        "thread_messages": [
            {
                "author": "Jochen Hoenicke",
                "date": "2016-04-20T16:32:25",
                "message_text_only": "Hello Bitcoin Developers,\n\nI would like to make a proposal to update BIP-32 in a small way.\n\nTL;DR: BIP-32 is hard to use right (due to its requirement to skip\naddresses).  This proposal suggests a modification such that the\ndifficulty can be encapsulated in the library.\n\n#MOTIVATION:\n\nThe current BIP-32 specifies that if for some node in the hierarchy\nthe computed hash I_L is larger or equal to the prime or 0, then the\nnode is invalid and should be skipped in the BIP-32 tree.  This has\nseveral unfortunate consequences:\n\n- All callers of CKDpriv or CKDpub have to check for errors and handle\n  them appropriately.  This shifts the burden to the application\n  developer instead of being able to handle it in the BIP-32 library.\n\n- It is not clear what to do if an intermediate node is\n  missing. E.g. for the default wallet layout, if m/i_H/0 is missing\n  should m/i_H/1 be used for external chain and m/i_H/2 for internal\n  chain?  This would make the wallet handling much more difficult.\n\n- It gets even worse with standards like BIP-44.  If m/44' is missing\n  should we use m/45' instead?  If m/44'/0' is missing should we use\n  m/44'/1' instead, using the same addresses as for testnet?\n  One could also restart with a different seed in this case, but this\n  wouldn't work if one later wants to support another BIP-43 proposal\n  and still keep the same wallet.\n\nI think the first point alone is reason enough to change this.  I am\nnot aware of a BIP-32 application that handles errors like this\ncorrectly in all cases.  It is also very hard to test, since it is\ninfeasible to brute-force a BIP-32 key and a path where the node does\nnot exists.\n\nThis problem can be avoided by repeating the hashing with slightly\ndifferent input data until a valid private key is found.  This would\nbe in the same spirit as RFC-6979.  This way, the library will always\nreturn a valid node for all paths.  Of course, in the case where the\nnode is valid according to the current standard the behavior should be\nunchanged.\n\nI think the backward compatibility issues are minimal.  The chance\nthat this affects anyone is less than 10^-30.  Even if it happens, it\nwould only create some additional addresses (that are not seen if the\nuser downgrades).  The main reason for suggesting a change is that we\nwant a similar method for different curves where a collision is much\nmore likely.\n\n#QUESTIONS:\n\nWhat is the procedure to update the BIP?  Is it still possible to\nchange the existing BIP-32 even though it is marked as final?  Or\nshould I make a new BIP for this that obsoletes BIP-32?\n\nWhat algorithm is preferred? (bike-shedding)  My suggestion:\n\n---\n\nChange the last step of the private -> private derivation functions to:\n\n . In case parse(I_L) >= n or k_i = 0, the procedure is repeated\n   at step 2 with\n    I = HMAC-SHA512(Key = c_par, Data = 0x01 || I_R || ser32(i))\n\n---\n\nI think this suggestion is simple to implement (a bit harder to unit\ntest) and the string to hash with HMAC-SHA512 always has the same\nlength.  I use I_R, since I_L is obviously not very random if I_L >= n.\nThere is a minimal chance that it will lead to an infinite loop if I_R\nis the same in two consecutive iterations, but that has only a chance\nof 1 in 2^512 (if the algorithm is used for different curves that make\nI_L >= n more likely, the chance is still less than 1 in 2^256).  In\ntheory, this loop can be avoided by incrementing i in every iteration,\nbut this would make an implementation error in the \"hard to test\" path\nof the program more likely.\n\nThe other derivation functions should be updated in a similar matter.\nAlso the derivation of the root node from the seed should be updated\nin a similar matter to avoid invalid seeds.\n\nIf you followed until here, thanks for reading this long posting.\n\n  Jochen"
            },
            {
                "author": "Marek Palatinus",
                "date": "2016-04-21T12:08:26",
                "message_text_only": "Sipa, you are probably the most competent to answer this. Could you please\ntell us your opinion? For me, this is straightforward, backward compatible\nfix and I like it a lot. Not sure about the process of changing \"Final\" BIP\nthough.\n\nSlush\n\nOn Wed, Apr 20, 2016 at 6:32 PM, Jochen Hoenicke via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Bitcoin Developers,\n>\n> I would like to make a proposal to update BIP-32 in a small way.\n>\n> TL;DR: BIP-32 is hard to use right (due to its requirement to skip\n> addresses).  This proposal suggests a modification such that the\n> difficulty can be encapsulated in the library.\n>\n> #MOTIVATION:\n>\n> The current BIP-32 specifies that if for some node in the hierarchy\n> the computed hash I_L is larger or equal to the prime or 0, then the\n> node is invalid and should be skipped in the BIP-32 tree.  This has\n> several unfortunate consequences:\n>\n> - All callers of CKDpriv or CKDpub have to check for errors and handle\n>   them appropriately.  This shifts the burden to the application\n>   developer instead of being able to handle it in the BIP-32 library.\n>\n> - It is not clear what to do if an intermediate node is\n>   missing. E.g. for the default wallet layout, if m/i_H/0 is missing\n>   should m/i_H/1 be used for external chain and m/i_H/2 for internal\n>   chain?  This would make the wallet handling much more difficult.\n>\n> - It gets even worse with standards like BIP-44.  If m/44' is missing\n>   should we use m/45' instead?  If m/44'/0' is missing should we use\n>   m/44'/1' instead, using the same addresses as for testnet?\n>   One could also restart with a different seed in this case, but this\n>   wouldn't work if one later wants to support another BIP-43 proposal\n>   and still keep the same wallet.\n>\n> I think the first point alone is reason enough to change this.  I am\n> not aware of a BIP-32 application that handles errors like this\n> correctly in all cases.  It is also very hard to test, since it is\n> infeasible to brute-force a BIP-32 key and a path where the node does\n> not exists.\n>\n> This problem can be avoided by repeating the hashing with slightly\n> different input data until a valid private key is found.  This would\n> be in the same spirit as RFC-6979.  This way, the library will always\n> return a valid node for all paths.  Of course, in the case where the\n> node is valid according to the current standard the behavior should be\n> unchanged.\n>\n> I think the backward compatibility issues are minimal.  The chance\n> that this affects anyone is less than 10^-30.  Even if it happens, it\n> would only create some additional addresses (that are not seen if the\n> user downgrades).  The main reason for suggesting a change is that we\n> want a similar method for different curves where a collision is much\n> more likely.\n>\n> #QUESTIONS:\n>\n> What is the procedure to update the BIP?  Is it still possible to\n> change the existing BIP-32 even though it is marked as final?  Or\n> should I make a new BIP for this that obsoletes BIP-32?\n>\n> What algorithm is preferred? (bike-shedding)  My suggestion:\n>\n> ---\n>\n> Change the last step of the private -> private derivation functions to:\n>\n>  . In case parse(I_L) >= n or k_i = 0, the procedure is repeated\n>    at step 2 with\n>     I = HMAC-SHA512(Key = c_par, Data = 0x01 || I_R || ser32(i))\n>\n> ---\n>\n> I think this suggestion is simple to implement (a bit harder to unit\n> test) and the string to hash with HMAC-SHA512 always has the same\n> length.  I use I_R, since I_L is obviously not very random if I_L >= n.\n> There is a minimal chance that it will lead to an infinite loop if I_R\n> is the same in two consecutive iterations, but that has only a chance\n> of 1 in 2^512 (if the algorithm is used for different curves that make\n> I_L >= n more likely, the chance is still less than 1 in 2^256).  In\n> theory, this loop can be avoided by incrementing i in every iteration,\n> but this would make an implementation error in the \"hard to test\" path\n> of the program more likely.\n>\n> The other derivation functions should be updated in a similar matter.\n> Also the derivation of the root node from the seed should be updated\n> in a similar matter to avoid invalid seeds.\n>\n> If you followed until here, thanks for reading this long posting.\n>\n>   Jochen\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160421/1b0958b3/attachment.html>"
            },
            {
                "author": "Eric Lombrozo",
                "date": "2016-04-21T15:28:45",
                "message_text_only": "In practice the probability of this case triggering is on the order of 2^-128 or something astronomically tiny. I've been using BIP32 for a few years already as have many others...I don't think we've ever had to handle this case. Justifiably, many app developers feel like the additional complexity of properly handling this case is not worth the effort.\n\nHaving said that, if the handling of this case is simple to implement and easy to isolate in the program flow, I am in favor of doing something along the lines of what you propose.\n\n- Eric\n\nOn April 20, 2016 9:32:25 AM PDT, Jochen Hoenicke via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Hello Bitcoin Developers,\n>\n>I would like to make a proposal to update BIP-32 in a small way.\n>\n>TL;DR: BIP-32 is hard to use right (due to its requirement to skip\n>addresses).  This proposal suggests a modification such that the\n>difficulty can be encapsulated in the library.\n>\n>#MOTIVATION:\n>\n>The current BIP-32 specifies that if for some node in the hierarchy\n>the computed hash I_L is larger or equal to the prime or 0, then the\n>node is invalid and should be skipped in the BIP-32 tree.  This has\n>several unfortunate consequences:\n>\n>- All callers of CKDpriv or CKDpub have to check for errors and handle\n>  them appropriately.  This shifts the burden to the application\n>  developer instead of being able to handle it in the BIP-32 library.\n>\n>- It is not clear what to do if an intermediate node is\n>  missing. E.g. for the default wallet layout, if m/i_H/0 is missing\n>  should m/i_H/1 be used for external chain and m/i_H/2 for internal\n>  chain?  This would make the wallet handling much more difficult.\n>\n>- It gets even worse with standards like BIP-44.  If m/44' is missing\n>  should we use m/45' instead?  If m/44'/0' is missing should we use\n>  m/44'/1' instead, using the same addresses as for testnet?\n>  One could also restart with a different seed in this case, but this\n>  wouldn't work if one later wants to support another BIP-43 proposal\n>  and still keep the same wallet.\n>\n>I think the first point alone is reason enough to change this.  I am\n>not aware of a BIP-32 application that handles errors like this\n>correctly in all cases.  It is also very hard to test, since it is\n>infeasible to brute-force a BIP-32 key and a path where the node does\n>not exists.\n>\n>This problem can be avoided by repeating the hashing with slightly\n>different input data until a valid private key is found.  This would\n>be in the same spirit as RFC-6979.  This way, the library will always\n>return a valid node for all paths.  Of course, in the case where the\n>node is valid according to the current standard the behavior should be\n>unchanged.\n>\n>I think the backward compatibility issues are minimal.  The chance\n>that this affects anyone is less than 10^-30.  Even if it happens, it\n>would only create some additional addresses (that are not seen if the\n>user downgrades).  The main reason for suggesting a change is that we\n>want a similar method for different curves where a collision is much\n>more likely.\n>\n>#QUESTIONS:\n>\n>What is the procedure to update the BIP?  Is it still possible to\n>change the existing BIP-32 even though it is marked as final?  Or\n>should I make a new BIP for this that obsoletes BIP-32?\n>\n>What algorithm is preferred? (bike-shedding)  My suggestion:\n>\n>---\n>\n>Change the last step of the private -> private derivation functions to:\n>\n> . In case parse(I_L) >= n or k_i = 0, the procedure is repeated\n>   at step 2 with\n>    I = HMAC-SHA512(Key = c_par, Data = 0x01 || I_R || ser32(i))\n>\n>---\n>\n>I think this suggestion is simple to implement (a bit harder to unit\n>test) and the string to hash with HMAC-SHA512 always has the same\n>length.  I use I_R, since I_L is obviously not very random if I_L >= n.\n>There is a minimal chance that it will lead to an infinite loop if I_R\n>is the same in two consecutive iterations, but that has only a chance\n>of 1 in 2^512 (if the algorithm is used for different curves that make\n>I_L >= n more likely, the chance is still less than 1 in 2^256).  In\n>theory, this loop can be avoided by incrementing i in every iteration,\n>but this would make an implementation error in the \"hard to test\" path\n>of the program more likely.\n>\n>The other derivation functions should be updated in a similar matter.\n>Also the derivation of the root node from the seed should be updated\n>in a similar matter to avoid invalid seeds.\n>\n>If you followed until here, thanks for reading this long posting.\n>\n>  Jochen\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160421/f6ea5a61/attachment.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2016-04-21T17:23:48",
                "message_text_only": "On 21/04/16 17:28, Eric Lombrozo via bitcoin-dev wrote:\n> I don't think we've ever had to handle this case. \n\nThis is the main problem: we are not sure, because not a lot of software\ndoes this checks. Also even if you do check, it's hard to handle an\nexception (you can't always skip - what if the problematic node is m/44'?).\n\nOne of the motivations is to fix BIP-32 so it can be used for\nnon-secp256k1 curves as well. For NIST P-256 curve this chance is 2^-32.\n\nJochen even managed to find an example[1]:\n\nm/28578'/33941 where m is derived from\n\"000102030405060708090a0b0c0d0e0f\" seed.\n\n[1]\nhttps://github.com/trezor/trezor-crypto/commit/16ff4387ae79429e629a5454708abf7385b3a9a3\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"stick\" Rusnak\nSatoshiLabs.com"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2016-04-22T09:14:38",
                "message_text_only": "Am 21.04.2016 um 17:28 schrieb Eric Lombrozo:\n> In practice the probability of this case triggering is on the order of\n> 2^-128 or something astronomically tiny. I've been using BIP32 for a few\n> years already as have many others...I don't think we've ever had to\n> handle this case. Justifiably, many app developers feel like the\n> additional complexity of properly handling this case is not worth the\n> effort.\n> \n> Having said that, if the handling of this case is simple to implement\n> and easy to isolate in the program flow, I am in favor of doing\n> something along the lines of what you propose.\n> \n\nYes, the idea is to handle the problem in the library so that app\ndevelopers don't have to handle the case of missing addresses or just\nignore the problem.  It also doesn't add much complexity to the library\nas the current implementations already test for invalid keys.  The\nlibrary would then just retry instead of returning an error (that most\napp developers would then ignore).\n\n  Jochen"
            }
        ],
        "thread_summary": {
            "title": "Proposal to update BIP-32",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Lombrozo",
                "Pavol Rusnak",
                "Marek Palatinus",
                "Jochen Hoenicke"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15101
        }
    },
    {
        "title": "[bitcoin-dev] Recent editing for the consensus BIPs of segregated witness (141 and 143)",
        "thread_messages": [
            {
                "author": "jl2012 at xbt.hk",
                "date": "2016-04-23T08:59:32",
                "message_text_only": "In the past month, there are a number of revisions in BIP141 and 143. Except\nthe use of BIP9 for deployment, none of these edits was a result of a change\nof consensus behavior of the reference implementation. Instead, the text\nwere edited for clarifications or corrections to match the reference\nimplementation. The consensus specification (except the use of BIP9) has not\nchanged since early Feb 2016, if not earlier.\n\n \n\nHistory of BIP141 and revision proposals\n\nhttps://github.com/bitcoin/bips/commits/master/bip-0141.mediawiki\n\nhttps://github.com/bitcoin/bips/pull/365\n\nhttps://github.com/bitcoin/bips/pull/376\n\n \n\nHistory of BIP143\n\nhttps://github.com/bitcoin/bips/commits/master/bip-0143.mediawiki\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160423/dedfdc10/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Recent editing for the consensus BIPs of segregated witness (141 and 143)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "jl2012 at xbt.hk"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 887
        }
    },
    {
        "title": "[bitcoin-dev] Private \"Merkle\" Vaults for the Bitcoin system",
        "thread_messages": [
            {
                "author": "J\u00e9r\u00f4me Legoupil",
                "date": "2016-04-24T10:05:52",
                "message_text_only": "In Febuary, an email intitled \"Bitcoin Vaults\" was addressed to this mailing list linking to a paper on \u201ccovenants\u201d (see mail below) describing a way to apply recursive restrictions temporarily or permanently on bitcoins (for digital asset use-cases) and Bitcoin Vaults were offered as an application (thanks to the authors for sharing their work with the community, I personally found this paper insightful and inspiring). Unfortunately, this proposal isn\u2019t fungibility friendly and could lead Bitcoin to undesirable outcomes.\n\nWhat follows is an attempt to design Vaults that preserve Bitcoin\u2019s fungibility and keep their defensive attributes private from blockchain observers and from potential insider participants: the Vault\u2019s defence is incrementally revealed when executed. If I am a war chief defending a castle, I\u2019m certainly not going to show my defence strategy to the world and if it leaked to the enemy, it would greatly weaken my chances to succeed: greater privacy leads to greater security.\n \nVaults enable important use-cases for Bitcoin as a store of value, in particular the tricky but critical use-case of successions (heritages).\n\n\n\u2014 General idea \u2014 \n\nThis design restricts the bitcoins in a Vault to a private, predefined, finite (no patterns) and unforgeable set of authorized actions defined by the Vault creator at the setup.\n\nDefinition: an authorized action (or action) is an authorized address the bitcoins inside a Vault can be sent to, with an authorized timelock.\nAction = <pubKeyHash> < timelock>\n\nThe Vault can be defined as a set of parent/child authorized actions. This enables the Vault creator to construct a Merkle tree of his Vault. During the setup, the creator computes the hashs of every authorized action, and builds his Merkle tree from the bottom, up to the top Merkle root. The Vault creator must give the appropriate Merkle proofs (authorizations) to the Vault participants (if any) according to the authorizations he grants them, and when someone wants to move funds inside or out of the Vault, he needs to provide to the network (in addition of a valid signature) the Merkle proof that demonstrates that his action is authorized by the Vault. The network can verify that:    \nHash [ Merkle_proof(Action) + Hash(Action) ] == Merkle_proof(Parent_Action)\n\nThe Merkle tree must be destroyed once the setup is completed. Storing the tree anywhere is unnecessary and endangers the Vault's privacy.\n\n\n\u2014 Example \u2014 \n\nIn this example, the Vault is composed of the actions A, B, C, D:\n\nA--->B--->C\n          \\\n            `--->D\n\nIf H is the hash function, the Merkle tree is:\n                                                                          Merkle_root  \n                                                                              /     \\\n              H(H(H(H(D)+H(1)) + H(H(C)+H(1))) + H(B))       H(A)\n                                                 /     \\                                                        \nH(H(H(D)+H(1)) + H(H(C)+H(1)))        H(B)                                 \n                     /     \\                                   \n H(H(D)+H(1))        H(H(C)+H(1))                \n           /                            \\\n          1                             1\n\nNote: 1 are terminations to signal to the network that the coins are now allowed to exit the Vault. If the 1-terminations were not added, the bitcoins would be locked forever in the Vault because it would require to reverse H to spend them.\n\nWith notations:\n                                                                                   Merkle_root  \n                                                                                        /     \\\n                                                              Merkle_Proof(A)       H(A)\n                                                                        /     \\                                                        \nMerkle_Proof(parent of C) = Merkle_Proof(B)        H(B)                                 \n                                      /     \\                                   \n            Merkle_Proof(C)        H(H(C)+H(1))                \n                                                        \\\n                                                         1\n\n\u2014 nSequence \u2014\n\nnSequence has different timelock meanings for the different time related OP codes:\nOP_CLTV: a tx spending the outputs of a [parent tx with nSequence] is invalid if current block number <= nSequence\nOP_CSV: a tx spending the outputs of a [parent tx with nSequence] is invalid if current block number <= block number of the parent tx + nSequence\n\nNew meaning of nSequence for OP_VAULT:\nOP_VAULT: a tx with nSequence is invalid if current block number <= block number of the parent tx + nSequence\n\n\u2014OP_VAULT\u2014 \n\nThis opcode checks if the tx timelock allows the tx to be included in a block and outputs a hash.\n\nOP_VAULT (nSequence, Merkle_proof(Action), pubKeyHash)\n{\nIF (current block number >= Max(block number of the parent outputs) + nSequence of current tx)\n     hAction=H(H(pubKeyHash)+H(nSequence));\n     h=H(Merkle_proof(Action)+hAction);\n     return h;\n\nELSE\n     return H(0);                                    // the tx cannot be included in a block yet\n}\n\n\n\u2014Vault transaction structures\u2014\n\nFunding tx\nscriptSig=<sig> <pubKey>\nscriptPubKey=\n<3> OP_PICK OP_HASH160 OP_VAULT <Merkle_root> OP_EQUALVERIFY OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n\nVault tx\nscriptSig=<sig> <pubKey> <nSequence> <Merkle_proof>\nscriptPubKey=\n<3> OP_PICK OP_HASH160 OP_VAULT <Merkle_proof> OP_EQUALVERIFY OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n\nExit tx\nscriptSig=<sig>  <pubKey> <nSequence> <Merkle_proof>\nscriptPubKey=\nOP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n\nNote: The exit tx can also use OP_VAULT if it is exiting the Vault while funding another Vault.\n\n\n\u2014New consensus rules\u2014 (enforcement of OP_VAULT txs)\n\nIF\n// this new rule concerns only Vault txs...\n(parent tx VAULT_FLAG_ENABLE)\nAND\n // ...that are not permitted to exit the Vault if the action is not terminated by 1 in the Merkle tree \n(    \nH(<Merkle_proof> in tx\u2019s scriptSig + H(H(H(pubKeyHash)+H(nSequence))) + H(1))) != <Merkle_proof> in parent tx\u2019s scriptSig\n)\nAND\n{\n// the tx must be flagged as a Vault tx\n(tx VAULT_FLAG_DISABLE) \nOR\n// the tx violates the Merkle tree data structure\n(<Merkle_proof> in tx\u2019s scriptSig != <Merkle_proof> in tx\u2019s scriptPubKey)\n}\n\nTHEN the transaction is INVALID.\n\n\u2014Privacy\u2014 \n\nIn this design, Vault txs are CoinJoin/CT compatible (joining with other Vault txs) and perhaps Vault users will be willing to way for days or weeks to achieve maximum privacy, as they are susceptible of holding significant value in these structures.\n\n\u2014Use-cases\u2014 \n\n\"Smart successions\" : a morbid yet critical use-case for Bitcoin as a store of value\n\nBitcoin currently struggles in dealing with successions in a trustless manner. How does the Bitcoin system know when the succession should be executed ? What happens in case of conflict between the heirs ? It\u2019s a tricky but important use-case.\n\nBitcoin successions are dealt with by either sharing decrypted private keys with the heirs (trusting they won\u2019t take the coins before due time or won\u2019t have them stolen), renting a safe at the bank and making a testament (trusting the bank) or simply hiding the keys and hoping the heirs will find them when you disappear. None of these schemes are satisfying, especially when dealing with multiple heirs. This gap could likely hold back investors from investing a significant portion of their wealth in Bitcoin if they don\u2019t have a trustless and secure mechanism that guarantees their succession will be executed according to their will.\n\nFunding addr\n    \\\n      `->Transfert addr\u20140\u2014>Alice addr                                 (1)\n               |          \\\n               |            `-50000\u2014>Multisig2/2\u2014>Bob addr    \n               |                                             \\                               (2)\n               |                                               `\u2014>Carol addr\n               |\n                `-100000\u2014>Multisig2/3\u2014>Bob addr                \n                                                  \\                                          (3) \n                                                    `\u2014>Carol addr             \n\n(1) Alice\u2019s recovery address in case Bob and Carol were too impatient to spend the heritage.\n(2) Alice added a Multisig2/2 controlled by Bob and Carol. Alice gave Bob and Carol each, half of the Merkel proof to pull the funds into Multisig2/2: first Bob and Carol need to agree on the conditions of the succession and sign the exit transaction from the Multisig2/2, than they can share their Merkel proof halves and pull the funds.\n(3) Arbitration in case of disagreement (or if Bob or Carol is uncooperative, or disappeared): Alice added a Multisig2/3 involving an arbitrator in case Alice and Bob couldn\u2019t find an agreement after 20\u2019000 blocks or something. The arbitrator has no information on the succession until Bob or Carol asks for his assistance. Alice gave each Bob and Carol the full Merkel proof to pull the funds to Multisig2/3.\n\nWe can imagine services assisting in the Vault setups and in the blockchain monitoring, enabling successions to occur entirely on-chain, in a trustless, private and peer-to-peer manner, outside of the current financial system. \n\nScorched earth policies if the Vault defender is entirely compromised\nThe following defence strategy is inspired from the paper mentionned in the introduction :\n\nFunding addr\n    \\\n      `->Transfert addr-1000->Spending addr\n                \\\n                  `-0->Recovery addr1-100->Recovery addr2-1000->Recovery addr3\n                                                                         \\\n                                                                           `-0->Hidden addr ??\n\nAn attacker broadcasts the Transfer tx from the Funding address. The defender can stay patient and learn if the attacker knows the recovery key (& the corresponding Merkle proofs) and ajust his defence accordingly: if indeed the adversary can move funds (he knows the recovery key(s)) and approches to the Vault exit (he knows also the Merkle proofs), the defender can burn all funds into fees, denying the attacker.\n\n\u2014Thanks for your attention\u2014\n\nPlease let me know if you think this idea is worth exploring deeper.\n\nCheers,\nJerome\n                                                                 \n\n\n> On 27 Feb 2016, at 00:23, bitcoin-dev-request at lists.linuxfoundation.org wrote:\n> \n> Send bitcoin-dev mailing list submissions to\n> \tbitcoin-dev at lists.linuxfoundation.org\n> \n> To subscribe or unsubscribe via the World Wide Web, visit\n> \thttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> or, via email, send a message with subject or body 'help' to\n> \tbitcoin-dev-request at lists.linuxfoundation.org\n> \n> You can reach the person managing the list at\n> \tbitcoin-dev-owner at lists.linuxfoundation.org\n> \n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of bitcoin-dev digest...\"\n> \n> \n> Today's Topics:\n> \n>   1. Bitcoin Vaults. (Emin G?n Sirer)\n>   2. The first successful Zero-Knowledge Contingent Payment\n>      (Gregory Maxwell)\n>   3. Re: The first successful Zero-Knowledge Contingent\tPayment\n>      (Sergio Demian Lerner)\n>   4. Fwd: The first successful Zero-Knowledge Contingent\tPayment\n>      (Gregory Maxwell)\n> \n> \n> ----------------------------------------------------------------------\n> \n> Message: 1\n> Date: Fri, 26 Feb 2016 11:05:20 -0500\n> From: Emin G?n Sirer <el33th4x0r at gmail.com>\n> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n> Cc: Malte M?ser <malte.moeser at uni-muenster.de>,\tIttay Eyal\n> \t<ittay.eyal at cornell.edu>\n> Subject: [bitcoin-dev] Bitcoin Vaults.\n> Message-ID:\n> \t<CAPkFh0vuLsoNQUEdH-kGqXYvFJt1tXLvt0eMEuFZGm7Pus-_2g at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n> \n> At the 3rd Bitcoin Workshop being held in conjunction with the Financial\n> Cryptography Conference in Barbados, my group will be presenting a new idea\n> for improving Bitcoin wallet security and deterring thefts today.\n> \n> The write-up is here:\n> \n> http://hackingdistributed.com/2016/02/26/how-to-implement-secure-bitcoin-vaults/\n> \n> The paper with the nitty gritty details is here:\n>    http://fc16.ifca.ai/bitcoin/papers/MES16.pdf\n> \n> The core idea:\n> \n> Our paper describes a way to create vaults, special accounts whose keys can\n> be neutralized if they fall into the hands of attackers. Vaults are\n> Bitcoin?s decentralized version of you calling your bank to report a stolen\n> credit card -- it renders the attacker?s transactions null and void. And\n> here?s the interesting part: in so doing, vaults demotivate key theft in\n> the first place. An attacker who knows that he will not be able to get away\n> with theft is less likely to attack in the first place, compared to current\n> Bitcoin attackers who are guaranteed that their hacking efforts will be\n> handsomely rewarded.\n> \n> Operationally, the idea is simple. You send your money to a vault address\n> that you yourself create. Every vault address has a vault key and a\n> recovery key. When spending money from the vault address with the\n> corresponding vault key, you must wait for a predefined amount of time\n> (called the unvaulting period) that you established at the time you created\n> the vault -- say, 24 hours. When all goes well, your vault funds are\n> unlocked after the unvaulting period and you can move them to a standard\n> address and subsequently spend them in the usual way. Now, in case Harry\n> the Hacker gets a hold of your vault key, you have 24 hours to revert any\n> transaction issued by Harry, using the recovery key. His theft,\n> essentially, gets undone, and the funds are diverted unilaterally to their\n> rightful owner. It?s like an ?undo? facility that the modern banking world\n> relies on, but for Bitcoin.\n> \n> The technical trick relies on a single new opcode, CheckOutputVerify, that\n> checks the shape of a redeem transaction. Note that fungibility is not\n> affected, as the restrictions are at the discretion of the coin owner alone\n> and can only be placed by the coin owner ahead of time.\n> \n> We suspect that this modest change could actually be a game-changer for\n> bitcoin security: clients and keys are notoriously hard to secure, and a\n> facility that allows you to possibly recover, and if not, permanently keep\n> the hacker from acquiring your funds, could greatly deter Bitcoin thefts.\n> \n> As always, comments and suggestions are welcome.\n> - egs, Ittay Eyal and Malte Moeser.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160424/403f4b0c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Private \"Merkle\" Vaults for the Bitcoin system",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "J\u00e9r\u00f4me Legoupil"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 14882
        }
    },
    {
        "title": "[bitcoin-dev] BIP Draft: Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets",
        "thread_messages": [
            {
                "author": "Kefkius",
                "date": "2016-04-26T23:00:48",
                "message_text_only": "I'm re-submitting this after a little under a year because, though it\ngenerated little discussion, I feel it is still necessary.\n\nThe following can also be found at:\nhttps://github.com/Kefkius/bip-kefkius-multicoin-multisig/blob/master/README.md\n\n<pre>\n  BIP: bip-kefkius-multicoin-multisig\n  Title: Multi-Currency Hierarchy For Use In Multisignature\nDeterministic Wallets\n  Author: Tyler Willis <kefkius at maza.club>\n  Status: Draft\n  Type: Standards Track\n</pre>\n\n## Abstract ##\n\nThis BIP defines a hierarchy based on BIP-0044 for deterministic wallets\nintended to facilitate multi-currency, multisignature wallet management.\n\nThis BIP is an application of BIP-0043.\n\n## Motivation ##\n\nThe hierarchy defined in BIP-0044 places a coin's type level above the\nlevel designating account number. This limits the possible\nimplementations of multi-currency, multisignature wallets. The hierarchy\ndefined here facilitates the creation of wallets intended to be both\nmulti-currency and multisignature.\n\n## Specification ##\n\n### Path Levels ###\n\n<pre>\nm / purpose' / wallet' / coin_type / change / address_index\n</pre>\n\n#### Purpose ####\n\nPurpose is a constant tentatively set to\n`bip-kefkius-multicoin-multisig` as there is no BIP number assigned to\nthis proposal. Hardened derivation is used here.\n\n#### Wallet ####\n\nThis level is incremented for every wallet that one makes. Much like the\naccount node in BIP-0044, this is intended to organize independent\nidentities within the key space.\nBasically, each index in this level represents a group of cosigners.\nHardened derivation is used here.\n\n#### Coin Type ####\n\nThis is the BIP-0044 index of the coin being managed. Public derivation\nis used here.\nPublic derivation is used so that cosigners need only know one of each\nother's public keys, rather than needing to distribute public keys for\neach coin.\n\n#### Change ####\n\n0 is used for public addresses and 1 is used for change addresses.\nIdentical to BIP-0044 behavior. Public derivation is used here.\n\n#### Address Index ####\n\nThe address index. This increases sequentially as it does in BIP-0044.\nPublic derivation is used here.\n\n\n## Examples ##\n\n| wallet | coin      | change? | address | path                         |\n|:-------|:----------|:--------|:--------|:-----------------------------|\n| first  | Bitcoin   | no      | first   | m /\nbip-kefkius-multicoin-multisig' / 0' / 0  / 0 / 0   |\n| first  | Bitcoin   | no      | second  | m /\nbip-kefkius-multicoin-multisig' / 0' / 0  / 0 / 1   |\n| first  | Testnet   | no      | first   | m /\nbip-kefkius-multicoin-multisig' / 0' / 1  / 0 / 0   |\n| second | Bitcoin   | no      | first   | m /\nbip-kefkius-multicoin-multisig' / 1' / 0  / 0 / 0   |\n| second | Bitcoin   | yes     | first   | m /\nbip-kefkius-multicoin-multisig' / 1' / 0  / 1 / 0   |\n| third  | Testnet   | yes     | sixth   | m /\nbip-kefkius-multicoin-multisig' / 2' / 1  / 1 / 5   |"
            }
        ],
        "thread_summary": {
            "title": "BIP Draft: Multi-Currency Hierarchy For Use In Multisignature Deterministic Wallets",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Kefkius"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2899
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: Scripting System in Merkelized Abstract Syntax Tree",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-04-29T05:48:10",
                "message_text_only": "https://github.com/jl2012/bips/blob/mastopcodes/bip-mastopcodes.mediawiki\n\nThis BIP defines the scripting system in Merkelized Abstract Syntax Tree (BIP114). It re-enables some of the previously disabled opcodes, introduces new opcodes, and defines expandable opcodes for future extension.\n\nIt will:\n\t\u2022 re-enable CAT, SUBSTR, LEFT, RIGHT, INVERT, AND, OR, XOR, LSHIFT, and RSHIFT;\n\t\u2022 introduce new opcodes: DUPTOALTSTACK, DUPFROMALTSTACK, SWAPSTACK, SWAPCAT, and RESIZE;\n\t\u2022 define expandable opcodes for future softforks of stack manipulating opcodes: EXPAND1 to EXPAND32.\n\n\nThis BIP is based on the BIP114 MAST: https://github.com/bitcoin/bips/blob/master/bip-0114.mediawiki\n\nReference implementation, including the BIP9 logic and script tests, could be found at https://github.com/jl2012/bitcoin/tree/segwit_mast . This branch is rebased on top of the #7910 segwit PR. However, I have not tested the BIP9 activation.\n\nThe implementation of the re-enabled opcode are mostly taken from the Elements Project.\n\n-------------\n\nThis BIP does not describe changes in CHECKSIG (e.g. new hash type, Schnorr sig), which I think should be another BIP.\n\nI have also considered more radical changes. For example, make all comparison opcode to be \u201cVERIFY\u201d type, and a script passes if and only if the stack is exactly empty after evaluation.\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 671 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160429/dfca9def/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: Scripting System in Merkelized Abstract Syntax Tree",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1632
        }
    },
    {
        "title": "[bitcoin-dev] BIP144: use of 1<<3 service bit",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-04-29T07:25:28",
                "message_text_only": "Please note that the BIP144 has just been revised to match the implementation in #7910. We will use the 1<<3 service bit (NODE_WITNESS) to signal the readiness for segwit.\n\nhttps://github.com/bitcoin/bips/commit/dde47fc973b015c6cc91a0ed28fb3aca57add5e6 <https://github.com/bitcoin/bips/commit/dde47fc973b015c6cc91a0ed28fb3aca57add5e6>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160429/908f845b/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 671 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160429/908f845b/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP144: use of 1<<3 service bit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 818
        }
    },
    {
        "title": "[bitcoin-dev] segwit subsidy and multi-sender (coinjoin) transactions",
        "thread_messages": [
            {
                "author": "Kristov Atlas",
                "date": "2016-04-29T18:22:32",
                "message_text_only": "Has anyone thought about the effects of the 75% Segregated Witness subsidy\non CoinJoin transactions and CoinJoin-like transactions? Better yet, has\nanyone collected data or come up with a methodology for the collection of\ndata?\n\n>From this link: https://bitcoincore.org/en/2016/01/26/segwit-benefits/\n\n\"Segwit improves the situation here by making signature data, which does\nnot impact the UTXO set size, cost 75% less than data that does impact the\nUTXO set size. This is expected to encourage users to favour the use of\ntransactions that minimise impact on the UTXO set in order to minimise\nfees, and to encourage developers to design smart contracts and new\nfeatures in a way that will also minimise the impact on the UTXO set.\"\n\nMy expectation from the above is that this will serve as a financial\ndisincentive against CoinJoin transactions. However, if people have\nevidence otherwise, I'd like to hear it.\n\nI noticed jl2012 objected to this characterization here, but has not yet\nprovided evidence:\nhttps://www.reddit.com/r/Bitcoin/comments/4gyhsj/what_are_the_impacts_of_segwits_75_fee_discount/d2lvxmw\n\nA sample of the 16 transaction id's posted in the JoinMarket thread on\nBitcoinTalk shows an average ratio of 1.38 or outputs to inputs:\n\nhttps://docs.google.com/spreadsheets/d/1p9jZYXxX1HDtKCxTy79Zj5PrQaF20mxbD7BAuz0KC8s/edit?usp=sharing\n\nAs we know, a \"traditional\" CoinJoin transaction creates roughly 2x UTXOs\nfor everyone 1 it consumes -- 1 spend and 1 change -- unless address reuse\ncomes into play.\n\nPlease refrain from bringing up Schnorr signatures in your reply, since\nthey are not on any immediate roadmap.\n\nThanks,\nKristov\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160429/faf5665f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "segwit subsidy and multi-sender (coinjoin) transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Kristov Atlas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1826
        }
    }
]