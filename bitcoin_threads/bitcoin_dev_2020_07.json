[
    {
        "title": "[bitcoin-dev] Is Bitcoin mempool synchronized?",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-01T00:53:46",
                "message_text_only": "Good morning Hilda,\n\n> Hi there,\n>\n> I have been assuming Bitcoin system to be well synchronized, including mempools. But after being challenged, I started to think that I actually cannot verify this without knocking the door of every miner in every single second (just a time slice reasonable to me; stop torturing me by asking why). Can anyone share any thoughts with me?\n\n\nNo, definitely not.\n\nThere is no good way to limit the amount of transactions someone can push at you, except by various heuristics.\nYet those very same heuristics mean that someone with a good knowledge of those heuristics can make your mempool desynchronized with that of somebody else.\n\nFortunately for Bitcoin, it is the blockchain itself that we synchronize on.\nPeople cannot push blocks at you without doing the work of grinding towards the difficulty target, thus it is not possible to spam blocks.\n\nTANSTAAGM - There Ain't No Such Thing As A Global Mempool\n\nFor this reason, any consensus rule has to refer only to data inside blocks, and never to data in mempools, are mempools are ephemeral and not synchronized across all nodes.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Is Bitcoin mempool synchronized?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1134
        }
    },
    {
        "title": "[bitcoin-dev] MAD-HTLC",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-01T16:58:24",
                "message_text_only": "Good morning Tejaswi,\n\n> Hello ZmnSCPxj (as there would be no better way to start an email to you :-),\n>\n> I posted a reply to Dave in the other sub-thread of this main thread. We have a paper about something similar to what you have said - where we look at \"weak\" and \"strong\" miners, and how even if there are a few weak miners, they have a dominating strategy, etc.\u00a0\n>\n\nBy my reading, it seems to me that you divide miners into \"weak\" and \"powerful\".\nWeak miners have lower hashrate than powerful ones.\nThe dividing point depends on how much Alice and Bob fees are.\nIf the hashrate share of a miner is less than the ratio of Alice (honest) fee to Bob (bribing) fee, then the miner is weak.\n\nAnd your paper posits that if a miner is weak, its best strategy is to take the myopic strategy and include the currently-valid Alice transaction.\n\nThus, if Alice even *matches* Bob, it seems to me that this ratio f / b is 1.0 implying a miner can only be powerful if it has already 51%-attacked Bitcoin (which tends to invalidate all our security assumptions of higher-layer protocols anyway, since a 51% attacker can censor anything with impunity).\n\nOf course, Bob can offer up to the entire fund amount, for free, to miners as a bribe, without loss to Bob.\n\nFor more realistic scenarios where no miner has 100% hashrate, then Alice can make all miners weak by being willing to pay up to 50% of the fund as fee, as a miner that achieves greater than 50% hashrate share would already effectively pwnzored Bitcoin and gained UNLIMITED POWAH anyway.\n\nSo it looks to me that scorched-earth is a possible mitigation against this attack.\n\n--\n\nAnother analysis, similar but a little off-tangent to yours, would be to consider miners as a breeding group with various strategies, and see which one is able to gain more utilons (with which it creates more miners) and outbreed the other miners.\n\nThis models the fact that miners can use their earnings to reinvest into their mining operations and increase their mining hashrate, and the amount they can reinvest is proportional to their earnings.\nA miner that \"gives birth\" to a child miner with the same strategy is, in the so-called \"real world\", simply a miner that has earned enough and reinvested those earnings to double the hashrate of their business (which, logically speaking, would use the same strategy throughout the entire business).\n\nLet us start with a population of 4 miners, 3 of which follow the non-myopic strategy, and the remaining following the myopic strategy.\nLet us postulate that all miners have the same unit hashrate.\nThus, this starting population is 75% non-myopic, 25% myopic.\n\nIf there exists a timelocked bribe, then if non-myopic miner is chosen at a block, it will have to sacrifice the Alice fee minus whatever lesser transaction fee it can replace in its block.\nIf the Alice transaction is successfully delayed until the Bob transaction is valid, then the non-myopic miners can get the Bob transaction confirmed.\n\nHowever, even in the case that the Alice transaction is delayed, the myopic miner still has its 25% chance --- equal to the 25% chance of the three non-myopic miners --- to confirm the Bob transaction and earn the increased bribe that Bob offers.\n\nThus, the non-myopic miners can end up sacrificing fee earnings, and in the end the myopic miner still has the 25% chance to get the Bob transaction fee later when it becomes valid.\nSo the non-myopic miners do not impose any loss on myopic miners.\n\nOn the other hand, if the non-myopic miners sacrificed their chances to include the Alice transaction in the hope of getting the later 25% chance to get the Bob higher-fee timelocked transaction, and then the myopic miner gets the next block, the myopic miner gets the Alice transaction confirmed and the 25% chance to get the Bob higher fee is lost by the non-myopic miners.\nThus, the myopic miner is able to impose costs on their non-myopic competitors.\n\nSo even if by chance for the entire locktime, only the non-myopic miners are selected, the myopic miner still retains its 25% chance of getting the block at locktime + 1 and confirming and earning the bigger Bob fee.\n\nThus, we expect that the myopic miner will earn more than 25% of subsidies and fees than the non-myopic miners, in such a mixed environment.\n\nWe can then consider that the myopic miner, being able to earn more, is able to increase its progeny (i.e. expand its mining business and inspire new miners to follow its strategy towards success) faster than the non-myopic miners.\n\nWe can thus conclude that the myopic miners will eventually dominate over the breeding population and drive the non-myopic miners to near-extinction.\n\nIt is helpful to remember that rationality is about success *in the universe you exist in*.\nWhile miners may step back and consider that, ***if*** all of them were to use non-myopic strategy, they would all earn more, the fact of the matter is that each miner works for themselves, and themselves alone, in a highly competitive environment.\nThus, even though they know *all of them* will benefit if they use the non-myopic strategy, they cannot be sure, unless they are all perfectly synchronized mind-clones of each other, that the other miners will rather be selfish and mine for themselves, even if in the end every miner earns less\nThe standard for success is to earn more *than your competitors*, not ensure that *every* miner earns more.\n\nFortunately, since miners are running a business, this competition leads to better services to the the customers of the mining business, a known phenomenon of the free market, yay free market greed is good.\nThe user Alice is a customer of the mining business.\nAlice gets, as a side effect of this competitiveness of miners (which leads to miners adopting myopic strategies in order to gain an edge over non-myopic miners), improved security of their HTLCs without requiring slashable fidelity bonds or such-like that MAD-HTLC proposes.\n\n\nUsing this model, it seems to me that non-myopic miners can only maintain hold over the blockchain if all miners agree to use non-myopic strategy.\nThis is basically all miners forming a cartel / monopoly, which we know is detrimental to customers of the monopoly, and is the reason why we prefer decentralization.\n\n\nRegards,\nZmnSCPxj\n\n\n\n\n> On Mon, Jun 29, 2020 at 8:05 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Good morning Dave, et al.,\n> >\n> > > >\u00a0 \u00a0 \u00a0 Myopic Miners: This bribery attack relies on all miners\n> > > >\n> > > >\n> > > > being rational, hence considering their utility at game conclu-\n> > > > sion instead of myopically optimizing for the next block. If\n> > > > a portion of the miners are myopic and any of them gets to\n> > > > create a block during the first T \u2212 1 rounds, that miner would\n> > > > include Alice\u2019s transaction and Bob\u2019s bribery attempt would\n> > > > have failed.\n> > > > In such scenarios the attack succeeds only with a certain\n> > > > probability \u2013 only if a myopic miner does not create a block\n> > > > in the first T \u2212 1 rounds. The success probability therefore\n> > > > decreases exponentially in T . Hence, to incentivize miners\n> > > > to support the attack, Bob has to increase his offered bribe\n> > > > exponentially in T .\n> > >\n> > > This is a good abstract description, but I think it might be useful for\n> > > readers of this list who are wondering about the impact of this attack\n> > > to put it in concrete terms. I'm bad at statistics, but I think the\n> > > probability of bribery failing (even if Bob offers a bribe with an\n> > > appropriately high feerate) is 1-exp(-b*h) where `b` is the number of\n> > > blocks until timeout and `h` is a percentage of the hashrate controlled\n> > > by so-called myopic miners. Given that, here's a table of attack\n> > > failure probabilities:\n> > >\n> > > \"Myopic\" hashrate\n> > > B 1% 10% 33% 50%\n> > > l +---------------------------------\n> > > o 6 | 5.82% 45.12% 86.19% 95.02%\n> > > c 36 | 30.23% 97.27% 100.00% 100.00%\n> > > k 144 | 76.31% 100.00% 100.00% 100.00%\n> > > s 288 | 94.39% 100.00% 100.00% 100.00%\n> > >\n> > > So, if I understand correctly, even a small amount of \"myopic\" hashrate\n> > > and long timeouts---or modest amounts of hashrate and short\n> > > timeouts---makes this attack unlikely to succeed (and, even in the cases\n> > > where it does succeed, Bob will have to offer a very large bribe to\n> > > compensate \"rational\" miners for their high chance of losing out on\n> > > gaining any transaction fees).\n> > >\n> > > Additionally, I think there's the problem of measuring the distribution\n> > > of \"myopic\" hashrate versus \"rational\" hashrate. \"Rational\" miners need\n> > > to do this in order to ensure they only accept Bob's timelocked bribe if\n> > > it pays a sufficiently high fee. However, different miners who try to\n> > > track what bribes were relayed versus what transactions got mined may\n> > > come to different conclusions about the relative hashrate of \"myopic\"\n> > > miners, leading some of them to require higher bribes, which may lead\n> > > those those who estimated a lower relative hash rate to assume the rate\n> > > of \"myopic\" mining in increasing, producing a feedback loop that makes\n> > > other miners think the rate of \"myopic\" miners is increasing. (And that\n> > > assumes none of the miners is deliberately juking the stats to mislead\n> > > its competitors into leaving money on the table.)\n> >\n> > A thought occurs to me, that we should not be so hasty to call non-myopic strategy \"rational\".\n> > Let us consider instead \"myopic\" and \"non-myopic\" strategies in a population of miners.\n> >\n> > I contend that in a mixed population of \"myopic\" and \"non-myopic\" miners, the myopic strategy is dominant in the game-theoretic sense, i.e. it might earn less if all miners were myopic, but if most miners were non-myopic and a small sub-population were myopic and there was no easy way for non-myopic miners to punish myopic miners, then the myopic miners will end up earning more (at the expense of the non-myopic miners) and dominate over non-myopic miners.\n> > Such dominant result should prevent non-myopic miners from arising in the first place.\n> >\n> > The dominance results from the fact that by accepting the Alice transaction, myopic miners are effectively deducting the fees earned by non-myopic miners by preventing the Bob transaction from being confirmable.\n> > On the other hand, even if the non-myopic miners successfully defer the Alice transaction, the myopic miner still has a chance equal to its hashrate of getting the Bob transaction and its attached fee.\n> > Thus, myopic miners impose costs on their non-myopic competitors that non-myopic miners cannot impose their myopic competitors.\n> > If even one myopic miner successfully gets the Alice transaction confirmed, all the non-myopic miners lose out on the Bob bribe fee.\n> >\n> > So I think the myopic strategy will be dominant and non-myopic miners will not arise in the first place.\n> >\n> > Regards,\n> > ZmnSCPxj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-07-02T12:22:51",
                "message_text_only": "On Wed, Jul 1, 2020 at 6:58 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> And your paper posits that if a miner is weak, its best strategy is to\n> take the myopic strategy and include the currently-valid Alice transaction.\n>\n\nYes. The proof is quite trivial and follows from the definition of weak: if\nthe myopic miner's hashpower percentage is p_i, and it's lower than f/b,\nthat means that f > b*p_i. By including the currently-valid Alice\ntransaction, the myopic miner could make f, which is higher than their\nexpected gain, which is b*p_i. The myopic miner has a p_i chance of mining\nthe first block when Bob's transaction becomes valid, and it's most likely\nto stay valid for just 1 block, as every miner would want that immediately\nwhen it gets valid. This is where we disagree with the MAD-HTLC paper. They\nassume that there are not any miners with sub-1% hashrate around. We find\nthat there are many such miners, and with channel_reserve_satoshi set to 1%\nof the channel value, Alice can bump her fees to at least 1% of the channel\nvalue without worry (because she will get Bob's channel_reserve_satoshi's\nfor herself if Bob is cheating by releasing a previous commitment TXN).\n\nWe additionally also show that when strong miners know that weak miners are\naround, some of their strategies get dominated as well, and they will be\nforced to include Alice's transaction as well. This, if there is just one\n*known* weak miner, things are good for Alice. As an FYI, in our paper\nAlice is the cheater and Bob is the victim. There were reasons to \"reverse\nthe convention\", so to speak - but that's for another day :-)\n\n\n>\n> Thus, if Alice even *matches* Bob, it seems to me that this ratio f / b is\n> 1.0 implying a miner can only be powerful if it has already 51%-attacked\n> Bitcoin (which tends to invalidate all our security assumptions of\n> higher-layer protocols anyway, since a 51% attacker can censor anything\n> with impunity).\n>\n\nWe assume that Bob will bribe with the entire channel value - because he\nhas received commensurate goods and services off-chain. So, Alice will find\nit difficult to match Bob's bribe, but she doesn't have to.\n\n\n>\n> Of course, Bob can offer up to the entire fund amount, for free, to miners\n> as a bribe, without loss to Bob.\n>\n\nYes. Precisely.\n\n\n>\n> For more realistic scenarios where no miner has 100% hashrate, then Alice\n> can make all miners weak by being willing to pay up to 50% of the fund as\n> fee, as a miner that achieves greater than 50% hashrate share would already\n> effectively pwnzored Bitcoin and gained UNLIMITED POWAH anyway.\n>\n\nBut she doesn't have to go as far as 50%. Just 1% seems quite reasonable,\ngiven a reasonable timelock. We have a closed form solution for the\ntimelock T as well. In Lightning's case, with 1% channel_reserve_satoshis\naround, we arrive at T = 316, which is much longer than the current default\nof 144.\n\n\n>\n> So it looks to me that scorched-earth is a possible mitigation against\n> this attack.\n>\n\nI don't follow this. We show that a reasonable value of fees and timelock\nare enough to avoid the attack. Why scorch the earth?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200702/acae8c36/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-02T16:06:04",
                "message_text_only": "Good morning Tejaswi,\n\n> > So it looks to me that scorched-earth is a possible mitigation against this attack.\n>\n> I don't follow this. We show that a reasonable value of fees and timelock are enough to avoid the attack. Why scorch the earth?\n\nBecause your model only considers that a block might have only 0 or 1 transactions, and there is no such thing as a mempool containing alternative, fee-paying transactions that the miner could include *instead*.\n\nIn reality, what a miner can earn from adding Alice transaction is the *difference* between the Alice transaction fee and the transaction that *just* misses getting included in the block because of feerate.\n\nThus, the f will not, in fact, *quite* be the Alice fee, but instead less than that.\n\nIndeed if the Alice transaction fee is lower than the top 4 Mweight transactions in the mempool, the miner would be *losing* funds by including the Alice transaction.\n\nMy understanding is that we expect mempools to eventually never empty, as the block subsidy reduces over time, thus the payoff f for including the Alice transaction *instead of* some other transaction will be less than the Alice fee.\n\n\nThis effect also holds for Bob, but we can probably expect, all things being equal, that approximately the same value will be deducted from both the Bob bribe and Alice fee by the mempool effect.\nThus the ratio should really be (f - x) / (b - x), where x is the fee-of-transaction-that-just-misses-the-block.\nAt fee spikes, this x will go higher, and thus (f - x) / (b - x) will be far smaller than f / b and might even become negative, in which case the Alice transaction will not be confirmed even by myopic miners, because the Alice transaction will be below the top 4Mweight transactions in the mempool.\n\n\nSo it seems to me reasonable to use a *gradual* scorched earth policy, as it is not only resilient against this attack, but also to fee spikes.\nAlice starts at the 1% reserve, then for every block that goes by, bumps up the fee.\nThen Alice will settle at an (f - x) / (b - x) level that achieves the least weak miner that is known to run the myopic strategy.\n\n\nI believe this is also better for UX --- people already accept that during high fee spikes, they end up paying more for onchain activities.\nBut boosting up `to_self_delay` is bad because it makes honest unilateral closes take longer, and we already get frownie faces from users about this parameter.\nBy using a gradual scorched-earth strategy we can start at the reserve level, and if we are not under attack and there is no fee spike, do not lose anything other than the reserve funds of the thief (which is not ours, but is instead that of the thief).\nBut if an attack happens during a fee spike, then even though we retain our current default `to_self_delay` of 144, we still have the ability to gradually and automatically move to higher fee regions until our transaction confirms, and we have a good excuse for it to present to users: \"a fee spike was happening at the time, so you had to pay some extra miner fees\".\n\n\n----\n\nAnd since you and your paper openly discusses it anyway, I would like to reveal that the MAD-HTLC argument does not apply to *just* HTLCs.\nYou make recommendations about `to_self_delay` and `channel_reserve_satoshis`, which are not parameters of Lightning HTLCs (those are stuff like `cltv_delta` and `final_cltv`), but are channel parameters.\n\nThe MAD-HTLC argument applies just as well to channel mechanisms themselves, ***independently of*** any HTLCs they transport.\n\nThe MAD-HTLC paper has the following core argument:\n\n* We currently assume that currently-valid transactions will inevitably supersede alternate transactions that are valid at a later block height, simply because of the time advantage.\n  * However, the owner of a later-block-height transaction can bribe miners to defer confirmation of currently-valid transactions, until its later-block-height transaction is valid and confirms.\n\nThe above core argument is presented as applying to HTLCs.\n\nHowever, the same argument actually **also** applies to all current offchain multiparticipant cryptocurrency systems (i.e. \"channel mechanisms\").\n\n* Spilman\n* Poon-Dryja (what we currently use in Lightning)\n* Decker-Wattenhofer decrementing-`nSequence`\n* Decker-Russell-Osuntokun\n\nThe [Khabbazian-Nadahalli-Wattenhofer \"Timelocked Bribing\" paper](https://eprint.iacr.org/2020/774.pdf) mentions the use of revoked transactions in a Poon-Dryja mechanism, but seems to imply that the issue is with the HTLC instantiated inside the revoked transaction.\nBut note that the paper describes recommendations for the `to_self_delay` parameter and also analyzes the `channel_reserve_satoshis` parameter, which are parameters of the ***Poon-Dryja*** mechanism, and **not** of the HTLCs instantiated inside it.\n\nSo, to be very clear, the MAD-HTLC argument applies to all the above mechanisms *even if HTLCs are not used at all*.\nOr put another way, if you use a modern offchain updateable cryptocurrency system at all, you are still vulnerable to the MAD-HTLC argument even if you never instantiate HTLCs inside the offchain system.\n\nThus, other proposed systems that (could) use any of the channel mechanisms, but do ***not*** necessarily use HTLCs, such as CoinPools, channel factories, and statechains, are also vulnerable to the MAD-HTLC argument.\n\nIn particular, if the MAD-HTLC argument holds, we should take note that e.g. Lightning channels have to be at least as large as any HTLC they contain, and since the MAD-HTLC argument applies to the channel itself (in addition to any HTLCs they contain), the application of that argument implies greater loss, as it is the entire channel that is at risk, not just any HTLCs it might contain.\n\nSpilman\n=======\n\nA Spilman channel is a unidirectional single-funded channel.\n\nThe overall idea was presented pre-SegWit, and needed `OP_CHECKLOCKTIMEVERIFY` to be malleation-safe.\nI will describe here a modernized version that uses SegWit (and thus is malleation safe) instead.\n\nSuppose Bob wishes to make a Spilman channel to Alice.\nThe setup is as follows:\n\n* Bob creates but does *NOT* sign a funding transaction, paying out to a 2-of-2 between Alice and Bob, and hands over this txid and the output number to Alice.\n* Alice creates a timeout transaction, `nLockTime`d to a pre-agreed locktime, spending the above txout, and returning the funds to Bob, and signs this transaction and hands over the signature and tx to Bob.\n* Bob signs the funding transaction and broadcasts it.\n* Alice and Bob wait for deep confirmation of the funding tx.\n\nAt each payment from Bob to Alice, Bob signs a non-`nLockTime`d (or one with current blockheight) transaction that spends the funding txout and assigns more of the fund to Alice, then sends the signature and tx to Alice.\n\nAt any time, Alice can unilaterally close the channel using any of the signatures given by Bob.\nRationally, it will publish the one that gives it the most money, which is the latest such transaction, thus leading to the unidirectional nature of Spilman channels.\nAlice needs to perform this unilateral close far before the pre-agreed locktime.\n\nUnder the MAD-HTLC argument, Bob can bribe miners to ignore the Alice unilateral close transaction, and the initial timeout transaction by Bob gets confirmed even if within the channel mechanism Alice is supposed to own most or all of the funds.\n\nPoon-Dryja\n==========\n\nA Poon-Dryja channel is a modern two-participant bidirectional channel.\n\nThe core of security of Poon-Dryja involves \"revocable outputs\".\nA revocable output is an output that, when published onchain, is owned by one entity (the owner), but that entity may reveal a secret, the revocation secret, to another entity (the revoker).\nOnce that other entity knows the revocation secret, if the output is ever published onchain, it can revoke the output and claim its value.\n\nPoon-Dryja uses this building block to implement an updateable state.\nAll states are represented by commitment transactions that have revocable outputs.\nIn order to advance to a new state, the revocable outputs of previous states are revoked by exchanging revocation secrets.\nThus, the security of Poon-Dryja is dependent on the correct operation of revocation.\n\nRevocable outputs are implemented by imposing a relative locktime on the owner of the output, and requiring knowledge of two secrets from the revoker.\n\nThus, a revocable output has two branches:\n\n* Revocation branch: with the revoker privkey and knowledge of a revocaation secret, the revoker can claim the fund immediately.\n* Claim branch: with the owner privkey and a relative locktime, the owner can claim the fund after a pre-agreed number of blocks (`to_self_delay` in Lightning) since the output is confirmed onchain.\n\nUnder the MAD-HTLC argument, the owner of the revoked output can bribe miners to ignore attempts by the revoker to claim the funds until the claim branch is valid and confirmable.\nThus, a thief can publish old state, then apply the MAD-HTLC argument to get miners to ignore the revoker of the old state.\n\nDecker-Wattenhofer decrementing-`nSequence`\n===========================================\n\nDecker-Wattenhofer (\"Duplex Micropayment Channels\") is a modern multi-participant (N >= 2) offchain updateable cryptocurrency mechanism.\n\nDecker-Wattenhofer chains together two different mechanisms, embedding them one inside the other, in order to balance the tradeoffs of one with the tradeoffs of the other.\n\n* One or more decrementing-`nSequence` mechanisms, chained one inside the other.\n* Two (\"duplex\") unidirectional Spilman variants, using a relative locktime instead of an absolute locktime, one in both directions of the channel, inside the innermost decrementing-`nSequence` mechanism.\n\nThe decrementing-`nSequence` mechanisms by themselves are multiparticipant (N >= 2), and if we focus only on having one or more of these mechanisms chained together, we can consider Decker-Wattenhofer as multiparticipant.\n\nIn the decrementing-`nSequence` mechanism, there is a kickoff transaction which spends from the n-of-n funding outpoint, and sends it to yet another n-of-n output between the participants.\nThen, the second n-of-n is spent by a transaction with a relative-locktime `nSequence` transaction, which then distributes the money among various participants.\n\nWhen a new state is created, the participants create and sign a new relative-locktime `nSequence` transaction spending the kickoff n-of-n outpoint.\nThe new state transaction has a lower `nSequence` than the most previous state transaction, hence decrementing-`nSequence`.\nOnce the latest state transaction has a 0-block relative locktime, a newer state can no longer be added to the mechanism.\n\nThe kickoff n-of-n outpoint thus has multiple branches, one for each created state.\nThe most recent state is assumed to supersede previous states, because it has the smallest relative locktime among all states.\n\nUnder the MAD-HTLC argument, a participant which prefers an older state can bribe miners to defer confirmation of all more recent states.\nThus, that participant can publish the kickoff and bribe miners to defer more recent states until its preferred state is confirmable onchain.\n\nDecker-Russell-Osuntokun\n========================\n\nDecker-Russell-Osuntokun (\"eltoo\") is a futuristic multiparticipant (N >= 2) offchain updateable cryptocurrency system.\n\nDecker-Russell-Osuntokun uses a proposed new `SIGHASH_NOINPUT` flag, which does not commit to the specific output being spent, allowing a signature that signs using `SIGHASH_NOINPUT` to be used to spend a different transaction outpoint, as long as the same pubkey is used for that outpoint.\n\nAs is typical for channel mechanisms, a funding outpoint is created, which is an n-of-n of all participants.\nThe funding outpoint is spent by an update transaction with a single output, which has the following branches:\n\n* Update branch: can be spent by the same n-of-n pubkeys as the funding outpoint, as long as the spending transaction has a higher `nLockTime` than the update transaction.\n* State branch: can be spent by a different n-of-n pubkeys from the same participants, after a relative locktime.\n  * Each update transaction has its own unique set of n-of-n pubkeys for the state branch, given by the same participant set.\n\nOf note is that the `nLockTime` used in Decker-Russell-Osuntokun are always past `nLockTime`s, so that the update branch is always confirmable at the current tip, from now until forever.\nOnly the state branch has an actual timelock that could prevent immediate confirmation of a transaction spending that branch.\n\nUpdate transactions (awesomely mis)use `nLockTime` as a sequence number; the first update transaction has the lowest `nLockTime`, then each succeeding update transaction has a higher `nLockTime`, until they reach the present time.\n\nUpdate transactions are signed with `SIGHASH_NOINPUT`.\nThis allows the update transaction to not only spend the funding outpoint itself, but also to spend any previous update transaction.\n\nThus, if an old update transaction is published onchain, its output can be re-spent by any newer update transaction before the state transaction for that update can come into play.\nAny other participant who notices this event can simply publish the newest update transaction it knows, as that would supersede the state transaction, which can only be confirmed after a time delay.\n\nUnder the MAD-HTLC argument, a participant who prefers an older state can publish the update transaction for the older state, then bribe miners to defer confirmation of newer update transactions, until the state transaction for that update transaction can be confirmed.\n\nConclusion\n==========\n\nAll the above mechanisms use a timelock, and implicitly have the assumption that \"a transaction, that can be confirmed now, supersedes any transaction that has a timelock that forces it to be confirmed later\".\n\nIt seems likely to me that even future mechanisms will use the same assumption as well.\n\nIn particular, many proposed mechanisms for non-federated sidechains often include some kind of delay between when a sidechain coin is burned and the corresponding mainchain coin is released (i.e. side-to-main peg).\nOften, this delay exists in order to allow showing of a counterproof that the supposed side-to-main transfer did not actually exist in the sidechain (or was later reorged out, or whatever).\nIt seems to me that the MAD-HTLC argument would also apply to such mechanisms (if anyone still wants to go push sidechains, anyway).\n\nThus, we really need to carefully investigate the MAD-HTLC argument.\n\nMy current analysis suggests that in practice, the MAD-HTLC argument does not apply at all (else I would not be revealing that all channel mechanisms are broken **if** the MAD-HTLC argument *does* apply), since the myopic strategy seems to be pretty much inevitably dominant at stable states.\nBut it would still be best to investigate further until we are fully convinced that the MAD-HTLC argument (\"'earlier supersedes later' might be falsified by bribery\") does not apply.\n\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-07-03T09:43:37",
                "message_text_only": "On Thu, Jul 2, 2020 at 6:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> At fee spikes, this x will go higher, and thus (f - x) / (b - x) will be\n> far smaller than f / b and might even become negative, in which case the\n> Alice transaction will not be confirmed even by myopic miners, because the\n> Alice transaction will be below the top 4Mweight transactions in the\n> mempool.\n>\n\nI agree. The MAD-HTLC authors actually keep the base fee in their\ncalculations, and we deliberately decided to ignore this. We believe that\nthis base fee to be much lower than the typical 1% channel balance, and it\nactually doesn't change any of our results. This was brushed under the\n\"without loss of generality\" rug. I admit that we should have made this\nclear in our Assumptions section though. Point taken.\n\n\n> But if an attack happens during a fee spike, then even though we retain\n> our current default `to_self_delay` of 144, we still have the ability to\n> gradually and automatically move to higher fee regions until our\n> transaction confirms, and we have a good excuse for it to present to users:\n> \"a fee spike was happening at the time, so you had to pay some extra miner\n> fees\".\n>\n\nAgree on the UX. There is a tradeoff between the timelocked value of the\nchannel balance to Alice during benign vs malicious abandonment by Bob. In\nyour opinion, increasing the fees beyond 1% (and thereby cutting into\nAlice's share itself) is a slightly better tradeoff than increasing\nto_self_delay.\n\n\n> And since you and your paper openly discusses it anyway, I would like to\n> reveal that the MAD-HTLC argument does not apply to *just* HTLCs.\n>\n\nWe know. Maybe we should have made it clear in the paper that when we use\nthe Poon-Dryja channel construction, we use the idea that the knowledge of\nthe preimage of a hash is equivalent to knowing the private key of the\nrevocation public key. In fact, this is how the Poon-Dryja construction is\nexplained in McCorry's Ph.D thesis\n<https://nms.kcl.ac.uk/patrick.mccorry/thesis.pdf>, and IMHO is easier to\nunderstand than the original description in the Poon-Dryja paper (or Bolt\n#3, for that matter).\n\nYou could further argue that the hashlock is an incidental artefact, and\nour paper mostly refers to timelocked transactions. And the rest of your\nemail describes applications of timelocked (and obviously presigned)\ntransactions, which are all vulnerable to the same bribing attack.\nAdditionally, the Wattehnofer in our paper is the same Wattenhofer from the\nDuplex Channel paper.\n\nMy current analysis suggests that in practice, the MAD-HTLC argument does\n> not apply at all (else I would not be revealing that all channel mechanisms\n> are broken **if** the MAD-HTLC argument *does* apply), since the myopic\n> strategy seems to be pretty much inevitably dominant at stable states.\n>\n\nWe agree.\n\n\n> But it would still be best to investigate further until we are fully\n> convinced that the MAD-HTLC argument (\"'earlier supersedes later' might be\n> falsified by bribery\") does not apply.\n>\n\nI think this is the analysis our paper does, and perhaps it's our mistake\nthat we do not set the context better. We only mention (and propose fixes\nfor) Poon-Dryja channel construction, and Tier Nolan's Atomic Swap\nconstruction.\n\nWe could have addressed Spilman's one-way channels or Decker-Wattenhofer\nduplex channels, but that would have been pointless as they were never\ngoing to make it into production after Poon-Dryja and subsequently, Eltoo\nwere proposed. But not addressing Eltoo in the paper is an omission that I\nam a bit upset about. We additionally do not address more sophisticated\natomic swaps from Somsen or Fournier. Nor do we address Kanzure's vault\nproposal. In fact, one rule of thumb might be that wherever watchtowers are\nrequired, a timelocked bribe might be possible.\n\nAnd again, thanks for the detailed analysis.\n\nOn Thu, Jul 2, 2020 at 6:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Tejaswi,\n>\n> > > So it looks to me that scorched-earth is a possible mitigation against\n> this attack.\n> >\n> > I don't follow this. We show that a reasonable value of fees and\n> timelock are enough to avoid the attack. Why scorch the earth?\n>\n> Because your model only considers that a block might have only 0 or 1\n> transactions, and there is no such thing as a mempool containing\n> alternative, fee-paying transactions that the miner could include *instead*.\n>\n> In reality, what a miner can earn from adding Alice transaction is the\n> *difference* between the Alice transaction fee and the transaction that\n> *just* misses getting included in the block because of feerate.\n>\n> Thus, the f will not, in fact, *quite* be the Alice fee, but instead less\n> than that.\n>\n> Indeed if the Alice transaction fee is lower than the top 4 Mweight\n> transactions in the mempool, the miner would be *losing* funds by including\n> the Alice transaction.\n>\n> My understanding is that we expect mempools to eventually never empty, as\n> the block subsidy reduces over time, thus the payoff f for including the\n> Alice transaction *instead of* some other transaction will be less than the\n> Alice fee.\n>\n>\n> This effect also holds for Bob, but we can probably expect, all things\n> being equal, that approximately the same value will be deducted from both\n> the Bob bribe and Alice fee by the mempool effect.\n> Thus the ratio should really be (f - x) / (b - x), where x is the\n> fee-of-transaction-that-just-misses-the-block.\n> At fee spikes, this x will go higher, and thus (f - x) / (b - x) will be\n> far smaller than f / b and might even become negative, in which case the\n> Alice transaction will not be confirmed even by myopic miners, because the\n> Alice transaction will be below the top 4Mweight transactions in the\n> mempool.\n>\n>\n> So it seems to me reasonable to use a *gradual* scorched earth policy, as\n> it is not only resilient against this attack, but also to fee spikes.\n> Alice starts at the 1% reserve, then for every block that goes by, bumps\n> up the fee.\n> Then Alice will settle at an (f - x) / (b - x) level that achieves the\n> least weak miner that is known to run the myopic strategy.\n>\n>\n> I believe this is also better for UX --- people already accept that during\n> high fee spikes, they end up paying more for onchain activities.\n> But boosting up `to_self_delay` is bad because it makes honest unilateral\n> closes take longer, and we already get frownie faces from users about this\n> parameter.\n> By using a gradual scorched-earth strategy we can start at the reserve\n> level, and if we are not under attack and there is no fee spike, do not\n> lose anything other than the reserve funds of the thief (which is not ours,\n> but is instead that of the thief).\n> But if an attack happens during a fee spike, then even though we retain\n> our current default `to_self_delay` of 144, we still have the ability to\n> gradually and automatically move to higher fee regions until our\n> transaction confirms, and we have a good excuse for it to present to users:\n> \"a fee spike was happening at the time, so you had to pay some extra miner\n> fees\".\n>\n>\n> ----\n>\n> And since you and your paper openly discusses it anyway, I would like to\n> reveal that the MAD-HTLC argument does not apply to *just* HTLCs.\n> You make recommendations about `to_self_delay` and\n> `channel_reserve_satoshis`, which are not parameters of Lightning HTLCs\n> (those are stuff like `cltv_delta` and `final_cltv`), but are channel\n> parameters.\n>\n> The MAD-HTLC argument applies just as well to channel mechanisms\n> themselves, ***independently of*** any HTLCs they transport.\n>\n> The MAD-HTLC paper has the following core argument:\n>\n> * We currently assume that currently-valid transactions will inevitably\n> supersede alternate transactions that are valid at a later block height,\n> simply because of the time advantage.\n>   * However, the owner of a later-block-height transaction can bribe\n> miners to defer confirmation of currently-valid transactions, until its\n> later-block-height transaction is valid and confirms.\n>\n> The above core argument is presented as applying to HTLCs.\n>\n> However, the same argument actually **also** applies to all current\n> offchain multiparticipant cryptocurrency systems (i.e. \"channel\n> mechanisms\").\n>\n> * Spilman\n> * Poon-Dryja (what we currently use in Lightning)\n> * Decker-Wattenhofer decrementing-`nSequence`\n> * Decker-Russell-Osuntokun\n>\n> The [Khabbazian-Nadahalli-Wattenhofer \"Timelocked Bribing\" paper](\n> https://eprint.iacr.org/2020/774.pdf) mentions the use of revoked\n> transactions in a Poon-Dryja mechanism, but seems to imply that the issue\n> is with the HTLC instantiated inside the revoked transaction.\n> But note that the paper describes recommendations for the `to_self_delay`\n> parameter and also analyzes the `channel_reserve_satoshis` parameter, which\n> are parameters of the ***Poon-Dryja*** mechanism, and **not** of the HTLCs\n> instantiated inside it.\n>\n> So, to be very clear, the MAD-HTLC argument applies to all the above\n> mechanisms *even if HTLCs are not used at all*.\n> Or put another way, if you use a modern offchain updateable cryptocurrency\n> system at all, you are still vulnerable to the MAD-HTLC argument even if\n> you never instantiate HTLCs inside the offchain system.\n>\n> Thus, other proposed systems that (could) use any of the channel\n> mechanisms, but do ***not*** necessarily use HTLCs, such as CoinPools,\n> channel factories, and statechains, are also vulnerable to the MAD-HTLC\n> argument.\n>\n> In particular, if the MAD-HTLC argument holds, we should take note that\n> e.g. Lightning channels have to be at least as large as any HTLC they\n> contain, and since the MAD-HTLC argument applies to the channel itself (in\n> addition to any HTLCs they contain), the application of that argument\n> implies greater loss, as it is the entire channel that is at risk, not just\n> any HTLCs it might contain.\n>\n> Spilman\n> =======\n>\n> A Spilman channel is a unidirectional single-funded channel.\n>\n> The overall idea was presented pre-SegWit, and needed\n> `OP_CHECKLOCKTIMEVERIFY` to be malleation-safe.\n> I will describe here a modernized version that uses SegWit (and thus is\n> malleation safe) instead.\n>\n> Suppose Bob wishes to make a Spilman channel to Alice.\n> The setup is as follows:\n>\n> * Bob creates but does *NOT* sign a funding transaction, paying out to a\n> 2-of-2 between Alice and Bob, and hands over this txid and the output\n> number to Alice.\n> * Alice creates a timeout transaction, `nLockTime`d to a pre-agreed\n> locktime, spending the above txout, and returning the funds to Bob, and\n> signs this transaction and hands over the signature and tx to Bob.\n> * Bob signs the funding transaction and broadcasts it.\n> * Alice and Bob wait for deep confirmation of the funding tx.\n>\n> At each payment from Bob to Alice, Bob signs a non-`nLockTime`d (or one\n> with current blockheight) transaction that spends the funding txout and\n> assigns more of the fund to Alice, then sends the signature and tx to Alice.\n>\n> At any time, Alice can unilaterally close the channel using any of the\n> signatures given by Bob.\n> Rationally, it will publish the one that gives it the most money, which is\n> the latest such transaction, thus leading to the unidirectional nature of\n> Spilman channels.\n> Alice needs to perform this unilateral close far before the pre-agreed\n> locktime.\n>\n> Under the MAD-HTLC argument, Bob can bribe miners to ignore the Alice\n> unilateral close transaction, and the initial timeout transaction by Bob\n> gets confirmed even if within the channel mechanism Alice is supposed to\n> own most or all of the funds.\n>\n> Poon-Dryja\n> ==========\n>\n> A Poon-Dryja channel is a modern two-participant bidirectional channel.\n>\n> The core of security of Poon-Dryja involves \"revocable outputs\".\n> A revocable output is an output that, when published onchain, is owned by\n> one entity (the owner), but that entity may reveal a secret, the revocation\n> secret, to another entity (the revoker).\n> Once that other entity knows the revocation secret, if the output is ever\n> published onchain, it can revoke the output and claim its value.\n>\n> Poon-Dryja uses this building block to implement an updateable state.\n> All states are represented by commitment transactions that have revocable\n> outputs.\n> In order to advance to a new state, the revocable outputs of previous\n> states are revoked by exchanging revocation secrets.\n> Thus, the security of Poon-Dryja is dependent on the correct operation of\n> revocation.\n>\n> Revocable outputs are implemented by imposing a relative locktime on the\n> owner of the output, and requiring knowledge of two secrets from the\n> revoker.\n>\n> Thus, a revocable output has two branches:\n>\n> * Revocation branch: with the revoker privkey and knowledge of a\n> revocaation secret, the revoker can claim the fund immediately.\n> * Claim branch: with the owner privkey and a relative locktime, the owner\n> can claim the fund after a pre-agreed number of blocks (`to_self_delay` in\n> Lightning) since the output is confirmed onchain.\n>\n> Under the MAD-HTLC argument, the owner of the revoked output can bribe\n> miners to ignore attempts by the revoker to claim the funds until the claim\n> branch is valid and confirmable.\n> Thus, a thief can publish old state, then apply the MAD-HTLC argument to\n> get miners to ignore the revoker of the old state.\n>\n> Decker-Wattenhofer decrementing-`nSequence`\n> ===========================================\n>\n> Decker-Wattenhofer (\"Duplex Micropayment Channels\") is a modern\n> multi-participant (N >= 2) offchain updateable cryptocurrency mechanism.\n>\n> Decker-Wattenhofer chains together two different mechanisms, embedding\n> them one inside the other, in order to balance the tradeoffs of one with\n> the tradeoffs of the other.\n>\n> * One or more decrementing-`nSequence` mechanisms, chained one inside the\n> other.\n> * Two (\"duplex\") unidirectional Spilman variants, using a relative\n> locktime instead of an absolute locktime, one in both directions of the\n> channel, inside the innermost decrementing-`nSequence` mechanism.\n>\n> The decrementing-`nSequence` mechanisms by themselves are multiparticipant\n> (N >= 2), and if we focus only on having one or more of these mechanisms\n> chained together, we can consider Decker-Wattenhofer as multiparticipant.\n>\n> In the decrementing-`nSequence` mechanism, there is a kickoff transaction\n> which spends from the n-of-n funding outpoint, and sends it to yet another\n> n-of-n output between the participants.\n> Then, the second n-of-n is spent by a transaction with a relative-locktime\n> `nSequence` transaction, which then distributes the money among various\n> participants.\n>\n> When a new state is created, the participants create and sign a new\n> relative-locktime `nSequence` transaction spending the kickoff n-of-n\n> outpoint.\n> The new state transaction has a lower `nSequence` than the most previous\n> state transaction, hence decrementing-`nSequence`.\n> Once the latest state transaction has a 0-block relative locktime, a newer\n> state can no longer be added to the mechanism.\n>\n> The kickoff n-of-n outpoint thus has multiple branches, one for each\n> created state.\n> The most recent state is assumed to supersede previous states, because it\n> has the smallest relative locktime among all states.\n>\n> Under the MAD-HTLC argument, a participant which prefers an older state\n> can bribe miners to defer confirmation of all more recent states.\n> Thus, that participant can publish the kickoff and bribe miners to defer\n> more recent states until its preferred state is confirmable onchain.\n>\n> Decker-Russell-Osuntokun\n> ========================\n>\n> Decker-Russell-Osuntokun (\"eltoo\") is a futuristic multiparticipant (N >=\n> 2) offchain updateable cryptocurrency system.\n>\n> Decker-Russell-Osuntokun uses a proposed new `SIGHASH_NOINPUT` flag, which\n> does not commit to the specific output being spent, allowing a signature\n> that signs using `SIGHASH_NOINPUT` to be used to spend a different\n> transaction outpoint, as long as the same pubkey is used for that outpoint.\n>\n> As is typical for channel mechanisms, a funding outpoint is created, which\n> is an n-of-n of all participants.\n> The funding outpoint is spent by an update transaction with a single\n> output, which has the following branches:\n>\n> * Update branch: can be spent by the same n-of-n pubkeys as the funding\n> outpoint, as long as the spending transaction has a higher `nLockTime` than\n> the update transaction.\n> * State branch: can be spent by a different n-of-n pubkeys from the same\n> participants, after a relative locktime.\n>   * Each update transaction has its own unique set of n-of-n pubkeys for\n> the state branch, given by the same participant set.\n>\n> Of note is that the `nLockTime` used in Decker-Russell-Osuntokun are\n> always past `nLockTime`s, so that the update branch is always confirmable\n> at the current tip, from now until forever.\n> Only the state branch has an actual timelock that could prevent immediate\n> confirmation of a transaction spending that branch.\n>\n> Update transactions (awesomely mis)use `nLockTime` as a sequence number;\n> the first update transaction has the lowest `nLockTime`, then each\n> succeeding update transaction has a higher `nLockTime`, until they reach\n> the present time.\n>\n> Update transactions are signed with `SIGHASH_NOINPUT`.\n> This allows the update transaction to not only spend the funding outpoint\n> itself, but also to spend any previous update transaction.\n>\n> Thus, if an old update transaction is published onchain, its output can be\n> re-spent by any newer update transaction before the state transaction for\n> that update can come into play.\n> Any other participant who notices this event can simply publish the newest\n> update transaction it knows, as that would supersede the state transaction,\n> which can only be confirmed after a time delay.\n>\n> Under the MAD-HTLC argument, a participant who prefers an older state can\n> publish the update transaction for the older state, then bribe miners to\n> defer confirmation of newer update transactions, until the state\n> transaction for that update transaction can be confirmed.\n>\n> Conclusion\n> ==========\n>\n> All the above mechanisms use a timelock, and implicitly have the\n> assumption that \"a transaction, that can be confirmed now, supersedes any\n> transaction that has a timelock that forces it to be confirmed later\".\n>\n> It seems likely to me that even future mechanisms will use the same\n> assumption as well.\n>\n> In particular, many proposed mechanisms for non-federated sidechains often\n> include some kind of delay between when a sidechain coin is burned and the\n> corresponding mainchain coin is released (i.e. side-to-main peg).\n> Often, this delay exists in order to allow showing of a counterproof that\n> the supposed side-to-main transfer did not actually exist in the sidechain\n> (or was later reorged out, or whatever).\n> It seems to me that the MAD-HTLC argument would also apply to such\n> mechanisms (if anyone still wants to go push sidechains, anyway).\n>\n> Thus, we really need to carefully investigate the MAD-HTLC argument.\n>\n> My current analysis suggests that in practice, the MAD-HTLC argument does\n> not apply at all (else I would not be revealing that all channel mechanisms\n> are broken **if** the MAD-HTLC argument *does* apply), since the myopic\n> strategy seems to be pretty much inevitably dominant at stable states.\n> But it would still be best to investigate further until we are fully\n> convinced that the MAD-HTLC argument (\"'earlier supersedes later' might be\n> falsified by bribery\") does not apply.\n>\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200703/26c3b0e4/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-03T10:16:55",
                "message_text_only": "Good morning Tejaswi,\n\n\n\n> > But if an attack happens during a fee spike, then even though we retain our current default `to_self_delay` of 144, we still have the ability to gradually and automatically move to higher fee regions until our transaction confirms, and we have a good excuse for it to present to users: \"a fee spike was happening at the time, so you had to pay some extra miner fees\".\n>\n> Agree on the UX. There is a tradeoff between the timelocked value of the channel balance to Alice during benign vs malicious abandonment by Bob. In your opinion, increasing the fees beyond 1% (and thereby cutting into Alice's share itself) is a slightly better tradeoff than increasing to_self_delay.\u00a0\n\nCurrently, we say `to_self_delay` is a parameter of how long you can be offline, and is imposed on your counterparty (so its effect on you is to allow the counterparty to safely be offline for that long).\nThis explanation seems palatable to users; they understand that it is the counterparty which is asking this of them, and that they ask a similar number of their counterparty, which is also their own protection.\n\nOn the other hand, we do not really expect to get beyond 1% unless we are under attack, *or* the fee spikes are really, really bad.\nSo this seems a practical tradeoff for us over in Lightning-land.\n\n\n> > And since you and your paper openly discusses it anyway, I would like to reveal that the MAD-HTLC argument does not apply to *just* HTLCs.\n>\n> We know. Maybe we should have made it clear in the paper that when we use the Poon-Dryja channel construction, we use the idea that the knowledge of the preimage of a hash is equivalent to knowing the private key of the revocation public key. In fact, this is how the Poon-Dryja construction is explained in McCorry's Ph.D thesis, and IMHO is easier to understand than the original description in the Poon-Dryja paper (or Bolt #3, for that matter).\u00a0\n\nYes, I realized it a little after reading MAD-HTLC that it applied to all the other known channel mechanisms as well, not just HTLCs, and decided to investigate this topic further, and have been circumspect regarding this.\n\n> You could further argue that the hashlock\u00a0is an incidental artefact, and our paper mostly refers to timelocked transactions. And the rest of your email describes applications of timelocked (and obviously presigned) transactions, which are all vulnerable to the same bribing attack. Additionally, the Wattehnofer in our paper is the same Wattenhofer from the Duplex Channel paper.\n\nYes, I agree that the hashlock is an incidental artefact.\n\nWhat MAD-HTLC questions is our assumption that a valid transaction with an earlier locktime supersedes a valid transaction spending the same txout with a later locktime.\nWhether it involves presigned transactions or hashlocks are incidental artefacts.\nSo for example, a SCRIPT `OP_IF <A> OP_ELSE <1 day> OP_CHECKSEQUENCEVERIFY OP_DROP <B> OP_ENDIF OP_CHECKSIG` would also be vulnerable to the MAD-HTLC argument.\n\n(Indeed, BOLT spec uses something very much like that script, now that I look at it again; in our case the `<A>` is a combination of keys from both parties, that cannot be signed with unless one party knows both sub-keys.)\n\n>\n> > My current analysis suggests that in practice, the MAD-HTLC argument does not apply at all (else I would not be revealing that all channel mechanisms are broken **if** the MAD-HTLC argument *does* apply), since the myopic strategy seems to be pretty much inevitably dominant at stable states.\n>\n> We agree.\u00a0\n> \u00a0\n>\n> > But it would still be best to investigate further until we are fully convinced that the MAD-HTLC argument (\"'earlier supersedes later' might be falsified by bribery\") does not apply.\n>\n> I think this is the analysis our paper does, and perhaps it's our mistake that we do not set the context better. We only mention (and propose fixes for) Poon-Dryja channel construction, and Tier Nolan's Atomic Swap construction.\u00a0\n>\n> We could have addressed Spilman's one-way channels or Decker-Wattenhofer duplex channels, but that would have been pointless as they were never going to make it into production after Poon-Dryja and subsequently, Eltoo were proposed.\n\nI suggested that, until `SIGHASH_ANYPREVOUT` gets enabled, the Decker-Wattenhofer construction (removing the duplex Spilman-like channels at the end and leaving just the decrementing-`nSequence` constructions) could be used for Ruben Somsen StateChains, so you might not want to dismiss that so readily.\n\nThe decrementing-`nSequence` mechanisms have the advantage that it does not require a punishment/revocation branch, similar to Decker-Russell-Osuntokun \"eltoo\", and thus would work just as well to implement statechains, at least until all the debates around `SIGHASH_ANYPREVOUT` settle and it gets deployed.\n\nSimilarly, the proposed CoinPool as well could be implemented using Decker-Wattenhofer, assuming  it gets any details or support behind it sufficiently to push it before `SIGHASH_ANYPREVOUT` gets deployed.\n\n> But not addressing Eltoo in the paper is an omission that I am a bit upset about. We additionally do not address more sophisticated atomic swaps from Somsen or Fournier. Nor do we address Kanzure's vault proposal. In fact, one rule of thumb might be that wherever watchtowers are required, a timelocked bribe might be possible.\u00a0\n\nI think a better heuristic is that, if the logic of the construction assumes \"transaction with earlier locktime supersedes transaction with later locktime\", then it is timelocked-bribery-vulnerable.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-07-03T10:44:59",
                "message_text_only": "On Fri, Jul 3, 2020 at 12:17 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n>\n> > In fact, one rule of thumb might be that wherever watchtowers are\n> required, a timelocked bribe might be possible.\n>\n> I think a better heuristic is that, if the logic of the construction\n> assumes \"transaction with earlier locktime supersedes transaction with\n> later locktime\", then it is timelocked-bribery-vulnerable.\n>\n\nThat's true by definition. Timelocked bribes are, well, going to be\npossible when there are timelocks. I was going more for an \"indirect clue\"\nthat wherever a watchtower is proposed, a timelocked bribe is possible.\nThis is entirely a pedantic point :-)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200703/13a76f16/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-03T12:38:37",
                "message_text_only": "Good morning Ittay,\n\n> Hi all,\n>\n> Itay from MAD-HTLC here. I feel like some details got lost along the way so please let me get these sorted out.\n>\n> 1. Myopic and non-myopic miners:\n> When we use the term\u00a0myopic\u00a0we mean a miner that optimizes transaction selection for the next block with respect only to the next block. The term\u00a0non-myopic\u00a0refers to a miner that optimizes transaction selection for the next block with respect to several future blocks. To accommodate for the stochastic\u00a0nature of block creation these optimizations are of the\u00a0expected revenue.\u00a0However,\u00a0neither of these mean that these miners choose to act in a way that reduces their expected revenue -- specifically, if from a\u00a0non-myopic's miner perspective including Alice's immediate transaction is better off than waiting for Bob's future transaction, then this is what they do.\n>\n> Consequently, saying that \"being myopic\" dominates \"being non-myopic\" is incorrect -- myopic is\u00a0included\u00a0in being non-myopic, thus cannot be better than it.\n\nThe term \"dominates\" here is a technical term in game theory.\n\nA strategy dominates over another strategy if, in a mixed environment, the first strategy always wins more points than the second strategy, no matter what proportion they may initially start in the mixed environment.\n\nFor example, in an environment of prisoner dilemma games, a tit-for-tat strategy dominates over the always-betray strategy, which dominates over always-cooperate strategy.\n\nThe above is the use of the term \"dominate\", and not that somehow one strategy \"contains\" the other.\nAlways-betray does not contain always-cooperate.\n\nIt is immaterial that the non-myopic \"contains\" myopic strategy as a sub-strategy.\nSometimes, overriding a sub-strategy can lead to worse outcomes and you are better off sticking to the sub-strategy rather than an extended strategy that sometimes overrides the sub-strategy\n\n(notice how mixed teams of computer+human are no longer dominant in chess, because computer chess AIs are now so sophisticated that on average, the human overriding the computer strategy often leads to worse outcomes than just following the computer; yet about a decade ago such mixed computer+human teams were dominant over pure-computer and pure-human teams; yet you could say the same, that the computer+human \"includes\" the pure-computer strategy, but nowadays does ***not*** dominate it).\n\nOr: worse is better.\n\n\nWhat matters is, if you make them compete in an environment, myopic strategies will consistently beat non-myopic strategies because the myopic miners will impose costs on the non-myopic miners.\n\n\n>\n> So, the next issue to address is estimation of how much of the hash rate is actually non-myopic. Currently that answer is simple -- probably 0. Bitcoin Core (97% of the blocks) doesn't offer these optimizations, and most likely other clients do not have these as well. But, we showed this is rather trivial to implement (150 LoC in Bitcoin Core), and theoretically can be included in Core's next version AFAIK. Moreover, any miner can simply apply our patch independently, achieving the same effect.\n>\n> Please note more elaborate optimizations are in miners' best interest, especially as mining incentives transition from block minting to fees -- the latter are becoming the main income source, and I believe less sophisticated miners will miss out substantially. You can check out Phil Daian's paper about front-running in Ethereum for example:\u00a0https://arxiv.org/abs/1904.05234\n\nYes, but again: myopic strategies dominate over non-myopic strategies, thus implementing non-myopic strategies is pointless, since they will lose revenue in an environment where even a single miner is myopic.\n\nIt is immaterial that it takes only 150 LoC to implement non-myopia: if it earns less money in an environment where even a minority of blocks are created by myopic miners (much less 97%), nobody will use the non-myopic strategy and they will remain at negligible near-0% hashrate.\n\nAs they say, \"you can't get to there from here\".\n\n\n> As common in game-theory papers, our analysis does assume\u00a0Common Knowledge\u00a0-- all participants know all other participants, their available strategies and utilities\u00a0(Tejaswi et al.'s paper makes the same assumption). As commented before, true, this is not always the case -- nodes might have different mempools, and some might not have applied the optimization patch and act myopically. Such miners are therefore \"resisting\" the attack -- as stated, by including Alice's transaction they ruin other miners' potential profit from Bob's high fee transaction.\n\nThe only additional assumption you are missing is that miners care about *themselves* and not about *all miners*.\n\nNon-myopia may earn more money for *all* miners if *all* miners use it, but if a *single* miner starts using myopic strategies in a non-myopic environment, they will earn more funds than their non-myopic competitors and thus dominate, shifting the percentages until almost all miners are using myopic strategies.\nThat they require less processing (\"keep it simple, sir\") is just gravy on top.\n\n\nThe only way for non-myopic miners to win is to form a cartel, and a miner cartel with >50% hashpower would be the end of Bitcoin anyway.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-04T20:58:57",
                "message_text_only": "Good morning Ittay,\n\n\n> The analysis in our MAD-HTLC paper shows that when all players are rational (i.e., make the best decisions), and have the greater strategy space (which is easy to achieve, 150 Loc), the subgame-perfect-equilibrium strategy (this is like Nash-equilibrium for dynamic games\u00a0https://en.wikipedia.org/wiki/Subgame_perfect_equilibrium) for even relatively-small fee is to support the attack. Putting it in game-theory terms -- strategy \"exclude-Alice-until-timeout-then-include-Bob\" results with higher utility than strategy \"include-Alice-Tx-now\" (and by definition, \"include-Alice-Tx-now\" does not dominante\u00a0 \"exclude-Alice-until-timeout-then-include-Bob\").\n\nIt may be helpful to think in terms of Prisoner Dilemma.\n\n\n               | cooperate | betray\n    -----------+-----------+---------\n    cooperate  | -1, -1    | 0, -3\n    -----------+-----------+---------\n    betray     | -3, 0     | -2, -2\n\n\"include-Alice-Tx-now\" imposes a greater cost on those playing \"exclude-Alice-until-timeout-then-include-Bob\" players, than the benefit that both miners play \"exclude-Alice-until-timeout-then-include-Bob\".\n\nBasically, \"cooperate\" == \"exclude-Alice-until-timeout-then-include-Bob\", \"betray\" == \"include-Alice-Tx-now\".\n\nOne way to get around this is to invoke Iterated Prisoner Dilemma, but that requires that miners can identify other miners and to be able to act accordingly to how those other miners have acted in the past.\nThe entire point of Bitcoin mining is to allow strong anonymity of miners (not that this commonly happens in practice, given the habit of putting identifying information in coinbases).\n\nAnother way would be to have a higher system that polices its constituents and ensures that every miner plays \"exclude-Alice-until-timeout-then-include-Bob\", and punishes \"include-Alice-Tx-now\".\nBut that would be equivalent to a centralized cartel, and would be the death of Bitcoin anyway, at which point, all Bitcoin tokens will be worthless.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stanga",
                "date": "2020-07-05T09:03:14",
                "message_text_only": "Hi ZmnSCPxj,\n\n1. If all miners are rational and non-myopic, they will support the attack.\nThey don't need to cooperate, it's not the end of Bitcoin, but they all\nhave to know everyone is rational and non-myopic. If you want to be secure\nin a situation like this then mad-htlc helps. Otherwise you can stick with\nhtlc. To be clear, assuming it away means assuming at least some miners are\naltruistic or suboptimal.\n\n2. I believe what Itay meant when he said myopic is included in non-myopic\nis that non-myopic will never choose a worse strategy than myopic. They\nboth have the same utility function, but the non-myopic has more freedom.\nSpecifically, if there are enough miners that are either irrational or\nmyopic, and the bribe is small, then the best non-myopic strategy and the\nbest myopic strategy is to not accept the bribe. (I think we're all in\nagreement on this one, it's just about terminology)\n\nBest,\nIttay\n\n\nOn Fri, Jul 3, 2020 at 3:38 PM ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Ittay,\n>\n> > Hi all,\n> >\n> > Itay from MAD-HTLC here. I feel like some details got lost along the way\n> so please let me get these sorted out.\n> >\n> > 1. Myopic and non-myopic miners:\n> > When we use the term myopic we mean a miner that optimizes transaction\n> selection for the next block with respect only to the next block. The\n> term non-myopic refers to a miner that optimizes transaction selection for\n> the next block with respect to several future blocks. To accommodate for\n> the stochastic nature of block creation these optimizations are of\n> the expected revenue. However, neither of these mean that these miners\n> choose to act in a way that reduces their expected revenue -- specifically,\n> if from a non-myopic's miner perspective including Alice's immediate\n> transaction is better off than waiting for Bob's future transaction, then\n> this is what they do.\n> >\n> > Consequently, saying that \"being myopic\" dominates \"being non-myopic\" is\n> incorrect -- myopic is included in being non-myopic, thus cannot be better\n> than it.\n>\n> The term \"dominates\" here is a technical term in game theory.\n>\n> A strategy dominates over another strategy if, in a mixed environment, the\n> first strategy always wins more points than the second strategy, no matter\n> what proportion they may initially start in the mixed environment.\n>\n> For example, in an environment of prisoner dilemma games, a tit-for-tat\n> strategy dominates over the always-betray strategy, which dominates over\n> always-cooperate strategy.\n>\n> The above is the use of the term \"dominate\", and not that somehow one\n> strategy \"contains\" the other.\n> Always-betray does not contain always-cooperate.\n>\n> It is immaterial that the non-myopic \"contains\" myopic strategy as a\n> sub-strategy.\n> Sometimes, overriding a sub-strategy can lead to worse outcomes and you\n> are better off sticking to the sub-strategy rather than an extended\n> strategy that sometimes overrides the sub-strategy\n>\n> (notice how mixed teams of computer+human are no longer dominant in chess,\n> because computer chess AIs are now so sophisticated that on average, the\n> human overriding the computer strategy often leads to worse outcomes than\n> just following the computer; yet about a decade ago such mixed\n> computer+human teams were dominant over pure-computer and pure-human teams;\n> yet you could say the same, that the computer+human \"includes\" the\n> pure-computer strategy, but nowadays does ***not*** dominate it).\n>\n> Or: worse is better.\n>\n>\n> What matters is, if you make them compete in an environment, myopic\n> strategies will consistently beat non-myopic strategies because the myopic\n> miners will impose costs on the non-myopic miners.\n>\n>\n> >\n> > So, the next issue to address is estimation of how much of the hash rate\n> is actually non-myopic. Currently that answer is simple -- probably 0.\n> Bitcoin Core (97% of the blocks) doesn't offer these optimizations, and\n> most likely other clients do not have these as well. But, we showed this is\n> rather trivial to implement (150 LoC in Bitcoin Core), and theoretically\n> can be included in Core's next version AFAIK. Moreover, any miner can\n> simply apply our patch independently, achieving the same effect.\n> >\n> > Please note more elaborate optimizations are in miners' best interest,\n> especially as mining incentives transition from block minting to fees --\n> the latter are becoming the main income source, and I believe less\n> sophisticated miners will miss out substantially. You can check out Phil\n> Daian's paper about front-running in Ethereum for example:\n> https://arxiv.org/abs/1904.05234\n>\n> Yes, but again: myopic strategies dominate over non-myopic strategies,\n> thus implementing non-myopic strategies is pointless, since they will lose\n> revenue in an environment where even a single miner is myopic.\n>\n> It is immaterial that it takes only 150 LoC to implement non-myopia: if it\n> earns less money in an environment where even a minority of blocks are\n> created by myopic miners (much less 97%), nobody will use the non-myopic\n> strategy and they will remain at negligible near-0% hashrate.\n>\n> As they say, \"you can't get to there from here\".\n>\n>\n> > As common in game-theory papers, our analysis does assume Common\n> Knowledge -- all participants know all other participants, their available\n> strategies and utilities (Tejaswi et al.'s paper makes the same\n> assumption). As commented before, true, this is not always the case --\n> nodes might have different mempools, and some might not have applied the\n> optimization patch and act myopically. Such miners are therefore\n> \"resisting\" the attack -- as stated, by including Alice's transaction they\n> ruin other miners' potential profit from Bob's high fee transaction.\n>\n> The only additional assumption you are missing is that miners care about\n> *themselves* and not about *all miners*.\n>\n> Non-myopia may earn more money for *all* miners if *all* miners use it,\n> but if a *single* miner starts using myopic strategies in a non-myopic\n> environment, they will earn more funds than their non-myopic competitors\n> and thus dominate, shifting the percentages until almost all miners are\n> using myopic strategies.\n> That they require less processing (\"keep it simple, sir\") is just gravy on\n> top.\n>\n>\n> The only way for non-myopic miners to win is to form a cartel, and a miner\n> cartel with >50% hashpower would be the end of Bitcoin anyway.\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200705/49df518d/attachment-0001.html>"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-07-06T11:13:47",
                "message_text_only": "On Fri, Jul 3, 2020 at 1:49 PM Itay Tsabary <sitay at campus.technion.ac.il>\nwrote:\n\n> Note the required token amount for the collateral contract is low and\n> independent of the required deposit tokens -- only a relatively small\n> incentive is required to make \"acting honestly\" Bob's preferred choice.\n> So, this is basically a negligible overhead, token-wise. As a downside, it\n> does create slightly larger transactions (another UTXO, etc.).\n>\n\nI read the MAD-HTLC paper and I think it actually doesn't get into the size\nof the collateral (v^{col}). I might have missed it though. Can you please\npoint me to the section in the paper where the amount is discussed?\n\nI assumed that v^{col} has to be at least the size of v^{dep}. Otherwise,\nBob can threaten Alice with an HTLC bribery attack, and Alice knows that\nBob has very little to lose. Bob *should* have the same amount to lose, to\nmake it work - no?\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200706/9218119e/attachment.html>"
            },
            {
                "author": "Tejaswi Nadahalli",
                "date": "2020-07-02T12:39:35",
                "message_text_only": "On Wed, Jul 1, 2020 at 6:58 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Another analysis, similar but a little off-tangent to yours, would be to\n> consider miners as a breeding group with various strategies, and see which\n> one is able to gain more utilons (with which it creates more miners) and\n> outbreed the other miners.\n>\n> This models the fact that miners can use their earnings to reinvest into\n> their mining operations and increase their mining hashrate, and the amount\n> they can reinvest is proportional to their earnings.\n> A miner that \"gives birth\" to a child miner with the same strategy is, in\n> the so-called \"real world\", simply a miner that has earned enough and\n> reinvested those earnings to double the hashrate of their business (which,\n> logically speaking, would use the same strategy throughout the entire\n> business).\n>\n> Let us start with a population of 4 miners, 3 of which follow the\n> non-myopic strategy, and the remaining following the myopic strategy.\n> Let us postulate that all miners have the same unit hashrate.\n> Thus, this starting population is 75% non-myopic, 25% myopic.\n>\n> If there exists a timelocked bribe, then if non-myopic miner is chosen at\n> a block, it will have to sacrifice the Alice fee minus whatever lesser\n> transaction fee it can replace in its block.\n> If the Alice transaction is successfully delayed until the Bob transaction\n> is valid, then the non-myopic miners can get the Bob transaction confirmed.\n>\n> However, even in the case that the Alice transaction is delayed, the\n> myopic miner still has its 25% chance --- equal to the 25% chance of the\n> three non-myopic miners --- to confirm the Bob transaction and earn the\n> increased bribe that Bob offers.\n>\n> Thus, the non-myopic miners can end up sacrificing fee earnings, and in\n> the end the myopic miner still has the 25% chance to get the Bob\n> transaction fee later when it becomes valid.\n> So the non-myopic miners do not impose any loss on myopic miners.\n>\n> On the other hand, if the non-myopic miners sacrificed their chances to\n> include the Alice transaction in the hope of getting the later 25% chance\n> to get the Bob higher-fee timelocked transaction, and then the myopic miner\n> gets the next block, the myopic miner gets the Alice transaction confirmed\n> and the 25% chance to get the Bob higher fee is lost by the non-myopic\n> miners.\n> Thus, the myopic miner is able to impose costs on their non-myopic\n> competitors.\n>\n> So even if by chance for the entire locktime, only the non-myopic miners\n> are selected, the myopic miner still retains its 25% chance of getting the\n> block at locktime + 1 and confirming and earning the bigger Bob fee.\n>\n> Thus, we expect that the myopic miner will earn more than 25% of subsidies\n> and fees than the non-myopic miners, in such a mixed environment.\n>\n\nThis is exactly our analysis, and is covered in section 2.5 of our paper.\nWe formalize the ideas a bit more, and are able to relate the values of\nAlice-fee, Bob-bribe, timelock, and miner's hashpower percentage. We go a\nbit further into #reckless territory as well - reducing the timelock value\nto super low values. That's in Algorithm #1 of our paper, and is a bit more\ninvolved.\n\n\n>\n> We can then consider that the myopic miner, being able to earn more, is\n> able to increase its progeny (i.e. expand its mining business and inspire\n> new miners to follow its strategy towards success) faster than the\n> non-myopic miners.\n>\n> We can thus conclude that the myopic miners will eventually dominate over\n> the breeding population and drive the non-myopic miners to near-extinction.\n>\n\nThis is an interesting direction that we chose to not look at. Like the\nMAD-HTLC authors, we assume a constant hash-rate distribution across time,\nwhich is obviously not a great assumption. It might work in the local\ncontext of an HTLC's timelock, but in our approach, we are also interested\nin *weak* miners, and finding them across 1000's of blocks might get tricky.\n\n\n> It is helpful to remember that rationality is about success *in the\n> universe you exist in*.\n> While miners may step back and consider that, ***if*** all of them were to\n> use non-myopic strategy, they would all earn more, the fact of the matter\n> is that each miner works for themselves, and themselves alone, in a highly\n> competitive environment.\n> Thus, even though they know *all of them* will benefit if they use the\n> non-myopic strategy, they cannot be sure, unless they are all perfectly\n> synchronized mind-clones of each other, that the other miners will rather\n> be selfish and mine for themselves, even if in the end every miner earns\n> less\n> The standard for success is to earn more *than your competitors*, not\n> ensure that *every* miner earns more.\n>\n> Fortunately, since miners are running a business, this competition leads\n> to better services to the the customers of the mining business, a known\n> phenomenon of the free market, yay free market greed is good.\n> The user Alice is a customer of the mining business.\n> Alice gets, as a side effect of this competitiveness of miners (which\n> leads to miners adopting myopic strategies in order to gain an edge over\n> non-myopic miners), improved security of their HTLCs without requiring\n> slashable fidelity bonds or such-like that MAD-HTLC proposes.\n>\n\nYes. And in the context of Lightning, both Alice and Bob need to have\nfidelity bonds, which triples the already bad channel-lockin cost.\n\n\n> Using this model, it seems to me that non-myopic miners can only maintain\n> hold over the blockchain if all miners agree to use non-myopic strategy.\n> This is basically all miners forming a cartel / monopoly, which we know is\n> detrimental to customers of the monopoly, and is the reason why we prefer\n> decentralization.\n>\n\nIf miners form a cartel and get to 51%, we are all doomed anyway.\n\nThanks for the detailed reply. And apologies for splitting my email into\ntwo parts.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200702/cddaaefc/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-04T21:05:34",
                "message_text_only": "Good morning Dave,\n\n\n> > > -   Inputs:\n> > >     -   Bob 1 BTC - HTLC amount\n> > >     -   Bob 1 BTC - Bob fidelity bond\n> > > -   Cases:\n> > >     -   Alice reveals hashlock at any time:\n> > >         -   1 BTC goes to Alice\n> > >         -   1 BTC goes to Bob (fidelity bond refund)\n> > >     -   Bob reveals bob-hashlock after time L:\n> > >         -   2 BTC goes to Bob (HTLC refund + fidelity bond refund)\n> > >     -   Bob cheated, anybody reveals both hashlock and bob-hashlock:\n> > >         -   2 BTC goes to miner\n> > >\n> > > [...]\n> >\n> > The cases you present are exactly how MAD-HTLC works. It comprises two\n> > contracts (UTXOs):\n> >\n> > -   Deposit (holding the intended HTLC tokens), with three redeem paths:\n> >     -   Alice (signature), with preimage \"A\", no timeout\n> >     -   Bob (signature), with preimage \"B\", timeout T\n> >     -   Any entity (miner), with both preimages \"A\" and \"B\", no timeout\n> > -   Collateral (the fidelity bond, doesn't have to be of the same amount)\n> >     -   Bob (signature), no preimage, timeout T\n> >     -   Any entity (miner), with both preimages \"A\" and \"B\", timeout T\n>\n> I'm not these are safe if your counterparty is a miner. Imagine Bob\n> offers Alice a MAD-HTLC. Alice knows the payment preimage (\"preimage\n> A\"). Bob knows the bond preimage (\"preimage B\") and he's the one making\n> the payment and offering the bond.\n>\n> After receiving the HTLC, Alice takes no action on it, so the timelock\n> expires. Bob publicly broadcasts the refund transaction with the bond\n> preimage. Unbeknownst to Bob, Alice is actually a miner and she uses her\n> pre-existing knowledge of the payment preimage plus her received\n> knowledge of the bond preimage to privately attempt mining a transaction\n> that pays her both the payment (\"deposit\") and the bond (\"collateral\").\n>\n> Assuming Alice is a non-majority miner, she isn't guaranteed to\n> succeed---her chance of success depends on her percentage of the network\n> hashrate and how much fee Bob paid to incentivize other miners to\n> confirm his refund transaction quickly. However, as long as Alice has a\n> non-trivial amount of hashrate, she will succeed some percentage of the\n> time in executing this type of attack. Any of her theft attempts that\n> fail will leave no public trace, perhaps lulling users into a false\n> sense of security.\n\n\nThis note seems to have gotten missed in discussion.\n\nAnother note is that from what I can tell, the preimages \"A\" and \"B\" can be provided by any miner.\n\nIf the fund value plus the collateral is large enough, it may incentivize competing miners to reorg the chain, redirecting the funds of the MAD-HTLC to themselves, rather than advance the blockchain state, at least until alternative transctions bump their fees up enough that the collateral + fund is matched.\n\nThis may not apply to Lightning at least if you do not go beyond the Wumbo limit, but *could* apply to e.g. SwapMarket, if it uses MAD-HTLCs.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "MAD-HTLC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Tejaswi Nadahalli",
                "Stanga"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 80282
        }
    },
    {
        "title": "[bitcoin-dev] Tool for checking a wallet's handling of reverted 0-conf transactions",
        "thread_messages": [
            {
                "author": "Oded Leiba",
                "date": "2020-07-02T13:51:18",
                "message_text_only": "As was disclosed today, several wallets have been found not to handle well\nthe scenario of reverted transactions at zero confirmations. This includes\nshowing an increased balance to the user without decreasing it when a\ntransaction is replaced and also preventing the user from being able to\nspend other valid coins.\n\nYou can test the behavior of your own wallet (either that you use or\ndevelop) and read more about it in this new tool:\n\nhttps://github.com/KZen-networks/big-spender\n\nOded\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200702/3d4df6d8/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Tool for checking a wallet's handling of reverted 0-conf transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Oded Leiba"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 676
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: BIP32 Path Templates",
        "thread_messages": [
            {
                "author": "Dmitry Petukhov",
                "date": "2020-07-02T16:28:39",
                "message_text_only": "I think there should be standard format to describe constraints for\nBIP32 paths.\n\nI present a BIP draft that specifies \"path templates\" for BIP32 paths:\n\nhttps://github.com/dgpv/bip32_template_parse_tplaplus_spec/blob/master/bip-path-templates.mediawiki\n\nMatching against these templates allow to easily discern 'valid'\npaths, that match the constraints, and 'invalid' paths, that exceed the\nconstraints. Extended motivation is given at the end of this message,\nand in the text of the BIP draft.\n\nA formal spec in TLA+ of a finite state machine implementing the parser\nfor the described format (and the matching operation) accompanies this\nBIP draft: https://github.com/dgpv/bip32_template_parse_tplaplus_spec\n\nThis formal spec can be used with TLC model checker and a helper script\nto generate thorough test data for implementations.\n\nOne (python) implementation of template parsing and matching already\nexists (linked in the BIP draft).\n\nExamples of the templates:\n\n\"m/[44,49,84]'/0'/0'/[0-1]/[0-50000]\" specifies a full template that\nmatches both external and internal chains of BIP44, BIP49 and BIP84\npaths, with a constraint that the address index cannot be larger than\n50000\n\n\"[0-2,33,123]/*\" specifies a partial template that matches non-hardened\nvalues 0, 1, 2, 33, 123 as first index, and any non-hardened value at\nsecond index\n\n\"*h/0\" specifies a partial template that matches any hardened index\nfollowed by any non-hardened index\n\n\nMotivation:\n\nBIP32 derivation path format is universal, and a number of schemes for\nderivation were proposed in BIP43 and other documents, such as BIPs\n44,45,49,84. The flexibility of the format allowed industry\nparticipants to implement custom derivation shemes that fit particular\npurposes, but not necessarily useful in general.\n\nUnrestricted derivation path usage might be unsafe in certain contexts.\nIn particular, when \"change\" outputs of a transaction are sent to the\naddresses derived via paths unknown to the sender, the sender might\nloose access to the whole change amount.\n\nA simplistic approach of hard-coding the checks for well-known paths\ninto software and firmware leads to reduced interoperability. Vendors\ncannot choose custom paths that are appropriate for their particular,\nnon-general-purpose applications, and are forced to shoehorn their\nsolutions into using well-known paths, or convince other vendors to\nsupport their custom paths. This approach scales poorly.\n\nA flexible approach proposed is to define a standard notation for\n\"BIP32 path templates\" that succintly describes the constraints to\nimpose on the derivation path.\n\nWide support for these path templates will increase interoperability\nand flexibility of solutions, and will allow vendors and individual\ndevelopers to easily define their own custom restrictions. This way,\nthey will be able to deal with the risks of accidental or malicious use\nof unrestricted derivation paths in a more flexible and precise manner.\n\nWell-known path templates can be pre-configured by default on devices\nand applications, but users can have an option to turn off the\ntemplates that are not relevant to their uses.\n\nHaving standardized format for custom path templates will enable a\ncommon approach to be developed to the enforcement of\napplication-specific path restrictions in devices and applications. One\nexample of such approach might be for devices to allow to install\napplication-specific profiles with path templates and possibly other\ncustom parameters. Care must be taken to prevent accidental\ninstallation of malicious or incorrect profile, though."
            },
            {
                "author": "David A. Harding",
                "date": "2020-07-03T14:39:45",
                "message_text_only": "On Thu, Jul 02, 2020 at 09:28:39PM +0500, Dmitry Petukhov via bitcoin-dev wrote:\n> I think there should be standard format to describe constraints for\n> BIP32 paths.\n> \n> I present a BIP draft that specifies \"path templates\" for BIP32 paths:\n> \n> https://github.com/dgpv/bip32_template_parse_tplaplus_spec/blob/master/bip-path-templates.mediawiki\n\nHi Dmitry,\n\nHow do path templates compare to key origin identification[1] in\noutput script descriptors?\n\nCould you maybe give a specfic example of how path templates might be\nused?  Are they for backups?  Multisig wallet coordination?  Managing\ndata between software transaction construction and hardware device\nsigning?\n\nThanks,\n\n-Dave\n\n[1] https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md#key-origin-identification\n    (See earlier in the doc for examples)\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200703/222eff96/attachment.sig>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-07-03T16:53:44",
                "message_text_only": "IIUC, key origin identification specify chains of addresses, with\nrelation to specific keys. As the name suggests, they are for\nidentidication.\n\nPath templates specify application-specific constraints for the\nderivation paths. They are for imposing restrictions.\n\nYou could use path templates for identification, too, and in fact the\n\"path\" part of the key origin identification would be a valid path\ntemplate. Path templates have potential to identify multiple chains\nof addresses though, and I cannot say how useful it can be, if at all.\n\nWhen a hardware wallet or some other type of autonomous signer signs a\ntransaction, there are two points where HD derivation can occur: 1) when\nsigning an input 2) when checking if the output is the change output\n\nThe second case is occurs more often, I think (determining actual\namount sent), but the first case can have uses, too -- when an\nautonomous signer can impose restrictions on derivation path based on\nthe identity of the user that request the signing, for example. \n\nIn both of these points an application-specific or usecase-specific\nsigning scheme might require that only certain whitelisted derivation\npaths are used (sending change to the known key, but using derivation\npath unknown to the sender allows an attacker to hold the change amount\nfor ransom, for example)\n\nAn autonomous signer might not be aware of the restrictions used in\nparticular scheme, because it might be developed by different vendor\nthan the implementor of the particular scheme. Or it might be difficult\nto update the firmware of autonomous signer when the checks of the\npath constraints are hard-coded in the program code. Having constraints\nspecified as data would allow to place them in configuration of the\nsigner.\n\nOne particular example of this being a problem is how hardware wallet\nvendors seem to be inclined to decide to just restrict the derivation\npaths allowed for the change addresses to the set of \"well-known\"\npaths.\n\nSuch restrictions, on one hand, break custom schemes used by\nvarious software solutions that rely on the ability of hardware wallet\nto sign custom paths, and on the other hand, such hardcoded restrictions\nmight happen to be too relaxed, if the set of \"well-known\" path grows,\nor the user or software vendor knows for sure that they won't use\naddresses past index 1000, for example.\n\nThe format for the path templates described in the presented BIP draft\naims to provide a building block for interoperability between various\nhardware and software vendors in regard to this particular task of\nspecifying derivation path restrictions.\n\nAdopting a common format for specifying restictions is a flexible\nalternative to everyone adopting a rigid set of \"well-known\" paths.\nSuch a set will inevitably grow, and those who really need custom\npaths and do not have resources to push for standardization of their\ncustom paths will be at a disadvantage.\n\nMy hope is that having a clear specification and (possibly, in the\nfuture) permissibly licensed quality implementations would make\nadopting such format easier for vendors.\n\n\u0412 Fri, 3 Jul 2020 10:39:45 -0400\n\"David A. Harding\" <dave at dtrt.org> wrote:\n\n> On Thu, Jul 02, 2020 at 09:28:39PM +0500, Dmitry Petukhov via\n> bitcoin-dev wrote:\n> > I think there should be standard format to describe constraints for\n> > BIP32 paths.\n> > \n> > I present a BIP draft that specifies \"path templates\" for BIP32\n> > paths:\n> > \n> > https://github.com/dgpv/bip32_template_parse_tplaplus_spec/blob/master/bip-path-templates.mediawiki\n> >  \n> \n> Hi Dmitry,\n> \n> How do path templates compare to key origin identification[1] in\n> output script descriptors?\n> \n> Could you maybe give a specfic example of how path templates might be\n> used?  Are they for backups?  Multisig wallet coordination?  Managing\n> data between software transaction construction and hardware device\n> signing?\n> \n> Thanks,\n> \n> -Dave\n> \n> [1]\n> https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md#key-origin-identification\n> (See earlier in the doc for examples)\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 833 bytes\nDesc: \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200703/b3edfbd0/attachment.sig>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-07-03T19:10:50",
                "message_text_only": "\u0412 Fri, 3 Jul 2020 21:53:44 +0500\nDmitry Petukhov via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrote:\n\n> The format for the path templates described in the presented BIP draft\n> aims to provide a building block for interoperability between various\n> hardware and software vendors in regard to this particular task of\n> specifying derivation path restrictions.\n\nOne example of an interoperability workflow might be:\n\nA software vendor that utilizes custom derivation paths in their\nschemes create a \"profile\" that contains the constraints on the paths\n(and possibly other parameters, but this is out of scope of the\nproposal) for their particular scheme. In a simple case it might just\nbe a path template string provided in the documentation.\n\nA user of a software solution from that vendor takes a hardware wallet\nthat supports path templates (or richer \"profiles\") and installs the\nprofile for that solution into hardware wallet. In a simple case, the\nuser just pastes a path template string into some configuration utility\nprogram and then confirms the setting on-device.\n\nThe device statrts to enforce the constraints specified in the template\n(or \"profile\"), and the software solution works as intended by the\nsoftware vendor.\n\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 833 bytes\nDesc: \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200704/36cbf66c/attachment.sig>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-07-06T15:24:27",
                "message_text_only": "\u0412 Fri, 3 Jul 2020 21:53:44 +0500\nDmitry Petukhov via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrote:\n\n> My hope is that having a clear specification and (possibly, in the\n> future) permissibly licensed quality implementations would make\n> adopting such format easier for vendors.\n\nI have added a C implementation (MIT-licensed):\nhttps://github.com/dgpv/bip32_template_c_implementation\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: not available\nType: application/pgp-signature\nSize: 833 bytes\nDesc: \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200706/88a3b672/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: BIP32 Path Templates",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dmitry Petukhov",
                "David A. Harding"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 11249
        }
    },
    {
        "title": "[bitcoin-dev] BIP 118 and SIGHASH_ANYPREVOUT",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2020-07-09T21:40:48",
                "message_text_only": "Hello world,\n\nAfter talking with Christina ages ago, we came to the conclusion that\nit made more sense to update BIP 118 to the latest thinking than have\na new BIP number, so I've (finally) opened a (draft) PR to update BIP\n118 with the ANYPREVOUT bip I've passed around to a few people,\n\nhttps://github.com/bitcoin/bips/pull/943\n\nProbably easiest to just read the new BIP text on github:\n\nhttps://github.com/ajtowns/bips/blob/bip-anyprevout/bip-0118.mediawiki\n\nIt doesn't come with tested code at this point, but I figure better to\nhave the text available for discussion than nothing.\n\nSome significant changes since previous discussion include complete lack\nof chaperone signatures or anything like it (if you want them, you can\nalways add them yourself, of course), and that ANYPREVOUTANYSCRIPT no\nlonger commits to the value (details/rationale in the text).\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2020-07-09T22:30:50",
                "message_text_only": "On Fri, Jul 10, 2020 at 07:40:48AM +1000, Anthony Towns via bitcoin-dev wrote:\n> After talking with Christina\n\nChristian. Dr Christian Decker, PhD. Dr Bitcoin. cdecker. Snyke.\n\nCheers,\naj, hoping he typed one of those right, at least..."
            },
            {
                "author": "Christian Decker",
                "date": "2020-07-10T07:46:54",
                "message_text_only": "No worries, it's a common character twist I find myself doing from time to\ntime :-)\n\nCheers,\nChristina\n\nOn Fri, 10 Jul 2020, 00:31 Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Jul 10, 2020 at 07:40:48AM +1000, Anthony Towns via bitcoin-dev\n> wrote:\n> > After talking with Christina\n>\n> Christian. Dr Christian Decker, PhD. Dr Bitcoin. cdecker. Snyke.\n>\n> Cheers,\n> aj, hoping he typed one of those right, at least...\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200710/69626cb1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-10T03:29:39",
                "message_text_only": "Good morning aj,\n\nIt seems okay to me.\n\n--\n\nSlightly off-topic, but I suppose a Decker-Russell-Osuntokun construction could, in theory, have only a single internal taproot pubkey, `P = MuSig(A, B)` for a channel between A and B.\n\nSo the funding outpoint would be spent with a taprooted P + a single tapscript `<1> OP_CHECKSIG`.\n\nUpdate transactions would be signed with the internal taproot pubkey using `SIGHASH_ANYPREVOUTANYSCRIPT`.\nThe update transaction output would be spendable with a taprooted P + a single tapscript `<index + 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <1> OP_CHECKSIG`.\nEach update transaction would have a monotonically-increasing `nLockTime`, i.e. the above `index`.\n\nThen a state transaction would be signed with the internal taproot pubkey using `SIGHASH_ANYPREVOUT`, which commits to the exact script including `<index + 1>`, which is unique for each update transaction.\nThus a state transaction can only spend the specific update transaction, but the update transaction can spend the funding outpoint or any update transaction outpoint.\nState transaction input would have an `nSequence` requiring a relative locktime of the agreed-upon unilateral close delay.\n\nThe above assumes MuSig signing, which requires 1.5 round trips for a channel, or three broadcast rounds for a multiparticipant (n >= 3) construction.\n\n\nRegards,\nZmnSCPxj\n\n> Hello world,\n>\n> After talking with Christina ages ago, we came to the conclusion that\n> it made more sense to update BIP 118 to the latest thinking than have\n> a new BIP number, so I've (finally) opened a (draft) PR to update BIP\n> 118 with the ANYPREVOUT bip I've passed around to a few people,\n>\n> https://github.com/bitcoin/bips/pull/943\n>\n> Probably easiest to just read the new BIP text on github:\n>\n> https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-0118.mediawiki\n>\n> It doesn't come with tested code at this point, but I figure better to\n> have the text available for discussion than nothing.\n>\n> Some significant changes since previous discussion include complete lack\n> of chaperone signatures or anything like it (if you want them, you can\n> always add them yourself, of course), and that ANYPREVOUTANYSCRIPT no\n> longer commits to the value (details/rationale in the text).\n>\n> Cheers,\n> aj\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "BIP 118 and SIGHASH_ANYPREVOUT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Anthony Towns",
                "Christian Decker"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 4348
        }
    },
    {
        "title": "[bitcoin-dev] Taproot activation discussion",
        "thread_messages": [
            {
                "author": "Steve Lee",
                "date": "2020-07-12T14:53:26",
                "message_text_only": "Hello all,\n\nA new Freenode IRC channel ##taproot-activation has been created for\ndiscussion about various activation proposals, community outreach, and\ngeneral next steps to gain adoption. Feel free to engage, lurk, or ignore.\n\nSteve\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200712/b2f73cae/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Taproot activation discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Steve Lee"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 416
        }
    },
    {
        "title": "[bitcoin-dev] Lightning - Is HTLC vulnerable? And mention of Channel Factories",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2020-07-14T02:58:10",
                "message_text_only": "Sorry. Re-sending with correction to CC bitcoin-dev\n\n\n\n\n\n I am sorry if this was already brought up in previous threads. If I know\nlightning network correctly then HTLC is used to enforce settlements on\nblockchain if there is a dispute. Could a person lose money if their HTLC\ndoes not get confirmed in the timeframe or if an older HTLC gets\nconfirmed first? I see different ways this could happen.\n\n One, if the blockchain is very saturated with other transactions. The\nreason we need lightning network is why it might have troubles with\nsettlements? Two, competition from a different conflicting HTLC. A newer\nHTLC might not get confirmed before an older HTL. Three, denial of service\nthe lightning router so they never have a chance to send a settlement\nHTLC.\n\nI found out about a recent attack technique that sounds like it might be\nsimilar called \"flood and loot\".\n\nIs this a concern on lightning network? I humbly say that I do not fully\nunderstand all of lightning network yet. I am working to grasp the idea.\nThese are questions I look to find answer for. Another question I have. I\ndid read the paper Scalable Funding of Bitcoin Micropayment Channel\nNetworks. Would channel factories be better and eliminate my concern?\n\n\nI am sending this to lightning-dev mailing list. I do not see\nlightning-dev emails because google recaptcha blocks me from the\nsubscribe. Please CC me if you reply so I can read it.\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-14T14:42:21",
                "message_text_only": "Good morning Mr. Lee,\n\n> Sorry. Re-sending with correction to CC bitcoin-dev\n>\n> I am sorry if this was already brought up in previous threads. If I know\n> lightning network correctly then HTLC is used to enforce settlements on\n> blockchain if there is a dispute. Could a person lose money if their HTLC\n> does not get confirmed in the timeframe or if an older HTLC gets\n> confirmed first? I see different ways this could happen.\n>\n> One, if the blockchain is very saturated with other transactions. The\n> reason we need lightning network is why it might have troubles with\n> settlements?\n\nThis could happen, but the entire exercise is to move transactions off the blockchain, precisely to lower this risk.\n\nOtherwise, transfers onchain will take a long time.\nIn practice, a long time to settle a payment will invalidate many real-world economic exchanges anyway (consider paying for food at a restaurant --- if your payments take days to settle, the food has gotten stale before the restaurant receives payment and releases your food).\nThus, if an onchain transfer takes a long time to settle, there is already risk of economic loss present.\n\nBy moving activity offchain, we reduce pressure onchain and improve settlement speeds on both offchain and onchain, reducing risk of economic loss due to delay.\n\n\n> Two, competition from a different conflicting HTLC. A newer\n> HTLC might not get confirmed before an older HTL.\n\nI cannot make sense of this.\n\nYou cannot create conflicting HTLCs.\nEither you have some free money to create an HTLC, in which case there is no possible conflict with an existing HTLC (the fund is reserved for HTLCs, or it is yours without further encumbrance).\n\nThus it is not possible to create a conflicting HTLC in any case: either you have funds (that are not already in an HTLC) to fund an HTLC and that HTLC cannot conflict with existing ones, or you have no funds and a new HTLC cannot be created until one of the HTLCs is resolved one way or another.\n\n> Three, denial of service\n> the lightning router so they never have a chance to send a settlement\n> HTLC.\n\nThis is possible, but only that node risks loss.\n\nThe reason why unilateral close is always possible is to handle the case where a routing node comes offline.\n\nIf you have offered an HTLC to a routing node, you retain a timelock branch back to you (the \"T\" in HTLC).\n\nIf the routing node goes offline past the timelock in the HTLC, then you unilaterally close the channel and drop the HTLC onchain.\nThis is what lets you recover your funds.\n\n\n>\n> I found out about a recent attack technique that sounds like it might be\n> similar called \"flood and loot\".\n\nRoughly, my understanding of Flood and Loot is to make a lot of uneconomically tiny HTLCs going through a target victim forwarding node.\nYou make circular routes going from your own node back to yourself.\nThen you refuse to actually claim the HTLCs sent back to yourself.\n\nThen you go offline.\nThis means that the only way for the forwarding node to recover its funds is to drop the channel(s) involved onchain.\nBut if the HTLCs are many and tiny, they are simply too uneconomic to claim onchain, so they just lose the channel funds as fees.\n\n\n\n>\n> Is this a concern on lightning network?\n\nYes.\nWork is being done (anchor commitments) to mitigate the effects of onchain fees on Lightning.\n\n> I humbly say that I do not fully\n> understand all of lightning network yet. I am working to grasp the idea.\n> These are questions I look to find answer for. Another question I have. I\n> did read the paper Scalable Funding of Bitcoin Micropayment Channel\n> Networks. Would channel factories be better and eliminate my concern?\n\nThey would not.\nUltimately, your \"final defense\" is to drop the entire construction onchain until you reach the HTLCs and you can have the blockchain enforce the HTLC contract.\n\nIt would *help* to reduce blockchain bloat by reducing the size of transactions to create multiple channels, and thus also secondarily helps reduce onchain fee pressure and also reduce Flood-and-Loot (which is basically a layer-crossing attack, taking advantage of lower-layer fees to create attacks on higher layers).\n\nBut always the underlying problem remains: security costs something, and you have to pay for protection on the Internet when transacting with potentially untrusted (and untrustable) entities.\nIt seems unlikely that \"security costs something\" can be eliminated.\nOne can consider that modern-day state-imposed taxation is paying for security, for instance, of traditional face-to-face transactions.\nWith Bitcoin, you can choose to either transact and pay for security, or not transact and forgo what you would have bought.\nWith some tradeoffs, you can pay by other means that may be cheaper for you.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2020-07-15T15:23:24",
                "message_text_only": "On Tue, 14 Jul 2020 at 16:42, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Mr. Lee,\n>\n> > Sorry. Re-sending with correction to CC bitcoin-dev\n> >\n> > I am sorry if this was already brought up in previous threads. If I know\n> > lightning network correctly then HTLC is used to enforce settlements on\n> > blockchain if there is a dispute. Could a person lose money if their HTLC\n> > does not get confirmed in the timeframe or if an older HTLC gets\n> > confirmed first? I see different ways this could happen.\n> >\n> > One, if the blockchain is very saturated with other transactions. The\n> > reason we need lightning network is why it might have troubles with\n> > settlements?\n>\n> This could happen, but the entire exercise is to move transactions off the\n> blockchain, precisely to lower this risk.\n>\n> Otherwise, transfers onchain will take a long time.\n> In practice, a long time to settle a payment will invalidate many\n> real-world economic exchanges anyway (consider paying for food at a\n> restaurant --- if your payments take days to settle, the food has gotten\n> stale before the restaurant receives payment and releases your food).\n> Thus, if an onchain transfer takes a long time to settle, there is already\n> risk of economic loss present.\n>\n> By moving activity offchain, we reduce pressure onchain and improve\n> settlement speeds on both offchain and onchain, reducing risk of economic\n> loss due to delay.\n>\n>\n> > Two, competition from a different conflicting HTLC. A newer\n> > HTLC might not get confirmed before an older HTL.\n>\n> I cannot make sense of this.\n>\n> You cannot create conflicting HTLCs.\n>\n\nCorrect.  Removing or Creating an HTLC is something that both channel\npartners need to agree on.  They may create multiple pending HTLCs as long\nas there are enough funds, but creating conflicting HTLCs is not possible.\n\n\n> >\n> > I found out about a recent attack technique that sounds like it might be\n> > similar called \"flood and loot\".\n>\n> Roughly, my understanding of Flood and Loot is to make a lot of\n> uneconomically tiny HTLCs going through a target victim forwarding node.\n> You make circular routes going from your own node back to yourself.\n> Then you refuse to actually claim the HTLCs sent back to yourself.\n>\n\nNo, the way I understand it is that an attacker, say Malleroy, routes a lot\nof medium sized HTLC payments from his node to his node via a victim node,\nsay Alice's, and possibly other nodes.\nThen Malleroy *accepts* the payments by publishing the hash on the\nreceiving end, so he gets all the sent funds on his receiving channel.\nMalleroy's receiving node behaves completely honestly, and nobody can prove\nthat it belongs to the attacker.\nFinally when Alice claims her HTLC by presenting the hash, Malleroy just\nignores the claim.  Now Alice, the victim, is forced to close the channel\nto prevent the HTLC to timeout. If Malleroy does it with multiple victims\nat exactly the same time, they will all compete with each other.  The\nvictims cannot increase the fee for the HTLC claiming transaction, because\nthey are the ones who force-closed the channel.  CPFP doesn't work, because\ntheir ultimate output is CLTV'd.  As soon as the HTLC timeouts Malleroy can\nclaim the still pending HTLCs using an RBF transaction.\n\nSo it is Alice who has to force close, which puts her at a big disadvantage.\n\nMalleroy will have to pay the lightning fees, but they are negligible.  The\nfee for the on-chain force-close transaction (with the HTLC outputs) is\npaid by whoever opened the channel. AFAIK the fee for the HTLC resolving\ntransactions is paid by whoever claims the HTLC.  In this scenario it is\npaid from Alice's money.  If Malleroy opened the channel, he risks losing\nsome funds to on-chain fees.  On the other hand the one who pays the fee\ncontrols the fee.  He could negotiate a very low fee (say a cent per HTLC),\nwhen the network is idle and then wait for a natural congestion before\nstarting the attack, giving him a low risk with high success probability.\nEvery HTLC he can claim after timeout is profit.\n\nRegards,\n  Jochen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200715/ed01a6cf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning - Is HTLC vulnerable? And mention of Channel Factories",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Jochen Hoenicke",
                "Mr. Lee Chiffre"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10560
        }
    },
    {
        "title": "[bitcoin-dev] Thoughts on soft-fork activation",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2020-07-14T09:37:30",
                "message_text_only": "Hi,\n\nI've been trying to figure out a good way to activate soft forks in\nfuture. I'd like to post some thoughts on that. So:\n\nI think there's two proposals that are roughly plausible. The first is\nLuke's recent update to BIP 8:\n\n    https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki\n\nIt has the advantage of being about as simple as possible, and (in my\nopinion) is an incremental improvement on how segwit was activated. Its\nmain properties are:\n\n   - signalling via a version bit\n   - state tansitions based on height rather than median time\n   - 1 year time frame\n   - optional mandatory activation at the end of the year\n   - mandatory signalling if mandatory activation occurs\n   - if the soft fork activates on the most work chain, nodes don't\n     risk falling out of consensus depending on whether they've opted in\n     to mandatory activation or not\n\nI think there's some fixable problems with that proposal as it stands\n(mostly already mentioned in the comments in the recently merged PR,\nhttps://github.com/bitcoin/bips/pull/550 )\n\nThe approach I've been working on is based on the more complicated and\nslower method described by Matt on this list back in January. I've got a\nBIP drafted at:\n\n    https://github.com/ajtowns/bips/blob/202007-activation-dec-thresh/bip-decthresh.mediawiki\n\nThe main difference with the mechanism described in January is that the\nthreshold gradually decreases during the secondary period -- it starts at\n95%, gradually decreases until 50%, then mandatorily activates. The idea\nhere is to provide at least some potential reward for miners signalling\nin the secondary phase: if 8% of hashpower had refused to signal for\na soft-fork, then there would have been no chance of activating until\nthe very end of the period. This way, every additional percentage of\nhashpower signalling brings the activation deadline forward.\n\nThe main differences between the two proposals is that the BIP 8 approach\nhas a relatively short time frame for users to upgrade if we want\nmandatory activation without a supermajority of hashpower enforcing the\nrules; while the \"decreasing threshold\" approach linked above provides\nquite a long timeline.\n\nIn addition, there is always the potential to introduce a BIP 91/148\nstyle soft-fork after the fact where either miners or users coordinate to\nhave mandatory signalling which then activates a pre-existing deployment\nattempt.\n\nI think the design constraints we want are:\n\n * if everyone cooperates and no one objects, we activate pretty quickly\n\n * there's no obvious exploits, and we have plausible contingency plans\n   in place to discourage people from try to use the attempt to deploy\n   a new soft fork as a way of attacking bitcoin, either via social\n   disruption or by preventing bitcoin from improving\n\n * we don't want to ship code that causes people to fall out of\n   consensus in the (hopefully unlikely) event that things don't go\n   smoothly [0]\n\nIn light of that, I think I'm leaning towards:\n\n * use BIP 8 with mandatory activation disabled in bitcoin core -- if\n   you want to participate in enforcing mandatory activation, you'll\n   need to recompile, or use a fork like bitcoin knots; however if\n   mandatory activation occurs on the longest chain, you'll still follow\n   that chain and enforce the rules.\n\n * be prepared to update the BIP 8 parameters to allow mandatory\n   activation in bitcoin core if, after 9 months say, it's apparent that\n   there aren't reasonable objections, there's strong support for\n   activation, the vast majority of nodes have already updated to\n   enforce the rules upon activation, and there's strong support for\n   mandatory activation\n\n * change the dec-threshold proposal to be compatible with BIP 8, and\n   keep it maintained so that it can be used if there seems to be\n   widespread consensus for activation, but BIP 8 activation does\n   not seem certain -- ie, as an extra contingency plan.\n\n * be prepared to support miners coordinating via BIP 91 either to\n   bring activation forward in either BIP 8 or \"decreasing threshold\" or\n   de-risk BIP 8 mandatory activation -- ie, an alternative contingency\n   plan. This is more appropriate if we've found that users/miners have\n   upgraded so that activation is safe; so it's a decision we can make\n   later when we have more data, rather than having to make the decision\n   early when we don't have enough information to judge whether it's\n   safe or not.\n\n * (also, improve BIP 8 a bit more before deploying it -- I'm hoping for\n   some modest changes, which is why \"decreasing threshold\" isn't already\n   compatible with BIP 8)\n\n * (continue to ensure the underlying soft fork makes sense and is\n   well implemented on its own merits)\n\n * (continue to talk to as many people as we can about the underlying\n   changes and make sure people understand what's going on and that\n   we've addressed any reasonable objections)\n\nI'm hopeful activating taproot will go smoothly, but I'm not 100% sure\nof it, and there are potentially many different ways in which things go\nwrong; so starting with something simple and being ready to adapt if/when\nwe see things starting to go weird seems like a good approach to me.\n\nCheers,\naj\n\n[0] At least, that's how I'm phrasing some of the concerns that were\n    expressed in, eg,\n\n    https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/014152.html"
            },
            {
                "author": "Matt Corallo",
                "date": "2020-07-14T20:46:06",
                "message_text_only": "Thanks Anthony for this writeup!\n\nI find it incredibly disappointing that the idea of naive flag day fork activation is being seriously discussed in the\nform of BIP 9. Activation of forks is not only about the included changes but also around the culture of how changes to\nBitcoin should be and are made. Whether we like it or not, how Taproot activates will set a community understanding and\nfuture norms around how many changes are made.\n\nMembers of this list lost sleep and years off their life from stress fighting to ensure that the process by which\nBitcoin changes is not only principled in its rejection of unilateral changes, but also that that idea was broadly\nunderstood, and broadly *enforced* by community members - the only way in which it has any impact. That fight is far\nfrom over - Bitcoin's community grows and changes daily, and the history around what changed and how has been rewritten\ntime and time again. Worse still, the principled nature of Bitcoin's change process is targeted constantly as untrue in\nan attempt by various alternative systems to pretend that their change process of \"developers ship new code, users run\nit blindly\" is identical to Bitcoin.\n\nWhile members of this list may be aware of significant outreach efforts and design work to ensure that Taproot is not\nonly broadly acceptable to Bitcoin users, but also has effectively no impact on users who wish not to use it, it is\ncertainly not the case that all Bitcoin users are aware of that work, nor seen the results directly communicated to them.\n\nWorse still, it is hard to argue that a new version of Bitcoin Core containing a fixed future activation of a new\nconsensus rule is anything other than \"developers have decided on new rules\" (even if it is, based on our own knowledge,\nnot the case). Indeed, even the proposal by Anthony, which makes reference to my previous work has this issue, and it\nmay not be avoidable - there is very legitimate concern over miners blocking changes to Bitcoin which do not harm them\nwhich users objectively desire, potentially purely through apathy. But to dismiss the concerns over the optics which set\nthe stage for how future changes are made to Bitcoin purely because miners may be too busy with other things to upgrade\ntheir nodes seems naive at best.\n\nI appreciate the concern over activation timeline given miner apathy, and to some extend Anthony's work here addresses\nthat with decreasing activation thresholds during the second signaling period, but bikeshedding on timeline may be merited.\n\nTo not make every attempt to distance the activation method from the public perception unilateral activation strikes me\nas the worst of all possible outcomes for Bitcoin's longevity. Having a quieting period after BIP 9 activation failure\nmay not be the best way to do that, but it seems like a reasonable attempt.\n\nMatt\n\nOn 7/14/20 5:37 AM, Anthony Towns via bitcoin-dev wrote:\n> Hi,\n> \n> I've been trying to figure out a good way to activate soft forks in\n> future. I'd like to post some thoughts on that. So:\n> \n> I think there's two proposals that are roughly plausible. The first is\n> Luke's recent update to BIP 8:\n> \n>     https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki\n> \n> It has the advantage of being about as simple as possible, and (in my\n> opinion) is an incremental improvement on how segwit was activated. Its\n> main properties are:\n> \n>    - signalling via a version bit\n>    - state tansitions based on height rather than median time\n>    - 1 year time frame\n>    - optional mandatory activation at the end of the year\n>    - mandatory signalling if mandatory activation occurs\n>    - if the soft fork activates on the most work chain, nodes don't\n>      risk falling out of consensus depending on whether they've opted in\n>      to mandatory activation or not\n> \n> I think there's some fixable problems with that proposal as it stands\n> (mostly already mentioned in the comments in the recently merged PR,\n> https://github.com/bitcoin/bips/pull/550 )\n> \n> The approach I've been working on is based on the more complicated and\n> slower method described by Matt on this list back in January. I've got a\n> BIP drafted at:\n> \n>     https://github.com/ajtowns/bips/blob/202007-activation-dec-thresh/bip-decthresh.mediawiki\n> \n> The main difference with the mechanism described in January is that the\n> threshold gradually decreases during the secondary period -- it starts at\n> 95%, gradually decreases until 50%, then mandatorily activates. The idea\n> here is to provide at least some potential reward for miners signalling\n> in the secondary phase: if 8% of hashpower had refused to signal for\n> a soft-fork, then there would have been no chance of activating until\n> the very end of the period. This way, every additional percentage of\n> hashpower signalling brings the activation deadline forward.\n> \n> The main differences between the two proposals is that the BIP 8 approach\n> has a relatively short time frame for users to upgrade if we want\n> mandatory activation without a supermajority of hashpower enforcing the\n> rules; while the \"decreasing threshold\" approach linked above provides\n> quite a long timeline.\n> \n> In addition, there is always the potential to introduce a BIP 91/148\n> style soft-fork after the fact where either miners or users coordinate to\n> have mandatory signalling which then activates a pre-existing deployment\n> attempt.\n> \n> I think the design constraints we want are:\n> \n>  * if everyone cooperates and no one objects, we activate pretty quickly\n> \n>  * there's no obvious exploits, and we have plausible contingency plans\n>    in place to discourage people from try to use the attempt to deploy\n>    a new soft fork as a way of attacking bitcoin, either via social\n>    disruption or by preventing bitcoin from improving\n> \n>  * we don't want to ship code that causes people to fall out of\n>    consensus in the (hopefully unlikely) event that things don't go\n>    smoothly [0]\n> \n> In light of that, I think I'm leaning towards:\n> \n>  * use BIP 8 with mandatory activation disabled in bitcoin core -- if\n>    you want to participate in enforcing mandatory activation, you'll\n>    need to recompile, or use a fork like bitcoin knots; however if\n>    mandatory activation occurs on the longest chain, you'll still follow\n>    that chain and enforce the rules.\n> \n>  * be prepared to update the BIP 8 parameters to allow mandatory\n>    activation in bitcoin core if, after 9 months say, it's apparent that\n>    there aren't reasonable objections, there's strong support for\n>    activation, the vast majority of nodes have already updated to\n>    enforce the rules upon activation, and there's strong support for\n>    mandatory activation\n> \n>  * change the dec-threshold proposal to be compatible with BIP 8, and\n>    keep it maintained so that it can be used if there seems to be\n>    widespread consensus for activation, but BIP 8 activation does\n>    not seem certain -- ie, as an extra contingency plan.\n> \n>  * be prepared to support miners coordinating via BIP 91 either to\n>    bring activation forward in either BIP 8 or \"decreasing threshold\" or\n>    de-risk BIP 8 mandatory activation -- ie, an alternative contingency\n>    plan. This is more appropriate if we've found that users/miners have\n>    upgraded so that activation is safe; so it's a decision we can make\n>    later when we have more data, rather than having to make the decision\n>    early when we don't have enough information to judge whether it's\n>    safe or not.\n> \n>  * (also, improve BIP 8 a bit more before deploying it -- I'm hoping for\n>    some modest changes, which is why \"decreasing threshold\" isn't already\n>    compatible with BIP 8)\n> \n>  * (continue to ensure the underlying soft fork makes sense and is\n>    well implemented on its own merits)\n> \n>  * (continue to talk to as many people as we can about the underlying\n>    changes and make sure people understand what's going on and that\n>    we've addressed any reasonable objections)\n> \n> I'm hopeful activating taproot will go smoothly, but I'm not 100% sure\n> of it, and there are potentially many different ways in which things go\n> wrong; so starting with something simple and being ready to adapt if/when\n> we see things starting to go weird seems like a good approach to me.\n> \n> Cheers,\n> aj\n> \n> [0] At least, that's how I'm phrasing some of the concerns that were\n>     expressed in, eg,\n> \n>     https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925\n>     https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/014152.html\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-17T02:58:46",
                "message_text_only": "Good morning list, BlueMatt and aj,\n\nThere is an idea circulating on IRC and elsewhere, which seems to be at least mildly supported by gmax and roconnor, which I will try to explain here.\n\n(These are my words, so if there is some mistake, I apologize)\n\nBasically:\n\n* Deploy a BIP8 `lockinontimeout=true` `lockin=+42 months` (or 36 months, or 24 months) at next release.\n  * Pedanty note: BIP8 uses blockheights, not actual times.\n* Then 1 year after `starttime`, ***if*** it is not activated yet:\n  * Discuss.\n  * If we think it is only because of miner apathy and user support seems good regardless, deploy a BIP91 reduced-threshold 80% that enforces the BIP8 bit.\n    * We hope that this will stave off independent attempts at a UASF with a faster timeout.\n  * If we think there are real reasons not to continue with Taproot as-is, deploy an abort: a softfork that disallows transaction outputs with `OP_1 <32-bytes>` `scriptPubKey` (other lengths and other versions are allowed).\n\nThis approximates what aj is proposing:\n\n* Ultimately, we expect to deploy a BIP8 `lockinontimeout=true` that will have a timeout that ends +42 months after the first countdown, even with Modern Softfork Activation.\n* The abort is roughly equivalent to the Modern Softfork Activation case where during the 6 month discussion period we decide not to deploy Taproot after all.\n* The deployment of a BIP91 reduced-threshold 80% approximates what aj proposes, to reduce the threshold for activation later.\n\nAs I understand it, an advantage of this proposal is that we can deploy very quickly a relatively simple BIP8 `locktimeontimeout=true`, then continue debate on various details (is 80% too low? too high? are users actually deploying? are mining pools updating? etc) in parallel.\nThis lets the code into the hands of users where they can start deploying it and we can start getting better gauges on how well Taproot is supported.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Thoughts on soft-fork activation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Anthony Towns",
                "Matt Corallo"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 16183
        }
    },
    {
        "title": "[bitcoin-dev] Bech32 weakness and impact on bip-taproot addresses",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2020-07-15T20:56:12",
                "message_text_only": "On Wed, Nov 13, 2019 at 1:31 AM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> That brings me to Matt's point: there is no need to do this right now. We\n> can simply amend BIP173 to only permit length 20 and length 32 (and only\n> length 20 for v0, if you like; but they're so far apart that permitting\n> both shouldn't hurt), for now. Introducing the \"new\" address format (the\n> one using an improved checksum algorithm) only needs to be there in time\n> for when a non-32-byte-witness-program would come in sight.\n>\n\nAs a prerequisite to taproot activation, I was looking into amending BIP173\nas stated above.  However after reviewing\nhttps://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb#detection-of-insertion-errors\nit seems that insertions of 5 characters or more is \"safe\" in the sense\nthat there is low probability of creating a valid checksum by doing so\nrandomly.\n\nThis means we could safely allow witness programs of lengths *20*, 23, 26,\n29, *32*, 36, and 40 (or 39).  These correspond to Bech32 addresses of\nlength *42*, 47, 52, 57, *62*, 68, and 74 (or 73).  We could also support a\nset of shorter addresses, but given the lack of entropy in such short\naddresses, it is hard to believe that such witness programs could be used\nto secure anything.  I'm not sure what the motivation for allowing such\nshort witness programs was, but I'm somewhat inclined to exclude them from\nthe segwit address format.\n\nGiven that we would only be able to support one of 39 or 40 byte witness\nprograms, it is sensible to choose to allow 40 byte witness programs to be\naddressable.  This is the maximum witness program size allowed by BIP 141.\n\nSo my proposal would be to amend BIP173 in such a way to restrict \"bc\" and\n\"tb\" segwit address formats to require witness programs be of size *20*,\n23, 26, 29, *32*, 36, or 40.  Witness programs of other sizes (between 2\nand 40) would, of course, still be legal in accordance with BIP 141;\nhowever they would be unaddressable by using this \"bc\" and \"tb\" prefix.\nAnother address format would be needed to support other witness sizes,\nshould the need ever arise.\n\n-- \nRussell O'Connor\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200715/42e33bf5/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2020-07-15T21:05:22",
                "message_text_only": "Can you make it clear what the bold vs not-bold numbers mean?\n\nOn Wed, Jul 15, 2020 at 4:56 PM Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, Nov 13, 2019 at 1:31 AM Pieter Wuille via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> That brings me to Matt's point: there is no need to do this right now. We\n>> can simply amend BIP173 to only permit length 20 and length 32 (and only\n>> length 20 for v0, if you like; but they're so far apart that permitting\n>> both shouldn't hurt), for now. Introducing the \"new\" address format (the\n>> one using an improved checksum algorithm) only needs to be there in time\n>> for when a non-32-byte-witness-program would come in sight.\n>>\n>\n> As a prerequisite to taproot activation, I was looking into amending\n> BIP173 as stated above.  However after reviewing\n> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb#detection-of-insertion-errors\n> it seems that insertions of 5 characters or more is \"safe\" in the sense\n> that there is low probability of creating a valid checksum by doing so\n> randomly.\n>\n> This means we could safely allow witness programs of lengths *20*, 23,\n> 26, 29, *32*, 36, and 40 (or 39).  These correspond to Bech32 addresses\n> of length *42*, 47, 52, 57, *62*, 68, and 74 (or 73).  We could also\n> support a set of shorter addresses, but given the lack of entropy in such\n> short addresses, it is hard to believe that such witness programs could be\n> used to secure anything.  I'm not sure what the motivation for allowing\n> such short witness programs was, but I'm somewhat inclined to exclude them\n> from the segwit address format.\n>\n> Given that we would only be able to support one of 39 or 40 byte witness\n> programs, it is sensible to choose to allow 40 byte witness programs to be\n> addressable.  This is the maximum witness program size allowed by BIP 141.\n>\n> So my proposal would be to amend BIP173 in such a way to restrict \"bc\" and\n> \"tb\" segwit address formats to require witness programs be of size *20*,\n> 23, 26, 29, *32*, 36, or 40.  Witness programs of other sizes (between 2\n> and 40) would, of course, still be legal in accordance with BIP 141;\n> however they would be unaddressable by using this \"bc\" and \"tb\" prefix.\n> Another address format would be needed to support other witness sizes,\n> should the need ever arise.\n>\n> --\n> Russell O'Connor\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200715/0a190d55/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2020-07-15T21:11:11",
                "message_text_only": "The bold values are the witness program lengths and address lengths of the\nsegwit v0 programs (BIP-141), which clearly need to be covered in my\nproposed amendment.  32 bytes is also the proposed witness program length\nfor segwit v1 that would correspond to a taproot (BIP-341) program.\n\nOn Wed, Jul 15, 2020 at 5:05 PM Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> Can you make it clear what the bold vs not-bold numbers mean?\n>\n> On Wed, Jul 15, 2020 at 4:56 PM Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Wed, Nov 13, 2019 at 1:31 AM Pieter Wuille via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>>\n>>> That brings me to Matt's point: there is no need to do this right now.\n>>> We can simply amend BIP173 to only permit length 20 and length 32 (and only\n>>> length 20 for v0, if you like; but they're so far apart that permitting\n>>> both shouldn't hurt), for now. Introducing the \"new\" address format (the\n>>> one using an improved checksum algorithm) only needs to be there in time\n>>> for when a non-32-byte-witness-program would come in sight.\n>>>\n>>\n>> As a prerequisite to taproot activation, I was looking into amending\n>> BIP173 as stated above.  However after reviewing\n>> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb#detection-of-insertion-errors\n>> it seems that insertions of 5 characters or more is \"safe\" in the sense\n>> that there is low probability of creating a valid checksum by doing so\n>> randomly.\n>>\n>> This means we could safely allow witness programs of lengths *20*, 23,\n>> 26, 29, *32*, 36, and 40 (or 39).  These correspond to Bech32 addresses\n>> of length *42*, 47, 52, 57, *62*, 68, and 74 (or 73).  We could also\n>> support a set of shorter addresses, but given the lack of entropy in such\n>> short addresses, it is hard to believe that such witness programs could be\n>> used to secure anything.  I'm not sure what the motivation for allowing\n>> such short witness programs was, but I'm somewhat inclined to exclude them\n>> from the segwit address format.\n>>\n>> Given that we would only be able to support one of 39 or 40 byte witness\n>> programs, it is sensible to choose to allow 40 byte witness programs to be\n>> addressable.  This is the maximum witness program size allowed by BIP 141.\n>>\n>> So my proposal would be to amend BIP173 in such a way to restrict \"bc\"\n>> and \"tb\" segwit address formats to require witness programs be of size\n>> *20*, 23, 26, 29, *32*, 36, or 40.  Witness programs of other sizes\n>> (between 2 and 40) would, of course, still be legal in accordance with BIP\n>> 141; however they would be unaddressable by using this \"bc\" and \"tb\"\n>> prefix.  Another address format would be needed to support other witness\n>> sizes, should the need ever arise.\n>>\n>> --\n>> Russell O'Connor\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200715/33a67832/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bech32 weakness and impact on bip-taproot addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Greg Sanders"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8351
        }
    },
    {
        "title": "[bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-17T06:02:03",
                "message_text_only": "Good morning Chris,\n\n> On 13/06/2020 15:06, ZmnSCPxj wrote:\n>\n> > Good morning Chris,\n> >\n> > > Would it be fair to summarize the idea in this way:\n> > > CoinSwappers can slow down the CoinSwap process which will give an\n> > > opportunity for makers to use batching.\n> >\n> > I think so.\n> > Regards,\n> > ZmnSCPxj\n>\n> It's definitely a good idea. As well as improving privacy by pretending\n> to be a service provider which uses batching, it may also be practical\n> just because CoinSwap takers will want to slow down the process for\n> greater privacy so that an adversary would have to search more of the\n> blockchain to attempt to deanonymize them. Also, by being prepared to\n> wait longer the takers will also save miner fees.\n\nDespite the subject title, I have realized belatedly that the same kind of batching can be done by the taker as well.\n\nFor example, the taker can contact two makers in parallel to setup separate CoinSwaps with them.\nThen the taker produces a transaction spending its funds and sending them out to two outputs.\n\nIf the taker uses P2PKH for receiving and change, and we use (via 2p-ECDSA) P2PKH 2-of-2 to anchor the swaps, then if both CoinSwap operations are successful, the transaction looks exactly like an ordinary pay-to-someone-and-get-back-change transaction.\n\nIndeed, each of the two makers contacted, if they are not themselves colluding with each other, cannot really differentiate this from somebody doing a CoinSwap only with them, since the other output is indistinguishable from change.\n\nI am uncertain how much extra privacy (or cheapness) this buys the taker, however.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Hiding CoinSwap Makers Among Custodial Services",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1630
        }
    },
    {
        "title": "[bitcoin-dev] The Cryptographic Relay: An Electrical Device For Smart Transferable Hardware",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-20T14:18:10",
                "message_text_only": "Introduction\n============\n\nAn electrical relay is an electrically-controlled switch, often diagrammed as:\n\n      +-------------o\n      |\n      |   \\\n      |    \\\n      +--o  o-------o\n\n    o----  |\n         ) |\n         ) |\n         ) |\n    o----  |\n\nThe terminals at the left feed into a coil.\nWhen electricity passes through the coil, it magnetizes a core, and the magnetism attracts a switch into a closed position, which would let electricity to pass through the terminals at the right.\nThis can be used to \"turn on\" or supply power to a different electrical device.\n\nIf no electricity is passing through the coil via the terminals on the left, then no electricity can pass through the terminals on the right, as the switch is an open position at default.\n\nThis is a fairly simple logic circuitry, upon which more complicated circuitry can be made.\n\nSimilarly, a Cryptographic Relay is a hardware electrical component that allows control of some electrical circuit.\nIt has two terminals which are the two terminals of a switch.\nIt can also be contacted, for example via Bluetooth, by an electronic computing device.\nThe Cryptographic Relay has a public key, which represents the current owner of the relay.\nIf the electronic device is able to provide a proof-of-knowledge of the private key (i.e. a signature) corresponding to the public key that the Cryptographic Relay knows, then it allows the switch to be controlled by that device.\n\nMotivation\n==========\n\nSuppose I have a car I wish to sell to you, for Bitcoins.\nThis car, as it happens, has a Cryptographic Relay: it will only start its engine if it gets a signed message from me using a private key I have on my phone.\nIt knows my public key, and will only turn off and on at my command.\n\nNow, you want to be able to know that by paying me Bitcoins, you get sole ownership of the car I am selling.\n\nThis is in fact, nothing more than a swap operation.\nI have an asset, a car, and you have an asset, some Bitcoins.\nWe want to atomically swap one asset for the other asset, and those assets do not exist in a single asset-assignment system.\n\nPaying Bitcoins For Cars Via Succinct Atomic Swaps\n==================================================\n\nFortunately, there is an atomic swap operation, Succinct Atomic Swaps, which can be used to create an atomic swap between my car and your Bitcoins.\n\nAn important part of this Succinct Atomic Swap is that all timeouts are only in one asset-assignment system.\nThe original Succinct Atomic Swap discussion gives an example of swapping Bitcoins for Litecoins.\nEach has its own distinct blockchain, which is a distinct distributed asset-assignment system.\n\nA crucial part of the Succinct Atomic Swap is that all timelocks are only on one asset-assignment system.\nThe other asset-assignment system need not support anything other than assigning ownership of assets to (homomorphically additive) public keys.\n\nThis is important as a major simplification of the Cryptographic Relay:\nThe relay only needs to know its *current owner*, and does not need to know the current time!\n\nThus, in order for you to buy my car:\n\n* You set up the Succinct Atomic Swap on the Bitcoin blockchain.\n* We generate fresh private keys, then combine them via MuSig, and I transfer the ownership of the car to that MuSig public key.\n* If I claim the funds, that atomically reveals my share of the private key to you, so you can claim the car using your private key plus my share and transfer the car to sole control of you.\n* If I fail to claim the funds, then when you reclaim your funds at timeout, that atomically reveals your share of the private key to me, so that I can claim the car using my private key plus your share and transfer the car back to sole control of me.\n\nThis is in fact the same as the Succinct Atomic Swap example, except that instead of me swapping my Litecoins for your Bitcoins, I am swapping my Cryptographic Relay for your Bitcoins.\n\nCryptographic Relay Operations\n==============================\n\nThus, a Cryptographic Relay needs to support only the following basic operations.\nThese operations are triggered by its owner sending a message, plus a signature verifiable by the public key, to the Cryptographic Relay.\n(Cryptographer warning: if using Schnorr, the message hashed into the signature also has to include the public key that is signing it, since BIP32 nonhardened derivation allows a Schnorr signature created by one child private key to be trivially malleated into a signature for the same message by a sibling private key; this does not exist in ECDSA due to its nonlinearity.\nmessage sends need not include the public key, it can be added by the cryptographic relay since it has to know the public key of the owner anyway.\nOf note is that the bip-340 description of Schnorr includes the public key in the hash operation of signatures as well, and does not require this.)\n\nThe only operations necessary are:\n\n1.  Turn on.\n2.  Turn off.\n3.  Transfer ownership to new pubkey ___.\n\nDue to Succinct Atomic Swaps not requiring any kind of timelock on one asset-assignment system, the Cryptographic Relay need not have any concept of time, as mentioned above, and transfer of ownership can be done by a simple message signed by the current owner transferring ownership to a new public key.\n\n(Cryptographer warning: turn-on/turn-off messages should be challenge-response: the Cryptographic Relay requests signing with a unique nonce included in the message, otherwise previous messages can be captured by third parties and replayed; ownership-transfer messages should probably also include a nonce, or otherwise we could require non-reuse of keys.\nThis can be implemented with a 64-bit incrementing nonce, which should work for the practical lifetime of any Cryptographic Relay.)\n\n(Cryptographer warning: similarly, ownership-transfer messages should probably be indexed as well with an incrementing nonce, otherwise key reuse would allow signature replay; similarly again, each Cryptographic Relay should have a UUID that is included in message hashes, as otherwise key reuse would allow signature replay for commands to one device to be repeated for another device.)\n\nLightning\n=========\n\nUnfortunately, it seems not possible to transport Succinct Atomic Swap constructions over the Lightning Network.\n\nSuccinct Atomic Swaps have an asymmetric setup, unlike the traditional HTLC-based atomic swaps.\nThis asymmetry makes it difficult to reason about how a forwarding node on the Lightning Network would be able to accept a Succinct Atomic Swap and then send out another Succinct Atomic Swap.\n\nAn observation to make is that the Bitcoin-side construction in the Succinct Atomic Swap description has the following branches:\n\n* B gets the money, and A learns a secret from B.\n* After a timeout, A gets the money back, and B learns a secret from A.\n\nUnfortunately, the above construction, while instantiatable in a single channel (any absolute-timelock contract enforceable on a blockchain can be instantiated in a channel anchored in that blockchain), cannot be safely *forwarded* over the Lightning Network in a sequence of channels forming a route.\n\nThis is because we need to have a different timeout at each forwarding hop, in order to allow a forwarding node enough time to discover an event and react accordingly.\nThis means that each forwarding node has to have a shorter timeout on its outgoing contract than its incoming contract.\n\nBut in the half-Succinct-Atomic-Swap contract, the forwarding node needs to provide a secret in order to reclaim the funds at the timeout.\nAnd it can only discover that secret at the later timeout of the incoming contract.\nThus, it is not safe for the forwarding node to forward any half-Succinct-Atomic-Swap contract.\n\nThus, we either:\n\n* Prevent old, low-value cryptographic cars from being bought using Lightning, reducing their economic veolocity and preventing moon and lambos.\n* OR, we give the Cryptographic Relay a notion of time which makes it compatible with PTLCs that can be routed over Lightning.\n  In essence, the PTLC \"goes over one more hop\", this time transferring ownership of the Cryptographic Relay.\n\nA Cryptographic Notion of Time\n==============================\n\nTime stops for no one; it will not stop for thee.\n\nOr, in more science-appropriate terms: the passage of time is the direction in which universal entropy increases.\n\nNow, we can observe that block header hashes are, in fact, low-entropy.\nThis is because the higher bits of block header hashes are consistently 0; there are thus fewer bits of entropy you can extract from a block header hash.\n\nNow, we can observe that temperature is largely itself also an expression of entropy.\nHigher-entropy areas are higher temperature, and lower-entropy areas are lower temperature.\nOverall, the temperature differential across the universe decreases in the direction of future time.\n\nHowever, it is possible to implement a sort of Maxwell's Demon.\nMaxwell's Demon is an entity that guards a hole between two containers containing air.\nIf a high-speed, high-tempreature molecule of air on the left side approaches the hole, Maxwell's Demon magically swats it away, but if a similar high-speed, high-temperature molecule of air on the right side approaches the hole, Maxwell's Demon lets it pass.\nIt has the reverse policy for low-temperature molecules of air, letting it go from the left container to the right container.\n\nOver time, the temperature of the right container drops, because all the high-temperature molecules have been moved to the left container.\n\nOf course, we already have implementations of Maxwell's Demon.\nWe call such implementations \"refrigerators\".\n\nRefrigerators, to do their magic, must consume energy and emit heat.\nIndeed, the total heat emitted by the refrigerator is much larger than the heat it removes in the cold part of the refrigerator.\nWe can verify that the refrigerator is working, trivially, by checking that the supposedly-cold part of the refrigerator is indeed cold.\nBut we know that refrigerators, to do their work, must consume energy and emit heat.\n\nAnd we also know that, due to the heat emitted by the refrigerators, the universal level of entropy increases, and we know thereby a direction of time is equivalent to a refrigerator successfully freezing something.\n\nSimilarly, in order to create low-entropy (\"cold\") block header hashes, miners of Bitcoin must consume energy and emit heat.\nBitcoin miners then act similarly to Maxwell's Demon; they reject candidate blocks whose block header hashes are not \"cold enough\" (i.e. have entropy greater than the difficulty target), and only allow \"cold\" block headers to be broadcast over the blockchain.\n\nAnd since we know that:\n\n* The future is where the universal entropy is larger than the past.\n* Miners producing blocks must consume energy and emit waste heat (increasing universal entropy).\n\n...then we know that a longer proof-of-work header chain represents more actual physical time passing.\n\nProof-of-work is therefore also an unforgeable proof-of-time-passing.\n\nThus, all we need for a cryptographically-secure *measure of time* is a header chain.\n\nCrucially, this is better than SPV security, since we are only measuring the passage of time and do not particularly care about reorgs and the transactions in the block.\nThe longest chain wins, so the \"largest blockheight\" can only grow monotonically even if a reorg happens.\nEven if the transactions in a reorg are ultimately disconfirmed (double-spent), or turn out to be invalid, the Cryptographic Relay does not depend on their validity, it only cares about time passing in order to implement a timeout.\n\nThis is significantly better than having to implement a stable clock on the Cryptographic Relay to implement a timeout.\nClocks may drift, and the Cryptographic Relay might not want to tr\\*st external sources to give it a true notion of time.\nLoss of power supply may also cause the Cryptographic Relay to lose its clock as well.\nThus, it must use this cryptographic notion of time.\n\nGiving Cryptographic Relays a Notion of Time\n============================================\n\nIn order to implement timelocks, we can add an `nLockTime` field to ownership-transfer messages for the Cryptographic Relay.\n\nOn manufacturing a Cryptographic Relay, the manufacturer stores in unchangeable memory (e.g. burned diode non-erasable PROMs) the block header hash of a sufficiently-deep block (for example, one that has been buried for 6 or so difficulty adjustment periods), its blockheight, and the difficulty target for the adjustment period.\n\nIf the Cryptographic Relay receives an ownership-transfer message with `nLockTime` greater than this recorded block height, it demands a header chain rooted at the prerecorded block up to the specified `nLockTime`.\nIt then validates that the header chain has sufficient difficulty for each adjustment period covered, and also emulates the difficulty adjustment at appropriate blockheights.\nThis is sufficient proof to it that time has passed since its manufacture, as a header chain is a cryptographic proof of time passing.\n\nThis allows me to sell a cryptographic car to you, over Lightning, by this ritual:\n\n* First, we generate fresh keypairs and their combined MuSig pubkey.\n* We perform a MuSig signing operation, signing an ownership-transfer message with a future `nLockTime`, transferring ownership from the MuSig pubkey back to my unilateral pubkey.\n* I transfer control of the car to the MuSig pubkey.\n* We partially perform a second MuSig signing operation, signing an ownership-transfer message with a 0 `nLockTime`, transferring ownership from the MuSig pubkey back to you, but pausing after the `R` exchange.\n  * Specifically, after the `R` exchange, you generate the point corresponding to my share of the signature `s`, which you can get from my `R`, your `R`, my public key, and your public key, and the message we agreed on.\n* I generate an invoice for the above signature share point (i.e. pay for signature).\n* You pay the invoice, making sure that the maximum cltv-delta for the outgoing payment does not exceed the pre-agreed timeout (minus some time margin you deem safe).\n\nThen:\n\n* If you successfully pay the invoice (i.e. I release my share of the signature) you can now complete the signature for the transfer to your unilateral control.\n* If you are unable to pay the invoice, then once the future blockheight is reached, I download the Bitcoin block header chain and feed it and the backout ownership-transfer message to the car and regain control of my vehicle.\n\nThis provides Lightning-with-PTLCs compatibility (which we expect to be deployed on the network anyway), while still requiring relatively low resources on the Cryptographic Relay hardware (at the cost that timelocked backouts require much bandwidth; but since such backouts are expected to be rare, this may be an acceptable tradeoff).\n\nA Cryptographic Relay accepting this notion of time can continue to be used with Succinct Atomic Swaps, by using ownership-transfer messages with a 0 `nLockTime`, with the advantage that backouts need not download a block header chain to the Cryptographic Relay.\n\nA Case Against Blockchain Proliferation\n=======================================\n\nWe can argue that the Cryptographic Relay is a device tr\\*sted to actually do what we claim it does here.\nIn particular, its users tr\\*st that its manufacturer does not have a secret backdoor, a special public key recognized by every Cryptographic Relay by which the manufacturer can gain ownership of every piece of smart hardware in the world.\n\nThis may lead some to propose that a publicly-auditable blockchain can be used to manage the assignment of ownership of Cryptographic Relay devices.\nThat way, the source code that performs the ownership-assignment can be openly audited, and independent observers can check that the asset-assignment blockchain indeed works using the published source code by compiling it themselves and running it, and checking that it remains in synchrony with the asset-assignment blockchain.\n\nHowever, I should point out that merely because some blockchain somewhere considers asset X to be owned by pubkey Y, does not mean that the actual real-world asset X will have a control system that responds to pubkey Y.\n\nOr in other words, the manufacturer of the actual real-world asset X can still insert a secret backdoor that ignores the public asset-assignment blockchain anyway.\n\nAnd since blockchains are massive bandwidth hogs, we should avoid using them unless we gain some actual benefit.\n\nOn the other hand, the proposed Cryptographic Relay here is reasonably simple, requires no consensus system.\n\nThe best that can be done would be to standardize Cryptographic Relays and encourage multiple manufacturers to follow the same standard.\nSuch a standard would include communication protocols between the Cryptographic Relay and the controlling devices, but would also include details like voltage levels, current limits, normally-closed vs normally-open vs make-before-break SPDT/DPDT vs break-before-make SPDT/DPDT, physical dimensions of the package(s), etc.\n\nTr\\*st in manufacturers can be acquired, at very high expense, by using cut-and-choose: get a number of Cryptographic Relays, randomly select some of them, then open those and analyze if there are any backdoors, then utilize the rest if the randomly-opened ones do not have any discovered backdoors or other security issues.\n\nDelegated Operators\n===================\n\nAnother useful capability to add to Cryptographic Relays would be to allow adding operators, which are additional public keys that can turn it on or off, but cannot authorize a transfer of ownership or the addition of new operators.\n\nOnly the owner of the Cryptographic Relay can add or delete operators.\n\nFor example, suppose you, the buyer of my cryptographic car, represent a typical family share-owned between you and all of your husbands.\nThen when purchasing the car from me, you can transfer ownership of the car to a MuSig n-of-n between you and your husbands, rather than unilateral control of yourself.\n\nOf course, practically speaking, only one of you or your husbands can operate the car at once.\nThus, while the ownership of the vehicle is an n-of-n MuSig, you can assign individual keys of yourself and each of your husbands, as operators of the car.\n\nThe Cryptographic Relay would need to allocate a fixed amount of space for the number of allowed operators, thus imposing a practical limit on the number of husbands you can have simultaneously.\nUnfortunately, the Cryptographic Relay cannot store an arbitrary number of public keys, thus there are limits on the number of husbands a human can have.\n\nWhenever an ownership transfer is performed, all operators are deleted, thus preventing one of the previous operators attempting to start the car and drive it off even though it is semantically owned by someone else.\n\nA car purchased by an extended family, such as a company, might be owned by a k-of-n of the stakeholders of the company, and then employees of the company might be assigned as operators.\n\nPractical Deployment\n====================\n\nBy focusing on developing the most basic Cryptographic Relay, this provides us with a practical deployment for smart devices that can recognize their owner and be used only by the owner (and its delegated operators).\n\nIn particular, any existing non-smart electrical device can be modified post-warranty into a smart device that knows its owner, by adding a Cryptographic Relay hardware device somewhere along the path to its power supply.\nFor example, a Cryptographic Relay could replace a power switch, or be spliced onto the power cord.\n\nNow, of course such a jury-rigging could be easily bypassed, by simply splicing a wire across its terminals.\nSimilarly, many existing cars can be started without keys by hot-wiring.\nUltimately, the same can be said of almost any end-user appliance; possession remains 9/10ths of the law.\n\nA Cryptographic Relay is a simple device:\n\n* The design of the device is simple, requiring support for only a few operations.\n* The interface of the device is simple: it is only a switch, and easy to integrate into more complex applications.\n  The switch may be used as the route for the power supply, or it may be used simply for an electrical connection that is detected by some control system of the appliance to know whether it should act as \"on\" or \"off\".\n  This simplicity and generality allows simple interfacing with a variety of electrical devices.\n\nThe intent is that:\n\n* It is easy to implement and subsequently manufacture the device, so that risks of backdoors being installed by centralized manufacturers is mitigated by having multiple Cryptographic Relay manufacturers competing and incentivized to discover backdoors and other security failures of their competitors.\n* It is easy to integrate the device into the design of a more complex device intended for use by an end-user.\n  It is also easy to integrate the device, post-design, to a more complex existing device that did not include it.\n\nCollateralizing Cryptographic Relay Devices\n===========================================\n\nGiving Cryptographic Relays a notion of time allows them to be used in more complicated contracts.\n\nSuppose after purchasing the cryptographic car from me, you and your husbands find yourselves in tight financial straits.\nYou and your husbands might then want to take a loan from some entity.\n\nObviously, that entity will not simply loan out precious Bitcoins unless you promise to pay it back with *more* Bitcoins than what it gave out.\nAnd that entity might want to accept your cryptographic car as collateral for the loan, so that if you are unable to pay, the entity can partially recoup losses by reselling your cryptographic car.\n\nWith `SIGHASH_ANYPREVOUT` and Taproot, it becomes possible to trustlessly arrange a collateralized loan on the cryptographic car (to the extent the loan shark tr\\*sts that none of you or any of your husbands have replaced the Cryptographic Relay with a backdoored device, at least).\n\nThe loan shark arranges a loan in a multi-step process involving multiple PTLC-like constructions:\n\n* First, all of you (you and your husbands, and the loan shark) generate two fresh keypairs.\n  * Call the first the \"loan-out\" keypair.\n  * Call the second the \"loan-payback\" keypair.\n* You generate (but do not sign!) a command to transfer control of the car from you to a MuSig(you, your husbands ..., loan shark) using the \"loan-out\" pubkeys.\n* Generate the initial backout command, which transfers from the MuSig loan-out pubkey above, back to you and your husbands, but with an `nLockTime` in the future.\n  Get a complete signature for this command with the loan shark and your husbands and you.\n  * This backout timeout period should be short, and is needed only if the loan shark suddenly aborts before it hands over the loan to you.\n* Sign the transfer of the car from you to the MuSig loan-out and feed it to the car.\n* Generate (but do not sign!) the collateralization command, which transfers from the MuSig loan-out pubkey, to a new MusSig(you, your husbands ..., loan shark) using the \"loan-payback\" pubkeys.\n* Generate the collateral-claim command, which transfers from the MuSig loan-payback pubkey to the loan shark, but with an `nLockTime` a little after the due date of your loan.\n  Generate a complete signature for this command to the loan shark, which the loan shark will now hold and use in case you do not pay back the loan.\n* Generate the collateral-reclaim command, which transfers from the MuSig loan-payback pubkey back to you and your husbands.\n  Generate a partial signature for this command from you and your husbands, but with a missing share from the loan shark, and keep this partial signature.\n* Generate a Taproot address (called the loan-payback Taproot address) with two SCRIPT branches, with an internal public key equal to the loan-payback pubkey.\n  * One SCRIPT branch allows signing by the internal public key with `SIGHASH_ANYPREVOUT`.\n  * The other SCRIPT branch imposes a short `OP_CHECKSEQUENCEVERIFY` timeout, and claiming by the MuSig of you and your husbands.\n* Generate loan-payback Bitcoin transaction, which spends using a `SIGHASH_ANYPREVOUT` signature on the first branch of the above Taproot address, an amount equal to your loan plus interest, and sending unilateral control to the loan shark.\n  Demand an adaptor signature for this transaction, which would reveal to you the loan shark signature share of the collateral-reclaim command.\n  Then provide the signature shares for you and your husband to the loan shark.\n  * If the loan shark completes this signature and reclaims the loan plus interest, you learn the share to complete the collateral-reclaim command and thereby reclaim your car after paying back the loan.\n* Now the loan shark creates (but does not sign!) the loan-out transaction, which pays out the MuSig loan-out pubkey the amount being loaned.\n* Generate the loan-out-revert transaction, which spends the loan-out transaction and pays it back to the loan shark, but with an `nLockTime` in the future, nearer than the `nLockTime` of the initial backout command.\n  Sign this transaction with you and your husbands and the loan shark.\n* The loan shark generates a partial signature for the collateralization command, missing the shares from you and your husbands.\n* Generate the loan-out-claim transaction, which spends the loan-out transaction and pays it to you and your husbands.\n  The loan shark will demand an adaptor signature for this transaction, which lets it learn the sum of the missing signatures shares for the collateralization command.\n  Then the loan shark provides its share of the signature for the loan-out-claim transaction.\n* The loan shark signs the loan-out transaction and broadcasts it.\n* You now complete the signature for the loan-out-claim transaction and broadcast it.\n  The loan shark learns the missing signature shares for the collateralization command and performs it, locking your car into collateralization (where it cannot be transferred unless you, your husbands, and the loan shark agree).\n  With the loan-out-claim transaction valid, you can now take the loan.\n\nThen, if you are able to pay back the loan before the due date:\n\n* Send the loan amount plus interest, exactly, to the loan-payback Taproot address.\n* If the loan shark accepts the payback of the loan, it reanchors the loan-payback Bitcoin transaction and completes the signature, then claims the paid back loan.\n* With the loan-payback signature completed, you learn the partial signature needed to complete the signature for the collateral-reclaim command, and you can now feed it to the car and regain ownership over it.\n* If the loan shark does not accept payback of the loan, you can at least recover the loan and interest by the second branch of the loan-payback Taproot address.\n\nIf you are unable to pay back the loan:\n\n* The collateral-claim command becomes valid a little after the loan due date, and the loan shark takes unilateral possession of your car to recoup its losses.\n\nThe above uses onchain Bitcoins.\nSimilar setups may be possible over Lightning (there is no need for a `SIGHASH_ANYPREVOUT` in this case, as the loan shark may issue a long-lived invoice that lets you learn its signature share for the collateral-reclaim command signature)."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-21T01:27:27",
                "message_text_only": "Good morning list,\n\nAndy Schroder shared a mildly related link: http://andyschroder.com/DistributedCharge/\n\nThe above project does not use the Cryptographic Relay.\nBriefly, it is a rentable charging station for electric cars.\n\nI observed, however, that a rentable Cryptographic Relay device could be implemented using Cryptographic Relay features:\n\n* Support for MuSig (by use of Schnorr signatures).\n* Timelocks (by use of block header chains).\n* Delegated operators.\n\n> Suppose you own a Cryptographic Relay controlling a charger for electrical cars.\n> And I wish to rent this charger for some time so I can charge my electrical car.\n>\n> This rental contract can be done by this ritual:\n>\n> * We generate two fresh keypairs.\n>   * Call the first keypair the \"rent-transfer\" keypair.\n>   * Call the second keypair the \"rental-period\" keypair.\n> * You generate, but do not sign, a rent-transfer command to transfer ownership from your unilateral ownership to the MuSig of our rent-transfer keys.\n> * We generate an initial backout command to transfer ownership from the MuSig rent-transfer key back to your control, but with an `nLockTime` in the close future.\n>   We sign this command.\n> * We generate a rental-start command to transfer ownership from the MuSig rent-transfer key to our MuSig rental-period key.\n>   I create a partial signature, missing only your share.\n> * We generate a command to add me as a delegated operator of the device, authorized by the MuSig rental-period key.\n> * We generate a rental-end command to transfer ownership from the MuSig rental-period key, back to your unilateral control, with an `nLockTime` equal to the end of the rental period.\n>   We sign this command.\n> * Then, I create (but do not sign!) a rent-funding Bitcoin transaction for the rent, paying to the Musig rent-transfer key.\n> * We generate a rent-reclaim Bitcoin transaction spending the above rent-funding Bitcoin transaction, sending the funds back to my unilateral control, but with an `nLockTime` in the future but less than the timeout of the initial backout command.\n>   We sign this transaction.\n> * You sign the rent-transfer command and feed it to the device.\n> * We generate a rent-claim Bitcoin transaction spending the above rent-funding Bitcoin transaction, sending the funds to your unilateral control.\n>   I demand an adaptor signature, such that I can learn your share of the signature of the rental-start command.\n>   Then I provide a partial signature to you.\n> * You complete the rent-claim Bitcoin transaction signature, claiming the rental fee.\n> * I get the completed rental-start command signature and send it to the device, transferring ownership of the device to our MuSig rental-period pubkey.\n> * I send the command to add me as an operator of the device, letting me use the device as I see fit, but not transfer ownership to anyone else.\n> * When the rental period ends, you send the rental-end command to the device and turn it off so I can no longer use it.\n>\n> The above can probably also be done with the Bitcoin-side payments done via Lightning-with-PTLC.\n> It requires Taproot, but does not require `SIGHASH_ANYPREVOUT`.\n\nWe can also consider the case where the renter of the device wishes to return it early, for a partial refund of the total rent (or equivalently, for the renter to rent in units of smaller time and just extending the rental period as needed).\n\n> As the ownership of the device is in a 2-of-2 between the renter and the \"true owner\", they can, after having a meeting of minds, arrange for an early return command conditional on a partial refund of the original rent.\n> Again, there is simply a need for pay-for-signature, with the renter partial-signing a command to return the device ownership early, which if completed by the owner, completes the signature to refund the original rent.\n>\n> Alternately, the rent may pay for a short rental period, and to extend the rental period, the 2-of-2 between the nenter and \"true owner\" on the device is \"reseated\" (i.e. fresh keypairs to generate a fresh 2-of-2 are created and ownership transferred to the new 2-of-2) which invalidates the previous timeout, and moves to a later timeout.\n> The \"re-rental\" command which moves the ownership from the previous 2-of-2 to the next 2-of-2 is partially signed by the renter, and to complete the signature, the renter pays for the signature share from the owner.\n> (this is done after setting up the command to make the renter a delegated operator and the command to let the owner re-acquire unilateral ownership of the device, I elide those steps here.)\n> The pay-for-signature can be done over Lightning as well.\n\nNow, suppose the device being rented out is in fact a smart domicile, which can be locked/unlocked by the owner/operator of a Cryptographic Relay.\nTypically, when renting out domiciles, a deposit is involved, where:\n\n* The tenant pays out the rent plus the deposit.\n* The landlady may keep the deposit in case of egregious damage to (or other abuse of) the domicile.\n\nThe construction of a rent-with-deposit contract is actually similar to the construction of the earlier given collateralized loan:\n\n> * The \"loan shark\" position is taken up by the \"renter\".\n> * The \"loaner\" position is taken up by the \"landlady\" of the device being rented out.\n> * The \"loan shark\" also asks for a command to add them as a delegated operator of the device.\n> * Instead of the payback amount being larger than what the loan shark/renter pays to the loaner/landlady, it is smaller, with the lower payback amount representing the deposit.\n>\n> In this particular case, the contractors need not use `SIGHASH_ANYPREVOUT`, instead the landlady can give a PTLC on the deposit with the deposit being funded from the loan payout transaction (which would be a rent+deposit-payout transaction).\n\n(note: missing in the above is the detail that at the end of the contract period, ownership of the device goes back to the landlady/loaner position, as opposed to the collateralized-loan case where it goes to the loan shark position.)\n\nPerhaps smart contract languages should have PTLCs and partial signatures as primitives and be written in a compositional/declarative style, rather than some Turing-complete mess, because PTLCs are cool.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andy Schroder",
                "date": "2020-07-21T05:25:44",
                "message_text_only": "See multiple places below\n\n\nAndy Schroder\n\nOn 7/20/20 10:18 AM, ZmnSCPxj via bitcoin-dev wrote:\n> Introduction\n> ============\n>\n> An electrical relay is an electrically-controlled switch, often diagrammed as:\n>\n>        +-------------o\n>        |\n>        |   \\\n>        |    \\\n>        +--o  o-------o\n>\n>      o----  |\n>           ) |\n>           ) |\n>           ) |\n>      o----  |\n>\n> The terminals at the left feed into a coil.\n> When electricity passes through the coil, it magnetizes a core, and the magnetism attracts a switch into a closed position, which would let electricity to pass through the terminals at the right.\n> This can be used to \"turn on\" or supply power to a different electrical device.\n>\n> If no electricity is passing through the coil via the terminals on the left, then no electricity can pass through the terminals on the right, as the switch is an open position at default.\n>\n> This is a fairly simple logic circuitry, upon which more complicated circuitry can be made.\n>\n> Similarly, a Cryptographic Relay is a hardware electrical component that allows control of some electrical circuit.\n> It has two terminals which are the two terminals of a switch.\n> It can also be contacted, for example via Bluetooth, by an electronic computing device.\n> The Cryptographic Relay has a public key, which represents the current owner of the relay.\n> If the electronic device is able to provide a proof-of-knowledge of the private key (i.e. a signature) corresponding to the public key that the Cryptographic Relay knows, then it allows the switch to be controlled by that device.\n>\n> Motivation\n> ==========\n>\n> Suppose I have a car I wish to sell to you, for Bitcoins.\n> This car, as it happens, has a Cryptographic Relay: it will only start its engine if it gets a signed message from me using a private key I have on my phone.\n> It knows my public key, and will only turn off and on at my command.\n>\n> Now, you want to be able to know that by paying me Bitcoins, you get sole ownership of the car I am selling.\n>\n> This is in fact, nothing more than a swap operation.\n> I have an asset, a car, and you have an asset, some Bitcoins.\n> We want to atomically swap one asset for the other asset, and those assets do not exist in a single asset-assignment system.\n>\n> Paying Bitcoins For Cars Via Succinct Atomic Swaps\n> ==================================================\n>\n> Fortunately, there is an atomic swap operation, Succinct Atomic Swaps, which can be used to create an atomic swap between my car and your Bitcoins.\n>\n> An important part of this Succinct Atomic Swap is that all timeouts are only in one asset-assignment system.\n> The original Succinct Atomic Swap discussion gives an example of swapping Bitcoins for Litecoins.\n> Each has its own distinct blockchain, which is a distinct distributed asset-assignment system.\n>\n> A crucial part of the Succinct Atomic Swap is that all timelocks are only on one asset-assignment system.\n> The other asset-assignment system need not support anything other than assigning ownership of assets to (homomorphically additive) public keys.\n>\n> This is important as a major simplification of the Cryptographic Relay:\n> The relay only needs to know its *current owner*, and does not need to know the current time!\n>\n> Thus, in order for you to buy my car:\n>\n> * You set up the Succinct Atomic Swap on the Bitcoin blockchain.\n> * We generate fresh private keys, then combine them via MuSig, and I transfer the ownership of the car to that MuSig public key.\n> * If I claim the funds, that atomically reveals my share of the private key to you, so you can claim the car using your private key plus my share and transfer the car to sole control of you.\n> * If I fail to claim the funds, then when you reclaim your funds at timeout, that atomically reveals your share of the private key to me, so that I can claim the car using my private key plus your share and transfer the car back to sole control of me.\n>\n> This is in fact the same as the Succinct Atomic Swap example, except that instead of me swapping my Litecoins for your Bitcoins, I am swapping my Cryptographic Relay for your Bitcoins.\n>\n> Cryptographic Relay Operations\n> ==============================\n>\n> Thus, a Cryptographic Relay needs to support only the following basic operations.\n> These operations are triggered by its owner sending a message, plus a signature verifiable by the public key, to the Cryptographic Relay.\n> (Cryptographer warning: if using Schnorr, the message hashed into the signature also has to include the public key that is signing it, since BIP32 nonhardened derivation allows a Schnorr signature created by one child private key to be trivially malleated into a signature for the same message by a sibling private key; this does not exist in ECDSA due to its nonlinearity.\n> message sends need not include the public key, it can be added by the cryptographic relay since it has to know the public key of the owner anyway.\n> Of note is that the bip-340 description of Schnorr includes the public key in the hash operation of signatures as well, and does not require this.)\n>\n> The only operations necessary are:\n>\n> 1.  Turn on.\n> 2.  Turn off.\n> 3.  Transfer ownership to new pubkey ___.\n>\n> Due to Succinct Atomic Swaps not requiring any kind of timelock on one asset-assignment system, the Cryptographic Relay need not have any concept of time, as mentioned above, and transfer of ownership can be done by a simple message signed by the current owner transferring ownership to a new public key.\n>\n> (Cryptographer warning: turn-on/turn-off messages should be challenge-response: the Cryptographic Relay requests signing with a unique nonce included in the message, otherwise previous messages can be captured by third parties and replayed; ownership-transfer messages should probably also include a nonce, or otherwise we could require non-reuse of keys.\n> This can be implemented with a 64-bit incrementing nonce, which should work for the practical lifetime of any Cryptographic Relay.)\n>\n> (Cryptographer warning: similarly, ownership-transfer messages should probably be indexed as well with an incrementing nonce, otherwise key reuse would allow signature replay; similarly again, each Cryptographic Relay should have a UUID that is included in message hashes, as otherwise key reuse would allow signature replay for commands to one device to be repeated for another device.)\n>\n> Lightning\n> =========\n>\n> Unfortunately, it seems not possible to transport Succinct Atomic Swap constructions over the Lightning Network.\n>\n> Succinct Atomic Swaps have an asymmetric setup, unlike the traditional HTLC-based atomic swaps.\n> This asymmetry makes it difficult to reason about how a forwarding node on the Lightning Network would be able to accept a Succinct Atomic Swap and then send out another Succinct Atomic Swap.\n>\n> An observation to make is that the Bitcoin-side construction in the Succinct Atomic Swap description has the following branches:\n>\n> * B gets the money, and A learns a secret from B.\n> * After a timeout, A gets the money back, and B learns a secret from A.\n>\n> Unfortunately, the above construction, while instantiatable in a single channel (any absolute-timelock contract enforceable on a blockchain can be instantiated in a channel anchored in that blockchain), cannot be safely *forwarded* over the Lightning Network in a sequence of channels forming a route.\n>\n> This is because we need to have a different timeout at each forwarding hop, in order to allow a forwarding node enough time to discover an event and react accordingly.\n> This means that each forwarding node has to have a shorter timeout on its outgoing contract than its incoming contract.\n>\n> But in the half-Succinct-Atomic-Swap contract, the forwarding node needs to provide a secret in order to reclaim the funds at the timeout.\n> And it can only discover that secret at the later timeout of the incoming contract.\n> Thus, it is not safe for the forwarding node to forward any half-Succinct-Atomic-Swap contract.\n>\n> Thus, we either:\n>\n> * Prevent old, low-value cryptographic cars from being bought using Lightning, reducing their economic veolocity and preventing moon and lambos.\n> * OR, we give the Cryptographic Relay a notion of time which makes it compatible with PTLCs that can be routed over Lightning.\n>    In essence, the PTLC \"goes over one more hop\", this time transferring ownership of the Cryptographic Relay.\n>\n> A Cryptographic Notion of Time\n> ==============================\n>\n> Time stops for no one; it will not stop for thee.\n>\n> Or, in more science-appropriate terms: the passage of time is the direction in which universal entropy increases.\n>\n> Now, we can observe that block header hashes are, in fact, low-entropy.\n> This is because the higher bits of block header hashes are consistently 0; there are thus fewer bits of entropy you can extract from a block header hash.\n>\n> Now, we can observe that temperature is largely itself also an expression of entropy.\n> Higher-entropy areas are higher temperature, and lower-entropy areas are lower temperature\n\n, at constant pressure\n\n> .\n\nOr, at constant temperature, higher entropy areas have lower pressure \nand lower entropy areas have higher pressure. See the background contour \nof the figure on the bottom left here for an example with carbon dioxide:\n\nhttp://andyschroder.com/CO2Cycle/Explorer?DatasetNumber=1&0_ValueIndex=Optimal&HorizontalAxis=0&1_ValueIndex=Optimal&VerticalAxis=1&2_ValueIndex=Optimal&3_ValueIndex=Optimal&4_ValueIndex=Optimal&5_ValueIndex=0&6_ValueIndex=0&7_ValueIndex=0&8_ValueIndex=0&9_ValueIndex=0&10_ValueIndex=0&11_ValueIndex=0&12_ValueIndex=0&ContourValue=efficiency&LinePlotVerticalAxisValue=efficiency&CyclePlotVerticalAxis=Temperature&CyclePlotHorizontalAxis=Pressure&CyclePlotContourLevel=Entropy\n\n\n\n\n\n\n> Overall, the temperature differential across the universe decreases in the direction of future time.\n> However, it is possible to implement a sort of Maxwell's Demon.\n> Maxwell's Demon is an entity that guards a hole between two containers containing air.\n> If a high-speed, high-tempreature molecule of air on the left side approaches the hole, Maxwell's Demon magically swats it away, but if a similar high-speed, high-temperature molecule of air on the right side approaches the hole, Maxwell's Demon lets it pass.\n> It has the reverse policy for low-temperature molecules of air, letting it go from the left container to the right container.\n>\n> Over time, the temperature of the right container drops, because all the high-temperature molecules have been moved to the left container.\n>\n> Of course, we already have implementations of Maxwell's Demon.\n> We call such implementations \"refrigerators\".\nDon't know why I never thought of it this way!\n\n\n>\n> Refrigerators, to do their magic, must consume energy and emit heat.\n> Indeed, the total heat emitted by the refrigerator is much larger than the heat it removes in the cold part of the refrigerator.\n\nNot necessarily \"much larger\". For example, a good geothermal heat pump \nhas a COP greater than 8. That means 8 units of heat are removed for 1 \nunit of work input. That means that the total heat emitted by the \nrefrigerator is only (1-(8+1)/8) = 12.5% higher than the heat it removes \nfrom inside the refrigerator.\n\n\n\n\n\n> We can verify that the refrigerator is working, trivially, by checking that the supposedly-cold part of the refrigerator is indeed cold\nand it's temperature does not begin to rise over time.\n\n\n\n\n> But we know that refrigerators, to do their work, must consume\n\nmechanical\n\n> energy and emit heat.\n>\n> And we also know that, due to the heat emitted by the refrigerators, the universal level of entropy increases, and we know thereby a direction of time is equivalent to a refrigerator successfully freezing something.\n\nHowever, the entropy inside a chamber can still decrease if the pressure \ngoes up and heat is allowed to conduct away as the temperature tries to \ngo up. This however, also results in more work being input into the \nrefrigerator, which means it still consumes energy. Also, if you are \nokay with the temperature inside a chamber going up (instead of down), \nyou can consume energy and compress it adiabatically and the pressure \nwill rise and so will the entropy rise.\n\n\n\n\n\n> .\n>\n> Similarly, in order to create low-entropy (\"cold\") block header hashes, miners of Bitcoin must consume energy and emit heat.\n> Bitcoin miners then act similarly to Maxwell's Demon; they reject candidate blocks whose block header hashes are not \"cold enough\" (i.e. have entropy\n\nproduction\n\n\n>   greater than the difficulty target), and only allow \"cold\" block headers to be broadcast over the blockchain.\n\nBlocks freeze the transactions in place!\n\nOr, blocks compress transactions in place.\n\n>\n> And since we know that:\n>\n> * The future is where the universal entropy is larger than the past.\n> * Miners producing blocks must consume energy and emit waste heat (increasing universal entropy).\n>\n> ...then we know that a longer proof-of-work header chain represents more actual physical time passing.\n>\n> Proof-of-work is therefore also an unforgeable proof-of-time-passing.\n>\n> Thus, all we need for a cryptographically-secure *measure of time* is a header chain.\n>\n> Crucially, this is better than SPV security, since we are only measuring the passage of time and do not particularly care about reorgs and the transactions in the block.\n> The longest chain wins, so the \"largest blockheight\" can only grow monotonically even if a reorg happens.\n> Even if the transactions in a reorg are ultimately disconfirmed (double-spent), or turn out to be invalid, the Cryptographic Relay does not depend on their validity, it only cares about time passing in order to implement a timeout.\n>\n> This is significantly better than having to implement a stable clock on the Cryptographic Relay to implement a timeout.\n> Clocks may drift, and the Cryptographic Relay might not want to tr\\*st external sources to give it a true notion of time.\n> Loss of power supply may also cause the Cryptographic Relay to lose its clock as well.\n> Thus, it must use this cryptographic notion of time.\n\nVery interesting thought!\n\n>\n> Giving Cryptographic Relays a Notion of Time\n> ============================================\n>\n> In order to implement timelocks, we can add an `nLockTime` field to ownership-transfer messages for the Cryptographic Relay.\n>\n> On manufacturing a Cryptographic Relay, the manufacturer stores in unchangeable memory (e.g. burned diode non-erasable PROMs) the block header hash of a sufficiently-deep block (for example, one that has been buried for 6 or so difficulty adjustment periods), its blockheight, and the difficulty target for the adjustment period.\n>\n> If the Cryptographic Relay receives an ownership-transfer message with `nLockTime` greater than this recorded block height, it demands a header chain rooted at the prerecorded block up to the specified `nLockTime`.\n> It then validates that the header chain has sufficient difficulty for each adjustment period covered, and also emulates the difficulty adjustment at appropriate blockheights.\n> This is sufficient proof to it that time has passed since its manufacture, as a header chain is a cryptographic proof of time passing.\n>\n> This allows me to sell a cryptographic car to you, over Lightning, by this ritual:\n>\n> * First, we generate fresh keypairs and their combined MuSig pubkey.\n> * We perform a MuSig signing operation, signing an ownership-transfer message with a future `nLockTime`, transferring ownership from the MuSig pubkey back to my unilateral pubkey.\n> * I transfer control of the car to the MuSig pubkey.\n> * We partially perform a second MuSig signing operation, signing an ownership-transfer message with a 0 `nLockTime`, transferring ownership from the MuSig pubkey back to you, but pausing after the `R` exchange.\n>    * Specifically, after the `R` exchange, you generate the point corresponding to my share of the signature `s`, which you can get from my `R`, your `R`, my public key, and your public key, and the message we agreed on.\n> * I generate an invoice for the above signature share point (i.e. pay for signature).\n> * You pay the invoice, making sure that the maximum cltv-delta for the outgoing payment does not exceed the pre-agreed timeout (minus some time margin you deem safe).\n>\n> Then:\n>\n> * If you successfully pay the invoice (i.e. I release my share of the signature) you can now complete the signature for the transfer to your unilateral control.\n> * If you are unable to pay the invoice, then once the future blockheight is reached, I download the Bitcoin block header chain and feed it and the backout ownership-transfer message to the car and regain control of my vehicle.\n>\n> This provides Lightning-with-PTLCs compatibility (which we expect to be deployed on the network anyway), while still requiring relatively low resources on the Cryptographic Relay hardware (at the cost that timelocked backouts require much bandwidth; but since such backouts are expected to be rare, this may be an acceptable tradeoff).\n>\n> A Cryptographic Relay accepting this notion of time can continue to be used with Succinct Atomic Swaps, by using ownership-transfer messages with a 0 `nLockTime`, with the advantage that backouts need not download a block header chain to the Cryptographic Relay.\n>\n> A Case Against Blockchain Proliferation\n> =======================================\n>\n> We can argue that the Cryptographic Relay is a device tr\\*sted to actually do what we claim it does here.\n> In particular, its users tr\\*st that its manufacturer does not have a secret backdoor, a special public key recognized by every Cryptographic Relay by which the manufacturer can gain ownership of every piece of smart hardware in the world.\n>\n> This may lead some to propose that a publicly-auditable blockchain can be used to manage the assignment of ownership of Cryptographic Relay devices.\n> That way, the source code that performs the ownership-assignment can be openly audited, and independent observers can check that the asset-assignment blockchain indeed works using the published source code by compiling it themselves and running it, and checking that it remains in synchrony with the asset-assignment blockchain.\n>\n> However, I should point out that merely because some blockchain somewhere considers asset X to be owned by pubkey Y, does not mean that the actual real-world asset X will have a control system that responds to pubkey Y.\n>\n> Or in other words, the manufacturer of the actual real-world asset X can still insert a secret backdoor that ignores the public asset-assignment blockchain anyway.\nAnd you are saying below that risk can be mitigated if manufactures \nworking very hard to build up enough market share that there is enough \nauditing of their devices that appear to be honestly manufactured?\n\n\n\n>\n> And since blockchains are massive bandwidth hogs, we should avoid using them unless we gain some actual benefit.\n>\n> On the other hand, the proposed Cryptographic Relay here is reasonably simple, requires no consensus system.\n>\n> The best that can be done would be to standardize Cryptographic Relays and encourage multiple manufacturers to follow the same standard.\n> Such a standard would include communication protocols between the Cryptographic Relay and the controlling devices, but would also include details like voltage levels, current limits, normally-closed vs normally-open vs make-before-break SPDT/DPDT vs break-before-make SPDT/DPDT, physical dimensions of the package(s), etc.\n\nI would just keep it simple and stick with simple standards for \ntransistors and then let the user choose many of the parameters their \nown by supplying their own electro mechanical relay. Most I/O devices \nhave a transistor in them, then you need a booster transistor to add on \nit to it to get enough current in order to actually drive a relay coil. \nThis is more complicated for the end user, but gives them more flexibility.\n\n\n>\n> Tr\\*st in manufacturers can be acquired, at very high expense, by using cut-and-choose: get a number of Cryptographic Relays, randomly select some of them, then open those and analyze if there are any backdoors, then utilize the rest if the randomly-opened ones do not have any discovered backdoors or other security issues.\n>\n> Delegated Operators\n> ===================\n>\n> Another useful capability to add to Cryptographic Relays would be to allow adding operators, which are additional public keys that can turn it on or off, but cannot authorize a transfer of ownership or the addition of new operators.\n>\n> Only the owner of the Cryptographic Relay can add or delete operators.\n>\n> For example, suppose you, the buyer of my cryptographic car, represent a typical family share-owned between you and all of your husbands.\n> Then when purchasing the car from me, you can transfer ownership of the car to a MuSig n-of-n between you and your husbands, rather than unilateral control of yourself.\n>\n> Of course, practically speaking, only one of you or your husbands can operate the car at once.\n> Thus, while the ownership of the vehicle is an n-of-n MuSig, you can assign individual keys of yourself and each of your husbands, as operators of the car.\n>\n> The Cryptographic Relay would need to allocate a fixed amount of space for the number of allowed operators, thus imposing a practical limit on the number of husbands you can have simultaneously.\n> Unfortunately, the Cryptographic Relay cannot store an arbitrary number of public keys, thus there are limits on the number of husbands a human can have.\n>\n> Whenever an ownership transfer is performed, all operators are deleted, thus preventing one of the previous operators attempting to start the car and drive it off even though it is semantically owned by someone else.\n>\n> A car purchased by an extended family, such as a company, might be owned by a k-of-n of the stakeholders of the company, and then employees of the company might be assigned as operators.\n>\n> Practical Deployment\n> ====================\n>\n> By focusing on developing the most basic Cryptographic Relay, this provides us with a practical deployment for smart devices that can recognize their owner and be used only by the owner (and its delegated operators).\n>\n> In particular, any existing non-smart electrical device can be modified post-warranty into a smart device that knows its owner, by adding a Cryptographic Relay hardware device somewhere along the path to its power supply.\n> For example, a Cryptographic Relay could replace a power switch, or be spliced onto the power cord.\n>\n> Now, of course such a jury-rigging could be easily bypassed, by simply splicing a wire across its terminals.\n> Similarly, many existing cars can be started without keys by hot-wiring.\n> Ultimately, the same can be said of almost any end-user appliance; possession remains 9/10ths of the law.\n\n\nThis is true, but if the devices is complicated and interconnected \nenough, the cost to hot-wire may outweigh the gains of stealing the \ndevice. For example, in an electric car, the battery pack, inverter, \nmotor, charge controller, media computer, autopilot computer, bluetooth \nradio, cellular radio, FM radio, A/C compressor controller, drivetrain \ncoolant system controller, charge port controller, anti-lock brake \ncontroller, power window motors, door locks, ignition, etc. all were \nlocked together, it could become prohibitively expensive to hot wire \ngiven all those components would need to be removed from the vehicle and \na specific chip removed (which likely will be embedded). And, it's \ntrivial to \"bake in\" the \"cryptographic relays\" into every component \nduring the initial manufacturing process. So, the transfer of ownership \ncould need to by performed on all components simultaneously in order to \nsuccessfully sell/trade the vehicle in order for this transfer to be \nreally effective.\n\n\n\n\n\n>\n> A Cryptographic Relay is a simple device:\n>\n> * The design of the device is simple, requiring support for only a few operations.\n> * The interface of the device is simple: it is only a switch, and easy to integrate into more complex applications.\n>    The switch may be used as the route for the power supply, or it may be used simply for an electrical connection that is detected by some control system of the appliance to know whether it should act as \"on\" or \"off\".\n>    This simplicity and generality allows simple interfacing with a variety of electrical devices.\n>\n> The intent is that:\n>\n> * It is easy to implement and subsequently manufacture the device, so that risks of backdoors being installed by centralized manufacturers is mitigated by having multiple Cryptographic Relay manufacturers competing and incentivized to discover backdoors and other security failures of their competitors.\n> * It is easy to integrate the device into the design of a more complex device intended for use by an end-user.\n>    It is also easy to integrate the device, post-design, to a more complex existing device that did not include it.\n>\n> Collateralizing Cryptographic Relay Devices\n> ===========================================\n>\n> Giving Cryptographic Relays a notion of time allows them to be used in more complicated contracts.\n>\n> Suppose after purchasing the cryptographic car from me, you and your husbands find yourselves in tight financial straits.\n> You and your husbands might then want to take a loan from some entity.\n>\n> Obviously, that entity will not simply loan out precious Bitcoins unless you promise to pay it back with *more* Bitcoins than what it gave out.\n> And that entity might want to accept your cryptographic car as collateral for the loan, so that if you are unable to pay, the entity can partially recoup losses by reselling your cryptographic car.\n>\n> With `SIGHASH_ANYPREVOUT` and Taproot, it becomes possible to trustlessly arrange a collateralized loan on the cryptographic car (to the extent the loan shark tr\\*sts that none of you or any of your husbands have replaced the Cryptographic Relay with a backdoored device, at least).\n>\n> The loan shark arranges a loan in a multi-step process involving multiple PTLC-like constructions:\n>\n> * First, all of you (you and your husbands, and the loan shark) generate two fresh keypairs.\n>    * Call the first the \"loan-out\" keypair.\n>    * Call the second the \"loan-payback\" keypair.\n> * You generate (but do not sign!) a command to transfer control of the car from you to a MuSig(you, your husbands ..., loan shark) using the \"loan-out\" pubkeys.\n> * Generate the initial backout command, which transfers from the MuSig loan-out pubkey above, back to you and your husbands, but with an `nLockTime` in the future.\n>    Get a complete signature for this command with the loan shark and your husbands and you.\n>    * This backout timeout period should be short, and is needed only if the loan shark suddenly aborts before it hands over the loan to you.\n> * Sign the transfer of the car from you to the MuSig loan-out and feed it to the car.\n> * Generate (but do not sign!) the collateralization command, which transfers from the MuSig loan-out pubkey, to a new MusSig(you, your husbands ..., loan shark) using the \"loan-payback\" pubkeys.\n> * Generate the collateral-claim command, which transfers from the MuSig loan-payback pubkey to the loan shark, but with an `nLockTime` a little after the due date of your loan.\n>    Generate a complete signature for this command to the loan shark, which the loan shark will now hold and use in case you do not pay back the loan.\n> * Generate the collateral-reclaim command, which transfers from the MuSig loan-payback pubkey back to you and your husbands.\n>    Generate a partial signature for this command from you and your husbands, but with a missing share from the loan shark, and keep this partial signature.\n> * Generate a Taproot address (called the loan-payback Taproot address) with two SCRIPT branches, with an internal public key equal to the loan-payback pubkey.\n>    * One SCRIPT branch allows signing by the internal public key with `SIGHASH_ANYPREVOUT`.\n>    * The other SCRIPT branch imposes a short `OP_CHECKSEQUENCEVERIFY` timeout, and claiming by the MuSig of you and your husbands.\n> * Generate loan-payback Bitcoin transaction, which spends using a `SIGHASH_ANYPREVOUT` signature on the first branch of the above Taproot address, an amount equal to your loan plus interest, and sending unilateral control to the loan shark.\n>    Demand an adaptor signature for this transaction, which would reveal to you the loan shark signature share of the collateral-reclaim command.\n>    Then provide the signature shares for you and your husband to the loan shark.\n>    * If the loan shark completes this signature and reclaims the loan plus interest, you learn the share to complete the collateral-reclaim command and thereby reclaim your car after paying back the loan.\n> * Now the loan shark creates (but does not sign!) the loan-out transaction, which pays out the MuSig loan-out pubkey the amount being loaned.\n> * Generate the loan-out-revert transaction, which spends the loan-out transaction and pays it back to the loan shark, but with an `nLockTime` in the future, nearer than the `nLockTime` of the initial backout command.\n>    Sign this transaction with you and your husbands and the loan shark.\n> * The loan shark generates a partial signature for the collateralization command, missing the shares from you and your husbands.\n> * Generate the loan-out-claim transaction, which spends the loan-out transaction and pays it to you and your husbands.\n>    The loan shark will demand an adaptor signature for this transaction, which lets it learn the sum of the missing signatures shares for the collateralization command.\n>    Then the loan shark provides its share of the signature for the loan-out-claim transaction.\n> * The loan shark signs the loan-out transaction and broadcasts it.\n> * You now complete the signature for the loan-out-claim transaction and broadcast it.\n>    The loan shark learns the missing signature shares for the collateralization command and performs it, locking your car into collateralization (where it cannot be transferred unless you, your husbands, and the loan shark agree).\n>    With the loan-out-claim transaction valid, you can now take the loan.\n>\n> Then, if you are able to pay back the loan before the due date:\n>\n> * Send the loan amount plus interest, exactly, to the loan-payback Taproot address.\n> * If the loan shark accepts the payback of the loan, it reanchors the loan-payback Bitcoin transaction and completes the signature, then claims the paid back loan.\n> * With the loan-payback signature completed, you learn the partial signature needed to complete the signature for the collateral-reclaim command, and you can now feed it to the car and regain ownership over it.\n> * If the loan shark does not accept payback of the loan, you can at least recover the loan and interest by the second branch of the loan-payback Taproot address.\n>\n> If you are unable to pay back the loan:\n>\n> * The collateral-claim command becomes valid a little after the loan due date, and the loan shark takes unilateral possession of your car to recoup its losses.\n>\n> The above uses onchain Bitcoins.\n> Similar setups may be possible over Lightning (there is no need for a `SIGHASH_ANYPREVOUT` in this case, as the loan shark may issue a long-lived invoice that lets you learn its signature share for the collateral-reclaim command signature).\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-21T09:19:17",
                "message_text_only": "Good morning Andy,\n\n> > A Cryptographic Notion of Time\n> >\n> > ===============================\n> >\n> > Time stops for no one; it will not stop for thee.\n> > Or, in more science-appropriate terms: the passage of time is the direction in which universal entropy increases.\n> > Now, we can observe that block header hashes are, in fact, low-entropy.\n> > This is because the higher bits of block header hashes are consistently 0; there are thus fewer bits of entropy you can extract from a block header hash.\n> > Now, we can observe that temperature is largely itself also an expression of entropy.\n> > Higher-entropy areas are higher temperature, and lower-entropy areas are lower temperature\n>\n> , at constant pressure\n\nTrue.\n\n> > .\n>\n> Or, at constant temperature, higher entropy areas have lower pressure\n> and lower entropy areas have higher pressure. See the background contour\n> of the figure on the bottom left here for an example with carbon dioxide:\n>\n> http://andyschroder.com/CO2Cycle/Explorer?DatasetNumber=1&0_ValueIndex=Optimal&HorizontalAxis=0&1_ValueIndex=Optimal&VerticalAxis=1&2_ValueIndex=Optimal&3_ValueIndex=Optimal&4_ValueIndex=Optimal&5_ValueIndex=0&6_ValueIndex=0&7_ValueIndex=0&8_ValueIndex=0&9_ValueIndex=0&10_ValueIndex=0&11_ValueIndex=0&12_ValueIndex=0&ContourValue=efficiency&LinePlotVerticalAxisValue=efficiency&CyclePlotVerticalAxis=Temperature&CyclePlotHorizontalAxis=Pressure&CyclePlotContourLevel=Entropy\n\nYes, PVT relation.\n\n> > Overall, the temperature differential across the universe decreases in the direction of future time.\n> > However, it is possible to implement a sort of Maxwell's Demon.\n> > Maxwell's Demon is an entity that guards a hole between two containers containing air.\n> > If a high-speed, high-tempreature molecule of air on the left side approaches the hole, Maxwell's Demon magically swats it away, but if a similar high-speed, high-temperature molecule of air on the right side approaches the hole, Maxwell's Demon lets it pass.\n> > It has the reverse policy for low-temperature molecules of air, letting it go from the left container to the right container.\n> > Over time, the temperature of the right container drops, because all the high-temperature molecules have been moved to the left container.\n> > Of course, we already have implementations of Maxwell's Demon.\n> > We call such implementations \"refrigerators\".\n>\n> Don't know why I never thought of it this way!\n>\n\nYes.\n\n> > Refrigerators, to do their magic, must consume energy and emit heat.\n> > Indeed, the total heat emitted by the refrigerator is much larger than the heat it removes in the cold part of the refrigerator.\n>\n> Not necessarily \"much larger\". For example, a good geothermal heat pump\n> has a COP greater than 8. That means 8 units of heat are removed for 1\n> unit of work input. That means that the total heat emitted by the\n> refrigerator is only (1-(8+1)/8) = 12.5% higher than the heat it removes\n> from inside the refrigerator.\n>\n\nGranted.\nI am now investigating geothermal heat pumps in the context of taking over the world, thank you for your information.\n\n> > We can verify that the refrigerator is working, trivially, by checking that the supposedly-cold part of the refrigerator is indeed cold\n>\n> and it's temperature does not begin to rise over time.\n>\n> > But we know that refrigerators, to do their work, must consume\n>\n> mechanical\n>\n> > energy and emit heat.\n> > And we also know that, due to the heat emitted by the refrigerators, the universal level of entropy increases, and we know thereby a direction of time is equivalent to a refrigerator successfully freezing something.\n>\n> However, the entropy inside a chamber can still decrease if the pressure\n> goes up and heat is allowed to conduct away as the temperature tries to\n> go up. This however, also results in more work being input into the\n> refrigerator, which means it still consumes energy. Also, if you are\n> okay with the temperature inside a chamber going up (instead of down),\n> you can consume energy and compress it adiabatically and the pressure\n> will rise and so will the entropy rise.\n>\n> > .\n> > Similarly, in order to create low-entropy (\"cold\") block header hashes, miners of Bitcoin must consume energy and emit heat.\n> > Bitcoin miners then act similarly to Maxwell's Demon; they reject candidate blocks whose block header hashes are not \"cold enough\" (i.e. have entropy\n>\n> production\n>\n> > greater than the difficulty target), and only allow \"cold\" block headers to be broadcast over the blockchain.\n>\n> Blocks freeze the transactions in place!\n\nCertainly an interesting thought!\n\n>\n> Or, blocks compress transactions in place.\n>\n> > And since we know that:\n> >\n> > -   The future is where the universal entropy is larger than the past.\n> > -   Miners producing blocks must consume energy and emit waste heat (increasing universal entropy).\n> >\n> > ...then we know that a longer proof-of-work header chain represents more actual physical time passing.\n> > Proof-of-work is therefore also an unforgeable proof-of-time-passing.\n> > Thus, all we need for a cryptographically-secure measure of time is a header chain.\n> > Crucially, this is better than SPV security, since we are only measuring the passage of time and do not particularly care about reorgs and the transactions in the block.\n> > The longest chain wins, so the \"largest blockheight\" can only grow monotonically even if a reorg happens.\n> > Even if the transactions in a reorg are ultimately disconfirmed (double-spent), or turn out to be invalid, the Cryptographic Relay does not depend on their validity, it only cares about time passing in order to implement a timeout.\n> > This is significantly better than having to implement a stable clock on the Cryptographic Relay to implement a timeout.\n> > Clocks may drift, and the Cryptographic Relay might not want to tr\\*st external sources to give it a true notion of time.\n> > Loss of power supply may also cause the Cryptographic Relay to lose its clock as well.\n> > Thus, it must use this cryptographic notion of time.\n>\n> Very interesting thought!\n\nThank you very much.\n\n\n> > A Case Against Blockchain Proliferation\n> >\n> > ========================================\n> >\n> > We can argue that the Cryptographic Relay is a device tr\\*sted to actually do what we claim it does here.\n> > In particular, its users tr\\*st that its manufacturer does not have a secret backdoor, a special public key recognized by every Cryptographic Relay by which the manufacturer can gain ownership of every piece of smart hardware in the world.\n> > This may lead some to propose that a publicly-auditable blockchain can be used to manage the assignment of ownership of Cryptographic Relay devices.\n> > That way, the source code that performs the ownership-assignment can be openly audited, and independent observers can check that the asset-assignment blockchain indeed works using the published source code by compiling it themselves and running it, and checking that it remains in synchrony with the asset-assignment blockchain.\n> > However, I should point out that merely because some blockchain somewhere considers asset X to be owned by pubkey Y, does not mean that the actual real-world asset X will have a control system that responds to pubkey Y.\n> > Or in other words, the manufacturer of the actual real-world asset X can still insert a secret backdoor that ignores the public asset-assignment blockchain anyway.\n>\n> And you are saying below that risk can be mitigated if manufactures\n> working very hard to build up enough market share that there is enough\n> auditing of their devices that appear to be honestly manufactured?\n>\n\nPotentially.\nA lot of alternative blockchains that are designed for handling asset-assignment of real-world things, are far more centralized due to their non-generic nature: very few entities are interested in those spaces.\n\nA Cryptographic Relay demonstrates that we can do better, by making a generic component, and disposing of the blockchain, and shows that even in the \"blockchain for things!\" case, you *still have to trust manufacturers anyway*.\n\nAfter all, CPUs are commoditized enough that we hardly ever wonder if e.g. Intel or AMD or ARM have secreted backdoors into their CPUs.\nHopefully, Cryptographic Relays are commoditized enough as well that the probability of a manufacturer adding secret backdoors is low.\n\n> > And since blockchains are massive bandwidth hogs, we should avoid using them unless we gain some actual benefit.\n> > On the other hand, the proposed Cryptographic Relay here is reasonably simple, requires no consensus system.\n> > The best that can be done would be to standardize Cryptographic Relays and encourage multiple manufacturers to follow the same standard.\n> > Such a standard would include communication protocols between the Cryptographic Relay and the controlling devices, but would also include details like voltage levels, current limits, normally-closed vs normally-open vs make-before-break SPDT/DPDT vs break-before-make SPDT/DPDT, physical dimensions of the package(s), etc.\n>\n> I would just keep it simple and stick with simple standards for\n> transistors and then let the user choose many of the parameters their\n> own by supplying their own electro mechanical relay. Most I/O devices\n> have a transistor in them, then you need a booster transistor to add on\n> it to it to get enough current in order to actually drive a relay coil.\n> This is more complicated for the end user, but gives them more flexibility.\n\nI considered the \"relay\" interface to be better since a relay can be used as a (very slow) transistor, but if you want to transport say a 220V AC mains supply, you cannot use a transistor.\nThe slowness of relays (due to their mechanical nature) is acceptable since power-on and power-off events are expected to be rare compared to the operation of the device.\n\nFor example, a pre-existing non-cryptographic Smart TV can be upgraded into a cryptographic Smart TV by splicing a DPST Cryptographic Relay in its mains supply cord.\n(This voids warranty, but if warranty is already ended, might as well.)\n\nThat said, it is possible to start with a relay driver interface instead of a relay interface (though I prefer the latch-type relays due to their better mechanical longevity and lower continuous power use, which requires two relay driver interfaces and timing).\n\n> > Practical Deployment\n> >\n> > =====================\n> >\n> > By focusing on developing the most basic Cryptographic Relay, this provides us with a practical deployment for smart devices that can recognize their owner and be used only by the owner (and its delegated operators).\n> > In particular, any existing non-smart electrical device can be modified post-warranty into a smart device that knows its owner, by adding a Cryptographic Relay hardware device somewhere along the path to its power supply.\n> > For example, a Cryptographic Relay could replace a power switch, or be spliced onto the power cord.\n> > Now, of course such a jury-rigging could be easily bypassed, by simply splicing a wire across its terminals.\n> > Similarly, many existing cars can be started without keys by hot-wiring.\n> > Ultimately, the same can be said of almost any end-user appliance; possession remains 9/10ths of the law.\n>\n> This is true, but if the devices is complicated and interconnected\n> enough, the cost to hot-wire may outweigh the gains of stealing the\n> device. For example, in an electric car, the battery pack, inverter,\n> motor, charge controller, media computer, autopilot computer, bluetooth\n> radio, cellular radio, FM radio, A/C compressor controller, drivetrain\n> coolant system controller, charge port controller, anti-lock brake\n> controller, power window motors, door locks, ignition, etc. all were\n> locked together, it could become prohibitively expensive to hot wire\n> given all those components would need to be removed from the vehicle and\n> a specific chip removed (which likely will be embedded). And, it's\n> trivial to \"bake in\" the \"cryptographic relays\" into every component\n> during the initial manufacturing process. So, the transfer of ownership\n> could need to by performed on all components simultaneously in order to\n> successfully sell/trade the vehicle in order for this transfer to be\n> really effective.\n\nIndeed, that would be possible.\n\nThough note that if I am trying to abscond with an electric car, all I need to *hot*wire would be the battery pack, inverter, motor, and ignition.\nAfter absconding the electric car and placing it in a location I control, I can crack (i.e. splice wires across) the Cryptographic Relays of the other components at my leisure.\n\nThus, this post is simply a prelude to me becoming the next protagonist of Fast and Furious.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "The Cryptographic Relay: An Electrical Device For Smart Transferable Hardware",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Andy Schroder"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 78397
        }
    },
    {
        "title": "[bitcoin-dev] Implementing Investment Aggregation",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-21T03:40:07",
                "message_text_only": "Introduction\n============\n\nIn a capitalist economic system, it is allowed for an entity to lend money out to another entity, as long as both agree upon the conditions of the loan: how long, how much interest, any collateral, etc.\nThis is a simple extension of basic capitalist economic thinking: that the owner of funds or other capital, is the one who should decide how to utilize (or not utilize) that capital, including the decision to lend (or not lend).\n\nIt has been observed as well that groups of people may have relatively small savings that they can afford to put into investment (i.e. loaning out for an interest rate), but as the technological capabilities of our shared civilization have expanded, the required capital to create new businesses or expand existing ones have grown much larger than most single individuals can invest in.\n\nThus, coordinators that aggregate the savings of multiple individuals, and then lend them out for interest to new or expanding businesses, have also arisen, in order to take advantage of the larger return-on-investment of more capital-intensive but high-technology businesses, capturing the long tail of small investors.\nTraditionally, we call these coordinators \"banks\".\n\nHowever, this typically involves delegating the work of judging whether a business proposal is likely to give a return on investment, or not, to the coordinator itself.\nFurther, the coordinator typically acts as a custodian of the funds, thus adding the risk of custodial default to the small-time investors in addition to loan default.\n(In this view-point, central banks that provide fiscal insurance in case of loan default by printing new money, are no different from custodial default, as they degrade the monetary base in doing so.)\n\nThis writeup proposes the use of features that we expect to deploy at some point in the future, to allow for a non-custodial coordinator of multiple small investors.\n\nThis is not a decentralized system, as there is a coordinator; however, as the coordinator is non-custodial, and takes on the risk of default as well, the risk is reduced relative to a centralized custodial solution.\n\nNote that custodiality is probably a much bigger risk than centralization, and a centralized non-custodial probably has fewer risks than a decentralized custodial setup.\nIn particular, a decentralized custodial setup can be emulated by a centralized custodial setup using sockpuppets, and without any decent sybil protection (which can be too expensive and price out investments by the long tail of small investors, thus leading to centralization amongst a few large investors anyway), is likely no better than a centralized custodial setup.\nFocusing on non-custodiality rather than decentralization may be a better option in general.\n\nA group of small investors may very well elect a coordinator, and since each investor remains in control of its funds until it is transferred to the lendee, the coordinator has no special power beyond what it has as one of the small investors anyway, thus keeping decentralization in spirit if not in form.\n\nNon-custodial Investment Aggregation\n====================================\n\nIn principle, if a small investor finds a potentially-lucrative business that needs capital to start or expand its operation, and promises to return the loaned capital with interest later, then that small investor need not store its money with anyone else: it could just deal with the business itself directly.\n\nHowever, the small investor still needs to determine, for itself, whether the business is expected to be lucrative, and that the expected return on investment is positive (i.e. the probability of non-default times (1 plus interest rate) is greater than 1, and the absolute probability of non-default fits its risk profile).\nWe will not attempt to fix this problem here, only the requirement (as with the current banking system) to trust some bank **in addition to** trusting the businesses that are taking on loans to start/expand their business.\n\n(again: not your keys not your coins applies, as always; investors are taking on risk of default.)\n\nThe coordinator need only do something as simple as find a sufficiently large set of entities that are willing to indicate their Bitcoin UTXOs as being earmarked for investment in a particular business.\n\nThe coordinator, upon finding such a set, can then create a transaction spending those UTXOs and paying unilaterally to the business taking the loan.\nThe business provides proof that the destination address is under its unilateral control (so that investors know that they only need to trust that the business itself will do everything in its power to succeed and pay back the loan, without having additional trust in the coordinator to hold their funds in custody).\nThen the individual investors sign the transaction, releasing their funds to the business.\n\nHowever, the issue now arises: suppose the business succeeds and is able to pay back its loan.\nHow does the business pay back the loan?\n\nThus, prior to the investors ever signing the loan-out transaction, they first prepare a loan-payback transaction.\nThis loan-payback transaction spends from a multisignature of all the investors, equal in value to the loan amount plus agreed-upon interest, and distributes the money to each of the involved investors.\nCrucially, this loan-payback transaction is signed with a `SIGHASH_ANYPREVOUT` signature.\n\nNow, in order for the business to pay back its loan, it only needs to gather enough Bitcoins to pay back the loan, and pay back the exact amount to the multisignature address of the investors.\nThen, any of the investors can reclaim their funds, plus interest, by re-anchoring the loan-payback transaction to this transaction output and broadcasting it.\n\nThe coordinator, for its services, may extract a fee from the loan-payback transaction that all the investors can agree to; thus, it takes on as well the risk of default by the business (the coordinator exerts effort to locate investors and encourage them to invest, and would lose the fee paid for its efforts if the business it is proposing as a good investment does not pay back), which seems appropriate if it also serves as a basic filter against bad business investments.\nFinally, by working in Bitcoin, it cannot have a lender of last resort, and thus must evaluate possible business investments as accurately as possible (as default risks its fee earnings).\n\n(investors also need to consider the possibility that the purported \"business\" is really a sockpuppet of the coordinator; the investors should also evaluate this when considering whether to invest in the business or not, as part of risk of default.)\n\n(the above risk is mitigated somewhat if the investors identify the business first, then elect a coordinator to handle all the \"paperwork\" (txes, transporting signatures/PSBTs, etc.) by drawing lots.)\n\nThus, ***if*** the business is actually able to pay back its loan, the coordinator is never in custodial possession of funds.\n\nCross-business Aggregation\n==========================\n\nNothing in the above setup really changes if the investors would prefer to spread their risk by investing sub-sections of their savings into multiple different businesses.\nThis gives somewhat lower expected returns, but gives some protection against complete loss, allowing individual investors to adjust their risk exposure and their desired expected returns.\n\nThe batch transaction that aggregates the allocated UTXOs of the investors can pay out to multiple borrowing businesses.\nAnd each business can be given a loan-payback address, which is controlled by the investors that extended their loans.\nInvestors generate an aggregate loan-payback transaction and signature for each business they invest in.\n\nCollateralized Loans\n====================\n\nAs observed in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-July/018053.html, a Cryptographic Relay would allow collateralized loans.\n\nNothing prevents the \"loan shark\" in the collateralized loan example from being a MuSig of multiple small investors.\nPractically, a coordinator would help facilitate construction of the necessary transactions and interaction with the loanee, but as long as ownership remains controlled by the individual investors, there should not be any custodial issues.\n\nOf course, if the loan defaults, then the collateral needs to be sold in order to recoup the loss incurred in loan default case.\nCoordinating this sale amongst the multiple small investors is now potentially harder.\n\nAn additional service may be willing to pre-allocate Bitcoin funds into a timelocked contract, where the amount can be claimed conditional on transfer of the ownership of the collateral to the service in the future, or if the fund is not so claimed, to be returned to the service with the collateral not claimed (as it might have been reclaimed by the loaner after successfully paying back its loan).\nThis additional service earns by arbitraging the time preference: in case of default, the investors would prefer to recoup their financial losses quickly, while the service is now in possession of the collateral that it can resell later at a higher rate.\n\nNote that these are all operations that traditional banks perform; again, this idea simply removes the necessity for custodial holding of funds, in the way traditional banks do."
            },
            {
                "author": "esnierde",
                "date": "2020-07-21T05:23:00",
                "message_text_only": "Good Day ZmnSCPxj,\n\nThanks for sharing the idea! I read through the doc and have some concerns\nthat might be off the topic or outside the scope. Please bear with me.\n\nThe traditional banking system provides more than custodial holding of\nfunds in terms of lending & borrowing. One important function is to match\nlong term investments with short or variable term deposits. Alice might be\nwilling to make investments at time 0, but some emergency occurs and she\nmay need (part of) her bitcoins back at time 1 before the loan due date.\n\nAlso, in the banking system, there are usually sophisticated risk analysis\nsystems covering formulas, due diligence, and funds for loan defaults.\nBanks can reinvest partial of what they namely have and obtain profits to\ncover possible losses when borrowers cannot pay back 100%. In this way,\nthey are more resilient to defaults & change of collaterals' value, and\nborrowers might be able to leverage 1 unit worth of collateral to get 3\nunits fund instead of 1.\n\nThank you,\nHilda\n\nOn Mon, 20 Jul 2020 at 23:40, ZmnSCPxj via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Introduction\n> ============\n>\n> In a capitalist economic system, it is allowed for an entity to lend money\n> out to another entity, as long as both agree upon the conditions of the\n> loan: how long, how much interest, any collateral, etc.\n> This is a simple extension of basic capitalist economic thinking: that the\n> owner of funds or other capital, is the one who should decide how to\n> utilize (or not utilize) that capital, including the decision to lend (or\n> not lend).\n>\n> It has been observed as well that groups of people may have relatively\n> small savings that they can afford to put into investment (i.e. loaning out\n> for an interest rate), but as the technological capabilities of our shared\n> civilization have expanded, the required capital to create new businesses\n> or expand existing ones have grown much larger than most single individuals\n> can invest in.\n>\n> Thus, coordinators that aggregate the savings of multiple individuals, and\n> then lend them out for interest to new or expanding businesses, have also\n> arisen, in order to take advantage of the larger return-on-investment of\n> more capital-intensive but high-technology businesses, capturing the long\n> tail of small investors.\n> Traditionally, we call these coordinators \"banks\".\n>\n> However, this typically involves delegating the work of judging whether a\n> business proposal is likely to give a return on investment, or not, to the\n> coordinator itself.\n> Further, the coordinator typically acts as a custodian of the funds, thus\n> adding the risk of custodial default to the small-time investors in\n> addition to loan default.\n> (In this view-point, central banks that provide fiscal insurance in case\n> of loan default by printing new money, are no different from custodial\n> default, as they degrade the monetary base in doing so.)\n>\n> This writeup proposes the use of features that we expect to deploy at some\n> point in the future, to allow for a non-custodial coordinator of multiple\n> small investors.\n>\n> This is not a decentralized system, as there is a coordinator; however, as\n> the coordinator is non-custodial, and takes on the risk of default as well,\n> the risk is reduced relative to a centralized custodial solution.\n>\n> Note that custodiality is probably a much bigger risk than centralization,\n> and a centralized non-custodial probably has fewer risks than a\n> decentralized custodial setup.\n> In particular, a decentralized custodial setup can be emulated by a\n> centralized custodial setup using sockpuppets, and without any decent sybil\n> protection (which can be too expensive and price out investments by the\n> long tail of small investors, thus leading to centralization amongst a few\n> large investors anyway), is likely no better than a centralized custodial\n> setup.\n> Focusing on non-custodiality rather than decentralization may be a better\n> option in general.\n>\n> A group of small investors may very well elect a coordinator, and since\n> each investor remains in control of its funds until it is transferred to\n> the lendee, the coordinator has no special power beyond what it has as one\n> of the small investors anyway, thus keeping decentralization in spirit if\n> not in form.\n>\n> Non-custodial Investment Aggregation\n> ====================================\n>\n> In principle, if a small investor finds a potentially-lucrative business\n> that needs capital to start or expand its operation, and promises to return\n> the loaned capital with interest later, then that small investor need not\n> store its money with anyone else: it could just deal with the business\n> itself directly.\n>\n> However, the small investor still needs to determine, for itself, whether\n> the business is expected to be lucrative, and that the expected return on\n> investment is positive (i.e. the probability of non-default times (1 plus\n> interest rate) is greater than 1, and the absolute probability of\n> non-default fits its risk profile).\n> We will not attempt to fix this problem here, only the requirement (as\n> with the current banking system) to trust some bank **in addition to**\n> trusting the businesses that are taking on loans to start/expand their\n> business.\n>\n> (again: not your keys not your coins applies, as always; investors are\n> taking on risk of default.)\n>\n> The coordinator need only do something as simple as find a sufficiently\n> large set of entities that are willing to indicate their Bitcoin UTXOs as\n> being earmarked for investment in a particular business.\n>\n> The coordinator, upon finding such a set, can then create a transaction\n> spending those UTXOs and paying unilaterally to the business taking the\n> loan.\n> The business provides proof that the destination address is under its\n> unilateral control (so that investors know that they only need to trust\n> that the business itself will do everything in its power to succeed and pay\n> back the loan, without having additional trust in the coordinator to hold\n> their funds in custody).\n> Then the individual investors sign the transaction, releasing their funds\n> to the business.\n>\n> However, the issue now arises: suppose the business succeeds and is able\n> to pay back its loan.\n> How does the business pay back the loan?\n>\n> Thus, prior to the investors ever signing the loan-out transaction, they\n> first prepare a loan-payback transaction.\n> This loan-payback transaction spends from a multisignature of all the\n> investors, equal in value to the loan amount plus agreed-upon interest, and\n> distributes the money to each of the involved investors.\n> Crucially, this loan-payback transaction is signed with a\n> `SIGHASH_ANYPREVOUT` signature.\n>\n> Now, in order for the business to pay back its loan, it only needs to\n> gather enough Bitcoins to pay back the loan, and pay back the exact amount\n> to the multisignature address of the investors.\n> Then, any of the investors can reclaim their funds, plus interest, by\n> re-anchoring the loan-payback transaction to this transaction output and\n> broadcasting it.\n>\n> The coordinator, for its services, may extract a fee from the loan-payback\n> transaction that all the investors can agree to; thus, it takes on as well\n> the risk of default by the business (the coordinator exerts effort to\n> locate investors and encourage them to invest, and would lose the fee paid\n> for its efforts if the business it is proposing as a good investment does\n> not pay back), which seems appropriate if it also serves as a basic filter\n> against bad business investments.\n> Finally, by working in Bitcoin, it cannot have a lender of last resort,\n> and thus must evaluate possible business investments as accurately as\n> possible (as default risks its fee earnings).\n>\n> (investors also need to consider the possibility that the purported\n> \"business\" is really a sockpuppet of the coordinator; the investors should\n> also evaluate this when considering whether to invest in the business or\n> not, as part of risk of default.)\n>\n> (the above risk is mitigated somewhat if the investors identify the\n> business first, then elect a coordinator to handle all the \"paperwork\"\n> (txes, transporting signatures/PSBTs, etc.) by drawing lots.)\n>\n> Thus, ***if*** the business is actually able to pay back its loan, the\n> coordinator is never in custodial possession of funds.\n>\n> Cross-business Aggregation\n> ==========================\n>\n> Nothing in the above setup really changes if the investors would prefer to\n> spread their risk by investing sub-sections of their savings into multiple\n> different businesses.\n> This gives somewhat lower expected returns, but gives some protection\n> against complete loss, allowing individual investors to adjust their risk\n> exposure and their desired expected returns.\n>\n> The batch transaction that aggregates the allocated UTXOs of the investors\n> can pay out to multiple borrowing businesses.\n> And each business can be given a loan-payback address, which is controlled\n> by the investors that extended their loans.\n> Investors generate an aggregate loan-payback transaction and signature for\n> each business they invest in.\n>\n> Collateralized Loans\n> ====================\n>\n> As observed in\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-July/018053.html,\n> a Cryptographic Relay would allow collateralized loans.\n>\n> Nothing prevents the \"loan shark\" in the collateralized loan example from\n> being a MuSig of multiple small investors.\n> Practically, a coordinator would help facilitate construction of the\n> necessary transactions and interaction with the loanee, but as long as\n> ownership remains controlled by the individual investors, there should not\n> be any custodial issues.\n>\n> Of course, if the loan defaults, then the collateral needs to be sold in\n> order to recoup the loss incurred in loan default case.\n> Coordinating this sale amongst the multiple small investors is now\n> potentially harder.\n>\n> An additional service may be willing to pre-allocate Bitcoin funds into a\n> timelocked contract, where the amount can be claimed conditional on\n> transfer of the ownership of the collateral to the service in the future,\n> or if the fund is not so claimed, to be returned to the service with the\n> collateral not claimed (as it might have been reclaimed by the loaner after\n> successfully paying back its loan).\n> This additional service earns by arbitraging the time preference: in case\n> of default, the investors would prefer to recoup their financial losses\n> quickly, while the service is now in possession of the collateral that it\n> can resell later at a higher rate.\n>\n> Note that these are all operations that traditional banks perform; again,\n> this idea simply removes the necessity for custodial holding of funds, in\n> the way traditional banks do.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200721/9eab96b7/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-07-21T16:28:03",
                "message_text_only": "Good morning Hilda,\n\n> Good Day ZmnSCPxj,\n>\n> Thanks for sharing the\u00a0idea! I read through the\u00a0doc and have some concerns that might be off the topic or outside the scope. Please bear with me.\n>\n> The traditional banking system provides more than custodial holding of funds in terms of lending & borrowing. One important function is to match long term investments with short or variable term deposits. Alice might be willing to make investments at time 0, but some emergency occurs and she may need (part of) her bitcoins back at time 1 before the loan due\u00a0date.\u00a0\n\nThis may be possible by using a Decker-Russell-Osuntokun (\"eltoo\") mechanism.\n\nThe laon-payback transaction (the one that is signed with `SIGHASH_ANYPREVOUT`) can, instead of paying out directly to the investors, pay out to a Decker-Russell-Osuntokun mechanism that is signed by a MuSig of the investors plus the coordinator.\n\nThe initial state of this mechanism is the payouts of each investor, in proportion to the amounts they lent out.\nThus, if none of the investors need to liquidate early, this initial state is what gets posted on the blockchain ***if*** the loaning business successfully pays back / does not default.\n\nIf one of the investors needs to liquidate its position in this loan agreement, the coordinator can offer to buy its position (in whole or in part) for a smaller amount (as the coordinator takes on more risk).\nThen all the investors plus the coordinator sign a new state of the Decker-Russell-Osuntokun mechanism, with the coordinator getting more funds, and the liquidating investor losing all or part of its allocation.\nThe investor doing the liquidation can demand a pay-for-signature, so that its signature share of the new state is only acquired by the coordinator if and only if it actually gets paid with Bitcoins now.\n\nThe position need not be bought by the coordinator --- one of the other small investors in the business can \"double down\" and purchase more of the share of the eventual loan-payback by the same mechanism, from peer investors who need to liquidate their position in the loan-payback early, increasing its risk exposure but potentially getting even more profit in case the invested business pays back the loan.\n\n\n>\n> Also, in the banking system, there are usually sophisticated risk analysis systems covering formulas, due diligence, and funds for loan defaults. Banks can reinvest partial of what they namely have and obtain profits to cover possible losses when borrowers cannot pay back 100%. In this way, they are more resilient to defaults & change of collaterals' value, and borrowers might be able to leverage 1 unit worth of collateral to get 3 units fund instead of 1.\u00a0\n\nSimilar constructions could be done by the coordinator and / or the investors directly; unfortunately I know too little of them to give an idea how this can be done.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Implementing Investment Aggregation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "esnierde"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 23521
        }
    },
    {
        "title": "[bitcoin-dev] Seeking Tech Review of \"Learning Bitcoin from the Command Line\"",
        "thread_messages": [
            {
                "author": "Christopher Allen",
                "date": "2020-07-23T01:52:41",
                "message_text_only": "Dear Bitcoin Experts,\n\nLearning Bitcoin from the Command Line\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/>\nwas one of Blockchain Common <https://www.BlockchainCommons.com>'s first\nofferings, and it remains one of the most popular. Not only has it received\non Github over 100 watches, 300 forks, and 1200 stars, but we also know of\na number of people who learned how to program Bitcoin from the course and\nhave become full-time developers in our community or have joined your ranks\nas bitcoin-core contributors.\n\nWe think that it's a unique course precisely because of its command-line\nfocus, which makes it \"intermediate\" between the introductory courses and\nthe more intense summer workshop and internships for bitcoin development.\n\nIn the course, we teach the fundamental RPC commands for interacting with\nBitcoin Core, primarily using the bitcoin-cli command line, but also with\nlater in the course curl and via other programming languages via RPC. By\ndoing so, we provide a nuts-and-bolts guide to the functionality of\nBitcoin that\nreally teaches how it works, and so will continue to be useful even if\nreaders choose to move on to higher levels of abstraction that hide some of\nthe Bitcoin fundamentals.\n\nWe're hoping that we can get your help in reviewing the core material\nmaking up our newest iteration of this course:\nhttps://github.com/BlockchainCommons/Learning-Bitcoin\n-from-the-Command-Line/blob/master/README.md\n\nThe majority of the original work on Learning Bitcoin was done in 2017, and\ndespite some interim updates, by the start of this year, it had become\noutdated due to the rapid state of Bitcoin development. We've been\nexpending effort in the last few months to update all of our existing\nexamples, to change out commands that have been deprecated or defaults\nchanged to ensure that the outputs that students see match what they'd get\nfrom the command line.\n\nIn addition to updating the old course, we've also added major new sections\non descriptors\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/03_5_Understanding_the_Descriptor.md>\n, Segwit\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/04_6_Creating_a_Segwit_Transaction.md>,\nP2WPKH\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/09_5_Scripting_a_P2WPKH.md>,\nand Segwit Scripting\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/10_5_Scripting_a_Segwit_Script.md>\nand\nwhole new chapters on PSBTs\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/07_0_Expanding_Bitcoin_Transactions_PSBTs.md>\n(including\nHWI) and Tor\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/blob/master/14_0_Using_Tor.md>.\nWe think that what we have is some of the most accessible explanatory\nmatter available for these new topics at this intermediate level.\n\nWe'd love to get your comments on the whole front part of the course, from\nChapter 0 to 14. That's the complete, finished material on all of\n`bitcoin-cli` and Bitcoin Scripting.\n\nHowever, if you have limited time, the sections and chapters linked above\nare the newest and rawest material in the course, and so those are the ones\nthat we'd like fact-checked the most. Either way, please feel free to\nreport out thoughts, comments, and corrections on the issues page\n<https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line/issues>\nor\nto enter PRs for specific corrections.\n\nIf you don't have time for that either, we are also looking for financial\nsupport to continue this project. Blockchain Commons has already paid out\nof pocket for this initial work, as open infrastructure to improve the\nblockchain community, but we need to be able to complete this project,\nwhich involves putting together chapters 15 and up on interacting with\nBitcoin RPC using more programming languages (C, C++, Python, Go, Rust\nSwift), using LibWally, and onward to using Lightning. (We've got scattered\nmaterial for most of these sections right now, but they are very early\ndrafts and still need to be finished, standardized, and polished.)\n\nYou can also support Learning Bitcoin by becoming an ongoing patron for\nBlockchain Commons through Github at\nhttps://github.com/sponsors/BlockchainCommons, starting at $20 a month.\nThis will both help fund Learning Bitcoin and in the future will support\nother projects intended to improve blockchain and cryptocurrency\ninfrastructure, such as #SmartCustody, Bitcoin Standup, LetheKit,\ncryptographic libraries and more. A number of bitcoin-core contributors\nalready have their \"badge\" of support listed on our Sponsors' page, add\nyours!\n\nAlternatively, we can accept one-time Bitcoin contributions directly at our\nBTCPay server: https://btcpay.blockchaincommons.com/\n\nThank you for your help!\n\nChristopher Allen\nPrincipale Architect & Executive Director\nBlockchain Commons\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200722/a17a0187/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Seeking Tech Review of \"Learning Bitcoin from the Command Line\"",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5172
        }
    },
    {
        "title": "[bitcoin-dev] Signet update",
        "thread_messages": [
            {
                "author": "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3",
                "date": "2020-07-27T02:35:42",
                "message_text_only": "Hello,\n\nSome progress (courtesy of ajtowns!) has been made on the Signet\nproposal (BIP-325):\n\n* Block signatures are now verified as transactions\n\nAmong other things, this means Signet is (probably) compatible with\nPSBT (thanks sipa!), and no longer requires the custom \"simple\nsignature verifier/creator\" stuff.\n\nThis unfortunately means Signet will hard fork, but I don't think\nanyone is using it seriously yet, so it shouldn't be an issue.\n\nThe BIP pull request is here: https://github.com/bitcoin/bips/pull/947\n\nFeedback welcome."
            }
        ],
        "thread_summary": {
            "title": "Signet update",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 533
        }
    },
    {
        "title": "[bitcoin-dev] Minsc, a Miniscript-based scripting language",
        "thread_messages": [
            {
                "author": "Nadav Ivgi",
                "date": "2020-07-29T15:10:42",
                "message_text_only": "Hi all,\n\nI recently released Minsc, a high-level scripting language for expressing\nBitcoin Script spending conditions using a simple and familiar syntax.\n\nMinsc is based on the Miniscript Policy language, with additional features\nand syntactic sugar sprinkled on top, including variables, functions, infix\nnotation, human-readable times and more.\n\nA live compiler (Minsc->Policy->Miniscript->Script) and documentation are\navailable on the website: https://min.sc\n\nSource code (in Rust) is available on github:\nhttps://github.com/shesek/minsc\n\nSome example Minsc scripts:\n\n- A user and a 2FA service need to sign off, but after 90 days the user\nalone is enough\n\n      pk(user_pk) && (9 at pk(service_pk) || older(90 days))\n\n- Traditional preimage-based HTLC\n\n      $redeem = pk(A) && sha256(H);\n      $refund = pk(B) && older(10);\n\n      likely@$redeem || $refund\n\n- Liquid-like federated pegin with emergency recovery keys\n\n      $federation = 4 of [ pk(A), pk(B), pk(C), pk(D), pk(E) ];\n      $recovery = 2 of [ pk(F), pk(G), pk(H) ];\n      $timeout = older(heightwise 2 weeks);\n\n      likely@$federation || ($timeout && $recovery)\n\n- The BOLT #3 received HTLC policy\n\n      fn htlc_received($revoke_pk, $local_pk, $remote_pk, $secret, $delay) {\n        $success = pk($local_pk) && hash160($secret);\n        $timeout = older($delay);\n\n        pk($revoke_pk) || (pk($remote_pk) && ($success || $timeout))\n      }\n\n      htlc_received(A, B, C, H, 3 hours)\n\n- 2FA where the user has a 2-of-2 setup and the service provider is a\n3-of-4 federation\n\n      fn two_factor($user, $provider, $delay) =\n        $user && (likely@$provider || older($delay));\n\n      $user = pk(user_desktop) && pk(user_mobile);\n      $providers = [ pk(P1), pk(P2), pk(P3), pk(P4) ];\n\n      two_factor($user, 3 of $providers, 4 months)\n\n- Easily add NSA backdoors to everything \ud83d\udd75\ufe0f\ud83d\udeaa\n\n      _backdoor=pk(usgovt), _pk=pk, _older=older, _after=after,\n      _sha256=sha256, _ripemd160=ripemd160;\n\n      fn pk(x) = _pk(x) || _backdoor;\n      fn older(x) = _older(x) || _backdoor;\n      fn after(x) = _after(x) || _backdoor;\n      fn sha256(x) = _sha256(x) || _backdoor;\n      fn ripemd160(x) = _ripemd160(x) || _backdoor;\n\n      (pk(A) && sha256(H)) || (pk(B) && older(10))\n\nFeedback is appreciated!\n\nNadav\n\nP.S Since every Miniscript Policy is also a valid Minsc expression, the\nmin.sc web code editor UI could also be useful for experimenting with bare\npolicies. You'll get syntax highlighting, parentheses matching, real-time\ncompilation (in a web worker so the browser doesn't freeze) and syntax\nerror reporting.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200729/97272a76/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Minsc, a Miniscript-based scripting language",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Nadav Ivgi"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2763
        }
    },
    {
        "title": "[bitcoin-dev] Advances in Bitcoin Contracting : Uniform Policy and Package Relay",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2020-07-29T20:17:11",
                "message_text_only": "Hi list,\n\nSecurity and operations of higher-layer protocols (vaults, LN, CoinJoin,\nwatchtowers, ...) come with different assumptions and demands with regards\nto tx-relay and fee models. As the Bitcoin stack is quite young, it would\nbe great to make those ones more understood and what p2p/mempool changes we\nmight adopt at the base layer to better answer them. I would like to\nexplore this with my current post.\n\n### Time-Sensitive Protocols Security-Model (you can skip this if you know\nLN)\n\nLightning, the most deployed time-sensitive protocol as of now, relies on\nthe timely confirmations of some of its transactions to enforce its\nsecurity model. Like timing out an outgoing HTLC, claiming an incoming HTLC\nor punishing a revoked commitment. Ensuring timely confirmation is\ntwo-fold: a) propagating well-transactions across the network to quickly\nhit miner mempools b) offering a competitive feerate to get in next coming\nblocks.\n\nUpdating feerate just-in-time is quite challenging for LN as you can't\nresign a commitment once your counterparty is non-responsive or malicious,\nand thus any fee strategy assuming interactivity is closed. With current\nconstraints of maintaining a trustless chain of transactions (no\nParent-Pay-For-Child), the only option is a CPFP. Ongoing update of LN\nprotocol (anchor-outputs) will allow a channel participant to unilaterally\nbump feerate of its commitment/HTLCs txn, assuming there is no\n_adversarial_ network mempool conditions like a concurrent broadcast.\n\nBeyond enforcing the need to secure its funds by bumping feerate, an\noffchain user might be willingly to accelerate confirmation of a broadcast\nfor liquidity management in face of mempool-congestion. This issue is\nlikely shared by any multi-party protocol like Coinjoins where resigning is\npainful and a party may have different liquidity preferences than other\nparticipants and would like to express them in an unilateral fee bumping.\n\n### Effective Transaction Propagation and Uniform Relay Policy\n\nEven before competing on feerate, the first and foremost point of the\nlaid-out security model was the well-propagation of transactions across the\np2p network. Its effectiveness is determined by compliance to 1) consensus\nrules 2) policy rules. This second set is a tighter one governing different\naspects of your transactions (like size, output type, feerate,\nancestors/descendants, ...) and introduced to sanitize the p2p network\nagainst a wide scope of resources abuses (RBF bandwidth waste, package\nevaluation CPU DoS, economic nonsense outputs, ...)\n\nThese rules diverge across implementations/versions and a subset of them\ncan be tightened or relaxed by node operators. This heterogeneity is\nactually where the risk is scored for higher protocols, your LN's full-node\nmight be connected to tx-relay peers with more constraining policies than\nyours and thus will always reject your time-sensitive transactions,\nsilently breaking security of your channels [0].\n\nOf course, LN protocols devs have always been aware of these issues and\ncarefully reflect policies enforcement in their codebase. That said an\nimportant subset of them aren't documented or even standardized and thus\nhard to incorporate in upper layers specs. Testing them in a black box\napproach (i.e `testmempoolaccept`) before production doesn't work as your\nbroadcast has to be valid against the union of your yet-unknown tx-relay\ntopology, further static checks are blurred with dynamic ones (the feerate\nnow is different than the one at a future broadcast), and your transaction\nmight be malleate by your counterparty (like a ridiculous feerate).\n\nAnd the other side, AFAIK, Core developers have always acknowledged these\nissues and been really conscientious when updating such API policy. The\nconcerning change with protocol like LN is the severity consequences in\ncase of incompatible changes. Previously, your basic transaction would have\nbeen rejected by the network and your application could have been updated\nbefore successfully rebroadcasting. Now, such changes potentially outlawing\nyour time-sensitive broadcasts is a direct, measurable risk of fund loss,\neither triggered by mempool-congestion or exploited by a malicious\ncounterparty.\n\nTherefore, moving towards such stable tx-relay/bumping API, I propose:\na) Identifying and documenting the subset of policy rules on which upper\nlayers have to rely on to enforce their security model\nb) Guaranteeing backward-compatibility of those rules or, in case of\ntightening change, making sure there is ecosystem coordination with some\nminimal warning period (1 release ?)\n\nCommitting to a uniform policy would be a philosophical change, it would\nossify some parts of full-node implementations. Another side-effect means\nthat upper layer devs would be incentivized to rely on such stable API. In\ncase of new DoS on the base layer, we might have to tighten them in a short\ntimeline at the price of breaking some offchain applications [1] On the\nother side, full-node operators have an interest to follow such uniform\npolicy, as it would improve the effective feerate discovery by their\nmempools.\n\n### Adversarial Fee Bumping and Package Relay\n\nAssuming anchor-output gets adopted & deployed, even beyond LN, it doesn't\nguarantee success of CPFP, where success is defined as letting know the\nnetwork mempools of your fee-bid, confirmation being always a function of\nconcurrent fee-bids from other users. Indeed, if it allows bump at the\ntransaction-level, there is no guarantee of enforcement at the tx-relay\nlayer. Mempool acceptance for any transaction is done on its own, a\nlow-feerate parent can be rejected while a high-feerate child might have to\nfollow fews microseconds later.\n\nThis has consequences both for network nodes, the ones with small mempools\nwon't discover the best feerate bid, which false their fee-estimator and\nfor CPFP users, their feerate bump having chances to fail. It's specially\nconcerning for LN where concurrent broadcast for the same utxo can be\nleveraged by a counterparty to steal channel funds. A class of attacks\nknown as pinning achievable today [2].\n\nSolving this means likely deploying a package relay, an old known\nproposition to evaluate the feerate of a whole chain of transactions to\ndecide their mempool acceptance. Ensuring package relay effectiveness means\nmaking it part of such uniform policy laid out above, thus providing a\ncensorship-resistant, reliable highway across the p2p network to always\nincrease feerate of your blockspace bids. It will force a pinning attacker\nto enter in a feerate competition with the honest party to maintain the\npin, thus cancelling the threat.\n\nPackage relay design is also pending on bumping patterns. Ideally if a LN\nhub is closing multiple channels at the same time, you should be able to\nspread one CPFP on multiple parents, which is an increase of DoS surface\nfor the mempol. Also package relay might be the default broadcast policy by\nLN nodes for unilateral broadcast, as you can't dissociate if your\ntransaction is stucking due to congestion or an ongoing pinning without\nglobal view of network mempools. In the future, if LN broadcasts account\nfor an honest share of the whole tx-relay, it won't be free bandwidth-wise.\n\n\nTo conclude, upper layers of the Bitcoin stack require that single\nfull-nodes behave in a homogeneous way such that the base network as a\nwhole system provide a trustworthy propagation/fee bumping API [3]\n\nI'm eager to get feedback on any subject introduced here, especially the\nuniform policy proposal which is really worthy of discussion and\ncontroversial for sure.\n\nCheers,\n\nAntoine\n\n[0] E.g\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017883.html\nor  https://github.com/bitcoin/bitcoin/issues/13283 when policy break your\nbroadcast\n\n[1] Again this is not a LN specific issue, timelocked vaults have the same\nissue\n\n[2] https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md\n\n[3] In fact these requirements aren't specifics from the _new_ upper-layer\nBitcoin stack but a fundamental assumption made by anything using\ntimelocks/concurrent states, i.e also old-school 2013 payment channels\ndesigns\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200729/47b99dc4/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Advances in Bitcoin Contracting : Uniform Policy and Package Relay",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8358
        }
    }
]