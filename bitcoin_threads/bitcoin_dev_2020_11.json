[
    {
        "title": "[bitcoin-dev] RFC BIP-0002: Defer, not reject.",
        "thread_messages": [
            {
                "author": "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3",
                "date": "2020-11-02T12:11:40",
                "message_text_only": "Follow-up to this: there is now an alternative to this which proposes\nthat the rejection criteria in BIP 2 is updated to require there to be\nan actual concern. This is here:\nhttps://github.com/bitcoin/bips/pull/1016\n\nPlease nod or something at either or both of them.\n\nOn Tue, Oct 13, 2020 at 7:06 PM \u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3 <karl at dglab.com> wrote:\n>\n> Hello,\n>\n> I am making a minor proposed change to BIP-0002\n>\n> https://github.com/bitcoin/bips/pull/1012\n>\n> I propose that we change the 3-year-rule to allow anyone to change the\n> status of a BIP to \"Deferred\", rather than \"Rejected\".\n>\n> Rejecting a BIP already has ambiguous meaning in BIP-0002 as it\n> stands, with \"hard\" rejects:\n>\n> > The BIP editor will not unreasonably reject a BIP. Reasons for rejecting BIPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Bitcoin philosophy.\n>\n> and \"soft\" rejects:\n>\n> > BIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such a BIP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph.\n>\n> My proposal is that we disambiguate the second into \"deferred\" instead.\n>\n> Alternatively, we add a new status e.g. \"Inactive\"."
            }
        ],
        "thread_summary": {
            "title": "RFC BIP-0002: Defer, not reject.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1548
        }
    },
    {
        "title": "[bitcoin-dev] Progress on bech32 for future Segwit Versions (BIP-173)",
        "thread_messages": [
            {
                "author": "Mike Schmidt",
                "date": "2020-11-06T19:49:44",
                "message_text_only": "Well I sure picked a bad couple weeks to volunteer to send a bunch of\nBitcoin test transactions...\n\nWhile I tested less than I would have liked, there are some notable results:\n\n- Green wallet segwit v1 send resulted in funds being sent to the wrong\naddress (bc1qmfr3p9j00pfxjh0zmgp99y8zftmd3s5pmedqhyptwy6lm87hf5sstpn3we\ninstead of my intended destination, Pieter's r5n8 address. You can see this\nwith Rusty's test transaction as well:\nef1662fd2eb736612afb1b60e3efabfdf700b1c4822733d9dbe1bfee607a5b9b\nBlockstream is aware of the issue and has fixes.\n- Blockchain.com's wallet behaved similarly, sending to the same, incorrect\naddress. Rusty's blockchain.com transaction for reference:\n64b0fcb22d57b3c920fee1a97b9facec5b128d9c895a49c7d321292fb4156c21\nI will be reaching out to Blockchain's team to let them know about this.\n- Blockchain.info's explorer suffers similarly, \"Unable to decode output\naddress\" when viewing a tx with v1 output, and inability to display address\ndetails for a v1 address\n- Bitgo accepts a v1 send address, but then a \u201cServer error\u201d during send\noccurs\n- Coinbase (web) reported on final step of sending: Your send failed Please\nenter a valid email or Bitcoin address\n- brd sends successfully to v1\n- bitrefill, casa, xapo, wasabi, all previously failed address validation,\nand still fail address validation\n- binance, bitmex, kraken, all previously failed address validation, but\nnow accept v1 addresses. I did not attempt full send with these services,\nsimply passing initial validations.\n- While Riccardo noted that Aqua successfully sent to Pieter's address\n(b48a59fa9e036e997ba733904f631b1a64f5274be646698e49fd542141ca9404) Ive been\ninformed Aqua has disabled send to v1 addresses for now.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201106/9b92d93c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Progress on bech32 for future Segwit Versions (BIP-173)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mike Schmidt"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1902
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Archaeology",
        "thread_messages": [
            {
                "author": "Dan Bryant",
                "date": "2020-11-11T15:06:54",
                "message_text_only": "TLDR; How to build old OpenSSL releases in MSYS/MinGW v1.0.11\n\nIn a similar vein to the Github Artic Code Vault, and the Nakamoto\nInstitute, I thought it would be educational to do a build of the first\nthree versions of Bitcoin (v0.1.0, v0.1.3, and v0.1.5) [ref1].  Don't\nworry, I will keep these on a VLAN and not spam the IRC channel.\n\nWanting to be as accurate as possible, I spun up some VMs to try to\nrecreate the vintage Oct 2009 toolchains that were used.  The original\nSatoshi posts seem to imply that the builds could be done using Visual C++\nversion 6.0 or MinGW and MSYS (which were at v1.0.11).  Since it looks like\nmost versions of VC 6 have been purged from the internet, the only option\nleft is MinGW which is still up on sourceforge.  Most things seemed to\nbuild OK, with the exception of OpenSSL, which looks to fail due to some\nissues in mk1mf.pl [ref2]  Perhaps there was a bad version of perl in MSYS\nv1.0.11, I'm not sure.\n\nSo my question is..  Has anyone been here long enough to recall the steps\nto build OpenSSL v0.9.8h in MSYS 1.0.11?  Or, does anyone know where to\nfind a non-sketchy copy of Visual C++ 6.0?\n\nMy options so far seem to be.\n\n1. Try to find out how Satoshi did the MinGW OpenSSL build back in 2009.\n2. Try to do the OpenSSL build through Cygwin which could cross-complile to\nMinGW at the time\n3. Try to do the  OpenSSL build through Msys2 with later versions of perl\nand libc\n4. Buy some sketchy version of VC 6 on ebay and try that\n5. Patch Bitcoin 0.1.0 to use OpenSSL v1.0.0 where they fixed the perl bug\n6. Give up and use a precompiled OpenSSL release\n7. Give up and use the Linux build methods introduced in Bitcoin v0.1.6\n\nI realize this all sounds like a fool's folly, but it seems important (at\nsome level) to be able to reproduce these old builds.  But perhaps it's\njust my OCD.\n\nThoughts?\n\nFor those interested.  The mk1mf.pl bug seems to be in parsing the list of\nheaders through either the var_add, clean_up_ws, or do_copy_rule subs.  I\nsee both the headers and header directories being parsed, but the\ndirectories are dropped when building the make rules causing make to assume\nall headers are at root, failing the build.  Perhaps there is a version\nsed, basename or dirname that is missing in MSYS, but I've failed to find\nthe dependency yet.\n\n* ref1: https://satoshi.nakamotoinstitute.org/code/\n* ref1: https://github.com/openssl/openssl/blob/OpenSSL_0_9_8h/util/mk1mf.pl\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201111/bfd33ca1/attachment.html>"
            },
            {
                "author": "Dan Bryant",
                "date": "2020-11-14T17:00:12",
                "message_text_only": "Finally got it working,but was a bit harder than I expected.  I had to\nforgo the OpenSSL modifications that Satoshi originally suggested.  I also\nswitched to Strawberry Perl.  Those two changes seemed to fix the OpenSSL\nbuild.  Everything else was all essentially as documented in v0.4.0, which\nis the first version to put all the build steps out in detail.  The one\nexception is the bitcoin build itself.  There are three minor issues that\ncan be worked around with copy commands.\n\n1. The Makefile points to /wxWidgets/lib/vc_lib/ where it should really\npoint to /wxWidgets/lib/gcc_lib/\n2. The Makefile points to /OpenSSL/include where it should really point to\n/OpenSSL/outinc\n3. The Makefile builds to /obj without first creating the directory\n\nThat covers v0.1.5, and I think it will probably be smooth sailing from\nthere all the way to v0.4.0.  I'll verify that my v0.1.5 toolchain can\nbuild v0.1.0 and v0.1.3 as well.  For anyone interested, here are the\nbinaries I used to create the build environment.  All of them are\nvintage and would have been accessible to Satoshi with the exception of\nWin2012 and VirtualBox.  I'll try to reproduce my work on a Win2000 which\nis now quasi-open-domain.\n\nFor anyone wanting to give it a shot...\n\n* https://www.microsoft.com/en-us/evalcenter/evaluate-hyper-v-server-2012\n*\nhttps://download.virtualbox.org/virtualbox/6.1.12/VirtualBox-6.1.12-139181-Win.exe\n* https://downloads.sourceforge.net/gnuwin32/zlib-1.2.3-bin.zip\n* https://downloads.sourceforge.net/gnuwin32/bzip2-1.0.5-bin.zip\n* https://downloads.sourceforge.net/gnuwin32/libarchive-2.4.12-1-bin.zip\n* https://downloads.sourceforge.net/mingw/binutils-2.19.1-mingw32-bin.tar.gz\n* https://downloads.sourceforge.net/mingw/gcc-core-3.4.5-20051220-1.tar.gz\n* https://downloads.sourceforge.net/mingw/gcc-g++-3.4.5-20051220-1.tar.gz\n* https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dev.tar.gz\n* https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dll.tar.gz\n* https://downloads.sourceforge.net/mingw/w32api-3.13-mingw32-dev.tar.gz\n*\nhttps://downloads.sourceforge.net/mingw/mingw32-make-3.81-20080326-2.tar.gz\n* https://downloads.sourceforge.net/mingw/MSYS-1.0.11.exe\n* https://downloads.sourceforge.net/mingw/msysDTK-1.0.1.exe\n* http://strawberryperl.com/download/5.8.8/strawberry-perl-5.8.8.2.zip\n* https://github.com/bitcoin/bitcoin/archive/v0.1.5.zip\n* https://downloads.sourceforge.net/wxwindows/wxWidgets-2.8.11.zip\n* https://github.com/openssl/openssl/archive/OpenSSL_0_9_8h.zip\n* https://download.oracle.com/berkeley-db/db-4.7.25.NC.zip\n* https://downloads.sourceforge.net/boost/1.37.0/boost_1_37_0.zip\n*\nhttps://downloads.sourceforge.net/boost/boost-jam/boost-jam-3.1.17-1-ntx86.zip\n\n\nOn Wed, Nov 11, 2020 at 9:06 AM Dan Bryant <dkbryant at gmail.com> wrote:\n\n> TLDR; How to build old OpenSSL releases in MSYS/MinGW v1.0.11\n>\n> In a similar vein to the Github Artic Code Vault, and the Nakamoto\n> Institute, I thought it would be educational to do a build of the first\n> three versions of Bitcoin (v0.1.0, v0.1.3, and v0.1.5) [ref1].  Don't\n> worry, I will keep these on a VLAN and not spam the IRC channel.\n>\n> Wanting to be as accurate as possible, I spun up some VMs to try to\n> recreate the vintage Oct 2009 toolchains that were used.  The original\n> Satoshi posts seem to imply that the builds could be done using Visual C++\n> version 6.0 or MinGW and MSYS (which were at v1.0.11).  Since it looks like\n> most versions of VC 6 have been purged from the internet, the only option\n> left is MinGW which is still up on sourceforge.  Most things seemed to\n> build OK, with the exception of OpenSSL, which looks to fail due to some\n> issues in mk1mf.pl [ref2]  Perhaps there was a bad version of perl in\n> MSYS v1.0.11, I'm not sure.\n>\n> So my question is..  Has anyone been here long enough to recall the steps\n> to build OpenSSL v0.9.8h in MSYS 1.0.11?  Or, does anyone know where to\n> find a non-sketchy copy of Visual C++ 6.0?\n>\n> My options so far seem to be.\n>\n> 1. Try to find out how Satoshi did the MinGW OpenSSL build back in 2009.\n> 2. Try to do the OpenSSL build through Cygwin which could\n> cross-complile to MinGW at the time\n> 3. Try to do the  OpenSSL build through Msys2 with later versions of perl\n> and libc\n> 4. Buy some sketchy version of VC 6 on ebay and try that\n> 5. Patch Bitcoin 0.1.0 to use OpenSSL v1.0.0 where they fixed the perl bug\n> 6. Give up and use a precompiled OpenSSL release\n> 7. Give up and use the Linux build methods introduced in Bitcoin v0.1.6\n>\n> I realize this all sounds like a fool's folly, but it seems important (at\n> some level) to be able to reproduce these old builds.  But perhaps it's\n> just my OCD.\n>\n> Thoughts?\n>\n> For those interested.  The mk1mf.pl bug seems to be in parsing the list\n> of headers through either the var_add, clean_up_ws, or do_copy_rule subs.\n> I see both the headers and header directories being parsed, but the\n> directories are dropped when building the make rules causing make to assume\n> all headers are at root, failing the build.  Perhaps there is a version\n> sed, basename or dirname that is missing in MSYS, but I've failed to find\n> the dependency yet.\n>\n> * ref1: https://satoshi.nakamotoinstitute.org/code/\n> * ref1:\n> https://github.com/openssl/openssl/blob/OpenSSL_0_9_8h/util/mk1mf.pl\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201114/41d8e903/attachment.html>"
            },
            {
                "author": "Dan Bryant",
                "date": "2020-11-15T05:41:33",
                "message_text_only": "I think I'm set now.  I should have everything I need from v0.1.0 to 0.3.13\nwhen they changed the compiler.  I'll refine it a bit more then eventually\nstart posting the binary builds on the repo below.  I might go ahead and\ndisable the IRC bot to ensure people don't inadvertently spam the\n`#bitcoin` IRC.  Since I have a patch process worked out it should be\nfairly straight forward.  Since the official builds pickup at v0.8.6, I'll\nlikely stop there.\n\nhttps://github.com/brianddk/bitcoin-archaeology\n\n\nOn Sat, Nov 14, 2020 at 11:00 AM Dan Bryant <dkbryant at gmail.com> wrote:\n\n> Finally got it working,but was a bit harder than I expected.  I had to\n> forgo the OpenSSL modifications that Satoshi originally suggested.  I also\n> switched to Strawberry Perl.  Those two changes seemed to fix the OpenSSL\n> build.  Everything else was all essentially as documented in v0.4.0, which\n> is the first version to put all the build steps out in detail.  The one\n> exception is the bitcoin build itself.  There are three minor issues that\n> can be worked around with copy commands.\n>\n> 1. The Makefile points to /wxWidgets/lib/vc_lib/ where it should really\n> point to /wxWidgets/lib/gcc_lib/\n> 2. The Makefile points to /OpenSSL/include where it should really point to\n> /OpenSSL/outinc\n> 3. The Makefile builds to /obj without first creating the directory\n>\n> That covers v0.1.5, and I think it will probably be smooth sailing from\n> there all the way to v0.4.0.  I'll verify that my v0.1.5 toolchain can\n> build v0.1.0 and v0.1.3 as well.  For anyone interested, here are the\n> binaries I used to create the build environment.  All of them are\n> vintage and would have been accessible to Satoshi with the exception of\n> Win2012 and VirtualBox.  I'll try to reproduce my work on a Win2000 which\n> is now quasi-open-domain.\n>\n> For anyone wanting to give it a shot...\n>\n> * https://www.microsoft.com/en-us/evalcenter/evaluate-hyper-v-server-2012\n> *\n> https://download.virtualbox.org/virtualbox/6.1.12/VirtualBox-6.1.12-139181-Win.exe\n> * https://downloads.sourceforge.net/gnuwin32/zlib-1.2.3-bin.zip\n> * https://downloads.sourceforge.net/gnuwin32/bzip2-1.0.5-bin.zip\n> * https://downloads.sourceforge.net/gnuwin32/libarchive-2.4.12-1-bin.zip\n> *\n> https://downloads.sourceforge.net/mingw/binutils-2.19.1-mingw32-bin.tar.gz\n> * https://downloads.sourceforge.net/mingw/gcc-core-3.4.5-20051220-1.tar.gz\n> * https://downloads.sourceforge.net/mingw/gcc-g++-3.4.5-20051220-1.tar.gz\n> *\n> https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dev.tar.gz\n> *\n> https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dll.tar.gz\n> * https://downloads.sourceforge.net/mingw/w32api-3.13-mingw32-dev.tar.gz\n> *\n> https://downloads.sourceforge.net/mingw/mingw32-make-3.81-20080326-2.tar.gz\n> * https://downloads.sourceforge.net/mingw/MSYS-1.0.11.exe\n> * https://downloads.sourceforge.net/mingw/msysDTK-1.0.1.exe\n> * http://strawberryperl.com/download/5.8.8/strawberry-perl-5.8.8.2.zip\n> * https://github.com/bitcoin/bitcoin/archive/v0.1.5.zip\n> * https://downloads.sourceforge.net/wxwindows/wxWidgets-2.8.11.zip\n> * https://github.com/openssl/openssl/archive/OpenSSL_0_9_8h.zip\n> * https://download.oracle.com/berkeley-db/db-4.7.25.NC.zip\n> * https://downloads.sourceforge.net/boost/1.37.0/boost_1_37_0.zip\n> *\n> https://downloads.sourceforge.net/boost/boost-jam/boost-jam-3.1.17-1-ntx86.zip\n>\n>\n> On Wed, Nov 11, 2020 at 9:06 AM Dan Bryant <dkbryant at gmail.com> wrote:\n>\n>> TLDR; How to build old OpenSSL releases in MSYS/MinGW v1.0.11\n>>\n>> In a similar vein to the Github Artic Code Vault, and the Nakamoto\n>> Institute, I thought it would be educational to do a build of the first\n>> three versions of Bitcoin (v0.1.0, v0.1.3, and v0.1.5) [ref1].  Don't\n>> worry, I will keep these on a VLAN and not spam the IRC channel.\n>>\n>> Wanting to be as accurate as possible, I spun up some VMs to try to\n>> recreate the vintage Oct 2009 toolchains that were used.  The original\n>> Satoshi posts seem to imply that the builds could be done using Visual C++\n>> version 6.0 or MinGW and MSYS (which were at v1.0.11).  Since it looks like\n>> most versions of VC 6 have been purged from the internet, the only option\n>> left is MinGW which is still up on sourceforge.  Most things seemed to\n>> build OK, with the exception of OpenSSL, which looks to fail due to some\n>> issues in mk1mf.pl [ref2]  Perhaps there was a bad version of perl in\n>> MSYS v1.0.11, I'm not sure.\n>>\n>> So my question is..  Has anyone been here long enough to recall the steps\n>> to build OpenSSL v0.9.8h in MSYS 1.0.11?  Or, does anyone know where to\n>> find a non-sketchy copy of Visual C++ 6.0?\n>>\n>> My options so far seem to be.\n>>\n>> 1. Try to find out how Satoshi did the MinGW OpenSSL build back in 2009.\n>> 2. Try to do the OpenSSL build through Cygwin which could\n>> cross-complile to MinGW at the time\n>> 3. Try to do the  OpenSSL build through Msys2 with later versions of perl\n>> and libc\n>> 4. Buy some sketchy version of VC 6 on ebay and try that\n>> 5. Patch Bitcoin 0.1.0 to use OpenSSL v1.0.0 where they fixed the perl bug\n>> 6. Give up and use a precompiled OpenSSL release\n>> 7. Give up and use the Linux build methods introduced in Bitcoin v0.1.6\n>>\n>> I realize this all sounds like a fool's folly, but it seems important (at\n>> some level) to be able to reproduce these old builds.  But perhaps it's\n>> just my OCD.\n>>\n>> Thoughts?\n>>\n>> For those interested.  The mk1mf.pl bug seems to be in parsing the list\n>> of headers through either the var_add, clean_up_ws, or do_copy_rule subs.\n>> I see both the headers and header directories being parsed, but the\n>> directories are dropped when building the make rules causing make to assume\n>> all headers are at root, failing the build.  Perhaps there is a version\n>> sed, basename or dirname that is missing in MSYS, but I've failed to find\n>> the dependency yet.\n>>\n>> * ref1: https://satoshi.nakamotoinstitute.org/code/\n>> * ref1:\n>> https://github.com/openssl/openssl/blob/OpenSSL_0_9_8h/util/mk1mf.pl\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201114/33a421d0/attachment-0001.html>"
            },
            {
                "author": "Dan Bryant",
                "date": "2020-11-21T22:59:36",
                "message_text_only": "I've gathered all the source archives from v0.1.0 to v0.9.0 with the\nexception of one.\n\nI can't get v0.1.2 anywhere.  None of the crawlers from Web Archive seemed\nto have captured it.  I realize the build was recalled, but I would still\nlike to examine it purely out of curiosity.\n\nDoes anyone know of a mirror or have a personal copy of \"bitcoin-0.1.2.rar\"\nfrom 2009 / 2010 that they would be willing to share?  Even a checksum\nwould be nice so I could verify what I had if I ever come across it in the\nfuture.\n\nFirst and last sighting of it on Web Archive:\n\n*\nhttp://web.archive.org/web/20091127010808/http://sourceforge.net/projects/bitcoin/files\n*\nhttp://web.archive.org/web/20101210071124/http://sourceforge.net:80/projects/bitcoin/files/Bitcoin/\n\nOn Sat, Nov 14, 2020 at 11:41 PM Dan Bryant <dkbryant at gmail.com> wrote:\n\n> I think I'm set now.  I should have everything I need from v0.1.0 to\n> 0.3.13 when they changed the compiler.  I'll refine it a bit more then\n> eventually start posting the binary builds on the repo below.  I might go\n> ahead and disable the IRC bot to ensure people don't inadvertently spam the\n> `#bitcoin` IRC.  Since I have a patch process worked out it should be\n> fairly straight forward.  Since the official builds pickup at v0.8.6, I'll\n> likely stop there.\n>\n> https://github.com/brianddk/bitcoin-archaeology\n>\n>\n> On Sat, Nov 14, 2020 at 11:00 AM Dan Bryant <dkbryant at gmail.com> wrote:\n>\n>> Finally got it working,but was a bit harder than I expected.  I had to\n>> forgo the OpenSSL modifications that Satoshi originally suggested.  I also\n>> switched to Strawberry Perl.  Those two changes seemed to fix the OpenSSL\n>> build.  Everything else was all essentially as documented in v0.4.0, which\n>> is the first version to put all the build steps out in detail.  The one\n>> exception is the bitcoin build itself.  There are three minor issues that\n>> can be worked around with copy commands.\n>>\n>> 1. The Makefile points to /wxWidgets/lib/vc_lib/ where it should really\n>> point to /wxWidgets/lib/gcc_lib/\n>> 2. The Makefile points to /OpenSSL/include where it should really point\n>> to /OpenSSL/outinc\n>> 3. The Makefile builds to /obj without first creating the directory\n>>\n>> That covers v0.1.5, and I think it will probably be smooth sailing from\n>> there all the way to v0.4.0.  I'll verify that my v0.1.5 toolchain can\n>> build v0.1.0 and v0.1.3 as well.  For anyone interested, here are the\n>> binaries I used to create the build environment.  All of them are\n>> vintage and would have been accessible to Satoshi with the exception of\n>> Win2012 and VirtualBox.  I'll try to reproduce my work on a Win2000 which\n>> is now quasi-open-domain.\n>>\n>> For anyone wanting to give it a shot...\n>>\n>> * https://www.microsoft.com/en-us/evalcenter/evaluate-hyper-v-server-2012\n>> *\n>> https://download.virtualbox.org/virtualbox/6.1.12/VirtualBox-6.1.12-139181-Win.exe\n>> * https://downloads.sourceforge.net/gnuwin32/zlib-1.2.3-bin.zip\n>> * https://downloads.sourceforge.net/gnuwin32/bzip2-1.0.5-bin.zip\n>> * https://downloads.sourceforge.net/gnuwin32/libarchive-2.4.12-1-bin.zip\n>> *\n>> https://downloads.sourceforge.net/mingw/binutils-2.19.1-mingw32-bin.tar.gz\n>> *\n>> https://downloads.sourceforge.net/mingw/gcc-core-3.4.5-20051220-1.tar.gz\n>> * https://downloads.sourceforge.net/mingw/gcc-g++-3.4.5-20051220-1.tar.gz\n>> *\n>> https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dev.tar.gz\n>> *\n>> https://downloads.sourceforge.net/mingw/mingwrt-3.15.2-mingw32-dll.tar.gz\n>> * https://downloads.sourceforge.net/mingw/w32api-3.13-mingw32-dev.tar.gz\n>> *\n>> https://downloads.sourceforge.net/mingw/mingw32-make-3.81-20080326-2.tar.gz\n>> * https://downloads.sourceforge.net/mingw/MSYS-1.0.11.exe\n>> * https://downloads.sourceforge.net/mingw/msysDTK-1.0.1.exe\n>> * http://strawberryperl.com/download/5.8.8/strawberry-perl-5.8.8.2.zip\n>> * https://github.com/bitcoin/bitcoin/archive/v0.1.5.zip\n>> * https://downloads.sourceforge.net/wxwindows/wxWidgets-2.8.11.zip\n>> * https://github.com/openssl/openssl/archive/OpenSSL_0_9_8h.zip\n>> * https://download.oracle.com/berkeley-db/db-4.7.25.NC.zip\n>> * https://downloads.sourceforge.net/boost/1.37.0/boost_1_37_0.zip\n>> *\n>> https://downloads.sourceforge.net/boost/boost-jam/boost-jam-3.1.17-1-ntx86.zip\n>>\n>>\n>> On Wed, Nov 11, 2020 at 9:06 AM Dan Bryant <dkbryant at gmail.com> wrote:\n>>\n>>> TLDR; How to build old OpenSSL releases in MSYS/MinGW v1.0.11\n>>>\n>>> In a similar vein to the Github Artic Code Vault, and the Nakamoto\n>>> Institute, I thought it would be educational to do a build of the first\n>>> three versions of Bitcoin (v0.1.0, v0.1.3, and v0.1.5) [ref1].  Don't\n>>> worry, I will keep these on a VLAN and not spam the IRC channel.\n>>>\n>>> Wanting to be as accurate as possible, I spun up some VMs to try to\n>>> recreate the vintage Oct 2009 toolchains that were used.  The original\n>>> Satoshi posts seem to imply that the builds could be done using Visual C++\n>>> version 6.0 or MinGW and MSYS (which were at v1.0.11).  Since it looks like\n>>> most versions of VC 6 have been purged from the internet, the only option\n>>> left is MinGW which is still up on sourceforge.  Most things seemed to\n>>> build OK, with the exception of OpenSSL, which looks to fail due to some\n>>> issues in mk1mf.pl [ref2]  Perhaps there was a bad version of perl in\n>>> MSYS v1.0.11, I'm not sure.\n>>>\n>>> So my question is..  Has anyone been here long enough to recall the\n>>> steps to build OpenSSL v0.9.8h in MSYS 1.0.11?  Or, does anyone know where\n>>> to find a non-sketchy copy of Visual C++ 6.0?\n>>>\n>>> My options so far seem to be.\n>>>\n>>> 1. Try to find out how Satoshi did the MinGW OpenSSL build back in 2009.\n>>> 2. Try to do the OpenSSL build through Cygwin which could\n>>> cross-complile to MinGW at the time\n>>> 3. Try to do the  OpenSSL build through Msys2 with later versions of\n>>> perl and libc\n>>> 4. Buy some sketchy version of VC 6 on ebay and try that\n>>> 5. Patch Bitcoin 0.1.0 to use OpenSSL v1.0.0 where they fixed the perl\n>>> bug\n>>> 6. Give up and use a precompiled OpenSSL release\n>>> 7. Give up and use the Linux build methods introduced in Bitcoin v0.1.6\n>>>\n>>> I realize this all sounds like a fool's folly, but it seems important\n>>> (at some level) to be able to reproduce these old builds.  But perhaps it's\n>>> just my OCD.\n>>>\n>>> Thoughts?\n>>>\n>>> For those interested.  The mk1mf.pl bug seems to be in parsing the list\n>>> of headers through either the var_add, clean_up_ws, or do_copy_rule subs.\n>>> I see both the headers and header directories being parsed, but the\n>>> directories are dropped when building the make rules causing make to assume\n>>> all headers are at root, failing the build.  Perhaps there is a version\n>>> sed, basename or dirname that is missing in MSYS, but I've failed to find\n>>> the dependency yet.\n>>>\n>>> * ref1: https://satoshi.nakamotoinstitute.org/code/\n>>> * ref1:\n>>> https://github.com/openssl/openssl/blob/OpenSSL_0_9_8h/util/mk1mf.pl\n>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201121/40fc4057/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Archaeology",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dan Bryant"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 21534
        }
    },
    {
        "title": "[bitcoin-dev] CoinPools based on m-of-n Schnorr aggregated signatures",
        "thread_messages": [
            {
                "author": "Sridhar G",
                "date": "2020-11-15T22:18:17",
                "message_text_only": "Hi everyone,\n\nN-of-n multisig transaction using Schnorr aggregate signature is trivial\nand is similar to the current P2PKH. I would like to propose a model for\nm-of-n multisig transactions using Schnorr aggregate signatures and use\nthis to enable CoinPools for off-chain scalability.\n\n1. Creating the pool\n\nA transaction is made on the bitcoin network with an output having the\nfollowing script:\n\n<pub_key_1> <pub_key_2> <pub_key_3> .. <pub_key_N> N M OP_POOL\n\nBitcoin network will create a \u2018pool\u2019 with all the \u2018N\u2019 public keys and note\ndown the threshold M for this pool. This UTXO would be referred as <POOL_ID>\n\n2. Depositing money to pool\n\nDeposits can be made to a pool with <POOL_ID> with the following script\n\n<POOL_ID> OP_LOAD_POOL_AGG_PUB_KEY OP_CHECKSIG\n\n3. Redeeming money from pool\n\nRedeem script would contain the aggregated signature from all signers and\nthe bitmap of signers.\n\n*<AGG_SIG> <SIGNERS_BITMAP>* <POOL_ID>  OP_LOAD_POOL_AGG_PUB_KEY\nOP_CHECKSIG\n\n\nWith <AGG_SIG> <SIGNERS_BITMAP> provided by the person that redeems money\nfrom a pool, where\n\n<AGG_SIG> - is the aggregated signature\n\n<SIGNERS_BITMAP> - Is a bitmap representing whether the member of the pool\nat position 'i' of bitmap has signed or not(1 = signed, 0 - has not signed)\n\n\n\nSo we will be introducing two new opcodes:\n\n   1.\n\n   OP_POOL - this will be used to create a new coin pool.\n   2.\n\n   OP_LOAD_POOL_AGG_PUB_KEY - This opcode does three things\n   1.\n\n      loads the pool (POOL_ID)\n      2.\n\n      checks if there are atleast 'm' signers (based on SIGNERS_BITMAP)\n      3.\n\n      aggregates the public key of the signers. (based on SIGNERS_BITMAP)\n\n      The opcode uses the top two elements from the stack- the first\nelement from the stack specifies the POOL_ID to load, which will load the\npublic keys from the pool. This opcode also checks if there are \u2018M\u2019\nsigners(as specified at the time of creation of the pool) and aggregates\nthe public keys that have signed based on SIGNERS_BITMAP using Schnorr\naggregate signature scheme and puts back this aggregated public key onto\nthe stack.\n\n\nSIGNERS_BITMAP is a 32 byte value, and represents a bitmap of which public\nkeys from the pool have signed the transaction.\n\nHaving this scheme would enable-\n\n   1.\n\n   Scalability of m-of-n multisig transactions - People can deposit money\n   to a pool(with 32 byte SIGNERS_BITMAP, we can allow for 256 possible\n   signers).\n   2.\n\n   Trust minimized off-chain scalability solutions due to the use of a\n   sufficiently large pool of signers. Most existing pools might allow for\n   only a few signers as having many signers would mean higher transaction\n   cost.\n\n\nDownsides:\n\n   1.\n\n   We need to have the public keys of the members of the pool exposed.\n\n\nDespite the downsides of exposing public keys, do you think this would be a\nviable scheme for enabling CoinPool for the Bitcoin network? Or, any scheme\nthat may expose public keys is a no-go in the Bitcoin network?\n\n\nThanks! Looking for your feedback and thoughts on this.\n\n-Sridhar\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201115/cab0a90a/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-11-16T01:32:11",
                "message_text_only": "Good morning Sridhar,\n\nMy understanding is that it is still possible to generate an m-of-n aggregated pubkey, it \"just\" requires an interactive setup (i.e. all n signers have to talk to each other and send data a few times to each other) and they have to keep extra data around in order to \"sign for\" the n - m missing signers.\n`andytoshi` and `pwuille` can probably teach you the details.\n\nOf course, if you want to trade off the interactive setup + data storage, for extra block space and a privacy loss, that seems a reasonable tradeoff to make.\n\nMy understanding is that current plan is to implement a `OP_CHECKSIGADD`, where your script would be:\n\n   <0> <pubkey1> OP_CHECKSIGADD <pubkey2> OP_CHECKSIGADD <pubkey3> OP_CHECKSIGADD <m> OP_EQUAL\n\nHowever, `OP_CHECKSIGADD` would have individual signatures from the m participating signers.\nYour `OP_POOL`, as I understand it, would instead have a single m-of-m signature.\n\nThis adds another tradeoff:\n\n* `OP_CHECKSIGADD` takes up more block space, but each signer can give their signature independently without having to enter a signing sessiong with other participating signers.\n  * For example, this can reduce the number of communication rounds and the latency.\n  * A participating signer can emit its own signature and then go offline and you can still use its signature when you have gotten the required m participants.\n* `OP_POOL` takes less block space, but all participating signers have to be online simultaneously.\n\nI think the fact that `OP_POOL` requires all participating signers to be online simultaneously to generate a single signature sort of defeats the purpose, as (by my naive understanding, which could be grossly wrong) in the m-of-n key setup, the extra data needed would be stored by all participants, so even if one participant loses this data any of the others can still provide it.\nInteractive setup may not be so onerous if you are doing multiple interactive signing sessions later anyway.\nSo doing a verifiable secret sharing at interactive setup, to generate a single pubkey that is just used directly as the pubkey of the UTXO, would end up being smaller and more private anyway, and would \"just\" require interactive setup + storage of extra data.\n\nI guess the question is: just how big is the extra data in the m-of-n verifiable secret sharing?\n\nRegards,\nZmnSCPxj\n\n\n> Hi everyone,\n>\n> N-of-n multisig transaction using Schnorr aggregate signature is trivial and is similar to the current P2PKH. I would like to propose a model for m-of-n multisig transactions using Schnorr aggregate signatures and use this to enable CoinPools for off-chain scalability.\n>\n> 1. Creating the pool\n>\n> A transaction is made on the bitcoin network with an output having the following script:\n>\n> <pub_key_1> <pub_key_2> <pub_key_3> .. <pub_key_N> N M OP_POOL\n>\n> Bitcoin network will create a \u2018pool\u2019 with all the \u2018N\u2019 public keys and note down the threshold M for this pool. This UTXO would be referred as <POOL_ID>\n>\n> 2. Depositing money to pool\n>\n> Deposits can be made to a pool with <POOL_ID> with the following script\n>\n> <POOL_ID> OP_LOAD_POOL_AGG_PUB_KEY OP_CHECKSIG\n>\n> 3. Redeeming money from pool\n>\n> Redeem script would contain the aggregated signature from all signers and the bitmap of signers.\n>\n> <AGG_SIG> <SIGNERS_BITMAP> <POOL_ID>\u00a0 OP_LOAD_POOL_AGG_PUB_KEY OP_CHECKSIG\n>\n> With <AGG_SIG> <SIGNERS_BITMAP> provided by the person that redeems money from a pool, where\n>\n> <AGG_SIG> - is the aggregated signature\n>\n> <SIGNERS_BITMAP> - Is a bitmap representing whether the member of the pool at position 'i' of bitmap has signed or not(1 = signed, 0 - has not signed)\n>\n> So we will be introducing two new opcodes:\n>\n> 1.  OP_POOL - this will be used to create a new coin pool.\n>\n> 2.  OP_LOAD_POOL_AGG_PUB_KEY - This opcode does three things\n>\n>\n> 1.  loads the pool (POOL_ID)\n>\n> 2.  checks if there are atleast 'm' signers (based on SIGNERS_BITMAP)\n>\n> 3.  aggregates the public key of the signers. (based on SIGNERS_BITMAP)\n>\n>\n> The opcode uses the top two elements from the stack- the first element from the stack specifies the POOL_ID to load, which will load the public keys from the pool. This opcode also checks if there are \u2018M\u2019 signers(as specified at the time of creation of the pool) and aggregates the public keys that have signed based on SIGNERS_BITMAP using Schnorr aggregate signature scheme and puts back this aggregated public key onto the stack.\n>\n> SIGNERS_BITMAP is a 32 byte value, and represents a bitmap of which public keys from the pool have signed the transaction.\n>\n> Having this scheme would enable-\n>\n> 1.  Scalability of m-of-n multisig transactions - People can deposit money to a pool(with 32 byte SIGNERS_BITMAP, we can allow for 256 possible signers).\n>\n> 2.  Trust minimized off-chain scalability solutions due to the use of a sufficiently large pool of signers. Most existing pools might allow for only a few signers as having many signers would mean higher transaction cost.\n>\n>\n> Downsides:\n>\n> 1.  We need to have the public keys of the members of the pool exposed.\n>\n>\n> Despite the downsides of exposing public keys, do you think this would be a viable scheme for enabling CoinPool for the Bitcoin network? Or, any scheme that may expose public keys is a no-go in the Bitcoin network?\n>\n> Thanks! Looking for your feedback and thoughts on this.\n>\n> -Sridhar"
            }
        ],
        "thread_summary": {
            "title": "CoinPools based on m-of-n Schnorr aggregated signatures",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sridhar G",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8583
        }
    },
    {
        "title": "[bitcoin-dev] Against proprietary and PoR fields in PSBT BIP174",
        "thread_messages": [
            {
                "author": "Ferdinando M. Ametrano",
                "date": "2020-11-16T23:01:34",
                "message_text_only": "Hi all,\n\nWhile implementing PSBT support in the *btclib* library (\nhttps://github.com/btclib-org/btclib), I have failed to understand the\nrationale for the *proprietary* and *proof-of-reserves* types.\n\nFirst off, at face value they have nothing to do with the operations\nintrinsically required to finalize a valid transaction from PSBT\nmanipulation.\n\nMoreover, whatever information content they can provide for non-standard\nPSBT manipulation, that content could stay in the *unknown* field without\nany loss of generality. How to structure and deal with unknown data would\nbe the responsibility of proprietary software or users wanting to provide\nproof-of-reserve. As long as BIP174 clearly prescribes that unknown data\nmust be kept during PSBT manipulation, that should be enough.\n\nLet me stress the above point: I have a project where we include\nproprietary information in the PSBT. Any PSBT software supporting unknown\ndata gently keeps our proprietary information and our proprietary software\nretrieves that data from serialized PSBT with no problem. There is no need\nfor a PSBT implementation to provide explicit support for *proprietary* and\n*proof-of-reserves* types.\n\nMy last conclusion is reinforced by the evidence of all PSBT\nimplementations I know of, including bitcoin core and HWI, not implementing\nproprietary and proof-of-reserve types. There is a high probability that\npart of BIP174 would be just ignored.\n\nAm I missing something?\n\nThanks\n--\n*Ferdinando M. Ametrano*\nwww.ametrano.net/about\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201117/0e8032c8/attachment.html>"
            },
            {
                "author": "Ferdinando M. Ametrano",
                "date": "2020-11-16T23:38:19",
                "message_text_only": "After having checked that the BIP174 test vectors do not cover the\n*proprietary* and *proof-of-reserves* types, I went ahead and submitted a\nPR to the bips repo for the removal of those fields from the PSBT\nspecifications\n\nhttps://github.com/bitcoin/bips/pull/1038\n\n--\n*Ferdinando M. Ametrano*\nwww.ametrano.net/about\n\n\nOn Tue, Nov 17, 2020 at 12:01 AM Ferdinando M. Ametrano <\nferdinando at ametrano.net> wrote:\n\n> Hi all,\n>\n> While implementing PSBT support in the *btclib* library (\n> https://github.com/btclib-org/btclib), I have failed to understand the\n> rationale for the *proprietary* and *proof-of-reserves* types.\n>\n> First off, at face value they have nothing to do with the operations\n> intrinsically required to finalize a valid transaction from PSBT\n> manipulation.\n>\n> Moreover, whatever information content they can provide for non-standard\n> PSBT manipulation, that content could stay in the *unknown* field without\n> any loss of generality. How to structure and deal with unknown data would\n> be the responsibility of proprietary software or users wanting to provide\n> proof-of-reserve. As long as BIP174 clearly prescribes that unknown data\n> must be kept during PSBT manipulation, that should be enough.\n>\n> Let me stress the above point: I have a project where we include\n> proprietary information in the PSBT. Any PSBT software supporting unknown\n> data gently keeps our proprietary information and our proprietary software\n> retrieves that data from serialized PSBT with no problem. There is no need\n> for a PSBT implementation to provide explicit support for *proprietary*\n> and *proof-of-reserves* types.\n>\n> My last conclusion is reinforced by the evidence of all PSBT\n> implementations I know of, including bitcoin core and HWI, not implementing\n> proprietary and proof-of-reserve types. There is a high probability that\n> part of BIP174 would be just ignored.\n>\n> Am I missing something?\n>\n> Thanks\n> --\n> *Ferdinando M. Ametrano*\n> www.ametrano.net/about\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201117/3fe0ccf0/attachment.html>"
            },
            {
                "author": "Jonathan Underwood",
                "date": "2020-11-26T23:24:32",
                "message_text_only": "It is very common to set aside one or more \"version slots\" for proprietary\nusage so that people adding their own features don't use version 7 only to\nhave the official BIP add a REAL version 7 a couple months later.\nIt makes perfect sense to just say \"anyone adding their own stuff, format\nyour versions like this and stay out of our way\"\nAs a BIP174 library, you don't have to add logic to \"support\" those\nversions, just treat them as unknown. The only people who will need to\nworry about the logic of parsing and encoding those versions are apps that\nutilize them.\n\n2020\u5e7411\u670817\u65e5(\u706b) 8:41 Ferdinando M. Ametrano via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> After having checked that the BIP174 test vectors do not cover the\n> *proprietary* and *proof-of-reserves* types, I went ahead and submitted a\n> PR to the bips repo for the removal of those fields from the PSBT\n> specifications\n>\n> https://github.com/bitcoin/bips/pull/1038\n>\n> --\n> *Ferdinando M. Ametrano*\n> www.ametrano.net/about\n>\n>\n> On Tue, Nov 17, 2020 at 12:01 AM Ferdinando M. Ametrano <\n> ferdinando at ametrano.net> wrote:\n>\n>> Hi all,\n>>\n>> While implementing PSBT support in the *btclib* library (\n>> https://github.com/btclib-org/btclib), I have failed to understand the\n>> rationale for the *proprietary* and *proof-of-reserves* types.\n>>\n>> First off, at face value they have nothing to do with the operations\n>> intrinsically required to finalize a valid transaction from PSBT\n>> manipulation.\n>>\n>> Moreover, whatever information content they can provide for non-standard\n>> PSBT manipulation, that content could stay in the *unknown* field\n>> without any loss of generality. How to structure and deal with unknown data\n>> would be the responsibility of proprietary software or users wanting to\n>> provide proof-of-reserve. As long as BIP174 clearly prescribes that\n>> unknown data must be kept during PSBT manipulation, that should be enough.\n>>\n>> Let me stress the above point: I have a project where we include\n>> proprietary information in the PSBT. Any PSBT software supporting unknown\n>> data gently keeps our proprietary information and our proprietary software\n>> retrieves that data from serialized PSBT with no problem. There is no need\n>> for a PSBT implementation to provide explicit support for *proprietary*\n>> and *proof-of-reserves* types.\n>>\n>> My last conclusion is reinforced by the evidence of all PSBT\n>> implementations I know of, including bitcoin core and HWI, not implementing\n>> proprietary and proof-of-reserve types. There is a high probability that\n>> part of BIP174 would be just ignored.\n>>\n>> Am I missing something?\n>>\n>> Thanks\n>> --\n>> *Ferdinando M. Ametrano*\n>> www.ametrano.net/about\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201127/e60d2a92/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Against proprietary and PoR fields in PSBT BIP174",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jonathan Underwood",
                "Ferdinando M. Ametrano"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 7109
        }
    },
    {
        "title": "[bitcoin-dev] Bulletin boards without selective censorability for bitcoin fungibility markets",
        "thread_messages": [
            {
                "author": "AdamISZ",
                "date": "2020-11-23T00:40:56",
                "message_text_only": "Canvassing opinions/critiques from those working on bitcoin and related protocols.\n\nSee the attached gist for a write-up of an outline of an idea, which is conceived for joinmarket but can apply in other scenarios where there is market for liquidity and in which privacy is a very high priority (hence 'bitcoin fungibility markets' can certainly include coinswap along with coinjoin, but possibly other things):\n\nhttps://gist.github.com/AdamISZ/b52704905cdd914ec9dac9fc52b621d6\n\nAbstract reproduced below:\n\nMakers need a reasonable guarantee that their offers will not be censored, and therefore will be available to any taker requesting the joining service.\n\nThis is today, in Joinmarket specifically, somewhat achieved through the use of redundancy. In particular, 2 or sometimes 3 independent IRC servers are used simultaneously, and the makers and takers use digitial signatures to ensure that spoofing other users is not possible. This model is limited however; not only because IRC servers are not ideal for this purpose (being principally designed for human text chat, not bot traffic), but also because at the least, we trust that the IRC servers are not colluding together to selectively censor individual participants. The risk of censorship of that type is ameliorated by the fact that makers connect (almost exclusively) over Tor, to the hidden service / onion of the IRC servers. Still, since these bots persist and use the same nick over multiple servers, and since their offering amounts, fees etc. may sometimes fingerprint them, selective censorship is possible, again, if there is collusion.\n\nIn this document I present a sketch of an approach to make such selective censorship very difficult using cryptographic blinding as well as a proof-of-misbehavior approach; the former making selective censorship very difficult to achieve, and the latter strongly disincentivising it.\n\nNote that here \"selective\" is a very important word, but total censorship and random censorship should also be ineffective and disincentivised, for fairly obvious reasons, although I will outline them.\n\nIf the desired effect is achieved, we can reasonably run Joinmarket or a similar system on a single bulletin board server, with the caveat that it will need to be sufficiently easy to stand up a new instance; this should be true as long as the code is open source and the resource requirements are not excessive.\n\nIt should also be noted that the design here is of course not specific to CoinJoin, but would also work the same way for CoinSwap (so \"bitcoin fungibility markets\") and perhaps other similar bitcoin-native systems whenever the concept of a \"liquidity maker\" (henceforth \"maker\") applies, so perhaps second layer also (this has not been investigated).\n\nRegards,\nwaxwing\n\nSent with ProtonMail Secure Email."
            },
            {
                "author": "AdamISZ",
                "date": "2020-11-23T12:24:18",
                "message_text_only": "\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, 23 November 2020 00:40, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Canvassing opinions/critiques from those working on bitcoin and related protocols.\n>\n> See the attached gist for a write-up of an outline of an idea, which is conceived for joinmarket but can apply in other scenarios where there is market for liquidity and in which privacy is a very high priority (hence 'bitcoin fungibility markets' can certainly include coinswap along with coinjoin, but possibly other things):\n>\n> https://gist.github.com/AdamISZ/b52704905cdd914ec9dac9fc52b621d6\n\nGreg Maxwell pointed out to me on IRC that this idea doesn't work: there is only a receipt on the commitment to the offer (message) from the maker, not on the plaintext version, hence there is nothing stopping the maker from falsely claiming censorship after not sending the plaintext.\n\nReflecting on this a bit more, my intuition is that this problem is much more difficult than I had hoped; if there is a solution I suspect it involves much more sophisticated ideas. Many solutions just end up begging the question by presuming the existence of an uncensorable BB in order to create a new one; and/or use the blockchain for that function, but that is too slow and expensive, usually. I'd be happy to be proved wrong, though :)\n\nwaxwing"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-11-23T13:53:15",
                "message_text_only": "Hi Adam,\n\nThat's a tricky issue you're trying to tackle.\n\n>and/or use the blockchain for that function, but that is too slow and\nexpensive, usually\n\nWhile perhaps not the most easy/practical path to take, it IS possible to\ncreate a custom blockchain for this specific purpose to use as a\ncensorship-resistant data layer via Blind Merged Mining:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-December/017534.html\n\nNote that while it's not described in detail in my post, there is a\n(slightly suboptimal) way to do it without a soft fork.\n\nAnd here are more details about the perpetual one-way peg mechanism (needed\nto pay for fees without introducing speculation):\nhttps://medium.com/@RubenSomsen/21-million-bitcoins-to-rule-all-sidechains-the-perpetual-one-way-peg-96cb2f8ac302\n\nCheers,\nRuben\n\nOn Mon, Nov 23, 2020 at 1:59 PM AdamISZ via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, 23 November 2020 00:40, AdamISZ via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Canvassing opinions/critiques from those working on bitcoin and related\n> protocols.\n> >\n> > See the attached gist for a write-up of an outline of an idea, which is\n> conceived for joinmarket but can apply in other scenarios where there is\n> market for liquidity and in which privacy is a very high priority (hence\n> 'bitcoin fungibility markets' can certainly include coinswap along with\n> coinjoin, but possibly other things):\n> >\n> > https://gist.github.com/AdamISZ/b52704905cdd914ec9dac9fc52b621d6\n>\n> Greg Maxwell pointed out to me on IRC that this idea doesn't work: there\n> is only a receipt on the commitment to the offer (message) from the maker,\n> not on the plaintext version, hence there is nothing stopping the maker\n> from falsely claiming censorship after not sending the plaintext.\n>\n> Reflecting on this a bit more, my intuition is that this problem is much\n> more difficult than I had hoped; if there is a solution I suspect it\n> involves much more sophisticated ideas. Many solutions just end up begging\n> the question by presuming the existence of an uncensorable BB in order to\n> create a new one; and/or use the blockchain for that function, but that is\n> too slow and expensive, usually. I'd be happy to be proved wrong, though :)\n>\n> waxwing\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201123/32a9a5c5/attachment.html>"
            },
            {
                "author": "yanmaani at cock.li",
                "date": "2020-11-25T01:52:08",
                "message_text_only": "On 2020-11-23 12:24, AdamISZ via bitcoin-dev wrote:\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Monday, 23 November 2020 00:40, AdamISZ via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> Canvassing opinions/critiques from those working on bitcoin and \n>> related protocols.\n>> \n>> See the attached gist for a write-up of an outline of an idea, which \n>> is conceived for joinmarket but can apply in other scenarios where \n>> there is market for liquidity and in which privacy is a very high \n>> priority (hence 'bitcoin fungibility markets' can certainly include \n>> coinswap along with coinjoin, but possibly other things):\n>> \n>> https://gist.github.com/AdamISZ/b52704905cdd914ec9dac9fc52b621d6\n> \n> Greg Maxwell pointed out to me on IRC that this idea doesn't work:\n> there is only a receipt on the commitment to the offer (message) from\n> the maker, not on the plaintext version, hence there is nothing\n> stopping the maker from falsely claiming censorship after not sending\n> the plaintext.\n> \n> Reflecting on this a bit more, my intuition is that this problem is\n> much more difficult than I had hoped; if there is a solution I suspect\n> it involves much more sophisticated ideas. Many solutions just end up\n> begging the question by presuming the existence of an uncensorable BB\n> in order to create a new one; and/or use the blockchain for that\n> function, but that is too slow and expensive, usually. I'd be happy to\n> be proved wrong, though :)\n> \n> waxwing\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nBlockchains are bad for this, because you don't want for it to cost \nmoney to use your bulletin board. However, the problem was solved more \nthan a decade ago. Look into FMS, which combines Usenet/mailing lists \nwith a web of trust for spam resistance."
            }
        ],
        "thread_summary": {
            "title": "Bulletin boards without selective censorability for bitcoin fungibility markets",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "yanmaani at cock.li",
                "AdamISZ",
                "Ruben Somsen"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 8816
        }
    },
    {
        "title": "[bitcoin-dev] Formal specification of Miniscript in Alloy",
        "thread_messages": [
            {
                "author": "Dmitry Petukhov",
                "date": "2020-11-25T11:15:55",
                "message_text_only": "I have created a formal specification of Miniscript [1] using\nthe specification language of Alloy analyzer [2]\n\nLink: https://github.com/dgpv/miniscript-alloy-spec\n\nPossible uses for the spec:\n\n- Implementing Miniscript libraries, as additional reference that might\n  be easier to navigate than prose spec\n\n- Generating test cases for implementations, although currently this\n  will be a manual process due to the tools limitation (can be overcome\n  with GUI automation)\n\n- Checking the implementation against the spec, by writing a program\n  that would generate Alloy .als files from the data structures of the\n  implementation, and then checking these files in Alloy\n\n- Extending or amending Miniscript, if the need arise. Having\n  extenstions and changes checked (with bounds) against a spec should\n  help catch inconsistencies\n\n- Exploring the properties of Miniscript\n\nIf you have an interest in Miniscript, please consider looking at the\nspec and share your ideas.\n\nThe spec may contain mistakes, as it was not yet checked against any\nimplementation, it was only checked for consistency using its own\npredicates, with the scope of up to 8 nodes.\n\nIf you notice a mistake or inconsistency, please submit an issue on\ngithub (or communicate this in other ways)\n\n[1] http://bitcoin.sipa.be/miniscript/\n[2] https://alloytools.org/"
            },
            {
                "author": "Clark Moody",
                "date": "2020-11-25T15:43:10",
                "message_text_only": "Thanks for this! I can't comment on the correctness of your implementation,\nbut I really appreciate the idea and effort.\n\nBy chance, did you come across any other spec definitions in alternate\nformal grammars?\n\n\n-Clark\n\n\nOn Wed, Nov 25, 2020 at 5:35 AM Dmitry Petukhov via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have created a formal specification of Miniscript [1] using\n> the specification language of Alloy analyzer [2]\n>\n> Link: https://github.com/dgpv/miniscript-alloy-spec\n>\n> Possible uses for the spec:\n>\n> - Implementing Miniscript libraries, as additional reference that might\n>   be easier to navigate than prose spec\n>\n> - Generating test cases for implementations, although currently this\n>   will be a manual process due to the tools limitation (can be overcome\n>   with GUI automation)\n>\n> - Checking the implementation against the spec, by writing a program\n>   that would generate Alloy .als files from the data structures of the\n>   implementation, and then checking these files in Alloy\n>\n> - Extending or amending Miniscript, if the need arise. Having\n>   extenstions and changes checked (with bounds) against a spec should\n>   help catch inconsistencies\n>\n> - Exploring the properties of Miniscript\n>\n> If you have an interest in Miniscript, please consider looking at the\n> spec and share your ideas.\n>\n> The spec may contain mistakes, as it was not yet checked against any\n> implementation, it was only checked for consistency using its own\n> predicates, with the scope of up to 8 nodes.\n>\n> If you notice a mistake or inconsistency, please submit an issue on\n> github (or communicate this in other ways)\n>\n> [1] http://bitcoin.sipa.be/miniscript/\n> [2] https://alloytools.org/\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201125/b23d248c/attachment.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2020-11-25T16:09:46",
                "message_text_only": "\u0412 Wed, 25 Nov 2020 09:43:10 -0600\nClark Moody <clark at clarkmoody.com> wrote:\n\n> Thanks for this! I can't comment on the correctness of your\n> implementation, but I really appreciate the idea and effort.\n> \n> By chance, did you come across any other spec definitions in alternate\n> formal grammars?\n\nAs far as I know, this is the first formal spec for Miniscript.\n\nI also considered using the K framework [1] for the task (it would\nalso give the parser out of the box), but at the time it did not have\nthe reference documentation, only tutorials on their site. It seems that\nthey have published the new site, with more documentation.\n\nI am satisfied with how Alloy spec turned out, though - in my opinion,\nthe node definitions in the spec are very readable.\n\n[1] https://kframework.org/\n\n\n> On Wed, Nov 25, 2020 at 5:35 AM Dmitry Petukhov via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > I have created a formal specification of Miniscript [1] using\n> > the specification language of Alloy analyzer [2]\n> >\n> > Link: https://github.com/dgpv/miniscript-alloy-spec\n> >\n> > Possible uses for the spec:\n> >\n> > - Implementing Miniscript libraries, as additional reference that\n> > might be easier to navigate than prose spec\n> >\n> > - Generating test cases for implementations, although currently this\n> >   will be a manual process due to the tools limitation (can be\n> > overcome with GUI automation)\n> >\n> > - Checking the implementation against the spec, by writing a program\n> >   that would generate Alloy .als files from the data structures of\n> > the implementation, and then checking these files in Alloy\n> >\n> > - Extending or amending Miniscript, if the need arise. Having\n> >   extenstions and changes checked (with bounds) against a spec\n> > should help catch inconsistencies\n> >\n> > - Exploring the properties of Miniscript\n> >\n> > If you have an interest in Miniscript, please consider looking at\n> > the spec and share your ideas.\n> >\n> > The spec may contain mistakes, as it was not yet checked against any\n> > implementation, it was only checked for consistency using its own\n> > predicates, with the scope of up to 8 nodes.\n> >\n> > If you notice a mistake or inconsistency, please submit an issue on\n> > github (or communicate this in other ways)\n> >\n> > [1] http://bitcoin.sipa.be/miniscript/\n> > [2] https://alloytools.org/\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >"
            }
        ],
        "thread_summary": {
            "title": "Formal specification of Miniscript in Alloy",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Clark Moody",
                "Dmitry Petukhov"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5995
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal: Elliptic SSS scheme",
        "thread_messages": [
            {
                "author": "Egor Zuev",
                "date": "2020-11-27T17:12:29",
                "message_text_only": "Hi everyone!\n\nWould like to propose the solution for sharing the private key / other\nsensitive information with a modified SSS scheme.\n\nThe key features are:\n1) the secret restoration is not possible without corresponding signatures\n2) share[i] belongs to privateKey[i] only, which means it can't be signed\nwith a different private key\n\nI hope this approach can help on the application level to share sensitive\ninformation or it can be used as m-of-n multi-signature (this is\ndiscussable). I've attached the pdf file with the concept description. Also\nhere is the repo with a working example in node.js:\nhttps://github.com/ega-forever/esss\n\nThanks in advance for your time.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201127/d56cfd65/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: musig-esss.v1.pdf\nType: application/pdf\nSize: 207167 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201127/d56cfd65/attachment-0001.pdf>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal: Elliptic SSS scheme",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Egor Zuev"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1136
        }
    },
    {
        "title": "[bitcoin-dev] Out-of-band transaction fees",
        "thread_messages": [
            {
                "author": "Sebastian Geisler",
                "date": "2020-11-30T23:03:06",
                "message_text_only": "Hi all,\n\nthe possibility of out of band transaction fee payments is a well known\nfact. Yet it has been mostly discussed as an annoying inevitability that\ncan be problematic if on-chain fees are to be used as a consensus\nparameter. The potential use cases have seen little interest though\n(please correct me if I'm wrong).\n\nOne such use case is sending UTXOs \"intact\". Let's assume we get to a\npoint where Bitcoin is primarily a settlement layer for L2 systems.\nThese L2 systems might want to protect their privacy and keep UTXOs of a\ncommon sizes (e.g. 1 BTC, 10 BTC, \u2026). For certain settlement\napplications these can be transferred as a whole, but currently fee\nrequirements force the system to add another input for fees which will\nintroduce taint (because it's used repeatedly). If instead a fee could\nbe paid out of band in a privacy preserving way the TXO chain would leak\nlittle about the intermediate holders.\n\nTaking this concept even further CoinJoin-like protocols could also be\nused to introduce further ambiguity without leaking that a certain\nentity took part in the CJ (which fee inputs/reused \"toxic waste\"\ninevitably do afaik). Such a mechanism would probably also make CJ\ntransactions much smaller as _no_ fee inputs had to be provided\n(assuming the inputs already have the right size).\n\nOut-of-band transaction \"accelerators\" already exist and taking fee\npayment out-of-band can not be effectively prevented. So even though any\nsuch proposal will probably have slight centralizing effects I believe\nthat having a standard for it is preferable to having every pool\nimplement their own API making it harder for small pools to get into the\nmarket.\n\nImo the central questions are:\n * how to build such a out-of-band \"transaction bounty\" system\n * how to standardized it\n * how can the centralizing effects from it be mitigated\n\nImo fees are small enough to not really care about counter party risk\nthat much. It's more important that it is easy to run so that there is\nsome choice for users and miners. In that sense I consider\nsingle-operator services providing both standardized user and miner APIs\nas well as an optional UI suitable. I would still take into account that\nthis could change and might consider the needs of federated services in\nthe protocol.\n\nEach such service would need to announce which means of payment it\nsupports and allow users and miners to choose when paying/redeeming\nfees. Users should be able to submit transactions and either be\npresented with a single payment method dependent \"invoice\" or one per\ninput (for the CoinJoin use case). As soon as all invoices are paid the\nbounty goes live and is visible to miners through an API.\n\nMiners that included a transaction need a way to authenticate when\nclaiming the bounty. One possibility would be to optionally include a\nunique public key e.g. in the coinbase scriptsig after the height push\n(is this feasible?). This could be used to claim any bounties after 100,\n120, or even a user-defined confirmation threshold is met. If the key is\nunique for every block there won't be a problem with pool accountability\nwhich might become a risk down the road (so this should also be enforced\nat least in the bounty protocol to avoid lazy implementations leading to\ndangerous precedents).\n\nAny feedback is welcome :)\n\ntl;dr Out-of-band fee payment services are inevitable and useful, so we\nshould at least standardize them and mitigate negative effects as much\nas possible.\n\nBest,\nSebastian"
            }
        ],
        "thread_summary": {
            "title": "Out-of-band transaction fees",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sebastian Geisler"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3472
        }
    }
]