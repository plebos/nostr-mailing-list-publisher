[
    {
        "title": "[bitcoin-dev] I do not support the BIP 148 UASF",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-05-02T16:54:35",
                "message_text_only": "If the flag day for a wtxid commitment is timed before the current segwit\nperiod end, I suspect segwit would activate within the current period.\n\nOn Tue, Apr 25, 2017 at 2:46 PM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tuesday 25 April 2017 6:28:14 PM Gregory Maxwell via bitcoin-dev wrote:\n> > > https://github.com/bitcoin/bitcoin/compare/master...\n> shaolinfry:uasegwit-f\n> > > lagday\n> > >\n> > > I believe this approach would satisfy the more measured approach\n> expected\n> > > for Bitcoin and does not have the issues you brought up about BIP148.\n> >\n> > I have not reviewed it carefully yet, but I agree that it addresses my\n> > main concern!  I think this is a much better approach. Thanks.\n>\n> FWIW, I disagree in this case. I think given the circumstances, if we are\n> going to do a UASF for segwit at all, we need a clearly decisive outcome,\n> which is given by BIP 148. Using the approach in BIP 8 makes sense in many\n> cases, but in this case, it is liable to simply create a prolonged\n> uncertainty\n> where nobody knows the outcome when segwit's rules are challenged by a\n> malicious miner.\n>\n> If BIP 148 fails to achieve widespread support, we could do a BIP 8-based\n> UASF\n> with Segwit v2 (along with some other changes I suggested in the other\n> thread), but I think the tradeoffs right now favour BIP 148 as the best\n> UASF\n> deployment.\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170502/0cee5728/attachment.html>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2017-05-22T19:23:22",
                "message_text_only": "I also do not support the BIP 148 UASF, and I'd like to add to the points\nthat Greg has already raised in this thread.\n\nBIP 148 would introduce a new consensus rule that softforks out non-segwit\nsignalling blocks in some time period.  I reject this consensus rule as\nboth arbitrary and needlessly disruptive.  Bitcoin's primary purpose is to\nreach consensus on the state of a shared ledger, and even though I think\nthe Bitcoin network ought to adopt segwit, I don't think that concern\ntrumps the goal of not splitting the network.\n\nMany BIP 148 advocates seem to start with the assumption that segwit\nalready has a lot of support, and suggest that BIP 148 does as well.\nHowever I don't think it's fair or correct to separate the activation\nproposal for segwit from the rest of the segwit proposal.  The deployment\nparameters for segwit are consensus-critical; assuming that some other\ndeployment has consensus because it would result in the rest of the segwit\nproposal activating is an unjustified leap.\n\nEven if there were no feasible alternate segwit deployment method available\nto us, I would hesitate to recommend that the network adopt a potentially\nconsensus-splitting approach, even though I firmly believe that the ideas\nbehind segwit are fundamentally good ones.  But fortunately that is not the\nsituation we are in; we have substantially less disruptive methods\navailable to us to activate it, even if the current BIP 9 deployment were\nto fail -- such as another BIP 9 deployment in the future, or perhaps a BIP\n149 deployment.\n\nIf we do pursue a \"user-activated\" deployment of segwit, I'd recommend that\nwe do so in a more careful way than BIP 148 or 149 currently suggest, which\nas I understand would otherwise make very few changes to the current\nimplementation.  However, due to the BIP 9 activation assumption, the\nBitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together\nthe idea that miners would both enforce the rules and mine segwit blocks.\nHowever, we can separate these concerns, as we started to do in the Bitcoin\nCore 0.14.1 release, where mining segwit blocks is not required in order to\ngenerally mine or signal for segwit in the software.  And we can go further\nstill: without too much work, we could make further improvements to\naccommodate miners who, for whatever reason, don't want to upgrade their\nsystems, such as by improving block relay from pre-segwit peers [1], or\noptimizing transaction selection for miners who are willing to enforce the\nsegwit rules but haven't upgraded their systems to mine segwit blocks [2].\n\nIf we would seek to activate a soft-fork with less clear miner signaling\n(such as BIP 149), then I think such improvements are warranted to minimize\nnetwork disruption.  In general, we should not seek to censor hashpower on\nthe network unless we have a very important reason for doing so.  While the\nissues here are nuanced, if I were to evaluate the BIP 148 soft-fork\nproposal on the spectrum of \"censorship attack on Bitcoin\" to \"benign\nprotocol upgrade\", BIP 148 strikes me as closer to the former than the\nlatter.  There is simply no need here to orphan these non-signalling blocks\nthat could otherwise be used to secure the network.\n\nTo go further: I think BIP 148 is ill-conceived even for achieving its own\npresumed goals -- the motivation for adding a consensus rule that applies\nto the version bits on blocks is surely for the effect such bits have on\nolder software, such as Bitcoin Core releases 0.13.1 and later.  Yet in\ntrying to bring those implementations along as segwit-enforcing software,\nBIP 148 would risk forking from such clients in the short term!  If one\nreally cared about maintaining consensus with older, segwit-enabled\nsoftware, it would make far more sense to seek segwit activation in a way\nthat didn't fork from them (such as BIP 149, or a new BIP 9 deployment\nafter this one times out).  And if one doesn't care about such consensus,\nthen it'd be far simpler to just set (e.g.) August 1 as the flag day\nactivation of segwit, and not play these contortionist games with block\nversion bits, which carry no useful or intrinsic meaning.  Either of these\ntwo approaches should have the advantage of reduced fork risk, compared\nwith BIP 148.\n\nOf course, everyone is free to run the software of their choosing.  I write\nthis to both generally convey my opposition to a careless proposal, which I\nbelieve represents a way of thinking that is detrimental to Bitcoin's long\nrun success, and specifically explain why I oppose inclusion of this\nproposal in the Bitcoin Core implementation [3].  The Bitcoin Core project\nhasn't been, and shouldn't be, careless in deploying consensus changes.\nInstead, I think the Bitcoin Core project ought to stand up for the best\npractices that our community has learned about how to deploy such changes\n(specifically for minimizing chain-split risk when deploying a soft fork!),\nand I think we should all avoid adoption or encouragement of practices that\nwould depart from the high standards we are capable of achieving.\n\n\n [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017\n-March/013811.html\n [2] https://github.com/bitcoin/bitcoin/pull/9955\n [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925\n\n\n--Suhas Daftuar\n\n\nOn Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I do not support the BIP148 UASF for some of the same reasons that I\n> do support segwit:  Bitcoin is valuable in part because it has high\n> security and stability, segwit was carefully designed to support and\n> amplify that engineering integrity that people can count on now and\n> into the future.\n>\n> I do not feel the the approach proposed in BIP148 really measures up\n> to the standard set by segwit itself, or the existing best practices\n> in protocol development in this community.\n>\n> The primary flaw in BIP148 is that by forcing the activation of the\n> existing (non-UASF segwit) nodes it almost guarantees at a minor level\n> of disruption.\n>\n> Segwit was carefully engineered so that older unmodified miners could\n> continue operating _completely_ without interruption after segwit\n> activates.\n>\n> Older nodes will not include segwit spends, and so their blocks will\n> not be invalid even if they do not have segwit support. They can\n> upgrade to it on their own schedule. The only risk non-participating\n> miners take after segwit activation is that if someone else mines an\n> invalid block they would extend it, a risk many miners already\n> frequently take with spy-mining.\n>\n> I do not think it is a horrible proposal: it is better engineered than\n> many things that many altcoins do, but just not up to our normal\n> standards. I respect the motivations of the authors of BIP 148.  If\n> your goal is the fastest possible segwit activation then it is very\n> useful to exploit the >80% of existing nodes that already support the\n> original version of segwit.\n>\n> But the fastest support should not be our goal, as a community-- there\n> is always some reckless altcoin or centralized system that can support\n> something faster than we can-- trying to match that would only erode\n> our distinguishing value in being well engineered and stable.\n>\n> \"First do no harm.\" We should use the least disruptive mechanisms\n> available, and the BIP148 proposal does not meet that test.  To hear\n> some people-- non-developers on reddit and such-- a few even see the\n> forced orphaning of 148 as a virtue, that it's punitive for\n> misbehaving miners. I could not not disagree with that perspective any\n> more strongly.\n>\n> Of course, I do not oppose the general concept of a UASF but\n> _generally_ a soft-fork (of any kind) does not need to risk disruption\n> of mining, just as segwit's activation does not.  UASF are the\n> original kind of soft-fork and were the only kind of fork practiced by\n> Satoshi. P2SH was activated based on a date, and all prior ones were\n> based on times or heights.  We introduced miner based activation as\n> part of a process of making Bitcoin more stable in the common case\n> where the ecosystem is all in harmony.  It's kind of weird to see UASF\n> portrayed as something new.\n>\n> It's important the users not be at the mercy of any one part of the\n> ecosystem to the extent that we can avoid it-- be it developers,\n> exchanges, chat forums, or mining hardware makers.  Ultimately the\n> rules of Bitcoin work because they're enforced by the users\n> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it\n> something people can count on: the rules aren't easy to just change.\n>\n> There have been some other UASF proposals that avoid the forced\n> disruption-- by just defining a new witness bit and allowing\n> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I\n> think they are vastly superior. They would be slower to deploy, but I\n> do not think that is a flaw.\n>\n> We should have patience. Bitcoin is a system that should last for all\n> ages and power mankind for a long time-- ten years from now a couple\n> years of dispute will seem like nothing. But the reputation we earn\n> for stability and integrity, for being a system of money people can\n> count on will mean everything.\n>\n> If these discussions come up, they'll come up in the form of reminding\n> people that Bitcoin isn't easily changed at a whim, even when the\n> whims are obviously good, and how that protects it from being managed\n> like all the competing systems of money that the world used to use\n> were managed. :)\n>\n> So have patience, don't take short cuts.  Segwit is a good improvement\n> and we should respect it by knowing that it's good enough to wait for,\n> and for however its activated to be done the best way we know how.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/8cfe10a6/attachment-0001.html>"
            },
            {
                "author": "Steven Pine",
                "date": "2017-05-23T04:03:49",
                "message_text_only": "I'm glad some discussion has been moved back here.\n\nCorrect me if I am wrong, but currently core developers are arguing over\nwhether or not to allow an optional configuration switch which defaults off\nbut signals and enforces BIP148 when used. Who are we protecting users\nfrom, themselves? Are you protecting core? from what? I am somewhat\ngenuinely befuddled by those who can't even allow a user config switch to\nbe set.\n\nI guess I find it all incredibly silly, but perhaps I suffer from some\nbasic confusion.\n\n\n\nOn Mon, May 22, 2017 at 3:23 PM, Suhas Daftuar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I also do not support the BIP 148 UASF, and I'd like to add to the points\n> that Greg has already raised in this thread.\n>\n> BIP 148 would introduce a new consensus rule that softforks out non-segwit\n> signalling blocks in some time period.  I reject this consensus rule as\n> both arbitrary and needlessly disruptive.  Bitcoin's primary purpose is to\n> reach consensus on the state of a shared ledger, and even though I think\n> the Bitcoin network ought to adopt segwit, I don't think that concern\n> trumps the goal of not splitting the network.\n>\n> Many BIP 148 advocates seem to start with the assumption that segwit\n> already has a lot of support, and suggest that BIP 148 does as well.\n> However I don't think it's fair or correct to separate the activation\n> proposal for segwit from the rest of the segwit proposal.  The deployment\n> parameters for segwit are consensus-critical; assuming that some other\n> deployment has consensus because it would result in the rest of the segwit\n> proposal activating is an unjustified leap.\n>\n> Even if there were no feasible alternate segwit deployment method\n> available to us, I would hesitate to recommend that the network adopt a\n> potentially consensus-splitting approach, even though I firmly believe that\n> the ideas behind segwit are fundamentally good ones.  But fortunately that\n> is not the situation we are in; we have substantially less disruptive\n> methods available to us to activate it, even if the current BIP 9\n> deployment were to fail -- such as another BIP 9 deployment in the future,\n> or perhaps a BIP 149 deployment.\n>\n> If we do pursue a \"user-activated\" deployment of segwit, I'd recommend\n> that we do so in a more careful way than BIP 148 or 149 currently suggest,\n> which as I understand would otherwise make very few changes to the current\n> implementation.  However, due to the BIP 9 activation assumption, the\n> Bitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together\n> the idea that miners would both enforce the rules and mine segwit blocks.\n> However, we can separate these concerns, as we started to do in the Bitcoin\n> Core 0.14.1 release, where mining segwit blocks is not required in order to\n> generally mine or signal for segwit in the software.  And we can go further\n> still: without too much work, we could make further improvements to\n> accommodate miners who, for whatever reason, don't want to upgrade their\n> systems, such as by improving block relay from pre-segwit peers [1], or\n> optimizing transaction selection for miners who are willing to enforce the\n> segwit rules but haven't upgraded their systems to mine segwit blocks [2].\n>\n> If we would seek to activate a soft-fork with less clear miner signaling\n> (such as BIP 149), then I think such improvements are warranted to minimize\n> network disruption.  In general, we should not seek to censor hashpower on\n> the network unless we have a very important reason for doing so.  While the\n> issues here are nuanced, if I were to evaluate the BIP 148 soft-fork\n> proposal on the spectrum of \"censorship attack on Bitcoin\" to \"benign\n> protocol upgrade\", BIP 148 strikes me as closer to the former than the\n> latter.  There is simply no need here to orphan these non-signalling blocks\n> that could otherwise be used to secure the network.\n>\n> To go further: I think BIP 148 is ill-conceived even for achieving its own\n> presumed goals -- the motivation for adding a consensus rule that applies\n> to the version bits on blocks is surely for the effect such bits have on\n> older software, such as Bitcoin Core releases 0.13.1 and later.  Yet in\n> trying to bring those implementations along as segwit-enforcing software,\n> BIP 148 would risk forking from such clients in the short term!  If one\n> really cared about maintaining consensus with older, segwit-enabled\n> software, it would make far more sense to seek segwit activation in a way\n> that didn't fork from them (such as BIP 149, or a new BIP 9 deployment\n> after this one times out).  And if one doesn't care about such consensus,\n> then it'd be far simpler to just set (e.g.) August 1 as the flag day\n> activation of segwit, and not play these contortionist games with block\n> version bits, which carry no useful or intrinsic meaning.  Either of these\n> two approaches should have the advantage of reduced fork risk, compared\n> with BIP 148.\n>\n> Of course, everyone is free to run the software of their choosing.  I\n> write this to both generally convey my opposition to a careless proposal,\n> which I believe represents a way of thinking that is detrimental to\n> Bitcoin's long run success, and specifically explain why I oppose inclusion\n> of this proposal in the Bitcoin Core implementation [3].  The Bitcoin Core\n> project hasn't been, and shouldn't be, careless in deploying consensus\n> changes.  Instead, I think the Bitcoin Core project ought to stand up for\n> the best practices that our community has learned about how to deploy such\n> changes (specifically for minimizing chain-split risk when deploying a soft\n> fork!), and I think we should all avoid adoption or encouragement of\n> practices that would depart from the high standards we are capable of\n> achieving.\n>\n>\n>  [1] https://lists.linuxfoundation.org/pipermail/\n> bitcoin-dev/2017-March/013811.html\n>  [2] https://github.com/bitcoin/bitcoin/pull/9955\n>  [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925\n>\n>\n> --Suhas Daftuar\n>\n>\n> On Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I do not support the BIP148 UASF for some of the same reasons that I\n>> do support segwit:  Bitcoin is valuable in part because it has high\n>> security and stability, segwit was carefully designed to support and\n>> amplify that engineering integrity that people can count on now and\n>> into the future.\n>>\n>> I do not feel the the approach proposed in BIP148 really measures up\n>> to the standard set by segwit itself, or the existing best practices\n>> in protocol development in this community.\n>>\n>> The primary flaw in BIP148 is that by forcing the activation of the\n>> existing (non-UASF segwit) nodes it almost guarantees at a minor level\n>> of disruption.\n>>\n>> Segwit was carefully engineered so that older unmodified miners could\n>> continue operating _completely_ without interruption after segwit\n>> activates.\n>>\n>> Older nodes will not include segwit spends, and so their blocks will\n>> not be invalid even if they do not have segwit support. They can\n>> upgrade to it on their own schedule. The only risk non-participating\n>> miners take after segwit activation is that if someone else mines an\n>> invalid block they would extend it, a risk many miners already\n>> frequently take with spy-mining.\n>>\n>> I do not think it is a horrible proposal: it is better engineered than\n>> many things that many altcoins do, but just not up to our normal\n>> standards. I respect the motivations of the authors of BIP 148.  If\n>> your goal is the fastest possible segwit activation then it is very\n>> useful to exploit the >80% of existing nodes that already support the\n>> original version of segwit.\n>>\n>> But the fastest support should not be our goal, as a community-- there\n>> is always some reckless altcoin or centralized system that can support\n>> something faster than we can-- trying to match that would only erode\n>> our distinguishing value in being well engineered and stable.\n>>\n>> \"First do no harm.\" We should use the least disruptive mechanisms\n>> available, and the BIP148 proposal does not meet that test.  To hear\n>> some people-- non-developers on reddit and such-- a few even see the\n>> forced orphaning of 148 as a virtue, that it's punitive for\n>> misbehaving miners. I could not not disagree with that perspective any\n>> more strongly.\n>>\n>> Of course, I do not oppose the general concept of a UASF but\n>> _generally_ a soft-fork (of any kind) does not need to risk disruption\n>> of mining, just as segwit's activation does not.  UASF are the\n>> original kind of soft-fork and were the only kind of fork practiced by\n>> Satoshi. P2SH was activated based on a date, and all prior ones were\n>> based on times or heights.  We introduced miner based activation as\n>> part of a process of making Bitcoin more stable in the common case\n>> where the ecosystem is all in harmony.  It's kind of weird to see UASF\n>> portrayed as something new.\n>>\n>> It's important the users not be at the mercy of any one part of the\n>> ecosystem to the extent that we can avoid it-- be it developers,\n>> exchanges, chat forums, or mining hardware makers.  Ultimately the\n>> rules of Bitcoin work because they're enforced by the users\n>> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it\n>> something people can count on: the rules aren't easy to just change.\n>>\n>> There have been some other UASF proposals that avoid the forced\n>> disruption-- by just defining a new witness bit and allowing\n>> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I\n>> think they are vastly superior. They would be slower to deploy, but I\n>> do not think that is a flaw.\n>>\n>> We should have patience. Bitcoin is a system that should last for all\n>> ages and power mankind for a long time-- ten years from now a couple\n>> years of dispute will seem like nothing. But the reputation we earn\n>> for stability and integrity, for being a system of money people can\n>> count on will mean everything.\n>>\n>> If these discussions come up, they'll come up in the form of reminding\n>> people that Bitcoin isn't easily changed at a whim, even when the\n>> whims are obviously good, and how that protects it from being managed\n>> like all the competing systems of money that the world used to use\n>> were managed. :)\n>>\n>> So have patience, don't take short cuts.  Segwit is a good improvement\n>> and we should respect it by knowing that it's good enough to wait for,\n>> and for however its activated to be done the best way we know how.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n\n\n-- \nSteven Pine\n(510) 517-7075\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/6d4ec9c9/attachment.html>"
            },
            {
                "author": "Karl Johan Alm",
                "date": "2017-05-23T06:30:01",
                "message_text_only": "On Tue, May 23, 2017 at 1:03 PM, Steven Pine via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Correct me if I am wrong, but currently core developers are arguing over\n> whether or not to allow an optional configuration switch which defaults off\n> but signals and enforces BIP148 when used. Who are we protecting users from,\n> themselves? Are you protecting core? from what? I am somewhat genuinely\n> befuddled by those who can't even allow a user config switch to be set.\n\nEssentially, if we make a potentially very harmful option easy to\nenable for users, we are putting them at risk, so yes, this is about\nprotecting users of the base Bitcoin Core implementation. Users have,\nhopefully, come to appreciate this implementation for the peer\nreview-based strict development process, and making a hasty decision\ndue to time constraints (segwit activation expiration) may have\nundesirable consequences. Opinions among the regular contributors are\nsplit on the matter, which to me is an indication we should be\ncautious and consider all aspects before making a decision on the\nmatter."
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-23T12:55:26",
                "message_text_only": "On Tuesday 23 May 2017 6:30:01 AM Karl Johan Alm via bitcoin-dev wrote:\n> Essentially, if we make a potentially very harmful option easy to\n> enable for users, we are putting them at risk, so yes, this is about\n> protecting users of the base Bitcoin Core implementation.\n\nIn this case, NOT enforcing BIP148 puts users at more risk. Since devs are \ndivided in opinion, we should at the very least have an option to let users \ndecide one way or the other.\n\nLuke"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-23T13:20:10",
                "message_text_only": "On Tue, May 23, 2017 at 2:55 PM, Luke Dashjr via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On Tuesday 23 May 2017 6:30:01 AM Karl Johan Alm via bitcoin-dev wrote:\n>> Essentially, if we make a potentially very harmful option easy to\n>> enable for users, we are putting them at risk, so yes, this is about\n>> protecting users of the base Bitcoin Core implementation.\n>\n> In this case, NOT enforcing BIP148 puts users at more risk. Since devs are\n> divided in opinion, we should at the very least have an option to let users\n> decide one way or the other.\n\nWell, it's putting users at more risk only if for those users who\nactively decided to put themselves at risk.\nI also feel bip148 is rushed and that makes it more risky. I don't\nwant to reiterate points other have made but I don't fully agree with\nall of them.\nI prefer the way it is over the way it was (just activating at a given\ndate without forcing mining signaling), but I still think it's rushed\nand unnecessarily risky (unless activating segwit was urgent, which I\nthink it's not, no matter how much I want it to become active as soon\nas possible).\nOn the other hand, I support uasf and bip8 to replace bip9 for future\ndeployments, since bip9 made assumptions that weren't correct (like\nassuming miners would always signal changes that don't harm any user\nand are good for some of them).\nPerhaps bip149 can be modified to activate earlier if the current\nproposal is perceived as unnecessarily cautious.\n\nLuke, I've seen you say in other forums that \"bip148 is less risky\nthan bip149\", but I think that's clearly false.\n\nAs a reminder, one of my complains about bip109 was precisely that it\nwas also rushed in how fast it could activate."
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2017-05-23T09:47:48",
                "message_text_only": "> Who are we protecting users from, themselves? Are you protecting core?\nfrom what? I am somewhat genuinely befuddled by those who can't even allow\na user config switch to be set.\n\nIndeed. It seems silly. If you're activating the switch, you're most likely\nfully aware of what you're doing.\nI also saw some very harsh rhetoric being used against BIP148, which seems\nunjustified as we have no idea yet how it all will play out. We can only\nguess.\n\nHampus\n\n2017-05-23 6:03 GMT+02:00 Steven Pine via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> I'm glad some discussion has been moved back here.\n>\n> Correct me if I am wrong, but currently core developers are arguing over\n> whether or not to allow an optional configuration switch which defaults off\n> but signals and enforces BIP148 when used. Who are we protecting users\n> from, themselves? Are you protecting core? from what? I am somewhat\n> genuinely befuddled by those who can't even allow a user config switch to\n> be set.\n>\n> I guess I find it all incredibly silly, but perhaps I suffer from some\n> basic confusion.\n>\n>\n>\n> On Mon, May 22, 2017 at 3:23 PM, Suhas Daftuar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I also do not support the BIP 148 UASF, and I'd like to add to the points\n>> that Greg has already raised in this thread.\n>>\n>> BIP 148 would introduce a new consensus rule that softforks out\n>> non-segwit signalling blocks in some time period.  I reject this consensus\n>> rule as both arbitrary and needlessly disruptive.  Bitcoin's primary\n>> purpose is to reach consensus on the state of a shared ledger, and even\n>> though I think the Bitcoin network ought to adopt segwit, I don't think\n>> that concern trumps the goal of not splitting the network.\n>>\n>> Many BIP 148 advocates seem to start with the assumption that segwit\n>> already has a lot of support, and suggest that BIP 148 does as well.\n>> However I don't think it's fair or correct to separate the activation\n>> proposal for segwit from the rest of the segwit proposal.  The deployment\n>> parameters for segwit are consensus-critical; assuming that some other\n>> deployment has consensus because it would result in the rest of the segwit\n>> proposal activating is an unjustified leap.\n>>\n>> Even if there were no feasible alternate segwit deployment method\n>> available to us, I would hesitate to recommend that the network adopt a\n>> potentially consensus-splitting approach, even though I firmly believe that\n>> the ideas behind segwit are fundamentally good ones.  But fortunately that\n>> is not the situation we are in; we have substantially less disruptive\n>> methods available to us to activate it, even if the current BIP 9\n>> deployment were to fail -- such as another BIP 9 deployment in the future,\n>> or perhaps a BIP 149 deployment.\n>>\n>> If we do pursue a \"user-activated\" deployment of segwit, I'd recommend\n>> that we do so in a more careful way than BIP 148 or 149 currently suggest,\n>> which as I understand would otherwise make very few changes to the current\n>> implementation.  However, due to the BIP 9 activation assumption, the\n>> Bitcoin Core 0.13.1 - 0.14.0 segwit implementation largely lumps together\n>> the idea that miners would both enforce the rules and mine segwit blocks.\n>> However, we can separate these concerns, as we started to do in the Bitcoin\n>> Core 0.14.1 release, where mining segwit blocks is not required in order to\n>> generally mine or signal for segwit in the software.  And we can go further\n>> still: without too much work, we could make further improvements to\n>> accommodate miners who, for whatever reason, don't want to upgrade their\n>> systems, such as by improving block relay from pre-segwit peers [1], or\n>> optimizing transaction selection for miners who are willing to enforce the\n>> segwit rules but haven't upgraded their systems to mine segwit blocks [2].\n>>\n>> If we would seek to activate a soft-fork with less clear miner signaling\n>> (such as BIP 149), then I think such improvements are warranted to minimize\n>> network disruption.  In general, we should not seek to censor hashpower on\n>> the network unless we have a very important reason for doing so.  While the\n>> issues here are nuanced, if I were to evaluate the BIP 148 soft-fork\n>> proposal on the spectrum of \"censorship attack on Bitcoin\" to \"benign\n>> protocol upgrade\", BIP 148 strikes me as closer to the former than the\n>> latter.  There is simply no need here to orphan these non-signalling blocks\n>> that could otherwise be used to secure the network.\n>>\n>> To go further: I think BIP 148 is ill-conceived even for achieving its\n>> own presumed goals -- the motivation for adding a consensus rule that\n>> applies to the version bits on blocks is surely for the effect such bits\n>> have on older software, such as Bitcoin Core releases 0.13.1 and later.\n>> Yet in trying to bring those implementations along as segwit-enforcing\n>> software, BIP 148 would risk forking from such clients in the short term!\n>> If one really cared about maintaining consensus with older, segwit-enabled\n>> software, it would make far more sense to seek segwit activation in a way\n>> that didn't fork from them (such as BIP 149, or a new BIP 9 deployment\n>> after this one times out).  And if one doesn't care about such consensus,\n>> then it'd be far simpler to just set (e.g.) August 1 as the flag day\n>> activation of segwit, and not play these contortionist games with block\n>> version bits, which carry no useful or intrinsic meaning.  Either of these\n>> two approaches should have the advantage of reduced fork risk, compared\n>> with BIP 148.\n>>\n>> Of course, everyone is free to run the software of their choosing.  I\n>> write this to both generally convey my opposition to a careless proposal,\n>> which I believe represents a way of thinking that is detrimental to\n>> Bitcoin's long run success, and specifically explain why I oppose inclusion\n>> of this proposal in the Bitcoin Core implementation [3].  The Bitcoin Core\n>> project hasn't been, and shouldn't be, careless in deploying consensus\n>> changes.  Instead, I think the Bitcoin Core project ought to stand up for\n>> the best practices that our community has learned about how to deploy such\n>> changes (specifically for minimizing chain-split risk when deploying a soft\n>> fork!), and I think we should all avoid adoption or encouragement of\n>> practices that would depart from the high standards we are capable of\n>> achieving.\n>>\n>>\n>>  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-\n>> dev/2017-March/013811.html\n>>  [2] https://github.com/bitcoin/bitcoin/pull/9955\n>>  [3] https://github.com/bitcoin/bitcoin/pull/10428#issuecomment-303098925\n>>\n>>\n>> --Suhas Daftuar\n>>\n>>\n>> On Fri, Apr 14, 2017 at 3:56 AM, Gregory Maxwell via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> I do not support the BIP148 UASF for some of the same reasons that I\n>>> do support segwit:  Bitcoin is valuable in part because it has high\n>>> security and stability, segwit was carefully designed to support and\n>>> amplify that engineering integrity that people can count on now and\n>>> into the future.\n>>>\n>>> I do not feel the the approach proposed in BIP148 really measures up\n>>> to the standard set by segwit itself, or the existing best practices\n>>> in protocol development in this community.\n>>>\n>>> The primary flaw in BIP148 is that by forcing the activation of the\n>>> existing (non-UASF segwit) nodes it almost guarantees at a minor level\n>>> of disruption.\n>>>\n>>> Segwit was carefully engineered so that older unmodified miners could\n>>> continue operating _completely_ without interruption after segwit\n>>> activates.\n>>>\n>>> Older nodes will not include segwit spends, and so their blocks will\n>>> not be invalid even if they do not have segwit support. They can\n>>> upgrade to it on their own schedule. The only risk non-participating\n>>> miners take after segwit activation is that if someone else mines an\n>>> invalid block they would extend it, a risk many miners already\n>>> frequently take with spy-mining.\n>>>\n>>> I do not think it is a horrible proposal: it is better engineered than\n>>> many things that many altcoins do, but just not up to our normal\n>>> standards. I respect the motivations of the authors of BIP 148.  If\n>>> your goal is the fastest possible segwit activation then it is very\n>>> useful to exploit the >80% of existing nodes that already support the\n>>> original version of segwit.\n>>>\n>>> But the fastest support should not be our goal, as a community-- there\n>>> is always some reckless altcoin or centralized system that can support\n>>> something faster than we can-- trying to match that would only erode\n>>> our distinguishing value in being well engineered and stable.\n>>>\n>>> \"First do no harm.\" We should use the least disruptive mechanisms\n>>> available, and the BIP148 proposal does not meet that test.  To hear\n>>> some people-- non-developers on reddit and such-- a few even see the\n>>> forced orphaning of 148 as a virtue, that it's punitive for\n>>> misbehaving miners. I could not not disagree with that perspective any\n>>> more strongly.\n>>>\n>>> Of course, I do not oppose the general concept of a UASF but\n>>> _generally_ a soft-fork (of any kind) does not need to risk disruption\n>>> of mining, just as segwit's activation does not.  UASF are the\n>>> original kind of soft-fork and were the only kind of fork practiced by\n>>> Satoshi. P2SH was activated based on a date, and all prior ones were\n>>> based on times or heights.  We introduced miner based activation as\n>>> part of a process of making Bitcoin more stable in the common case\n>>> where the ecosystem is all in harmony.  It's kind of weird to see UASF\n>>> portrayed as something new.\n>>>\n>>> It's important the users not be at the mercy of any one part of the\n>>> ecosystem to the extent that we can avoid it-- be it developers,\n>>> exchanges, chat forums, or mining hardware makers.  Ultimately the\n>>> rules of Bitcoin work because they're enforced by the users\n>>> collectively-- that is what makes Bitcoin Bitcoin, it's what makes it\n>>> something people can count on: the rules aren't easy to just change.\n>>>\n>>> There have been some other UASF proposals that avoid the forced\n>>> disruption-- by just defining a new witness bit and allowing\n>>> non-upgraded-to-uasf miners and nodes to continue as non-upgraded, I\n>>> think they are vastly superior. They would be slower to deploy, but I\n>>> do not think that is a flaw.\n>>>\n>>> We should have patience. Bitcoin is a system that should last for all\n>>> ages and power mankind for a long time-- ten years from now a couple\n>>> years of dispute will seem like nothing. But the reputation we earn\n>>> for stability and integrity, for being a system of money people can\n>>> count on will mean everything.\n>>>\n>>> If these discussions come up, they'll come up in the form of reminding\n>>> people that Bitcoin isn't easily changed at a whim, even when the\n>>> whims are obviously good, and how that protects it from being managed\n>>> like all the competing systems of money that the world used to use\n>>> were managed. :)\n>>>\n>>> So have patience, don't take short cuts.  Segwit is a good improvement\n>>> and we should respect it by knowing that it's good enough to wait for,\n>>> and for however its activated to be done the best way we know how.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n>\n> --\n> Steven Pine\n> (510) 517-7075\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/0a7c89a0/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "I do not support the BIP 148 UASF",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Steven Pine",
                "Suhas Daftuar",
                "Hampus Sj\u00f6berg",
                "Jorge Tim\u00f3n",
                "Erik Aronesty",
                "Luke Dashjr",
                "Karl Johan Alm"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 38654
        }
    },
    {
        "title": "[bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-05-03T14:03:58",
                "message_text_only": "> But as you've observed, the failure probabilities are rather high,\n> especially if an active attacker targets nodes carrying less commonly\n> available blocks.\n\nWouldn't the solution be for nodes to use whatever mechanism an attacker\nuses to determine less commonly available blocks and choose to store a\nrandom percentage of them as well as their deterministic random set?\n\nIE X blocks end of chain (spv bootstrap), Y% deterministic random set,  Z%\npatch/fill set to deter attacks\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/f9489c19/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2017-05-03T19:10:47",
                "message_text_only": "Den 3 maj 2017 16:05 skrev \"Erik Aronesty via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> But as you've observed, the failure probabilities are rather high,\n> especially if an active attacker targets nodes carrying less commonly\n> available blocks.\n\nWouldn't the solution be for nodes to use whatever mechanism an attacker\nuses to determine less commonly available blocks and choose to store a\nrandom percentage of them as well as their deterministic random set?\n\nIE X blocks end of chain (spv bootstrap), Y% deterministic random set,  Z%\npatch/fill set to deter attacks\n\n\nThen he uses Sybil attacks to obscure what's actually rare and not. Even\nproof of storage isn't enough, you need proof of INDEPENDENT storage, which\nis essentially impossible, as well as a way of determining which nodes are\nrun by the same people (all the AWS nodes should essentially count as one).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/c4844326/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-05-03T22:45:40",
                "message_text_only": "Le 03/05/2017 \u00e0 21:10, Natanael via bitcoin-dev a \u00e9crit :\n>\n> Den 3 maj 2017 16:05 skrev \"Erik Aronesty via bitcoin-dev\"\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>>:\n>\n>     > But as you've observed, the failure probabilities are rather high,\n>     > especially if an active attacker targets nodes carrying less\n>     commonly\n>     > available blocks. \n>\n>     Wouldn't the solution be for nodes to use whatever mechanism an\n>     attacker uses to determine less commonly available blocks and\n>     choose to store a random percentage of them as well as their\n>     deterministic random set? \n>\n>     IE X blocks end of chain (spv bootstrap), Y% deterministic random\n>     set,  Z% patch/fill set to deter attacks\n>\n>\n> Then he uses Sybil attacks to obscure what's actually rare and not.\n\n> Even proof of storage isn't enough,you need proof of INDEPENDENT storage\n\nYes\n\n> , which is essentially impossible\n\nNo, the bittorrent network is a good example\n\n> , as well as a way of determining which nodes are run by the same\n> people (all the AWS nodes should essentially count as one).\n\nNo, this one is impossible and you don't care in fact, as long as the\nsystem forbids the nodes to position themselves where they like and can\ncheck that the nodes are behaving correctly, same people's nodes/IPs\nwould then just do the job\n\nAnd if you add to this a rewarding system that is not necessarily\nprofitable then you eliminate the incentive for sybil attacking the\nnetwork (like the \"tip\" proposal today) while motivating those that have\nthe resources to run full nodes, then increasing independence\n\n\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/134e4c1e/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Small Nodes: A Better Alternative to Pruned Nodes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Natanael",
                "Erik Aronesty",
                "Aymeric Vitte"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4269
        }
    },
    {
        "title": "[bitcoin-dev] Transaction signalling",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-05-03T19:41:07",
                "message_text_only": "BIP XXXX : User activated features (ROUGH OVERVIEW)\n\nA proposed change to a usage of the 'OP_RETURN' script opcode in Bitcoin\ntransactions, allowing multiple changes (features) to be deployed in\nparallel. It relies on interpreting the output field as a bit vector, where\neach bit can be used to track an independent change. Like BIP9, once a\nconsensus change succeeds or times out, there is a \"fallow\" pause after\nwhich the bit can be reused for later changes.\n\n==Motivation==\n\nBIP 9 introduced a mechanism for doing soft-forking changes, relying on\nmeasuring miner support indicated by version bits in block headers. As it\nrelies on miner support, any change which may conflict with miners but is\nacceptable to users may be difficult to deploy.   The alternative, a\nflag-day deployment can cause issues for users of a feature that has failed\nto achieve adequate miner support.\n\nBIP XXXX, if used for deployment, can be used in conjunction with BIP 9, in\norder to more safely deploy soft-forking changes that do not require a\nsupermajority of miners, but do require a large percentage of active\nusers.\n\nAlternatively, BIP XXXX signalling can be used to gauge user support for\n\"features\" - independent of its use as a direct deployment mechanism.   In\nthis document a \"feature\" can be considered synonymous with \"soft fork\",\nbut since this mechanism is \"user activated\", it is not necessarily\nrestricted to soft-forks.\n\n==Specification==\n\nEach \"feature\" is specified by the sames set of per-chain parameters as in\nBIP9, with the same usage and meaning (name, bit, starttime and timeout).\n\n===Bit flags===\n\nIf the outputs contain a zero valued OP_RETURN, and the length of the key\nis 2 bytes, and if the first byte (prefix) of that OP_RETURN's key\nparameter is 0x012, then the remaining byte is to be interpreted as an\n8-bit little-endian integer, and bits are selected within this integer as\nvalues (1 << N) where N is the bit number.  This allows up to 8 features to\nbe in the STARTED state at a time.\n\n===Array determination===\n\nIn order for this to successfully be used for deployment, a lightweight\nUTXO must be maintained in memory.   For each bit in STARTED state, a\ncorresponding bit is set in a map entry for each input address.   Each\ninput address is hashed to a 24 bit value using SHA3-256(input)[0:24].  An\narray with 16777216 2-byte entries (~32MB RAM) is used to record the\ncurrent activation state.   The first byte contains the bit flags most\nrecently associated with an entry.\n\nThe second byte contains the log base 2 of the number of \"1/100th\" bitcoins\nmost recently associated with this entry.   This is computed by taking the\nvalue, multiplying by 100, converting to an unsigned 32 bit integer, and\nusing the log2_32 function below (.... log2_32 func defined below ....).\n\nThis array is initialized to zero.   The array must be stored and\nmaintained for each block.  When a block is in the STARTED state for any\nbit, the array is updated for each transaction in the block according to\nthe rules above: a[i][0]=bits, a[i][1]=log2_32(....)\n\n===State transitions===\n\nState transitions work the same as BIP9, however, the determination of the\nLOCKED_IN tally is as follows:\n\nFor each bit in STARTED state, using the array above, the values are\ntotaled (unsigned int)(2 << a[i][1]) for each entry where this bit is set\nin a[i][0].  In addition the total of all the entries in a, irrespective of\nbit, are computed.   This can be done in a single pass, resulting in a\nvector of up to 8 32 bit entries containing the \"feature totals\" for the\narray, and one extra 32 bit entry for the sum total of observations since\nthe start time.\n\nThe percentage of observations is computed for each bit.   Up to 8 features\ncan be computed at a time, with reuse similar to BIP9.\n\nIf 2016 sequential blocks have a value of 95% or greater, a feature is\n\"LOCKED_IN\", (75% on testnet)\nbit.\n\nSimilar to BIP9, a block's state never depends on its own transactions set;\nonly on that of its ancestors.  ACTIVE and FAILED are terminal states, etc.\n\n\nOn Thu, Apr 20, 2017 at 12:14 PM, Erik Aronesty <erik at q32.com> wrote:\n\n> I agree, addresses create vulnerability, an OP_RETURN signal seems the\n> safest way to go for UA signalling.   I can model a BIP after BIP9, with\n> some discussion of how to properly collect statistics, and the ability for\n> nodes to activate features based on an \"economic majority\" defined in this\n> way.\n>\n> On Tue, Apr 18, 2017 at 6:29 PM, Tim Ruffing via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I don't have an opinion on whether signaling is a good idea in general.\n>>\n>> However I don't think that using addresses is a good idea, because this\n>> has privacy implications. For example, it makes it much easier to link\n>> the addresses, e.g., inputs with change address. (The change address\n>> votes for the same proposal as the input address.)\n>>\n>> Tim\n>>\n>> On Tue, 2017-04-18 at 18:07 +0000, Christian Decker via bitcoin-dev\n>> wrote:\n>> > I really like the idea of extending signalling capabilities to the\n>> > end-users. It gives stakeholders a voice in the decisions we take in\n>> > the network, and are a clear signal to all other involved parties. It\n>> > reminds me of a student thesis I supervised some time ago [1], in\n>> > which we explored various signalling ideas.\n>> >\n>> > I think we have a number of fields that may be used for such a\n>> > signalling, e.g., OP_RETURN, locktime, and output scripts. I think\n>> > OP_RETURN is probably not the field you'd want to use though since it\n>> > adds data that needs to be transferred, stored for bootstrap, and\n>> > outputs in the UTXO would need to be tagged with additional\n>> > information. Locktime has the advantage of being mostly a freeform\n>> > field for values in the past, but it clashes with other uses that may\n>> > rely on it. Furthermore, it is the transaction creator that specifies\n>> > the locktime, hence the signal trails one hop behind the current\n>> > owner, i.e., the actual stakeholder.\n>> >\n>> > I think probably the best field to signal would be the output\n>> > script. It is specified by the recipient of the funds, i.e., the\n>> > current owner, and is already stored in the UTXO, so a single pass\n>> > can\n>> > tally up the votes. We could for example use the last 4 bits of the\n>> > pubkey/pubkeyhash to opt in (3 leading 0 bits) and the vote (0/1\n>> > depending on the stakeholders desired signal). We'd need to define\n>> > similar semantics for other script types, but getting the standard\n>> > scripts to be recognized should be simple.\n>> >\n>> > In the spirit of full disclosure I'd like to also mention some of the\n>> > downsides of voting this way. Unlike the OP_RETURN proposal, users\n>> > that do not intend to signal will also be included in the tally. I'd\n>> > expect the signals of these users to be random with a 50% chance of\n>> > either outcome, so they should not influence the final result, but\n>> > may\n>> > muddy the water depending on what part of the population is\n>> > signalling. The opt-in should make sure that the majority of votes\n>> > are\n>> > actually voluntary votes, and not just users that randomly select a\n>> > pubkey/pubkeyhash, and can be adjusted as desired, though higher\n>> > values require more grinding on behalf of the users.\n>> >\n>> > The grinding may also exacerbate some problems we already have with\n>> > the HD Wallet lookahead, since we now skip a number of addresses, so\n>> > we should not require too many opt-in bits.\n>> >\n>> > So there are some problems we'd need to tackle, but I'm really\n>> > excited\n>> > about this, as it could provide data to make informed decisions, and\n>> > should put an end to the endless speculation about the will of the\n>> > economic majority.\n>> >\n>> > Cheers,\n>> > Christian\n>> >\n>> > [1] http://pub.tik.ee.ethz.ch/students/2015-HS/SA-2015-30.pdf\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/3d21c76d/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Transaction signalling",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8445
        }
    },
    {
        "title": "[bitcoin-dev] Full node \"tip\" function",
        "thread_messages": [
            {
                "author": "Erik Aronesty",
                "date": "2017-05-03T21:08:35",
                "message_text_only": "IDEA:\n\n- Full nodes advertise a bitcoin address.   Users that need to download the\nblock chain from that node can be encouraged to send a tip to the peers\nthat served them (by % served).   Recommended tip of 10mbit should be fine.\n\n- A full nodes can *require* a tip to download the blockchain.  If they do,\nusers that don't specify a tip cannot use them.\n\nCONS:\n\nFor some people, this may represent a barrier to hosting their own full\nnode.   After all, if you have to pay $15 just to get a copy of the\nblockchain, that just adds to the already expensive prospect of hosting a\nfull node.\n\nPROS:\n\nAs long as you manage to stay online, you should get your money back and\nmore.   This is the an incentive for quality, long term hosting.\n\nIn the long term, this should cause stable nodes to stick around longer.\nIt also discourages \"installation spam\" attacks on the network.\n\nFees for other node operations can be considered if this is successful.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/64e38729/attachment.html>"
            },
            {
                "author": "Ben Thompson",
                "date": "2017-05-03T21:43:16",
                "message_text_only": "I feel like this would be pointless as the vast majority of users would\nlikely download the blockchain from a node that was not enforcing a tip\nrequirement as it would seem like unnecessary cost as in protocol\u200bs such as\nBitTorrent there is no such tips in sharing files and the blockchain\ndistribution is in eccense the same thing. However perhaps I am\nunderestimating the generosity of node operators but I feel that adding a\ncost to the blockchain (assuming that all users add a tip requirement)\nwould lead to centralisation.\n\nOn Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> IDEA:\n>\n> - Full nodes advertise a bitcoin address.   Users that need to download\n> the block chain from that node can be encouraged to send a tip to the peers\n> that served them (by % served).   Recommended tip of 10mbit should be fine.\n>\n> - A full nodes can *require* a tip to download the blockchain.  If they\n> do, users that don't specify a tip cannot use them.\n>\n> CONS:\n>\n> For some people, this may represent a barrier to hosting their own full\n> node.   After all, if you have to pay $15 just to get a copy of the\n> blockchain, that just adds to the already expensive prospect of hosting a\n> full node.\n>\n> PROS:\n>\n> As long as you manage to stay online, you should get your money back and\n> more.   This is the an incentive for quality, long term hosting.\n>\n> In the long term, this should cause stable nodes to stick around longer.\n> It also discourages \"installation spam\" attacks on the network.\n>\n> Fees for other node operations can be considered if this is successful.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170503/ac45bd6c/attachment.html>"
            },
            {
                "author": "Tomas",
                "date": "2017-05-04T10:38:29",
                "message_text_only": "The ones that *could* pay non-mining full nodes are miners/pools, by\noutsourcing transaction selection using a different PoW.  By doing so\nthey could buy proof-of-uncensored-selection and proof-of-goodwill for a\nsmall fee.\nWe would allow full nodes to generate and broadcast a template\nblock which:\n* Does not contain a valid header yet\n* Contains the transaction selection\n* Contains a  coinbase output with a predetermined part of the block\n  reward (say 0.5%) to themselves* Contains a nonce for PoW of a predetermined currently ASIC resistant\n  hash function behind a OP_RETURN.\nThe template with the highest PoW since the last block would be leading.\nA miner/pool can then choose to use this instead of their own, adding\nthe rest of the reward and the SHA nonce themselves. That way they would\nset up a competition among full nodes.\nThis would of course be voluntary but provable, so maybe in a pool's\ninterest to do this via naming and shaming.\nTomas\nbitcrust\n\nOn Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:\n> I feel like this would be pointless as the vast majority of users\n> would likely download the blockchain from a node that was not\n> enforcing a tip requirement as it would seem like unnecessary cost as\n> in protocols such as BitTorrent there is no such tips in sharing files\n> and the blockchain distribution is in eccense the same thing. However\n> perhaps I am underestimating the generosity of node operators but I\n> feel that adding a cost to the blockchain (assuming that all users add\n> a tip requirement) would lead to centralisation.> \n> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <bitcoin-\n> dev at lists.linuxfoundation.org> wrote:>> IDEA:\n>> - Full nodes advertise a bitcoin address.   Users that need to\n>>   download the block chain from that node can be encouraged to send a\n>>   tip to the peers that served them (by % served).   Recommended tip\n>>   of 10mbit should be fine.>> \n>> - A full nodes can *require* a tip to download the blockchain.  If\n>>   they do, users that don't specify a tip cannot use them.>> \n>> CONS:\n>> \n>> For some people, this may represent a barrier to hosting their own\n>> full node.   After all, if you have to pay $15 just to get a copy of\n>> the blockchain, that just adds to the already expensive prospect of\n>> hosting a full node.>> PROS: \n>> \n>> As long as you manage to stay online, you should get your money back\n>> and more.   This is the an incentive for quality, long term hosting.>> In the long term, this should cause stable nodes to stick around\n>> longer.   It also discourages \"installation spam\" attacks on the\n>> network.>> Fees for other node operations can be considered if this is\n>> successful.>> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/c4a0d32c/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-05-04T13:37:43",
                "message_text_only": "Strange idea, incentiving people to run full nodes should certainly not\ndepend on miners, should certainly not involve another wasteful pow and\nshould certainly not encourage any collusion between participants like\nminers are doing (ie full nodes pools for example or miners creating\nfull nodes pools)\n\n\nLe 04/05/2017 \u00e0 12:38, Tomas via bitcoin-dev a \u00e9crit :\n> The ones that *could* pay non-mining full nodes are miners/pools, by\n> outsourcing transaction selection using a different PoW.  By doing so\n> they could buy proof-of-uncensored-selection and proof-of-goodwill for\n> a small fee.\n>\n> We would allow full nodes to generate and broadcast a template block\n> which:\n>\n> * Does not contain a valid header yet\n> * Contains the transaction selection\n> * Contains a coinbase output with a predetermined part of the block\n> reward (say 0.5%) to themselves\n> * Contains a nonce for PoW of a predetermined currently ASIC resistant\n> hash function behind a OP_RETURN.\n>\n> The template with the highest PoW since the last block would be\n> leading. A miner/pool can then choose to use this instead of their\n> own, adding the rest of the reward and the SHA nonce themselves. That\n> way they would set up a competition among full nodes.\n>\n> This would of course be voluntary but provable, so maybe in a pool's\n> interest to do this via naming and shaming.\n>\n> Tomas\n> bitcrust\n>\n> On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:\n>> I feel like this would be pointless as the vast majority of users\n>> would likely download the blockchain from a node that was not\n>> enforcing a tip requirement as it would seem like unnecessary cost as\n>> in protocols such as BitTorrent there is no such tips in sharing\n>> files and the blockchain distribution is in eccense the same thing.\n>> However perhaps I am underestimating the generosity of node operators\n>> but I feel that adding a cost to the blockchain (assuming that all\n>> users add a tip requirement) would lead to centralisation.\n>>\n>> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev,\n>> <bitcoin-dev at lists.linuxfoundation.org\n>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>\n>>     IDEA:\n>>     - Full nodes advertise a bitcoin address.   Users that need to\n>>     download the block chain from that node can be encouraged to send\n>>     a tip to the peers that served them (by % served).   Recommended\n>>     tip of 10mbit should be fine.\n>>\n>>     - A full nodes can *require* a tip to download the blockchain. \n>>     If they do, users that don't specify a tip cannot use them.\n>>\n>>     CONS:\n>>\n>>     For some people, this may represent a barrier to hosting their\n>>     own full node.   After all, if you have to pay $15 just to get a\n>>     copy of the blockchain, that just adds to the already expensive\n>>     prospect of hosting a full node.  \n>>     PROS:\n>>\n>>     As long as you manage to stay online, you should get your money\n>>     back and more.   This is the an incentive for quality, long term\n>>     hosting.\n>>     In the long term, this should cause stable nodes to stick around\n>>     longer.   It also discourages \"installation spam\" attacks on the\n>>     network.\n>>     Fees for other node operations can be considered if this is\n>>     successful.\n>>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/37a1e95c/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-04T13:47:45",
                "message_text_only": "- Full nodes already perform many valuable services, and simply allowing\npeople to pay for better service is something operators can do now - even\nwithout it being baked into bitcoind.   Paying for access to a higher-speed\nrelay network, for example, is something that many operators would do.\n\n- Baking in the ability to add service fees could make more people *want*\nto run more high quality, highly available full nodes... which is really\none of the most important things developers can be doing.\n\n\nOn Thu, May 4, 2017 at 9:37 AM, Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Strange idea, incentiving people to run full nodes should certainly not\n> depend on miners, should certainly not involve another wasteful pow and\n> should certainly not encourage any collusion between participants like\n> miners are doing (ie full nodes pools for example or miners creating full\n> nodes pools)\n>\n> Le 04/05/2017 \u00e0 12:38, Tomas via bitcoin-dev a \u00e9crit :\n>\n> The ones that *could* pay non-mining full nodes are miners/pools, by\n> outsourcing transaction selection using a different PoW.  By doing so they\n> could buy proof-of-uncensored-selection and proof-of-goodwill for a small\n> fee.\n>\n> We would allow full nodes to generate and broadcast a template block which:\n>\n> * Does not contain a valid header yet\n> * Contains the transaction selection\n> * Contains a coinbase output with a predetermined part of the block reward\n> (say 0.5%) to themselves\n> * Contains a nonce for PoW of a predetermined currently ASIC resistant\n> hash function behind a OP_RETURN.\n>\n> The template with the highest PoW since the last block would be leading. A\n> miner/pool can then choose to use this instead of their own, adding the\n> rest of the reward and the SHA nonce themselves. That way they would set up\n> a competition among full nodes.\n>\n> This would of course be voluntary but provable, so maybe in a pool's\n> interest to do this via naming and shaming.\n>\n> Tomas\n> bitcrust\n>\n> On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:\n>\n> I feel like this would be pointless as the vast majority of users would\n> likely download the blockchain from a node that was not enforcing a tip\n> requirement as it would seem like unnecessary cost as in protocols such as\n> BitTorrent there is no such tips in sharing files and the blockchain\n> distribution is in eccense the same thing. However perhaps I am\n> underestimating the generosity of node operators but I feel that adding a\n> cost to the blockchain (assuming that all users add a tip requirement)\n> would lead to centralisation.\n>\n> On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev, <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> IDEA:\n> - Full nodes advertise a bitcoin address.   Users that need to download\n> the block chain from that node can be encouraged to send a tip to the peers\n> that served them (by % served).   Recommended tip of 10mbit should be fine.\n>\n> - A full nodes can *require* a tip to download the blockchain.  If they\n> do, users that don't specify a tip cannot use them.\n>\n> CONS:\n>\n> For some people, this may represent a barrier to hosting their own full\n> node.   After all, if you have to pay $15 just to get a copy of the\n> blockchain, that just adds to the already expensive prospect of hosting a\n> full node.\n> PROS:\n>\n> As long as you manage to stay online, you should get your money back and\n> more.   This is the an incentive for quality, long term hosting.\n> In the long term, this should cause stable nodes to stick around longer.\n> It also discourages \"installation spam\" attacks on the network.\n> Fees for other node operations can be considered if this is successful.\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> --\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/3858fae9/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-03T21:53:07",
                "message_text_only": "On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> CONS:\n\nThe primary result would be paying people to sybil attack the network.\nIt's far cheaper to run one node behind thousands of IPs than it is to\nrun many nodes.\n\nSuggestions like this have come up many times before."
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-03T22:03:43",
                "message_text_only": "If we ever have a problem getting blocks, we could consider adding something to pay to receive historical blocks but luckily that isn't a problem we have today - the available connection slots and bandwidth on the network today appears to be more than sufficient to saturate nearly any fully-validating node.\n\nOn May 3, 2017 5:53:07 PM EDT, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev\n><bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> CONS:\n>\n>The primary result would be paying people to sybil attack the network.\n>It's far cheaper to run one node behind thousands of IPs than it is to\n>run many nodes.\n>\n>Suggestions like this have come up many times before.\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-04T13:15:02",
                "message_text_only": "> Greg\n> The primary result would be paying people to sybil attack the network.\n\nI cannot imagine the benefit to replicating an ip address in this case,\nexcept maybe you think that you would be more likely to be selected as a\npeer?   But there would be no actual advantage since download peers are\nselected based on throughput and actual blocks served.\n\nAlso, since this makes the network far more resistant to DDOS attacks, it\nhas added benefits.\n\n> Luke:\n> paying for services is in general a great idea, but one that Bitcoin\n> can much better serve once Lightning is in production.\n\nI agree, if lightning networks were baked in, then the tips could be as\ngranular as \"per block downloaded\", or even (outlandish seeming now, but\nmaybe not in a future where there is a \"public rpc api\") \"per rpc call\".\nMiners and business users would certainly pay for high quality services.\nSpinning up new nodes without a tip and relying on the \"free network\" would\nprobably take more time, for example.\n\nI suspect that if income were even a small possibility the number of full\nnodes would vastly increase.\n\nSybil attacks seem irrelevant as long as reasonable QOS metrics are stored\nper peer.\n\n\nOn Wed, May 3, 2017 at 5:53 PM, Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Wed, May 3, 2017 at 9:08 PM, Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > CONS:\n>\n> The primary result would be paying people to sybil attack the network.\n> It's far cheaper to run one node behind thousands of IPs than it is to\n> run many nodes.\n>\n> Suggestions like this have come up many times before.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/fa4898df/attachment.html>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-04T14:57:59",
                "message_text_only": "I agree with you here, Erik. Greg's standard answer doesn\u2019t apply to your \nsuggestion.\nI think he was a bit too trigger happy because we have seen a lot of similar \nsuggestions that have the Sybill issue he mentioned.\n\n\nOn Thursday, 4 May 2017 15:15:02 CEST Erik Aronesty via bitcoin-dev wrote:\n> > Greg\n> > The primary result would be paying people to sybil attack the network.\n> \n> I cannot imagine the benefit to replicating an ip address in this case,\n> except maybe you think that you would be more likely to be selected as a\n> peer?   But there would be no actual advantage since download peers are\n> selected based on throughput and actual blocks served.\n\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-03T23:21:13",
                "message_text_only": "I think paying for services is in general a great idea, but one that Bitcoin \ncan much better serve once Lightning is in production. Not only does it enable \ncost-effective micro-transactions, it also should allow nodes to initiate \npayments before they have a synced node (which is something impractical at \npresent).\n\nOn Wednesday 03 May 2017 9:08:35 PM Erik Aronesty via bitcoin-dev wrote:\n> IDEA:\n> \n> - Full nodes advertise a bitcoin address.   Users that need to download the\n> block chain from that node can be encouraged to send a tip to the peers\n> that served them (by % served).   Recommended tip of 10mbit should be fine.\n> \n> - A full nodes can *require* a tip to download the blockchain.  If they do,\n> users that don't specify a tip cannot use them.\n> \n> CONS:\n> \n> For some people, this may represent a barrier to hosting their own full\n> node.   After all, if you have to pay $15 just to get a copy of the\n> blockchain, that just adds to the already expensive prospect of hosting a\n> full node.\n> \n> PROS:\n> \n> As long as you manage to stay online, you should get your money back and\n> more.   This is the an incentive for quality, long term hosting.\n> \n> In the long term, this should cause stable nodes to stick around longer.\n> It also discourages \"installation spam\" attacks on the network.\n> \n> Fees for other node operations can be considered if this is successful."
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-05-04T14:31:11",
                "message_text_only": "Yes, as a whole, but I am sorry, your \"tip\" proposal is very very very\nbad as it is, think a little bit more about your latest answer and you\nwill understand why\n\nI am a bit perplexed sometimes about what is proposed on this list\n\nAdding services paid by the miners is not a bad idea, like some\nproposals that were posted here proposing some system to validate/format\nthe blocks for the miners\n\nBut, first, the highest priority is to scale the full nodes and this\ncannot depend on miners, then once this is done we can imagine other\nservices on top of it paid by the miners or others (+lightning & co)\n\nI have already explained many times my thoughts on the subject, I don't\npretend that they represent the perfect solution but at least it's\ndifferent from what we can read , so I think that the core dev team\nshould setup a task force/group to solve this quickly now, the\naccumulation of strange proposals/workarounds here does not help\n\nBecause it's a real question for everybody in the current context\nwhether we can trust bitcoin or not, unfortunately the answer currently\ntends toward the later, or please explain me why this statement could be\nwrong\n\n\nLe 04/05/2017 \u00e0 15:47, Erik Aronesty a \u00e9crit :\n>  - Full nodes already perform many valuable services, and simply\n> allowing people to pay for better service is something operators can\n> do now - even without it being baked into bitcoind.   Paying for\n> access to a higher-speed relay network, for example, is something that\n> many operators would do.\n>\n> - Baking in the ability to add service fees could make more people\n> *want* to run more high quality, highly available full nodes... which\n> is really one of the most important things developers can be doing.\n>\n>\n> On Thu, May 4, 2017 at 9:37 AM, Aymeric Vitte via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Strange idea, incentiving people to run full nodes should\n>     certainly not depend on miners, should certainly not involve\n>     another wasteful pow and should certainly not encourage any\n>     collusion between participants like miners are doing (ie full\n>     nodes pools for example or miners creating full nodes pools)\n>\n>\n>     Le 04/05/2017 \u00e0 12:38, Tomas via bitcoin-dev a \u00e9crit :\n>>     The ones that *could* pay non-mining full nodes are miners/pools,\n>>     by outsourcing transaction selection using a different PoW.  By\n>>     doing so they could buy proof-of-uncensored-selection and\n>>     proof-of-goodwill for a small fee.\n>>\n>>     We would allow full nodes to generate and broadcast a template\n>>     block which:\n>>\n>>     * Does not contain a valid header yet\n>>     * Contains the transaction selection\n>>     * Contains a coinbase output with a predetermined part of the\n>>     block reward (say 0.5%) to themselves\n>>     * Contains a nonce for PoW of a predetermined currently ASIC\n>>     resistant hash function behind a OP_RETURN.\n>>\n>>     The template with the highest PoW since the last block would be\n>>     leading. A miner/pool can then choose to use this instead of\n>>     their own, adding the rest of the reward and the SHA nonce\n>>     themselves. That way they would set up a competition among full\n>>     nodes.\n>>\n>>     This would of course be voluntary but provable, so maybe in a\n>>     pool's interest to do this via naming and shaming.\n>>\n>>     Tomas\n>>     bitcrust\n>>\n>>     On Wed, May 3, 2017, at 23:43, Ben Thompson via bitcoin-dev wrote:\n>>>     I feel like this would be pointless as the vast majority of\n>>>     users would likely download the blockchain from a node that was\n>>>     not enforcing a tip requirement as it would seem like\n>>>     unnecessary cost as in protocols such as BitTorrent there is no\n>>>     such tips in sharing files and the blockchain distribution is in\n>>>     eccense the same thing. However perhaps I am underestimating the\n>>>     generosity of node operators but I feel that adding a cost to\n>>>     the blockchain (assuming that all users add a tip requirement)\n>>>     would lead to centralisation.\n>>>\n>>>     On Wed, 3 May 2017, 22:21 Erik Aronesty via bitcoin-dev,\n>>>     <bitcoin-dev at lists.linuxfoundation.org\n>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>>\n>>>         IDEA:\n>>>         - Full nodes advertise a bitcoin address.   Users that need\n>>>         to download the block chain from that node can be encouraged\n>>>         to send a tip to the peers that served them (by % served).  \n>>>         Recommended tip of 10mbit should be fine.\n>>>\n>>>         - A full nodes can *require* a tip to download the\n>>>         blockchain.  If they do, users that don't specify a tip\n>>>         cannot use them.\n>>>\n>>>         CONS:\n>>>\n>>>         For some people, this may represent a barrier to hosting\n>>>         their own full node.   After all, if you have to pay $15\n>>>         just to get a copy of the blockchain, that just adds to the\n>>>         already expensive prospect of hosting a full node.  \n>>>         PROS:\n>>>\n>>>         As long as you manage to stay online, you should get your\n>>>         money back and more.   This is the an incentive for quality,\n>>>         long term hosting.\n>>>         In the long term, this should cause stable nodes to stick\n>>>         around longer.   It also discourages \"installation spam\"\n>>>         attacks on the network.\n>>>         Fees for other node operations can be considered if this is\n>>>         successful.\n>>>\n>>\n>>\n>>\n>>     _______________________________________________\n>>     bitcoin-dev mailing list\n>>     bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>\n>     -- \n>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n>     <https://github.com/Ayms/zcash-wallets>\n>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n>     <https://github.com/Ayms/bitcoin-wallets>\n>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n>     Check the 10 M passwords list: http://peersm.com/findmyass\n>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n>     Peersm : http://www.peersm.com\n>     torrent-live: https://github.com/Ayms/torrent-live\n>     <https://github.com/Ayms/torrent-live>\n>     node-Tor : https://www.github.com/Ayms/node-Tor\n>     <https://www.github.com/Ayms/node-Tor>\n>     GitHub : https://www.github.com/Ayms\n>\n>     _______________________________________________ bitcoin-dev\n>     mailing list bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev> \n>\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/b35d9902/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-04T19:28:10",
                "message_text_only": ">\n> This is actually LN\u2019s killer use case - not buying coffees ;)\n>\n\nYes, micro-payments for online network services is precisely what LN is\nbest at.\n\nEstablishing a channel with each peer is too expensive.   But using LN to\nmicro-pay for high-quality peer services seems like it would aggregate very\nwell.\n\nIt would be great if this protocol was in-place and ready to go in or\naround the same time LN is ready.   It would incentivize full nodes even\nfurther than LN does, and allow the network to be strongly DDOS resistant.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/f40af52a/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-08T21:00:10",
                "message_text_only": "A full node provides several services to the network:\n\n1\u2022Broadcasts blocks (public service)\n2\u2022Broadcasts transactions (public/private service)\n3\u2022Increases privacy by hiding other node\u2019s IPs\n4\u2022Increases network security by protecting it from global DoS.\n5\u2022Provides information filtering services to SPV nodes.\n6\u2022Provides historic blockchain and state information to new nodes.\n\nWith your tip idea you only encourages 6, and by increasing the number of\nnodes, also 3 and 4.\nThe services 1 and 2 cannot be encouraged by tips.\n\nHowever, it's a good way to start.\n\nThere was a way to encourage 2 I described in 2013. (\nhttps://bitcointalk.org/index.php?topic=385528.msg4155300#msg4155300)\n\nI'll soon present a solution to encourage full nodes to store the\nblockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS), a feature\nthat RSK will add to incentivize Bitcoin and RSK full nodes. This solution\nencourages 6.\n\n\n\nOn Thu, May 4, 2017 at 4:28 PM, Erik Aronesty via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This is actually LN\u2019s killer use case - not buying coffees ;)\n>>\n>\n> Yes, micro-payments for online network services is precisely what LN is\n> best at.\n>\n> Establishing a channel with each peer is too expensive.   But using LN to\n> micro-pay for high-quality peer services seems like it would aggregate very\n> well.\n>\n> It would be great if this protocol was in-place and ready to go in or\n> around the same time LN is ready.   It would incentivize full nodes even\n> further than LN does, and allow the network to be strongly DDOS resistant.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/02bf028a/attachment.html>"
            },
            {
                "author": "Natanael",
                "date": "2017-05-08T21:44:41",
                "message_text_only": "Den 8 maj 2017 23:01 skrev \"Sergio Demian Lerner via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\nI'll soon present a solution to encourage full nodes to store the\nblockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS)\n\n\nProving that you're holding your own copy of the blockchain, not shared\nwith other nodes? I don't think that's possible to do securely. It falls on\nthat the whole blockchain is both public and static, while any such proof\nof independence needs to rely on unique capabilities per node.\n\nAll you can do with a challenge-response protocol is to prevent honest\nnodes from being unwitting backends to dishonest transparent proxy nodes\n(by binding the challenge to cryptographic node identities).\n\nEven latency bounding protocols can't stop you from putting multiple\n*seemingly independent* nodes in front of the same backend with one single\ncopy of the blockchain.\n\nI believe best you can do is to force somebody to hold multiple copies\nlocally on multiple hardware units to not run out of memory I/O when\ncreating proofs for multiple remote nodes, through using memory heavy\nfunctions for the proof of storage, forcing quick random access. However\nsomebody willing to put enough RAM in a server rack to hold the full\nblockchain could still easily pretend to be multiple regular nodes with\nindependent copies.\n\nAny kind of attempt at forcing the full copy of the blockchain to be in\nmemory close to the CPU will either rule out most nodes from passing or\nwill be cheatable.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/fd49c403/attachment-0001.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-08T22:15:48",
                "message_text_only": "Yes you practically can. No proxy can defeat the protocol investing less\nmoney than buying storage space to store the blockchain.\n\nEven with challenge-response delays of minutes.  That's why it will be\nfully controlled by a RSK smart-contract, with no user intervention.\nI'm will post about this soon.\n\n\n\n\nOn Mon, May 8, 2017 at 6:44 PM, Natanael <natanael.l at gmail.com> wrote:\n\n>\n> Den 8 maj 2017 23:01 skrev \"Sergio Demian Lerner via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n> I'll soon present a solution to encourage full nodes to store the\n> blockchain based on Proof-of-Unique-Blockchain-Storage (PoUBS)\n>\n>\n> Proving that you're holding your own copy of the blockchain, not shared\n> with other nodes? I don't think that's possible to do securely. It falls on\n> that the whole blockchain is both public and static, while any such proof\n> of independence needs to rely on unique capabilities per node.\n>\n> All you can do with a challenge-response protocol is to prevent honest\n> nodes from being unwitting backends to dishonest transparent proxy nodes\n> (by binding the challenge to cryptographic node identities).\n>\n> Even latency bounding protocols can't stop you from putting multiple\n> *seemingly independent* nodes in front of the same backend with one single\n> copy of the blockchain.\n>\n> I believe best you can do is to force somebody to hold multiple copies\n> locally on multiple hardware units to not run out of memory I/O when\n> creating proofs for multiple remote nodes, through using memory heavy\n> functions for the proof of storage, forcing quick random access. However\n> somebody willing to put enough RAM in a server rack to hold the full\n> blockchain could still easily pretend to be multiple regular nodes with\n> independent copies.\n>\n> Any kind of attempt at forcing the full copy of the blockchain to be in\n> memory close to the CPU will either rule out most nodes from passing or\n> will be cheatable.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/ae0f8ad0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Full node \"tip\" function",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ben Thompson",
                "Tomas",
                "Natanael",
                "Tom Zander",
                "Aymeric Vitte",
                "Sergio Demian Lerner",
                "Gregory Maxwell",
                "Erik Aronesty",
                "Matt Corallo",
                "Luke Dashjr"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 34313
        }
    },
    {
        "title": "[bitcoin-dev] Combining SPV and Stealth addresses",
        "thread_messages": [
            {
                "author": "Henning Kopp",
                "date": "2017-05-04T12:51:39",
                "message_text_only": "Hi all,\n\nRecently I think a lot about combining Stealth addresses with SPV but\nI did not come to a satisfying conclusion, so I post this as a\nchallenge to the wider community. Maybe you have an idea.\n\n## Explanation of SPV\nIn SPV a thin client puts his public keys in a bloom filter\nand asks a full node to give him Merkle proofs of all transactions\nwhose pubkey are in the bloom filter. Since a bloom filter has a lot\nof false positives depending on the parameters, this gives privacy to\nthe thin client, since the full node cannot detect if a specific\ntransaction belongs to the thin client. This is cool if you want to\nuse Bitcoin on your smartphone.\n\n## Explanation of Stealth Addresses\nStealth addresses on the other hand enable receiver privacy. The\nsender of a transaction derives a one-time pubkey to which he sends the\nmoney. The receiver can check if the money was sent to him and recover\nthe one-time private key. This is cool, since an observer cannot\ndecide if two payments belong to the same recipient. Further the\nrecipient needs only to have one pubkey.\nFor a more formal explanation see https://github.com/genjix/bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey\nI will use their notation in the following.\n\n## The Problem\nMy line of thought was to combine stealth addresses with spv, so that\nI can use stealth addresses on my smart phone without losing privacy.\n\nBasically to check if a payment belongs to a pubkey (Q,R), the full\nnode needs to check if R' = R + H(dP)*G for each transaction. For this\nit needs the private scanning key d.\nThis sucks, since when I give my d to a full node, he can link all my\ntransactions. For an online-wallet this may be okay, but not for thin\nclient synchronisation.\n\n## Ideas\nIn the following I detail some ideas of me which did not work.\n\nIt does not suffice to have a Bloom filter and check if d is\ncontained since there is no way to recompute d from the equation. If\nthere were a way to recompute d, the scheme would offer no privacy,\nsince anyone could compute the private scanning key d and scan for\npayments.\nSo, if we modify the scheme we need to be sure that d is kept private.\n\nMultiparty computation may be possible in theory. The full node and\nthe thin client could collaboratively check R' = R + H(dP)*G, where d\nis the private input of the thin client and R, R',P is provided by the\nfull node. But this is costly and they need to do it for each\ntransaction. It may be more costly than simply setting up a full node.\n\nI do not think that some kind of search functionality without leaking\nthe search pattern (PIR?) would work, since the full node needs to compute on the\ndata it has found. And further it needs to retrieve the whole Merkle\nproofs.\n\nAny better ideas?\n\nBest,\nHenning\n\n-- \nHenning Kopp\nInstitute of Distributed Systems\nUlm University, Germany\n\nOffice: O27 - 3402\nPhone: +49 731 50-24138\nWeb: http://www.uni-ulm.de/in/vs/~kopp"
            },
            {
                "author": "Chris Pacia",
                "date": "2017-05-04T16:23:27",
                "message_text_only": "Yes I've had it working using two pushes in op_return.\n\nop_return op_pushdata <flag> op_pushdata <ephem_pubkey>\n\nFlag goes in your filter. You anonymity set is all other transactions using\nthat same flag.\n\nThis is fairly decent privacy but the problem is you still need filter\nmatches on outgoing transactions to build a functioning wallet. So it might\nnot be an improvement over standard bloom filters but at least you can do\nstealth if you want.\n\nOn May 4, 2017 9:00 AM, \"Henning Kopp via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Recently I think a lot about combining Stealth addresses with SPV but\n> I did not come to a satisfying conclusion, so I post this as a\n> challenge to the wider community. Maybe you have an idea.\n>\n> ## Explanation of SPV\n> In SPV a thin client puts his public keys in a bloom filter\n> and asks a full node to give him Merkle proofs of all transactions\n> whose pubkey are in the bloom filter. Since a bloom filter has a lot\n> of false positives depending on the parameters, this gives privacy to\n> the thin client, since the full node cannot detect if a specific\n> transaction belongs to the thin client. This is cool if you want to\n> use Bitcoin on your smartphone.\n>\n> ## Explanation of Stealth Addresses\n> Stealth addresses on the other hand enable receiver privacy. The\n> sender of a transaction derives a one-time pubkey to which he sends the\n> money. The receiver can check if the money was sent to him and recover\n> the one-time private key. This is cool, since an observer cannot\n> decide if two payments belong to the same recipient. Further the\n> recipient needs only to have one pubkey.\n> For a more formal explanation see https://github.com/genjix/\n> bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey\n> I will use their notation in the following.\n>\n> ## The Problem\n> My line of thought was to combine stealth addresses with spv, so that\n> I can use stealth addresses on my smart phone without losing privacy.\n>\n> Basically to check if a payment belongs to a pubkey (Q,R), the full\n> node needs to check if R' = R + H(dP)*G for each transaction. For this\n> it needs the private scanning key d.\n> This sucks, since when I give my d to a full node, he can link all my\n> transactions. For an online-wallet this may be okay, but not for thin\n> client synchronisation.\n>\n> ## Ideas\n> In the following I detail some ideas of me which did not work.\n>\n> It does not suffice to have a Bloom filter and check if d is\n> contained since there is no way to recompute d from the equation. If\n> there were a way to recompute d, the scheme would offer no privacy,\n> since anyone could compute the private scanning key d and scan for\n> payments.\n> So, if we modify the scheme we need to be sure that d is kept private.\n>\n> Multiparty computation may be possible in theory. The full node and\n> the thin client could collaboratively check R' = R + H(dP)*G, where d\n> is the private input of the thin client and R, R',P is provided by the\n> full node. But this is costly and they need to do it for each\n> transaction. It may be more costly than simply setting up a full node.\n>\n> I do not think that some kind of search functionality without leaking\n> the search pattern (PIR?) would work, since the full node needs to compute\n> on the\n> data it has found. And further it needs to retrieve the whole Merkle\n> proofs.\n>\n> Any better ideas?\n>\n> Best,\n> Henning\n>\n> --\n> Henning Kopp\n> Institute of Distributed Systems\n> Ulm University, Germany\n>\n> Office: O27 - 3402\n> Phone: +49 731 50-24138\n> Web: http://www.uni-ulm.de/in/vs/~kopp\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170504/1b1ad9a5/attachment.html>"
            },
            {
                "author": "Henning Kopp",
                "date": "2017-05-06T09:38:06",
                "message_text_only": "Sorry, I cannot quite follow you. What do you mean with flag?\n\nBest,\nHenning\n\n\nAm 04.05.2017 um 18:23 schrieb Chris Pacia:\n> Yes I've had it working using two pushes in op_return.\n>\n> op_return op_pushdata <flag> op_pushdata <ephem_pubkey>\n>\n> Flag goes in your filter. You anonymity set is all other transactions using\n> that same flag.\n>\n> This is fairly decent privacy but the problem is you still need filter\n> matches on outgoing transactions to build a functioning wallet. So it might\n> not be an improvement over standard bloom filters but at least you can do\n> stealth if you want.\n>\n> On May 4, 2017 9:00 AM, \"Henning Kopp via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> Recently I think a lot about combining Stealth addresses with SPV but\n>> I did not come to a satisfying conclusion, so I post this as a\n>> challenge to the wider community. Maybe you have an idea.\n>>\n>> ## Explanation of SPV\n>> In SPV a thin client puts his public keys in a bloom filter\n>> and asks a full node to give him Merkle proofs of all transactions\n>> whose pubkey are in the bloom filter. Since a bloom filter has a lot\n>> of false positives depending on the parameters, this gives privacy to\n>> the thin client, since the full node cannot detect if a specific\n>> transaction belongs to the thin client. This is cool if you want to\n>> use Bitcoin on your smartphone.\n>>\n>> ## Explanation of Stealth Addresses\n>> Stealth addresses on the other hand enable receiver privacy. The\n>> sender of a transaction derives a one-time pubkey to which he sends the\n>> money. The receiver can check if the money was sent to him and recover\n>> the one-time private key. This is cool, since an observer cannot\n>> decide if two payments belong to the same recipient. Further the\n>> recipient needs only to have one pubkey.\n>> For a more formal explanation see https://github.com/genjix/\n>> bips/blob/master/bip-stealth.mediawiki#Reuse_ScanPubkey\n>> I will use their notation in the following.\n>>\n>> ## The Problem\n>> My line of thought was to combine stealth addresses with spv, so that\n>> I can use stealth addresses on my smart phone without losing privacy.\n>>\n>> Basically to check if a payment belongs to a pubkey (Q,R), the full\n>> node needs to check if R' = R + H(dP)*G for each transaction. For this\n>> it needs the private scanning key d.\n>> This sucks, since when I give my d to a full node, he can link all my\n>> transactions. For an online-wallet this may be okay, but not for thin\n>> client synchronisation.\n>>\n>> ## Ideas\n>> In the following I detail some ideas of me which did not work.\n>>\n>> It does not suffice to have a Bloom filter and check if d is\n>> contained since there is no way to recompute d from the equation. If\n>> there were a way to recompute d, the scheme would offer no privacy,\n>> since anyone could compute the private scanning key d and scan for\n>> payments.\n>> So, if we modify the scheme we need to be sure that d is kept private.\n>>\n>> Multiparty computation may be possible in theory. The full node and\n>> the thin client could collaboratively check R' = R + H(dP)*G, where d\n>> is the private input of the thin client and R, R',P is provided by the\n>> full node. But this is costly and they need to do it for each\n>> transaction. It may be more costly than simply setting up a full node.\n>>\n>> I do not think that some kind of search functionality without leaking\n>> the search pattern (PIR?) would work, since the full node needs to compute\n>> on the\n>> data it has found. And further it needs to retrieve the whole Merkle\n>> proofs.\n>>\n>> Any better ideas?\n>>\n>> Best,\n>> Henning\n>>\n>> --\n>> Henning Kopp\n>> Institute of Distributed Systems\n>> Ulm University, Germany\n>>\n>> Office: O27 - 3402\n>> Phone: +49 731 50-24138\n>> Web: http://www.uni-ulm.de/in/vs/~kopp\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>"
            }
        ],
        "thread_summary": {
            "title": "Combining SPV and Stealth addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Henning Kopp",
                "Chris Pacia"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10891
        }
    },
    {
        "title": "[bitcoin-dev] Fraud Proofs with semi SPV",
        "thread_messages": [
            {
                "author": "Tomas",
                "date": "2017-05-05T08:49:35",
                "message_text_only": "I would like some feedback on the idea to use a node type a bit heavier\nthen SPV (dubbed FSPV) to solve Fraud Proofs.\n\nAn FSPV node not only downloads block headers, but also the \"spend-tree\nblocks\", consisting of all TXIDs and all previous output indices and\nTXIDs. The latter can be compacted using a scheme similar to Compact\nBlocks, which will make the spend-tree block ~80kb in size.\n\nThIs way the FSPV can track the full transaction graph at little cost.\n\nThe advantage is, that Fraud Hint messages for absent/withheld\ntransactions become feasible. A normal SPV  is reduced to Full Node by\nsuch (cheaply faked) hint, but for an FSPV the cost is almost zero.\n\nAll it needs to do is add a taint-bit in the tree and propagate the\ntaint to the transaction graph. It then knows it needs to request the\nFraud Hinted transaction to consider any descendant transaction valid.\n\nThis makes it sufficient to punish fraudulent fraud hints or withheld\ntransactions by normal \"banscore\" procedures.\n\nAll other fraud can be proven by transaction-sets.\n\nMore information here:  https://bitcrust.org/blog-fraud-proofs\n\nTomas\nBitcrust"
            }
        ],
        "thread_summary": {
            "title": "Fraud Proofs with semi SPV",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tomas"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1122
        }
    },
    {
        "title": "[bitcoin-dev] Non-confirming block signalling",
        "thread_messages": [
            {
                "author": "Tomas",
                "date": "2017-05-05T11:24:49",
                "message_text_only": "I propose a method to mark blocks to indicate that they were generated\nwithout verifying the previous block. This can be done by using a bit of\nthe version field.\n\nThis would counter the reduction of security caused by what is known as\n\"SPV-mining\".\n\nThe BIP is here:\nhttps://github.com/tomasvdw/bips/blob/master/bip-non-confirming-block-signalling.mediawiki\n\nTomas\nbitcrust"
            },
            {
                "author": "Bryan Bishop",
                "date": "2017-05-05T13:01:40",
                "message_text_only": "On Fri, May 5, 2017 at 6:24 AM, Tomas via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I propose a method to mark blocks to indicate that they were generated\n> without verifying the previous block. This can be done by using a bit of\n> the version field.\n>\n\nsee also:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011853.html\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170505/fbd6515d/attachment.html>"
            },
            {
                "author": "Tomas",
                "date": "2017-05-05T13:09:17",
                "message_text_only": "Sorry, I wasn't aware. This is indeed the same proposal.\n\n\n\nOn Fri, May 5, 2017, at 15:01, Bryan Bishop wrote:\n> On Fri, May 5, 2017 at 6:24 AM, Tomas via bitcoin-dev <bitcoin-\n> dev at lists.linuxfoundation.org> wrote:>> I propose a method to mark blocks to indicate that they were\n>> generated>> without verifying the previous block. This can be done by using\n>> a bit of>> the version field.\n> \n> see also:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011853.html> \n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170505/7da7d11e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Non-confirming block signalling",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tomas",
                "Bryan Bishop"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 1700
        }
    },
    {
        "title": "[bitcoin-dev] Per-block non-interactive Schnorr signature aggregation",
        "thread_messages": [
            {
                "author": "adiabat",
                "date": "2017-05-07T06:45:00",
                "message_text_only": "If / when Schnorr signatures are deployed in a future witness version, it\nmay be possible to have non-interactive partial aggregation of the\nsignatures on a per-block basis.  This could save quite a bit of space.  It\n*seems* not to have any security problems but this mailing list is very\ngood at finding vulnerabilities so that type of feedback is the main reason\nI'm writing :) (A quick explanation of why this is horribly broken could\nsave me lots of time!)\n(also sorry if this has been discussed; didn't see anything)\n\nQuick recap / context of Schnorr sigs:\n\nThere are a bunch of private keys x1, x2, x3...\nmultiply by generator G to get x1G = P1, x2G = P2, x3G = P3\n\nEveryone makes their sighash m1, m2, m3, and their random nonces k1, k2, k3.\n\nTo sign, people calculate s values:\n\ns1 = k1 - h(m1, R1, P1)x1\ns2 = k2 - h(m2, R2, P2)x2\n\n(adding the P2 into the e hash value is not in most literature /\nexplanations but helps with some attacks; I beleive that's the current\nthinking.  Anyway it doesn't matter for this idea)\n\nSignature 1 is [R1, s1].  Verifiers check, given P1, m1, R1, s1:\n\ns1G =? R1 - h(m1, R1, P1)P1\n\nYou can *interactively* make aggregate signatures, which requires\nco-signers to build an aggregate R value by coming up with their own k\nvalues, sharing their R with the co-signers, adding up the R's to get a\nsummed R, and using that to sign.\n\nNon-interactively though, it seems like you can aggregate half the\nsignature.  The R values are unique to the [m, P] pair, but the s's can be\nsummed up:\n\ns1 + s2 = k1 + k2 - h(m1, R1, P1)x1 - h(m2, R2, P2)x2\n\n(s1 + s2)G = R1 + R2 - h(m1, R1, P1)P1 - h(m2, R2, P2)P2\n\nTo use this property in Bitcoin, when making transactions, wallets can sign\nin the normal way, and the signature, consisting of [R, s] goes into the\nwitness stack.  When miners generate a block, they remove the s-value from\nall compatible inputs, and commit to the aggregate s-value in the coinbase\ntransaction (either in a new OP_RETURN or alongside the existing witness\ncommitment structure).\n\nThe obvious advatage is that signatures go down to 32 bytes each, so you\ncan fit more of them in a block, and they take up less disk and network\nspace.  (In IBD; if a node maintains a mempool they'll need to receive all\nthe separate s-values)\n\nAnother advatage is that block verification is sped up.  For individual\nsignatures, the computation involves:\n\ne = h(m1, R1, P1)           <- hash function, super fast\ne*P                         <- point multiplication, slowest\nR - e*P                     <- point addidion, pretty fast\ns*G                         <- base point multiplication, pretty slow\n\nwith s-aggregate verification, the first three steps are still carried out\non each signature, but the s*G operation only needs to be done once.\nInstead another point addition per signature is needed, where you have some\naccumulator and add in the left side:\nA += R - e*P\nthis can be parallelized pretty well as it's commutative.\n\nThe main downside I can see (assuming this actually works) is that it's\nhard to cache signatures and quickly validate a block after it has come\nin.  It might not be as bad as it first seems, as validation given chached\nsignatures looks possible without any elliptic curve operations.  Keep an\naggregate s-value (which is a scalar) for all the txs in your mempool.\nWhen a block comes in, subtract all the s-values for txs not included in\nthe block.  If the block includes txs you weren't aware of, request them in\nthe same way compact blocks works, and get the full signature for those\ntxs.  It could be several thousand operations, but those are all bigInt\nmodular additions / subtractions which I believe are pretty quick in\ncomparison with point additions / multiplications.\n\nThere may be other complications due to the fact that the witness-txids\nchange when building a block.  TXIDs don't change though so should be\npossible to keep track of things OK.\n\nAlso you can't \"fail fast\" for the signature verification; you have to add\neverything up before you can tell if it's correct.  Probably not a big deal\nas PoW check comes first, and invalid blocks are pretty uncommon and quite\ncostly.\n\nWould be interested to hear if this idea looks promising.\nAndrew Polestra mentioned something like this in the context of CT /\nmimblewimble transactions a while ago, but it seems it may be applicable to\nregular bitcoin Schnorr txs.\n\n-Tadge\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/4f2f604d/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-10T01:59:06",
                "message_text_only": "I'm a bit amateur at this sort of thing, but let me try to argue that this\nproposal is in fact horribly broken ;)\n\nSuppose Alice has some UTXO with some money Bob wants to steal.  Grant me\nthat the public key P0 protecting Alice's UTXO is public (say because the\npublic key has been reused elsewhere).\n\nBob going to spend Alice's UTXO by generating random values s0, k0 and R0\n:= k0*G and thus creating a random signature for it, [R0, s0].  Now clearly\nthis signature isn't going to be valid by itself because it is just random.\nBob's goal will be to make a transaction with other inputs such that, while\nthe individual signatures are not valid, the aggregated signature will be\nvalid.\n\nTo do this Bob generates a set of random public keys P1 ... P_n of the form\nP_i := P0 + r_i*G, and a bunch of random k1 ... k_n with R1 := k1*G ... R_n\n:= k_n*G, such that\n\n    h(m1, R1, P1) + ... + h(m_n, R_n, P_n) = -h(m0, R0 P0) (modulo the\norder of the elliptic curve)\n\nI understand that this can be done efficiently with Wagner's Generalized\nBirthday attack.\n\nThe RHS aggregated signature equation on the private side is\n\n    k0 + k1 + ... k_n - h(m0, R0, P0)x0 - h(m1, R1, P1)(x0 + r1) - ... -\nh(m_n, R_n, P_n)(x0 + r_n)\n\nwith x0 unknown to Bob.  Rearranging the terms we get\n\n    k0 + k1 + ... k_n - [h(m0, R0, P0) + h(m1, R1, P1) + ... + h(m_n, R_n,\nP_n)]*x0 - [h(m1, R1, P1)*r1 + ... + h(m_n, R_n, P_n)*r_n]\n\nHowever [h(m0, R0, P0) + h(m1, R1, P1) + ... + h(m_n, R_n, P_n)] is 0 so\ncancelling that we are left with\n\n    k0 + k1 + ... k_n - [h(m1, R1, P1)*r1 + ... + h(m_n, R_n, P_n)*r_n]\n\nwhich no longer depends on the unknown value x0, so that is good.  Bob\nknows what this value is.\n\nBob creates a set UTXOs by spending to the set of public keys P1 .. P_n.\nBob don't know what the private keys are for these public keys, but that is\ngoing to be okay.\n\nBob creates a final transaction that takes as input the UTXO of Alice's\nfunds he wants to steal, with public key P0, and also his newly created\nUTXOs with public keys P1 ... P_n.\nFor the signature on Alice's input he uses [R0,s0].  For the rest of the\nsignature he picks s1 ... s_n such that\n\n    s0 + s1 + ... + sn = k0 + k1 + ... k_n - [h(m1, R1, P1)*r1 + ... +\nh(m_n, R_n, P_n)*r_n] (which is equal to k0 + k1 + ... k_n - h(m0, R0,\nP0)x0 - h(m1, R1, P1)(x0 + r1) - ... - h(m_n, R_n, P_n)(x0 + r_n)).\n\nand uses signatures [R1, s1] ... [R_n, s_n] on his other inputs.\n\nThus, while none of the individual signatures are valid, the aggregated\nsignature does validate.\n\nOne wrinkles in this argument is that Bob needs to pick m1 ... m_n before\nhe knows what the transaction will be.  I think this can be mitigated by\nusing some combination of SIGHASH_ANYONECANPAY, but I'm not sure if that\nworks.  Even if my argument doesn't actually work, I think it is close\nenough to be pretty scary.\n\nThanks goes to Pieter Wuille for helping explain things to me; however any\nerrors above are my own.\n\nOn Sun, May 7, 2017 at 2:45 AM, adiabat via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If / when Schnorr signatures are deployed in a future witness version, it\n> may be possible to have non-interactive partial aggregation of the\n> signatures on a per-block basis.  This could save quite a bit of space.  It\n> *seems* not to have any security problems but this mailing list is very\n> good at finding vulnerabilities so that type of feedback is the main reason\n> I'm writing :) (A quick explanation of why this is horribly broken could\n> save me lots of time!)\n> (also sorry if this has been discussed; didn't see anything)\n>\n> Quick recap / context of Schnorr sigs:\n>\n> There are a bunch of private keys x1, x2, x3...\n> multiply by generator G to get x1G = P1, x2G = P2, x3G = P3\n>\n> Everyone makes their sighash m1, m2, m3, and their random nonces k1, k2,\n> k3.\n>\n> To sign, people calculate s values:\n>\n> s1 = k1 - h(m1, R1, P1)x1\n> s2 = k2 - h(m2, R2, P2)x2\n>\n> (adding the P2 into the e hash value is not in most literature /\n> explanations but helps with some attacks; I beleive that's the current\n> thinking.  Anyway it doesn't matter for this idea)\n>\n> Signature 1 is [R1, s1].  Verifiers check, given P1, m1, R1, s1:\n>\n> s1G =? R1 - h(m1, R1, P1)P1\n>\n> You can *interactively* make aggregate signatures, which requires\n> co-signers to build an aggregate R value by coming up with their own k\n> values, sharing their R with the co-signers, adding up the R's to get a\n> summed R, and using that to sign.\n>\n> Non-interactively though, it seems like you can aggregate half the\n> signature.  The R values are unique to the [m, P] pair, but the s's can be\n> summed up:\n>\n> s1 + s2 = k1 + k2 - h(m1, R1, P1)x1 - h(m2, R2, P2)x2\n>\n> (s1 + s2)G = R1 + R2 - h(m1, R1, P1)P1 - h(m2, R2, P2)P2\n>\n> To use this property in Bitcoin, when making transactions, wallets can\n> sign in the normal way, and the signature, consisting of [R, s] goes into\n> the witness stack.  When miners generate a block, they remove the s-value\n> from all compatible inputs, and commit to the aggregate s-value in the\n> coinbase transaction (either in a new OP_RETURN or alongside the existing\n> witness commitment structure).\n>\n> The obvious advatage is that signatures go down to 32 bytes each, so you\n> can fit more of them in a block, and they take up less disk and network\n> space.  (In IBD; if a node maintains a mempool they'll need to receive all\n> the separate s-values)\n>\n> Another advatage is that block verification is sped up.  For individual\n> signatures, the computation involves:\n>\n> e = h(m1, R1, P1)           <- hash function, super fast\n> e*P                         <- point multiplication, slowest\n> R - e*P                     <- point addidion, pretty fast\n> s*G                         <- base point multiplication, pretty slow\n>\n> with s-aggregate verification, the first three steps are still carried out\n> on each signature, but the s*G operation only needs to be done once.\n> Instead another point addition per signature is needed, where you have some\n> accumulator and add in the left side:\n> A += R - e*P\n> this can be parallelized pretty well as it's commutative.\n>\n> The main downside I can see (assuming this actually works) is that it's\n> hard to cache signatures and quickly validate a block after it has come\n> in.  It might not be as bad as it first seems, as validation given chached\n> signatures looks possible without any elliptic curve operations.  Keep an\n> aggregate s-value (which is a scalar) for all the txs in your mempool.\n> When a block comes in, subtract all the s-values for txs not included in\n> the block.  If the block includes txs you weren't aware of, request them in\n> the same way compact blocks works, and get the full signature for those\n> txs.  It could be several thousand operations, but those are all bigInt\n> modular additions / subtractions which I believe are pretty quick in\n> comparison with point additions / multiplications.\n>\n> There may be other complications due to the fact that the witness-txids\n> change when building a block.  TXIDs don't change though so should be\n> possible to keep track of things OK.\n>\n> Also you can't \"fail fast\" for the signature verification; you have to add\n> everything up before you can tell if it's correct.  Probably not a big deal\n> as PoW check comes first, and invalid blocks are pretty uncommon and quite\n> costly.\n>\n> Would be interested to hear if this idea looks promising.\n> Andrew Polestra mentioned something like this in the context of CT /\n> mimblewimble transactions a while ago, but it seems it may be applicable to\n> regular bitcoin Schnorr txs.\n>\n> -Tadge\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/75fc05c4/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2017-05-10T07:55:42",
                "message_text_only": "On Tue, May 09, 2017 at 09:59:06PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> I'm a bit amateur at this sort of thing, but let me try to argue that this\n> proposal is in fact horribly broken ;)\n> \n> Suppose Alice has some UTXO with some money Bob wants to steal.  Grant me\n> that the public key P0 protecting Alice's UTXO is public (say because the\n> public key has been reused elsewhere).\n> \n> Bob going to spend Alice's UTXO by generating random values s0, k0 and R0\n> := k0*G and thus creating a random signature for it, [R0, s0].  Now clearly\n> this signature isn't going to be valid by itself because it is just random.\n> Bob's goal will be to make a transaction with other inputs such that, while\n> the individual signatures are not valid, the aggregated signature will be\n> valid.\n>\n\nIf you seed the randomization with every R value (which would come for free\nif you used, say, the witness root) then Wagner's attack no longer applies.\n\nThe idea is that no aggregation occurs until a miner produces a block. You\nhave a bunch of independent Schnorr sigs (s_i, R_i). Then the _miner_ multiples\neach s_i by H(witness root || index) or whatever, sums up the s_i's, and commits\nthe sum somewhere where it doesn't affect the root.\n\nVerifiers then multiply each R_i by the same multiplying factors and are able\nto do a batch verification of them.\n\n\nVerifiers who have seen a signature before and cached it as valid can save\nthemselves a bit of time by subtracting H(witness root || index)*s_i from\nthe summed s-value and then skipping R_i in the above step. These are scalar\noperations and are extremely cheap.\n\nThey can recognize the signature given only the transaction it signs and R_i,\nwhich uniquely determine a valid signature.\n\n\nI believe this is what Tadge was referring to when he mentioned a talk of mine.\nIt's roughly what I've had in mind whenever I talk about non-interactive Schnorr\naggregation.\n\n\n\nCheers\nAndrew\n\n\n-- \nAndrew Poelstra\nMathematics Department, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\n\"A goose alone, I suppose, can know the loneliness of geese\n who can never find their peace,\n whether north or south or west or east\"\n       --Joanna Newsom\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/ab8b75e7/attachment.sig>"
            },
            {
                "author": "adiabat",
                "date": "2017-05-10T14:59:08",
                "message_text_only": "I messed up and only replied to Russel O'Connor; my response is copied below.\nAnd then there's a bit more.\n\n-----\nAha, Wagner's generalized birthday attack, the bane of all clever tricks!\nI didn't realize it applied in this case but looks like it in fact does.\n applies to this case.  It would have to be a miner performing the\nattack as the s-value would only be aggregated in the coinbase tx, but\nthat's hardly an impediment.\n\nIn fact, sketching it out, it doesn't look like the need to know m1,\nm2... m_n is a big problem.  Even if the m's are fixed after being\nchosen based on the P1... Pn's, (in bitcoin, m always commits to P so\nnot sure why it's needed in the hash) there is still freedom to\ncollide the hashes.  The R values can be anything, so getting h(m1,\nR1, P1) + h(m2, R2, P2)... to equal -h(m0, R0, P0) is doable with\nWagner's attack by varying R1, R2... to get different hashes.\n\nI *think* there is a viable defense against this attack, but it does\nmake the whole aggregation setup less attractive.  The miner who\ncalculates s-aggregate could also aggregate all the public keys from\nall the aggregated signatures in the block (P0, P1...), sort them and\nhash the concatenated list of pubkeys.  They could then multiply s by\nthis combo-pubkey hash (call it h(c)).  Then when nodes verify the\naggregate signature, they need to go through all the pubkeys in the\nblock, create the same combo-pubkey hash, and multiply s by the\nmultiplicative inverse of the h(c) they calculate, then verify s.  I\nbelieve this breaks the Wagner generalized birthday attack because\nevery h(m_i, R_i, P_i)*h(c) included or omitted affects the c part of\nh(m0, R0, P0)*h(c).\n\nI'm not sure how badly this impacts the verification speed.  It might\nnot be too bad for verification as it's amortized over the whole\nblock.  For the miner doing the aggregation it's a bit slower as they\nneed to re-sort and hash all the pubkeys every time a new signature is\nadded.  Might not be too slow.\n\nI'm not super confident that this actually prevents the generalized\nbirthday attack though.  I missed that attack in the previous post so\nI'm 0 for 1 against Wagner so far :)\n\n-----\n\nAndrew: Right, commiting to all the R values would also work; is there\nan advantage to using the R's instead of the P's?  At first glance it\nseems about the same.\n\nAnother possible optimization: instead of sorting, concatenate all the\nR's or P's in the order they appear in the block.  Then have the miner\ncommit to s*h(c)^1, the multiplicative inverse of the hash of all\nthose values.  Then when nodes are verifying in IBD, they can just\nmultiply by h(c) and they don't have to compute the inverse.  A bit\nmore work for the miner and a bit less for the nodes.\n\n-Tadge"
            }
        ],
        "thread_summary": {
            "title": "Per-block non-interactive Schnorr signature aggregation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "adiabat",
                "Andrew Poelstra"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 17788
        }
    },
    {
        "title": "[bitcoin-dev] Generalized versionbits BIP requesting number assignment",
        "thread_messages": [
            {
                "author": "Sancho Panza",
                "date": "2017-05-07T08:42:28",
                "message_text_only": "Hola,\n\nI've submitted the generalized versionbits specification for BIP number assignment:\n\nhttps://github.com/bitcoin/bips/pull/532\n\nYour feedback and comments welcome.\n\nThe spec has been updated to include a link to the reference implementation.\nI hope to find time soon to produce a similar reference implementation on Bitcoin Core.\n\nSancho\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/e3a5fded/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Generalized versionbits BIP requesting number assignment",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sancho Panza"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 526
        }
    },
    {
        "title": "[bitcoin-dev] A BIP proposal for segwit addresses",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2017-05-07T21:39:14",
                "message_text_only": "On Mon, Mar 20, 2017 at 2:35 PM, Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> Hello everyone,\n>\n> You can find the text here:\n> https://github.com/sipa/bech32/blob/master/bip-witaddr.mediawiki\n>\n\nResponding to a few comments:\n\nBy Andreas Schildbach:\n\n> I'm not convinced that transmitting addresses via voice should be a\nusecase to target at\n\nI think it should be. It's certainly not the most important way through\nwhich addresses are communicated or verified, but I am trying to address\nall places where humans interact with addresses. I have certainly tried to\nverify addresses a few times through voice, when dealing with significant\namounts.\n\nRegarding your QR code comments: it is certainly possible to find a more\ncompact QR code representation. That is not the goal of the BIP though -\nit's trying to introduce one commonly recognizable format that has good\nproperties for all use cases, even if that means being suboptimal in\ncertain aspects for some.\n\n> I don't understand your comment about non-english speaking users.\nObviously they cannot voice-communicate at all with only-english-speaking\nusers, so there is no need to communicate voice-communicate addresses\nbetween them.\n\nI assume that Peter Todd is talking about cases where English speakers are\ninteracting with non-native English speakers, who may know how to pronounce\nnumbers or alphabetical characters, but not all special characters.\n\n> Speaking of URLs, actually Base 32 (as well as Base 43) makes QR codes\n*bigger* because due to the characters used for URL parameters (?&=) those\nQR codes are locked to binary mode.\n\nI believe that is incorrect. Data in QR codes can switch from one mode to\nanother on a per-character basis (with an overhead of a few bits). I don't\nknow to what extent common QR encoders make intelligent decisions about\nthis, but it does not seem very hard.\n\nBy Lucas Ontivero:\n\n> Here I think it could worth to mention that 58 requires mathematical\noperations over big numbers. This is not very fast and most of the\nprogramming languages don't provide support for big numbers OOB.\n\nIt's not that hard to emulate the bignum logic in languages that don't\nsupport it. See for example this code in Bitcoin Core:\nhttps://github.com/bitcoin/bitcoin/blob/v0.14.1/src/base58.cpp#L37L53. So I\nthink it's not necessary to go into all the possible ways Base58 can be\nimplemented in the document, and the existing language (\"Base58 decoding is\ncomplicated and relatively slow.\") is sufficient.\n\n> I understand that if a new generic encoding format is introduced that\ncould lead to some confusions but what if in the future there is a new type\nof address that can also be encoded with bech32? Don't we need a address\ntype anyway?\n\nI believe that it's likely that new types of outputs that may be introduced\nin the future will most likely not be a simple constant byte sequence that\ncan be computed directly from addresses, but need some processing by the\nsender. This is the case for example for Reusable/Stealth addresses and\nConfidential Transactions addresses. Such outputs, if ever introduced on a\nwide scale, should ideally not be representable as existing address types,\nas that could not only lead to confusion, but also to lost privacy and\nfunds.\n\nAnd, If there ever is a need for introducing a \"constant scriptPubKey\" type\naddress again, the encoding proposed in this document can be reused.\nCurrently, the header value can be at most 17. In the future new proposals\ncould give a meaning to values 18 through 31.\n\n\nIn general:\n\nIn the past weeks people have contributed two new reference implementations\n(Haskell and Rust), and a C++ and Go one are underway (see\nhttps://github.com/sipa/bech32).\n\nI'd like to move forward and request a BIP number assignment for this\nproposal.\n\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/926b2de1/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-07T22:34:29",
                "message_text_only": "On Sun, May 07, 2017 at 02:39:14PM -0700, Pieter Wuille via bitcoin-dev wrote:\n> > I don't understand your comment about non-english speaking users.\n> Obviously they cannot voice-communicate at all with only-english-speaking\n> users, so there is no need to communicate voice-communicate addresses\n> between them.\n> \n> I assume that Peter Todd is talking about cases where English speakers are\n> interacting with non-native English speakers, who may know how to pronounce\n> numbers or alphabetical characters, but not all special characters.\n\nExactly - knowledge of the English language isn't a binary. Equally, I don't\nremember ever learning names of special characters in French class back in\nelementary school, but I do recall us drilling the alphabet and especially\nnumbers repeatedly.\n\nIf I were trying to tell a French speaker a BTC address, I'd probably be able\nto succesfully do it with bech32, but not with any encoding using special\ncharacters.\n\n> In general:\n> \n> In the past weeks people have contributed two new reference implementations\n> (Haskell and Rust), and a C++ and Go one are underway (see\n> https://github.com/sipa/bech32).\n\nFWIW, I also did a partial rust implementation of just the Bech32 encoding for\na prototype non-BTC use-case. Other than the version number being it's own\n\"chunk\" I found it very straight-forward to implement and I think it'll make\nfor a nice replacement for what otherwise would have been hex digests.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170507/9320e243/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2017-05-20T20:13:13",
                "message_text_only": "On Sun, May 7, 2017 at 2:39 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> I'd like to move forward and request a BIP number assignment for this\n> proposal.\n\nThe proposal has been submitted as BIP173:\nhttps://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\n\nCheers,\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "A BIP proposal for segwit addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Peter Todd"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6052
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal: Rate Limiting with server specified Proof of Work challenges",
        "thread_messages": [
            {
                "author": "Karl Johan Alm",
                "date": "2017-05-08T02:48:54",
                "message_text_only": "Hello,\n\nI am proposing a new feature for rate limiting purposes where nodes\ncan make and solve arbitrary PoW challenges in return for connection\nslots (to be expanded to cover e.g. bloom filters or other DoS risky\nservices).\n\nThe BIP currently includes two proofs of work (sha256 and\ncuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or\nsha256(sha256(sha256)), etc).\n\nLink: https://github.com/kallewoof/bips/blob/pow-connection-slots/bip-rate-limiting-via-pow.mediawiki\n\nFeedback welcome."
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-08T18:58:54",
                "message_text_only": "- It would be cool if any rate-limiting POW was specified as bytecode ...\nso nodes can plug in as many \"machine-captcha\" things as they please, and\nsolvers can choose to solve... or just say \"nope too hard\".\n\n- Alternately, it would be a lot nicer if you just required people to pay a\nnanobit .... that could prevent DDOS even better, and generate a revenue\nstream for nodes.\n\n\nOn Sun, May 7, 2017 at 10:48 PM, Karl Johan Alm via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> I am proposing a new feature for rate limiting purposes where nodes\n> can make and solve arbitrary PoW challenges in return for connection\n> slots (to be expanded to cover e.g. bloom filters or other DoS risky\n> services).\n>\n> The BIP currently includes two proofs of work (sha256 and\n> cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or\n> sha256(sha256(sha256)), etc).\n>\n> Link: https://github.com/kallewoof/bips/blob/pow-connection-\n> slots/bip-rate-limiting-via-pow.mediawiki\n>\n> Feedback welcome.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/81601374/attachment.html>"
            },
            {
                "author": "Karl Johan Alm",
                "date": "2017-05-09T01:15:25",
                "message_text_only": "Erik,\n\nOn Tue, May 9, 2017 at 3:58 AM, Erik Aronesty <erik at q32.com> wrote:\n> - It would be cool if any rate-limiting POW was specified as bytecode ... so\n> nodes can plug in as many \"machine-captcha\" things as they please, and\n> solvers can choose to solve... or just say \"nope too hard\".\n\nI'm not entirely sure what you mean, but right now you can make an\narbitrary chain of challenges, and the BIP includes methods for\ndetermining an approximate time to solve (nodes will, at the very\nleast, discard any challenge which will on average take longer time to\nsolve than the expiration of the challenge itself, for example, i.e.\nthe \"nope too hard\" part).\n\n> - Alternately, it would be a lot nicer if you just required people to pay a\n> nanobit .... that could prevent DDOS even better, and generate a revenue\n> stream for nodes.\n\nOthers mentioned this approach. I haven't given it much thought.\nAdmittedly it would be an effective way to prevent DoS but it also has\nsome unwanted side effects that need to be cleared up (e.g. in a\nno-gains scenario like the BIP proposes, the node requesting PoW done\ndoesn't *gain* anything from lying to the node performing the work)."
            },
            {
                "author": "Karl Johan Alm",
                "date": "2017-05-19T04:09:29",
                "message_text_only": "Hello,\n\nSome time has passed since this was initially posted, and I have not\nreceived any negative feedback. If no objections are raised, I would\nlike to have a BIP number assigned.\n\nOn Mon, May 8, 2017 at 11:48 AM, Karl Johan Alm\n<karljohan-alm at garage.co.jp> wrote:\n> Hello,\n>\n> I am proposing a new feature for rate limiting purposes where nodes\n> can make and solve arbitrary PoW challenges in return for connection\n> slots (to be expanded to cover e.g. bloom filters or other DoS risky\n> services).\n>\n> The BIP currently includes two proofs of work (sha256 and\n> cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or\n> sha256(sha256(sha256)), etc).\n>\n> Link: https://github.com/kallewoof/bips/blob/pow-connection-slots/bip-rate-limiting-via-pow.mediawiki\n>\n> Feedback welcome."
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal: Rate Limiting with server specified Proof of Work challenges",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Karl Johan Alm",
                "Erik Aronesty"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 3859
        }
    },
    {
        "title": "[bitcoin-dev] TXMempool and dirty entries",
        "thread_messages": [
            {
                "author": "DJ Bitcoin",
                "date": "2017-05-08T09:38:16",
                "message_text_only": "An HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/a2490e42/attachment.html>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2017-05-08T16:33:42",
                "message_text_only": "Hi,\n\nI've moved the bitcoin-dev list to bcc:, as this question is better suited\nto forums dedicated to Bitcoin Core implementation specifics, rather than\nthe general bitcoin development list.\n\nPlease feel free in the future to ask questions like this on the\nbitcoin-core-dev mailing list (https://lists.linuxfoundation\n.org/mailman/listinfo/bitcoin-core-dev) or on the #bitcoin-core-dev\nfreenode IRC channel.\n\nThe work limit (that was put in place in https://github.com/bitcoin/\nbitcoin/pull/6654, when the concept of \"dirty\" entries was introduced) was\nremoved in https://github.com/bitcoin/bitcoin/pull/7594, in preparation for\nancestor-feerate-mining.  So those comments should have been cleaned up to\nmatch the new code.\n\nPlease feel free to file an issue or open a PR to update those comments at\nhttps://github.com/bitcoin/bitcoin.\n\nThanks,\nSuhas\n\n\nOn Mon, May 8, 2017 at 5:38 AM, DJ Bitcoin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Guys,\n>\n> I have a question about the use of txmempool. find attached the code in\n> txmempool.h\n>\n>\n> ======================================================\n> /* Adding transactions from a disconnected block can be very time\n> consuming,\n>  * because we don't have a way to limit the number of in-mempool\n> descendants.\n>  * To bound CPU processing, we limit the amount of work we're willing to do\n>  * to properly update the descendant information for a tx being added from\n>  * a disconnected block.  If we would exceed the limit, then we instead\n> mark\n>  * the entry as \"dirty\", and set the feerate for sorting purposes to be\n> equal\n>  * the feerate of the transaction without any descendants. */\n>\n> class CTxMemPoolEntry\n> {\n>    private:\n>    // ...\n>    // Information about descendants of this transaction that are in the\n>    // mempool; if we remove this transaction we must remove all of these\n>    // descendants as well. if nCountWithDescendants is 0, treat this entry\n> as\n>    // dirty, and nSizeWithDescendants and nModFeesWithDescendants will not\n> be\n>    // correct.\n>\n>    int64_t nCountWithDescendants; //!< number of descendant transactions\n>    // ...\n> ======================================================\n>\n>\n> Now, the only place where nCountWithDescendants is modified is the\n> following (txmempool.cpp):\n>\n>\n> ======================================================\n> void CTxMemPoolEntry::UpdateDescendantState(int64_t modifySize, CAmount\n> modifyFee, int64_t modifyCount)\n> {\n>     nSizeWithDescendants += modifySize;\n>     assert(int64_t(nSizeWithDescendants) > 0);\n>     nModFeesWithDescendants += modifyFee;\n>     nCountWithDescendants += modifyCount;\n>     assert(int64_t(nCountWithDescendants) > 0);\n> }\n> ======================================================\n>\n>\n> Therefore, nCountWithDescendants is never zero.\n> Am i missing something? Where is this concept of \"dirty\" defined?\n>\n> Thanks a lot,\n> DJ\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/dfb5c9f0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "TXMempool and dirty entries",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Suhas Daftuar",
                "DJ Bitcoin"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3439
        }
    },
    {
        "title": "[bitcoin-dev] Some real-world results about the current Segwit Discount",
        "thread_messages": [
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-08T22:42:23",
                "message_text_only": "I have processed 1000 blocks starting from Block #461653.\n\nI computed several metrics, including the supposed size of witness data and\nnon-witness data (onchain), assuming all P2SH inputs/outputs are converted\nto P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.\n\nThis takes into account that other types of transactions will not be\nmodified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't\ntake into account that LN transactions may affect the current state,\n increasing the segwit/nosegwit ratio.\n\nAmong a lot of information, I've got the following real world results...\n\nacMainChainSpace =352608924\nacSegwitSpace =599400403\nRatio segwit/nosegwit=1.6999\n\nThis implies that the 75% that discount is not the best option to prevent\nwitness spam in a block of 4 MB, as stated in\nhttps://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.\n\nThe non-witness data weight factor should not be 4 but 2.35. The closest\ninteger value is 2, which leads to a 50% witness discount.\n\nThe Bitcoinj source code is available for anyone to review. I encourage\nanyone to re-compute this with another utility to cross-check. Maybe\nAntoine Le Calvez (p2sh.info) would like to double-check.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/aaeb7ba1/attachment.html>"
            },
            {
                "author": "Alphonse Pace",
                "date": "2017-05-08T23:47:32",
                "message_text_only": "Sergio,\n\nI'm not sure what the data you present has to do with the discount.  A 75%\ndiscount prevents witness spam precisely because it is 75%, nothing more.\nThe current usage simply gives a guideline on how much capacity is gained\nthrough a particular discount.  With the data you show, it would imply that\nthose blocks, with SegWit used where possible, would result in blocks of\n~1.8MB.\n\n\n\nOn Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have processed 1000 blocks starting from Block #461653.\n>\n> I computed several metrics, including the supposed size of witness data\n> and non-witness data (onchain), assuming all P2SH inputs/outputs are\n> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.\n>\n> This takes into account that other types of transactions will not be\n> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't\n> take into account that LN transactions may affect the current state,\n>  increasing the segwit/nosegwit ratio.\n>\n> Among a lot of information, I've got the following real world results...\n>\n> acMainChainSpace =352608924\n> acSegwitSpace =599400403\n> Ratio segwit/nosegwit=1.6999\n>\n> This implies that the 75% that discount is not the best option to prevent\n> witness spam in a block of 4 MB, as stated in https://segwit.org/why-a-\n> discount-factor-of-4-why-not-2-or-8-bbcebe91721e.\n>\n> The non-witness data weight factor should not be 4 but 2.35. The closest\n> integer value is 2, which leads to a 50% witness discount.\n>\n> The Bitcoinj source code is available for anyone to review. I encourage\n> anyone to re-compute this with another utility to cross-check. Maybe\n> Antoine Le Calvez (p2sh.info) would like to double-check.\n>\n>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/eda3ff72/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-09T13:49:05",
                "message_text_only": "This [1] article says the current discount prevents witness spam. Witness\nspam is free space in the witness part of the block that can be filled by\nminers to create bigger blocks with almost no cost for the benefit a\ncluster of miners with low latency, increasing centralization.\n\nThe 75% discount does not prevent it, but on the contrary leaves a lot of\nextra witness space for spam.\n\nIf the maximum block weight is set to 2.7M, each byte of non-witness block\ncosts 1.7, and each byte of witness costs 1, then a normal filled block\nwould be 2.7M bytes (1.7+1), and there will be no need to create ever a 4\nMbyte block. The worst case would be the average case, and the transaction\nrate would be the maximum possible.\n\nThe current 75% discount can only achieve more transactions per second if\nthe type of transactions change. Therefore the current 75% discount only\nmakes the block size worst case worse (4 Mbytes when it should be 2.7\nMbytes).\n\n80% of all inputs/outputs are P2PKH. The only way to make use of the extra\nwitness\nspace If most P2PKH transactions are replaced by multisigs (typically for\nLN).\n\nSo it seems the 75% discount has been chosen with the idea that in the\nfuture the current transaction pattern will shift towards multisigs. This\nis not a bad idea, as it's the only direction Bitcoin can scale without a\nHF.\nBut it's a bad idea if we end up doing, for example, a 2X blocksize\nincrease HF in the future. In that case it's much better to use a 50%\nwitness discount, and do not make scaling risky by making the worse case\nblock size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n\nI've uploaded the code here:\nhttps://github.com/SergioDemianLerner/SegwitStats\n\n [1] https://segwit.org/why-a-discount-factor-of-4-why-not-\n2-or-8-bbcebe91721e.\n\n\nOn Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Sergio,\n>\n> I'm not sure what the data you present has to do with the discount.  A 75%\n> discount prevents witness spam precisely because it is 75%, nothing more.\n> The current usage simply gives a guideline on how much capacity is gained\n> through a particular discount.  With the data you show, it would imply that\n> those blocks, with SegWit used where possible, would result in blocks of\n> ~1.8MB.\n>\n>\n>\n> On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I have processed 1000 blocks starting from Block #461653.\n>>\n>> I computed several metrics, including the supposed size of witness data\n>> and non-witness data (onchain), assuming all P2SH inputs/outputs are\n>> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.\n>>\n>> This takes into account that other types of transactions will not be\n>> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't\n>> take into account that LN transactions may affect the current state,\n>>  increasing the segwit/nosegwit ratio.\n>>\n>> Among a lot of information, I've got the following real world results...\n>>\n>> acMainChainSpace =352608924\n>> acSegwitSpace =599400403\n>> Ratio segwit/nosegwit=1.6999\n>>\n>> This implies that the 75% that discount is not the best option to prevent\n>> witness spam in a block of 4 MB, as stated in\n>> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e\n>> .\n>>\n>> The non-witness data weight factor should not be 4 but 2.35. The closest\n>> integer value is 2, which leads to a 50% witness discount.\n>>\n>> The Bitcoinj source code is available for anyone to review. I encourage\n>> anyone to re-compute this with another utility to cross-check. Maybe\n>> Antoine Le Calvez (p2sh.info) would like to double-check.\n>>\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/38a4f95e/attachment.html>"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-09T14:33:34",
                "message_text_only": "The discount is designed to reduce UTXO bloat primarily, witness spam\ndata would not make it into the UTXO set. The discount brings the fee\nof a transaction more in line with the actual costs to the network for\nthe transaction. A miner spamming the network with 4MB witness blocks\nwould have very little impact on the UTXO size compared with 1MB\nnon-witness blocks. UTXO size is a bigger issue than blockchain size\nsince full nodes can't prune the UTXO set.\n\nThe discount of 75% for the SegWit softfork doesn't really have any\neffect on future hard forks as it can always be adjusted as needed\nlater on as part of a HF.\n\nOn Tue, May 9, 2017 at 8:49 AM, Sergio Demian Lerner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> This [1] article says the current discount prevents witness spam. Witness\n> spam is free space in the witness part of the block that can be filled by\n> miners to create bigger blocks with almost no cost for the benefit a cluster\n> of miners with low latency, increasing centralization.\n>\n> The 75% discount does not prevent it, but on the contrary leaves a lot of\n> extra witness space for spam.\n>\n> If the maximum block weight is set to 2.7M, each byte of non-witness block\n> costs 1.7, and each byte of witness costs 1, then a normal filled block\n> would be 2.7M bytes (1.7+1), and there will be no need to create ever a 4\n> Mbyte block. The worst case would be the average case, and the transaction\n> rate would be the maximum possible.\n>\n> The current 75% discount can only achieve more transactions per second if\n> the type of transactions change. Therefore the current 75% discount only\n> makes the block size worst case worse (4 Mbytes when it should be 2.7\n> Mbytes).\n>\n> 80% of all inputs/outputs are P2PKH. The only way to make use of the extra\n> witness\n> space If most P2PKH transactions are replaced by multisigs (typically for\n> LN).\n>\n> So it seems the 75% discount has been chosen with the idea that in the\n> future the current transaction pattern will shift towards multisigs. This is\n> not a bad idea, as it's the only direction Bitcoin can scale without a HF.\n> But it's a bad idea if we end up doing, for example, a 2X blocksize increase\n> HF in the future. In that case it's much better to use a 50% witness\n> discount, and do not make scaling risky by making the worse case block size\n> 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n>\n> I've uploaded the code here:\n> https://github.com/SergioDemianLerner/SegwitStats\n>\n>  [1]\n> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.\n>\n>\n> On Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Sergio,\n>>\n>> I'm not sure what the data you present has to do with the discount.  A 75%\n>> discount prevents witness spam precisely because it is 75%, nothing more.\n>> The current usage simply gives a guideline on how much capacity is gained\n>> through a particular discount.  With the data you show, it would imply that\n>> those blocks, with SegWit used where possible, would result in blocks of\n>> ~1.8MB.\n>>\n>>\n>>\n>> On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> I have processed 1000 blocks starting from Block #461653.\n>>>\n>>> I computed several metrics, including the supposed size of witness data\n>>> and non-witness data (onchain), assuming all P2SH inputs/outputs are\n>>> converted to P2PWSH and all P2PKH inputs/outputs are converted to P2WPKH.\n>>>\n>>> This takes into account that other types of transactions will not be\n>>> modified by Segwit (e.g. OP_RETURN outputs, or P2PK). This analysis doesn't\n>>> take into account that LN transactions may affect the current state,\n>>> increasing the segwit/nosegwit ratio.\n>>>\n>>> Among a lot of information, I've got the following real world results...\n>>>\n>>> acMainChainSpace =352608924\n>>> acSegwitSpace =599400403\n>>> Ratio segwit/nosegwit=1.6999\n>>>\n>>> This implies that the 75% that discount is not the best option to prevent\n>>> witness spam in a block of 4 MB, as stated in\n>>> https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e.\n>>>\n>>> The non-witness data weight factor should not be 4 but 2.35. The closest\n>>> integer value is 2, which leads to a 50% witness discount.\n>>>\n>>> The Bitcoinj source code is available for anyone to review. I encourage\n>>> anyone to re-compute this with another utility to cross-check. Maybe Antoine\n>>> Le Calvez (p2sh.info) would like to double-check.\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-05-09T15:45:04",
                "message_text_only": "> On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \n> So it seems the 75% discount has been chosen with the idea that in the future the current transaction pattern will shift towards multisigs. This is not a bad idea, as it's the only direction Bitcoin can scale without a HF. \n> But it's a bad idea if we end up doing, for example, a 2X blocksize increase HF in the future. In that case it's much better to use a 50% witness discount, and do not make scaling risky by making the worse case block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n> \n\nAs we could change any parameter in a hardfork, I don\u2019t think this has any relation with the current BIP141 proposal. We could just use 75% in a softfork, and change that to a different value (or completely redefine the definition of weight) with a hardfork later."
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-09T16:19:13",
                "message_text_only": "Thanks Johnson and Hampus for the clarifications.\nHowever, I would rather do the opposite: soft-fork to 50% now, and\nsoft-fork again to 75% discount later if needed, because it doesn't affect\nthe max transactions/second.\n\nSegwit as it is today should be activated. However if it is not before\nNovember, then for the next Segwit attempt I would choose a more\nconservative 50% discount.\n\n\n\nOn Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk> wrote:\n\n>\n> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >\n> > So it seems the 75% discount has been chosen with the idea that in the\n> future the current transaction pattern will shift towards multisigs. This\n> is not a bad idea, as it's the only direction Bitcoin can scale without a\n> HF.\n> > But it's a bad idea if we end up doing, for example, a 2X blocksize\n> increase HF in the future. In that case it's much better to use a 50%\n> witness discount, and do not make scaling risky by making the worse case\n> block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n> >\n>\n> As we could change any parameter in a hardfork, I don\u2019t think this has any\n> relation with the current BIP141 proposal. We could just use 75% in a\n> softfork, and change that to a different value (or completely redefine the\n> definition of weight) with a hardfork later.\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/e01b3062/attachment-0001.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-05-09T16:27:40",
                "message_text_only": "No, changing from 50% to 75% is a hardfork. (75 -> 50 is a softfork). Unless you make it pre-scheduled, or leave a special \u201cbackdoor\u201d softfork to change the discount.\n\nAnd that would certainly reduce the max tx/s with 50% discount, also reduce the incentive to spend witness UTXO. \n\n> On 10 May 2017, at 00:19, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n> \n> Thanks Johnson and Hampus for the clarifications. \n> However, I would rather do the opposite: soft-fork to 50% now, and soft-fork again to 75% discount later if needed, because it doesn't affect the max transactions/second. \n> \n> Segwit as it is today should be activated. However if it is not before November, then for the next Segwit attempt I would choose a more conservative 50% discount.\n> \n> \n> \n> On Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk <mailto:jl2012 at xbt.hk>> wrote:\n> \n> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> >\n> >\n> > So it seems the 75% discount has been chosen with the idea that in the future the current transaction pattern will shift towards multisigs. This is not a bad idea, as it's the only direction Bitcoin can scale without a HF.\n> > But it's a bad idea if we end up doing, for example, a 2X blocksize increase HF in the future. In that case it's much better to use a 50% witness discount, and do not make scaling risky by making the worse case block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n> >\n> \n> As we could change any parameter in a hardfork, I don\u2019t think this has any relation with the current BIP141 proposal. We could just use 75% in a softfork, and change that to a different value (or completely redefine the definition of weight) with a hardfork later.\n> \n> \n> \n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/7cb9f0fc/attachment.html>"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-09T16:27:59",
                "message_text_only": "Doing a second soft-fork from 50% to 75% sounds more difficult since\nthat's going from a more restrictive ruleset to less restrictive, you\nmight be able to hack around it but it wouldn't be a fully backwards\ncompatible change like going from 75% to 50% would be. 50% vs 75% does\naffect max transactions/second in practice, the exact amount depends\non the real world usage of course though.\n\nOn Tue, May 9, 2017 at 11:19 AM, Sergio Demian Lerner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Thanks Johnson and Hampus for the clarifications.\n> However, I would rather do the opposite: soft-fork to 50% now, and soft-fork\n> again to 75% discount later if needed, because it doesn't affect the max\n> transactions/second.\n>\n> Segwit as it is today should be activated. However if it is not before\n> November, then for the next Segwit attempt I would choose a more\n> conservative 50% discount.\n>\n>\n>\n> On Tue, May 9, 2017 at 12:45 PM, Johnson Lau <jl2012 at xbt.hk> wrote:\n>>\n>>\n>> > On 9 May 2017, at 21:49, Sergio Demian Lerner via bitcoin-dev\n>> > <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >\n>> >\n>> > So it seems the 75% discount has been chosen with the idea that in the\n>> > future the current transaction pattern will shift towards multisigs. This is\n>> > not a bad idea, as it's the only direction Bitcoin can scale without a HF.\n>> > But it's a bad idea if we end up doing, for example, a 2X blocksize\n>> > increase HF in the future. In that case it's much better to use a 50%\n>> > witness discount, and do not make scaling risky by making the worse case\n>> > block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n>> >\n>>\n>> As we could change any parameter in a hardfork, I don\u2019t think this has any\n>> relation with the current BIP141 proposal. We could just use 75% in a\n>> softfork, and change that to a different value (or completely redefine the\n>> definition of weight) with a hardfork later.\n>>\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-09T18:15:45",
                "message_text_only": "I'm not sure who wrote segwit.org, but I wouldn't take it as\nauthoritative reasoning why we must do X over Y.\n\nYou seem to be claiming that there is not cost for a miner to fill\n\"extra witness space\", but this is very untrue - in order to do so they\nmust forgo fees on other transactions. Your analysis on worst-case vs\nnormal-case blocks also seems flawed - there is a single limit, and not\na separate, secondary, witness limit.\n\nYou suggested \"If the maximum block weight is set to 2.7M, each byte of\nnon-witness block costs 1.7\", but these numbers dont work out - setting\nthe discount to 1.7 gets you a maximum block size of 1.7MB (in a soft\nfork), not 2.7MB. If you set the max block weight to 2.7 with a 1.7x\ndiscount, you have a hard fork. If you set the discount to 2.7x with a\n2.7 weight limit, you dont get 2.7MB average-sized blocks, but smaller,\nand still have the potential for padding blocks with pure-witness data\nto create larger blocks.\n\nAdditionally, note that by padding blocks with larger witness data you\nlose some of the CPU cost to validate as you no longer have as many\ninputs (which have a maximal validation cost).\n\nFurther, I'm not sure why you're arguing for a given witness discount on\nthe basis of a future hardfork - it seems highly unlikely the community\nis in a position to pull something like that off, and even if it were,\nwhy set the witness discount with that assumption? If there were to be a\nhardfork, we should probably tweak a bunch of parameters (see, eg, my\npost from February of last year at\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012403.html).\n\nMaybe you could clarify your proposal a bit here, because the way I read\nit you seem to have misunderstood SegWit's discount system.\n\nOn 05/09/17 13:49, Sergio Demian Lerner via bitcoin-dev wrote:\n> This [1] article says the current discount prevents witness spam.\n> Witness spam is free space in the witness part of the block that can be\n> filled by miners to create bigger blocks with almost no cost for the\n> benefit a cluster of miners with low latency, increasing centralization.\n> \n> The 75% discount does not prevent it, but on the contrary leaves a lot\n> of extra witness space for spam.\n> \n> If the maximum block weight is set to 2.7M, each byte of non-witness\n> block costs 1.7, and each byte of witness costs 1, then a normal filled\n> block would be 2.7M bytes (1.7+1), and there will be no need to create\n> ever a 4 Mbyte block. The worst case would be the average case, and the\n> transaction rate would be the maximum possible.\n> \n> The current 75% discount can only achieve more transactions per second\n> if the type of transactions change. Therefore the current 75% discount\n> only makes the block size worst case worse (4 Mbytes when it should be\n> 2.7 Mbytes).\n> \n> 80% of all inputs/outputs are P2PKH. The only way to make use of the\n> extra witness \n> space If most P2PKH transactions are replaced by multisigs (typically\n> for LN).\n> \n> So it seems the 75% discount has been chosen with the idea that in the\n> future the current transaction pattern will shift towards multisigs.\n> This is not a bad idea, as it's the only direction Bitcoin can scale\n> without a HF. \n> But it's a bad idea if we end up doing, for example, a 2X blocksize\n> increase HF in the future. In that case it's much better to use a 50%\n> witness discount, and do not make scaling risky by making the worse case\n> block size 8 Mbytes, when it could have been 2*2.7=5.4 Mbytes.\n> \n> I've uploaded the code here:\n> https://github.com/SergioDemianLerner/SegwitStats\n> \n>  [1] https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e\n> <https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e>.\n> \n> \n> On Mon, May 8, 2017 at 8:47 PM, Alphonse Pace via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>     Sergio,\n> \n>     I'm not sure what the data you present has to do with the discount. \n>     A 75% discount prevents witness spam precisely because it is 75%,\n>     nothing more.  The current usage simply gives a guideline on how\n>     much capacity is gained through a particular discount.  With the\n>     data you show, it would imply that those blocks, with SegWit used\n>     where possible, would result in blocks of ~1.8MB.\n> \n> \n> \n>     On Mon, May 8, 2017 at 5:42 PM, Sergio Demian Lerner via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> \n>         I have processed 1000 blocks starting from Block #461653.\n> \n>         I computed several metrics, including the supposed size of\n>         witness data and non-witness data (onchain), assuming all P2SH\n>         inputs/outputs are converted to P2PWSH and all P2PKH\n>         inputs/outputs are converted to P2WPKH.\n> \n>         This takes into account that other types of transactions will\n>         not be modified by Segwit (e.g. OP_RETURN outputs, or P2PK).\n>         This analysis doesn't take into account that LN transactions may\n>         affect the current state,  increasing the segwit/nosegwit ratio.\n> \n>         Among a lot of information, I've got the following real world\n>         results...\n> \n>         acMainChainSpace =352608924\n>         acSegwitSpace =599400403\n>         Ratio segwit/nosegwit=1.6999\n> \n>         This implies that the 75% that discount is not the best option\n>         to prevent witness spam in a block of 4 MB, as stated in\n>         https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e\n>         <https://segwit.org/why-a-discount-factor-of-4-why-not-2-or-8-bbcebe91721e>.\n> \n>         The non-witness data weight factor should not be 4 but 2.35. The\n>         closest integer value is 2, which leads to a 50% witness discount.\n> \n>         The Bitcoinj source code is available for anyone to review. I\n>         encourage anyone to re-compute this with another utility to\n>         cross-check. Maybe Antoine Le Calvez (p2sh.info\n>         <http://p2sh.info>) would like to double-check.\n> \n> \n> \n> \n> \n> \n>         _______________________________________________\n>         bitcoin-dev mailing list\n>         bitcoin-dev at lists.linuxfoundation.org\n>         <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n> \n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n> \n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-09T18:58:25",
                "message_text_only": ">\n>\n>\n> You suggested \"If the maximum block weight is set to 2.7M, each byte of\n> non-witness block costs 1.7\", but these numbers dont work out - setting\n> the discount to 1.7 gets you a maximum block size of 1.7MB (in a soft\n> fork), not 2.7MB.\n\n\nYes. In a soft-fork is true.\nI was thinking about what a HF could do to optimize the balance, and I\nforgot I was in the context of a SF.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/473e88df/attachment.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-09T19:15:32",
                "message_text_only": "Let n be the non-segwit bytes. Let the seg/noseg ratio be 1.7.\n\nSegwit with 75% discount: (let WITNESS_SCALE_FACTOR=4)\nn*WITNESS_SCALE_FACTOR+n*1.7 = 4,000,000\nThen n=4,000,000 / 5.7 = 701K\nAverage block size = 701K*(1+1.7)=1.8 Mbytes\nMaximum block size = 4 MBytes\n\nSegwit with 50% discount + 2MB HF: (let WITNESS_SCALE_FACTOR=2)\nn*2+n*1.7 = 4,000,000\nn = 4,000,000/ 3.7 = 1.08M\nAverage block size = 1.08M*(1+1.7)=2.9 Mbytes\nMaximum block size = 4 MBytes\n\nThe capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum\nblock size is the same.\n\n\nOn Tue, May 9, 2017 at 3:58 PM, Sergio Demian Lerner <\nsergio.d.lerner at gmail.com> wrote:\n\n>\n>>\n>> You suggested \"If the maximum block weight is set to 2.7M, each byte of\n>> non-witness block costs 1.7\", but these numbers dont work out - setting\n>> the discount to 1.7 gets you a maximum block size of 1.7MB (in a soft\n>> fork), not 2.7MB.\n>\n>\n> Yes. In a soft-fork is true.\n> I was thinking about what a HF could do to optimize the balance, and I\n> forgot I was in the context of a SF.\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/4a3d4465/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-09T19:30:52",
                "message_text_only": "On Tue, May 9, 2017 at 7:15 PM, Sergio Demian Lerner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> The capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum\n> block size is the same.\n\nAnd the UTXO bloat potential is twice as large and the cost of that\nUTXO bloat is significantly reduced.  So you're basically gutting the\nmost of the gain from weight, making something incompatible, etc.\n\nI'm not sure what to explain-- even that page on segwit.org explains\nthat the values are selected to balance worst case costs not to\noptimize one to the total exclusion of others. Raw size is not very\nrelevant in the long run, but if your goal were to optimize for it\n(which it seems to be), then the limit should be pure size."
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-09T19:42:56",
                "message_text_only": "There is something in between throwing the SegWit goals out the window\n(as Sergio seems to be advocating for) and having a higher discount\nratio (which is required for the soft fork version to be useful).\n\nWhen I first started looking at the problem I very much wanted to reduce\nthe worst-case block size (though have come around to caring a bit less\nabout that thanks to all the work in FIBRE and other similar systems\nover the past year or two), but rapidly realized that just reducing the\nSegwit discount wasn't really the right solution here.\n\nYou might as well take the real win and reduce the cost of the input\nprevout itself so that average inputs are less expensive than outputs\n(which SegWit doesn't quite achieve due to the large prevout size - 40\nbytes). This way you can reduce the discount, still get the SegWit goal,\nand get a lower ratio between worst-case and average-case block size,\nthough, frankly, I'm less interested in the last one these days, at\nleast for reasonable parameters. If you're gonna look at hard forks,\nlimiting yourself to just the parameters that we can tweak in a soft\nfork seems short-sighted, at beast.\n\nMatt\n\nOn 05/09/17 19:30, Gregory Maxwell wrote:\n> On Tue, May 9, 2017 at 7:15 PM, Sergio Demian Lerner via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> The capacity of Segwit(50%)+2MbHF is 50% more than Segwit, and the maximum\n>> block size is the same.\n> \n> And the UTXO bloat potential is twice as large and the cost of that\n> UTXO bloat is significantly reduced.  So you're basically gutting the\n> most of the gain from weight, making something incompatible, etc.\n> \n> I'm not sure what to explain-- even that page on segwit.org explains\n> that the values are selected to balance worst case costs not to\n> optimize one to the total exclusion of others. Raw size is not very\n> relevant in the long run, but if your goal were to optimize for it\n> (which it seems to be), then the limit should be pure size.\n>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-09T20:13:14",
                "message_text_only": "On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n> at beast.\n\nRawr."
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-09T20:58:35",
                "message_text_only": "I agree with you Matt.\nI'm artificially limiting myself to changing the parameters of Segwit as it\nis..\n\nThis is motivated by the idea that a consensual HF in the current state\nwould have greater chance of acceptance if it changes the minimum number of\nlines of code.\n\n\n\nOn Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org> wrote:\n\n> On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com>\n> wrote:\n> > at beast.\n>\n> Rawr.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/d8ac393a/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-10T05:37:33",
                "message_text_only": "If there's a better factor than 0.25 I would change it now before deploying\nsegwit instead of leaving it to be changed later with a hf.\n\nOn 9 May 2017 10:59 pm, \"Sergio Demian Lerner via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I agree with you Matt.\n> I'm artificially limiting myself to changing the parameters of Segwit as\n> it is..\n>\n> This is motivated by the idea that a consensual HF in the current state\n> would have greater chance of acceptance if it changes the minimum number of\n> lines of code.\n>\n>\n>\n> On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org> wrote:\n>\n>> On Tue, May 9, 2017 at 7:42 PM, Matt Corallo <lf-lists at mattcorallo.com>\n>> wrote:\n>> > at beast.\n>>\n>> Rawr.\n>>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/2a5e2c51/attachment-0001.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-10T14:05:30",
                "message_text_only": "I'm highly unconvinced of this point. Sure, you can change fewer lines\nof code, but if the result is, lets be honest, shit, how do you believe\nits going to have a higher chance of getting acceptance from the broader\ncommunity? I think you're over-optimizing in the wrong direction.\n\nMatt\n\nOn 05/09/17 20:58, Sergio Demian Lerner wrote:\n> I agree with you Matt. \n> I'm artificially limiting myself to changing the parameters of Segwit as\n> it is.. \n> \n> This is motivated by the idea that a consensual HF in the current state\n> would have greater chance of acceptance if it changes the minimum number\n> of lines of code.\n> \n> \n> \n> On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org\n> <mailto:greg at xiph.org>> wrote:\n> \n>     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo\n>     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n>     > at beast.\n> \n>     Rawr.\n> \n>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-10T15:25:27",
                "message_text_only": "Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It has\nalways been good enough. And at the beginning it was quite simple. Simple\nenough it allowed gradual improvements that anyone with some technical\nbackground could understand. Now we need a full website to explain an\nimprovement.\nBut this is becoming more and more out of topic.\n\n\nOn Wed, May 10, 2017 at 11:05 AM, Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> I'm highly unconvinced of this point. Sure, you can change fewer lines\n> of code, but if the result is, lets be honest, shit, how do you believe\n> its going to have a higher chance of getting acceptance from the broader\n> community? I think you're over-optimizing in the wrong direction.\n>\n> Matt\n>\n> On 05/09/17 20:58, Sergio Demian Lerner wrote:\n> > I agree with you Matt.\n> > I'm artificially limiting myself to changing the parameters of Segwit as\n> > it is..\n> >\n> > This is motivated by the idea that a consensual HF in the current state\n> > would have greater chance of acceptance if it changes the minimum number\n> > of lines of code.\n> >\n> >\n> >\n> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org\n> > <mailto:greg at xiph.org>> wrote:\n> >\n> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo\n> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>> wrote:\n> >     > at beast.\n> >\n> >     Rawr.\n> >\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/6ecb8e46/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-10T16:39:00",
                "message_text_only": "I highly disagree about the \"not shit\" part.  You're advocating for throwing away one of the key features of Segwit, something that is very important for Bitcoin's long-term reliability! If you think doing so is going to somehow help get support in a divided community, I don't understand how - more likely you're only going to make things significantly worse.\n\nOn May 10, 2017 11:25:27 AM EDT, Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:\n>Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It\n>has\n>always been good enough. And at the beginning it was quite simple.\n>Simple\n>enough it allowed gradual improvements that anyone with some technical\n>background could understand. Now we need a full website to explain an\n>improvement.\n>But this is becoming more and more out of topic.\n>\n>\n>On Wed, May 10, 2017 at 11:05 AM, Matt Corallo\n><lf-lists at mattcorallo.com>\n>wrote:\n>\n>> I'm highly unconvinced of this point. Sure, you can change fewer\n>lines\n>> of code, but if the result is, lets be honest, shit, how do you\n>believe\n>> its going to have a higher chance of getting acceptance from the\n>broader\n>> community? I think you're over-optimizing in the wrong direction.\n>>\n>> Matt\n>>\n>> On 05/09/17 20:58, Sergio Demian Lerner wrote:\n>> > I agree with you Matt.\n>> > I'm artificially limiting myself to changing the parameters of\n>Segwit as\n>> > it is..\n>> >\n>> > This is motivated by the idea that a consensual HF in the current\n>state\n>> > would have greater chance of acceptance if it changes the minimum\n>number\n>> > of lines of code.\n>> >\n>> >\n>> >\n>> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org\n>> > <mailto:greg at xiph.org>> wrote:\n>> >\n>> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo\n>> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>>\n>wrote:\n>> >     > at beast.\n>> >\n>> >     Rawr.\n>> >\n>> >\n>>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2017-05-10T19:40:12",
                "message_text_only": "I'm not advocating. I'm mediating.\n\n\nThis is out of\n\nOn Wed, May 10, 2017 at 1:39 PM, Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> I highly disagree about the \"not shit\" part.  You're advocating for\n> throwing away one of the key features of Segwit, something that is very\n> important for Bitcoin's long-term reliability! If you think doing so is\n> going to somehow help get support in a divided community, I don't\n> understand how - more likely you're only going to make things significantly\n> worse.\n>\n> On May 10, 2017 11:25:27 AM EDT, Sergio Demian Lerner <\n> sergio.d.lerner at gmail.com> wrote:\n> >Jaja. But no shit. Not perfect maybe, but Bitcoin was never perfect. It\n> >has\n> >always been good enough. And at the beginning it was quite simple.\n> >Simple\n> >enough it allowed gradual improvements that anyone with some technical\n> >background could understand. Now we need a full website to explain an\n> >improvement.\n> >But this is becoming more and more out of topic.\n> >\n> >\n> >On Wed, May 10, 2017 at 11:05 AM, Matt Corallo\n> ><lf-lists at mattcorallo.com>\n> >wrote:\n> >\n> >> I'm highly unconvinced of this point. Sure, you can change fewer\n> >lines\n> >> of code, but if the result is, lets be honest, shit, how do you\n> >believe\n> >> its going to have a higher chance of getting acceptance from the\n> >broader\n> >> community? I think you're over-optimizing in the wrong direction.\n> >>\n> >> Matt\n> >>\n> >> On 05/09/17 20:58, Sergio Demian Lerner wrote:\n> >> > I agree with you Matt.\n> >> > I'm artificially limiting myself to changing the parameters of\n> >Segwit as\n> >> > it is..\n> >> >\n> >> > This is motivated by the idea that a consensual HF in the current\n> >state\n> >> > would have greater chance of acceptance if it changes the minimum\n> >number\n> >> > of lines of code.\n> >> >\n> >> >\n> >> >\n> >> > On Tue, May 9, 2017 at 5:13 PM, Gregory Maxwell <greg at xiph.org\n> >> > <mailto:greg at xiph.org>> wrote:\n> >> >\n> >> >     On Tue, May 9, 2017 at 7:42 PM, Matt Corallo\n> >> >     <lf-lists at mattcorallo.com <mailto:lf-lists at mattcorallo.com>>\n> >wrote:\n> >> >     > at beast.\n> >> >\n> >> >     Rawr.\n> >> >\n> >> >\n> >>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/cb1623ce/attachment-0001.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-08T23:56:49",
                "message_text_only": "On Mon, May 8, 2017 at 10:42 PM, Sergio Demian Lerner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> The non-witness data weight factor should not be 4 but 2.35. The closest\n> integer value is 2, which leads to a 50% witness discount.\n\nSergio, You've provided absolutely no information to qualify your\n\"should be\".  It sounds like you are only measuring how much data is\nwitness vs non-witness while completely ignoring the relative cost of\nUTXO bloat?  It's perfectly acceptable to increase the worst case in\none dimension while decreasing it in another-- and thats what segwit\ndoes.\n\nThis sounds like a misunderstanding of what the factors should have\naccomplish. The non-witness factor should be as large as possible\nbecause the prunable witness data has little to no long term cost to\nthe system, no cost to lite clients, etc-- as eventually the system's\nsurvival will require transitioning to starting from a state snapshot.\nBut it cannot be too large because of the hyperbolic increase in worst\ncase bandwidth.   Also, when starting from a state snapshot security\nwill require starting from an old one-- otherwise the whole system\nbecomes much closer to SPV security, so the cost of witness data\nbetween there and the tip will still matter.\n\nIf I had any leaning to adjust it, it would be towards five-- not\ntowards even lower values.\n\n> The Bitcoinj source code is available for anyone to review.\n\nWhere is it? (I have to say, I haven't found bitcoinj based things at\nall readable but it would be worth seeing.)"
            }
        ],
        "thread_summary": {
            "title": "Some real-world results about the current Segwit Discount",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "James Hilliard",
                "Alphonse Pace",
                "Sergio Demian Lerner",
                "Jorge Tim\u00f3n",
                "Gregory Maxwell",
                "Matt Corallo"
            ],
            "messages_count": 21,
            "total_messages_chars_count": 41315
        }
    },
    {
        "title": "[bitcoin-dev] Extension block proposal by Jeffrey et al",
        "thread_messages": [
            {
                "author": "Christopher Jeffrey",
                "date": "2017-05-09T00:56:59",
                "message_text_only": "Johnson,\n\nYeah, I do still see the issue. I think there are still some reasonable\nways to mitigate it.\n\nI've started revising the extension block specification/code to coexist\nwith mainchain segwit. I think the benefit of this is that we can\nrequire exiting outputs to only be witness programs. Presumably segwit\nwallets will be more likely to be aware of a new output maturity rule\n(I've opened a PR[1] which describes this in greater detail). I think\nthis probably reduces the likelihood of the legacy wallet issue,\nassuming most segwit-supporting wallets would implement this rule before\nthe activation of segwit.\n\nWhat's your opinion on whether this would have a great enough effect to\nprevent the legacy wallet issue? I think switching to witness programs\nonly may be a good balance between fungibility and backward-compat,\nprobably better all around than creating a whole new\naddr-type/wit-program just for exits.\n\n[1] https://github.com/tothemoon-org/extension-blocks/pull/16\n\nOn Mon, Apr 10, 2017 at 06:14:36PM +0800, Johnson Lau wrote:\n>\n> > On 6 Apr 2017, at 01:43, Christopher Jeffrey <chjj at purse.io> wrote:\n> >\n> >\n> >> This hits the biggest question I asked in my January post: do you want\n> >> to allow direct exit payment to legacy addresses? As a block reorg\n> >> will almost guarantee changing txid of the resolution tx, that will\n> >> permanently invalidate all the child txs based on the resolution tx.\n> >> This is a significant change to the current tx model. To fix this, you\n> >> need to make exit outputs unspendable for up to 100 blocks. Doing\n> >> this, however, will make legacy wallet users very confused as they do\n> >> not anticipate funding being locked up for a long period of time. So\n> >> you can\u2019t let the money sent back to a legacy address directly, but\n> >> sent to a new format address that only recognized by new wallet, which\n> >> understands the lock up requirement. This way, however, introduces\n> >> friction and some fungibility issues, and I\u2019d expect people using\n> >> cross chain atomic swap to exchange bitcoin and xbitcoin\n> >\n> > Yes, this issue is probably the biggest edge case in the proposal.\n> >\n> > I think there's two possible solutions:\n> >\n> > First solution:\n> >\n> > Like you said, add a maturity requirement for exiting outputs. Likely\n> > lower than coinbase's 100 block requirement. To solve the issue of\n> > non-upgraded wallets not being aware of this rule and spending early,\n> > have upgraded mempool implementations accept/relay txs that contain\n> > early spends of exits, but not mine them until they are mature. This way\n> > non-upgraded wallets do not end up broadcasting transactions that are\n> > considered invalid to the rest of the network.\n>\n> This won\u2019t solve the problem. Think about the following conversation:\n>\n> Alice (not upgraded): Please pay 1 BTC to my address 1ALicExyz\n> Bob (upgraded): ok, paid, please check\n>\n> 10 minutes later\n>\n> Alice: received and confirmed, thanks!\n>\n> 5 minutes later:\n>\n> Carol (not upgraded): Please pay 0.5BTC to my address 3CaroLXXX\n> Alice: paid, please check\n>\n> 1 hour later:\n>\n> Carol: it\u2019s not confirmed. Have you paid enough fees?\n> Alice: ok, I\u2019ll RBF/CPFP it\n>\n> 2 hours later:\n>\n> Carol: it\u2019s still not confirmed.\n> Alice: I have already paid double fees. Maybe the network is congested and I need to pay more\u2026..\n>\n> Repeat until the lock up period ends.\n>\n> So this so-called \u201csoftfork\u201d actually made non-upgraded wallet totally unusable. If failed to meet the very important requirement of a softfork: backward compatibility\n>\n> More discussion:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013985.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013985.html>\n>\n>\n> >\n> > Depending on how wallets handle reorgs, a non-upgraded wallet may put\n> > reorg'd spend chains from exits back into an unconfirmed state, when in\n> > reality they should probably delete them or mark them conflicted in some\n> > way. This may be an acceptable compromise as the wallet will still see\n> > the funds as unconfirmed when they really don't exist anymore, but maybe\n> > unconfirmed is good enough. Users are pretty used to dropping\n> > non-confirming txs from their wallet, and this is much better than\n> > legacy wallets seeing there funds as confirmed when they could be\n> > permanently reorged out at any moment.\n> >\n> > Second solution:\n> >\n> > Move all exiting outputs to the coinbase. This will enforce a 100 block\n> > maturity requirement and non-upgraded wallets will be aware of this.\n>\n> This is also unacceptable.\n>\n> When someone says \"Please pay 1 BTC to my address 1ALicExyz\u201d, no one anticipates being paid by a coinbase output. Some exchanges like btc-e explicitly reject coinbase payment.\n>\n> Such deterioration in user experience is unacceptable. It basically forces everyone to upgrade, i.e. a hardfork with soft fork\u2019s skin\n>\n>\n>\n> >\n> > The first solution might require more implementation, but allows more\n> > flexibility with the maturity requirement. The second solution is\n> > possibly simpler, but sticks to a hard 100 block limit.\n> >\n> >> 1. Is it acceptable to have massive txid malleability and transaction\n> >> chain invalidation for every natural happening reorg?  Yes: the\n> >> current spec is ok; No: next question (I\u2019d say no)\n> >\n> > Answered above.\n> >\n> >> 2. Is locking up exit outputs the best way to deal with the problem?\n> >> (I tried really hard to find a better solution but failed)\n> >\n> > You've probably thought about this more than anyone, so I'd say yes, it\n> > may be the only way. Painful, but necessary.\n> >\n> >> 3. How long the lock-up period should be? Answer could be anywhere\n> >> from 1 to 100\n> >\n> > I imagine having something lower than 100 would be preferable to users,\n> > maybe somewhere in the 5 to 15 range. A 15 block reorg on mainnet is\n> > seriously unlikely unless something strange is happening. A 5 block\n> > reorg is still pretty unlikely, but possible. The coinbase solution only\n> > allows for 100 blocks though.\n> >\n> >> 4. With a lock-up period, should it allow direct exit to legacy\n> >> address? (I think it\u2019s ok if the lock-up is short, like 1-2 block. But\n> >> is that safe enough?)\n> >\n> > I think so. Adding a kind of special address probably creates more\n> > issues than it solves.\n>\n>\n> As I explained above, no legacy wallet would anticipate a lock up. If you want to make a softfork, all burden of incompatibility must be taken by the upgraded system. Only allow exit to a new address guarantees that only upgraded wallet will see the locked-up tx:\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013490.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013490.html>\n> >\n> >> 5. Due to the fungibility issues, it may need a new name for the\n> >> tokens in the ext-block\n> >\n> > I suppose the market will decide whether that's the case.\n> >\n> > It's worth noting, if segwit is not activated on the mainchain, it\n> > creates a much bigger incentive to use the extension block, and\n> > potentially ensures that users will have less of a reason to exit.\n> >\n>\n> I think it\u2019s unacceptable if malleability is not fixed in main chain, for 3 reasons:\n>\n> 1. a solution is *already* available and tested for > 1 year.\n>\n> 2. the deactivation design (which I think is an interesting idea) makes the ext block unsuitable for long-term storage of value.\n>\n> 3. LN over main chain allows instant exchange of main coin and xcoin without going through the ugly 2-way-peg process.\n>\n>\n>\n\n--\nChristopher Jeffrey (JJ) <chjjeffrey at gmail.com>\nCTO & Bitcoin Menace, purse.io\nhttps://github.com/chjj\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170508/6eb88054/attachment-0001.sig>"
            },
            {
                "author": "Johnson Lau",
                "date": "2017-05-09T17:56:28",
                "message_text_only": "To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.\n\nMainchain segwit is particularly important here, as that allows atomic swap between the bitcoin and xbitcoin. Only services with high liquidity (exchanges, payment processors) would need to occasionally settle between the chains.\n\n\n> On 9 May 2017, at 08:56, Christopher Jeffrey <chjj at purse.io> wrote:\n> \n> Johnson,\n> \n> Yeah, I do still see the issue. I think there are still some reasonable\n> ways to mitigate it.\n> \n> I've started revising the extension block specification/code to coexist\n> with mainchain segwit. I think the benefit of this is that we can\n> require exiting outputs to only be witness programs. Presumably segwit\n> wallets will be more likely to be aware of a new output maturity rule\n> (I've opened a PR[1] which describes this in greater detail). I think\n> this probably reduces the likelihood of the legacy wallet issue,\n> assuming most segwit-supporting wallets would implement this rule before\n> the activation of segwit.\n> \n> What's your opinion on whether this would have a great enough effect to\n> prevent the legacy wallet issue? I think switching to witness programs\n> only may be a good balance between fungibility and backward-compat,\n> probably better all around than creating a whole new\n> addr-type/wit-program just for exits.\n> \n> [1] https://github.com/tothemoon-org/extension-blocks/pull/16 <https://github.com/tothemoon-org/extension-blocks/pull/16>\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170510/5dfbf5ba/attachment-0001.html>"
            },
            {
                "author": "Christopher Jeffrey",
                "date": "2017-05-10T01:19:30",
                "message_text_only": "> To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.\n\nJohnson,\n\nI feel that's not as much of an issue with v0 witness programs. Segwit\nisn't activated yet, and segwit-capable wallets aren't as widely\ndeployed for production. Not to mention, they're all going to require\nfurther development anyway: the address serialization for witness\nprograms only became a BIP this week. No segwit wallets should ever be\nplanning to receive money to naked witness programs right now, since\naddresses are for it aren't even available.\n\nI think we have the benefit of timing here. The state of segwit wallet\ndevelopment incidentally creates a window of time where this maturity\nrule can be implemented.\n\nOn Wed, May 10, 2017 at 01:56:28AM +0800, Johnson Lau wrote:\n> To make it completely transparent to unupgraded wallets, the return outputs have to be sent to something that is non-standard today, i.e. not P2PK, P2PKH, P2SH, bare multi-sig, and (with BIP141) v0 P2WPKH and v0 P2WSH.\n>\n> Mainchain segwit is particularly important here, as that allows atomic swap between the bitcoin and xbitcoin. Only services with high liquidity (exchanges, payment processors) would need to occasionally settle between the chains.\n>\n>\n> > On 9 May 2017, at 08:56, Christopher Jeffrey <chjj at purse.io> wrote:\n> >\n> > Johnson,\n> >\n> > Yeah, I do still see the issue. I think there are still some reasonable\n> > ways to mitigate it.\n> >\n> > I've started revising the extension block specification/code to coexist\n> > with mainchain segwit. I think the benefit of this is that we can\n> > require exiting outputs to only be witness programs. Presumably segwit\n> > wallets will be more likely to be aware of a new output maturity rule\n> > (I've opened a PR[1] which describes this in greater detail). I think\n> > this probably reduces the likelihood of the legacy wallet issue,\n> > assuming most segwit-supporting wallets would implement this rule before\n> > the activation of segwit.\n> >\n> > What's your opinion on whether this would have a great enough effect to\n> > prevent the legacy wallet issue? I think switching to witness programs\n> > only may be a good balance between fungibility and backward-compat,\n> > probably better all around than creating a whole new\n> > addr-type/wit-program just for exits.\n> >\n> > [1] https://github.com/tothemoon-org/extension-blocks/pull/16 <https://github.com/tothemoon-org/extension-blocks/pull/16>\n> >\n>\n\n--\nChristopher Jeffrey (JJ) <chjjeffrey at gmail.com>\nCTO & Bitcoin Menace, purse.io\nhttps://github.com/chjj\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/2360432a/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Extension block proposal by Jeffrey et al",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Jeffrey",
                "Johnson Lau"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12725
        }
    },
    {
        "title": "[bitcoin-dev] Network-layer attacks",
        "thread_messages": [
            {
                "author": "Raystonn .",
                "date": "2017-05-09T16:09:09",
                "message_text_only": "This study was released last week, detailing some attacks at the network layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of the countermeasures discussed in the paper, the use of encryption to secure communications between nodes looks like low hanging fruit.\n\n\nRaystonn\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/6ad5633b/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2017-05-09T18:05:43",
                "message_text_only": "See https://github.com/bitcoin/bips/blob/master/bip-0150.mediawiki and\nhttps://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki\n\nOn Tue, May 9, 2017 at 12:09 PM, Raystonn . via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This study was released last week, detailing some attacks at the network\n> layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of the\n> countermeasures discussed in the paper, the use of encryption\n> to secure communications between nodes looks like low hanging fruit.\n>\n>\n> Raystonn\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170509/573def94/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-09T23:11:31",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn 05/09/2017 09:09 AM, Raystonn . via bitcoin-dev wrote:\n> This study was released last week, detailing some attacks at the\n> network layer: https://btc-hijack.ethz.ch/files/btc_hijack.pdf.  Of\n> the countermeasures discussed in the paper, the use of encryption \n> to secure communications between nodes looks like low hanging\n> fruit.\n\nI draw a very different conclusion.\n\nThe paper states:\n\n\u201cOur work underscores the importance of proposed modifications which\nargue for encrypting Bitcoin traffic or traffic exchanged among miners.\u201d\n\nThe phrase, \u201cencrypting ... traffic exchanged among miners,\u201d is not\nmerely about encryption, since if one cannot identify the peer as the\nintended miner it could just as well be an attacker. This is about\n(presumably encrypted) authenticated connections.\n\nIndeed, encryption of traffic among miners is referred to again here:\n\n\u201cFinally, an attacker cannot intercept (possibly encrypted) private\nconnections, corresponding to peering agreements between mining pools.\n- From the attacker\u2019s point of view, these connections can be treated as\nintra-pool connections and the corresponding pair of pools can be\nconsidered as one larger pool.\u201d\n\nSo the encryption-based defense for miners is to use authentication to\ncreate, \u201cone larger pool,\u201d consisting of, \u201cprivate connections.\u201d\n\nAdditionally it states, \u201cwe show that hijacking fewer than 100\nprefixes is enough to isolate a large amount of the mining power due\nto Bitcoin\u2019s centralization.\u201d\n\nIn other words the proposed solution, to what is largely a problem of\nminer centralization, is to create one miner. The paper doesn\u2019t\nattempt to investigate the downside to that apparent centralization\nspiral.\n\nThe paper investigates routing attacks on the p2p protocol,\nspecifically partitioning and delay. Regarding traffic encryption it\n*stresses* the caution:\n\n\u201cYet, we stress that not all routing attacks will be solved by such\nmeasures since attackers can still disrupt connectivity and isolate\nnodes by dropping Bitcoin packets instead of modifying them.\u201d\n\nIn other words it recognizes that encryption is both centralizing and\nineffective. Along these lines it also observes:\n\n* A smaller set of nodes will be easier to isolate for extended periods.\n* All incoming connection slots can be occupied by connections from\nattacker nodes.\n* Outgoing connections can be biased via a traditional eclipse attack.\n\nNotice that none of these issues are mitigated by encryption, since in\neach case the encrypted connection may just as easily be the attacker.\nThe presumed powerful attacker (one with the ability to modify\nInternet routing tables) is not deterred by encryption. Instead of\nmodifying or dropping packets he can simply redirect traffic to his\nown node(s) and carry on the attack on an encrypted connection with\nthe victim. As such all calls for encryption in the P2P protocol\nultimately end in calls for authentication.\n\nIt is true that if all connections are authenticated these attacks are\nmitigated. But as the \u201cone larger pool\u201d discussion shows, this is\nsimply a regression to a private network.\n\nAs for the two scenarios analyzed, the summary on delay attacks includes\n:\n\n* Delay attackers intercepting 50% of a node\u2019s connection can waste\n63% of its mining power.\n* Due to pools multi-homing, Bitcoin (as a whole) is not vulnerable to\ndelay attackers, even powerful ones.\n* Even a small degree of multi-homing is enough to protect Bitcoin\nfrom powerful attackers.\n\nFurthermore, the delay attack scenario explicitly relies on, \u201cthe fact\nthat a [Core] Bitcoin node waits for 20 minutes after having requested\na block from a peer before requesting it again from another peer.\u201d The\nwaste of mining power above is a function of that delay. So delay is\nnot a material concern for the entire network, and there are\nmitigations that hang much lower than making the network private.\n\nRegarding partitioning, clearly neither encryption nor authentication\ncan ensure that one is seeing the strongest chain unless the network\nis fully private (and trustworthy). The paper states, \u201cIncrease\npartition persistence: ... Intuitively, the attacker needs to suppress\nthe effect of churn in order to keep the victim nodes isolated.\u201d In\nother words, simply rotating connections is presumed to be effective.\n\nThere are other useful countermeasures listed in the paper:\n\n* Increase the diversity of node connections\n* Select Bitcoin peers while taking routing into account\n* Monitor round-trip time (RTT)\n* Monitor additional statistics\n* Embrace churn\n* Use gateways in different ASes\n* Prefer peers hosted in the same AS and in /24 prefixes\n* Use distinct control and data channels\n* Use UDP heartbeats\n* Request a block on multiple connections\n\nThe single recommendation that includes encryption is heavily qualified:\n\n* Encrypt Bitcoin Communication and/or adopt MAC\n\"While encrypting Bitcoin connections would not prevent adversaries\nfrom dropping packets, it would prevent them from eavesdropping\nconnections and modifying key messages. Alternatively, using a Message\nAuthentication Code (MAC) to validate that the content of each message\nhas not been changed would make delay attacks much more difficult.\"\n\nFirst, it should be widely understood that eavesdropping on the relay\nof public information is not an attack. Secondly, the paper clearly\nstates, \u201cattackers can still disrupt connectivity and isolate nodes by\ndropping Bitcoin packets instead of modifying them.\u201d So the\ndistinction between dropping and modifying messages is immaterial. And\nthirdly, the paper recognizes that eclipse attacks remain effective\nshort of authentication.\n\nTaken alongside the risk of centralization though the widespread use\nof authentication, which the paper does not contemplate, encryption is\nanything but low hanging fruit. Several of the other above mitigations\nare described as effective, and it is the case that some nodes already\nemploy some of them. Libbitcoin for example embraces churn by\nproviding both configurable and partially-randomized connection\ntimeout and a configurable block withholding timeout.\n\nThe paper is a valuable contribution in assessing risks to the P2P\nnetwork and individual nodes, and suggesting mitigations, but it is\nnot comprehensive. As with block size, the most obvious answer is not\nalways the right answer. Bitcoin is a public cache of independently\nverifiable information shared anonymously over a P2P network. The\nprimary threat is centralization. Authentication is a necessary aspect\nof centralizing the network.\n\ne\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZEkyWAAoJEDzYwH8LXOFOwW4H/2icvGAiKmSSI8+TtiI52hDC\nSouctpRXE/R0BSs1+KkSnj8c6nwNDqwpWWzKyDLVHT53FBk5cbUkUnTCev+MxZvm\nsrk63/nnI12/7RpEVoPVEiHXYd60hzNjN2Fod1ox+lN7Ln3nf22f+3ZP2evv8ETd\njZSnjVlOcnRrx/s67iE+n+IYPAtAENcxQhzZtGY1vLLgRrX7YbKlgjI8DNuSOgvZ\nVugTU3NeahUpGJQ5tvBWt0eHE0StzvcoCpts58Eozs4rnp7FWWDNYH9dtyzgqM6/\nqONC0MEHtO63PQ09DriHpAAUDw9xXCGOyv6aJ1TErzkJEXmkHn0QxUg/sYknL18=\n=jAkv\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Network-layer attacks",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Raystonn .",
                "Eric Voskuil",
                "Greg Sanders"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8437
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits",
        "thread_messages": [
            {
                "author": "Jonas Schnelli",
                "date": "2017-05-11T15:13:12",
                "message_text_only": "Hi\n\nCurrently, pruned peers have no way how to signal their (valuable) service.\nA BIP proposal to improve this (draft):\nhttps://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT <https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT>\n\nFeedback is highly welcome.\n\n</jonas>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/f520ab16/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/f520ab16/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-11T18:17:19",
                "message_text_only": "It probably should be stated in terms of what you're promising to do--\n 288 and 1152 blocks, not what we hope it will accomplish. Then advise\nclients to use peers with headroom because their estimates could be\nwrong and reorgs.\n\nReorgs aren't the only concerns that drive larger numbers:  The peak\nat syncing is at ~24 hours, but sometimes there are quite a few more\nthan 144 blocks in 24 hours. Also, new blocks show up in the chain:\nyou think you're 144 behind but by the time you connect you find\nyou're 146 behind from that peer's perspective.\n\nI think it's a bit ambiguous what it's saying about the headers,\nespecially because it goes into detail about address relay. I believe\nnodes with any of these settings should be willing to serve headers\nfor their entire best chain.  Perhaps you could say that this is\nequivalent to NODE_NETWORK except that they aren't necessarily willing\nto server historical blocks.\n\nI'm unsure about the third depth level. Perhaps that should be left\nundefined for sending right now and treated as least 1152 blocks by\nreceivers-- I don't have any reason to think 7056 is a particularly\nuseful choice, and we'll need another (longer) level for UTXO based\nsync.   You could probably go further and say that nodes shouldn't\nsend it now, but if sent it means they intend to keep 2016*2 blocks.\n(Not sending because the requirement for sending it may be that the\nnode is able to send you a UTXO data feed.)\n\n> consider to switch a low percentage\n\nThat isn't grammatical, you want \"switching\".  But I think it would be\nbetter to say that when a node believe it is in sync enough to use\nNODE_NETWORK_LIMITED_X it should just treat them identically to\nNODE_NETWORK in peer selection.   We don't really need any more\ntopology distortion than that.   In particular, I don't want to be in\na case where NODE_NETWORK peers suddenly find themselves far less well\nconnected.\n\nIn terms of making room, a node network peer could choose to\ndisconnect the least useful peers that aren't syncing from them to\nmake more room for ones that are.  This lets them decide what\nconnections they want, based on how full they are and what is useful\nto them, rather than finding themselves all lonely because nodes\ndecided to avoid them to be \"helpful\", and we already use\ndisconnections to manage fullness.\n\nOn Thu, May 11, 2017 at 3:13 PM, Jonas Schnelli via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi\n>\n> Currently, pruned peers have no way how to signal their (valuable) service.\n> A BIP proposal to improve this (draft):\n> https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT\n>\n> Feedback is highly welcome.\n>\n> </jonas>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-11T19:24:21",
                "message_text_only": "> A peer signaling NODE_NETWORK_LIMITED_LOW & NODE_NETWORK_LIMITED_HIGH MUST\n> be capable of serving at least the last 7'056 blocks (~49 days)\n> (NODE_NETWORK_LIMITED_HIGH's value ^2).\n\nIs 49 days particularly useful? Would it be a problem to instead leave both-\nbits undefined? I'm thinking this might be better as a way to indicate \"7 \ndays, plus a deterministically chosen set of historical blocks\"...\n\n> Current Bitcoin-Core pruned full nodes guarantees a minimum of 288 blocks,\n> thus allowing to signal NODE_NETWORK_LIMITED_LOW with the current minimum\n> configuration.\n\nThis is technically true right now, but as soon as segwit activates, it will \nno longer be... Therefore, I suggest striking it from the BIP, expounding on \nit in greater detail, or making it true for the longer term.\n\n> Peers following this BIP SHOULD connect a limited amount of their available\n> outbound connections to peers signaling one or both of the\n> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks\n> than the signaled number.\n\nThis isn't entirely clear whether it refers to peers downloading blocks, or \npeers serving them. (I assume the former, but it should be clarified.)\n\n> Light clients (and such) who are not checking the nServiceFlags (service\n> bits) from a relayed addr-message may unwillingly connect to a pruned peer\n> and ask for (filtered) blocks at a depth below their pruned depth.\n\nWouldn't this already be a problem, without the BIP?\n\nLuke"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2017-05-11T20:10:08",
                "message_text_only": "> Is 49 days particularly useful? Would it be a problem to instead leave both-\n> bits undefined? I'm thinking this might be better as a way to indicate \"7\n> days, plus a deterministically chosen set of historical blocks\"\u2026\n\nI though two service bits allow three states and we should define all three combinations.\nBut I guess an adequate \u201edefinition\u201c would be to reserve it for future \u201edefinitions\u201c.\nOr use Gregory's proposal of min 2016*2 blocks & keep it \u201eundefined\u201c for now.\n\n49 days was chosen to allow SPV peers to be \u201eoffline\u201c for a month and still be capable to catch-up with a peer pruned to a datadir of ~10GB.\n\n> \n> This is technically true right now, but as soon as segwit activates, it will\n> no longer be... Therefore, I suggest striking it from the BIP, expounding on\n> it in greater detail, or making it true for the longer term.\n\nAFAIK Core does also guaranteed the 288 blocks post segwit activation:\nhttps://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa62400893f4358c5ae/src/validation.h#L204\nBut maybe I\u2019m confused.\n\n> \n>> Peers following this BIP SHOULD connect a limited amount of their available\n>> outbound connections to peers signaling one or both of the\n>> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks\n>> than the signaled number.\n> \n> This isn't entirely clear whether it refers to peers downloading blocks, or\n> peers serving them. (I assume the former, but it should be clarified.)\n\nIndeed. I\u2019ll try to make that more clear.\n\n> \n>> Light clients (and such) who are not checking the nServiceFlags (service\n>> bits) from a relayed addr-message may unwillingly connect to a pruned peer\n>> and ask for (filtered) blocks at a depth below their pruned depth.\n> \n> Wouldn't this already be a problem, without the BIP?\n\nAFAIK, Core does currently only relay NODE_NETWORK addresses.\nBut yes, It may be a problem already.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/96f3a942/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2017-05-11T20:36:33",
                "message_text_only": "Sorry again, is this discussion really serious?\n\nIn this thread, previous ones or others, the level of approximation is\nobvious, often shadowed by useless maths/papers and strange calculations\nthat are not helping, at the end nobody knows what would happen \"if\",\nhow far the chain can roll back, etc\n\nThen don't make pruning the default if it's the current concern, pruning\nis of no use\n\nAgain, the priority should be to scale the full nodes\n\n\nLe 11/05/2017 \u00e0 22:10, Jonas Schnelli via bitcoin-dev a \u00e9crit :\n>> Is 49 days particularly useful? Would it be a problem to instead leave both-\n>> bits undefined? I'm thinking this might be better as a way to indicate \"7\n>> days, plus a deterministically chosen set of historical blocks\"\u2026\n> I though two service bits allow three states and we should define all three combinations.\n> But I guess an adequate \u201edefinition\u201c would be to reserve it for future \u201edefinitions\u201c.\n> Or use Gregory's proposal of min 2016*2 blocks & keep it \u201eundefined\u201c for now.\n>\n> 49 days was chosen to allow SPV peers to be \u201eoffline\u201c for a month and still be capable to catch-up with a peer pruned to a datadir of ~10GB.\n>\n>> This is technically true right now, but as soon as segwit activates, it will\n>> no longer be... Therefore, I suggest striking it from the BIP, expounding on\n>> it in greater detail, or making it true for the longer term.\n> AFAIK Core does also guaranteed the 288 blocks post segwit activation:\n> https://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa62400893f4358c5ae/src/validation.h#L204\n> But maybe I\u2019m confused.\n>\n>>> Peers following this BIP SHOULD connect a limited amount of their available\n>>> outbound connections to peers signaling one or both of the\n>>> NODE_NETWORK_LIMITED_* service bits if they expect to request less blocks\n>>> than the signaled number.\n>> This isn't entirely clear whether it refers to peers downloading blocks, or\n>> peers serving them. (I assume the former, but it should be clarified.)\n> Indeed. I\u2019ll try to make that more clear.\n>\n>>> Light clients (and such) who are not checking the nServiceFlags (service\n>>> bits) from a relayed addr-message may unwillingly connect to a pruned peer\n>>> and ask for (filtered) blocks at a depth below their pruned depth.\n>> Wouldn't this already be a problem, without the BIP?\n> AFAIK, Core does currently only relay NODE_NETWORK addresses.\n> But yes, It may be a problem already.\n>\n> </jonas>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170511/d4b6aaff/attachment-0001.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-11T21:05:09",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn 05/11/2017 01:36 PM, Aymeric Vitte via bitcoin-dev wrote:\n> Sorry again, is this discussion really serious?\n> \n> In this thread, previous ones or others, the level of approximation\n> is obvious, often shadowed by useless maths/papers and strange\n> calculations that are not helping, at the end nobody knows what\n> would happen \"if\", how far the chain can roll back, etc\n> \n> Then don't make pruning the default if it's the current concern,\n> pruning is of no use\n> \n> Again, the priority should be to scale the full nodes\n\nI agree. Every full node operator should (and likely would at some\npoint) simply never connect to, or relay the address of, any \"peer\"\nadvertising itself as diminished. Why on earth would a full node\noperator want to encourage shrinking support for bootstrapping and\ndeep reorgs, resulting in greater load for himself. That's a race to\nthe bottom.\n\nWe are literally talking about $7.50 for the *entire chain* with\nbreathing room. If someone wants to save a few dollars they are better\noff attempting to hide their pruning.\n\ne\n\n> Le 11/05/2017 \u00e0 22:10, Jonas Schnelli via bitcoin-dev a \u00e9crit :\n>>> Is 49 days particularly useful? Would it be a problem to\n>>> instead leave both- bits undefined? I'm thinking this might be\n>>> better as a way to indicate \"7 days, plus a deterministically\n>>> chosen set of historical blocks\"\u2026\n>> I though two service bits allow three states and we should define\n>> all three combinations. But I guess an adequate \u201edefinition\u201c\n>> would be to reserve it for future \u201edefinitions\u201c. Or use Gregory's\n>> proposal of min 2016*2 blocks & keep it \u201eundefined\u201c for now.\n>> \n>> 49 days was chosen to allow SPV peers to be \u201eoffline\u201c for a month\n>> and still be capable to catch-up with a peer pruned to a datadir\n>> of ~10GB.\n>> \n>>> This is technically true right now, but as soon as segwit\n>>> activates, it will no longer be... Therefore, I suggest\n>>> striking it from the BIP, expounding on it in greater detail,\n>>> or making it true for the longer term.\n>> AFAIK Core does also guaranteed the 288 blocks post segwit\n>> activation: \n>> https://github.com/bitcoin/bitcoin/blob/08a7316c144f9f2516db8fa624008\n93f4358c5ae/src/validation.h#L204\n>>\n>> \nBut maybe I\u2019m confused.\n>> \n>>>> Peers following this BIP SHOULD connect a limited amount of\n>>>> their available outbound connections to peers signaling one\n>>>> or both of the NODE_NETWORK_LIMITED_* service bits if they\n>>>> expect to request less blocks than the signaled number.\n>>> This isn't entirely clear whether it refers to peers\n>>> downloading blocks, or peers serving them. (I assume the\n>>> former, but it should be clarified.)\n>> Indeed. I\u2019ll try to make that more clear.\n>> \n>>>> Light clients (and such) who are not checking the\n>>>> nServiceFlags (service bits) from a relayed addr-message may\n>>>> unwillingly connect to a pruned peer and ask for (filtered)\n>>>> blocks at a depth below their pruned depth.\n>>> Wouldn't this already be a problem, without the BIP?\n>> AFAIK, Core does currently only relay NODE_NETWORK addresses. But\n>> yes, It may be a problem already.\n>> \n>> </jonas>\n>> \n>> \n>> \n>> _______________________________________________ bitcoin-dev\n>> mailing list bitcoin-dev at lists.linuxfoundation.org \n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> -- Zcash wallets made simple:\n> https://github.com/Ayms/zcash-wallets Bitcoin wallets made simple:\n> https://github.com/Ayms/bitcoin-wallets Get the torrent dynamic\n> blocklist: http://peersm.com/getblocklist Check the 10 M passwords\n> list: http://peersm.com/findmyass Anti-spies and private torrents,\n> dynamic blocklist: http://torrent-live.org Peersm :\n> http://www.peersm.com torrent-live:\n> https://github.com/Ayms/torrent-live node-Tor :\n> https://www.github.com/Ayms/node-Tor GitHub :\n> https://www.github.com/Ayms\n> \n> \n> \n> _______________________________________________ bitcoin-dev mailing\n> list bitcoin-dev at lists.linuxfoundation.org \n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZFNHtAAoJEDzYwH8LXOFOYRwH/0By+TNSgnV6m4c7g1ZrjboG\n8fZSeGaz7FXmAUZ69XMdQ1H+wlP0e4OAz9eRCcVqcn3K9OZJn++hbzI2K+zijyxZ\ncpQjg/2dcTc4B0Z3PZdnuZx5mnHzavr/1vPlgOYla7AbYqcKB5dkq/HqgD6tFsJP\nHXPClbEkVRF6UFP/7sDfzW8FMJycMSVcbEpuWAhcx2d+NusywWhbkuc5NiT9J1Ug\n/3OFhHVJtd+rDl2B4iRHXHOhysUGffvmmLANZpPMcOgplM6Xwv7nMT34FV4HCdgs\nGyxc9GSFsD6xsOshBRPICtEZe+IDDb0cnOLjDdAnUnKeolUljFY52djSa300Fp0=\n=REyc\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-12T02:22:15",
                "message_text_only": "On Thu, May 11, 2017 at 3:13 PM, Jonas Schnelli via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi\n>\n> Currently, pruned peers have no way how to signal their (valuable) service.\n> A BIP proposal to improve this (draft):\n> https://github.com/jonasschnelli/bips/wiki/NODE_NETWORK_LIMITED-BIP-DRAFT\n\nThe instructions for relay addresses should not instruct you to relay\nthese addresses but rather that you should relay addresses you would\nconnect to, under the generalized assumption that if it is useful to\nyou it will be useful to others.\n\nThis avoids instructing someone who might not consider\nnon-node-network peers useful from being directed by the BIP to relay\nthings that they don't find useful. (In particular, it means that the\nobvious implementation of just throwing out the 'useless' information\nworks fine.)  I think would better reflect what people are likely to\nactually do."
            }
        ],
        "thread_summary": {
            "title": "BIP proposal: NODE_NETWORK_LIMITED service bits",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Aymeric Vitte",
                "Luke Dashjr",
                "Gregory Maxwell",
                "Jonas Schnelli"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 16062
        }
    },
    {
        "title": "[bitcoin-dev] BIP: Block signal enforcement via tx fees",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2017-05-12T19:22:56",
                "message_text_only": "I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the community \nto put economic pressure on miners to deploy softforks without the extreme of \na UASF.\n\n    https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki\n\nDue to the potential for miners to maliciously block this softfork, it is \nsuggested that we deploy it using BIP 8 to ensure it eventually activates even \nif encountering hostility.\n\nThis is intended to be an alternative to BIP 8 in the long term.\nIt is NOT intended to make BIP 148 obsolete, given the timeframes involved.\n\nAn implementation is available (based on top of BIP 115's implementation):\n\n   https://github.com/luke-jr/bitcoin/compare/cbah...luke-jr:checkblockversion\n\nLuke"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-12T22:17:30",
                "message_text_only": "Good morning Luke,\n\nMinor editorial nitpick, this paragraph is repeated, maybe one of these should be Testnet?\n\nFor Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).\n\nFor Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/07779029/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-12T22:22:14",
                "message_text_only": "On Fri, May 12, 2017 at 07:22:56PM +0000, Luke Dashjr via bitcoin-dev wrote:\n> I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the community \n> to put economic pressure on miners to deploy softforks without the extreme of \n> a UASF.\n> \n>     https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki\n\nI strongly disagree with this proposal.\n\nnVersion signaling is already technically unenforceable, in the sense that we\ndon't have good ways of ensuring miners actually adopt the rules they're\nclaiming to signal. Equally, it's users who ultimately adopt rules, not miners,\nand attempting to pay miners to signal certain bits will further confuse this\npoint.\n\nQuite likely the outcome of users trying to anonymously pay anonymous miners to\nsignal certain bits will be the complete breakdown of the honesty of the\nnVersion signalling system, currently enforced only by \"gentlemans agreement\".\n\nA more productive direction would be a direct coin-owner signalling process,\nwith users taking action based on what provable coin-ownership has signalled.\n\n\nAlso, as an aside, this \"specification\" again shows the inadequacy and\nunreadability of English language specifications. I'd strongly suggest you\ndelete it and instead mark the \"reference implementation\" as the specification.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/ff3215fe/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-13T00:49:33",
                "message_text_only": "On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:\n> nVersion signaling is already technically unenforceable, in the sense that\n> we don't have good ways of ensuring miners actually adopt the rules\n> they're claiming to signal. Equally, it's users who ultimately adopt\n> rules, not miners, and attempting to pay miners to signal certain bits\n> will further confuse this point.\n\nThis BIP doesn't change that. Enforcement remains primarily by users.\n\n> Quite likely the outcome of users trying to anonymously pay anonymous\n> miners to signal certain bits will be the complete breakdown of the\n> honesty of the nVersion signalling system, currently enforced only by\n> \"gentlemans agreement\".\n\nYou assume users will pay for signalling of softforks prematurely. So long as \nit waits until deployment of the softfork is widespread, this risk is minimal. \nAt worst, it creates risks similar to a UASF. So long as UASF is the \nalternative, this way seems strictly better.\n\n> Also, as an aside, this \"specification\" again shows the inadequacy and\n> unreadability of English language specifications. I'd strongly suggest you\n> delete it and instead mark the \"reference implementation\" as the\n> specification.\n\nHow so?\n\nOn Friday 12 May 2017 10:17:30 PM ZmnSCPxj wrote:\n> Minor editorial nitpick, this paragraph is repeated, maybe one of these\n> should be Testnet?\n> \n> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch\n> timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).\n> \n> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD (Epoch\n> timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch timestamp TBD).\n\nFixed, thanks.\n\nLuke"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-13T03:26:08",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nIf people want to influence the decisions of miners, all they need to\ndo is mine.\n\nI do not see why any person would want to pay, and then trust, another\nto mine accordingly. Each person can mine and attain their level of\ninfluence. This not only avoids the side payment, but earns the person\nmoney.\n\nThere is nothing inherently wrong with paying people to run nodes or\nsignal \"readiness\", but there is no reason whatsoever to consider\nthese ideas beneficial from a personal/economic or\nsecurity/decentralization standpoint.\n\nIf you are not running a node you are not part of the economic\nconsensus. If you are not mining you have no say in transaction\nordering. The \"solution\" is both obvious and necessary to secure Bitcoin\n.\n\nIf a person does not want to bother then he/she clearly does not have\na strong opinion. As developers we should be focused on reducing the\ncomplexities of mining and of validation, not finding ways for people\nto avoid participating in these necessarily distributed roles.\n\ne\n\nOn 05/12/2017 05:49 PM, Luke Dashjr via bitcoin-dev wrote:\n> On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:\n>> nVersion signaling is already technically unenforceable, in the \n>> sense that we don't have good ways of ensuring miners actually \n>> adopt the rules they're claiming to signal. Equally, it's users \n>> who ultimately adopt rules, not miners, and attempting to pay \n>> miners to signal certain bits will further confuse this point.\n> \n> This BIP doesn't change that. Enforcement remains primarily by \n> users.\n> \n>> Quite likely the outcome of users trying to anonymously pay \n>> anonymous miners to signal certain bits will be the complete \n>> breakdown of the honesty of the nVersion signalling system, \n>> currently enforced only by \"gentlemans agreement\".\n> \n> You assume users will pay for signalling of softforks prematurely.\n>  So long as it waits until deployment of the softfork is \n> widespread, this risk is minimal. At worst, it creates risks \n> similar to a UASF. So long as UASF is the alternative, this way \n> seems strictly better.\n> \n>> Also, as an aside, this \"specification\" again shows the \n>> inadequacy and unreadability of English language specifications.\n>>  I'd strongly suggest you delete it and instead mark the \n>> \"reference implementation\" as the specification.\n> \n> How so?\n> \n> On Friday 12 May 2017 10:17:30 PM ZmnSCPxj wrote:\n>> Minor editorial nitpick, this paragraph is repeated, maybe one of\n>> these should be Testnet?\n>> \n>> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD \n>> (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch \n>> timestamp TBD).\n>> \n>> For Bitcoin '''mainnet''', the BIP8 '''starttime''' will be TBD \n>> (Epoch timestamp TBD) and BIP8 '''timeout''' will be TBD (Epoch \n>> timestamp TBD).\n> \n> Fixed, thanks.\n> \n> Luke _______________________________________________ bitcoin-dev \n> mailing list bitcoin-dev at lists.linuxfoundation.org \n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZFnzNAAoJEDzYwH8LXOFOlMsH/2Li7lDTr57EC2mSt4BuCf3Q\nQ1sx21CBumm6OQKMxd207wgXTaxVJVmrGPXfJ6ZW8Bf+2tMKgc/LsZfzXdEo5+Fx\niTkdgJeW8QbKiEGzOFKMxWXH9jyCnd0WcDnKw/v7WqUhYfy2c9wz9RzCMY5iJqph\nxd2+DeiEIjXIvE+l2TXGwjnB8Wp41QeY0I98kG3HHwNvNREbbGS/BjtLj5+eBygU\nm+6dxkJoEttms31F47WFoZRzN7u5pe3BY5kDfZdVkbG7MOomSYwlhMvR3PtA1wrz\nFeAUcHpp9MPj+qgHGwAGMfJiG/5WsVSrl/dJTm68zPOdwH60fMNNT/Srfbj1Ty8=\n=9Xik\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-13T03:54:50",
                "message_text_only": "Good morning,\n\n>I do not see why any person would want to pay, and then trust, another\n>to mine accordingly. Each person can mine and attain their level of\n>influence. This not only avoids the side payment, but earns the person\n>money.\n\nThe problem, is that, the rate of conversion of Bitcoin-> hashrate is different for different people.\n\nFor some, it's very cheap to convert Bitcoin -> hashrate. For others, it's very expensive. The reason, is the large difference in electricity rates depending on country.\n\nIt's all very well for those who can get electricity cheaply. But, for some, it is not.\n\nThus, paying someone with better Bitcoin->hashrate conversion via fees such as these is more economically logical, than to suffer a lower Bitcoin->hashrate conversion.\n\n>If a person does not want to bother then he/she clearly does not have\n>a strong opinion. As developers we should be focused on reducing the\n>complexities of mining and of validation, not finding ways for people\n>to avoid participating in these necessarily distributed roles.\n\nIt is also, very obviously, clear that you are operating under very strange assumptions, that all people are already equal somehow, or that someone who is paid x10 more is strictly superior, even though skill-wise and ability-wise, they are the same, and the one paid less is simply suffering due to the country where he or she is born in, through no fault of their own.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170512/2496484f/attachment.html>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-13T05:36:43",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn 05/12/2017 08:54 PM, ZmnSCPxj wrote:\n> Good morning,\n> \n>> I do not see why any person would want to pay, and then trust,\n>> another to mine accordingly. Each person can mine and attain\n>> their level of influence. This not only avoids the side payment,\n>> but earns the person money.\n> \n> The problem, is that, the rate of conversion of Bitcoin-> hashrate\n> is different for different people.\n> \n> For some, it's very cheap to convert Bitcoin -> hashrate.  For\n> others, it's very expensive.  The reason, is the large difference\n> in electricity rates depending on country.\n> \n> It's all very well for those who can get electricity cheaply.  But,\n> for some, it is not.\n> \n> Thus, paying someone with better Bitcoin->hashrate conversion via\n> fees such as these is more economically logical, than to suffer a\n> lower Bitcoin->hashrate conversion.\n\nDespite the tedious explanation of absolute advantage, this is simply\nan argument for all people to pay one person to mine, as there is\npresumably always one person who will be able to mine more efficiently\nthan all others.\n\nThe argument fails to recognize that mining for one's self may (or may\nnot) result in a net loss, but donating to a miner in the hope of some\naction is comparatively a total loss. One is an expense in exchange\nfor the intended social outcome, and the other is payment for\nrepresentative government.\n\nAnd in this form of representative government that you propose, if we\nassume that miners are somehow bound to honor the payments (votes),\nhow are the votes distributed? Is this supposed to be democratic in\nthe sense of one person one vote? Your argument below is clearly based\non that idea. However the result would be very different. The\nwealthier would of course exert the greater influence. So the idea\nfails by its own standard.\n\n>> If a person does not want to bother then he/she clearly does not\n>> have a strong opinion. As developers we should be focused on\n>> reducing the complexities of mining and of validation, not\n>> finding ways for people to avoid participating in these\n>> necessarily distributed roles.\n> \n> It is also, very obviously, clear that you are operating under\n> very strange assumptions, that all people are already equal\n> somehow, or that someone who is paid x10 more is strictly superior,\n> even though skill-wise and ability-wise, they are the same, and the\n> one paid less is simply suffering due to the country where he or\n> she is born in, through no fault of their own.\n\nYou are making a political argument wrapped in appeal to emotion. Both\nare pointless in this context.\n\ne\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZFptnAAoJEDzYwH8LXOFOs34IAIciCyrn7FMq7leiQ6jAvr3g\nsW9YRQ403IJd9BiBj3lI6xpsxtJ4zezkU2AFZUTf9X6AoIX/UJtPb8clb4RIpicf\nACK+iec4YM+15kgPcLyLij3aALvNNCNQ+XuXeHT1bHqfukP+bc/DBAnm48qGvW9o\nugRIFFWqtt8FB9MAh/VM6SsfaQc3D8hk6Dh3SyEVzohkrgWpRVQKNGD/FYY8odCA\n8KPo/R3jrgO6JNR0EGxR3SatuKLYUgMcl3n63fanAOh8ESHGHHiP0SEpYoG3wOCt\neAyEcPI4SezJHBjJWcsPe0hhLg0HkvFaLwQe8tGHXrCzsZ18QTNBA0h9npWqqi4=\n=LKcb\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-13T05:45:24",
                "message_text_only": "On Saturday 13 May 2017 3:26:08 AM Eric Voskuil wrote:\n> If people want to influence the decisions of miners, all they need to\n> do is mine.\n\nMost people cannot mine except at a huge expense (profit is limited to few \npeople via monopoly and electric costs). But more importantly, the profits \nfrom every miner you buy will go to pay for Bitmain growing their arsenal more \nthan enough to offset your influence.\n\nMining is simply broken at this point.\n\n> There is nothing inherently wrong with paying people to run nodes or\n> signal \"readiness\", but there is no reason whatsoever to consider\n> these ideas beneficial from a personal/economic or\n> security/decentralization standpoint.\n\nRunning a node and mining are two very different things.\n\n> The argument fails to recognize that mining for one's self may (or may\n> not) result in a net loss, but donating to a miner in the hope of some\n> action is comparatively a total loss. One is an expense in exchange\n> for the intended social outcome, and the other is payment for\n> representative government.\n> \n> And in this form of representative government that you propose, if we\n> assume that miners are somehow bound to honor the payments (votes), ...\n\nFirst of all, this isn't donating to miners, but forbidding them from mining \nyour transaction (and thereby collecting your transaction fee) unless they \nsignal for the softfork.\n\nSecondly, your argument here assumes miners are a government or control \nBitcoin in some way. This is not correct. Miners are entrusted with \nenforcement of softforks *for old nodes only*, and therefore given the ability \nto trigger activation of the new rules via signalling. But entrusting them \nwith this is NOT done by the system itself, but by the users, whose updated \nnodes are the primary mechanism for enforcing softforks. So miners are in fact \nalready bound to honour the wishes of the greater economy, and their refusal \nto do so is an attack on the network.\n\nLuke"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-13T06:43:59",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nOn 05/12/2017 10:45 PM, Luke Dashjr wrote:\n> On Saturday 13 May 2017 3:26:08 AM Eric Voskuil wrote:\n>> If people want to influence the decisions of miners, all they\n>> need to do is mine.\n> \n> Most people cannot mine except at a huge expense (profit is limited\n> to few people via monopoly and electric costs). But more\n> importantly, the profits from every miner you buy will go to pay\n> for Bitmain growing their arsenal more than enough to offset your\n> influence.\n\nYou seem to be suggesting that in order to decentralize mining nobody\nshould mine. I'm having a hard time making sense out of that.\n\n> Mining is simply broken at this point.\n\nSo maybe you are just saying that nobody should mine because it's a\nzero sum game that one miner will always win and therefore we should\nnot push up the hash rate by trying to compete because the same miner\njust makes more money on the hardware. Apparently it is economically\nimpossible for anyone else to compete in hardware as well.\n\nI agree that there is a serious problem of mining centralization (and\neconomic/validation centralization). If these problems are not solved\nBitcoin will fail. It will rise again, with people a little wiser, but\nthe disruption will be unfortunate for many.\n\nI don't want to see that, so I tend to not advocate for solutions that\nrun counter to the security model. Many people must mine, there is no\nway around it. And if people want a say with respect to mining, they\nshould mine. As a developer I would rather work toward fixing that\nproblem than putting a band-aid over it that basically tells people\nthat the way they get their say is by donating to the big mining\npersonality of their choice.\n\n>> There is nothing inherently wrong with paying people to run nodes\n>> or signal \"readiness\", but there is no reason whatsoever to\n>> consider these ideas beneficial from a personal/economic or \n>> security/decentralization standpoint.\n> \n> Running a node and mining are two very different things.\n\nNo, really?\n\nIf it wasn't clear, I was relating two sets of proposals. One aims to\nfind ways to fund node operation and the other aims to fund miner\nsignaling. The former fails to understand the economics and security\nmodel of full node operation and the latter fails to understand that\ndistributed mining is as essential to Bitcoin survival as distributed\nvalidation.\n\n>> The argument fails to recognize that mining for one's self may\n>> (or may not) result in a net loss, but donating to a miner in the\n>> hope of some action is comparatively a total loss. One is an\n>> expense in exchange for the intended social outcome, and the\n>> other is payment for representative government.\n>> \n>> And in this form of representative government that you propose,\n>> if we assume that miners are somehow bound to honor the payments\n>> (votes), ...\n> \n> First of all, this isn't donating to miners, but forbidding them\n> from mining your transaction (and thereby collecting your\n> transaction fee) unless they signal for the softfork.\n\nI assumed that people understand how markets work. Miners compete for\nfees. By eliminating a subset of potential sellers (currently by ~70%)\nthe buyer raises his own price. Presumably the price is raised even\nfurther by increasing the size of the transaction. This is either a\ndonation to the cause or a purchase of the signal, depending on how\nyou want to describe it (all donations are purchases of a sort).\n\nSo there is a cost increase that could alternatively be incurred by\nmining (i.e. assuming a lossy operation). If one is going to spend\nmoney on influencing mining one might as well not do it in a way that\ncontributes to centralization while training people to rely on it.\n\n> Secondly, your argument here assumes miners are a government or\n> control Bitcoin in some way. This is not correct.\n\nMiners absolutely \"control Bitcoin in some way\" - that is their\npurpose. They control the ordering of transactions, and with\nsufficient hash power can double-spend and therefore make the network\nunusable. Why would you bother to make me type this?\n\n> So miners are in fact already bound to honour the wishes of the\n> greater economy, and their refusal to do so is an attack on the\n> network.\n\nAbsolute nonsense, a miner incurs no obligation to the \"greater\neconomy\". He is offering a service in voluntary trade. He is likely to\ndo what it takes to spend his coinbase, assuming he wants to. This\ngives the economy strong economic control over his behavior. But\nnothing whatsoever obligates him to signal soft forks (or not optimize\nhis operations).\n\nDouble spending is an attack, on the person who has been robbed. The\nstate enforcing a patent is an attack, on the person against whom it\nis enforced. These are called attacks **because they are actually\ntheft**. You are conflating normal operation (despite disagreement\nwith some unmeasurable \"wishes\") with robbery.\n\ne\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZFqstAAoJEDzYwH8LXOFOsvsH/2aWlsfi5hB1IrnX1UBsMJl8\n+R6BZE+d5C5uNkk6/yENHqwwgTv8yhOKav2Y7xYx/DedhVftX90h9CtdeKGgCS2H\ncYNtoNauAvF2nlEMGGGcinLkYbS0dyQm07zwOI8gwuzbkslFGxLFClngFlFgMF4S\n4/YCWvtRJ0O5dkrAZuKwG/7JQ1JNopbDTxssirA/OzwTGjq7BUv7INyR8nBbOp6I\nxcrjq2bXja6Kxo08pr3+UrWc+0LO8fvX9z3rkm6USyin7TueS85gEUsk30h1Xng3\nAl1QccJ9KKJ+iQKdGozeHD2OlTFC1zW2kZaWbhgxOewDlmf7cNwZXEUwfr4C4Hs=\n=j5eo\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-13T12:48:48",
                "message_text_only": "On Sat, May 13, 2017 at 12:49:33AM +0000, Luke Dashjr wrote:\n> On Friday 12 May 2017 10:22:14 PM Peter Todd wrote:\n> > nVersion signaling is already technically unenforceable, in the sense that\n> > we don't have good ways of ensuring miners actually adopt the rules\n> > they're claiming to signal. Equally, it's users who ultimately adopt\n> > rules, not miners, and attempting to pay miners to signal certain bits\n> > will further confuse this point.\n> \n> This BIP doesn't change that. Enforcement remains primarily by users.\n\nI'm not arguing that it changes that; I'm arguing that it further confuses the\nsituation.\n\n> > Quite likely the outcome of users trying to anonymously pay anonymous\n> > miners to signal certain bits will be the complete breakdown of the\n> > honesty of the nVersion signalling system, currently enforced only by\n> > \"gentlemans agreement\".\n> \n> You assume users will pay for signalling of softforks prematurely. So long as \n> it waits until deployment of the softfork is widespread, this risk is minimal. \n> At worst, it creates risks similar to a UASF. So long as UASF is the \n> alternative, this way seems strictly better.\n\nI think you're assuming that the users paying for soft-fork signalling will\nrepresent an economic majority; that's not necessarily the case.\n\nFor example, if miners decide there's no downside to false signalling, they may\ntake the extra fees provided by 1% of the users paying to signal a fork, while\nthe other 99% don't participate, resulting in a situation where we have blocks\nviolating the nVersion protocol, and an unknown % of that 99% rejecting those\nblocks. At best that'd be no worse than a UASF, and at wost you're wrecked the\nvalidity of the nVersion \"gentlemans agreement\"\n\n> > Also, as an aside, this \"specification\" again shows the inadequacy and\n> > unreadability of English language specifications. I'd strongly suggest you\n> > delete it and instead mark the \"reference implementation\" as the\n> > specification.\n> \n> How so?\n\nJust read it: you have ten separate lines of dense English text describing\nsomething that could have been specified instead by ten lines of much more\nformally defined C++. In particular, note how many of those lines of English\ntext refer to C++ code anyway, like the sentence \"minimal-length 40-bit\nCScriptNum\"\n\nI don't want to have to learn another language - formally defined English that\nstill fails to be formally defined - just to read Bitcoin's specification.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/b4e84f6e/attachment-0001.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-13T16:42:44",
                "message_text_only": "On Saturday 13 May 2017 12:48:48 PM Peter Todd wrote:\n> > You assume users will pay for signalling of softforks prematurely. So\n> > long as it waits until deployment of the softfork is widespread, this\n> > risk is minimal. At worst, it creates risks similar to a UASF. So long\n> > as UASF is the alternative, this way seems strictly better.\n> \n> I think you're assuming that the users paying for soft-fork signalling will\n> represent an economic majority; that's not necessarily the case.\n\nI'm assuming that if the economic majority hasn't consented to the softfork, \nat least as many users will make their transactions conditional on non-\nsignalling."
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-13T04:23:41",
                "message_text_only": "I recall chatting about this idea recently and my conclusion was the same\nas Peter Todd's conclusion: this will just encourage miners to false signal\nreadiness with undermines both BIP 9 and BIP 8.\n\nI felt that rather than using script system for this construction, it would\nbe better to use the transaction version number instead by soft-forking in\na rule that says when the most significant bits of a transaction version\nare 001 then the transaction can only be included in blocks whose lower 29\nversion bits are set at the same position as the lower 29 version bits set\nin the transaction version.\n\nThat is to say, if we have block version blkVersion and transaction version\ntxVersion, we soft fork in a rule that requires that\n\n(txVersion & 0xe0000000 != 0x020000000) || ((blkVersion & 0xe0000000 =\n0x020000000) && (blkVersion & txVersion = txVersion))\n\nWhile I think that making use of the transaction version number is superior\nto adding an opcode, because it doesn't interfere with caching of script\nvalidity and because it doesn't use any more transaction space by making\nuse of the otherwise useless transaction version number, I still think it\nis a bad proposal.\n\nOn Fri, May 12, 2017 at 3:22 PM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the\n> community\n> to put economic pressure on miners to deploy softforks without the extreme\n> of\n> a UASF.\n>\n>     https://github.com/luke-jr/bips/blob/bip-cbv/bip-cbv.mediawiki\n>\n> Due to the potential for miners to maliciously block this softfork, it is\n> suggested that we deploy it using BIP 8 to ensure it eventually activates\n> even\n> if encountering hostility.\n>\n> This is intended to be an alternative to BIP 8 in the long term.\n> It is NOT intended to make BIP 148 obsolete, given the timeframes involved.\n>\n> An implementation is available (based on top of BIP 115's implementation):\n>\n>    https://github.com/luke-jr/bitcoin/compare/cbah...luke-\n> jr:checkblockversion\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/5ceec501/attachment-0001.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-13T05:26:58",
                "message_text_only": "On Saturday 13 May 2017 4:23:41 AM Russell O'Connor wrote:\n> I recall chatting about this idea recently and my conclusion was the same\n> as Peter Todd's conclusion: this will just encourage miners to false signal\n> readiness with undermines both BIP 9 and BIP 8.\n\nI already explained why this isn't the case: If we're comparing MASF to \nMASF+CBV, then I agree. But MASF is not necessarily always on the table, so \nthe comparison where this becomes relevant is MASF+CBV vs UASF.\n\n> I felt that rather than using script system for this construction, it would\n> be better to use the transaction version number instead by soft-forking in\n> a rule that says when the most significant bits of a transaction version\n> are 001 then the transaction can only be included in blocks whose lower 29\n> version bits are set at the same position as the lower 29 version bits set\n> in the transaction version.\n\nVersionbits change/lose their meaning after the deployment timeout. For this \nreason, the timeout must be specified so the check is skipped when that \noccurs.\n\nAlso, doing it the way you describe would fail to enforce that BIP9 is \nactually in use for the block version; you could simply add that as an \nadditional condition, but it seems pretty hacky since you wouldn't be able to \nupgrade versionbits anymore...\n\n> While I think that making use of the transaction version number is superior\n> to adding an opcode, because it doesn't interfere with caching of script\n> validity\n\nScript validity can still be cached with this: you would always allow the \nopcode to succeed at evaluation-time, and simply store the criteria checked \nseparately. Then it would behave effectively the same as using the transaction \nversion number.\n\nLuke"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-13T17:11:27",
                "message_text_only": "On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> Versionbits change/lose their meaning after the deployment timeout. For\n> this\n> reason, the timeout must be specified so the check is skipped when that\n> occurs.\n>\n\nTo add a timeout a user can optionally bundle a pair of similar\ntransactions.  One with the transaction version bits set and a second with\na locktime set.  The effect is the same.\n\nAlso, doing it the way you describe would fail to enforce that BIP9 is\n> actually in use for the block version; you could simply add that as an\n> additional condition, but it seems pretty hacky since you wouldn't be able\n> to\n> upgrade versionbits anymore...\n>\n\n\nMy formal condition does include a check for the block version (I've\ncorrected the constants below):\n\n(txVersion & 0xe0000000 != 0x200000000) || (*(blkVersion & 0xe0000000 =\n0x200000000)* && (blkVersion & txVersion = txVersion))\n\nNothing here prevents upgrading versionbits AFAICT.  Any txVersion that\ndoes not begin with 0b001 is unconditionally acceptable and available for\nfurther soft-forking.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170513/a5f8fe70/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-15T01:14:13",
                "message_text_only": "Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> Versionbits change/lose their meaning after the deployment timeout. For\n>> this\n>> reason, the timeout must be specified so the check is skipped when that\n>> occurs.\n>>\n>\n> To add a timeout a user can optionally bundle a pair of similar\n> transactions.  One with the transaction version bits set and a second with\n> a locktime set.  The effect is the same.\n\nI have a similar proposal to Russell; use tx nVersion.  However, my\nsubset is simpler, and uses fewer precious nVersion bits:\n\n1. Top version 26 bits must be 1 (say)\n2. Next bit indicates positive (must have bit set) or negative (must NOT\n   have bit set).\n3. Bottom 5 bits refer to which BIP8/9 bit we're talking about.\n\nThis only allows specifying a single bit, and only support BIP8/9-style\nsignalling.\n\nI believe we can skip the timeout: miners don't signal 100% either way\nanyway.  If a BIP is in LOCKIN, wallets shouldn't set positive on that\nbit (this gives them two weeks).  Similarly, if a BIP is close to\nFAILED, don't set positive on your tx.  Wallets shouldn't signal until\nany bit until see some minimal chance it's accepted (eg. 1 in 20 blocks).\n\n> I recall chatting about this idea recently and my conclusion was the same\n> as Peter Todd's conclusion: this will just encourage miners to false signal\n> readiness with undermines both BIP 9 and BIP 8.\n\nThis is gentler on miners than a UASF flag day, and does offer some\nharder-to-game signalling from bitcoin users.\n\nFalse signalling miners still have the 2 week LOCKIN period to upgrade,\notherwise they can already lose money.  You could argue they're *more*\nlikely to upgrade with a signal that significant parts of the economy\nhave done so.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2017-05-20T05:05:43",
                "message_text_only": "On Sat, May 13, 2017 at 01:11:27PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> On Sat, May 13, 2017 at 1:26 AM, Luke Dashjr <luke at dashjr.org> wrote:\n> > Versionbits change/lose their meaning after the deployment timeout. For\n> > this reason, the timeout must be specified so the check is skipped \n> > when that occurs.\n> To add a timeout a user can optionally bundle a pair of similar transactions.\u00a0\n> One with the transaction version bits set and a second with a locktime set.\u00a0\n> The effect is the same.\n\nAnother approach to ensuring the timeout might be to simply use input \nheight. ie:\n\n  * if there is a BIP-9 soft-fork using bit N currently STARTED or\n    LOCKED_IN phase. since the soft-fork is started, set the height of\n    the first block after starttime as \"S\".\n\n  * then a transaction is invalid in a block if:\n     * the soft-fork has not timed out or activated\n     * the block does not signal bit N\n     * the transaction nversion does signal bit N (by whatever formula)\n     * at least one input to the transaction has a height >= S\n\nThat's compatible with bit reuse: if a transaction designed to encourage\nsoft-fork foo with bit 1 does not get mined by the time foo finishes (by\ntimeout or success), then when soft-fork bar reaches STARTED phase while\nreusing bit 1, the old transaction can be mined by either signalling\nor non-signalling miners -- because all of the transaction inputs are\nprior to bar's block S, the invalidation rule doesn't apply for bar, and\nbecause foo has timed out or activated, it doesn't apply for foo either.\n\nIt means you can't directly use a bunch of old coins on their own to\nincentivise miner signalling -- you need to include a coin from after\nstarttime. That doesn't seem terribly onerous though; and should be\neasily solvable by just providing a coinjoin API anyway.  I think it's\ncompatible with using bitcoin days destroyed as a weighting measure too,\nsince only one of the coins needs to be relatively recent.\n\nThe above is a \"fail-open\" timeout rather than \"fail-closed\" -- if you\nsignal for foo, but your transaction doesn't get mined because too few\nminers are signalling foo, and then foo fails to activate and times out,\nyour transaction can then be mined by the miners that didn't signal. If\nthis isn't what you want, double-spending should be fine: provide a double\nspend at market rates that doesn't require signalling directly to miners\nand their choice becomes \"mine this thing now and get the fee directly\"\nversus \"hope no one else mines it now, and that I get the chance to mine\nthe original higher fee transaction after activation, before anyone else\ndoes\", so at least the economically-rational choice should be to mine\nthe lower-fee double spend immediately. So it should be reasonable to\noffer a higher fee for signalling, without risking that non-signalling\nminers will be able to claim that high fee eventually.\n\nI'm not sure the incentives about tying user-signalling for a soft-fork\nto miner signalling for a soft-fork are entirely sound; but if they are\nthen just using nversion seems a lot more user-friendly than requiring\nscript changes to me. In particular, it doesn't require any setup or\nteardown costs -- you don't have to get an input with a particular\nscript encoded that you can then spend to signal, and you don't have to\nremember variations on output address when you want to spend a transaction\nthat was signalling; likewise changes to wallets are pretty simple and\ndon't have \"you lost all your money\" results if there's a bug. Well,\nthe above timeout procedure requires getting a recent coin as \"setup\",\nbut that's pretty trivial, at least.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-14T12:18:18",
                "message_text_only": "Good morning Luke,\n\nConsidering the proposal as a whole, I think, it's a little imperfect.\n\nThe main problem, is that the end goal is activation, but what the opcode rewards is signalling.\n\nConsider a miner who signals only if the number of non-signalling blocks in this retargeting time > 5% of 2016. Such a miner would still effectively block a softfork activation, while still has a chance (albeit reduced) of winning the transaction fees of the block-signalling-opcode, in proportion to the number of miners not signaling for a softfork or using a similar algorithm.\n\nWhat we should reward should be activation.\n\nHow about an opcode which requires this stack (stack top at right)\n\n<signature> <publickeyhash> <versionbit>\n\n1. If the <versionbit> given is in state FAILED, then it checks if the given <signature> matches the given <publickeyhash>.\n\n2. If the <versionbit> given is in state LOCKED_IN or ACTIVE, it checks if the given <signature> matches the block's coinbase transaction signature.\n\nThis creates an output which is refundable to the owner, if the softfork fails to activate, but which may be claimed by miners, if the softfork activates.\n\nI don't know enough yet about Bitcoin's codebase to know if the above spec is actually workable.\n\nBut basically, I think we should create an assurance contract for activation of a softfork.\n\n--\n\nAlso, this invites an inverse logic:\n\n1. If the <versionbit> given is in state LOCKED_IN or ACTIVE, then it checks if the given <signature> matches the given <publickeyhash>.\n\n2. If the <versionbit> given is in state FAILED, it checks if the given <signature> matches the block's coinbase transaction signature.\n\nI think, your proposal allows an economic actor to pay fees if the miner is explicitly not signaling. This is supposed to allow a vote against a particular softfork.\n\nThus, it should also be possible to allow to vote against a softfork.\n\nBut in any case, I think, it's better to pay on activation or failure to activate, rather than mere signalling, as signalling is not the goal. Activation, or rejection of activation, is the goal.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170514/de6d19a9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP: Block signal enforcement via tx fees",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Eric Voskuil",
                "Anthony Towns",
                "Peter Todd",
                "ZmnSCPxj",
                "Russell O'Connor",
                "Luke Dashjr"
            ],
            "messages_count": 17,
            "total_messages_chars_count": 36944
        }
    },
    {
        "title": "[bitcoin-dev] Rolling UTXO set hashes",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2017-05-15T20:01:14",
                "message_text_only": "Hello all,\n\nI would like to discuss a way of computing a UTXO set hash that is\nvery efficient to update, but does not support any compact proofs of\nexistence or non-existence.\n\nMuch has been written on the topic of various data structures and\nderived hashes for the UTXO/TXO set before (including Alan Reiner's\ntrust-free lite nodes [1], Peter Todd's TXO MMR commitments [2] [3],\nor Bram Cohen's TXO bitfield [4]). They all provide interesting extra\nfunctionality or tradeoffs, but require invasive changes to the P2P\nprotocol or how wallets work, or force nodes to maintain their\ndatabase in a normative fashion. Instead, here I focus on an efficient\nhash that supports nothing but comparing two UTXO sets. However, it is\nnot incompatible with any of those other approaches, so we can gain\nsome of the advantages of a UTXO hash without adopting something that\nmay be incompatible with future protocol enhancements.\n\n1. Incremental hashing\n\nComputing a hash of the UTXO set is easy when it does not need\nefficient updates, and when we can assume a fixed serialization with a\nnormative ordering for the data in it - just serialize the whole thing\nand hash it. As different software or releases may use different\ndatabase models for the UTXO set, a solution that is order-independent\nwould seem preferable.\n\nThis brings us to the problem of computing a hash of unordered data.\nSeveral approaches that accomplish this through incremental hashing\nwere suggested in [5], including XHASH, AdHash, and MuHash. XHASH\nconsists of first hashing all the set elements independently, and\nXORing all those hashes together. This is insecure, as Gaussian\nelimination can easily find a subset of random hashes that XOR to a\ngiven value. AdHash/MuHash are similar, except addition/multiplication\nmodulo a large prime are used instead of XOR. Wagner [6] showed that\nattacking XHASH or AdHash is an instance of a generalized birthday\nproblem (called the k-sum problem in his paper, with unrestricted k),\nand gives a O(2^(2*sqrt(n)-1)) algorithm to attack it (for n-bit\nhashes). As a result, AdHash with 256-bit hashes only has 31 bits of\nsecurity.\n\nThankfully, [6] also shows that the k-sum problem cannot be\nefficiently solved in groups in which the discrete logarithm problem\nis hard, as an efficient k-sum solver can be used to compute discrete\nlogarithms. As a result, MuHash modulo a sufficiently large safe prime\nis provably secure under the DL assumption. Common guidelines on\nsecurity parameters [7] say that 3072-bit DL has about 128 bits of\nsecurity. A final 256-bit hash can be applied to the 3072-bit result\nwithout loss of security to reduce the final size.\n\nAn alternative to multiplication modulo a prime is using an elliptic\ncurve group. Due to the ECDLP assumption, which the security of\nBitcoin signatures already relies on, this also results in security\nagainst k-sum solving. This approach is used in the Elliptic Curve\nMultiset Hash (ECMH) in [8]. For this to work, we must \"hash onto a\ncurve point\" in a way that results in points without known discrete\nlogarithm. The paper suggests using (controversial) binary elliptic\ncurves to make that operation efficient. If we only consider\nsecp256k1, one approach is just reading potential X coordinates from a\nPRNG until one is found that has a corresponding Y coordinate\naccording to the curve equation. On average, 2 iterations are needed.\nA constant time algorithm to hash onto the curve exists as well [9],\nbut it is only slightly faster and is much more complicated to\nimplement.\n\nAdHash-like constructions with a sufficiently large intermediate hash\ncan be made secure against Wagner's algorithm, as suggested in [10].\n4160-bit hashes would be needed for 128 bits of security. When\nrepetition is allowed, [8] gives a stronger attack against AdHash,\nsuggesting that as much as 400000 bits are needed. While repetition is\nnot directly an issue for our use case, it would be nice if\nverification software would not be required to check for duplicated\nentries.\n\n2. Efficient addition and deletion\n\nInterestingly, both ECMH and MuHash not only support adding set\nelements in any order but also deleting in any order. As a result, we\ncan simply maintain a running sum for the UTXO set as a whole, and\nadd/subtract when creating/spending an output in it. In the case of\nMuHash it is slightly more complicated, as computing an inverse is\nrelatively expensive. This can be solved by representing the running\nvalue as a fraction, and multiplying created elements into the\nnumerator and spent elements into the denominator. Only when the final\nhash is desired, a single modular inverse and multiplication is needed\nto combine the two.\n\nAs the update operations are also associative, H(a)+H(b)+H(c)+H(d) can\nin fact be computed as (H(a)+H(b)) + (H(c)+H(d)). This implies that\nall of this is perfectly parallellizable: each thread can process an\narbitrary subset of the update operations, allowing them to be\nefficiently combined later.\n\n3. Comparison of approaches\n\nNumbers below are based on preliminary benchmarks on a single thread\nof a i7-6820HQ CPU running at 3.4GHz.\n\n(1) (MuHash) Multiplying 3072-bit hashes mod 2^3072 - 1103717 (the\nlargest 3072-bit safe prime).\n    * Needs a fast modular multiplication/inverse implementation.\n    * Using SHA512 + ChaCha20 for generating the hashes takes 1.2us per element.\n    * Modular multiplication using GMP takes 1.5us per element (2.5us\nwith a 60-line C+asm implementation).\n    * 768 bytes for maintaining a running sum (384 for numerator, 384\nfor denominator)\n    * Very common security assumption. Even if the DL assumption would\nbe broken (but no k-sum algorithm faster than Wagner's is found), this\nstill maintains 110 bits of security.\n\n(2) (ECMH) Adding secp256k1 EC points\n    * Much more complicated than the previous approaches when\nimplementing from scratch, but almost no extra complexity when ECDSA\nsecp256k1 signature validation is already implemented.\n    * Using SHA512 + libsecp256k1's point decompression for generating\nthe points takes 11us per element on average.\n    * Addition/subtracting of N points takes 5.25us + 0.25us*N.\n    * 64 bytes for a running sum.\n    * Identical security assumption as Bitcoin's signatures.\n\nUsing the numbers above, we find that:\n* Computing the hash from just the UTXO set takes (1) 2m15s (2) 9m20s\n* Processing all creations and spends in an average block takes (1)\n24ms (2) 100ms\n* Processing precomputed per-transaction aggregates in an average\nblock takes (1) 3ms (2) 0.5ms\n\nNote that while (2) has higher CPU usage than (1) in general, it has\nlower latency when using precomputed per-transaction aggregates. Using\nsuch aggregates is also more feasible as they're only 64 bytes rather\nthan 768. Because of simplicity, (1) has my preference.\n\nOverall, these numbers are sufficiently low (note that they can be\nparallellized) that it would be reasonable for full nodes and/or other\nsoftware to always maintain one of them, and effectively have a\nrolling cryptographical checksum of the UTXO set at all times.\n\n4. Use cases\n\n* Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash\ncomputation. This currently requires minutes of I/O and CPU, as it\nserializes and hashes the entire UTXO set. A rolling set hash would\nmake this instant, making the whole RPC much more usable for sanity\nchecking.\n* Assisting in implementation of fast sync methods with known good\nblocks/UTXO sets.\n* Database consistency checking: by remembering the UTXO set hash of\nthe past few blocks (computed on the fly), a consistency check can be\ndone that recomputes it based on the database.\n\n\n  [1] https://bitcointalk.org/index.php?topic=88208.0\n  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html\n  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html\n  [4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013928.html\n  [5] https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf\n  [6] https://people.eecs.berkeley.edu/~daw/papers/genbday.html\n  [7] https://www.keylength.com/\n  [8] https://arxiv.org/pdf/1601.06502.pdf\n  [9] https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n  [10] http://csrc.nist.gov/groups/ST/hash/sha-3/Aug2014/documents/gligoroski_paper_sha3_2014_workshop.pdf\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Peter R",
                "date": "2017-05-15T20:53:45",
                "message_text_only": "Hi Pieter,\n\nI wanted to say that I thought this write-up was excellent!  And efficiently hashing the UTXO set in this rolling fashion is a very exciting idea!! \n\nPeter R\n\n> On May 15, 2017, at 1:01 PM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hello all,\n> \n> I would like to discuss a way of computing a UTXO set hash that is\n> very efficient to update, but does not support any compact proofs of\n> existence or non-existence.\n> \n> Much has been written on the topic of various data structures and\n> derived hashes for the UTXO/TXO set before (including Alan Reiner's\n> trust-free lite nodes [1], Peter Todd's TXO MMR commitments [2] [3],\n> or Bram Cohen's TXO bitfield [4]). They all provide interesting extra\n> functionality or tradeoffs, but require invasive changes to the P2P\n> protocol or how wallets work, or force nodes to maintain their\n> database in a normative fashion. Instead, here I focus on an efficient\n> hash that supports nothing but comparing two UTXO sets. However, it is\n> not incompatible with any of those other approaches, so we can gain\n> some of the advantages of a UTXO hash without adopting something that\n> may be incompatible with future protocol enhancements.\n> \n> 1. Incremental hashing\n> \n> Computing a hash of the UTXO set is easy when it does not need\n> efficient updates, and when we can assume a fixed serialization with a\n> normative ordering for the data in it - just serialize the whole thing\n> and hash it. As different software or releases may use different\n> database models for the UTXO set, a solution that is order-independent\n> would seem preferable.\n> \n> This brings us to the problem of computing a hash of unordered data.\n> Several approaches that accomplish this through incremental hashing\n> were suggested in [5], including XHASH, AdHash, and MuHash. XHASH\n> consists of first hashing all the set elements independently, and\n> XORing all those hashes together. This is insecure, as Gaussian\n> elimination can easily find a subset of random hashes that XOR to a\n> given value. AdHash/MuHash are similar, except addition/multiplication\n> modulo a large prime are used instead of XOR. Wagner [6] showed that\n> attacking XHASH or AdHash is an instance of a generalized birthday\n> problem (called the k-sum problem in his paper, with unrestricted k),\n> and gives a O(2^(2*sqrt(n)-1)) algorithm to attack it (for n-bit\n> hashes). As a result, AdHash with 256-bit hashes only has 31 bits of\n> security.\n> \n> Thankfully, [6] also shows that the k-sum problem cannot be\n> efficiently solved in groups in which the discrete logarithm problem\n> is hard, as an efficient k-sum solver can be used to compute discrete\n> logarithms. As a result, MuHash modulo a sufficiently large safe prime\n> is provably secure under the DL assumption. Common guidelines on\n> security parameters [7] say that 3072-bit DL has about 128 bits of\n> security. A final 256-bit hash can be applied to the 3072-bit result\n> without loss of security to reduce the final size.\n> \n> An alternative to multiplication modulo a prime is using an elliptic\n> curve group. Due to the ECDLP assumption, which the security of\n> Bitcoin signatures already relies on, this also results in security\n> against k-sum solving. This approach is used in the Elliptic Curve\n> Multiset Hash (ECMH) in [8]. For this to work, we must \"hash onto a\n> curve point\" in a way that results in points without known discrete\n> logarithm. The paper suggests using (controversial) binary elliptic\n> curves to make that operation efficient. If we only consider\n> secp256k1, one approach is just reading potential X coordinates from a\n> PRNG until one is found that has a corresponding Y coordinate\n> according to the curve equation. On average, 2 iterations are needed.\n> A constant time algorithm to hash onto the curve exists as well [9],\n> but it is only slightly faster and is much more complicated to\n> implement.\n> \n> AdHash-like constructions with a sufficiently large intermediate hash\n> can be made secure against Wagner's algorithm, as suggested in [10].\n> 4160-bit hashes would be needed for 128 bits of security. When\n> repetition is allowed, [8] gives a stronger attack against AdHash,\n> suggesting that as much as 400000 bits are needed. While repetition is\n> not directly an issue for our use case, it would be nice if\n> verification software would not be required to check for duplicated\n> entries.\n> \n> 2. Efficient addition and deletion\n> \n> Interestingly, both ECMH and MuHash not only support adding set\n> elements in any order but also deleting in any order. As a result, we\n> can simply maintain a running sum for the UTXO set as a whole, and\n> add/subtract when creating/spending an output in it. In the case of\n> MuHash it is slightly more complicated, as computing an inverse is\n> relatively expensive. This can be solved by representing the running\n> value as a fraction, and multiplying created elements into the\n> numerator and spent elements into the denominator. Only when the final\n> hash is desired, a single modular inverse and multiplication is needed\n> to combine the two.\n> \n> As the update operations are also associative, H(a)+H(b)+H(c)+H(d) can\n> in fact be computed as (H(a)+H(b)) + (H(c)+H(d)). This implies that\n> all of this is perfectly parallellizable: each thread can process an\n> arbitrary subset of the update operations, allowing them to be\n> efficiently combined later.\n> \n> 3. Comparison of approaches\n> \n> Numbers below are based on preliminary benchmarks on a single thread\n> of a i7-6820HQ CPU running at 3.4GHz.\n> \n> (1) (MuHash) Multiplying 3072-bit hashes mod 2^3072 - 1103717 (the\n> largest 3072-bit safe prime).\n>    * Needs a fast modular multiplication/inverse implementation.\n>    * Using SHA512 + ChaCha20 for generating the hashes takes 1.2us per element.\n>    * Modular multiplication using GMP takes 1.5us per element (2.5us\n> with a 60-line C+asm implementation).\n>    * 768 bytes for maintaining a running sum (384 for numerator, 384\n> for denominator)\n>    * Very common security assumption. Even if the DL assumption would\n> be broken (but no k-sum algorithm faster than Wagner's is found), this\n> still maintains 110 bits of security.\n> \n> (2) (ECMH) Adding secp256k1 EC points\n>    * Much more complicated than the previous approaches when\n> implementing from scratch, but almost no extra complexity when ECDSA\n> secp256k1 signature validation is already implemented.\n>    * Using SHA512 + libsecp256k1's point decompression for generating\n> the points takes 11us per element on average.\n>    * Addition/subtracting of N points takes 5.25us + 0.25us*N.\n>    * 64 bytes for a running sum.\n>    * Identical security assumption as Bitcoin's signatures.\n> \n> Using the numbers above, we find that:\n> * Computing the hash from just the UTXO set takes (1) 2m15s (2) 9m20s\n> * Processing all creations and spends in an average block takes (1)\n> 24ms (2) 100ms\n> * Processing precomputed per-transaction aggregates in an average\n> block takes (1) 3ms (2) 0.5ms\n> \n> Note that while (2) has higher CPU usage than (1) in general, it has\n> lower latency when using precomputed per-transaction aggregates. Using\n> such aggregates is also more feasible as they're only 64 bytes rather\n> than 768. Because of simplicity, (1) has my preference.\n> \n> Overall, these numbers are sufficiently low (note that they can be\n> parallellized) that it would be reasonable for full nodes and/or other\n> software to always maintain one of them, and effectively have a\n> rolling cryptographical checksum of the UTXO set at all times.\n> \n> 4. Use cases\n> \n> * Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash\n> computation. This currently requires minutes of I/O and CPU, as it\n> serializes and hashes the entire UTXO set. A rolling set hash would\n> make this instant, making the whole RPC much more usable for sanity\n> checking.\n> * Assisting in implementation of fast sync methods with known good\n> blocks/UTXO sets.\n> * Database consistency checking: by remembering the UTXO set hash of\n> the past few blocks (computed on the fly), a consistency check can be\n> done that recomputes it based on the database.\n> \n> \n>  [1] https://bitcointalk.org/index.php?topic=88208.0\n>  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html\n>  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html\n>  [4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013928.html\n>  [5] https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf\n>  [6] https://people.eecs.berkeley.edu/~daw/papers/genbday.html\n>  [7] https://www.keylength.com/\n>  [8] https://arxiv.org/pdf/1601.06502.pdf\n>  [9] https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n>  [10] http://csrc.nist.gov/groups/ST/hash/sha-3/Aug2014/documents/gligoroski_paper_sha3_2014_workshop.pdf\n> \n> Cheers,\n> \n> -- \n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-15T23:04:01",
                "message_text_only": "Good morning Pieter,\n\n>4. Use cases\n>\n>* Replacement for Bitcoin Core's gettxoutsetinfo RPC's hash\n>computation. This currently requires minutes of I/O and CPU, as it\n>serializes and hashes the entire UTXO set. A rolling set hash would\n>make this instant, making the whole RPC much more usable for sanity\n>checking.\n>* Assisting in implementation of fast sync methods with known good\n>blocks/UTXO sets.\n>* Database consistency checking: by remembering the UTXO set hash of\n>the past few blocks (computed on the fly), a consistency check can be\n>done that recomputes it based on the database.\n\nAnother use case I can think of is a potential \"chain-flip\" hard fork of block header formats, where the UTXO hash rather than merkle tree root of transactions is in the header, which would let lite nodes download a UTXO set from any full node and verify it by verifying only block headers starting from genesis.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/7e39b541/attachment.html>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-15T23:59:58",
                "message_text_only": "On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> transactions is in the header, which would let lite nodes download a UTXO\n> set from any full node and verify it by verifying only block headers\n> starting from genesis.\n\nYa, lite nodes with UTXO sets are one of the the oldest observed\nadvantages of a commitment to the UTXO data:\n\nhttps://bitcointalk.org/index.php?topic=21995.0\n\nBut it requires a commitment. And for most of the arguments for those\nyou really want compact membership proofs.  The recent rise in\ninterest in full block lite clients (for privacy reasons), perhaps\ncomplements the membership proofless usage.\n\nPieter describes some uses for doing something like this without a\ncommitment.  In my view, it's more interesting to first gain\nexperience with an operation without committing to it (which is a\nconsensus change and requires more care and consideration, which are\neasier if people have implementation experience).\n\n> rather than merkle tree root of transactions is in the header,\n\nFor audibility and engineering reasons it would need to be be in\naddition to rather than rather than, because the proof of work needs\nto commit to the witness data (in that kind of flip, the transactions\nthemselves become witnesses for UTXO deltas) or you get trivial DOS\nattacks where people provide malleated blocks that have invalid\nwitnesses."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-16T00:15:58",
                "message_text_only": ">On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev\n><bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> transactions is in the header, which would let lite nodes download a UTXO\n>> set from any full node and verify it by verifying only block headers\n>> starting from genesis.\n>\n>Ya, lite nodes with UTXO sets are one of the the oldest observed\n>advantages of a commitment to the UTXO data:\n>\n>https://bitcointalk.org/index.php?topic=21995.0\n>\n>But it requires a commitment. And for most of the arguments for those\n>you really want compact membership proofs. The recent rise in\n>interest in full block lite clients (for privacy reasons), perhaps\n>complements the membership proofless usage.\n>\n>Pieter describes some uses for doing something like this without a\n>commitment. In my view, it's more interesting to first gain\n>experience with an operation without committing to it (which is a\n>consensus change and requires more care and consideration, which are\n>easier if people have implementation experience).\n\nI understand. Thank you for your explanation.\n\n>> rather than merkle tree root of transactions is in the header,\n>\n>For audibility and engineering reasons it would need to be be in\n>addition to rather than rather than, because the proof of work needs\n>to commit to the witness data (in that kind of flip, the transactions\n>themselves become witnesses for UTXO deltas) or you get trivial DOS\n>attacks where people provide malleated blocks that have invalid\n>witnesses.\n\nAnother thought I have, is that instead of committing to the UTXO of the block, to commit to the UTXO of the previous block, and the merkle tree root of the transactions in the current block.\n\nMy thought is that this would help reduce SPV mining, as a miner would need to actually scan any received new blocks in order to create the UTXO set of the previous block. An empty block would make things easier for the next block's miner, not the current block's miner. However, I'm not sure if my understanding is correct, or if there is some subtlety I missed in this regard.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/723c293e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-16T11:01:04",
                "message_text_only": "On Mon, May 15, 2017 at 11:59:58PM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> On Mon, May 15, 2017 at 11:04 PM, ZmnSCPxj via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > transactions is in the header, which would let lite nodes download a UTXO\n> > set from any full node and verify it by verifying only block headers\n> > starting from genesis.\n> \n> Ya, lite nodes with UTXO sets are one of the the oldest observed\n> advantages of a commitment to the UTXO data:\n> \n> https://bitcointalk.org/index.php?topic=21995.0\n> \n> But it requires a commitment. And for most of the arguments for those\n> you really want compact membership proofs.  The recent rise in\n> interest in full block lite clients (for privacy reasons), perhaps\n> complements the membership proofless usage.\n> \n> Pieter describes some uses for doing something like this without a\n> commitment.  In my view, it's more interesting to first gain\n> experience with an operation without committing to it (which is a\n> consensus change and requires more care and consideration, which are\n> easier if people have implementation experience).\n\nTo be clear, *none* of the previous (U)TXO commitment schemes require *miners*\nto participate in generating a commitment. While that was previously thought to\nbe true by many, I've seen no counter-arguments to the argument I published I\nfew months ago(1) that (U)TXO commitments did not require a soft-fork to\ndeploy.\n\n1) \"[bitcoin-dev] TXO commitments do not need a soft-fork to be useful\",\n   Peter Todd, Feb 23 2017,\n   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/8b074bc9/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2017-05-16T18:17:19",
                "message_text_only": "On Tue, May 16, 2017 at 4:01 AM, Peter Todd via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> To be clear, *none* of the previous (U)TXO commitment schemes require *miners*\n> to participate in generating a commitment. While that was previously thought to\n> be true by many, I've seen no counter-arguments to the argument I published I\n> few months ago(1) that (U)TXO commitments did not require a soft-fork to\n> deploy.\n>\n> 1) \"[bitcoin-dev] TXO commitments do not need a soft-fork to be useful\",\n>    Peter Todd, Feb 23 2017,\n>    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html\n\nI'm aware, I agree, and I even referenced that mail in my original post.\n\nHowever, all of those approaches still require a network wide choice\nto be useful. A validating node that does not maintain a UTXO X must\nget a proof of its unspentness from somewhere for at least the block\nwhich contains a spend of X. In a world where such a model is deployed\nnetwork-wide, that proof information is generated by the wallet and\nrelayed wherever needed. In a partial deployment however, you need\nnodes that can produce the proof for other nodes, and the ability to\nproduce a proof is significantly more expensive than running either an\nold or a new full node.\n\nThis ability to produce proofs becomes even harder when there are\ndifferent models deployed at once. Even just having a different\ncriterion for which UTXOs need a proof (eg. \"only outputs created more\nthan 1000 blocks ago\") may already cause compatibility issues. Combine\nthat with the multitude of ideas about this (insertion-ordered TXO\ntrees, txid-ordered UTXO Patricia tries, AVL+ trees, append-only\nbitfield, ...) with different trade-offs (in CPU, RAM for validators,\ncomplexity for wallets/index services, ...), I don't think we're quite\nready to make that choice.\n\nTo be clear: I'm very much in favor of moving to a model where the\nresponsibilities of full nodes are reduced in the long term. But\nbefore that can happen there will need to be implementations,\nexperiments, analysis, ...\n\nBecause of that, I think it is worthwhile to investigate solutions to\nthe \"how can we efficiently compare UTXO sets\" problem separately from\nthe \"how do we reduce full node costs by sending proofs instead of it\nmaintaining the data\". And rolling UTXO set hashes are a solution for\njust the first - and one that has very low costs and no normative\ndatastructures at all.\n\n-- \nPieter"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-16T18:20:00",
                "message_text_only": "On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> just the first - and one that has very low costs and no normative\n> datastructures at all.\n\nThe serialization of the txout itself is normative, but very minimal."
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-23T04:47:48",
                "message_text_only": "Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>> just the first - and one that has very low costs and no normative\n>> datastructures at all.\n>\n> The serialization of the txout itself is normative, but very minimal.\n\nI do prefer the (2) approach, BTW, as it reuses existing primitives, but\nI know \"simpler\" means a different thing to mathier brains :)\n\nSince it wasn't explicit in the proposal, I think the txout information\nplaced in the hash here is worth discussing.\n\nI prefer a simple txid||outnumber[1], because it allows simple validation\nwithout knowing the UTXO set itself; even a lightweight node can assert\nthat UTXOhash for block N+1 is valid if the UTXOhash for block N is\nvalid (and vice versa!) given block N+1.  And miners can't really use\nthat even if they were to try not validating against UTXO (!) because\nthey need to know input amounts for fees (which are becoming\nsignificant).\n\nIf I want to hand you the complete validatable UTXO set, I need to hand\nyou all the txs with any unspent output, and some bitfield to indicate\nwhich ones are unspent.\n\nOTOH, if you serialize more (eg. ...||amount||scriptPubKey ?), then the UTXO\nset size needed to validate the utxohash is a little smaller: you need\nto send the txid, but not the tx nVersion, nLocktime or inputs.  But in a\nSegWit world, that's actually *bigger* AFAICT.\n\nThanks,\nRusty.\n\n[1] I think you could actually use txid^outnumber, and if that's not a\n    curve point SHA256() again, etc.  But I don't think that saves any\n    real time, and may cause other issues."
            },
            {
                "author": "Pieter Wuille",
                "date": "2017-05-23T20:43:45",
                "message_text_only": "On Mon, May 22, 2017 at 9:47 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n>> On Tue, May 16, 2017 at 6:17 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n>>> just the first - and one that has very low costs and no normative\n>>> datastructures at all.\n>>\n>> The serialization of the txout itself is normative, but very minimal.\n>\n> I do prefer the (2) approach, BTW, as it reuses existing primitives, but\n> I know \"simpler\" means a different thing to mathier brains :)\n\nOh, I didn't mean it that way at all. (1) is simpler to get decent\nperformance out of. Implementing (1) using any language that has big\ninteger support or can link against GMP is likely going to be faster\nthan the fastest possible implementation of (2).\n\n> Since it wasn't explicit in the proposal, I think the txout information\n> placed in the hash here is worth discussing.\n>\n> I prefer a simple txid||outnumber[1], because it allows simple validation\n> without knowing the UTXO set itself; even a lightweight node can assert\n> that UTXOhash for block N+1 is valid if the UTXOhash for block N is\n> valid (and vice versa!) given block N+1.  And miners can't really use\n> that even if they were to try not validating against UTXO (!) because\n> they need to know input amounts for fees (which are becoming\n> significant).\n>\n> If I want to hand you the complete validatable UTXO set, I need to hand\n> you all the txs with any unspent output, and some bitfield to indicate\n> which ones are unspent.\n\nThat seems to completely defeat the purpose... if I want to give you a\nUTXO set, and prove its correctness wrt the hash you know... I need to\nremember the full transactions those outputs came from?\n\n> OTOH, if you serialize more (eg. ...||amount||scriptPubKey ?), then the UTXO\n> set size needed to validate the utxohash is a little smaller: you need\n> to send the txid, but not the tx nVersion, nLocktime or inputs.  But in a\n> SegWit world, that's actually *bigger* AFAICT.\n\nThat's an interesting idea, but I believe you're forgetting:\n* The size of txin prevout/nsequence, which is typically larger than\ntxouts (even when excluding scriptSig/witness data).\n* The size of spent txouts for transactions with unspent outputs left.\n* The fact that you can deduplicate the txids for txn that have\nmultiple unspent outputs in the UTXO set serialization, even if that\ntxid is repeated in the rolling hash computation.\n\nThe construction I was considering and benchmarking is using 256-bit\ntruncated SHA512(256bit txid || 32bit voutindex || 1bit coinbase ||\n31bit height || CTxOut output) as secp256k1 X coordinate, or as key to\nseed a ChaCha20 PRNG whose outputs is the 3072-bit MuHash number. The\nreason for using SHA512 is that it can process most UTXOs in a single\ntransformation (as opposed to SHA256 which will almost always need 2).\nThe reason for using ChaCha20 is that it's incredibly fast for\nproducing much data when a key is already known. An alternative is\nusing SHAKE256 for the whole construction (as it both takes an\narbitrary amount of data, and produces an arbitrary length hash) - but\nit's a bit slower.\n\n> Thanks,\n> Rusty.\n>\n> [1] I think you could actually use txid^outnumber, and if that's not a\n>     curve point SHA256() again, etc.  But I don't think that saves any\n>     real time, and may cause other issues.\n\nThat just seems scary to me...\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "Rolling UTXO set hashes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Peter Todd",
                "ZmnSCPxj",
                "Gregory Maxwell",
                "Pieter Wuille",
                "Peter R"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 31941
        }
    },
    {
        "title": "[bitcoin-dev] Validationless mining without transactions",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-15T23:30:59",
                "message_text_only": "Today someone showed up on IRC suggesting a scheme for to improve the\nability of miners to mine without validation while including transactions\nby shipping around an approximate sketch of the txins that were used by a\nblock.\n\nI pointed out that what sounded like the exact same scheme had been\npreviously proposed by Anthony Towns over a year ago,  that it turned out\nthat it didn't need any consensus changes, but also wasn't very attractive\nbecause the actual transmission of the block (at least with FBRP or Fibre)\ndidn't really take any longer...  And, of course, mining without validating\ndoes a real number on SPV security assumptions.\n\nBut then realized the the conversation between Anthony and I was offlist.\nSo-- for posterity...\n\nI think the most interesting thing about this thread is that it gives a\nconcrete proof that a restriction on collecting transaction fees does not\ndiscourage validationless mining; nor to other proposed consensus changes\nmake it any easier to include transactions while mining without validation.\n\n\nForwarded conversation\nSubject: Blockchain verification flag (BIP draft)\n------------------------\n\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Mon, Feb 29, 2016 at 2:13 AM\nTo: Gregory Maxwell <greg at xiph.org>\n\n\nOn Fri, Dec 04, 2015 at 08:26:22AM +0000, Gregory Maxwell via bitcoin-dev\nwrote:\n> A significant fraction of hashrate currently mines blocks without\n> verifying them for a span of time after a new block shows up on the\n> network for economically rational reasons.\n\nTwo thoughts related to this. Are they obvious or daft?\n\na)\n\nWould it make sense to require some demonstration that you've validated\nprior blocks? eg, you could demonstrate you've done part of the work\nto at least verify signatures from the previous block by including the\nsha256 of the concatenation of all the sighash values in the coinbase\ntransaction -- if you'd already done the sig checking, calculating that\nas you went would be pretty cheap, I think. Then make the rule be that\nif you set the \"validated\" bit without including the demonstration of\nvalidation, your block is invalid.\n\nI guess this is more or less what Peter Todd proposed in:\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n2015-December/012105.html\n\nb)\n\nIt occurred to me while emailing with Matt Corallo, that it's probably\npossible to make it easy to generate actually useful blocks while doing\nvalidationless mining, rather than only creating empty blocks.\n\nWhen creating a block, you:\n\n   - calculate a fixed size (7168 bytes?) bloom filter of the\n     prevouts that the block is spending\n   - include the sha256 of the final bloom filter as the last output\n     in the coinbase\n   - enforce the inclusion of that sha256 by soft-fork\n   - as part of fast relaying, transmit:\n       - 80 byte block header\n       - 7168 byte bloom filter\n       - < 416 (?) byte merkle path to the coinbase\n       - 64 byte sha256 midstate for coinbase up to start of the\n         final transaction\n       - < 128 byte tail of coinbase including bloom commitment\n     (total of 7856 bytes, so less than 8kB)\n\nI think that would be enough to verify that the proof-of-work is\ncommitting to the bloom filter, and the bloom filter will then let\nyou throw out any transactions that could have been included in a block\nbuilt on block n-1, but can't be included in block n+1 -- whether they're\nincluded in the new block, or would be double spends. So given that\ninformation you can safely build a new block that's actually full of\ntransactions on top of the new block, even prior to downloading it in\nfull, let alone validating it.\n\nI've run that algorithm over the last couple of weeks' worth of\ntransactions (to see how many of the next block's transaction would have\nbeen thrown away using that approach) and it appeared to work fine --\nit throws away maybe a dozen transactions per block compared to accurate\nvalidation, but that's only about a couple of kB out of a 1MB block,\nso something like 0.2%.  (I'm seeing ~4500 prevouts per block roughly,\nso that's the error rate you'd expect; doubling for 2MB's worth of txes\nwith segwit predicts 3.5%, doubling again would presumably result in 14%\nof transactions being falsely identified as double spends prior to the\nblock actually validating)\n\nI haven't checked the math in detail, but I think that could reasonably\ngive an immediate 20% increase in effective blocksize, given the number of\nempty blocks that get mined... (There were only ~1571MB of transactions\nin the last 2016 blocks, so bumping the average from 780kB per block to\n940kB would be a 20% increase; which would bring the 1.7x segwit increase\nup to 2x too...)\n\nAlso, as far as I can see, you could probably even just have bitcoin core\ntransmit that 8kB of data around as part of propogating headers first.\nOnce you've got the new header and bloom filter, the only extra bit\nshould be passing both those into getblocktemplate to update the\npreviousblockhash and transaction selection. Both those together and it\nseems like you could be mining on top of the latest block seconds after\nit was found, just by naively running a bitcoin node?\n\nI saw the \"Bitcoin Classic\" roadmap includes:\n\n  \"Implement \"headers-first\" mining. As soon as a valid 80-byte block\n   header that extends the most-work chain is received, relay the header\n   (via a new p2p network message) and allow mining an empty block on top\n   of it, for up to 20 seconds.\"\n\nwhich seems like the same idea done worse...\n\nAny thoughts? Pointers to the bitcointalk thread where this was proposed\ntwo years ago? :)\n\nCheers,\naj\n\n\n----------\nFrom: Gregory Maxwell <gmaxwell at gmail.com>\nDate: Mon, Feb 29, 2016 at 3:20 AM\nTo: Anthony Towns <aj at erisian.com.au>\n\n\nOn Mon, Feb 29, 2016 at 2:13 AM, Anthony Towns <aj at erisian.com.au> wrote:\n> Would it make sense to require some demonstration that you've validated\n> prior blocks? eg, you could demonstrate you've done part of the work\n\nThat information is easily shared/delegated... so it just creates\nanother centralized information source, and another source of\nunfairness producing latency in the mining process. Without actually\npreventing parties from mining. Doubly so in the context of how\nvalidationless mining is actually done; the miners pull from other\nminer's stratum servers; so they'll just see the commitments there.\n\nSo I don't see there being too much value there.\n\n> if you set the \"validated\" bit without including the demonstration of\n> validation, your block is invalid.\n\nPretty good incentive to not adopt the scheme, perhaps?\n\nMoreover, this creates another way for a block to be invalid which has\nno compact fraud proof. :(\n\n> It occurred to me while emailing with Matt Corallo, that it's probably\n> possible to make it easy to generate actually useful blocks while doing\n> validationless mining, rather than only creating empty blocks.\n\nI agree but:\n\nI'm basically tired of repeating to people that there is no need for a\nvalidationless block to be empty. So Yes, I agree with you on that\nfact; it's possible for miners to do this already, with no protocol\nchanges (yes, it requires trusting each other but inherently\nvalidationless mining already requires that). Miners only don't bother\nright now because the funds left behind are insubstantial.\n\nIts absolutely untrue that an empty block is not useful. Every block,\nempty or not, mined against the best tip you know contributes to the\nresolution of consensus and collapsing the network onto a single\nstate. Every block that was mined only after validating a block\namplifies security; by helping leave behind an invalid chain faster. A\nblock doesn't need to contain transactions to do these things.\n\n>        - 7168 byte bloom filter\n\nFWIW, thats significantly larger than the amount of data typically\nneeded to send the whole block using the fast block relay protocol.\n\nYour estimates are assuming the empty blocks come purely from\ntransmission and verification, but because most verification is cached\nand transmission compressed-- they don't. There are numerous latency\nsources through the whole stack, some constant some\nsize-proportional... the mining without validation achieves its gains\nnot from skipping validation (at least not most of the time); but\nmostly from short cutting a deep stack with many latency sources;\nincluding ones that have nothing to do with bitcoin core or the\nBitcoin protocol.\n\nHigh hardware latency also amplifies short periods of empty block\nmining to longer periods.\n\nPerhaps most importantly, VFM mining avoids needing to identify and\ncharacterize these other delay sources, by short cutting right at the\nend no one needs to even figure out that their pool server is\nperforming a DNS request before every time it contacts their bitcoind\nRPC or whatnot.\n\n>   \"Implement \"headers-first\" mining. As soon as a valid 80-byte block\n\nThis BIP draft resulted in me relieving some pretty vicious attacks\nfrom that community... funny.\n\n> Any thoughts? Pointers to the bitcointalk thread where this was proposed\n> two years ago? :)\n\nRelevant to your interests: https://github.com/bitcoin/bitcoin/pull/1586\n\nLots of discussion on IRC.\n\n----------\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Wed, Mar 2, 2016 at 9:55 PM\nTo: Gregory Maxwell <gmaxwell at gmail.com>\n\n\nOn Mon, Feb 29, 2016 at 03:20:01AM +0000, Gregory Maxwell wrote:\n> On Mon, Feb 29, 2016 at 2:13 AM, Anthony Towns <aj at erisian.com.au> wrote:\n> > Would it make sense to require some demonstration that you've validated\n> > prior blocks? eg, you could demonstrate you've done part of the work\n> That information is easily shared/delegated...\n\nYeah, I thought about that. It's a tradeoff -- you definitely want the\nvalidation to be easily \"shared\" in the sense that you want one validation\nrun to suffice for billions of mining attempts; and you probably want\nit to be easy to compute when you receive a block, so you don't have\nto revalidate the previous one to validate the new one... But you don't\nwant it to be so easily shared that one person on the planet calculates\nit and everyone else just leeches from them.\n\n> so it just creates\n> another centralized information source, and another source of\n> unfairness producing latency in the mining process. Without actually\n> preventing parties from mining. Doubly so in the context of how\n> validationless mining is actually done; the miners pull from other\n> miner's stratum servers; so they'll just see the commitments there.\n\nI think you could make it hostile to accidental sharing by having it be:\n\n  <n> ;\n  sha256(\n      sha256( current block's first <n>+1 coinbase outputs ;\n               previous block's nonce )\n      sha256( previous block's sighash values )\n  )\n\nIf you skipped the internal sha256's (or just moved the nonce into the\nfinal sha256), you'd be half-way forced to revalidate the previous block\nevery time you found a new block, which might be worthwhile.\n\n> > if you set the \"validated\" bit without including the demonstration of\n> > validation, your block is invalid.\n> Pretty good incentive to not adopt the scheme, perhaps?\n\nWell, my theory was once you have validated the block, then the\ndemonstration is trivially easy to provide.\n\nI was thinking that you could add a positive incentive by making validated\nblocks count for something like 1.6x the chainwork for choosing which\nchain to build on; so if you have a chain with 3 unvalidated blocks in\na row, then a chain with 2 validated blocks in a row instead would be\npreferred for building your next block.\n\n> Moreover, this creates another way for a block to be invalid which has\n> no compact fraud proof. :(\n\nHmmm. That's true. Is it true by definition though? If you're proving\nyou've validated 100% of a block, then is it even conceptually possible\nto check that proof with less work than validating 100% of a block?\nSounds kind of SNARK-ish.\n\nOh, don't SNARKs (theoretically) give you a compact fraud proof, provided\nthe block size and sigops are bounded? The \"secret\" input is the block\ndata, public input is the block hash and the supposed validation proof\nhash, program returns true if the block hash matches the block data,\nand the calculated validation hash doesn't match the supposed validation\nhash. Shudder to think how long generating the proof would take though,\nor how hard it'd be to generate the circuit in the first place...\n\n> > It occurred to me while emailing with Matt Corallo, that it's probably\n> > possible to make it easy to generate actually useful blocks while doing\n> > validationless mining, rather than only creating empty blocks.\n> I agree but:\n> I'm basically tired of repeating to people that there is no need for a\n> validationless block to be empty. So Yes, I agree with you on that\n> fact; it's possible for miners to do this already, with no protocol\n> changes (yes, it requires trusting each other but inherently\n> validationless mining already requires that).\n\nIf you're only mining an empty block, the only way someone else can\ncause you to waste your time is by wasting their own time doing PoW on\nan invalid block. If you're mining a block with transactions in it, and\nthey can mine a valid block, but trick you into mining something that\ndouble spends, then they can make you waste your time without wasting\ntheir own, which seems like a much worse attack to me.\n\nThe advantage of the consensus enforced bloom filter is you don't have\nto trust anything more than that economic incentive. However if you just\nsent an unverifiable bloom filter, it'd be trivial to trick you into\nmining an invalid block.\n\n(If you already have the 1MB of block data, then extracting the prevouts\nfor use as a blacklist would probably be plenty fast though)\n\n(Of course, maybe 90% of current hashpower does trust each other\nanyway, in which case requiring trust isn't a burden, but that's not\nvery decentralised...)\n\n(Paragraphs deleted. My maths is probably wrong, but I think it is\nactually economically rational to mine invalid blocks as chaff to distract\nvalidationless miners? The numbers I get are something like \"if 40% of\nthe network is doing validationless mining for 20 seconds out of every\n10 minutes, then it's profitable to devote about 2% of your hashpower to\nmining invalid blocks\". Probably some pretty dodgy assumptions though,\nso I'm not including any algebra. But having actual invalid blocks with\nreal proof of work appear in the wild seems like it'd be a good way to\nencourage miners to do validation...)\n\n> Miners only don't bother\n> right now because the funds left behind are insubstantial.\n\nHey, fees are almost 1% of the block payout these days -- that's within\nan order of magnitude of a rounding error!\n\n> Its absolutely untrue that an empty block is not useful.\n\nYeah, I deleted \"useless\" for that reason then put it back in anyway...\n\n> >        - 7168 byte bloom filter\n> FWIW, thats significantly larger than the amount of data typically\n> needed to send the whole block using the fast block relay protocol.\n\nReally? Hmm, if you have 2-byte indexes into the most likely to be mined\n60k transactions, by 2000 transactions per block is about 4000 bytes. So\nI guess that makes sense. And weak blocks would make that generalisable\nand only add maybe a 32B index to include on the wire, presumably.\n\nIt'd only take a dozen missed transactions to be longer though.\n\n> Your estimates are assuming the empty blocks come purely from\n> transmission and verification, but because most verification is cached\n> and transmission compressed-- they don't. There are numerous latency\n> sources through the whole stack, some constant some\n> size-proportional... the mining without validation achieves its gains\n> not from skipping validation (at least not most of the time); but\n> mostly from short cutting a deep stack with many latency sources;\n> including ones that have nothing to do with bitcoin core or the\n> Bitcoin protocol.\n\nHmm, so my assumption is the \"bitcoin core\" side of the stack looks\nsomething like:\n\n   block header received by p2p or relay network\n     |\n     V\n   block data received by p2p or relay network\n     |\n     V\n   validation, UTXO set updates\n     |\n     V\n   getblocktemplate (possible tx ordering recalculation)\n     |\n     V\n   block header to do PoW on!\n     |\n     V\n   vary and push to miners over the network\n     |\n     V\n   push to ASICs\n\nand the validationless \"shortcut\" just looks like:\n\n   block header received by p2p or relay network\n     |\n     V\n   hack hack\n     |\n     V\n   new block header to do PoW on!\n     |\n     V\n   vary and push to miners over the network\n     |\n     V\n   push to ASICs\n\nand so making the bitcoin core parts able to provide an unvalidated\nheader to push to miners/ASICs against \"instantly\" would be a win as\nfar as getting bitcoin proper back into the loop all the time... That\nwould mean removing validation from the critical path, and possibly more\noptimisation of getblocktemplate to make it effectively instant too. But\nthose seem possible?\n\nHaving it be:\n\n  header received by bitcoin core\n    |\n    V\n  new block header to do (unverified) PoW on!\n    |\n    V\n  ...\n\nand\n\n  header received by bitcoin core\n    |\n    V\n  block data received by bitcoin core\n    |\n    V\n  block data validated\n    |\n    V\n  new block header to do (verified) PoW on!\n    |\n    V\n  ...\n\nwith mining tools being able to just reliably and efficiently leave\nbitcoin core in the loop seems like it ought to be a win to me...\n\n> Perhaps most importantly, VFM mining avoids needing to identify and\n> characterize these other delay sources, by short cutting right at the\n> end no one needs to even figure out that their pool server is\n> performing a DNS request before every time it contacts their bitcoind\n> RPC or whatnot.\n\nAt least with longpoll, doing a DNS query before connection shouldn't\nmatter?\n\n> >   \"Implement \"headers-first\" mining. As soon as a valid 80-byte block\n> This BIP draft resulted in me relieving some pretty vicious attacks\n> from that community... funny.\n\nI'm guessing you meant \"receiving\", which makes that a kinda weird\nfreudian slip? :) But yeah, technical consistency isn't something I've\nseen much of from that area...\n\n> > Any thoughts? Pointers to the bitcointalk thread where this was proposed\n> > two years ago? :)\n> Relevant to your interests: https://github.com/bitcoin/bitcoin/pull/1586\n\nTsk, 2 != 4...\n\nHmm, I'm not sure where this leaves my opinion on either of those ideas.\n\nCheers,\naj\n\n\n----------\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Sun, Mar 13, 2016 at 3:58 AM\nTo: Gregory Maxwell <gmaxwell at gmail.com>\n\n\nOn Thu, Mar 03, 2016 at 07:55:06AM +1000, Anthony Towns wrote:\n> > >        - 7168 byte bloom filter\n> > FWIW, thats significantly larger than the amount of data typically\n> > needed to send the whole block using the fast block relay protocol.\n> Really? Hmm, if you have 2-byte indexes into the most likely to be mined\n> 60k transactions, by 2000 transactions per block is about 4000 bytes. So\n> I guess that makes sense. And weak blocks would make that generalisable\n> and only add maybe a 32B index to include on the wire, presumably.\n> It'd only take a dozen missed transactions to be longer though.\n\nSo I think there's two levels of withholding adversarial miners could\ndo:\n\n - block withholding, so they have more time to build on top of their\n   own block, maybe increasing their effective hashrate if they have\n   above average connectivity\n\n - transaction withholding, so an entire block can be invalidated\n   after the fact, hitting SPV nodes. if there are SPV miners, this can\n   invalidate their work (potentially profitably, if you've accidently\n   orphaned yourself)\n\nYou could solve transaction withholding for miners just by saying\n\"a PoW isn't valid unless the merkle tree is valid\", that way you\ncan't retroactively invalidate a block, but then you need fast relay\nbefore starting to mine, not just the header and some hint as to what\ntransactions might be included, and therefore the bloom filter idea\nis pointless...\n\n\nHaving actually tried the relay network now, it seems like:\n\n a) it gets less coding gain than it theoretically could; the day or\n    so's worth of blocks from Lightsword only seemed to be ~8x less data,\n    rather than ~125x-250x, and what I'm seeing seems similar. So still\n    room for improvement?\n\n b) using \"weak blocks\" as a way of paying for adding \"non-standard\"\n    transactions (large, low fee, actually non-standard, etc) to the\n    mempool seems workable to me; so long as the only reason you're doing\n    weak blocks is so miners can ensure the transactions they're mining\n    are in mempools, and thus that their blocks will relay quickly, the\n    incentives seem properly aligned. (I think you'd want to distinguish\n    txns only relayed because they have a weak block, just to be nice to\n    SPV clients -- weak block txns might only be mined by one miner, while\n    standard, fee paying transactions are being mined by all/most miners)\n\n c) it seems like it would be possible to adapt the relay protocol into\n    a p2p environment to me? I'm thinking that you provide a bidirectional\n    mapping for (a subset of) your mempool for each connection you\n    have, so that you can quickly go to/from a 2-byte index to a\n    transaction. If you make it so that whoever was listening gets to\n    decide what transactions are okay, then you'd just need 9 of these\n    maps -- 1 for each of your outgoing connections (ie, 8 total), plus\n    another 1 that covers all your incoming connections, and each map\n    should only really need to use up to about a meg of memory, which\n    seems pretty feasible.  Maybe it means up to 8x5MB of your mempool\n    is controlled by other people's policies rather than your own,\n    but that doesn't seem to bad either.\n\n d) I'm a bit confused how it compares to IBLT; it seems like IBLT has\n    really strong ordering requirements to work correctly, but if you\n    had that you could compress the fast relay protocol really well,\n    since you could apply the same ordering to your shared mempool, and\n    then just send \"next tx, next tx, skip 1 tx, next tx, next tx, skip\n    3 tx, next tx, here's one you missed, ...\", which with compression\n    would probably get you to just a few /bits/ per (previously seen)\n    transaction...  [0] [1]\n\n e) for p2p relay, maybe it would make sense to have the protocol only\n    allow sending blocks where all the transactions are \"previously\n    seen\". that way if you get a block where some txes haven't been\n    seen before, you stall that block, and start sending transactions\n    through. if another block comes in in the meantime, that doesn't\n    have any new transactions, you send that block through straight away.\n    that encourages sending weak blocks through first, to ensure your\n    transactions are already in mempools and no one else can sneak\n    in first.\n\nHmm... So that all seems kind of plausible to me; in how many ways am I\nmistaken? :)\n\nCheers,\naj\n\n[0] A hard-fork change to have the block merkle tree be ordered by txid,\n    and have the transactions topologically sorted before being validated\n    would be kind-of interesting here -- apart from making sorting\n    obvious, it'd make it easy to prove that a block doesn't contain a\n    transaction. Bit altcoin-y though...\n\n[1] Maybe having the shared mempool indexes be sorted rather than FIFO\n    would make the data structures hard; I don't think so, but not sure.\n\n\n----------\nFrom: Gregory Maxwell <gmaxwell at gmail.com>\nDate: Sun, Mar 13, 2016 at 5:06 AM\nTo: Anthony Towns <aj at erisian.com.au>\n\n\nOn Sun, Mar 13, 2016 at 3:58 AM, Anthony Towns <aj at erisian.com.au> wrote:\n> On Thu, Mar 03, 2016 at 07:55:06AM +1000, Anthony Towns wrote:\n>> > >        - 7168 byte bloom filter\n>> > FWIW, thats significantly larger than the amount of data typically\n>> > needed to send the whole block using the fast block relay protocol.\n>> Really? Hmm, if you have 2-byte indexes into the most likely to be mined\n>> 60k transactions, by 2000 transactions per block is about 4000 bytes. So\n>> I guess that makes sense. And weak blocks would make that generalisable\n>> and only add maybe a 32B index to include on the wire, presumably.\n>> It'd only take a dozen missed transactions to be longer though.\n>\n> So I think there's two levels of withholding adversarial miners could\n> do:\n>\n>  - block withholding, so they have more time to build on top of their\n>    own block, maybe increasing their effective hashrate if they have\n>    above average connectivity\n\nAlso called \"selfish mining\".\n\n>  - transaction withholding, so an entire block can be invalidated\n>    after the fact, hitting SPV nodes. if there are SPV miners, this can\n>    invalidate their work (potentially profitably, if you've accidently\n>    orphaned yourself)\n> You could solve transaction withholding for miners just by saying\n> \"a PoW isn't valid unless the merkle tree is valid\", that way you\n> can't retroactively invalidate a block, but then you need fast relay\n> before starting to mine, not just the header and some hint as to what\n> transactions might be included, and therefore the bloom filter idea\n> is pointless...\n\nRight, this is how Bitcoin Core works (won't extend a chain it hasn't\nvalidated)-- but some miners have shortcutted it to reduce latency.\n(And not just bypassing validation, but the whole process, e.g.\ntransaction selection; which historically has taken more time than\npropagation).\n\n> Having actually tried the relay network now, it seems like:\n>\n>  a) it gets less coding gain than it theoretically could; the day or\n>     so's worth of blocks from Lightsword only seemed to be ~8x less data,\n>     rather than ~125x-250x, and what I'm seeing seems similar. So still\n>     room for improvement?\n\nIt's pretty variable.  It depends a lot on consistency between the\ntransactions the server side selects and the client. When spam attacks\ngo on, or miners change their policy compression falls off until the\nfar end twiddles.\n\nGo look at the distribution of the results.\n\n>  c) it seems like it would be possible to adapt the relay protocol into\n>     a p2p environment to me? I'm thinking that you provide a bidirectional\n>     mapping for (a subset of) your mempool for each connection you\n>     have, so that you can quickly go to/from a 2-byte index to a\n>     transaction. If you make it so that whoever was listening gets to\n>     decide what transactions are okay, then you'd just need 9 of these\n>     maps -- 1 for each of your outgoing connections (ie, 8 total), plus\n>     another 1 that covers all your incoming connections, and each map\n>     should only really need to use up to about a meg of memory, which\n>     seems pretty feasible.  Maybe it means up to 8x5MB of your mempool\n>     is controlled by other people's policies rather than your own,\n>     but that doesn't seem to bad either.\n\nThat is a bit kludgy, but yes-- it would work.\n\nBut the key thing about latency minimization is that you _must_ send a\nblock with no request; because otherwise the RTT for just the request\nalone will totally dominate the transfer in most cases.  And having N\npeers send you the whole block redundantly ends up hurting your\nperformance (esp because packet losses mean more round trips) even if\nthe compression is very high.\n\nAll these problems can be avoided; at least in theory. Optimal latency\nmitigation would be achieved by something like block network coding\ntechniques:\n\nhttps://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding\n\nWith these techniques peers could blindly send you data without you\nrequesting it, while every byte they send would usefully contribute to\nyour reconstruction. With extra effort and opportunistic forwarding\nthe entire network could, in theory, receive a block in the time it\ntook the original host to send only one block, while making use of a\nsignificant fraction of the network's whole bisection bandwidth.\n\n>  d) I'm a bit confused how it compares to IBLT; it seems like IBLT has\n>     really strong ordering requirements to work correctly, but if you\n>     had that you could compress the fast relay protocol really well,\n>     since you could apply the same ordering to your shared mempool, and\n>     then just send \"next tx, next tx, skip 1 tx, next tx, next tx, skip\n>     3 tx, next tx, here's one you missed, ...\", which with compression\n>     would probably get you to just a few /bits/ per (previously seen)\n>     transaction...  [0] [1]\n\nLatency of block relay easily ends up CPU bound; even when not doing\nanything too smart (this is why Matt's relay protocol stuff has AVX\nsha2 code in it). Prior IBLT implementation attempts have performance\nso low that their decode time ends up dwarfing transmission time, and\nplain uncoded blocks are faster for common host/bandwidth\nconfigurations.\n\nThe ordering requirements stuff is not that relevant in my view; you\nlikely believe this because Gavin rat-holed himself on it trying to\nspec out ordering requirements for miners...  The reality of it is\nthat a uniform permutation of, say, 4000 transactions can be stored in\nlog2(4000!)/8 bytes, or about 5.2kbytes (and this is easily achieved\njust by using range coding to optimally pack integers in the range\n[0..n_unpicked_txn) to pick transactions out of a lexagraphically\nsorted list) ... and this is without any prediction at all-- randomly\nordered txn in the block would work just as well.\n\n[E.g. using the uint coder from the daala video codec project can code\nthese values with about 1% overhead, and runs at about 12MB/sec doing\nso on my slow laptop]\n\nRecently some folks have been working privately on a block network\ncoding implementation... earlier attempts (even before IBLT became\ntrendy) were thwarted by the same thing that thwarts IBLT: the\ndecoding was so slow it dominated the latency. We've found some faster\ncoding schemes though... so it looks like it might be practical now. I\ncould send you more info if you read the block network coding page and\nare interested in helping.\n\nBoth IBLT and BNC would both be more useful in the weakblocks model\nbecause there the decode speed isn't latency critical-- so if it needs\n100ms of cpu time to decode an efficiently encoded block, that is no\nbig deal.\n\n>  e) for p2p relay, maybe it would make sense to have the protocol only\n>     allow sending blocks where all the transactions are \"previously\n>     seen\". that way if you get a block where some txes haven't been\n>     seen before, you stall that block, and start sending transactions\n>     through. if another block comes in in the meantime, that doesn't\n>     have any new transactions, you send that block through straight away.\n>     that encourages sending weak blocks through first, to ensure your\n>     transactions are already in mempools and no one else can sneak\n>     in first.\n\nYes, it's perfectly reasonable to do that for bandwidth minimization--\nthough it doesn't minimize latency.  \"Seen\" is complex, you have no\nguarantee a peer will accept any transaction you've sent it, or even\nthat it will retain any it sent you. So multiple round trips are\nrequired to resolve missing transactions.\n\nWe haven't bothered implementing this historically because the\nbandwidth reduction is small overall, and it's not the right strategy\nfor reducing latency-- the vast majority of bandwidth is eaten by\nrelay. Right now maybe 15% is used by blocks... so at most you'd get a\n15% improvement here.\n\nI did some fairly informal measurements and posted about it:\nhttps://bitcointalk.org/index.php?topic=1377345.0\n\nI also point out there that the existing blocksonly mode achieves\nbandwidth optimal transport already (ignoring things like transaction\nformat compression)... just so long as you don't care about learning\nabout unconfirmed transactions. :)\n\n> [0] A hard-fork change to have the block merkle tree be ordered by txid,\n>     and have the transactions topologically sorted before being validated\n>     would be kind-of interesting here -- apart from making sorting\n>     obvious, it'd make it easy to prove that a block doesn't contain a\n>     transaction. Bit altcoin-y though...\n\nIf you sort by data (or ID) without requiring the verifier to\ntopologically sort then an efficient permutation coder would only\nspend bits on places where dependencies push things out of the\nexpected order... which is fairly rare.\n\nSeems like a reasonable cost for avoiding the hardfork, no? The\nreceiver topo sort requirement would also require more memory in a\nblock verifier; and would be more complex to fraud proof, I think.\n\nEngineering wise it's not quite so simple. It's helpful for miners to\nhave blocks sorted by feerate so that later stages of the mining\nprocess can drop the least profitable transactions simply by\ntruncating the block.\n\n> [1] Maybe having the shared mempool indexes be sorted rather than FIFO\n>     would make the data structures hard; I don't think so, but not sure.\n\nI tried to get Matt to do that for his stuff previously; pointing out\nthe sorted indexes would be easier to efficiently code. His\ncounterargument was that for 2000 txn, the two bytes indexes take 4kb,\nwhich is pretty insignificant... and that his time would be better\nspent trying to get the hit-rate up. I found that hard to argue with.\n:)\n\n----------\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Mon, Mar 14, 2016 at 3:08 AM\nTo: Gregory Maxwell <gmaxwell at gmail.com>\n\n\nOn Sun, Mar 13, 2016 at 05:06:25AM +0000, Gregory Maxwell wrote:\n> >  - block withholding, so they have more time to build on top of their\n> >    own block, maybe increasing their effective hashrate if they have\n> >    above average connectivity\n> Also called \"selfish mining\".\n\nYup.\n\n> >  c) it seems like it would be possible to adapt the relay protocol into\n> >     a p2p environment to me? [...]\n> That is a bit kludgy, but yes-- it would work.\n> But the key thing about latency minimization is that you _must_ send a\n> block with no request; because otherwise the RTT for just the request\n> alone will totally dominate the transfer in most cases.  And having N\n> peers send you the whole block redundantly ends up hurting your\n> performance (esp because packet losses mean more round trips) even if\n> the compression is very high.\n\nIf the block can be encoded fully, then it's up to maybe 10kB per block\nmax (at 1MB blocksize); I don't think multiple transmissions matter much\nin that case? Hmm, maybe it does...\n\n> All these problems can be avoided; at least in theory. Optimal latency\n> mitigation would be achieved by something like block network coding\n> techniques:\n> https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding\n\nUgh, patents. Interesting that the patents on turbo codes have expired,\nlast time I looked they hadn't.\n\n> With these techniques peers could blindly send you data without you\n> requesting it, while every byte they send would usefully contribute to\n> your reconstruction.\n\nYeah, that makes sense I think. Pretty complicated though. The \"someone\nsent corrupt data\" seems a little bit problematic to deal with too,\nespecially in the \"optimistically forward stuff before you can validate\nit\" phase. At least if you're using error correcting codes anyway,\nthat's probably a self-solving problem.\n\nWhat's with the switch from 32 bit faux ids in the original section\nto 63 bits in the reimagination? I guess you use most of that for the\nadditional encoded length though...\n\nKeying with the previous block's hash seems kind-of painful, doesn't it?\nOnce you receive the ids, you want to lookup the actual transactions\nfrom your mempool, but since you can't decrypt anything useful with\nonly the first 50/60 bits of cyphertext, the only way to do that is\nto have already cycled through all the transactions in your mempool\nand pre-calculated what their network coded id for that block is, and\nyou have to do that everytime you receive a block (including orphans,\nI guess). It'd make reorgs more expensive too, because you'd have to\nreindex all the mempool then as well?\n\nMaybe if you're only doing that predictively it's not so bad? The 5MB-20MB\nof txes with highest fees get coded up, and you just download any other\ntransactions in full? If you're downloading large coinbase txes regularly\nanyway, that's probably no big deal.\n\n> Latency of block relay easily ends up CPU bound; even when not doing\n> anything too smart (this is why Matt's relay protocol stuff has AVX\n> sha2 code in it).\n\nYeah, that seemed a little odd to me; there shouldn't be that much\nhashing to validate a block (1MB of transactions, then maybe 128kB to\nget to sha256d, then another 2*128kB for the rest of the merkle tree?).\nMatt's code seems like it's doing a linear search through the tx index\nto find each tx though, which probably doesn't help.\n\n> Prior IBLT implementation attempts have performance\n> so low that their decode time ends up dwarfing transmission time, and\n> plain uncoded blocks are faster for common host/bandwidth\n> configurations.\n\nHeh.\n\n> The ordering requirements stuff is not that relevant in my view; you\n> likely believe this because Gavin rat-holed himself on it trying to\n> spec out ordering requirements for miners...  The reality of it is\n> that a uniform permutation of, say, 4000 transactions can be stored in\n> log2(4000!)/8 bytes, or about 5.2kbytes\n\nRight, but 5.2 kB is a lot of overhead; at least compared to the cases\nwhere Matt's stuff already works well :)\n\n> Recently some folks have been working privately on a block network\n> coding implementation... earlier attempts (even before IBLT became\n> trendy) were thwarted by the same thing that thwarts IBLT: the\n> decoding was so slow it dominated the latency. We've found some faster\n> coding schemes though...  so it looks like it might be practical now. I\n> could send you more info if you read the block network coding page and\n> are interested in helping.\n\nSure. (Though, fair warning, I've already failed a few times at doing\nanything useful with erasure coding...)\n\n> >  e) for p2p relay, maybe it would make sense to have the protocol only\n> >     allow sending blocks where all the transactions are \"previously\n> >     seen\". that way if you get a block where some txes haven't been\n> >     seen before, you stall that block, and start sending transactions\n> >     through. if another block comes in in the meantime, that doesn't\n> >     have any new transactions, you send that block through straight\naway.\n> >     that encourages sending weak blocks through first, to ensure your\n> >     transactions are already in mempools and no one else can sneak\n> >     in first.\n> Yes, it's perfectly reasonable to do that for bandwidth minimization--\n> though it doesn't minimize latency.  \"Seen\" is complex, you have no\n> guarantee a peer will accept any transaction you've sent it, or even\n> that it will retain any it sent you. So multiple round trips are\n> required to resolve missing transactions.\n\nThe \"p2p relay\" in my head has \"seen\" meaning \"the 5MB of transactions\nthe listening peer thinks is most likely to be mined\", odds on both\npeers have actually seen something like 145MB of additional transactions\ntoo. You don't do round trips; you just start sending the \"unseen\"\ntransactions automatically (by id or in full?), then you send the\ncompressed block. The only round trip is if you sent the id, but they\nactually needed the full tx.\n\nIn my head, you get good latency if you do weak blocks beforehand,\nand somewhat poorer latency if you don't. Even in my head, I'm not sure\nthat's actually feasible, though: I'm not sure weak blocks for coinbase\ntransactions really work, and comparatively high latency on 5% of blocks\nthat didn't get any weak blocks beforehand isn't very attractive...\n\n> We haven't bothered implementing this historically because the\n> bandwidth reduction is small overall, and it's not the right strategy\n> for reducing latency-- the vast majority of bandwidth is eaten by\n> relay. Right now maybe 15% is used by blocks... so at most you'd get a\n> 15% improvement here.\n\nYeah, I'm assuming a non-trivial increase in bandwidth usage compared\nto current relay. Compared to relaying spam transactions (that don't\nget mined prior to expiry), not sure it's significant though.\n\n> > [0] A hard-fork change to have the block merkle tree be ordered by txid,\n> >     and have the transactions topologically sorted before being\nvalidated\n> >     would be kind-of interesting here -- apart from making sorting\n> >     obvious, it'd make it easy to prove that a block doesn't contain a\n> >     transaction. Bit altcoin-y though...\n> If you sort by data (or ID) without requiring the verifier to\n> topologically sort then an efficient permutation coder would only\n> spend bits on places where dependencies push things out of the\n> expected order... which is fairly rare.\n\nReally? I was seeing a lot of transaction chains in the couple of blocks I\nlooked at. Also, you wouldn't get short proofs that a transaction isn't\npresent in a block that way either afaics.\n\n> Seems like a reasonable cost for avoiding the hardfork, no? The\n> receiver topo sort requirement would also require more memory in a\n> block verifier; and would be more complex to fraud proof, I think.\n\nHmm, I think it'd be easy to fraud proof -- just show adjacent merkle\npaths where the results are in the wrong order. Maybe the same's true\nwith the id-order-but-toposorted too -- just show adjacent merkle paths\nwhere the results are in the wrong order, and the later doesn't depend\non the former. I'm not sure that gives a unique sort though (but maybe\nthat doesn't actually matter).\n\n> Engineering wise it's not quite so simple. It's helpful for miners to\n> have blocks sorted by feerate so that later stages of the mining\n> process can drop the least profitable transactions simply by\n> truncating the block.\n\nYeah; not having ordering requirements seems far more practical.\n\n> > [1] Maybe having the shared mempool indexes be sorted rather than FIFO\n> >     would make the data structures hard; I don't think so, but not sure.\n> I tried to get Matt to do that for his stuff previously; pointing out\n> the sorted indexes would be easier to efficiently code. His\n> counterargument was that for 2000 txn, the two bytes indexes take 4kb,\n> which is pretty insignificant... and that his time would be better\n> spent trying to get the hit-rate up. I found that hard to argue with.\n> :)\n\nYeah. Having the bitcoin mempool and fee info (and heck, priority info)\nmore readily available when seeing new transactions and choosing what to\ninclude seems like it'd be helpful here. Seems relatively painful to do\nthat outside of bitcoin though.\n\nCheers,\naj\n\n\n----------\nFrom: Gregory Maxwell <gmaxwell at gmail.com>\nDate: Mon, May 15, 2017 at 8:03 PM\nTo: Anthony Towns <aj at erisian.com.au>\n\n\nI ran into someone proposing the same thing as you. Can I share this\ndiscussion with them? (with the public?)\n\n----------\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Mon, May 15, 2017 at 11:00 PM\nTo: Gregory Maxwell <gmaxwell at gmail.com>\n\n\nYes, go ahead on both counts.\n--\nSent from my phone.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170515/48773e42/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Validationless mining without transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 43254
        }
    },
    {
        "title": "[bitcoin-dev] TXO commitments do not need a soft-fork to be useful",
        "thread_messages": [
            {
                "author": "Alex Mizrahi",
                "date": "2017-05-16T12:15:17",
                "message_text_only": "> Something I've recently realised is that TXO commitments do not need to be\n> implemented as a consensus protocol change to be useful.\n\n\nYou're slow, Peter. I figured this out back in 2013:\n\nhttps://bitcointalk.org/index.php?topic=153662.10\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/4294b4ce/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-16T12:23:53",
                "message_text_only": "On Tue, May 16, 2017 at 03:15:17PM +0300, Alex Mizrahi via bitcoin-dev wrote:\n> > Something I've recently realised is that TXO commitments do not need to be\n> > implemented as a consensus protocol change to be useful.\n> \n> \n> You're slow, Peter. I figured this out back in 2013:\n> \n> https://bitcointalk.org/index.php?topic=153662.10\n\nLol, good job! And you even figured out that lovely \"distributed file system\"\nexplanation first.\n\nThough, it does look like I'm still the person who made it 100% *clear* the\nfirst time - you're explanation is easy to read the wrong way, particularly\nwhen you say:\n\n\"Next time I will teach you how to implement a blockchain-based cryptocurrency\nin such a way that new miners can start mining right away without downloading\nwhole blockchain, stay tuned...\"\n\nAfter all, at the time UTXO commitments had been already discussed. Also,\ntalking about a DHT in relation to this stuff probably made the explanation get\nmissed by some people.\n\n\nUnfortunately, I think this is a good example of how important coming up with\ngood explanations and analogies is. :/\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170516/f98a72c8/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "TXO commitments do not need a soft-fork to be useful",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Alex Mizrahi",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1841
        }
    },
    {
        "title": "[bitcoin-dev] BIP39 (mnemonic seeds) Unicode normalization compatibility issue",
        "thread_messages": [
            {
                "author": "Zach Lym",
                "date": "2017-05-17T17:01:04",
                "message_text_only": "I am working on a replacement for BIP39 and noticed that the password\nsection mandates a Unicode normalization pass but does not prohibit\nunassigned character points.\n\nI believe that this is problematic as newer drafts of Unicode alter the\noutput of normalization passes.  So if a user assigned a password using a\nwallet that linked to Unicode 9 but input a code point reserved in Unicode\n10, updating the wallet to Unicode 10 could incorrectly remap that code\npoint [0].\n\nThank you,\n-Zach Lym\n\nP.S. The relevant RFC on this subject specifies a different normalization\nprocedure [1]\n\n[BIP39]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n[0]: http://unicode.org/reports/tr15/#Stabilized_Strings\n[1]: https://tools.ietf.org/html/rfc7564\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170517/93410416/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP39 (mnemonic seeds) Unicode normalization compatibility issue",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zach Lym"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 936
        }
    },
    {
        "title": "[bitcoin-dev] Treating \u2018ASICBOOST\u2019 as a Security Vulnerability",
        "thread_messages": [
            {
                "author": "Cameron Garnham",
                "date": "2017-05-18T13:44:47",
                "message_text_only": "Hello Bitcoin Development Mailing List,\n\nI wish to explain why the current approach to \u2018ASICBOOST\u2019 dose not comply with our established best practices for security vulnerabilities and suggest what I consider to be an approach closer matching established industry best practices.\n\n\n1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.\n\nThe Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.\n\n\n2.     General ASIC optimisation cannot be considered a Security Vulnerabilities.\n\nQuickly being able to check inputs is not a vulnerability. However, being able to craft inputs that are significantly easier to check than alternative inputs is a vulnerability.\n\n\n3.     We should assign a CVE to the vulnerability exploited by \u2018ASICBOOST\u2019.\n\n\u2018ASICBOOST\u2019 is an attack on this Bitcoin\u2019s security assumptions and should be considered an exploit of the Bitcoin Proof-of-Work Function.\n\nFor a more detailed look at \u2018ASICBOOST\u2019, please have a look at this excellent document by Jeremy Rubin:\nhttp://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n\nThe Bitcoin Community should be able to track the progress of restoring the quality of the Bitcoin Proof-of-Work function to its original assumptions.\n\n\n4.     Work should be taken to prudently and swiftly restore Bitcoins Security Properties.\n\nI recommend the Bitcoin Community fix this vulnerability with expediency.\n\n\n\nCameron.\n\nPS:\n\nWith a soft-fork it probably is possible to completely fix this Proof-of-Work vulnerability.\n\n(Here is my working list of things to do):\n\n1.     Include extra data in the Coinbase Transaction, such as the Witness Root.\n\n2.     Lock the Version. (Use a space in the Coinbase Transaction for signalling future upgrades).\n\n3.     Lock the lower-bits on the Timestamp: Block timestamps only need ~1minute granularity.\n\n4.\tMake a deterministic ordering of transaction chains within a block. (However, I believe this option is more difficult).\n\nOf course, if we have a hard-fork, we should consider the Proof-of-Work internal merkle structure directly."
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-18T13:57:08",
                "message_text_only": "Locking the lower bits on the timestamp will likely break existing\nhardware that relies on being able to roll ntime.\n\nOn Thu, May 18, 2017 at 8:44 AM, Cameron Garnham via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hello Bitcoin Development Mailing List,\n>\n> I wish to explain why the current approach to \u2018ASICBOOST\u2019 dose not comply with our established best practices for security vulnerabilities and suggest what I consider to be an approach closer matching established industry best practices.\n>\n>\n> 1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.\n>\n> The Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.\n>\n>\n> 2.     General ASIC optimisation cannot be considered a Security Vulnerabilities.\n>\n> Quickly being able to check inputs is not a vulnerability. However, being able to craft inputs that are significantly easier to check than alternative inputs is a vulnerability.\n>\n>\n> 3.     We should assign a CVE to the vulnerability exploited by \u2018ASICBOOST\u2019.\n>\n> \u2018ASICBOOST\u2019 is an attack on this Bitcoin\u2019s security assumptions and should be considered an exploit of the Bitcoin Proof-of-Work Function.\n>\n> For a more detailed look at \u2018ASICBOOST\u2019, please have a look at this excellent document by Jeremy Rubin:\n> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n>\n> The Bitcoin Community should be able to track the progress of restoring the quality of the Bitcoin Proof-of-Work function to its original assumptions.\n>\n>\n> 4.     Work should be taken to prudently and swiftly restore Bitcoins Security Properties.\n>\n> I recommend the Bitcoin Community fix this vulnerability with expediency.\n>\n>\n>\n> Cameron.\n>\n> PS:\n>\n> With a soft-fork it probably is possible to completely fix this Proof-of-Work vulnerability.\n>\n> (Here is my working list of things to do):\n>\n> 1.     Include extra data in the Coinbase Transaction, such as the Witness Root.\n>\n> 2.     Lock the Version. (Use a space in the Coinbase Transaction for signalling future upgrades).\n>\n> 3.     Lock the lower-bits on the Timestamp: Block timestamps only need ~1minute granularity.\n>\n> 4.      Make a deterministic ordering of transaction chains within a block. (However, I believe this option is more difficult).\n>\n> Of course, if we have a hard-fork, we should consider the Proof-of-Work internal merkle structure directly.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-18T14:59:50",
                "message_text_only": "On Thu, May 18, 2017 at 2:44 PM, Cameron Garnham via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> 1.     Significant deviations from the Bitcoin Security Model have been\n> acknowledged as security vulnerabilities.\n>\n> The Bitcoin Security Model assumes that every input into the Proof-of-Work\n> function should have the same difficulty of producing a desired output.\n>\n\nThis isn't really that clear.\n\nArguably as long as the effort to find a block is proportional to the block\ndifficulty parameter, then it isn't an exploit.  It is just an optimisation.\n\nA quantum computer, for example, could find a block with effort\nproportional to the square root of the difficulty parameter, so that would\ncount as an attack.  Though in that case, the fix would likely be to tweak\nthe difficulty parameter update calculation.\n\nA better definition would be something like \"when performing work, each\nhash should be independent\".\n\nASICBOOST does multiple checks in parallel, so would violate that.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170518/8af10956/attachment.html>"
            },
            {
                "author": "Cameron Garnham",
                "date": "2017-05-19T07:32:36",
                "message_text_only": "(message was originally sent off-list by mistake).\n\nHello Tier,\n\nThank-you for your insightful reply,\n\nAm I correct that this suggest is that you think it is an optimisation to find some nonces having lower difficulty than other nonces?\n\nI would agree with you if this was limited to a dedicated nonce area of the Bitcoin System.\n\nHowever, in the case of Bitcoin it is a layer violation that the PoW function difficulty could be affected by the choice the transaction ordering, or the content of the Coinbase Transaction, etc.  Possibly giving unnatural and unintended incentives to other parts of the Bitcoin System.\n\nI can see two issues at play here:\n\n1.\tThe choice of input, outside of the dedicated nonce area, fed the PoW function should not change it\u2019s difficulty to evaluate.\n2.\tEvery PoW function execution should be independent.\n\nI think that both of these are security assumptions of the Bitcoin PoW function.\n\nI consider ASICBOOST as an attack upon both accounts.\n\nCameron.\n\n> \n> On 18 May 2017, at 17:59 , Tier Nolan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> On Thu, May 18, 2017 at 2:44 PM, Cameron Garnham via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 1.     Significant deviations from the Bitcoin Security Model have been acknowledged as security vulnerabilities.\n> \n> The Bitcoin Security Model assumes that every input into the Proof-of-Work function should have the same difficulty of producing a desired output.\n> \n> This isn't really that clear.\n> \n> Arguably as long as the effort to find a block is proportional to the block difficulty parameter, then it isn't an exploit.  It is just an optimisation.\n> \n> A quantum computer, for example, could find a block with effort proportional to the square root of the difficulty parameter, so that would count as an attack.  Though in that case, the fix would likely be to tweak the difficulty parameter update calculation.\n> \n> A better definition would be something like \"when performing work, each hash should be independent\".  \n> \n> ASICBOOST does multiple checks in parallel, so would violate that.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/e0038c2d/attachment-0001.html>"
            },
            {
                "author": "Ryan Grant",
                "date": "2017-05-18T19:28:38",
                "message_text_only": "On Thu, May 18, 2017 at 9:44 AM, Cameron Garnham via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 3.     We should assign a CVE to the vulnerability exploited by \u2018ASICBOOST\u2019.\n>\n> \u2018ASICBOOST\u2019 is an attack on this Bitcoin\u2019s security assumptions and\n> should be considered an exploit of the Bitcoin Proof-of-Work\n> Function.\n\nOn Thu, May 18, 2017 at 10:59 AM, Tier Nolan via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Arguably as long as the effort to find a block is proportional to the block\n> difficulty parameter, then it isn't an exploit.  It is just an optimisation.\n\nOne principled way to proceed would be to fault not the exploit, but\nthe protocol design.\n\nBits in the block header have been discovered which could be used for\ndual meanings, and at least one meaning does not preserve the\nincentive balances intended and assumed by others.  This unexpectedly\ncreates an incentive to block protocol improvements.  The protocol\nmust be repaired.\n\nIn this view, which focuses on covert-ASICBOOST, how work is done is\nup to the implementation.  But if the hashing work specified possibly\ncould gain from blocking development work, then we have a\nvulnerability.\n\nI believe this is clear grounds for taking action without any delay."
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-19T07:16:20",
                "message_text_only": "ASIC boost is definitely a protocol vulnerability.\n\nIt makes Bitcoin resistant to current and future modifications which are\nnecessary to preserve decentralization.\n\nThat alone should be enough to prioritize a swift preventative measure.\n\nOn May 18, 2017 3:29 PM, \"Ryan Grant via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nOn Thu, May 18, 2017 at 9:44 AM, Cameron Garnham via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 3.     We should assign a CVE to the vulnerability exploited by\n\u2018ASICBOOST\u2019.\n>\n> \u2018ASICBOOST\u2019 is an attack on this Bitcoin\u2019s security assumptions and\n> should be considered an exploit of the Bitcoin Proof-of-Work\n> Function.\n\nOn Thu, May 18, 2017 at 10:59 AM, Tier Nolan via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Arguably as long as the effort to find a block is proportional to the\nblock\n> difficulty parameter, then it isn't an exploit.  It is just an\noptimisation.\n\nOne principled way to proceed would be to fault not the exploit, but\nthe protocol design.\n\nBits in the block header have been discovered which could be used for\ndual meanings, and at least one meaning does not preserve the\nincentive balances intended and assumed by others.  This unexpectedly\ncreates an incentive to block protocol improvements.  The protocol\nmust be repaired.\n\nIn this view, which focuses on covert-ASICBOOST, how work is done is\nup to the implementation.  But if the hashing work specified possibly\ncould gain from blocking development work, then we have a\nvulnerability.\n\nI believe this is clear grounds for taking action without any delay.\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/08fec7f0/attachment.html>"
            },
            {
                "author": "Cameron Garnham",
                "date": "2017-05-24T17:59:28",
                "message_text_only": "Hello Bitcoin-Dev,\n\nA quick update that CVE-2017-9230 has been assigned for the security vulnerability commonly called \u2018ASICBOOST\u2019:\n\n\"The Bitcoin Proof-of-Work algorithm does not consider a certain attack methodology related to 80-byte block headers with a variety of initial 64-byte chunks followed by the same 16-byte chunk, multiple candidate root values ending with the same 4 bytes, and calculations involving sqrt numbers. This violates the security assumptions of (1) the choice of input, outside of the dedicated nonce area, fed into the Proof-of-Work function should not change its difficulty to evaluate and (2) every Proof-of-Work function execution should be independent.\u201d\n\nI would like to especially thank the CVE team at Mitre for their suggested description that was more appropriate than my proposed text.\n\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230\n\nCameron.\n\n\n\n> Begin forwarded message:\n> \n> From: <cve-request at mitre.org>\n> Subject: Re: [scr-xxxxx] Bitcoin - All\n> Date: 24 May 2017 at 18:52:22 GMT+3\n> To: <da2ce7 at gmail.com>\n> Cc: <cve-request at mitre.org>\n> \n> Signed PGP part\n> > [Suggested description]\n> > The Bitcoin Proof-of-Work algorithm does not consider a certain attack\n> > methodology related to 80-byte block headers with a variety of initial\n> > 64-byte chunks followed by the same 16-byte chunk, multiple candidate\n> > root values ending with the same 4 bytes, and calculations involving\n> > sqrt numbers. This violates the security assumptions of (1) the choice\n> > of input, outside of the dedicated nonce area, fed into the\n> > Proof-of-Work function should not change its difficulty to evaluate\n> > and (2) every Proof-of-Work function execution should be independent.\n> >\n> > ------------------------------------------\n> >\n> > [Additional Information]\n> > ASICBOOST, originality promoted as a patented mining optimisation(1).\n> > Has under detailed study (2), become regarded as an actively exploited\n> > (3), security vulnerability (4), of Bitcoin.\n> >\n> > The Bitcoin Proof-of-Work Algorithm is dependent on the following two\n> > security assumptions that are both broken by 'ASICBOOST':\n> > 1. The choice of input, outside of the dedicated nonce area, fed into\n> > the Proof-of-Work function should not change it's difficulty to\n> > evaluate.\n> > 2.  Every Proof-of-Work function execution should be independent.\n> >\n> > 'ASICBOOST' creates a layer-violation where the structure of the input\n> > outside of the dedicated nonce area will change the performance of the\n> > mining calculations (5). 'ASICBOOST' exploits a vulnerability where\n> > the Proof-of-Work function execution is not independent (6).\n> >\n> > References:\n> > (1) Original Whitepaper by Dr. Timo Hanke: https://arxiv.org/ftp/arxiv/papers/1604/1604.00575.pdf\n> > (2) Academic Write-up by Jeremy Rubin: http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n> > (3) Evidence of Active Exploit by Gregory Maxwell:\n> >  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html\n> > (4) Discussion to assign a CVE Number, by Cameron Garnham:\n> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014349.html\n> > (5) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:\n> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html\n> > (6) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:\n> >   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html\n> >\n> > The patent holder of this particular security vulnerability has a dedicated website: https://www.asicboost.com/\n> >\n> > ------------------------------------------\n> >\n> > [VulnerabilityType Other]\n> > Cryptocurrency Mining Algorithm Weakness\n> >\n> > ------------------------------------------\n> >\n> > [Vendor of Product]\n> > Bitcoin\n> >\n> > ------------------------------------------\n> >\n> > [Affected Product Code Base]\n> > Bitcoin - All\n> >\n> > ------------------------------------------\n> >\n> > [Affected Component]\n> > Bitcoin\n> >\n> > ------------------------------------------\n> >\n> > [Attack Type Other]\n> > Cryptocurrency Proof-of-Work Algorithm Weakness\n> >\n> > ------------------------------------------\n> >\n> > [CVE Impact Other]\n> > Creation of Perverse Incentives in a Cryptocurrency\n> >\n> > ------------------------------------------\n> >\n> > [Attack Vectors]\n> > Bitcoin Mining Unfair Advantage\n> > Bitcoin Layer-Violations Creating Perverse System Incentives\n> >\n> > ------------------------------------------\n> >\n> > [Reference]\n> > https://arxiv.org/ftp/arxiv/papers/1604/1604.00575.pdf\n> > http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014349.html\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html\n> >\n> > ------------------------------------------\n> >\n> > [Has vendor confirmed or acknowledged the vulnerability?]\n> > true\n> >\n> > ------------------------------------------\n> >\n> > [Discoverer]\n> > Original Discovery: Dr. Timo Hanke and Sergio Lerner. Proof of Active\n> > Exploit: Gregory Maxwell. CVE Reporter: Cameron Garnham\n> \n> Use CVE-2017-9230.\n> \n> \n> --\n> CVE Assignment Team\n> M/S M300, 202 Burlington Road, Bedford, MA 01730 USA\n> [ A PGP key is available for encrypted communications at\n>   http://cve.mitre.org/cve/request_id.html ]\n>"
            }
        ],
        "thread_summary": {
            "title": "Treating \u2018ASICBOOST\u2019 as a Security Vulnerability",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "James Hilliard",
                "Tier Nolan",
                "Erik Aronesty",
                "Cameron Garnham"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 17130
        }
    },
    {
        "title": "[bitcoin-dev] A proposal to reintroduce the disabled script opcodes",
        "thread_messages": [
            {
                "author": "Mark Boldyrev",
                "date": "2017-05-19T06:07:41",
                "message_text_only": "Back in 2010, there was a bug found in Core which allowed denial-of-service\nattacks due to the software crashing on some machines while executing a\nscript - see CVE-2010-537.\nI believe the removed (\"disabled\") opcodes should be re-introduced along\nwith a standardized behavior definition.\nFor example, when execution of an opcode results in an arithmetic error,\nsuch as OP_DIV with a zero divisor, the script should exit and fail.\nThe string splice opcodes should also check their arguments for\ncorrectness, etc.\n\nThese opcodes would enhance the flexibility of scripts and allow\nsophisticated native smart contracts to be created.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/6209b7a2/attachment.html>"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2017-05-19T13:13:03",
                "message_text_only": "AFAICT, re-enabling these old OP-codes would require a hardfork.\n\nIf we had SegWit enabled, we could via a soft fork allocate new OP-codes\nfor the same functionality (by introducing a new version of Script).\nI believe the Elements alpha project has been experimenting with\nre-enabling old OP-codes: https://elementsproject.org/elements/opcodes/\n\n2017-05-19 8:07 GMT+02:00 Mark Boldyrev via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Back in 2010, there was a bug found in Core which allowed\n> denial-of-service attacks due to the software crashing on some machines\n> while executing a script - see CVE-2010-537.\n> I believe the removed (\"disabled\") opcodes should be re-introduced along\n> with a standardized behavior definition.\n> For example, when execution of an opcode results in an arithmetic error,\n> such as OP_DIV with a zero divisor, the script should exit and fail.\n> The string splice opcodes should also check their arguments for\n> correctness, etc.\n>\n> These opcodes would enhance the flexibility of scripts and allow\n> sophisticated native smart contracts to be created.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170519/9dd5d326/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-22T14:09:19",
                "message_text_only": "On Fri, May 19, 2017 at 09:07:41AM +0300, Mark Boldyrev via bitcoin-dev wrote:\n> Back in 2010, there was a bug found in Core which allowed denial-of-service\n> attacks due to the software crashing on some machines while executing a\n> script - see CVE-2010-537.\n> I believe the removed (\"disabled\") opcodes should be re-introduced along\n> with a standardized behavior definition.\n> For example, when execution of an opcode results in an arithmetic error,\n> such as OP_DIV with a zero divisor, the script should exit and fail.\n> The string splice opcodes should also check their arguments for\n> correctness, etc.\n> \n> These opcodes would enhance the flexibility of scripts and allow\n> sophisticated native smart contracts to be created.\n\nIt'd help your case if you gave us some examples of such scripts being used.\n\nSee the CHECKSEQUENCEVERIFY and my own CHECKLOCKTIMEVERIFY bips for examples of\nhow to write up such use-cases.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/91bc394e/attachment.sig>"
            },
            {
                "author": "Ethan Heilman",
                "date": "2017-05-22T14:41:40",
                "message_text_only": ">It'd help your case if you gave us some examples of such scripts being\nused.\n\nI want OP_CAT so that I can securely and compactly verify many hashes and\nhash preimages. This would shrink offchain Tumblebit transactions\nsignificantly.\n\nFor instance if I want a transaction TxA which checks that a transaction\nTxB releases preimages x1,x2,...,x10 such that\ny1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check\nthat the preimahes hash correctly. With OP_CAT I would only have to store\none hash in TxA, yhash\n\nytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)\n\nTxA could then just hash all the preimages supplied by TxB and confirm they\nhash to TxA. This would reduce the size of TxA from approx 10*32B to\n32+10*16B. I have a version which improves this further but it is more\ncomplex.\n\nMost of the math OP codes aren't particularly helpful due to their 32bit\nnature and their strange overflow behavior.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/7a13e539/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-22T16:14:04",
                "message_text_only": "On Mon, May 22, 2017 at 10:41:40AM -0400, Ethan Heilman wrote:\n> >It'd help your case if you gave us some examples of such scripts being\n> used.\n> \n> I want OP_CAT so that I can securely and compactly verify many hashes and\n> hash preimages. This would shrink offchain Tumblebit transactions\n> significantly.\n> \n> For instance if I want a transaction TxA which checks that a transaction\n> TxB releases preimages x1,x2,...,x10 such that\n> y1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check\n> that the preimahes hash correctly. With OP_CAT I would only have to store\n> one hash in TxA, yhash\n> \n> ytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)\n> \n> TxA could then just hash all the preimages supplied by TxB and confirm they\n> hash to TxA. This would reduce the size of TxA from approx 10*32B to\n> 32+10*16B. I have a version which improves this further but it is more\n> complex.\n> \n> Most of the math OP codes aren't particularly helpful due to their 32bit\n> nature and their strange overflow behavior.\n\nGreat! That's exactly the type of justifying use-case we need for a BIP.\n\nAn OP_CAT will have to have limits on maximum output size; how big an output\ndoes your application need?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/5c5d8739/attachment.sig>"
            },
            {
                "author": "Ethan Heilman",
                "date": "2017-05-22T16:43:11",
                "message_text_only": "My OP_CAT usecase only needs to glue together hash outputs, so two 32\nBytes inputs generating a 64 Byte output. However increasing this\nwould enable additional space savings. I would push for an OP_CAT\nwhich can generate an output of no greater than 512 Bytes. Is there\nare maximum byte vectors size for script?\n\nThe ideal instruction for this usecase be an instruction that pops N\nvectors of the stack, concatenates them together and hashes them.\nOP_CATHASH256(N) --> OP_HASH256(v1||v2||..||vN)\nwhere || denotes concatenation. You could do this in a streaming\nfashion so that memory usage would never exceed 32 Bytes regardless of\nthe size of the input vectors.\n\nHowever I recognize that OP_CAT is more generally useful and it\nalready in scripts but just disabled.\n\n\n\n\nOn Mon, May 22, 2017 at 12:14 PM, Peter Todd <pete at petertodd.org> wrote:\n> On Mon, May 22, 2017 at 10:41:40AM -0400, Ethan Heilman wrote:\n>> >It'd help your case if you gave us some examples of such scripts being\n>> used.\n>>\n>> I want OP_CAT so that I can securely and compactly verify many hashes and\n>> hash preimages. This would shrink offchain Tumblebit transactions\n>> significantly.\n>>\n>> For instance if I want a transaction TxA which checks that a transaction\n>> TxB releases preimages x1,x2,...,x10 such that\n>> y1=H(x1), y2=H(x2),...,y10=H(x10). Currently I just put y1,...y10 and check\n>> that the preimahes hash correctly. With OP_CAT I would only have to store\n>> one hash in TxA, yhash\n>>\n>> ytotal = H(OP_CAT(H(OP_CAT(y1, y2)),y3)...y10)\n>>\n>> TxA could then just hash all the preimages supplied by TxB and confirm they\n>> hash to TxA. This would reduce the size of TxA from approx 10*32B to\n>> 32+10*16B. I have a version which improves this further but it is more\n>> complex.\n>>\n>> Most of the math OP codes aren't particularly helpful due to their 32bit\n>> nature and their strange overflow behavior.\n>\n> Great! That's exactly the type of justifying use-case we need for a BIP.\n>\n> An OP_CAT will have to have limits on maximum output size; how big an output\n> does your application need?\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org"
            }
        ],
        "thread_summary": {
            "title": "A proposal to reintroduce the disabled script opcodes",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Mark Boldyrev",
                "Hampus Sj\u00f6berg",
                "Ethan Heilman",
                "Peter Todd"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 8319
        }
    },
    {
        "title": "[bitcoin-dev] BIP135 implementation on Bitcoin Core available for review",
        "thread_messages": [
            {
                "author": "Sancho Panza",
                "date": "2017-05-21T11:57:10",
                "message_text_only": "I'm pleased to announce the completion of a Bitcoin Core implementation of BIP135:\n\nhttps://github.com/bitcoin/bitcoin/pull/10437\n\nReview comments appreciated, and happy to discuss / answer questions about the implementation in this thread or on Github.\n\nSancho\n\nBIP135: https://github.com/bitcoin/bips/blob/master/bip-0135.mediawiki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170521/8ec03f0b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP135 implementation on Bitcoin Core available for review",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Sancho Panza"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 516
        }
    },
    {
        "title": "[bitcoin-dev] Barry Silbert segwit agreement",
        "thread_messages": [
            {
                "author": "shaolinfry",
                "date": "2017-05-22T06:12:08",
                "message_text_only": "Someone sent me a copy of the Barry Silbert agreement, an agreement forged between a select number of participants https://pastebin.com/VuCYteJh\n\nParticipants agree to immediately activate Segwit, however, under a different activation proposal. Since I have spent the last few months researching various activation strategies of the current BIP141 deployment, as well as redeployment, I feel I am quite well placed to comment on the technicalities.\n\nTo be clear, the proposal as far as I can see does not activate BIP141, but is a completely new deployment which would be incompatible with the BIP141 deployment. I'm not sure how that can be considered \"immediate\" activation. Surely immediate activation would just be for miners to start signalling and segwit would be activated in 4-5 weeks. The proposal seems to require a lower 80% threshold, I assume because they were unable to convince 95% of the hashpower to go trigger activation.\n\nThere are a few options to activating segwit now, the first being for 95% of hashrate to signal. The second is for the community to deploy BIP148 UASF which will force miners to signal segwit. Being a UASF it is date triggered. The third option is a redeployment of segwit on a new bit, but requires waiting for the existing deployment to time out, because all the p2p messages and service bits related to segwit must be replaced too (which is what BIP149 does).\n\nA fourth option, first suggested to me by James Hilliard, was to make BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded this up a few weeks ago https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal but didnt get around to posting to the ML yet. This effectively lowers the threshold from 95% to 65% as coded, or could be upped to 80% or whatever was preferable.\n\nI think this removes the primary risk of BIP148 causing the creation of two chains, and gives an improved chance to get segwit activated quickly (assuming a majority of miners wish to go this route). But hash a primary disadvantage of still leaving the activation in the hands of miners. If it doesn't work out, then BIP149 can then be used as proposed, but it'll be even safer because we'll have futher guaged support.\n\nReferences:\n\nSEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal\nBIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\nBIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki\n\nI think the Barry Silbert agreement is very ill considered, and clearly lacking peer review from the technical community. Suggestions of a HF in 4 months are completely unrealistic and without technical merits. But more importantly, closed door agreements between selected participants is not how to garner consensus to change a $30bn decentralized system. The purpose of my email is to try and assist in the \"immediate activation of segwit\" which only requires hashrate to participate; and to provide some techincal input since I have done a great deal of research and development into the topic.\n\nGiven the history we've already passed the point where we should be expecting miners to cooperate in lowering their own fee income with a capacity increase; but we should be open to all reasonable options in the interest in moving things forward in a safe and collaborative way.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/795810e9/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-22T06:27:04",
                "message_text_only": "On Mon, May 22, 2017 at 02:12:08AM -0400, shaolinfry via bitcoin-dev wrote:\n> Someone sent me a copy of the Barry Silbert agreement, an agreement forged between a select number of participants https://pastebin.com/VuCYteJh\n\nIt's interesting how changing the bit used to signal could be used as a way to\ntry to trick people into changing node software ASAP to support the hard-fork\ncode. Basically, the narrative would be that other software *doesn't* support\nsegwit, so you have to upgrade right away.\n\n> A fourth option, first suggested to me by James Hilliard, was to make BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded this up a few weeks ago https://github.com/bitcoin/bitcoin/compare/master...shaolinfry:segsignal but didnt get around to posting to the ML yet. This effectively lowers the threshold from 95% to 65% as coded, or could be upped to 80% or whatever was preferable.\n\nIn contrast this proposal wouldn't have that effect, because as you point out\nit's compatibel with the existing segwit protocol once activated.\n\nSmells like political engineering to me.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/69af6329/attachment.sig>"
            },
            {
                "author": "Hampus Sj\u00f6berg",
                "date": "2017-05-22T09:23:22",
                "message_text_only": "I'm really happy to see people trying to cooperate to get SegWit activated.\nBut I'm really unsure about the technicalities about Silbert's proposal.\n\nIf we're going to do a hardfork, it makes most sense to assist Johnson in\nhis spoonnet/forcenet proposals.\nJust doing a simple 2MB without fixing anything else is very uninteresting,\nand a hardfork without addressing replay protection seems really\nunprofessional to me.\nAnd proposing a hardfork in 4 months in the future, is completely insane.\nYou cannot expect a 100% of all nodes in P2P network to upgrade in 4 months.\n\nI think it's much better to activate BIP141 ASAP, and then hardfork to 2MB\nSeptember 2018, or 2019 (together with forcenet/spoonnet).\nAnd if not, BIP148 is gaining momentum once again so that sounds much more\ninteresting.\n\nHampus\n\n2017-05-22 8:12 GMT+02:00 shaolinfry via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n> Someone sent me a copy of the Barry Silbert agreement, an agreement forged\n> between a select number of participants https://pastebin.com/VuCYteJh\n>\n> Participants agree to immediately activate Segwit, however, under a\n> different activation proposal. Since I have spent the last few months\n> researching various activation strategies of the current BIP141 deployment,\n> as well as redeployment, I feel I am quite well placed to comment on the\n> technicalities.\n>\n> To be clear, the proposal as far as I can see does not activate BIP141,\n> but is a completely new deployment which would be incompatible with the\n> BIP141 deployment. I'm not sure how that can be considered \"immediate\"\n> activation. Surely immediate activation would just be for miners to start\n> signalling and segwit would be activated in 4-5 weeks. The proposal seems\n> to require a lower 80% threshold, I assume because they were unable to\n> convince 95% of the hashpower to go trigger activation.\n>\n> There are a few options to activating segwit now, the first being for 95%\n> of hashrate to signal. The second is for the community to deploy BIP148\n> UASF which will force miners to signal segwit. Being a UASF it is date\n> triggered. The third option is a redeployment of segwit on a new bit, but\n> requires waiting for the existing deployment to time out, because all the\n> p2p messages and service bits related to segwit must be replaced too (which\n> is what BIP149 does).\n>\n> A fourth option, first suggested to me by James Hilliard, was to make\n> BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded\n> this up a few weeks ago https://github.com/bitcoin/\n> bitcoin/compare/master...shaolinfry:segsignal but didnt get around to\n> posting to the ML yet. This effectively lowers the threshold from 95% to\n> 65% as coded, or could be upped to 80% or whatever was preferable.\n>\n> I think this removes the primary risk of BIP148 causing the creation of\n> two chains, and gives an improved chance to get segwit activated quickly\n> (assuming a majority of miners wish to go this route). But hash a primary\n> disadvantage of still leaving the activation in the hands of miners. If it\n> doesn't work out, then BIP149 can then be used as proposed, but it'll be\n> even safer because we'll have futher guaged support.\n>\n> References:\n>\n> SEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...\n> shaolinfry:segsignal\n> BIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\n> BIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki\n>\n> I think the Barry Silbert agreement is very ill considered, and clearly\n> lacking peer review from the technical community. Suggestions of a HF in 4\n> months are completely unrealistic and without technical merits. But more\n> importantly, closed door agreements between selected participants is not\n> how to garner consensus to change a $30bn decentralized system. The purpose\n> of my email is to try and assist in the \"immediate activation of segwit\"\n> which only requires hashrate to participate; and to provide some techincal\n> input since I have done a great deal of research and development into the\n> topic.\n>\n> Given the history we've already passed the point where we should be\n> expecting miners to cooperate in lowering their own fee income with a\n> capacity increase; but we should be open to all reasonable options in the\n> interest in moving things forward in a safe and collaborative way.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/e17e2ba4/attachment.html>"
            },
            {
                "author": "Daniele Pinna",
                "date": "2017-05-22T12:29:12",
                "message_text_only": "I couldn't agree more. It would require however for the Devs to throw their\nweight behind this with a lot of momentum. Spoonnet has been under\ndevelopment for quite some time now. Counter offering SegWit plus Spoonnet\n12-24 months later would be a very progressive stance that I think would\ncatch the interest of large swaths of the community. I'd be curious to hear\nJohnson's opinion on this. How much more testing would his proposal require?\n\nDaniele\n\n\n----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Mon, 22 May 2017 11:23:22 +0200\n> From: Hampus Sj?berg <hampus.sjoberg at gmail.com>\n> To: shaolinfry <shaolinfry at protonmail.ch>\n> Cc: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: Re: [bitcoin-dev] Barry Silbert segwit agreement\n> Message-ID:\n>         <CAFMkqK_8CfaPmZgwMqGWpRujmmyGKXhZyxK_\n> tQ6f1OMHKdEMJA at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> I'm really happy to see people trying to cooperate to get SegWit activated.\n> But I'm really unsure about the technicalities about Silbert's proposal.\n>\n> If we're going to do a hardfork, it makes most sense to assist Johnson in\n> his spoonnet/forcenet proposals.\n> Just doing a simple 2MB without fixing anything else is very uninteresting,\n> and a hardfork without addressing replay protection seems really\n> unprofessional to me.\n> And proposing a hardfork in 4 months in the future, is completely insane.\n> You cannot expect a 100% of all nodes in P2P network to upgrade in 4\n> months.\n>\n> I think it's much better to activate BIP141 ASAP, and then hardfork to 2MB\n> September 2018, or 2019 (together with forcenet/spoonnet).\n> And if not, BIP148 is gaining momentum once again so that sounds much more\n> interesting.\n>\n> Hampus\n>\n> 2017-05-22 8:12 GMT+02:00 shaolinfry via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n> > Someone sent me a copy of the Barry Silbert agreement, an agreement\n> forged\n> > between a select number of participants https://pastebin.com/VuCYteJh\n> >\n> > Participants agree to immediately activate Segwit, however, under a\n> > different activation proposal. Since I have spent the last few months\n> > researching various activation strategies of the current BIP141\n> deployment,\n> > as well as redeployment, I feel I am quite well placed to comment on the\n> > technicalities.\n> >\n> > To be clear, the proposal as far as I can see does not activate BIP141,\n> > but is a completely new deployment which would be incompatible with the\n> > BIP141 deployment. I'm not sure how that can be considered \"immediate\"\n> > activation. Surely immediate activation would just be for miners to start\n> > signalling and segwit would be activated in 4-5 weeks. The proposal seems\n> > to require a lower 80% threshold, I assume because they were unable to\n> > convince 95% of the hashpower to go trigger activation.\n> >\n> > There are a few options to activating segwit now, the first being for 95%\n> > of hashrate to signal. The second is for the community to deploy BIP148\n> > UASF which will force miners to signal segwit. Being a UASF it is date\n> > triggered. The third option is a redeployment of segwit on a new bit, but\n> > requires waiting for the existing deployment to time out, because all the\n> > p2p messages and service bits related to segwit must be replaced too\n> (which\n> > is what BIP149 does).\n> >\n> > A fourth option, first suggested to me by James Hilliard, was to make\n> > BIP148 miner triggered (MASF) with a lower threshold, above 50%. I coded\n> > this up a few weeks ago https://github.com/bitcoin/\n> > bitcoin/compare/master...shaolinfry:segsignal but didnt get around to\n> > posting to the ML yet. This effectively lowers the threshold from 95% to\n> > 65% as coded, or could be upped to 80% or whatever was preferable.\n> >\n> > I think this removes the primary risk of BIP148 causing the creation of\n> > two chains, and gives an improved chance to get segwit activated quickly\n> > (assuming a majority of miners wish to go this route). But hash a primary\n> > disadvantage of still leaving the activation in the hands of miners. If\n> it\n> > doesn't work out, then BIP149 can then be used as proposed, but it'll be\n> > even safer because we'll have futher guaged support.\n> >\n> > References:\n> >\n> > SEGSIGNAL: https://github.com/bitcoin/bitcoin/compare/master...\n> > shaolinfry:segsignal\n> > BIP148: https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\n> > BIP149: https://github.com/bitcoin/bips/blob/master/bip-0149.mediawiki\n> >\n> > I think the Barry Silbert agreement is very ill considered, and clearly\n> > lacking peer review from the technical community. Suggestions of a HF in\n> 4\n> > months are completely unrealistic and without technical merits. But more\n> > importantly, closed door agreements between selected participants is not\n> > how to garner consensus to change a $30bn decentralized system. The\n> purpose\n> > of my email is to try and assist in the \"immediate activation of segwit\"\n> > which only requires hashrate to participate; and to provide some\n> techincal\n> > input since I have done a great deal of research and development into the\n> > topic.\n> >\n> > Given the history we've already passed the point where we should be\n> > expecting miners to cooperate in lowering their own fee income with a\n> > capacity increase; but we should be open to all reasonable options in the\n> > interest in moving things forward in a safe and collaborative way.\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/7b48551a/attachment.html>"
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2017-05-26T17:47:11",
                "message_text_only": "Forgive me if this is a dumb question.  Suppose that rather than directly\nactivating segwit, the Silbert/NYC Segwit2MB proposal's lock-in just\ntriggered BIP141 signaling (plus later HF).  Would that avoid\nincompatibility with existing BIP141 nodes, and get segwit activated\nsooner?  Eg:\n\n- Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support for\n\"segwit now, HF (TBD) at scheduled date (Nov 23?)\"\n- If bit 4 support reaches 80%, it locks in two things: the scheduled HF\n(conditional on segwit), and *immediately* turning on bit 1 (BIP141 support)\n\nI realize this would still leave problems like the aggressive HF schedule,\npossible chain split at the HF date between Segwit2MB nodes and any\nremaining BIP141 nodes, etc.  My focus here is how incompatibility with\nexisting nodes could be minimized.\n\n(BIP91 could also be used if BIP141 support still fell short of 95%.  But\nif Segwit2MB support reaches 80%, it seems likely that an additional 15%\nwill support BIP141-without-HF.)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/d6a31f4d/attachment.html>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-26T18:48:32",
                "message_text_only": "On Friday, 26 May 2017 19:47:11 CEST Jacob Eliosoff via bitcoin-dev wrote:\n> Forgive me if this is a dumb question.\n\nSorry for picking your email.\n\nI understand people want something different for the agreement, I know I do \ntoo.\nWe have a specific agreement on the table, signed by a huge subsection of the \nindustry.\n\nMaybe the time for changing things is not to be *after* the signatures are \nset. I know I\u2019d change some detials. But do we really want to go through \nanother conference where all the important people are present to agree on a \ncompromise? Or can we use the one we have?\n\nThe compromise is pretty simple;\nhttps://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77\n\n*  Activate Segregated Witness at an 80% threshold, signaling at bit 4\n*  Activate a 2 MB hard fork within six months\n\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-26T20:02:41",
                "message_text_only": "Your proposal seems to be simply BIP 91 tied to the\nas-yet-entirely-undefined hard fork Barry et al proposed.\n\nUsing James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as\nyou propose, would make the deployment on the incredibly short timeline\nBarry et al proposed slightly more realistic, though I would expect to\nsee hard fork code readily available and well-tested at this point in\norder to meet that timeline.\n\nUltimately, due to their aggressive timeline, the Barry et al proposal\nis incredibly unlikely to meet the requirements of a\nmulti-billion-dollar system, and continued research into meeting the\nspirit, not the text, of their agreement seems warranted.\n\nMatt\n\nOn 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:\n> Forgive me if this is a dumb question.  Suppose that rather than\n> directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in\n> just triggered BIP141 signaling (plus later HF).  Would that avoid\n> incompatibility with existing BIP141 nodes, and get segwit activated\n> sooner?  Eg:\n> \n> - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support\n> for \"segwit now, HF (TBD) at scheduled date (Nov 23?)\"\n> - If bit 4 support reaches 80%, it locks in two things: the scheduled HF\n> (conditional on segwit), and *immediately* turning on bit 1 (BIP141 support)\n> \n> I realize this would still leave problems like the aggressive HF\n> schedule, possible chain split at the HF date between Segwit2MB nodes\n> and any remaining BIP141 nodes, etc.  My focus here is how\n> incompatibility with existing nodes could be minimized.\n> \n> (BIP91 could also be used if BIP141 support still fell short of 95%. \n> But if Segwit2MB support reaches 80%, it seems likely that an additional\n> 15% will support BIP141-without-HF.)\n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2017-05-26T20:10:38",
                "message_text_only": "Just to clarify one thing, what I described differs from BIP91 in that\nthere's no orphaning.  Just when Segwit2MB support reaches 80%, those 80%\njoin everyone else in signaling for BIP141.  BIP91 orphaning is an optional\naddition but my guess is it wouldn't be needed.\n\n\nOn May 26, 2017 4:02 PM, \"Matt Corallo\" <lf-lists at mattcorallo.com> wrote:\n\n> Your proposal seems to be simply BIP 91 tied to the\n> as-yet-entirely-undefined hard fork Barry et al proposed.\n>\n> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as\n> you propose, would make the deployment on the incredibly short timeline\n> Barry et al proposed slightly more realistic, though I would expect to\n> see hard fork code readily available and well-tested at this point in\n> order to meet that timeline.\n>\n> Ultimately, due to their aggressive timeline, the Barry et al proposal\n> is incredibly unlikely to meet the requirements of a\n> multi-billion-dollar system, and continued research into meeting the\n> spirit, not the text, of their agreement seems warranted.\n>\n> Matt\n>\n> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:\n> > Forgive me if this is a dumb question.  Suppose that rather than\n> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in\n> > just triggered BIP141 signaling (plus later HF).  Would that avoid\n> > incompatibility with existing BIP141 nodes, and get segwit activated\n> > sooner?  Eg:\n> >\n> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support\n> > for \"segwit now, HF (TBD) at scheduled date (Nov 23?)\"\n> > - If bit 4 support reaches 80%, it locks in two things: the scheduled HF\n> > (conditional on segwit), and *immediately* turning on bit 1 (BIP141\n> support)\n> >\n> > I realize this would still leave problems like the aggressive HF\n> > schedule, possible chain split at the HF date between Segwit2MB nodes\n> > and any remaining BIP141 nodes, etc.  My focus here is how\n> > incompatibility with existing nodes could be minimized.\n> >\n> > (BIP91 could also be used if BIP141 support still fell short of 95%.\n> > But if Segwit2MB support reaches 80%, it seems likely that an additional\n> > 15% will support BIP141-without-HF.)\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/b8000d3a/attachment.html>"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-26T21:30:37",
                "message_text_only": "Mandatory signalling is the only way to lock in segwit with less than\n95% hashpower without a full redeployment(which for a number of\ntechnical reasons isn't feasible until after the existing segwit\ndeployment expires). There's no reason not to signal BIP141 bit 1\nwhile also signalling bit 4, but you would want to use bit 4 to\ncoordinate bit 1 mandatory signalling.\n\nIt would not be feasible to schedule any HF until one can be\ncompletely sure BIP141 is active(at least not without waiting for the\ntimeout and doing a redeployment) due to activation/p2p codepath\ncomplexity. This is why the mandatory signalling period is needed.\n\nSince it is likely a HF will take months of development and testing I\nsee this or something similar as the fastest safe path forward:\n1. Use BIP91 or similar to activate BIP141 via mandatory signalling\nASAP(likely using bit 4)\n2. Develop HF code based on assumption that BIP141 is active so that\nyou only have to test the BIP141->HF upgrade/activation codepath.\n3. Deploy HF after BIP141 lock in(bit 4 can be reused again here since\nthis will be after BIP91 expiration)\n\nWhen rolling out some features it often makes sense to combine them\ninto a single fork for example BIP's 68, 112, 113 were rolled out at\nthe same time as are BIP's 141, 143, 144, 145 for segwit, however a HF\nhas required features that would conflict with with features in the\nsegwit rollout which is why attempting to simultaneously deploy them\nwould cause major complexity/testing issues(you would have to deal\nwith feature conflict resolution for multiple potential activation\nscenarios). By doing a staged rollout of segwit and then a HF you get\na single testable upgrade path.\n\nBased on past development experiences I wouldn't expect a 6 month\ntimeline to be realistic for a properly tested HF, but this proposed\nupgrade path should be the fastest available for both SegWit and a HF\nregardless.\n\nOn Fri, May 26, 2017 at 4:10 PM, Jacob Eliosoff via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Just to clarify one thing, what I described differs from BIP91 in that\n> there's no orphaning.  Just when Segwit2MB support reaches 80%, those 80%\n> join everyone else in signaling for BIP141.  BIP91 orphaning is an optional\n> addition but my guess is it wouldn't be needed.\n>\n>\n> On May 26, 2017 4:02 PM, \"Matt Corallo\" <lf-lists at mattcorallo.com> wrote:\n>>\n>> Your proposal seems to be simply BIP 91 tied to the\n>> as-yet-entirely-undefined hard fork Barry et al proposed.\n>>\n>> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal, as\n>> you propose, would make the deployment on the incredibly short timeline\n>> Barry et al proposed slightly more realistic, though I would expect to\n>> see hard fork code readily available and well-tested at this point in\n>> order to meet that timeline.\n>>\n>> Ultimately, due to their aggressive timeline, the Barry et al proposal\n>> is incredibly unlikely to meet the requirements of a\n>> multi-billion-dollar system, and continued research into meeting the\n>> spirit, not the text, of their agreement seems warranted.\n>>\n>> Matt\n>>\n>> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:\n>> > Forgive me if this is a dumb question.  Suppose that rather than\n>> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in\n>> > just triggered BIP141 signaling (plus later HF).  Would that avoid\n>> > incompatibility with existing BIP141 nodes, and get segwit activated\n>> > sooner?  Eg:\n>> >\n>> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support\n>> > for \"segwit now, HF (TBD) at scheduled date (Nov 23?)\"\n>> > - If bit 4 support reaches 80%, it locks in two things: the scheduled HF\n>> > (conditional on segwit), and *immediately* turning on bit 1 (BIP141\n>> > support)\n>> >\n>> > I realize this would still leave problems like the aggressive HF\n>> > schedule, possible chain split at the HF date between Segwit2MB nodes\n>> > and any remaining BIP141 nodes, etc.  My focus here is how\n>> > incompatibility with existing nodes could be minimized.\n>> >\n>> > (BIP91 could also be used if BIP141 support still fell short of 95%.\n>> > But if Segwit2MB support reaches 80%, it seems likely that an additional\n>> > 15% will support BIP141-without-HF.)\n>> >\n>> >\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> >\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-26T22:12:49",
                "message_text_only": "On Friday, 26 May 2017 23:30:37 CEST James Hilliard via bitcoin-dev wrote:\n> It would not be feasible to schedule any HF until one can be\n> completely sure BIP141 is active\n\nwhy?\n\n> Since it is likely a HF will take months of development and testing I\n> see this or something similar as the fastest safe path forward\n\nThis should not be an issue, it started 2 years ago. Its tested.\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-26T22:44:44",
                "message_text_only": "While I'm not 100% convinced there are strict technical reasons for needing to wait till after segwit is active before a hard fork can be started (you can, after all, activate segwit as a part of the HF), there are useful design and conservatism reasons (not causing massive discontinuity in fee market, handling major system changes one at a time, etc).\n\nStill, totally agree that attempting to design, code, and test a new hard fork in six months, let alone deploy it, let alone simultaneously with segwit, is a joke and fails to take seriously the investment many have made in the bitcoin system. Previous, rather simple, soft forks required similar if not more development time, not counting deployment and activation time.\n\nIf the community is unable to form consensus around segwit alone for political reasons, further research into hard fork design may help, but even forks tied together would nearly certainly need to activate months apart.\n\nOn May 26, 2017 5:30:37 PM EDT, James Hilliard <james.hilliard1 at gmail.com> wrote:\n>Mandatory signalling is the only way to lock in segwit with less than\n>95% hashpower without a full redeployment(which for a number of\n>technical reasons isn't feasible until after the existing segwit\n>deployment expires). There's no reason not to signal BIP141 bit 1\n>while also signalling bit 4, but you would want to use bit 4 to\n>coordinate bit 1 mandatory signalling.\n>\n>It would not be feasible to schedule any HF until one can be\n>completely sure BIP141 is active(at least not without waiting for the\n>timeout and doing a redeployment) due to activation/p2p codepath\n>complexity. This is why the mandatory signalling period is needed.\n>\n>Since it is likely a HF will take months of development and testing I\n>see this or something similar as the fastest safe path forward:\n>1. Use BIP91 or similar to activate BIP141 via mandatory signalling\n>ASAP(likely using bit 4)\n>2. Develop HF code based on assumption that BIP141 is active so that\n>you only have to test the BIP141->HF upgrade/activation codepath.\n>3. Deploy HF after BIP141 lock in(bit 4 can be reused again here since\n>this will be after BIP91 expiration)\n>\n>When rolling out some features it often makes sense to combine them\n>into a single fork for example BIP's 68, 112, 113 were rolled out at\n>the same time as are BIP's 141, 143, 144, 145 for segwit, however a HF\n>has required features that would conflict with with features in the\n>segwit rollout which is why attempting to simultaneously deploy them\n>would cause major complexity/testing issues(you would have to deal\n>with feature conflict resolution for multiple potential activation\n>scenarios). By doing a staged rollout of segwit and then a HF you get\n>a single testable upgrade path.\n>\n>Based on past development experiences I wouldn't expect a 6 month\n>timeline to be realistic for a properly tested HF, but this proposed\n>upgrade path should be the fastest available for both SegWit and a HF\n>regardless.\n>\n>On Fri, May 26, 2017 at 4:10 PM, Jacob Eliosoff via bitcoin-dev\n><bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Just to clarify one thing, what I described differs from BIP91 in\n>that\n>> there's no orphaning.  Just when Segwit2MB support reaches 80%, those\n>80%\n>> join everyone else in signaling for BIP141.  BIP91 orphaning is an\n>optional\n>> addition but my guess is it wouldn't be needed.\n>>\n>>\n>> On May 26, 2017 4:02 PM, \"Matt Corallo\" <lf-lists at mattcorallo.com>\n>wrote:\n>>>\n>>> Your proposal seems to be simply BIP 91 tied to the\n>>> as-yet-entirely-undefined hard fork Barry et al proposed.\n>>>\n>>> Using James' BIP 91 instead of the Barry-bit-4/5/whatever proposal,\n>as\n>>> you propose, would make the deployment on the incredibly short\n>timeline\n>>> Barry et al proposed slightly more realistic, though I would expect\n>to\n>>> see hard fork code readily available and well-tested at this point\n>in\n>>> order to meet that timeline.\n>>>\n>>> Ultimately, due to their aggressive timeline, the Barry et al\n>proposal\n>>> is incredibly unlikely to meet the requirements of a\n>>> multi-billion-dollar system, and continued research into meeting the\n>>> spirit, not the text, of their agreement seems warranted.\n>>>\n>>> Matt\n>>>\n>>> On 05/26/17 17:47, Jacob Eliosoff via bitcoin-dev wrote:\n>>> > Forgive me if this is a dumb question.  Suppose that rather than\n>>> > directly activating segwit, the Silbert/NYC Segwit2MB proposal's\n>lock-in\n>>> > just triggered BIP141 signaling (plus later HF).  Would that avoid\n>>> > incompatibility with existing BIP141 nodes, and get segwit\n>activated\n>>> > sooner?  Eg:\n>>> >\n>>> > - Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals\n>support\n>>> > for \"segwit now, HF (TBD) at scheduled date (Nov 23?)\"\n>>> > - If bit 4 support reaches 80%, it locks in two things: the\n>scheduled HF\n>>> > (conditional on segwit), and *immediately* turning on bit 1\n>(BIP141\n>>> > support)\n>>> >\n>>> > I realize this would still leave problems like the aggressive HF\n>>> > schedule, possible chain split at the HF date between Segwit2MB\n>nodes\n>>> > and any remaining BIP141 nodes, etc.  My focus here is how\n>>> > incompatibility with existing nodes could be minimized.\n>>> >\n>>> > (BIP91 could also be used if BIP141 support still fell short of\n>95%.\n>>> > But if Segwit2MB support reaches 80%, it seems likely that an\n>additional\n>>> > 15% will support BIP141-without-HF.)\n>>> >\n>>> >\n>>> > _______________________________________________\n>>> > bitcoin-dev mailing list\n>>> > bitcoin-dev at lists.linuxfoundation.org\n>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> >\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-28T20:51:46",
                "message_text_only": "On Saturday, 27 May 2017 01:09:10 CEST James Hilliard wrote:\n> > why?\n> \n> the main\n> issue is due to 0.13.1+ having many segwit related features active\n> already, including all the P2P components, the new network service\n> flag, the witness-tx and block messages, compact blocks v2 and\n> preferential peering. \n\nHmm, the flags are identical in 0.13 and 0.14 clients.\n\nEither way, this is rather trivial to solve. If bugs in older clients mean \nthey can\u2019t operate properly when SW is activated (via bit 4) but they don\u2019t \nknow its activated (since they only look at bit1), then just ban them when \nthey misbehave.\nAnd tell people to upgrade to a version where SegWit is less buggy.\n\n> You would have to then have multiple activation\n> codepaths to test for such as BIP141(active)->HF BIP141(inactive)->HF\n> etc. By doing BIP141 first you then only have the BIP141(active)->HF\n> activation codepath to test for, and you also can't be sure you can\n> rely on BIP141(inactive)->HF activation codepath being the only one\n> until segwit activation expires.\n\nHeh, well, this is rather simple to solve by not having all those activation \ncodepaths and just picking **one**.\n\nYou can safely replace the bit1 activation code with a bit4 activation \nlogic, which is based on 80% and has no end-date.\nWe both know that the bip9 (bit1) based activation will not trigger before \nthe expiration date anyway.\n\nThese worries are rather trivial to solve if you do a little bit of proper \narchitecture of the solution.  This honestly can\u2019t be a reason for saying NO \nto the majority of the mining hash power giving you a break and offering a \nbetter SegWit activation.\n\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-28T23:28:11",
                "message_text_only": "On Sun, May 28, 2017 at 3:51 PM, Tom Zander via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On Saturday, 27 May 2017 01:09:10 CEST James Hilliard wrote:\n>> > why?\n>>\n>> the main\n>> issue is due to 0.13.1+ having many segwit related features active\n>> already, including all the P2P components, the new network service\n>> flag, the witness-tx and block messages, compact blocks v2 and\n>> preferential peering.\n>\n> Hmm, the flags are identical in 0.13 and 0.14 clients.\n>\n> Either way, this is rather trivial to solve. If bugs in older clients mean\n> they can\u2019t operate properly when SW is activated (via bit 4) but they don\u2019t\n> know its activated (since they only look at bit1), then just ban them when\n> they misbehave.\n> And tell people to upgrade to a version where SegWit is less buggy.\nThat would partition off those clients, which is not something we\nwould want to happen.\n>\n>> You would have to then have multiple activation\n>> codepaths to test for such as BIP141(active)->HF BIP141(inactive)->HF\n>> etc. By doing BIP141 first you then only have the BIP141(active)->HF\n>> activation codepath to test for, and you also can't be sure you can\n>> rely on BIP141(inactive)->HF activation codepath being the only one\n>> until segwit activation expires.\n>\n> Heh, well, this is rather simple to solve by not having all those activation\n> codepaths and just picking **one**.\nThis isn't possible until either BIP141 segwit is active or BIP141\nsegwit has expired.\n>\n> You can safely replace the bit1 activation code with a bit4 activation\n> logic, which is based on 80% and has no end-date.\n> We both know that the bip9 (bit1) based activation will not trigger before\n> the expiration date anyway.\nWe don't know that since bip9 bit1 only needs 55% hashpower to be\ntriggered(see BIP91 activation method for how this can be done)\n>\n> These worries are rather trivial to solve if you do a little bit of proper\n> architecture of the solution.  This honestly can\u2019t be a reason for saying NO\n> to the majority of the mining hash power giving you a break and offering a\n> better SegWit activation.\nBIP91 activation is clearly superior than trying to fully redeploy, it\nis far simpler and can be done almost immediately with only miners\nneeding to upgrade.\n>\n> --\n> Tom Zander\n> Blog: https://zander.github.io\n> Vlog: https://vimeo.com/channels/tomscryptochannel\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Barry Silbert segwit agreement",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "shaolinfry",
                "Hampus Sj\u00f6berg",
                "Tom Zander",
                "Daniele Pinna",
                "Peter Todd",
                "James Hilliard",
                "Matt Corallo",
                "Jacob Eliosoff"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 37487
        }
    },
    {
        "title": "[bitcoin-dev] Drivechain -- Request for Discussion",
        "thread_messages": [
            {
                "author": "Paul Sztorc",
                "date": "2017-05-22T06:17:07",
                "message_text_only": "Dear list,\n\nI've been working on \"drivechain\", a sidechain enabling technology, for\nsome time.\n\n* The technical info site is here: www.drivechain.info\n* The changes to Bitcoin are here:\nhttps://github.com/drivechain-project/bitcoin/tree/mainchainBMM\n* A Blank sidechain template is here:\nhttps://github.com/drivechain-project/bitcoin/tree/sidechainBMM\n\nAs many of you know, I've been seeking feedback in person, at various\nconferences and meetups over the past year, most prominently Scaling\nMilan. And I intend to continue to seek feedback at Consensus2017 this\nweek, so if you are in NYC please just walk up and start talking to me!\n\nBut I also wanted to ask the list for feedback. Initially, I was\nhesitant because I try not to consume reviewers' scarce time until the\nauthor has put in a serious effort. However, I may have waiting too\nlong, as today it is actually quite close to a working release.\n\n\nScaling Implications\n---------------------\n\nThis upgrade would have significant scaling implications. Since it is\nthe case that sidechains can be added by soft fork, and since each of\nthese chains will have its own blockspace, this theoretically removes\nthe blocksize limit from \"the Bitcoin system\" (if one includes\nsidechains as part of such a system). People who want a LargeBlock\nbitcoin can just move their BTC over to such a network [1], and their\ntxns will have no longer have an impact on \"Bitcoin Core\". Thus, even\nthough this upgrade does not actually increase \"scalability\" per se, it\nmay in fact put an end to the scalability debate...forever.\n\nThis work includes the relatively new concept of \"Blind Merged Mining\"\n[2] which I developed in January to allow SHA256^2 miners to merge-mine\nthese \"drivechains\", even if these miners aren't running the actual\nsidechain software. The goal is to prevent sidechains from affecting the\nlevelness of the mining \"playing field\". BMM is conceptually similar to\nZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not\nrequired for drivechain, but it would address some of the last remaining\nconcerns.\n\n\nTotal Transaction Fees in the Far Future\n-----------------------------------------\n\nSome people feel that a maximum blocksize limit is needed to ensure that\nfuture total equilibrium transaction fees are non-negligible. I\npresented [4] on why I don't agree, 8 months ago. The reviewers I spoke\nto over the last year have stopped bringing this complaint up, but I am\nnot sure everyone feels that way.\n\n\nJuxtaposition with a recent \"Scaling Compromise\"\n-------------------------------------------------\n\nRecently, a scalability proposal began to circulate on social media. As\nfar as I could tell, it goes something like \"immediately activate\nSegWit, and then HF to double the nonwitness blockspace to 2MB within 12\nmonths\". But such a proposal is quite meager, compared to a \"LargeBlock\nDrivechain\". The drivechain is better on both fronts, as it would not\nrequire a hardfork, and could *almost immediately* add _any_ amount of\nextra blockspace (specifically, I might expect a BIP101-like LargeBlock\nchain that has an 8 MB maxblocksize, which doubles every two years).\n\nIn other words, I don't know why anyone would support that proposal over\nmine. The only reasons would be either ignorance (ie, unfamiliarity with\ndrivechain) or because there are still nagging unspoken complaints about\ndrivechain which I apparently need to hear and address.\n\n\nOther Thoughts\n---------------\n\nUnfortunately, anyone who worked on the \"first generation\" of sidechain\ntechnology (the skiplist) or the \"second generation\" (federated /\nLiquid), will find that this is very different.\n\nI will admit that I am very pessimistic about any conversation that\ninvolves scalability. It is often said that \"talking politics lowers\nyour IQ by 25 points\". Bitcoin scalability conversations seem to drain\n50 points. (Instead of conversing, I think people should quietly work on\nwhatever they are passionate about until their problem either is solved,\nor it goes away for some other reason, or until we all agree to just\nstop talking about it.)\n\nCheers,\nPaul\n\n[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling\n[2] http://www.truthcoin.info/blog/blind-merged-mining/\n[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log\n[4]\nhttps://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-22T13:33:35",
                "message_text_only": "On Mon, May 22, 2017 at 02:17:07AM -0400, Paul Sztorc via bitcoin-dev wrote:\n> This work includes the relatively new concept of \"Blind Merged Mining\"\n> [2] which I developed in January to allow SHA256^2 miners to merge-mine\n> these \"drivechains\", even if these miners aren't running the actual\n> sidechain software. The goal is to prevent sidechains from affecting the\n> levelness of the mining \"playing field\". BMM is conceptually similar to\n> ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not\n> required for drivechain, but it would address some of the last remaining\n> concerns.\n\nThanks for the credit, although I think the security properties of what you're\nproposing are very different - and much weaker - than what I proposed in\nZookeyv.\n\nAs you state in [2] \"if miners never validate sidechains at all, whoever bids\nthe most for the chain (on a continuous basis), can spam a 3-month long stream\nof invalid headers, and then withdraw all of the coins deposited to the\nsidechain.\" and \"Since the mining is blind, and the sidechain-withdrawal\nsecurity-level is SPV, miners who remain blind forever have no way of telling\nwho \u201cshould\u201d really get the funds.\"\n\nFinally, you suggest that in this event, miners *do* have to upgrade to a full\nnode, an expensive and time-consuming operation (and one that may be impossible\nfor some miners if necessary data isn't available).\n\nIt's unclear to me what the incentive is for miners to do any of this. Could\nyou explain in more detail what that incentive is?\n\n\n> [2] http://www.truthcoin.info/blog/blind-merged-mining/\n> [3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/c4d63e2f/attachment.sig>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-22T15:30:46",
                "message_text_only": "Charlie, I'll be mostly in the tech track, of course. And I've already\nplanned to meet RSK guys after their event tomorrow.\n\nRyan, the more review the better. We aren't in any direct rush, other than\nthe natural desire to have cool things as early as possible.\n\nPeter, responses below:\n\nOn May 22, 2017 9:33 AM, \"Peter Todd\" <pete at petertodd.org> wrote:\n\nOn Mon, May 22, 2017 at 02:17:07AM -0400, Paul Sztorc via bitcoin-dev wrote:\n> This work includes the relatively new concept of \"Blind Merged Mining\"\n> [2] which I developed in January to allow SHA256^2 miners to merge-mine\n> these \"drivechains\", even if these miners aren't running the actual\n> sidechain software. The goal is to prevent sidechains from affecting the\n> levelness of the mining \"playing field\". BMM is conceptually similar to\n> ZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not\n> required for drivechain, but it would address some of the last remaining\n> concerns.\n\nThanks for the credit, although I think the security properties of what\nyou're\nproposing are very different - and much weaker - than what I proposed in\nZookeyv.\n\n\nAs you state in [2] \"if miners never validate sidechains at all, whoever\nbids\nthe most for the chain (on a continuous basis), can spam a 3-month long\nstream\nof invalid headers, and then withdraw all of the coins deposited to the\nsidechain.\" and \"Since the mining is blind, and the sidechain-withdrawal\nsecurity-level is SPV, miners who remain blind forever have no way of\ntelling\nwho \u201cshould\u201d really get the funds.\"\n\nFinally, you suggest that in this event, miners *do* have to upgrade to a\nfull\nnode, an expensive and time-consuming operation (and one that may be\nimpossible\nfor some miners if necessary data isn't available).\n\n\nSurprisingly, this requirement (or, more precisely, this incentive) does\nnot effect miners relative to each other. The incentive to upgrade is only\nfor the purpose of preventing a \"theft\" -- defined as: an improper\nwithdrawal from a sidechain. It is not about miner revenues or the ability\nto mine generally (or conduct BMM specifically). The costs of such a theft\n(decrease in market price, decrease in future transaction fee levels) would\nbe shared collectively by all future miners. Therefore, it would have no\neffect on miners relative to each other.\n\nMoreover, miners have other recourse if they are unable to run the node.\nThey can adopt a policy of simply rejecting (\"downvoting\") any withdrawals\nthat they don't understand. This would pause the withdraw process until\nenough miners understand enough of what is going on to proceed with it.\n\nFinally, the point in dispute is a single, infrequent, true/false question.\nSo miners may resort to semi-trusted methods to supplement their decision.\nIn other words, they can just ask people they trust, if the withdrawal is\ncorrect or not. It is up to users to decide if they are comfortable with\nthese risks, if/when they decide to deposit to a sidechain.\n\n\nIt's unclear to me what the incentive is for miners to do any of this. Could\nyou explain in more detail what that incentive is?\n\n\nIt is a matter of comparing the costs and benefits. Ignoring theft, the\ncosts are near-zero, and the benefits are >0. Specifically, they are: a\nhigher BTC price and greater transaction fees. Theft is discouraged by\nattempting to tie a theft to a loss of confidence in the miners, as\ndescribed in the spec/website.\nIn general the incentives are very similar to those of Bitcoin itself.\n\nPaul\n\n\n\n> [2] http://www.truthcoin.info/blog/blind-merged-mining/\n> [3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log\n\n--\nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/9bb81395/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-28T21:07:57",
                "message_text_only": "On Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:\n> Surprisingly, this requirement (or, more precisely, this incentive) does\n> not effect miners relative to each other. The incentive to upgrade is only\n> for the purpose of preventing a \"theft\" -- defined as: an improper\n> withdrawal from a sidechain. It is not about miner revenues or the ability\n> to mine generally (or conduct BMM specifically). The costs of such a theft\n> (decrease in market price, decrease in future transaction fee levels) would\n> be shared collectively by all future miners. Therefore, it would have no\n> effect on miners relative to each other.\n\nThat's not at all true. If I'm a miner with a better capability than another\nminer to prevent that theft, I have reasons to induce it to happen to give me\npolitical cover to pushing that other miner off the network.\n\nThis is a very similar problem to what we had with zeroconf double-spending,\nwhere entities such as Coinbase tried to pay off miners to guarantee something\nthat wasn't possible in a geninely decrentralized system: safe zeroconf\ntransactions.\n\n> Moreover, miners have other recourse if they are unable to run the node.\n> They can adopt a policy of simply rejecting (\"downvoting\") any withdrawals\n> that they don't understand. This would pause the withdraw process until\n> enough miners understand enough of what is going on to proceed with it.\n\nWhy are you forcing miners to run this code at all?\n\nEqually, you're opening up miners to huge political risks, as rejecting all\nwithdrawals is preventing users' from getting their money, which gives other\nminers a rational for kicking those miners off of Bitcoin entirely.\n\n> Finally, the point in dispute is a single, infrequent, true/false question.\n> So miners may resort to semi-trusted methods to supplement their decision.\n> In other words, they can just ask people they trust, if the withdrawal is\n> correct or not. It is up to users to decide if they are comfortable with\n> these risks, if/when they decide to deposit to a sidechain.\n\nWhy do you think this will be infrequent? Miners with a better ability to\nvalidate the drivechain have every reason to make these events more frequent.\n\n> It is a matter of comparing the costs and benefits. Ignoring theft, the\n> costs are near-zero, and the benefits are >0. Specifically, they are: a\n> higher BTC price and greater transaction fees. Theft is discouraged by\n> attempting to tie a theft to a loss of confidence in the miners, as\n> described in the spec/website.\n> In general the incentives are very similar to those of Bitcoin itself.\n\nThis is also a very dubious security model - I would argue that Bitcoin is much\n*more* valuable if miners do everything they can to ensure that drivechains\nfail, given the huge risks involved. I would also argue that users should do\nuser-activated-soft-forks to ensure they fail.\n\nBy comparison, note Adam Back and my own efforts to ensure miners have a\nsmaller part in the ecosystem, with things like committed (encrypted)\ntransactions and my closed-seal-set/truth-list approach(1). We want to involve\nminers as little as possible in the consensus, not more.\n\nI have to ask: What use-cases do you actually see for drivechains? Why can't\nthose use-cases be done in the much safer client-side validation fashion?\n\n1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/c960e00a/attachment.sig>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-30T05:11:51",
                "message_text_only": "Hi Peter,\n\nResponses below.\n\nOn 5/28/2017 5:07 PM, Peter Todd wrote:\n> On Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:\n>> Surprisingly, this requirement (or, more precisely, this incentive) does\n>> not effect miners relative to each other. The incentive to upgrade is only\n>> for the purpose of preventing a \"theft\" -- defined as: an improper\n>> withdrawal from a sidechain. It is not about miner revenues or the ability\n>> to mine generally (or conduct BMM specifically). The costs of such a theft\n>> (decrease in market price, decrease in future transaction fee levels) would\n>> be shared collectively by all future miners. Therefore, it would have no\n>> effect on miners relative to each other.\n> \n> That's not at all true. If I'm a miner with a better capability than another\n> miner to prevent that theft, I have reasons to induce it to happen to give me\n> political cover to pushing that other miner off the network.\n\nMiners can abstain from 'voting', which is politically neutral. Or, if\nthey wish, smaller miners could acquiesce to the coercion and just copy\nthe votes of the attacking 51% group. For users who are only running\nBitcoin Core, there is nothing bad about that.\n\nAs you say, a 51% group can arbitrarily start orphaning the blocks that\nare mined by non-member rivals. This _may_ be a problem, or it may not,\nbut it is not exacerbated by drivechain.\n\nSo, what exactly is \"not at all true\"?\n\n\n> \n> This is a very similar problem to what we had with zeroconf double-spending,\n> where entities such as Coinbase tried to pay off miners to guarantee something\n> that wasn't possible in a geninely decrentralized system: safe zeroconf\n> transactions.\n\nI don't see what you mean here. You can't stop Coinbase from donating\nBTC to a subset of miners. That will always be possible, and it has\nnothing to do with drivechain (as I see it).\n\n\n> \n>> Moreover, miners have other recourse if they are unable to run the node.\n>> They can adopt a policy of simply rejecting (\"downvoting\") any withdrawals\n>> that they don't understand. This would pause the withdraw process until\n>> enough miners understand enough of what is going on to proceed with it.\n> \n> Why are you forcing miners to run this code at all?\n\nCould we not say the same thing about the code behind CLTV?\n\nThe nature of a contract, is that people are happier to be bound by some\nrules that they themselves construct (for example, a nuclear\nnon-proliferation treaty).\n\nIn this case, miners prefer sidechains to exist (as existence makes the\nBTC they mine more valuable, and provides additional tx fee revenues),\nand so they would like to run code which makes them possible.\n\n\n> \n> Equally, you're opening up miners to huge political risks, as rejecting all\n> withdrawals is preventing users' from getting their money, which gives other\n> miners a rational for kicking those miners off of Bitcoin entirely.\n\nAs I explained above, miners can abstain from voting, which is\npolitically neutral, or else they can delegate their vote to an\naggressive miner. The \"51% can orphan\" concern could be raised, even in\na world without drivechain. All that is required, is for the miners to\nbe anonymous, or in private 'dark' pools (and to thereby escape censure).\n\nBut there is a much bigger issue here, which is that our threat models\nare different.\n\nAs you may know, my threat model [1] does not include miners \"pushing\neach other off\". It only cares about the miner-experience, to the extent\nthat it impacts the user-experience.\n\nMoreover, I reject [2] the premise that we can even measure \"miner\ncentralization\", or even that such a concept exists. If someone has a\ndefinition of this concept, which is both measurable and useful, I would\nbe interested to read it.\n\n( For what it's worth, Satoshi did not care about this, either. For\nexample: \"If a greedy attacker is able to assemble more CPU power than\nall the honest nodes, he...ought to find it more profitable to play by\nthe rules.\" which implies robustness to 51% owned by one entity. )\n\n[1] http://www.truthcoin.info/blog/mining-threat-equilibrium/\n[2] http://www.truthcoin.info/blog/mirage-miner-centralization/\n\n\n> \n>> Finally, the point in dispute is a single, infrequent, true/false question.\n>> So miners may resort to semi-trusted methods to supplement their decision.\n>> In other words, they can just ask people they trust, if the withdrawal is\n>> correct or not. It is up to users to decide if they are comfortable with\n>> these risks, if/when they decide to deposit to a sidechain.\n> \n> Why do you think this will be infrequent? Miners with a better ability to\n> validate the drivechain have every reason to make these events more frequent.\n\nIt is part of the spec. These timing parameters must be agreed upon when\nthe sidechain is added, ie _before_ users deposit to the sidechain. Once\nthe sidechain is created, the timing is enforced by nodes, the same as\nwith any other protocol rules. Miner-validation-ability has no effect on\nthe frequency.\n\n\n> \n>> It is a matter of comparing the costs and benefits. Ignoring theft, the\n>> costs are near-zero, and the benefits are >0. Specifically, they are: a\n>> higher BTC price and greater transaction fees. Theft is discouraged by\n>> attempting to tie a theft to a loss of confidence in the miners, as\n>> described in the spec/website.\n>> In general the incentives are very similar to those of Bitcoin itself.\n> \n> This is also a very dubious security model - I would argue that Bitcoin is much\n> *more* valuable if miners do everything they can to ensure that drivechains\n> fail, given the huge risks involved.\n\nI don't see how. Users are free to ignore the sidechain, so it can only\nbenefit them.\n\nFortunately for you, if that is actually what miners believe, then there\nwill be no problem, as miners will just filter out drivechains (so that\nBitcoin will be \"much *more* valuable\"), which they can easily do.\n\n\n>                                      I would also argue that users should do\n> user-activated-soft-forks to ensure they fail.\n\nAgain, I don't think that kind of UASF can succeed, because one option\nstrictly dominates the other. But the users get the final say, of course.\n\nEmpirically, I have observed overwhelming support for sidechains among\nusers, business, and other developers. The btc-investors I spoke to were\nall very excited about the prospect of sidechains, even more so than\nthey were excited about SegWit.\n\n\n> \n> By comparison, note Adam Back and my own efforts to ensure miners have a\n> smaller part in the ecosystem, with things like committed (encrypted)\n> transactions and my closed-seal-set/truth-list approach(1). We want to involve\n> miners as little as possible in the consensus, not more.\n\nI agree that miners should have as little influence as possible (and\nthey probably agree, as well). But a 51% group can filter any message\nthey like from the blockchain. For sidechains, there will need to be two\npublic networks, so concealment is not an option.\n\nAnd, I repeat, for regular users of Bitcoin Core, drivechain does not\nmake a 51% group more dangerous than they already are.\n\nMoreover, there are cases [1] where miner-involvement can make a big\n_positive_ impact. Just as it can be beneficial (essential, in fact) for\nBitcoin to filter out harmful interactions among txns (in other words,\ngood for miners to filter out double spends), I have discovered\nsituations where it is beneficial and essential for miners to filter out\nharmful interactions among multiple chains.\n\nSo I think I am actually hitting the \"as little as possible\" target.\n\n[1] http://www.truthcoin.info/blog/wise-contracts/#wise-contracts\n\n\n> \n> I have to ask: What use-cases do you actually see for drivechains? Why can't\n\nHere is a tentative project list:\nhttp://www.drivechain.info/projects/index.html\n\nAnd, as I say on the FAQ, \"If each individual user is free to sell\nhis/her BTC in exchange for an Altcoin (or for fiat), we can hardly deny\nusers the opportunity to move their money between two sidechains.\"\n\nSo, in a strong way, the entire altcoin market makes the case for a\nusefulness of sidechains. Bitcoin is a form of money, and only one form\nof money can exist per currency area. So, if Bitcoin is not the winner,\nit will eventually cease to exist altogether. Altcoin-competition is an\nexistential threat to Bitcoin, one which is far more relevant than\nanything you've presented so far.\n\nSecondly, one important value of permissionless innovation is that one\ndoesn't really know, today, what cool ideas other people are going to\ncome up with tomorrow. If you did, they'd be today's ideas.\n\nThird, Core's review process has two opposite problems: on one hand it\nis slow and grueling, and on the other it is fraught with the\npossibility of catastrophic error. It would be better, for everyone, to\nallow people to try their own (non-aggressive) experiments, and to make\ntheir own mistakes. Already, I have seen the review process abused to\ncreate/maintain fiefdoms of expertise, so that the abusers can extract\nmoney from clients/employers/VCs.\n\nJust think of all of the free time you would have, Peter, if you didn't\nhave to spend it all reviewing these projects!\n\n\n> those use-cases be done in the much safer client-side validation fashion?\n\n? How is drivechain _not_ within the category of client-side validation?\nWith BMM, validation is only performed by those users (\"clients\") who\nopt-in to the new features. The economic model of BMM is directly\ncomparable to that of Bitcoin's PoW -- the highest-bid chain should be\nthe healthiest one.\n\nCan you post the Github link for your most up-to-date client-side\nvalidation work so that we can compare the safety and other features?\n\nThanks,\nPaul\n\n> \n> 1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-22T14:39:19",
                "message_text_only": "Good morning Paul,\n\nI read only http://www.truthcoin.info/blog/blind-merged-mining/\n\nFrom just this document, I can't see a good justification for believing that a main->side locking transaction can be safely spent into a side->main unlocking transaction. Do you have a better explanation?\n\nOP_is_h_in_coinbase, as described, does not seem to protect against a sidechain reorg in your next section of the document. If I attempt to spend a main->side locking transaction on the basis of a \"mistaken\" side block #49, what prevents me from this sequence:\n\n1. Put a side:side->main transaction into a block together with TheDAO's hacked money.\n2. Wait for a reorg to revert TheDAO.\n3. Spend my now-free-in-the-reorg funds on Lightning Network to get mainchain funds.\n4. Create a main:side->main transaction with the side:side->main transaction in the TheDAO-hacked block as witness.\n5. Get another set of mainchain funds from the same sidechain funds.\n\nSo far, the only good side->main transfer I know of is in Blockstream's original sidechains paper, with the main:side->main transaction spending into a timelocked transaction that may be burned if a reorg proof is submitted (i.e. you try to create a main:side->main transaction with the side:side->main transaction in the mistaken #49 and #50 as your proof, but someone else can come along and show a corrected #49, #50, #51 without your side:side->main transaction and burn your funds). Is your proposal at the technical level actually similar, or does it truly seem to be riskier? It seems to me that your OP_is_h_in_coinbase should scan a series of sidechain block headers backed by mainchain (meaning at the minimum that sidechains should have some common header format prefix), rather than just mainchain depth as your article seems to imply.\n\nAlso, blinded merge mining seems strictly inferior to proof-of-burn: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-December/007012.html\n\nProof-of-burn integrates a lottery to reduce the ability of a mainchain-rich attacker to reorg the sidechain by burning its greater funds. However it still seems to me that a rich attacker can simply make more bets in that scheme by some trivial modification of the side block. Blind merged mining seems strictly inferior as a rich attacker can simply reorg the sidechain outright without playing such games.\n\nOr is your proposal strictly for centralized sidechains, where only one entity creates side blocks? How does your proposal handle multiple side block creators on the same sidechain, with the possibility that chain splits occur?\n\nRegarding your dig about people who dislike data centers, the main issue with miners blindly accepting sidechain commitments is that it violates \"Don't trust, verify\", not that allows datacenters to be slightly smaller by not including side:nodes.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n-------- Original Message --------\nSubject: [bitcoin-dev] Drivechain -- Request for Discussion\nLocal Time: May 22, 2017 6:17 AM\nUTC Time: May 22, 2017 6:17 AM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n\nDear list,\n\nI've been working on \"drivechain\", a sidechain enabling technology, for\nsome time.\n\n* The technical info site is here: www.drivechain.info\n* The changes to Bitcoin are here:\nhttps://github.com/drivechain-project/bitcoin/tree/mainchainBMM\n* A Blank sidechain template is here:\nhttps://github.com/drivechain-project/bitcoin/tree/sidechainBMM\n\nAs many of you know, I've been seeking feedback in person, at various\nconferences and meetups over the past year, most prominently Scaling\nMilan. And I intend to continue to seek feedback at Consensus2017 this\nweek, so if you are in NYC please just walk up and start talking to me!\n\nBut I also wanted to ask the list for feedback. Initially, I was\nhesitant because I try not to consume reviewers' scarce time until the\nauthor has put in a serious effort. However, I may have waiting too\nlong, as today it is actually quite close to a working release.\n\nScaling Implications\n---------------------\n\nThis upgrade would have significant scaling implications. Since it is\nthe case that sidechains can be added by soft fork, and since each of\nthese chains will have its own blockspace, this theoretically removes\nthe blocksize limit from \"the Bitcoin system\" (if one includes\nsidechains as part of such a system). People who want a LargeBlock\nbitcoin can just move their BTC over to such a network [1], and their\ntxns will have no longer have an impact on \"Bitcoin Core\". Thus, even\nthough this upgrade does not actually increase \"scalability\" per se, it\nmay in fact put an end to the scalability debate...forever.\n\nThis work includes the relatively new concept of \"Blind Merged Mining\"\n[2] which I developed in January to allow SHA256^2 miners to merge-mine\nthese \"drivechains\", even if these miners aren't running the actual\nsidechain software. The goal is to prevent sidechains from affecting the\nlevelness of the mining \"playing field\". BMM is conceptually similar to\nZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not\nrequired for drivechain, but it would address some of the last remaining\nconcerns.\n\nTotal Transaction Fees in the Far Future\n-----------------------------------------\n\nSome people feel that a maximum blocksize limit is needed to ensure that\nfuture total equilibrium transaction fees are non-negligible. I\npresented [4] on why I don't agree, 8 months ago. The reviewers I spoke\nto over the last year have stopped bringing this complaint up, but I am\nnot sure everyone feels that way.\n\nJuxtaposition with a recent \"Scaling Compromise\"\n-------------------------------------------------\n\nRecently, a scalability proposal began to circulate on social media. As\nfar as I could tell, it goes something like \"immediately activate\nSegWit, and then HF to double the nonwitness blockspace to 2MB within 12\nmonths\". But such a proposal is quite meager, compared to a \"LargeBlock\nDrivechain\". The drivechain is better on both fronts, as it would not\nrequire a hardfork, and could *almost immediately* add _any_ amount of\nextra blockspace (specifically, I might expect a BIP101-like LargeBlock\nchain that has an 8 MB maxblocksize, which doubles every two years).\n\nIn other words, I don't know why anyone would support that proposal over\nmine. The only reasons would be either ignorance (ie, unfamiliarity with\ndrivechain) or because there are still nagging unspoken complaints about\ndrivechain which I apparently need to hear and address.\n\nOther Thoughts\n---------------\n\nUnfortunately, anyone who worked on the \"first generation\" of sidechain\ntechnology (the skiplist) or the \"second generation\" (federated /\nLiquid), will find that this is very different.\n\nI will admit that I am very pessimistic about any conversation that\ninvolves scalability. It is often said that \"talking politics lowers\nyour IQ by 25 points\". Bitcoin scalability conversations seem to drain\n50 points. (Instead of conversing, I think people should quietly work on\nwhatever they are passionate about until their problem either is solved,\nor it goes away for some other reason, or until we all agree to just\nstop talking about it.)\n\nCheers,\nPaul\n\n[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling\n[2] http://www.truthcoin.info/blog/blind-merged-mining/\n[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log\n[4]\nhttps://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/b545bb82/attachment-0001.html>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-22T16:19:14",
                "message_text_only": "On May 22, 2017 10:39 AM, \"ZmnSCPxj\" <ZmnSCPxj at protonmail.com> wrote:\n\nGood morning Paul,\n\nI read only http://www.truthcoin.info/blog/blind-merged-mining/\n\n>From just this document, I can't see a good justification for believing\nthat a main->side locking transaction can be safely spent into a side->main\nunlocking transaction.  Do you have a better explanation?\n\n\nYes, a better explanation is in the drivechain spec, at:\nhttp://www.truthcoin.info/blog/drivechain/\n\nWhat you read is only an introduction of BMM. You may also consult the\nnotes (at the bottom of the BMM post) or the code, although this is time\nconsuming of course.\n\n\nIf I attempt to spend a main->side locking transaction on the basis of a\n\"mistaken\" side block #49, what prevents me from this sequence:\n\n\nThe literal answer to your question is that mainchain Bitcoin will notice\nthat, for the second withdrawal, the sum of the inputs is less than the sum\nof the outputs and they the transaction is therefore invalid.\n\n\n1.  Put a side:side->main transaction into a block together with TheDAO's\nhacked money.\n\nSo far, the only good side->main transfer I know of is in Blockstream's\noriginal sidechains paper, with the main:side->main transaction ... Is your\nproposal at the technical level actually similar, or does it truly seem to\nbe riskier?\n\n\nI feel that my proposal is more secure, as it can operate healthily and\nquickly while using spv proofs which are much slower and much much easier\nto audit.\n\n\nseems to me that your OP_is_h_in_coinbase should scan a series of sidechain\nblock headers backed by mainchain (meaning at the minimum that sidechains\nshould have some common header format prefix), rather than just mainchain\ndepth as your article seems to imply.\n\n\nHow would security be improved as a result? In either case, 51% of hashrate\ncan cause a reorg. The sidechain software itself does scan block headers,\nof course.\n\n\nBlind merged mining seems strictly inferior ... a rich attacker can simply\nreorg the sidechain outright without playing such games.\n\n\nIn the future, when there is no block subsidy, a rich attacker can also do\nthat in mainchain Bitcoin.\n\n\nOr is your proposal strictly for centralized sidechains, where only one\nentity creates side blocks?\n\n\nNot at all.\n\nHow does your proposal handle multiple side block creators on the same\nsidechain, with the possibility that chain splits occur?\n\n\nThe side block is only \"mined\" if it is committed to in a mainchain Bitcoin\nblog, and each mainchain block can only contain one block per sidechain. In\nthis way, drivechain sidechains are different from classical Namecoin\nmerged mining (where one _could_ run the entire system, mining included,\nwithout interfacing with Bitcoin at all).\n\n\nRegarding your dig about people who dislike data centers, the main issue\nwith miners blindly accepting sidechain commitments is that it violates\n\"Don't trust, verify\", not that allows datacenters to be slightly smaller\nby not including side:nodes.\n\n\nAs I explain early on, in earlier rounds of peer review, the focus was on\nharms the sidechain technology might do to mainchain Bitcoin, and the\n\"datacenter point\" was specifically the chief objection raised. So I am\nafraid you are entirely incorrect.\n\nIn point of fact, the transactions *are* validated...by sidechain full\nnodes, same as Bitcoin proper.\n\nPaul\n\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n-------- Original Message --------\nSubject: [bitcoin-dev] Drivechain -- Request for Discussion\nLocal Time: May 22, 2017 6:17 AM\nUTC Time: May 22, 2017 6:17 AM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n\nDear list,\n\nI've been working on \"drivechain\", a sidechain enabling technology, for\nsome time.\n\n* The technical info site is here: www.drivechain.info\n* The changes to Bitcoin are here:\nhttps://github.com/drivechain-project/bitcoin/tree/mainchainBMM\n* A Blank sidechain template is here:\nhttps://github.com/drivechain-project/bitcoin/tree/sidechainBMM\n\nAs many of you know, I've been seeking feedback in person, at various\nconferences and meetups over the past year, most prominently Scaling\nMilan. And I intend to continue to seek feedback at Consensus2017 this\nweek, so if you are in NYC please just walk up and start talking to me!\n\nBut I also wanted to ask the list for feedback. Initially, I was\nhesitant because I try not to consume reviewers' scarce time until the\nauthor has put in a serious effort. However, I may have waiting too\nlong, as today it is actually quite close to a working release.\n\n\nScaling Implications\n---------------------\n\nThis upgrade would have significant scaling implications. Since it is\nthe case that sidechains can be added by soft fork, and since each of\nthese chains will have its own blockspace, this theoretically removes\nthe blocksize limit from \"the Bitcoin system\" (if one includes\nsidechains as part of such a system). People who want a LargeBlock\nbitcoin can just move their BTC over to such a network [1], and their\ntxns will have no longer have an impact on \"Bitcoin Core\". Thus, even\nthough this upgrade does not actually increase \"scalability\" per se, it\nmay in fact put an end to the scalability debate...forever.\n\nThis work includes the relatively new concept of \"Blind Merged Mining\"\n[2] which I developed in January to allow SHA256^2 miners to merge-mine\nthese \"drivechains\", even if these miners aren't running the actual\nsidechain software. The goal is to prevent sidechains from affecting the\nlevelness of the mining \"playing field\". BMM is conceptually similar to\nZooKeeV [3] which Peter Todd sketched out in mid-2013. BMM is not\nrequired for drivechain, but it would address some of the last remaining\nconcerns.\n\n\nTotal Transaction Fees in the Far Future\n-----------------------------------------\n\nSome people feel that a maximum blocksize limit is needed to ensure that\nfuture total equilibrium transaction fees are non-negligible. I\npresented [4] on why I don't agree, 8 months ago. The reviewers I spoke\nto over the last year have stopped bringing this complaint up, but I am\nnot sure everyone feels that way.\n\n\nJuxtaposition with a recent \"Scaling Compromise\"\n-------------------------------------------------\n\nRecently, a scalability proposal began to circulate on social media. As\nfar as I could tell, it goes something like \"immediately activate\nSegWit, and then HF to double the nonwitness blockspace to 2MB within 12\nmonths\". But such a proposal is quite meager, compared to a \"LargeBlock\nDrivechain\". The drivechain is better on both fronts, as it would not\nrequire a hardfork, and could *almost immediately* add _any_ amount of\nextra blockspace (specifically, I might expect a BIP101-like LargeBlock\nchain that has an 8 MB maxblocksize, which doubles every two years).\n\nIn other words, I don't know why anyone would support that proposal over\nmine. The only reasons would be either ignorance (ie, unfamiliarity with\ndrivechain) or because there are still nagging unspoken complaints about\ndrivechain which I apparently need to hear and address.\n\n\nOther Thoughts\n---------------\n\nUnfortunately, anyone who worked on the \"first generation\" of sidechain\ntechnology (the skiplist) or the \"second generation\" (federated /\nLiquid), will find that this is very different.\n\nI will admit that I am very pessimistic about any conversation that\ninvolves scalability. It is often said that \"talking politics lowers\nyour IQ by 25 points\". Bitcoin scalability conversations seem to drain\n50 points. (Instead of conversing, I think people should quietly work on\nwhatever they are passionate about until their problem either is solved,\nor it goes away for some other reason, or until we all agree to just\nstop talking about it.)\n\nCheers,\nPaul\n\n[1] http://www.drivechain.info/faq/#can-sidechains-really-help-with-scaling\n[2] http://www.truthcoin.info/blog/blind-merged-mining/\n[3] https://s3.amazonaws.com/peter.todd/bitcoin-wizards-13-10-17.log\n[4]\nhttps://www.youtube.com/watch?v=YErLEuOi3xU&list=PLw8-\n6ARlyVciNjgS_NFhAu-qt7HPf_dtg&index=4\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/1d29ff66/attachment-0001.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-22T19:12:54",
                "message_text_only": "On Mon, May 22, 2017 at 5:19 PM, Paul Sztorc via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> In the future, when there is no block subsidy, a rich attacker can also do\n> that in mainchain Bitcoin.\n>\n\nI don't think they are the same.\n\nWith Bitcoin, you only get to reverse recent transactions.  If you actually\nreversed 2-3 weeks of transactions, then the Bitcoin price would fall,\ndestroying the value of the additional coins you managed to obtain.  Even\nif their was no price fall, you can only get a fraction of the total.\n\nWith BMM, you can \"buy\" the entire reserve of the sidechain by paying\n(timeout) * (average tx fees).  If you destroy a side-chain's value, then\nthat doesn't affect the value of the bitcoins you manage to steal.\n\nThe incentive could be eliminated by restricting the amount of coin that\ncan be transferred from the side chain to the main chain to a fraction of\nthe transaction fee pay to the bitcoin miners.\n\nIf the side chain pays x in fees, then at most x/10 can be transferred from\nthe side chain to the main chain.  This means that someone who pays for\nblock creation can only get 10% of that value transferred to the main chain.\n\nMain-chain miners could support fraud proofs.  A pool could easily run an\narchive node for the side chain in a different data center.\n\nThis wouldn't harm the performance of their main operations, but would\nguarantee that the side chain data is available for side chain validators.\n\nThe sidechain to main-chain timeout would be more than enough for fraud\nproofs to be constructed.\n\nThis means that the miners would need to know what the rules are for the\nside chain, so that they can process the fraud proofs.  They would also\nneed to run SPV nodes for the side chain, so they know which sidechain\nheaders to blacklist.\n\n\n> In point of fact, the transactions *are* validated...by sidechain full\n> nodes, same as Bitcoin proper.\n>\n>\nThe big difference is that Bitcoin holds no assets on another chain.  A\nside-chain's value is directly linked to the fact that it has 100% reserves\non the Bitcoin main chain.  That can be targeted for theft.\n\n\n> Paul\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/56029b8c/attachment.html>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-22T20:00:19",
                "message_text_only": "On May 22, 2017 3:13 PM, \"Tier Nolan via bitcoin-dev\" <bitcoin-dev at lists.\nlinuxfoundation.org> wrote:\n\nOn Mon, May 22, 2017 at 5:19 PM, Paul Sztorc via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> In the future, when there is no block subsidy, a rich attacker can also do\n> that in mainchain Bitcoin.\n>\n\nI don't think they are the same.\n\nWith Bitcoin, you only get to reverse recent transactions.  If you actually\nreversed 2-3 weeks of transactions, then the Bitcoin price would fall,\ndestroying the value of the additional coins you managed to obtain.  Even\nif their was no price fall, you can only get a fraction of the total.\n\n\nI would replace \"Bitcoins you manage to steal\" with \"Bitcoins you manage to\ndouble-spend\". Then, it still seems the same to me.\n\n\nWith BMM, you can \"buy\" the entire reserve of the sidechain by paying\n(timeout) * (average tx fees).  If you destroy a side-chain's value, then\nthat doesn't affect the value of the bitcoins you manage to steal.\n\n\nIt may destroy great value if it shakes confidence in the sidechain\ninfrastructure. Thus, the value of the stolen BTC may decrease, in addition\nto the lost future tx fee revenues of the attacked chain.\n\nhttp://www.truthcoin.info/blog/drivechain/#drivechains-security\n\nIn my view, sidechains should only exist at all if they positively impact\nBitcoin's value. It is therefore desirable for miners to steal from chains\nthat provide no value-add.\n\n\n\n\n> In point of fact, the transactions *are* validated...by sidechain full\n> nodes, same as Bitcoin proper.\n>\n>\nThe big difference is that Bitcoin holds no assets on another chain.  A\nside-chain's value is directly linked to the fact that it has 100% reserves\non the Bitcoin main chain.  That can be targeted for theft.\n\n\nAgain, I don't really think it is that different. One could interchange\n\"recent txns\" (those which could be double-spent within 2-3 weeks) with\n\"sidechain deposit tnxs\".\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/8a42bd04/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-23T09:51:26",
                "message_text_only": "On Mon, May 22, 2017 at 9:00 PM, Paul Sztorc <truthcoin at gmail.com> wrote:\n\n> I would replace \"Bitcoins you manage to steal\" with \"Bitcoins you manage\n> to double-spend\". Then, it still seems the same to me.\n>\n>\nWith double spending, you can only get ownership of coins that you owned at\nsome point in the past.  Coins that are owned by someone else from coinbase\nto their current owners cannot be stolen by a re-org (though they can be\nmoved around).\n\nWith BMM, you can take the entire reserve.  Creating a group of double\nspenders can help increase the reward.\n\n\n>\n> It may destroy great value if it shakes confidence in the sidechain\n> infrastructure. Thus, the value of the stolen BTC may decrease, in addition\n> to the lost future tx fee revenues of the attacked chain.\n>\n> http://www.truthcoin.info/blog/drivechain/#drivechains-security\n>\n>\nThat is a fair point.  If sidechains are how Bitcoin is scaled, then\nshaking confidence in a side-chain would shake confidence in Bitcoin's\nfuture.\n\nI wasn't thinking of a direct miner 51% attack.  It is enough to assume\nthat a majority of the miners go with the highest bidder each time.\n\nIf (average fees) * (timeout) is less than the total reserves, then it is\nworth it for a 3rd party to just bid for his theft fork.  Miners don't have\nto be assumed to be coordinating, they just have to be assumed to take the\nhighest bid.\n\nAgain, I don't really think it is that different. One could interchange\n> \"recent txns\" (those which could be double-spent within 2-3 weeks) with\n> \"sidechain deposit tnxs\".\n>\n\nIt is not \"recent txns\", it is recent txns that you (or your group) have\nthe key for.  No coordination is required to steal the entire reserve from\nthe sidechain.\n\nRecent txns and money on the sidechain have the property that they are\nriskier than money deep on the main chain.  This is the inherent point\nabout sidechains, so maybe not that big a deal.\n\nMy concern is that you could have a situation where an attack is possible\nand only need to assume that the miners are indifferent.\n\nIf the first attacker who tries it fails (say after creating a fork that is\n90% of the length required, so losing a lot of money), then it would\ndiscourage others.   If he succeeds, then it weakens sidechains as a\nconcept and that creates the incentive for miners to see that he fails.\n\nI wonder how the incentives work out.  If a group had 25% of the money on\nthe sidechain, they could try to outbid the attacker.\n\nIn fact, since the attacker, by definition, creates an illegal fork, the\neffect is that he reduces the block rate for the side chain (possibly to\nzero, if he wins every auction).  This means that there are more\ntransactions per block, if there is space, or more fees per transaction, if\nthe blocks are full.\n\nIn both cases, this pushes up the total fees per block, so he has to pay\nmore per block, weakening his attack.  This is similar to where transaction\nspam on Bitcoin is self-correcting by increasing the fees required to keep\nthe spam going.\n\nIs there a description of the actual implementation you decided to go with,\nother than the code?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/69551868/attachment.html>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-23T14:22:43",
                "message_text_only": "On 5/23/2017 5:51 AM, Tier Nolan via bitcoin-dev wrote:\n> On Mon, May 22, 2017 at 9:00 PM, Paul Sztorc <truthcoin at gmail.com\n> <mailto:truthcoin at gmail.com>> wrote:\n> \n>     I would replace \"Bitcoins you manage to steal\" with \"Bitcoins you\n>     manage to double-spend\". Then, it still seems the same to me.\n> \n> \n> With double spending, you can only get ownership of coins that you owned\n> at some point in the past.  Coins that are owned by someone else from\n> coinbase to their current owners cannot be stolen by a re-org (though\n> they can be moved around).\n\nI'm not sure it makes much of a difference. First of all, in point of\nfact, the miners themselves own the coins from the coinbase. But more\nimportantly, even if miners did not explicitly own the coins, they might\nprofit by being bribed -- these bribes would come from people who did\nown the coins.\n\nThe principle is that value \"v' has been taken from A and given to B.\nThis is effectively coercive activity, and therefore itself has value\nproportional to 'v'.\n\n> \n> With BMM, you can take the entire reserve.  Creating a group of double\n> spenders can help increase the reward.\n>  \n> \n> \n>     It may destroy great value if it shakes confidence in the sidechain\n>     infrastructure. Thus, the value of the stolen BTC may decrease, in\n>     addition to the lost future tx fee revenues of the attacked chain.\n> \n>     http://www.truthcoin.info/blog/drivechain/#drivechains-security\n>     <http://www.truthcoin.info/blog/drivechain/#drivechains-security>\n> \n> \n> That is a fair point.  If sidechains are how Bitcoin is scaled, then\n> shaking confidence in a side-chain would shake confidence in Bitcoin's\n> future.\n\nYes. The more value _on_ the sidechain, the more abhorrent the malfeasance.\n\n> \n> I wasn't thinking of a direct miner 51% attack.  It is enough to assume\n> that a majority of the miners go with the highest bidder each time.\n\nWhat do you think of my argument, that we already labor under such an\nassumption? An attacker could pay fees today equal to greater than\nsum(blockreward_(last N block)). According to you this would force a\nreorg, even on mainchain (pre-sidechain) Bitcoin. Yet this has never\nhappened.\n\nIt seems that this argument fully reduces to the \"what will happen when\nthe block subsidy falls to zero\" question.\n\n> \n> If (average fees) * (timeout) is less than the total reserves, then it\n> is worth it for a 3rd party to just bid for his theft fork.  Miners\n> don't have to be assumed to be coordinating, they just have to be\n> assumed to take the highest bid.\n> \n>     Again, I don't really think it is that different. One could\n>     interchange \"recent txns\" (those which could be double-spent within\n>     2-3 weeks) with \"sidechain deposit tnxs\".\n> \n> \n> It is not \"recent txns\", it is recent txns that you (or your group) have\n> the key for.  No coordination is required to steal the entire reserve\n> from the sidechain.\n\nSee above (?) for why I still feel they are comparable, if not identical.\n\n> \n> Recent txns and money on the sidechain have the property that they are\n> riskier than money deep on the main chain.  This is the inherent point\n> about sidechains, so maybe not that big a deal. \n\nYes. Sidechains have newer, more interesting features, and\nsimultaneously more risk.\n\n\n> \n> My concern is that you could have a situation where an attack is\n> possible and only need to assume that the miners are indifferent.\n\nAgain, I think that we _already_ need to eliminate any assumption of\n\"charitable miners\".\n\n> \n> If the first attacker who tries it fails (say after creating a fork that\n> is 90% of the length required, so losing a lot of money), then it would\n> discourage others.   If he succeeds, then it weakens sidechains as a\n> concept and that creates the incentive for miners to see that he fails.\n> \n> I wonder how the incentives work out.  If a group had 25% of the money\n> on the sidechain, they could try to outbid the attacker.\n\nYes, we may see interesting behavior where people buy up these\nliabilities using the LN. In my original post, I mention that miners\nthemselves may purchase these liabilities (at competitive rates, even if\nthese arent the idealized 1:1). At this point, miners would be paying\nthemselves and there would be no agency problem.\n\n> \n> In fact, since the attacker, by definition, creates an illegal fork, the\n> effect is that he reduces the block rate for the side chain (possibly to\n> zero, if he wins every auction).  This means that there are more\n> transactions per block, if there is space, or more fees per transaction,\n> if the blocks are full. \n> \n> In both cases, this pushes up the total fees per block, so he has to pay\n> more per block, weakening his attack.  This is similar to where\n> transaction spam on Bitcoin is self-correcting by increasing the fees\n> required to keep the spam going.\n> \n> Is there a description of the actual implementation you decided to go\n> with, other than the code?\n\nIf you haven't seen http://www.truthcoin.info/blog/drivechain/ , that is\nprobably the most human-readable description.\n\nCheers,\nPaul"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-24T08:50:22",
                "message_text_only": "On Tue, May 23, 2017 at 3:22 PM, Paul Sztorc <truthcoin at gmail.com> wrote:\n\n>\n> If you haven't seen http://www.truthcoin.info/blog/drivechain/ , that is\n> probably the most human-readable description.\n>\n\nI guess I was looking for the detail you get in the code, but without\nhaving to read the code.\n\nMy quick reading gives that the sidechain codes (critical hashes) are added\nwhen a coinbase is processed.\n\nAny coinbase output that has the form \"OP_RETURN <32 byte push>\" counts as\na potential critical hash.\n\nWhen the block is processed, the key value pair (hash, block_height) is\nadded to a hash map.\n\nThe OP_BRIBE opcode checks that the given hash is in the hash map and\nreplaces the top element on the stack with the pass/fail result.\n\nIt doesn't even check that the height matches the current block, though\nthere is a comment that that is a TODO.\n\nI agree with ZmnSCPxj, when updating a nop, you can't change the stack.  It\nhas to fail the script or do nothing.\n\nOP_BRIBE_VERIFY would cause the script to fail if the hash wasn't in the\ncoinbase, or cause a script failure otherwise.\n\nAnother concern is that you could have multiple bribes for the same chain\nin a single coinbase.  That isn't fair and arguably what the sidechain\nminer is paying for is to get his hash exclusively into the block.\n\nI would suggest that the output is\n\nOP_RETURN <sidechain_id> <critical hash>\n\nThen add the rule that only the first hash with a particular sidechain id\nactually counts.\n\nThis forces the miner to only accept the bribe from 1 miner for each\nsidechain for each block.  If he tries to accept 2, then only the first one\ncounts.\n\nOP_BRIBE_VERIFY could then operate as follows\n\n<block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY\n\nThis causes the script to fail if\n  <block height> does not match the block height, or\n  <critical hash> is not the hash for the sidechain with <sidechain_id>, or\n  there is no hash for that sidechain in the block's coinbase\n\nIf you want reduce the number of drops, you could serialize the info into a\nsingle push.\n\nThis has the advantage that a sidechain miner only has to pay if his block\nis accepted in the next bitcoin block.  Since he is the only miner for that\nsidechain that gets into the main bitcoin block, he is pretty much\nguaranteed to form the longest chain.\n\nWithout that rule, sidechain miners could end up having to pay even though\nit doesn't make their chain the longest.\n\nHow are these transactions propagated over the network?  For relaying, you\ncould have the rule that the opcode passes as long as <block height> is\nnear the current block height.  Maybe require that they are in the future.\nThey should be removed from the memory pool once the block height has\narrived, so losing miners can re-spend those outputs.\n\nThis opcode can be validated without needing to look at other blocks, which\nis good for validating historical blocks.\n\nI am still looking at the deposit/withdrawal code.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/ac8f7126/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-24T10:05:38",
                "message_text_only": "On Wed, May 24, 2017 at 9:50 AM, Tier Nolan <tier.nolan at gmail.com> wrote:\n\n> OP_BRIBE_VERIFY could then operate as follows\n>\n> <block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY\n>\n> This causes the script to fail if\n>   <block height> does not match the block height, or\n>   <critical hash> is not the hash for the sidechain with <sidechain_id>, or\n>   there is no hash for that sidechain in the block's coinbase\n>\n>\nI was thinking more on the process for these transactions.\n\nI assume that the process is\n\n- sidechain miner broadcasts transaction with OP_BRIBE output\n- this transaction ends up in the memory pool of miners\n- Miners add the transaction to their next block\n- Miners add a transaction which spends the output to one of their own\naddresses\n\nI think you need an additional rule that OP_BRIBE checks fails unless the\noutput is locked 100 or more blocks.\n\nThe output script would end up something like\n\nIF\n   <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY\nELSE\n  <public key> OP_CHECKSIG\nENDIF\n\nThis output acts like \"anyone can spend\" for the one block height.\nOtherwise, only the sidechain miner can spend the output.\n\nThis allows the sidechain miner to reclaim their coins if the transaction\nends up in a different block.\n\nOP_BRIBE_VERIFY would have an additional rule\n\nThe script to fails if\n  one or more of the transaction outputs start with something other than\nthe template\n  <block height> does not match the block height, or\n  <critical hash> is not the hash for the sidechain with <sidechain_id>, or\n  there is no hash for that sidechain in the block's coinbase\n\nThe template is\n  <100> OP_CHECKSEQUENCE_VERIFY\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/02094798/attachment.html>"
            },
            {
                "author": "CryptAxe",
                "date": "2017-05-24T17:32:22",
                "message_text_only": "Your assumptions of the bribe process are indeed correct you seem to\nhave a pretty good handle on all of that.\n\nHopefully I can clear up a few things. BMM among other things is still a\nwork in progress so you'll have to wait a\nbit longer before any reorg code is on github. The \"ratchet\" system on\ngithub right now just has the block hash\npart of the critical hash script. The completed version needs to check\nthe sidechain number (ID) and the sidechain\nblock number in the script. Also the block number can only change by +1\nor -1, so when a new h* is added to the\nqueue it must be compared to the most recent h* in the queue.\nstd::abs(queue.back().nHeight - ToAdd.nHeight) must equal 1.\n\nHere's what the script looks like on github:\nNote that the h* is just a block hash.\n\nscript << OP_RETURN << ToByteVector(h*);\n\nHere's what I'm testing right now as I'm working on BMM:\n\nscript << OP_RETURN << CScriptNum::serialize(nSidechain) <<\nCScriptNum(nSidechainHeight) << ToByteVector(sidechain blinded block\nhash h*)\n\nOne other thing I want to make sure is clear enough is that the block\nnumber in the critical hash script is\na sidechain block number, not a mainchain block number. That might mess\nup the new format you have\nsuggested for bribes. And the reason a sidechain miner would want to\nrefund their bribe is if the h* doesn't\nend up in a coinbase after a number of blocks, making their blinded\nblock on the sidechain invalid as tx's\nwill be spent in other blocks that do get their h* in a coinbase.\n\nWe were thinking about making bribe outputs have a maturity period like\ngenerated coins. You\nthink that they should be locked for >100 blocks by having OP_BRIBE also\ncheck the lock time?\n\nI like all of your suggestions so far, thank you for taking a look!\n\n\nOn 05/24/2017 03:05 AM, Tier Nolan via bitcoin-dev wrote:\n> On Wed, May 24, 2017 at 9:50 AM, Tier Nolan <tier.nolan at gmail.com\n> <mailto:tier.nolan at gmail.com>> wrote:\n>\n>     OP_BRIBE_VERIFY could then operate as follows\n>\n>     <block height> <sidechain_id> <critical hash> OP_BRIBE_VERIFY\n>\n>     This causes the script to fail if\n>       <block height> does not match the block height, or\n>       <critical hash> is not the hash for the sidechain with\n>     <sidechain_id>, or\n>       there is no hash for that sidechain in the block's coinbase\n>\n>\n> I was thinking more on the process for these transactions.\n>\n> I assume that the process is\n>\n> - sidechain miner broadcasts transaction with OP_BRIBE output\n> - this transaction ends up in the memory pool of miners\n> - Miners add the transaction to their next block\n> - Miners add a transaction which spends the output to one of their own\n> addresses\n>\n> I think you need an additional rule that OP_BRIBE checks fails unless\n> the output is locked 100 or more blocks.\n>\n> The output script would end up something like\n>\n> IF\n>    <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY\n> ELSE\n>   <public key> OP_CHECKSIG\n> ENDIF\n>\n> This output acts like \"anyone can spend\" for the one block height. \n> Otherwise, only the sidechain miner can spend the output.\n>\n> This allows the sidechain miner to reclaim their coins if the\n> transaction ends up in a different block.\n>\n> OP_BRIBE_VERIFY would have an additional rule\n>\n> The script to fails if\n>   one or more of the transaction outputs start with something other\n> than the template\n>   <block height> does not match the block height, or\n>   <critical hash> is not the hash for the sidechain with\n> <sidechain_id>, or\n>   there is no hash for that sidechain in the block's coinbase\n>\n> The template is\n>   <100> OP_CHECKSEQUENCE_VERIFY\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/6970f30f/attachment-0001.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2017-05-25T22:08:00",
                "message_text_only": "On Wed, May 24, 2017 at 6:32 PM, CryptAxe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Also the block number can only change by +1 or -1, so when a new h* is\n> added to the\n> queue it must be compared to the most recent h* in the queue.\n> std::abs(queue.back().nHeight - ToAdd.nHeight) must equal 1.\n>\n\nI think it is better to have it locked to a particular bitcoin height and\nif it doesn't get included in that block, the sidechain miner can re-claim\nit.\n\nThis could be taken to the extreme where the sidechain miner specifies a\nparticular parent of the claiming block.\n\nThe output should have a standard template, so miners can easily find bids.\n\nThe template on my previous post was:\n\nIF\n   <block height> <chain_id> <critical hash> OP_BRIBE_VERIFY\nELSE\n  <public key> OP_CHECKSIG\nENDIF\n\n\nIf the output is spent by the miner for block <block height>, then the\nsidechain miner has spent the funds.\n\nOtherwise, the sidechain miner can use the else branch to reclaim his money.\n\nThe sidechain miner could also reclaim his money if the transaction was\nincluded in an earlier block.  That would defeat the purpose of the bribe.\nBitcoin miners would have a (justified) incentive to not allow Bribe\noutputs to be spent \"early\".\n\nThe bribe transactions could be created with no fees.  This would mean that\nit is pointless for bitcoin miners to include them in blocks unless they\nare claiming the outputs.\n\nThe relay rules would need to be modified to handle that.  Pools could\nallow bids to be made directly, but that is less decentralized.\n\nHere's what I'm testing right now as I'm working on BMM:\n>\n> script << OP_RETURN << CScriptNum::serialize(nSidechain) <<\n> CScriptNum(nSidechainHeight) << ToByteVector(sidechain blinded block hash\n> h*)\n>\n\nI don't think OP_BRIBE should care about info for the side chain.  The only\nthing that is necessary is to indicate which sidechain.\n\nYou could just define the critical hash as\n\nHash( SideChainHeight | blinded h* )\n\nFor bribe payout release, it needs to give that particular miner an\nadvantage over all competitors, so their block forms the longest chain on\nthe sidechain (assuming their block is actually valid).\n\n> One other thing I want to make sure is clear enough is that the block\n> number in the critical hash script is\n> a sidechain block number, not a mainchain block number.\n>\nThe sidechain miner is saying that they will pay the bribe but only if\ntheir block is included in the main chain.  The means that main chain\nheight is important.\n\nThey are paying for their block to be placed ahead of all competing blocks\nfor their chain.\n\nIt does mean that the side-chain can have at most the same number of blocks\nas bitcoin.\n\n>\n> We were thinking about making bribe outputs have a maturity period like\n> generated coins. You\n> think that they should be locked for >100 blocks by having OP_BRIBE also\n> check the lock time?\n>\n\nWell, it depends on the exact rules for OP_BRIBE.\n\nThe process I see is:\n\n- sidechain miner submits a bribe transaction which pays to op bribe\n- bitcoin miner includes that transaction in his block (or it could be\nincluded in a previous block)\n- bitcoin miner includes a claim transaction in his block\n\nThe claim transaction spends the outputs from the bribe transaction.  If\nthe claim transaction is block height locked, then it violates the rules\nthat previous soft-forks have followed.\n\nFor previous opcode changes there was a requirement that if a transaction\nwas accepted into block N, then it must also be acceptable in block (N+1).\n\nThe only (unavoidable) exceptions were double spends and coinbases outputs.\n\nThis means that the same protection should be added to your claim\ntransaction.\n\nYou could do it by requiring all outputs of the claim transaction to start\nwith\n\n<100> CHECK_SEQUENCE_VERIFY DROP ...\n\nThis is only a few bytes extra at the start of the output script.\n\nThis means you can't use witness or P2SH output types for any of the\noutputs, but that isn't that important.  The point of the transaction is to\nmake a payment.\n\nAn alternative would be to just add the rule as part of soft-fork\ndefinition.  You could define a claim transaction as one that spends at\nleast one OP_BRIBE output and therefore, all its outputs have a 100 block\ndelay.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170525/f02cd841/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-23T00:13:55",
                "message_text_only": "Good morning,\n\n>What you read is only an introduction of BMM. You may also consult the notes (at the bottom of the BMM post) or the code, although this is time consuming of course.\n\nLooking over the code, I have a question: Is OP_BRIBE supposed to be softforked in, or hardforked? From my understanding, the code as published in your linked github cannot be softforked in, since it is not a softfork-compatible replacement for OP_NOP: it replaces the stack top value with a 0/1 value. Both CLTV and CSV do not touch the stack, only flag an error if they fail.\n\n(What happens if the h* to be put in the coinbase, by chance - even very unlikely chance - is 0? Then <h*> OP_NOP4 is not the same as <h*> OP_BRIBE scripts in result - the former will be rejected by old nodes, the latter will be accepted by new nodes)\n\nDoes Drivechain require a hardfork? My understanding is that you want to use some kind of softforked anyone-can-spend transaction to use Drivechain. So I don't quite understand why OP_BRIBE is written the way it is.\n\nIs OP_BRIBE the same as the OP_h_is_in_coinbase operation you described?\n\nHow is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot a sidechain scan the block for OP_RETURN attesting that the block hash is present in the block? OP_BRIBE encodes <h*> twice (once in the transaction, once in the coinbase), OP_RETURN encodes it once (once in the transaction)\n\n>The literal answer to your question is that mainchain Bitcoin will notice that, for the second withdrawal, the sum of the inputs is less than the sum of the outputs and they the transaction is therefore invalid.\n\nYou misunderstand. The first withdrawal was done by double-spending, and exchanging your sidechain funds for mainchain funds using some off-chain method. The second withdrawal is done on-chain.\n\nThat said, I confused OP_h_is_in_coinbase as your method of getting out of the sidechain into the mainchain. It seems, OP_h_is_in_coinbase is only for blind mining?\n\n>I feel that my proposal is more secure, as it can operate healthily and quickly while using spv proofs which are much slower and much much easier to audit.\n\nI don't quite understand how Drivechain handles sidechain reorgs, while keeping Bitcoin miners blinded. It seems sidechains need to be known (\"seen\") by the miner, so I don't see what is being blinded by blinded merge mining.\n\n>>seems to me that your OP_is_h_in_coinbase should scan a series of sidechain block headers backed by mainchain (meaning at the minimum that sidechains should have some common header format prefix), rather than just mainchain depth as your article seems to imply.\n>\n>How would security be improved as a result? In either case, 51% of hashrate can cause a reorg. The sidechain software itself does scan block headers, of course.\n\nI misunderstand the purpose of your OP_is_h_in_coinbase, sorry.\n\n>>Blind merged mining seems strictly inferior ... a rich attacker can simply reorg the sidechain outright without playing such games.\n>\n>In the future, when there is no block subsidy, a rich attacker can also do that in mainchain Bitcoin.\n\nI see. However, block subsidies will drop far in the future, do you mean to say, that sidechains will be used only in the far future?\n\n>>How does your proposal handle multiple side block creators on the same sidechain, with the possibility that chain splits occur?\n>\n>The side block is only \"mined\" if it is committed to in a mainchain Bitcoin blog, and each mainchain block can only contain one block per sidechain. In this way, drivechain sidechains are different from classical Namecoin merged mining (where one _could_ run the entire system, mining included, without interfacing with Bitcoin at all).\n\nI assume you mean \"mainchain Bitcoin block\" here.\n\nWhat mechanism ensures only one mainchain block can contain only one sidechain block? It seems, this isn't implemented by OP_BRIBE yet. Can you elaborate on this mechanism?\n\n>>Regarding your dig about people who dislike data centers, the main issue with miners blindly accepting sidechain commitments is that it violates \"Don't trust, verify\", not that allows datacenters to be slightly smaller by not including side:nodes.\n>\n>As I explain early on, in earlier rounds of peer review, the focus was on harms the sidechain technology might do to mainchain Bitcoin, and the \"datacenter point\" was specifically the chief objection raised. So I am afraid you are entirely incorrect.\n\nI see. It seems, the main problem, is that sidechains can be used to sneak in block size increases. Of course, the advantage of sidechains, is that when it increases block size irresponsibly, only those who participated in the sidechain will suffer.\n\n>In point of fact, the transactions *are* validated...by sidechain full nodes, same as Bitcoin proper.\n\nBut from blind merge mining by itself, how would the blinded merge miner know that there exists an actual sidechain full node that actually did validation?\n\nIt seems, that the \"blinding\" in merge mining does not seem to be at all useful without the miner actually seeing the sidechain. If you want miners to upgrade to side:fullnode as well, what would then be the point of blinding? Why not just ordinary merge mining?\n\nPerhaps the datacenter point is simply that your proposal suggests to reduce the size of the datacenter by removing surge suppressors and UPS's, to avoid some definition of \"datacenter is a room with >$XXX of equipment\".\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/55bb9433/attachment.html>"
            },
            {
                "author": "Paul Sztorc",
                "date": "2017-05-23T14:12:24",
                "message_text_only": "On 5/22/2017 8:13 PM, ZmnSCPxj wrote:\n> Good morning,\n> \n> \n> \n>>What you read is only an introduction of BMM. You may also consult the\n> notes (at the bottom of the BMM post) or the code, although this is time\n> consuming of course.\n> \n> Looking over the code, I have a question: Is OP_BRIBE supposed to be\n> softforked in, or hardforked?\n\nSoftforked, of course.\n\n  From my understanding, the code as\n> published in your linked github cannot be softforked in, since it is not\n> a softfork-compatible replacement for OP_NOP: it replaces the stack top\n> value with a 0/1 value.  Both CLTV and CSV do not touch the stack, only\n> flag an error if they fail.\n\nYour understanding may exceed my own. I don't understand the principle\nof your distinction, as it seems to me that one could add a new protocol\nrule which says that the block is invalid unless the OP Code does\nresults in arbitrary-item-x. The intent is to mimic CLTV or CSV\nbehavior, by causing something that would otherwise succeed, to fail, if\narbitrary new conditions are met.\n\n> \n> (What happens if the h* to be put in the coinbase, by chance - even very\n> unlikely chance - is 0?  Then <h*> OP_NOP4 is not the same as <h*>\n> OP_BRIBE scripts in result - the former will be rejected by old nodes,\n> the latter will be accepted by new nodes)\n\nThat would indeed be a bug, if it happened as you described. I will\ncheck when I get the chance, thanks.\n\n> \n> Is OP_BRIBE the same as the OP_h_is_in_coinbase operation you described?\n\nYes. Sorry if that was confusing.\n\n> \n> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot\n> a sidechain scan the block for OP_RETURN attesting that the block hash\n> is present in the block?\n\nThe sidechain software can indeed, but the mainchain software cannot\n(without making validation of both chains part of the mainchain, which\ndefeats the original purpose of sidechains).\n\nThe purpose of OP_BRIBE is to allow \"Sam\" (on the sidechain) and \"Mary\"\n(a mainchain miner) to work together. Sam would pay X BTC to Mary, if\nMary could provide Sam with some guarantee that Sam's sidechain block\n[defined by h*] would make it into the largest chain.\n\nSo, as I see it, this needs to be a mainchain consensus rule, but one\nwhich enforces the bare minimum criteria.\n\n\n> \n>>The literal answer to your question is that mainchain Bitcoin will\n> notice that, for the second withdrawal, the sum of the inputs is less\n> than the sum of the outputs and they the transaction is therefore invalid.\n> \n> You misunderstand.  The first withdrawal was done by double-spending,\n> and exchanging your sidechain funds for mainchain funds using some\n> off-chain method.  The second withdrawal is done on-chain.\n\nIf A, B, and C are transacting, and each has an account on both chains.\nThen your example would be something like:\n\n1. main:A sends 100 to side:A, then transfers 100 to side:B in exchange\nfor B's good or service (provided on the sidechain)\n2. side:B attempts to move side-to-main with the 100 BTC, using the\nlightning network. He swaps 100 side:BTC for 100 of C's main:BTC.\n3. C attempts to move side-to-main, using the slow, settlement method.\n4. C's side-to-main sidechain tx (wt) is bundled with others and becomes\na withdrawal attempt (WT^)\n5. The WT^ attempt is initiated on the mainchain.\n6. After a waiting period, the WT^ begins to accumulate ACKs or NACKs\n(upvotes / downvotes), on the mainchain.\n7. The transaction either succeeds or fails.\n\nI'm not sure, but your question seems to concern B, who exploits a reorg\nthat happens just after step 2. After the reorg, the sidechain chain\nhistory will have a different side-to-main withdrawal in part 3. The\ntime between each of these step is very long, on the order of weeks\n(summing to a length of time totaling months), for exactly this reason\n(as well as to encourage people to avoid using this 'formal' method, in\nfavor of the cooperative LN and Atomic Swaps).\n\nI think that this principle of scale (ie, very VERY slow withdrawals) is\nimportant and actually makes the security categorically different.\n\nFor extraordinary DAO-like situations, disinterested mainchain miners\nmerely need a single bit of information (per sidechain), which is\n\"distress=true\", and indicates to them to temporarily stop ACKing\nwithdrawals from the sidechain. This alone is enough to give the reorg\nan unlimited amount of time to work itself out.\n\n\n> \n> That said, I confused OP_h_is_in_coinbase as your method of getting out\n> of the sidechain into the mainchain.  It seems, OP_h_is_in_coinbase is\n> only for blind mining?\n\nCorrect\n\n> \n> \n> \n>>I feel that my proposal is more secure, as it can operate healthily and\n> quickly while using spv proofs which are much slower and much much\n> easier to audit.\n> \n> I don't quite understand how Drivechain handles sidechain reorgs, while\n> keeping Bitcoin miners blinded.  It seems sidechains need to be known\n> (\"seen\") by the miner, so I don't see what is being blinded by blinded\n> merge mining.\n\nMainchain miners do need to maintain some data about the sidechains, but\nthis is very minimal, and certainly does not include the transaction\ndata (or arbitrary messages) of the sidechain.\n> \n> \n>>>seems to me that your OP_is_h_in_coinbase should scan a series of\n> sidechain block headers backed by mainchain (meaning at the minimum that\n> sidechains should have some common header format prefix), rather than\n> just mainchain depth as your article seems to imply.\n>>\n>>How would security be improved as a result? In either case, 51% of\n> hashrate can cause a reorg. The sidechain software itself does scan\n> block headers, of course. \n> \n> I misunderstand the purpose of your OP_is_h_in_coinbase, sorry.\n> \n\nNo problem.\n\n> \n>>>Blind merged mining seems strictly inferior ... a rich attacker can\n> simply reorg the sidechain outright without playing such games.\n>>\n>>In the future, when there is no block subsidy, a rich attacker can also\n> do that in mainchain Bitcoin.\n> \n> I see.  However, block subsidies will drop far in the future, do you\n> mean to say, that sidechains will be used only in the far future?\n\nIn one sense, I mean \"you have already endorsed this 'fees only will\nwork' premise, by endorsing Bitcoin\".\n\nIn another sense I mean \"isn't it great that you will get a tiny\npreview, today, of future-Bitcoin's behavior?\".\n\n> \n>>>How does your proposal handle multiple side block creators on the same\n> sidechain, with the possibility that chain splits occur?\n>>\n>>The side block is only \"mined\" if it is committed to in a mainchain\n> Bitcoin blog, and each mainchain block can only contain one block per\n> sidechain. In this way, drivechain sidechains are different from\n> classical Namecoin merged mining (where one _could_ run the entire\n> system, mining included, without interfacing with Bitcoin at all).\n> \n> I assume you mean \"mainchain Bitcoin block\" here.\n> \n> What mechanism ensures only one mainchain block can contain only one\n> sidechain block?  It seems, this isn't implemented by OP_BRIBE yet.  Can\n> you elaborate on this mechanism?\n\nThat mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe\nis itself only ~half of BMM. I admit it is getting a little confusing.)\n\nDrivechain requires a soft fork to add each new sidechain. It requires\nthis literally for a few good reasons...but the best is: there is an\nimplicit requirement that the miners not steal from the sidechain\nanyway. In this way drivechain knows how to keep track of what it should\nexpect.\n\n> \n> \n>>>Regarding your dig about people who dislike data centers, the main\n> issue with miners blindly accepting sidechain commitments is that it\n> violates \"Don't trust, verify\", not that allows datacenters to be\n> slightly smaller by not including side:nodes.\n>>\n>>As I explain early on, in earlier rounds of peer review, the focus was\n> on harms the sidechain technology might do to mainchain Bitcoin, and the\n> \"datacenter point\" was specifically the chief objection raised. So I am\n> afraid you are entirely incorrect.\n> \n> I see.  It seems, the main problem, is that sidechains can be used to\n> sneak in block size increases.  Of course, the advantage of sidechains,\n> is that when it increases block size irresponsibly, only those who\n> participated in the sidechain will suffer.\n\nPrecisely.\n\n> \n>>In point of fact, the transactions *are* validated...by sidechain full\n> nodes, same as Bitcoin proper.\n> \n> But from blind merge mining by itself, how would the blinded merge miner\n> know that there exists an actual sidechain full node that actually did\n> validation?\n> \n> It seems, that the \"blinding\" in merge mining does not seem to be at all\n> useful without the miner actually seeing the sidechain.  If you want\n> miners to upgrade to side:fullnode as well, what would then be the point\n> of blinding?  Why not just ordinary merge mining?\n> \n> Perhaps the datacenter point is simply that your proposal suggests to\n> reduce the size of the datacenter by removing surge suppressors and\n> UPS's, to avoid some definition of \"datacenter is a room with >$XXX of\n> equipment\".\n\nI hope that my replies above already help with these. If not, let me know.\n\nThanks for your attention,\nPaul"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2017-05-23T23:26:52",
                "message_text_only": "Good morning,\n\n>> (What happens if the h* to be put in the coinbase, by chance - even very\n>> unlikely chance - is 0? Then <h*> OP_NOP4 is not the same as <h*>\n>> OP_BRIBE scripts in result - the former will be rejected by old nodes,\n>> the latter will be accepted by new nodes)\n>\n>That would indeed be a bug, if it happened as you described. I will\n>check when I get the chance, thanks.\n\nIndeed, this is the reason why CLTV and CSV do not pop off their parameters when executed, and require a subsequent OP_DROP. I suggest, that OP_BRIBE should not manipulate stack (pop, then push 0/1); my understanding is that this requirement is necessary for compatibility with old nodes, which will not manipulate stack on OP_NOP4. Instead, OP_BRIBE should imitate CLTV and CSV code, and raise an error in script execution if the check fails.\n\n>>\n>> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot\n>> a sidechain scan the block for OP_RETURN attesting that the block hash\n>> is present in the block?\n>\n>The sidechain software can indeed, but the mainchain software cannot\n>(without making validation of both chains part of the mainchain, which\n>defeats the original purpose of sidechains).\n>\n>The purpose of OP_BRIBE is to allow \"Sam\" (on the sidechain) and \"Mary\"\n>(a mainchain miner) to work together. Sam would pay X BTC to Mary, if\n>Mary could provide Sam with some guarantee that Sam's sidechain block\n>[defined by h*] would make it into the largest chain.\n\nRegarding \"largest chain\", do you mean mainchain or sidechain?\n\nAn OP_RETURN is still some guarantee that it will make it into the longest mainchain. If OP_RETURN tx is in a shorter mainchain but not on the longer mainchain, then on the longer mainchain, the utxo's funding the OP_RETURN tx is still unspent and the OP_RETURN tx will still be mineable by any miner following the longer mainchain. The X BTC would be the OP_RETURN transaction's fee, which Mary would still want to mine into the longest mainchain, as it is still money on the table if it is not mined on the longest mainchain.\n\nOr, does OP_BRIBE somehow assure that Sam's block goes onto the longer sidechain? But then, do not side blocks refer to their previous side block to define the sidechain?\n\n>1. main:A sends 100 to side:A, then transfers 100 to side:B in exchange\n>for B's good or service (provided on the sidechain)\n>2. side:B attempts to move side-to-main with the 100 BTC, using the\n>lightning network. He swaps 100 side:BTC for 100 of C's main:BTC.\n>3. C attempts to move side-to-main, using the slow, settlement method.\n>4. C's side-to-main sidechain tx (wt) is bundled with others and becomes\n>a withdrawal attempt (WT^)\n>5. The WT^ attempt is initiated on the mainchain.\n>6. After a waiting period, the WT^ begins to accumulate ACKs or NACKs\n>(upvotes / downvotes), on the mainchain.\n>7. The transaction either succeeds or fails.\n>\n>I'm not sure, but your question seems to concern B, who exploits a reorg\n>that happens just after step 2. After the reorg, the sidechain chain\n>history will have a different side-to-main withdrawal in part 3. The\n>time between each of these step is very long, on the order of weeks\n>(summing to a length of time totaling months), for exactly this reason\n>(as well as to encourage people to avoid using this 'formal' method, in\n>favor of the cooperative LN and Atomic Swaps).\n>\n>I think that this principle of scale (ie, very VERY slow withdrawals) is\n>important and actually makes the security categorically different.\n\nI see.\n\nIs there some predictable schedule for side->main withdrawals? If a withdrawal is imminent, or if some actor can get \"insider information\" about whether a withdrawal is imminent, cannot some actor induce the above, with potentially shorter time to reach step 3?\n\nFrom my reading, Blockstream's sidechains proposal supports a reorg proof after a side->main withdrawal on the mainchain side, with a reorg proof burn window after the main:side->main withdrawal, preventing its utxo from being used. If the reorg proof is published and shows that a sidechain reorg invalidates a particular side->main withdrawal, then the main:side->main withdrawal's utxo is burned.\n\n>For extraordinary DAO-like situations, disinterested mainchain miners\n>merely need a single bit of information (per sidechain), which is\n>\"distress=true\", and indicates to them to temporarily stop ACKing\n>withdrawals from the sidechain. This alone is enough to give the reorg\n>an unlimited amount of time to work itself out.\n\nDo you have some document containing these details? I cannot find this in the blog posts I've read so far.\n\n>>>I feel that my proposal is more secure, as it can operate healthily and\n>> quickly while using spv proofs which are much slower and much much\n>> easier to audit.\n>>\n>> I don't quite understand how Drivechain handles sidechain reorgs, while\n>> keeping Bitcoin miners blinded. It seems sidechains need to be known\n>> (\"seen\") by the miner, so I don't see what is being blinded by blinded\n>> merge mining.\n>\n>Mainchain miners do need to maintain some data about the sidechains, but\n>this is very minimal, and certainly does not include the transaction\n>data (or arbitrary messages) of the sidechain.\n\nAs above, do you have document containing what data mainchain needs to track?\n\n>>>>Blind merged mining seems strictly inferior ... a rich attacker can\n>> simply reorg the sidechain outright without playing such games.\n>>>\n>>>In the future, when there is no block subsidy, a rich attacker can also\n>> do that in mainchain Bitcoin.\n>>\n>> I see. However, block subsidies will drop far in the future, do you\n>> mean to say, that sidechains will be used only in the far future?\n>\n>In one sense, I mean \"you have already endorsed this 'fees only will\n>work' premise, by endorsing Bitcoin\".\n\nI endorse this on the basis of Greg Maxwell's analysis that a block size limit is necessary to have a fee market.\n\n>That mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe\n>is itself only ~half of BMM. I admit it is getting a little confusing.)\n\nCan you provide the details of this mechanism? For example, does h* actually include some information identifying the sidechain and OP_BRIBE is supposed to do some additional checking not shown in your current code, or ....?\n\n>Drivechain requires a soft fork to add each new sidechain\n\nOh.\n\nMy understanding is that with Blockstream's zk-SNARKs, a new sidechain would not require a soft fork at all (or even miner voting on the validity of WT^: the validity of side:side->main transactions is assured by proof that the zk-SNARK checking that transaction was executed correctly, and the lack of a reorg proof during the burn window after the main:side->main).\n\nIs your model then, that each sidechain maintainer has to maintain a patchset or some plugin system to Core? And miners who want to support particular sidechains to modify their software, applying the patch for each sidechain they want to support?\n\nIt seems this is somewhat brittle and may cause sidechain coding problems to leak into mainchain.\n\nI think, it is much less interesting to have to softfork in every sidechain, rather than to support a general mechanism (zk-SNARK) to allow sidechains to be launched without any modification to Core code.\n\n>. It requires\n>this literally for a few good reasons...but the best is: there is an\n>implicit requirement that the miners not steal from the sidechain\n>anyway. In this way drivechain knows how to keep track of what it should\n>expect.\n\nIt seems to be, more of \"completely sighted merged mining\" than \"blind merge mining\".\n\n>> Perhaps the datacenter point is simply that your proposal suggests to\n>> reduce the size of the datacenter by removing surge suppressors and\n>> UPS's, to avoid some definition of \"datacenter is a room with >$XXX of\n>> equipment\".\n>\n>I hope that my replies above already help with these. If not, let me know.\n\nI find this point now moot, as drivechains require a softfork for each sidechain, and the size of the datacenter is pointless if there is some need to softfork in every sidechain.\n\nRegards,\nZmnXCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/f4a593fe/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-29T05:54:34",
                "message_text_only": "Seems to me an obvious use case for drive chains are to have high speed\nsmall transactions on a side chain, eventually cleared to the main chain.\n\nNot sure why miners would want this to fail any more than any other side\nchain, like Liquid or lightning.\n\n\n\nOn May 28, 2017 5:23 PM, \"Peter Todd via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nOn Mon, May 22, 2017 at 05:30:46PM +0200, Paul Sztorc wrote:\n> Surprisingly, this requirement (or, more precisely, this incentive) does\n> not effect miners relative to each other. The incentive to upgrade is only\n> for the purpose of preventing a \"theft\" -- defined as: an improper\n> withdrawal from a sidechain. It is not about miner revenues or the ability\n> to mine generally (or conduct BMM specifically). The costs of such a theft\n> (decrease in market price, decrease in future transaction fee levels)\nwould\n> be shared collectively by all future miners. Therefore, it would have no\n> effect on miners relative to each other.\n\nThat's not at all true. If I'm a miner with a better capability than another\nminer to prevent that theft, I have reasons to induce it to happen to give\nme\npolitical cover to pushing that other miner off the network.\n\nThis is a very similar problem to what we had with zeroconf double-spending,\nwhere entities such as Coinbase tried to pay off miners to guarantee\nsomething\nthat wasn't possible in a geninely decrentralized system: safe zeroconf\ntransactions.\n\n> Moreover, miners have other recourse if they are unable to run the node.\n> They can adopt a policy of simply rejecting (\"downvoting\") any withdrawals\n> that they don't understand. This would pause the withdraw process until\n> enough miners understand enough of what is going on to proceed with it.\n\nWhy are you forcing miners to run this code at all?\n\nEqually, you're opening up miners to huge political risks, as rejecting all\nwithdrawals is preventing users' from getting their money, which gives other\nminers a rational for kicking those miners off of Bitcoin entirely.\n\n> Finally, the point in dispute is a single, infrequent, true/false\nquestion.\n> So miners may resort to semi-trusted methods to supplement their decision.\n> In other words, they can just ask people they trust, if the withdrawal is\n> correct or not. It is up to users to decide if they are comfortable with\n> these risks, if/when they decide to deposit to a sidechain.\n\nWhy do you think this will be infrequent? Miners with a better ability to\nvalidate the drivechain have every reason to make these events more\nfrequent.\n\n> It is a matter of comparing the costs and benefits. Ignoring theft, the\n> costs are near-zero, and the benefits are >0. Specifically, they are: a\n> higher BTC price and greater transaction fees. Theft is discouraged by\n> attempting to tie a theft to a loss of confidence in the miners, as\n> described in the spec/website.\n> In general the incentives are very similar to those of Bitcoin itself.\n\nThis is also a very dubious security model - I would argue that Bitcoin is\nmuch\n*more* valuable if miners do everything they can to ensure that drivechains\nfail, given the huge risks involved. I would also argue that users should do\nuser-activated-soft-forks to ensure they fail.\n\nBy comparison, note Adam Back and my own efforts to ensure miners have a\nsmaller part in the ecosystem, with things like committed (encrypted)\ntransactions and my closed-seal-set/truth-list approach(1). We want to\ninvolve\nminers as little as possible in the consensus, not more.\n\nI have to ask: What use-cases do you actually see for drivechains? Why can't\nthose use-cases be done in the much safer client-side validation fashion?\n\n1) https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy\n\n--\nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/f238957b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Drivechain -- Request for Discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "CryptAxe",
                "Peter Todd",
                "ZmnSCPxj",
                "Tier Nolan",
                "Erik Aronesty",
                "Paul Sztorc"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 93509
        }
    },
    {
        "title": "[bitcoin-dev] A Method for Computing Merkle Roots of Annotated Binary Trees",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2017-05-22T07:05:49",
                "message_text_only": "## Introduction\nThis document aims to specify and justify a method for computing Merkle\nroots for tree structures whose nodes are annotated with other data.  While\nthis proposal could be used to replace Bitcoin's Merkle root calculation,\nit is primarily aimed at new applications such as MAST, (U)TXO commitments\nor other Merklized structures.\n\n## Background\nBitcoin uses a Merkle tree construction to build a commitment to a sequence\nof transactions for a Bitcoin block.  The main operation for computing a\nMerkle tree is one that takes the recursively computed Merkle roots of two\nbranches and combines them to compute the Merkle root of the tree with\nthose two branches.  In Bitcoin, a Merkle root is 256 bits and the\nconstruction is\n\n    MerkleRoot := SHA256(SHA256(LeftRoot \u22c5 RightRoot))\n\nOne problem with this construction is that it is unnecessarily expensive.\nWhile the concatenation of the LeftRoot and the RightRoot fits in 512 bits,\nthe size of a SHA256 chunk, a second chunk is needed to fit SHA256's\npadding.  This means that inner SHA256 call invokes the SHA256 compression\nfunction twice, once for each chunk.  The outer SHA256 call invokes the\nSHA256 compression function a third time.  Bitcoin's Merkle root procedure\ncalls the SHA256 compression function a total of three times per node.\n\nThe main purpose of composing two calls to the SHA256 hash function is to\nprotect against length extension attacks.  A length extension attack is\nwhere an attacker has access to the hash of a message `HASH(msg)` and,\nwithout knowing `msg`, is able to construct the hash of a new message\n`HASH(msg \u22c5 attackerMsg)`.  This is attack is usually used against poorly\nconstructed MACs (Message Authentication Codes).  In the case of Bitcoin\nthere are no secret messages that are hashed, so the outer call to SHA256\nis unnecessary.\n\nAs mentioned above, the inner call to SHA256 requires two chunks because of\nSHA256's padding.  For the MerkleRoot construction added padding value is\nalways\n\n\n0x80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n000000000000000000000000000000000200\n\nbecause the input is of a fixed length.  SHA256's padding function is\ndesigned\n\n1. to add bits to the message so that the resulting message size is a\nmultiple of the chunk size (which is 512-bits in the case of SHA256).\n2. to satisfy the Merkle--Damg\u00e5rd property which says that if we can find a\nhash collision in SHA256, which operates on variable length messages, then\nwe can find a hash collision in SHA256's compression function, which\noperates on fixed length messages.\n\nWe could remove the second call to the SHA256 compression function and use\nSHA256 without padding.  If we did, we would lose the Merkle--Damg\u00e5rd\nproperty.  While this may be acceptable for some use cases, we are still\nleft with no room to add annotation data held at a node.  For Bitcoin's\nMerkle tree this is not a problem, because its trees are not annotated.\nHowever, for other applications, we would need to add another chunk to hold\nthe annotation, which would mean adding back the second call to the SHA256\ncompression function per node of the tree.\n\n## A New Merkle Root Algorithm\nBelow is an algorithm for computing Merkle roots that directly uses the\nSHA256 compression function.  This algorithm operates on binary trees and\nsupports per node annotations.  Furthermore this proposal satisfies the\nMerkle--Damg\u00e5rd property and more.\n\n#### Remark 1\nAny finitely branching tree can be represented by a binary tree, so this\nconstruction also applies to arbitrary finitely branching trees.\n\nThe SHA256 compression function takes two inputs:\n\n1. A 256-bit value for the previous chunk in a chain, or an initial vector\nin the case of the first chunk.\n2. A 512-bit chunk of data.\n\n    sha256Compress : Word256 \u00d7 Word512 -> Word256\n\nIn total, the SHA256 compression function compresses 768-bits into\n256-bits.  The Merkle roots of two branches occupy 512 bits, and this\nleaves another 256-bits of space available for tags.\n\nLet us define a recursive type for binary trees annotated with tags.\n\n    type Tree tag where\n      Leaf   : tag                       -> Tree tag\n      Unary  : tag \u00d7 Tree tag            -> Tree tag\n      Binary : tag \u00d7 Tree tag \u00d7 Tree tag -> Tree tag\n\nWe define a recursive algorithm for trees whose tags are 256-bit Words (or\nwhose tags can be represented by 256-bit words).\n\n    merkleRoot : Tree Word256 -> Word256\n    merkleRoot (Leaf (t))                :=\nsha256Compress(sha256(ApplicationName),\n0b0^256 \u22c5 t)\n    merkleRoot (Unary (t, child))        := sha256Compress(merkleRoot(child),\n0b0^256 \u22c5 t)\n    merkleRoot (Binary (t, left, right)) := sha256Compress(merkleRoot(left),\nmerkleRoot(right) \u22c5 t)\n\nWe need some initial value for the `Leaf` case.  This could be taken as the\ninitial vector for SHA256.  However, I suggest using the hash of an\napplication specific name.\n\n    ApplicationName : BitString\n\nWe further require that the tags dictate the kind of node it is attached\nto.  For example, if a given tag is used for Binary nodes, then it can only\nappear in other Binary nodes.  One way this can be accomplished is by\nrequiring the first two bits of a tag follow a particular scheme (the\nscheme below ensures that one of the first two bits is set, which will be\nuseful later when we define safe tags) such as\n\n- 0b11 when the node is a Leaf node.\n- 0b10 when the node is a Unary node.\n- 0b01 when the node is a Binary node.\n\nThis condition suffices to provide the Merkle--Damg\u00e5rd property:\n\n#### Theorem 2\nSuppose `t_1` and `t_2` are two different `Tree Word256` values such that\nany tag occurring in the two trees only occurs in one kind of node.  If\n`merkleRoot(t_1) = merkleRoot(t_2)` then we can effectively find a\ncollision in the SHA256 compression function.\n\nProof.\nWe proceed by structural induction on `t_1`.  Assume `t_1` and `t_2` are\ntwo different `Tree Word256` values such that `merkleRoot(t_1) =\nmerkleRoot(t_2)`.  Define a `tag` function to extract the tag name from the\nroot of a tree.\n\n    tag : Tree Word256 -> Word256\n    tag (Leaf (t))         := t\n    tag (Unary (t, _))     := t\n    tag (Binary (t, _, _)) := t\n\nCase 1: Suppose `tag(t_1) =/= tag(t_2)`.\nThis means that the inputs to `sha256Compress` that produced\n`merkleRoot(t_1)` and `merkleRoot(t_2)` are different and we have found a\ncollision in the SHA256 compression function.\n\nCase 2: Suppose `tag(t_1) = tag(t_2)`.\nLet `tg` be this tag.  By our requirement on tags, this means that `t_1`\nand `t_2` are the same kind of node.  Suppose `t_1 = Binary (tg, t_(1l),\nt_(1r))` and `t_2 = Binary (tg, t_(2l), t_(2r))`.  Since `t_1` and `t_2`\nare different, then either `t_(1l) =/= t_(2l)` or `t_(1r) =/= t_(2r)`.\nWithout loss of generality, assume `t_(1l) =/= t_(2l)`.\n\nCase 2a: Suppose `merkleRoot(t_(1l)) =/= merkleRoot(t_(2l))`.\nThis means that the inputs to `sha256Compress` that produced\n`merkleRoot(t_1)` and `merkleRoot(t_2)` are different and we have found a\ncollision in the SHA256 compression function.\n\nCase 2b: Suppose `merkleRoot(t_(1l)) = merkleRoot(t_(2l))`.\nThen by induction we can find a collision in the SHA256 compression\nfunction.\n\nThe cases where `t_1` and `t_2` are both `Unary` or `Leaf` nodes are\nhandled in a similar way.  The reader can verify the algorithm implied by\nthe above proof provides an effective method of finding a collision in the\nSHA256 compression function.  QED\n\n#### Remark 3\nWe have filled half of the chunk with `0b0^256` in for the `Unary` and\n`Leaf `cases in the definition of `merkleRoot`.  The proof of Theorem 2\ndoes not depend on this, and if we have extra ancillary data for these\ntypes of nodes it can replace the `0b0^256` in this first half of the\nchunk.  This is particularly useful for the `Leaf `case because `Leaf`\nnodes often hold extra data.  We also remark that if this data is too large\nto be represented by a `Word256`, it can instead be hashed with SHA256 and\nthe hash included instead.\n\nNot all of the inputs to the SHA256 compression function are created\nequal.  Only the second argument, the chunk data, is applied to the SHA256\nexpander.  `merkleRoot` is designed to ensure that the first argument of\nthe SHA256 compression function is only fed some output of the SHA256\ncompression function.  In fact, we can prove that the output of the\n`merkleRoot` function is always the midstate of some SHA256 hash.  To see\nthis, let us explicitly separate the `sha256` function into the padding\nstep, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.\n\n    sha256Pad : BitString -> List Word512\n\n    sha256IV : Word256\n\n    sha256Loop : Word256 \u00d7 List Word512 -> Word256\n    sha256Loop (prev, Nil)                := prev\n    sha256Loop (prev, Cons (chunk, rest)) := sha256Loop(sha256Compress(prev,\nchunk), rest)\n\n    unpaddedSha256 : List Word512 -> Word256\n    unpaddedSha256 (chunks) := sha256Loop(sha256IV, chunks)\n\n    sha256 : BitString -> Word256\n    sha256 (s) := unpaddedSha256(sha256Pad(s))\n\nNow we can state what we mean when we say that the output of the\n`merkleRoot` function is always the midstate of some SHA256 hash.\n\n#### Theorem 4\nFor all `t : Tree Word256` there exists some `l : List Word512` such that\n`merkleRoot(t) = unpaddedSha256(l)`.\n\nProof.\nWe construct a function to transform a tree into the required list of\nchunks.\n\n    merkleChain : Tree Word256 -> List Word512\n    merkleChain (Leaf (t))                := sha256Pad(ApplicationName) +\n[0b0^256 \u22c5 t]\n    merkleChain (Unary (t, child))        := merkleChain(child) + [0b0^256\n\u22c5 t]\n    merkleChain (Binary (t, left, right)) := merkleChain(left) +\n[merkleRoot(right) \u22c5 t]\n\nThe reader can verify by induction that\n\n    forall t : Tree Word256. merkleRoot(t) = unpaddedSha256(merkleChain(t)).\n\nQED\n\n### Large Tag Space\n\nIf one's application cannot directly represent the space of tags with a\n`Word256`, then one can hash the tags and still maintain the\nMerkle--Damg\u00e5rd property given by Theorem 2, as long as we still have the\nproperty that each tag uniquely determines the kind of node it applies to.\n\nWe first note that `Tree` is a functor.\n\n    treeMap : (a -> b) -> Tree a -> Tree b\n    treeMap f (Leaf (t))                := Leaf (f(t))\n    treeMap f (Unary (t, child))        := Unary (f(t), child)\n    treeMap f (Binary (t, left, right)) := Binary (f(t), left, right)\n\nWe can hash the tags of a tree.\n\n    hash256Tags : Tree BitString -> Tree Word256\n    hash256Tags (t) := treeMap sha256 t\n\nNow we can compute the `merkleRoot` of the result of `hash256Tags`.\n\n#### Theorem 5\nSuppose `t_1` and `t_2` are two different `Tree BitString` values such that\nany tag occurring in the two trees only occurs in one kind of node.  If\n`merkleRoot(hash256Tags(t_1)) = merkleRoot(hash256Tags(t_2))`, then we can\neffectively find a collision in the SHA256 compression function.\n\nProof.\nAssume `t_1` and `t_2` are two different `Tree BitString` values such that\n`merkleRoot(hash256Tags(t_1)) = merkleRoot(hash256Tags(t_2))`.\n\nCase 1: Suppose `hash256Tags(t_1) = hash256Tags(t_2)`.\nThis means there must be a collision in the `sha256` function.  By the\nMerkle--Damg\u00e5rd property of SHA256, this means we can effectively find a\ncollision in the SHA256 compression function.\n\nCase 2: Suppose `hash256Tags(t_1) =/= hash256Tags(t_2)`.\nIf the SHA256 hashes of each tag in the two trees uniquely determines the\nkinds of their nodes, then we can apply Theorem 2 to conclude that we can\neffectively find a collision in the SHA256 compression function.  If the\nSHA256 hashes of each tag in the two trees does not uniquely determine the\nkinds of their nodes then there are two different tags among the two trees,\n`tg_1` and `tg_2`, such that `sha256(tg_1) = sha256(tg_2)`.  Hence there is\na collision in the `sha256` function, and therefore we can effectively find\na collision in the SHA256 compression function.  QED\n\n## Avoiding collisions between merkleRoot and sha256\nFor the moment, let us assume there is no effective way to find a collision\nin the SHA256 compression function.  By the Merkle--Damg\u00e5rd property of\nSHA256, we cannot effectively find a collision within the sha256 function.\nWe have shown, by Theorem 2, that merkleRoot has the same Merkle--Damg\u00e5rd\nproperty and hence we cannot effectively find a collision within the\nmerkleRoot function.  However, we may have collisions between the `sha256`\nand the `merkleRoot` functions.  That is, we may be able to effectively\nfind values `s : BitString` and `t : Tree Word256` such that `sha256(s) =\nmerkleRoot(t)`.\n\nWhile this may not be a problem for most applications, it turns out that we\ncan place restrictions on the format of tags to ensure that there are never\ncollisions between `sha256` and `merkleRoot`.  Define a safe tag of type\n`Word256` to be a a value such that one the first 192 bits is set and the\n9th last bit is cleared.\n\n#### Theorem 6\nLet `t : Tree Word256` be a tree in which every tag is a safe tag.  Suppose\nwe have some `s : BitString` such that `sha256(s) = merkleRoot(t)`.  Then\nwe can effectively find a collision in the SHA256 compression function.\n\nProof.\nThe last chunk of `sha256Padding(s)` is a padding chunk as defined by the\nSHA256 standard.  If we look at the second half of this last chunk, then\naccording to the padding rules, it can never be the case that one of the\nfirst 192 bits is set and the 9^th last bit is cleared.  Because `t` only\ncontains safe tags, the inputs to their last compression function in the\ncomputation of `sha256(s)` and `merkleRoot(t)` must be different.\nTherefore if `sha256(s) = merkleRoot(t)` then we must have encountered a\ncollision in the final compression function of the two computations.  QED\n\n#### Remark 7\nIf we use safe tags we can consider a modified `merkleRoot'` function.\n\n    merkleRoot' : Tree Word256 -> Word256\n    merkleRoot' (Leaf (t))                :=\nsha256Compress(sha256(ApplicationName),\nsha256(\"\") \u22c5 t)\n    merkleRoot' (Unary (t, child))        := sha256Compress(merkleRoot'(child),\nsha256(\"\") \u22c5 t)\n    merkleRoot' (Binary (t, left, right)) := sha256Compress(merkleRoot'(left),\nmerkleRoot'(right) \u22c5 t)\n\nIf we use `merkleRoot'` we no longer require that tags uniquely define\ntheir node types in order to ensure the Merkle--Damg\u00e5rd property.  Instead\nwe can rely on the safe tags to ensure that the use of `sha256(s)` will\nnever collide with `merkleRoot'(t)`, and therefore nodes of different types\nwill never collide with each other the `merkleRoot'` computation.  However,\nI don't feel this is a particularly good approach, so I will not elaborate\non it further.\n\nUnfortunately, there is no guarantee that the result of `hash256Tags` will\nconsist of only safe tags, so we cannot use it to avoid collisions between\n`sha256` and `merkleRoot \u22c5 hash256Tags`.  To remedy this we define an\nalternative to `hash256Tags`.\n\n    hash224Tag : BitString -> Word256\n    hash224Tag (s) := 0xFFFF \u22c5 sha224(s) \u22c5 0x0000\n\n    hash224Tags : Tree BitString -> Tree Word256\n    hash224Tags (t) := treeMap hash224Tag t\n\nWe see that by appropriately padding the result of `sha224` we guarantee\nthat `hash224Tag(s)` is a safe tag.\n\n#### Theorem 8\nSuppose `t_1` and `t_2` are two different `Tree BitString` values such that\nany tag occurring in the two trees only occurs in one kind of node.  If\n`merkleRoot(hash224Tags(t_1)) = merkleRoot(hash224Tags(t_2))`, then we can\neffectively find either a collision in the SHA256 compression function, or\na collision in SHA224.\n\n#### Remark 9\nWe can safely replace the `0xFFFF` prefix in `hash224Tag` with one where\nthe first two bits determine the kind of node in accordance with our\npreviously defined scheme.\n\n#### Remark 10\nRather than using SHA224 we could use SHA256 and tweak it afterwards to set\nthe first bit and clear the 9th last bit. This comes at the cost of\neffectively using a non-standard hash function.\n\n#### Remark 11\nMost of this development not depend specifically on SHA256.  It all works\nsimilarly for SHA512 and other hash functions that compress in a similar\nmanner.  SHA256 is used as the primary example because one can find\nhardware support for it on commodity hardware (for example, see the Intel\nSHA extensions).\n\n## Conclusion\nWe have defined a merkleRoot function for computing Merkle roots of trees\nthat include annotations per node.  The resulting function uses one SHA256\ncompression function call per node and supports arbitrary 256-bit\nannotations per node.  Arbitrary annotations can be supported at the cost\nof more hashing.  We have also shown that by using safe tags we can\nadditionally get a property that the `merkleRoot` will not effectively\ncollide with `sha256` function.\n\n## Further Reading\nThe article [Characterizing Padding Rules of MD Hash Functions Preserving\nCollision Security](https://eprint.iacr.org/2009/325.pdf) by Mridul Nandi\nprovides a nice overview of various options for padding rules.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/c8eb4a67/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-22T14:05:48",
                "message_text_only": "On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev wrote:\n>     MerkleRoot := SHA256(SHA256(LeftRoot \u22c5 RightRoot))\n>     sha256Compress : Word256 \u00d7 Word512 -> Word256\n\nTo be clear, what math operations do you mean by \"\u22c5\" and \"\u00d7\"?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/e3d797df/attachment-0001.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-22T22:32:38",
                "message_text_only": "On May 22, 2017 23:05, \"Peter Todd\" <pete at petertodd.org> wrote:\n\nOn Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev\nwrote:\n>     MerkleRoot := SHA256(SHA256(LeftRoot \u22c5 RightRoot))\n>     sha256Compress : Word256 \u00d7 Word512 -> Word256\n\nTo be clear, what math operations do you mean by \"\u22c5\" and \"\u00d7\"?\n\n\nBy \"\u22c5\", I usually mean concatenation (though I also use it for function\ncomposition in one instance).   By \"\u00d7\", I mean the Cartesian product.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/cdef9d9f/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-27T17:41:38",
                "message_text_only": "On Mon, May 22, 2017 at 06:32:38PM -0400, Russell O'Connor wrote:\n> On May 22, 2017 23:05, \"Peter Todd\" <pete at petertodd.org> wrote:\n> \n> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> >     MerkleRoot := SHA256(SHA256(LeftRoot \u22c5 RightRoot))\n> >     sha256Compress : Word256 \u00d7 Word512 -> Word256\n> \n> To be clear, what math operations do you mean by \"\u22c5\" and \"\u00d7\"?\n> \n> \n> By \"\u22c5\", I usually mean concatenation (though I also use it for function\n> composition in one instance).   By \"\u00d7\", I mean the Cartesian product.\n\nCartesian product can mean a lot of things.\n\nWhat specifically do you mean by \"cartesian product\" here?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170527/37b53732/attachment.sig>"
            },
            {
                "author": "Bram Cohen",
                "date": "2017-05-23T06:06:07",
                "message_text_only": "On Mon, May 22, 2017 at 12:05 AM, Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The SHA256 compression function takes two inputs:\n>\n> 1. A 256-bit value for the previous chunk in a chain, or an initial vector\n> in the case of the first chunk.\n> 2. A 512-bit chunk of data.\n>\n>     sha256Compress : Word256 \u00d7 Word512 -> Word256\n>\n> In total, the SHA256 compression function compresses 768-bits into\n> 256-bits.  The Merkle roots of two branches occupy 512 bits, and this\n> leaves another 256-bits of space available for tags.\n>\n\nYa know, when you're building a Merkle Trie that's exactly the primitive\nyou need.\n\nIn my own construction the assumption is that the values are already hashed\ndown to 256 bits when they're passed in, and the tags (which are currently\ndone by sacrificing bits instead of using tags, that needs to be fixed)\ninclude three states for either side: empty, unary, or middle. Three of\nthose possibilities are unreachable (empty/empty, empty/unary, unary/empty)\nso there are 6 possible tags needed. This approach essentially skips doing\nthe unary hashes, a further performance improvement. There doesn't appear\nto be any downside in leveraging this trick as long as tags are cheap.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170522/1445b092/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-28T08:26:24",
                "message_text_only": "On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev wrote:\n> Not all of the inputs to the SHA256 compression function are created\n> equal.  Only the second argument, the chunk data, is applied to the SHA256\n> expander.  `merkleRoot` is designed to ensure that the first argument of\n> the SHA256 compression function is only fed some output of the SHA256\n> compression function.  In fact, we can prove that the output of the\n> `merkleRoot` function is always the midstate of some SHA256 hash.  To see\n> this, let us explicitly separate the `sha256` function into the padding\n> step, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.\n\nThis doesn't hold true in the case of pruned trees, as for the pruning to be\nuseful, you don't know what produced the left merkleRoot, and thus you can't\nguarantee it is in fact a midstate of a genuine SHA256 hash.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/def153ff/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-29T14:55:37",
                "message_text_only": "On Sun, May 28, 2017 at 4:26 AM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> > Not all of the inputs to the SHA256 compression function are created\n> > equal.  Only the second argument, the chunk data, is applied to the\n> SHA256\n> > expander.  `merkleRoot` is designed to ensure that the first argument of\n> > the SHA256 compression function is only fed some output of the SHA256\n> > compression function.  In fact, we can prove that the output of the\n> > `merkleRoot` function is always the midstate of some SHA256 hash.  To see\n> > this, let us explicitly separate the `sha256` function into the padding\n> > step, `sha256Pad`, and the recursive hashing step, `unpaddedSha256`.\n>\n> This doesn't hold true in the case of pruned trees, as for the pruning to\n> be\n> useful, you don't know what produced the left merkleRoot, and thus you\n> can't\n> guarantee it is in fact a midstate of a genuine SHA256 hash.\n>\n\nThanks for the review Peter.  This does seem like a serious issue that I\nhadn't considered yet.  As far as I understand, we have no reason to think\nthat the SHA-256 compression function will be secure with chosen initial\nvalues.\n\nSome of this proposal can be salvaged, I think, by putting the hash of the\ntags into Sha256Compress's first argument:\n\n    merkleRoot : Tree BitString -> Word256\n    merkleRoot (Leaf (t))                := sha256Compress(sha256(t),\n0b0^512)\n    merkleRoot (Unary (t, child))        := sha256Compress(sha256(t),\nmerkleRoot(child) \u22c5 0b0^256)\n    merkleRoot (Binary (t, left, right)) := sha256Compress(sha256(t),\nmerkleRoot(left) \u22c5 merkleRoot(right))\n\nThe Merkle--Damg\u00e5rd property will still hold under the same conditions\nabout tags determining the type of node (Leaf, Unary, or Binary) while\navoiding the need for SHA256's padding.  If you have a small number of\ntags, then you can pre-compute their hashes so that you only end up with\none call to SHA256 compress per node. If you have tags with a large amount\nof data, you were going to be hashing them anyways.\n\nUnfortunately we lose the ability to cleverly avoid collisions between the\nSha256 and MerkleRoot functions by using safe tags.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/8a3b421d/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2017-05-29T16:10:59",
                "message_text_only": "On Mon, May 29, 2017 at 10:55:37AM -0400, Russell O'Connor wrote:\n> > This doesn't hold true in the case of pruned trees, as for the pruning to\n> > be\n> > useful, you don't know what produced the left merkleRoot, and thus you\n> > can't\n> > guarantee it is in fact a midstate of a genuine SHA256 hash.\n> >\n> \n> Thanks for the review Peter.  This does seem like a serious issue that I\n> hadn't considered yet.  As far as I understand, we have no reason to think\n> that the SHA-256 compression function will be secure with chosen initial\n> values.\n\nWell, it's an easy thing to forget, unless like me, you've written a general\npurpose library to work with pruned data. :) (actually, soon to be two of\nthem!)\n\nI also ran into the midstate issue with my OpenTimestamps protocol, as I was\nlooking into whether or not it was safe to have a SHA256 midstate commitment\noperation, and couldn't find clear evidence that it was.\n\n> Some of this proposal can be salvaged, I think, by putting the hash of the\n> tags into Sha256Compress's first argument:\n> \n>     merkleRoot : Tree BitString -> Word256\n>     merkleRoot (Leaf (t))                := sha256Compress(sha256(t),\n> 0b0^512)\n>     merkleRoot (Unary (t, child))        := sha256Compress(sha256(t),\n> merkleRoot(child) \u22c5 0b0^256)\n>     merkleRoot (Binary (t, left, right)) := sha256Compress(sha256(t),\n> merkleRoot(left) \u22c5 merkleRoot(right))\n> \n> The Merkle--Damg\u00e5rd property will still hold under the same conditions\n> about tags determining the type of node (Leaf, Unary, or Binary) while\n> avoiding the need for SHA256's padding.  If you have a small number of\n> tags, then you can pre-compute their hashes so that you only end up with\n> one call to SHA256 compress per node. If you have tags with a large amount\n> of data, you were going to be hashing them anyways.\n\nNotice how what you're proposing here is almost the same thing as using SHA256\ndirectly, modulo the fact that you skip the final block containing the message\nlength.\n\nSimilarly, you don't need to compute sha256(t) - you can just as easily compute\nthe midstate sha256Compress(IV, t), and cache that midstate if you can reuse\ntags. Again, the only difference is the last block.\n\n> Unfortunately we lose the ability to cleverly avoid collisions between the\n> Sha256 and MerkleRoot functions by using safe tags.\n\nI think a better question to ask is why you want that property in the first\nplace?\n\nMy earlier python-proofmarshal(1) library had a scheme of per-use-case tags,\nbut I eventually realised that depending on tags being unique is a footgun. For\nexample, it's easy to see how two different systems could end up using the same\ntag due to designers forgetting to create new tags while copying and pasting\nold code. Similarly, if two such systems have to be integrated, you'll end up\nwith tags getting reused for two different purposes.\n\nNow, if you design a system where that doesn't matter, then by extension it'll\nalso be true that collisions between the sha256 and merkleroot functions don't\nmatter either. And that system will be more robust to design mistakes, as tags\nonly need to be unique \"locally\" to distinguish between different sub-types in\na sum type (enum).\n\n\nFWIW what I've done with my newer (and as yet unpublished) rust-proofmarshal\nwork is commitments are only valid for a specific type. Secondly, I use\nblake2b, whose compression function processes up to 128 bytes of message on\neach invocation.  That's large enough for four 32 byte hashes, which is by\nitself more than sufficient for a summed merkle tree with three 32 byte hashes\n(left right and sum) and a per-node-type tag.\n\nBlake2b's documentations don't make it clear if it's resistant to collision if\nthe adversary can control the salt or personalization strings, so I don't\nbother using them - the large block size by itself is enough to fit almost any\nuse-case into a single block, and it hashes blocks significantly faster than\nSHA256. This also has the advantage that the actual primitive I'm using is 100%\nstandard blake2b, an aid to debugging and development.\n\n1) https://github.com/proofchains/python-proofmarshal\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/22b1b0f7/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2017-05-27T22:07:07",
                "message_text_only": "On May 28, 2017 06:09, \"Russell O'Connor\" <roconnor at blockstream.io> wrote:\n\n\n\nOn May 28, 2017 03:16, \"Peter Todd\" <pete at petertodd.org> wrote:\n\nOn Mon, May 22, 2017 at 06:32:38PM -0400, Russell O'Connor wrote:\n> On May 22, 2017 23:05, \"Peter Todd\" <pete at petertodd.org> wrote:\n>\n> On Mon, May 22, 2017 at 03:05:49AM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> >     MerkleRoot := SHA256(SHA256(LeftRoot \u22c5 RightRoot))\n> >     sha256Compress : Word256 \u00d7 Word512 -> Word256\n>\n> To be clear, what math operations do you mean by \"\u22c5\" and \"\u00d7\"?\n>\n>\n> By \"\u22c5\", I usually mean concatenation (though I also use it for function\n> composition in one instance).   By \"\u00d7\", I mean the Cartesian product.\n\nCartesian product can mean a lot of things.\n\nWhat specifically do you mean by \"cartesian product\" here?\n\n\nOops, I forgot to reply all.  Below is my reply.\n\nGiven two types A and B, then A \u00d7 B is the type of pairs of A and B in the\nsense of type theory as used in Standard ML or Haskell or other typed\nlanguages.\n\n\nTo follow up, by \"sha256Compress : Word256 \u00d7 Word512 -> Word256\" I mean\nthat sha256Compress is a function that takes two arguments, the first being\na 256 bit word and the second being a 512 bit word, and returns a 256 bit\nword (or equivalently sha256Compress is a function that takes a pair as\ninput, the first component being a 256 bit word and the second component\nbeing a 512 bit word, and returns a 256 bit word).\n\nsha256Compress is meant to be the compression function defined by the\nSHA256 standard, though nothing here depends on anything more that its type\nsignature.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170527/95aace99/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "A Method for Computing Merkle Roots of Annotated Binary Trees",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "Bram Cohen",
                "Peter Todd"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 30540
        }
    },
    {
        "title": "[bitcoin-dev] Reduced signalling threshold activation of existing segwit deployment",
        "thread_messages": [
            {
                "author": "James Hilliard",
                "date": "2017-05-22T22:40:13",
                "message_text_only": "I would like to propose an implementation that accomplishes the first\npart of the Barry Silbert proposal independently from the second:\n\n\"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\nin a way that\n\nThe goal here is to minimize chain split risk and network disruption\nwhile maximizing backwards compatibility and still providing for rapid\nactivation of segwit at the 80% threshold using bit 4.\n\nBy activating segwit immediately and separately from any HF we can\nscale quickly without risking a rushed combined segwit+HF that would\nalmost certainly cause widespread issues.\n\nDraft proposal:\nhttps://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n\nProposal text:\n<pre>\n  BIP: segsignal\n  Layer: Consensus (soft fork)\n  Title: Reduced signalling threshold activation of existing segwit deployment\n  Author: James Hilliard <james.hilliard1 at gmail.com>\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-05-22\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a method to activate the existing BIP9 segwit\ndeployment with a majority hashpower less than 95%.\n\n==Definitions==\n\n\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\nusing bit 1, between November 15th 2016 and November 15th 2017 to\nactivate BIP141, BIP143 and BIP147.\n\n==Motivation==\n\nSegwit increases the blocksize, fixes transaction malleability, and\nmakes scripting easier to upgrade as well as bringing many other\n[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n\nThis BIP provides a way for a simple majority of miners to coordinate\nactivation of the existing segwit deployment with less than 95%\nhashpower. For a number of reasons a complete redeployment of segwit\nis difficulty to do until the existing deployment expires. This is due\nto 0.13.1+ having many segwit related features active already,\nincluding all the P2P components, the new network service flag, the\nwitness-tx and block messages, compact blocks v2 and preferential\npeering. A redeployment of segwit will need to redefine all these\nthings and doing so before expiry would greatly complicate testing.\n\n==Specification==\n\nWhile this BIP is active, all blocks must set the nVersion header top\n3 bits to 001 together with bit field (1<<1) (according to the\nexisting segwit deployment). Blocks that do not signal as required\nwill be rejected.\n\n==Deployment==\n\nThis BIP will be deployed by a \"version bits\" with an 80%(this can be\nadjusted if desired) activation threshold BIP9 with the name\n\"segsignal\" and using bit 4.\n\nThis BIP will have a start time of midnight June 1st, 2017 (epoch time\n1496275200) and timeout on midnight November 15th 2017 (epoch time\n1510704000). This BIP will cease to be active when segwit is\nlocked-in.\n\n=== Reference implementation ===\n\n<pre>\n// Check if Segregated Witness is Locked In\nbool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\nConsensus::Params& params)\n{\n    LOCK(cs_main);\n    return (VersionBitsState(pindexPrev, params,\nConsensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\nTHRESHOLD_LOCKED_IN);\n}\n\n// SEGSIGNAL mandatory segwit signalling.\nif ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\nConsensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n&&\n     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n// Segwit is not locked in\n     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\nand is not active.\n{\n    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\nVERSIONBITS_TOP_BITS;\n    bool fSegbit = (pindex->nVersion &\nVersionBitsMask(chainparams.GetConsensus(),\nConsensus::DEPLOYMENT_SEGWIT)) != 0;\n    if (!(fVersionBits && fSegbit)) {\n        return state.DoS(0, error(\"ConnectBlock(): relayed block must\nsignal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n    }\n}\n</pre>\n\nhttps://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n\n==Backwards Compatibility==\n\nThis deployment is compatible with the existing \"segwit\" bit 1\ndeployment scheduled between midnight November 15th, 2016 and midnight\nNovember 15th, 2017. Miners will need to upgrade their nodes to\nsupport segsignal otherwise they may build on top of an invalid block.\nWhile this bip is active users should either upgrade to segsignal or\nwait for additional confirmations when accepting payments.\n\n==Rationale==\n\nHistorically we have used IsSuperMajority() to activate soft forks\nsuch as BIP66 which has a mandatory signalling requirement for miners\nonce activated, this ensures that miners are aware of new rules being\nenforced. This technique can be leveraged to lower the signalling\nthreshold of a soft fork while it is in the process of being deployed\nin a backwards compatible way.\n\nBy orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\ndeployment, this BIP can cause the existing \"segwit\" deployment to\nactivate without needing to release a new deployment.\n\n==References==\n\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\nMailing list discussion]\n*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\nP2SH flag day activation]\n*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\nVersion 0 Witness Program]]\n*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons\nCC0 1.0 Universal."
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-22T22:43:00",
                "message_text_only": "Given the overwhelming support for SegWit across the ecosystem of businesses and users, this seems reasonable to me.\n\nOn May 22, 2017 6:40:13 PM EDT, James Hilliard via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>I would like to propose an implementation that accomplishes the first\n>part of the Barry Silbert proposal independently from the second:\n>\n>\"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>in a way that\n>\n>The goal here is to minimize chain split risk and network disruption\n>while maximizing backwards compatibility and still providing for rapid\n>activation of segwit at the 80% threshold using bit 4.\n>\n>By activating segwit immediately and separately from any HF we can\n>scale quickly without risking a rushed combined segwit+HF that would\n>almost certainly cause widespread issues.\n>\n>Draft proposal:\n>https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>\n>Proposal text:\n><pre>\n>  BIP: segsignal\n>  Layer: Consensus (soft fork)\n>Title: Reduced signalling threshold activation of existing segwit\n>deployment\n>  Author: James Hilliard <james.hilliard1 at gmail.com>\n>  Status: Draft\n>  Type: Standards Track\n>  Created: 2017-05-22\n>  License: BSD-3-Clause\n>           CC0-1.0\n></pre>\n>\n>==Abstract==\n>\n>This document specifies a method to activate the existing BIP9 segwit\n>deployment with a majority hashpower less than 95%.\n>\n>==Definitions==\n>\n>\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>using bit 1, between November 15th 2016 and November 15th 2017 to\n>activate BIP141, BIP143 and BIP147.\n>\n>==Motivation==\n>\n>Segwit increases the blocksize, fixes transaction malleability, and\n>makes scripting easier to upgrade as well as bringing many other\n>[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>\n>This BIP provides a way for a simple majority of miners to coordinate\n>activation of the existing segwit deployment with less than 95%\n>hashpower. For a number of reasons a complete redeployment of segwit\n>is difficulty to do until the existing deployment expires. This is due\n>to 0.13.1+ having many segwit related features active already,\n>including all the P2P components, the new network service flag, the\n>witness-tx and block messages, compact blocks v2 and preferential\n>peering. A redeployment of segwit will need to redefine all these\n>things and doing so before expiry would greatly complicate testing.\n>\n>==Specification==\n>\n>While this BIP is active, all blocks must set the nVersion header top\n>3 bits to 001 together with bit field (1<<1) (according to the\n>existing segwit deployment). Blocks that do not signal as required\n>will be rejected.\n>\n>==Deployment==\n>\n>This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>adjusted if desired) activation threshold BIP9 with the name\n>\"segsignal\" and using bit 4.\n>\n>This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>1496275200) and timeout on midnight November 15th 2017 (epoch time\n>1510704000). This BIP will cease to be active when segwit is\n>locked-in.\n>\n>=== Reference implementation ===\n>\n><pre>\n>// Check if Segregated Witness is Locked In\n>bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>Consensus::Params& params)\n>{\n>    LOCK(cs_main);\n>    return (VersionBitsState(pindexPrev, params,\n>Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>THRESHOLD_LOCKED_IN);\n>}\n>\n>// SEGSIGNAL mandatory segwit signalling.\n>if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>&&\n>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>// Segwit is not locked in\n>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>and is not active.\n>{\n>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>VERSIONBITS_TOP_BITS;\n>    bool fSegbit = (pindex->nVersion &\n>VersionBitsMask(chainparams.GetConsensus(),\n>Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>    if (!(fVersionBits && fSegbit)) {\n>        return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>    }\n>}\n></pre>\n>\n>https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>\n>==Backwards Compatibility==\n>\n>This deployment is compatible with the existing \"segwit\" bit 1\n>deployment scheduled between midnight November 15th, 2016 and midnight\n>November 15th, 2017. Miners will need to upgrade their nodes to\n>support segsignal otherwise they may build on top of an invalid block.\n>While this bip is active users should either upgrade to segsignal or\n>wait for additional confirmations when accepting payments.\n>\n>==Rationale==\n>\n>Historically we have used IsSuperMajority() to activate soft forks\n>such as BIP66 which has a mandatory signalling requirement for miners\n>once activated, this ensures that miners are aware of new rules being\n>enforced. This technique can be leveraged to lower the signalling\n>threshold of a soft fork while it is in the process of being deployed\n>in a backwards compatible way.\n>\n>By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>deployment, this BIP can cause the existing \"segwit\" deployment to\n>activate without needing to release a new deployment.\n>\n>==References==\n>\n>*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n>Mailing list discussion]\n>*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>P2SH flag day activation]\n>*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>Version 0 Witness Program]]\n>*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element\n>malleability]]\n>*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit\n>deployment]]\n>*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit\n>benefits]\n>\n>==Copyright==\n>\n>This document is dual licensed as BSD 3-clause, and Creative Commons\n>CC0 1.0 Universal.\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Kekcoin",
                "date": "2017-05-23T09:51:19",
                "message_text_only": "I think there may be merit to this idea, allowing for political compromise without sacrificing the technological integrity of Bitcoin. There are a few mechanical problems I see with it, though.\n\n1. It should change its activation logic from BIP9-style to BIP8-style with a flagday of August 1. This to maintain backwards compatibility with the current deployment of BIP148 nodes. This proposal seems to be a measure to prevent a chainsplit, so it must make sure to avoid triggering one.\n\n2. This should be for miners only; non-miners should not enforce this. It severely weakens the block-signalling activation mechanism in several ways (lowered threshold, short deployment timeframe, no \"locked in\" delay before activation) and by doing so opens up attack vectors for consensus-partitioning attacks using malicious false signalling. For non-miners that seek to take their fate into their own hands, enforcing BIP148 is enough.\n\n3. Even for miners this is more risky than usual; only 31% of hashrate is required to false-signal the activation to fork-off honest miners. This attack vector is magnified by the lack of \"locked in\" delay that would allow laggards to upgrade before activation. I suggest adding in at least a 1-week lock-in period (given the shorter timeframes 2 weeks may eat up too much of the available voting time before the brick wall of BIP148 activation on August 1).\n\nUnder the assumption that this is indeed compatible with the terms of the Silbert agreement, we can presume the involved miners are willing to trust eachother more than usual so such a short lock-in period should be acceptable.\n\n-------- Original Message --------\nSubject: [bitcoin-dev] Reduced signalling threshold activation of existing segwit deployment\nLocal Time: May 23, 2017 1:40 AM\nUTC Time: May 22, 2017 10:40 PM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n\nI would like to propose an implementation that accomplishes the first\npart of the Barry Silbert proposal independently from the second:\n\n\"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\nin a way that\n\nThe goal here is to minimize chain split risk and network disruption\nwhile maximizing backwards compatibility and still providing for rapid\nactivation of segwit at the 80% threshold using bit 4.\n\nBy activating segwit immediately and separately from any HF we can\nscale quickly without risking a rushed combined segwit+HF that would\nalmost certainly cause widespread issues.\n\nDraft proposal:\nhttps://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n\nProposal text:\n<pre>\nBIP: segsignal\nLayer: Consensus (soft fork)\nTitle: Reduced signalling threshold activation of existing segwit deployment\nAuthor: James Hilliard <james.hilliard1 at gmail.com>\nStatus: Draft\nType: Standards Track\nCreated: 2017-05-22\nLicense: BSD-3-Clause\nCC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a method to activate the existing BIP9 segwit\ndeployment with a majority hashpower less than 95%.\n\n==Definitions==\n\n\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\nusing bit 1, between November 15th 2016 and November 15th 2017 to\nactivate BIP141, BIP143 and BIP147.\n\n==Motivation==\n\nSegwit increases the blocksize, fixes transaction malleability, and\nmakes scripting easier to upgrade as well as bringing many other\n[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n\nThis BIP provides a way for a simple majority of miners to coordinate\nactivation of the existing segwit deployment with less than 95%\nhashpower. For a number of reasons a complete redeployment of segwit\nis difficulty to do until the existing deployment expires. This is due\nto 0.13.1+ having many segwit related features active already,\nincluding all the P2P components, the new network service flag, the\nwitness-tx and block messages, compact blocks v2 and preferential\npeering. A redeployment of segwit will need to redefine all these\nthings and doing so before expiry would greatly complicate testing.\n\n==Specification==\n\nWhile this BIP is active, all blocks must set the nVersion header top\n3 bits to 001 together with bit field (1<<1) (according to the\nexisting segwit deployment). Blocks that do not signal as required\nwill be rejected.\n\n==Deployment==\n\nThis BIP will be deployed by a \"version bits\" with an 80%(this can be\nadjusted if desired) activation threshold BIP9 with the name\n\"segsignal\" and using bit 4.\n\nThis BIP will have a start time of midnight June 1st, 2017 (epoch time\n1496275200) and timeout on midnight November 15th 2017 (epoch time\n1510704000). This BIP will cease to be active when segwit is\nlocked-in.\n\n=== Reference implementation ===\n\n<pre>\n// Check if Segregated Witness is Locked In\nbool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\nConsensus::Params& params)\n{\nLOCK(cs_main);\nreturn (VersionBitsState(pindexPrev, params,\nConsensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\nTHRESHOLD_LOCKED_IN);\n}\n\n// SEGSIGNAL mandatory segwit signalling.\nif ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\nConsensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n&&\n!IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n// Segwit is not locked in\n!IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\nand is not active.\n{\nbool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\nVERSIONBITS_TOP_BITS;\nbool fSegbit = (pindex->nVersion &\nVersionBitsMask(chainparams.GetConsensus(),\nConsensus::DEPLOYMENT_SEGWIT)) != 0;\nif (!(fVersionBits && fSegbit)) {\nreturn state.DoS(0, error(\"ConnectBlock(): relayed block must\nsignal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n}\n}\n</pre>\n\nhttps://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n\n==Backwards Compatibility==\n\nThis deployment is compatible with the existing \"segwit\" bit 1\ndeployment scheduled between midnight November 15th, 2016 and midnight\nNovember 15th, 2017. Miners will need to upgrade their nodes to\nsupport segsignal otherwise they may build on top of an invalid block.\nWhile this bip is active users should either upgrade to segsignal or\nwait for additional confirmations when accepting payments.\n\n==Rationale==\n\nHistorically we have used IsSuperMajority() to activate soft forks\nsuch as BIP66 which has a mandatory signalling requirement for miners\nonce activated, this ensures that miners are aware of new rules being\nenforced. This technique can be leveraged to lower the signalling\nthreshold of a soft fork while it is in the process of being deployed\nin a backwards compatible way.\n\nBy orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\ndeployment, this BIP can cause the existing \"segwit\" deployment to\nactivate without needing to release a new deployment.\n\n==References==\n\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\nMailing list discussion]\n*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\nP2SH flag day activation]\n*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\nVersion 0 Witness Program]]\n*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons\nCC0 1.0 Universal.\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/803c74dc/attachment-0001.html>"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-23T16:56:51",
                "message_text_only": "On Tue, May 23, 2017 at 5:51 AM, Kekcoin <kekcoin at protonmail.com> wrote:\n> I think there may be merit to this idea, allowing for political compromise\n> without sacrificing the technological integrity of Bitcoin. There are a few\n> mechanical problems I see with it, though.\n>\n> 1. It should change its activation logic from BIP9-style to BIP8-style with\n> a flagday of August 1. This to maintain backwards compatibility with the\n> current deployment of BIP148 nodes. This proposal seems to be a measure to\n> prevent a chainsplit, so it must make sure to avoid triggering one.\nThat can be done as a separate proposal, it's not mutually exclusive\nto this one for those who intend to run BIP148.\n>\n> 2. This should be for miners only; non-miners should not enforce this. It\n> severely weakens the block-signalling activation mechanism in several ways\n> (lowered threshold, short deployment timeframe, no \"locked in\" delay before\n> activation) and by doing so opens up attack vectors for\n> consensus-partitioning attacks using malicious false signalling. For\n> non-miners that seek to take their fate into their own hands, enforcing\n> BIP148 is enough.\nI disagree that it should be only run by miners, enforcement of\nsegsignal mandatory signalling by economic nodes strongly discourages\nany false signaling.\n>\n> 3. Even for miners this is more risky than usual; only 31% of hashrate is\n> required to false-signal the activation to fork-off honest miners. This\n> attack vector is magnified by the lack of \"locked in\" delay that would allow\n> laggards to upgrade before activation. I suggest adding in at least a 1-week\n> lock-in period (given the shorter timeframes 2 weeks may eat up too much of\n> the available voting time before the brick wall of BIP148 activation on\n> August 1).\nThose who can should still upgrade for segsignal, the more that\nupgrade ahead of activation the more secure it is. Those who don't\nupgrade would want to wait for more confirmations anyways. I didn't\nthink a lock in period was all that good an idea here due to the\nfairly short deployment timeline.\n>\n> Under the assumption that this is indeed compatible with the terms of the\n> Silbert agreement, we can presume the involved miners are willing to trust\n> eachother more than usual so such a short lock-in period should be\n> acceptable.\n>\n> -------- Original Message --------\n> Subject: [bitcoin-dev] Reduced signalling threshold activation of existing\n> segwit deployment\n> Local Time: May 23, 2017 1:40 AM\n> UTC Time: May 22, 2017 10:40 PM\n> From: bitcoin-dev at lists.linuxfoundation.org\n> To: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n>\n> I would like to propose an implementation that accomplishes the first\n> part of the Barry Silbert proposal independently from the second:\n>\n> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n> in a way that\n>\n> The goal here is to minimize chain split risk and network disruption\n> while maximizing backwards compatibility and still providing for rapid\n> activation of segwit at the 80% threshold using bit 4.\n>\n> By activating segwit immediately and separately from any HF we can\n> scale quickly without risking a rushed combined segwit+HF that would\n> almost certainly cause widespread issues.\n>\n> Draft proposal:\n> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>\n> Proposal text:\n> <pre>\n> BIP: segsignal\n> Layer: Consensus (soft fork)\n> Title: Reduced signalling threshold activation of existing segwit deployment\n> Author: James Hilliard <james.hilliard1 at gmail.com>\n> Status: Draft\n> Type: Standards Track\n> Created: 2017-05-22\n> License: BSD-3-Clause\n> CC0-1.0\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a method to activate the existing BIP9 segwit\n> deployment with a majority hashpower less than 95%.\n>\n> ==Definitions==\n>\n> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n> using bit 1, between November 15th 2016 and November 15th 2017 to\n> activate BIP141, BIP143 and BIP147.\n>\n> ==Motivation==\n>\n> Segwit increases the blocksize, fixes transaction malleability, and\n> makes scripting easier to upgrade as well as bringing many other\n> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>\n> This BIP provides a way for a simple majority of miners to coordinate\n> activation of the existing segwit deployment with less than 95%\n> hashpower. For a number of reasons a complete redeployment of segwit\n> is difficulty to do until the existing deployment expires. This is due\n> to 0.13.1+ having many segwit related features active already,\n> including all the P2P components, the new network service flag, the\n> witness-tx and block messages, compact blocks v2 and preferential\n> peering. A redeployment of segwit will need to redefine all these\n> things and doing so before expiry would greatly complicate testing.\n>\n> ==Specification==\n>\n> While this BIP is active, all blocks must set the nVersion header top\n> 3 bits to 001 together with bit field (1<<1) (according to the\n> existing segwit deployment). Blocks that do not signal as required\n> will be rejected.\n>\n> ==Deployment==\n>\n> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n> adjusted if desired) activation threshold BIP9 with the name\n> \"segsignal\" and using bit 4.\n>\n> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n> 1510704000). This BIP will cease to be active when segwit is\n> locked-in.\n>\n> === Reference implementation ===\n>\n> <pre>\n> // Check if Segregated Witness is Locked In\n> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n> Consensus::Params& params)\n> {\n> LOCK(cs_main);\n> return (VersionBitsState(pindexPrev, params,\n> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n> THRESHOLD_LOCKED_IN);\n> }\n>\n> // SEGSIGNAL mandatory segwit signalling.\n> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n> &&\n> !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n> // Segwit is not locked in\n> !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n> and is not active.\n> {\n> bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n> VERSIONBITS_TOP_BITS;\n> bool fSegbit = (pindex->nVersion &\n> VersionBitsMask(chainparams.GetConsensus(),\n> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n> if (!(fVersionBits && fSegbit)) {\n> return state.DoS(0, error(\"ConnectBlock(): relayed block must\n> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n> }\n> }\n> </pre>\n>\n> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>\n> ==Backwards Compatibility==\n>\n> This deployment is compatible with the existing \"segwit\" bit 1\n> deployment scheduled between midnight November 15th, 2016 and midnight\n> November 15th, 2017. Miners will need to upgrade their nodes to\n> support segsignal otherwise they may build on top of an invalid block.\n> While this bip is active users should either upgrade to segsignal or\n> wait for additional confirmations when accepting payments.\n>\n> ==Rationale==\n>\n> Historically we have used IsSuperMajority() to activate soft forks\n> such as BIP66 which has a mandatory signalling requirement for miners\n> once activated, this ensures that miners are aware of new rules being\n> enforced. This technique can be leveraged to lower the signalling\n> threshold of a soft fork while it is in the process of being deployed\n> in a backwards compatible way.\n>\n> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n> deployment, this BIP can cause the existing \"segwit\" deployment to\n> activate without needing to release a new deployment.\n>\n> ==References==\n>\n> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n> Mailing list discussion]\n> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n> P2SH flag day activation]\n> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n> Version 0 Witness Program]]\n> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>\n> ==Copyright==\n>\n> This document is dual licensed as BSD 3-clause, and Creative Commons\n> CC0 1.0 Universal.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>"
            },
            {
                "author": "Andrew Chow",
                "date": "2017-05-23T20:39:19",
                "message_text_only": "Hi James,\n\n>From what I understand, this proposal is incompatible with the current\nsegwit implementation with regards to the NODE_WITNESS service bit. I\nbelieve it could cause network partitioning if the service bit is not\nchanged.\n\nAndrew\n\n\nOn 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n> I would like to propose an implementation that accomplishes the first\n> part of the Barry Silbert proposal independently from the second:\n>\n> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n> in a way that\n>\n> The goal here is to minimize chain split risk and network disruption\n> while maximizing backwards compatibility and still providing for rapid\n> activation of segwit at the 80% threshold using bit 4.\n>\n> By activating segwit immediately and separately from any HF we can\n> scale quickly without risking a rushed combined segwit+HF that would\n> almost certainly cause widespread issues.\n>\n> Draft proposal:\n> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>\n> Proposal text:\n> <pre>\n>   BIP: segsignal\n>   Layer: Consensus (soft fork)\n>   Title: Reduced signalling threshold activation of existing segwit deployment\n>   Author: James Hilliard <james.hilliard1 at gmail.com>\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2017-05-22\n>   License: BSD-3-Clause\n>            CC0-1.0\n> </pre>\n>\n> ==Abstract==\n>\n> This document specifies a method to activate the existing BIP9 segwit\n> deployment with a majority hashpower less than 95%.\n>\n> ==Definitions==\n>\n> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n> using bit 1, between November 15th 2016 and November 15th 2017 to\n> activate BIP141, BIP143 and BIP147.\n>\n> ==Motivation==\n>\n> Segwit increases the blocksize, fixes transaction malleability, and\n> makes scripting easier to upgrade as well as bringing many other\n> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>\n> This BIP provides a way for a simple majority of miners to coordinate\n> activation of the existing segwit deployment with less than 95%\n> hashpower. For a number of reasons a complete redeployment of segwit\n> is difficulty to do until the existing deployment expires. This is due\n> to 0.13.1+ having many segwit related features active already,\n> including all the P2P components, the new network service flag, the\n> witness-tx and block messages, compact blocks v2 and preferential\n> peering. A redeployment of segwit will need to redefine all these\n> things and doing so before expiry would greatly complicate testing.\n>\n> ==Specification==\n>\n> While this BIP is active, all blocks must set the nVersion header top\n> 3 bits to 001 together with bit field (1<<1) (according to the\n> existing segwit deployment). Blocks that do not signal as required\n> will be rejected.\n>\n> ==Deployment==\n>\n> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n> adjusted if desired) activation threshold BIP9 with the name\n> \"segsignal\" and using bit 4.\n>\n> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n> 1510704000). This BIP will cease to be active when segwit is\n> locked-in.\n>\n> === Reference implementation ===\n>\n> <pre>\n> // Check if Segregated Witness is Locked In\n> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n> Consensus::Params& params)\n> {\n>     LOCK(cs_main);\n>     return (VersionBitsState(pindexPrev, params,\n> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n> THRESHOLD_LOCKED_IN);\n> }\n>\n> // SEGSIGNAL mandatory segwit signalling.\n> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n> &&\n>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n> // Segwit is not locked in\n>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n> and is not active.\n> {\n>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n> VERSIONBITS_TOP_BITS;\n>     bool fSegbit = (pindex->nVersion &\n> VersionBitsMask(chainparams.GetConsensus(),\n> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>     if (!(fVersionBits && fSegbit)) {\n>         return state.DoS(0, error(\"ConnectBlock(): relayed block must\n> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>     }\n> }\n> </pre>\n>\n> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>\n> ==Backwards Compatibility==\n>\n> This deployment is compatible with the existing \"segwit\" bit 1\n> deployment scheduled between midnight November 15th, 2016 and midnight\n> November 15th, 2017. Miners will need to upgrade their nodes to\n> support segsignal otherwise they may build on top of an invalid block.\n> While this bip is active users should either upgrade to segsignal or\n> wait for additional confirmations when accepting payments.\n>\n> ==Rationale==\n>\n> Historically we have used IsSuperMajority() to activate soft forks\n> such as BIP66 which has a mandatory signalling requirement for miners\n> once activated, this ensures that miners are aware of new rules being\n> enforced. This technique can be leveraged to lower the signalling\n> threshold of a soft fork while it is in the process of being deployed\n> in a backwards compatible way.\n>\n> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n> deployment, this BIP can cause the existing \"segwit\" deployment to\n> activate without needing to release a new deployment.\n>\n> ==References==\n>\n> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n> Mailing list discussion]\n> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n> P2SH flag day activation]\n> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n> Version 0 Witness Program]]\n> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>\n> ==Copyright==\n>\n> This document is dual licensed as BSD 3-clause, and Creative Commons\n> CC0 1.0 Universal.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-23T20:42:46",
                "message_text_only": "That is incorrect, it is compatible with the current segwit\nimplementation because it triggers a mandatory signalling period that\nwill activate segwit on existing nodes.\n\nOn Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi James,\n>\n> From what I understand, this proposal is incompatible with the current\n> segwit implementation with regards to the NODE_WITNESS service bit. I\n> believe it could cause network partitioning if the service bit is not\n> changed.\n>\n> Andrew\n>\n>\n> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n>> I would like to propose an implementation that accomplishes the first\n>> part of the Barry Silbert proposal independently from the second:\n>>\n>> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>> in a way that\n>>\n>> The goal here is to minimize chain split risk and network disruption\n>> while maximizing backwards compatibility and still providing for rapid\n>> activation of segwit at the 80% threshold using bit 4.\n>>\n>> By activating segwit immediately and separately from any HF we can\n>> scale quickly without risking a rushed combined segwit+HF that would\n>> almost certainly cause widespread issues.\n>>\n>> Draft proposal:\n>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>>\n>> Proposal text:\n>> <pre>\n>>   BIP: segsignal\n>>   Layer: Consensus (soft fork)\n>>   Title: Reduced signalling threshold activation of existing segwit deployment\n>>   Author: James Hilliard <james.hilliard1 at gmail.com>\n>>   Status: Draft\n>>   Type: Standards Track\n>>   Created: 2017-05-22\n>>   License: BSD-3-Clause\n>>            CC0-1.0\n>> </pre>\n>>\n>> ==Abstract==\n>>\n>> This document specifies a method to activate the existing BIP9 segwit\n>> deployment with a majority hashpower less than 95%.\n>>\n>> ==Definitions==\n>>\n>> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>> using bit 1, between November 15th 2016 and November 15th 2017 to\n>> activate BIP141, BIP143 and BIP147.\n>>\n>> ==Motivation==\n>>\n>> Segwit increases the blocksize, fixes transaction malleability, and\n>> makes scripting easier to upgrade as well as bringing many other\n>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>>\n>> This BIP provides a way for a simple majority of miners to coordinate\n>> activation of the existing segwit deployment with less than 95%\n>> hashpower. For a number of reasons a complete redeployment of segwit\n>> is difficulty to do until the existing deployment expires. This is due\n>> to 0.13.1+ having many segwit related features active already,\n>> including all the P2P components, the new network service flag, the\n>> witness-tx and block messages, compact blocks v2 and preferential\n>> peering. A redeployment of segwit will need to redefine all these\n>> things and doing so before expiry would greatly complicate testing.\n>>\n>> ==Specification==\n>>\n>> While this BIP is active, all blocks must set the nVersion header top\n>> 3 bits to 001 together with bit field (1<<1) (according to the\n>> existing segwit deployment). Blocks that do not signal as required\n>> will be rejected.\n>>\n>> ==Deployment==\n>>\n>> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>> adjusted if desired) activation threshold BIP9 with the name\n>> \"segsignal\" and using bit 4.\n>>\n>> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n>> 1510704000). This BIP will cease to be active when segwit is\n>> locked-in.\n>>\n>> === Reference implementation ===\n>>\n>> <pre>\n>> // Check if Segregated Witness is Locked In\n>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>> Consensus::Params& params)\n>> {\n>>     LOCK(cs_main);\n>>     return (VersionBitsState(pindexPrev, params,\n>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>> THRESHOLD_LOCKED_IN);\n>> }\n>>\n>> // SEGSIGNAL mandatory segwit signalling.\n>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>> &&\n>>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>> // Segwit is not locked in\n>>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>> and is not active.\n>> {\n>>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>> VERSIONBITS_TOP_BITS;\n>>     bool fSegbit = (pindex->nVersion &\n>> VersionBitsMask(chainparams.GetConsensus(),\n>> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>>     if (!(fVersionBits && fSegbit)) {\n>>         return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>>     }\n>> }\n>> </pre>\n>>\n>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>>\n>> ==Backwards Compatibility==\n>>\n>> This deployment is compatible with the existing \"segwit\" bit 1\n>> deployment scheduled between midnight November 15th, 2016 and midnight\n>> November 15th, 2017. Miners will need to upgrade their nodes to\n>> support segsignal otherwise they may build on top of an invalid block.\n>> While this bip is active users should either upgrade to segsignal or\n>> wait for additional confirmations when accepting payments.\n>>\n>> ==Rationale==\n>>\n>> Historically we have used IsSuperMajority() to activate soft forks\n>> such as BIP66 which has a mandatory signalling requirement for miners\n>> once activated, this ensures that miners are aware of new rules being\n>> enforced. This technique can be leveraged to lower the signalling\n>> threshold of a soft fork while it is in the process of being deployed\n>> in a backwards compatible way.\n>>\n>> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>> deployment, this BIP can cause the existing \"segwit\" deployment to\n>> activate without needing to release a new deployment.\n>>\n>> ==References==\n>>\n>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n>> Mailing list discussion]\n>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>> P2SH flag day activation]\n>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>> Version 0 Witness Program]]\n>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>>\n>> ==Copyright==\n>>\n>> This document is dual licensed as BSD 3-clause, and Creative Commons\n>> CC0 1.0 Universal.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Andrew Chow",
                "date": "2017-05-23T20:58:14",
                "message_text_only": "Ah. I see now. It wasn't very clear to me that that is what will happen.\n\nAlso, shouldn't the timeout date be set for before the BIP141 timeout?\nOtherwise this could lock in but not have enough time for Segwit to be\nlocked in.\n\n\nOn 5/23/2017 4:42 PM, James Hilliard wrote:\n> That is incorrect, it is compatible with the current segwit\n> implementation because it triggers a mandatory signalling period that\n> will activate segwit on existing nodes.\n>\n> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Hi James,\n>>\n>> From what I understand, this proposal is incompatible with the current\n>> segwit implementation with regards to the NODE_WITNESS service bit. I\n>> believe it could cause network partitioning if the service bit is not\n>> changed.\n>>\n>> Andrew\n>>\n>>\n>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n>>> I would like to propose an implementation that accomplishes the first\n>>> part of the Barry Silbert proposal independently from the second:\n>>>\n>>> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>>> in a way that\n>>>\n>>> The goal here is to minimize chain split risk and network disruption\n>>> while maximizing backwards compatibility and still providing for rapid\n>>> activation of segwit at the 80% threshold using bit 4.\n>>>\n>>> By activating segwit immediately and separately from any HF we can\n>>> scale quickly without risking a rushed combined segwit+HF that would\n>>> almost certainly cause widespread issues.\n>>>\n>>> Draft proposal:\n>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>>>\n>>> Proposal text:\n>>> <pre>\n>>>   BIP: segsignal\n>>>   Layer: Consensus (soft fork)\n>>>   Title: Reduced signalling threshold activation of existing segwit deployment\n>>>   Author: James Hilliard <james.hilliard1 at gmail.com>\n>>>   Status: Draft\n>>>   Type: Standards Track\n>>>   Created: 2017-05-22\n>>>   License: BSD-3-Clause\n>>>            CC0-1.0\n>>> </pre>\n>>>\n>>> ==Abstract==\n>>>\n>>> This document specifies a method to activate the existing BIP9 segwit\n>>> deployment with a majority hashpower less than 95%.\n>>>\n>>> ==Definitions==\n>>>\n>>> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>>> using bit 1, between November 15th 2016 and November 15th 2017 to\n>>> activate BIP141, BIP143 and BIP147.\n>>>\n>>> ==Motivation==\n>>>\n>>> Segwit increases the blocksize, fixes transaction malleability, and\n>>> makes scripting easier to upgrade as well as bringing many other\n>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>>>\n>>> This BIP provides a way for a simple majority of miners to coordinate\n>>> activation of the existing segwit deployment with less than 95%\n>>> hashpower. For a number of reasons a complete redeployment of segwit\n>>> is difficulty to do until the existing deployment expires. This is due\n>>> to 0.13.1+ having many segwit related features active already,\n>>> including all the P2P components, the new network service flag, the\n>>> witness-tx and block messages, compact blocks v2 and preferential\n>>> peering. A redeployment of segwit will need to redefine all these\n>>> things and doing so before expiry would greatly complicate testing.\n>>>\n>>> ==Specification==\n>>>\n>>> While this BIP is active, all blocks must set the nVersion header top\n>>> 3 bits to 001 together with bit field (1<<1) (according to the\n>>> existing segwit deployment). Blocks that do not signal as required\n>>> will be rejected.\n>>>\n>>> ==Deployment==\n>>>\n>>> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>>> adjusted if desired) activation threshold BIP9 with the name\n>>> \"segsignal\" and using bit 4.\n>>>\n>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n>>> 1510704000). This BIP will cease to be active when segwit is\n>>> locked-in.\n>>>\n>>> === Reference implementation ===\n>>>\n>>> <pre>\n>>> // Check if Segregated Witness is Locked In\n>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>>> Consensus::Params& params)\n>>> {\n>>>     LOCK(cs_main);\n>>>     return (VersionBitsState(pindexPrev, params,\n>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>>> THRESHOLD_LOCKED_IN);\n>>> }\n>>>\n>>> // SEGSIGNAL mandatory segwit signalling.\n>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>>> &&\n>>>      !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>>> // Segwit is not locked in\n>>>      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>>> and is not active.\n>>> {\n>>>     bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>>> VERSIONBITS_TOP_BITS;\n>>>     bool fSegbit = (pindex->nVersion &\n>>> VersionBitsMask(chainparams.GetConsensus(),\n>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>>>     if (!(fVersionBits && fSegbit)) {\n>>>         return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>>> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>>>     }\n>>> }\n>>> </pre>\n>>>\n>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>>>\n>>> ==Backwards Compatibility==\n>>>\n>>> This deployment is compatible with the existing \"segwit\" bit 1\n>>> deployment scheduled between midnight November 15th, 2016 and midnight\n>>> November 15th, 2017. Miners will need to upgrade their nodes to\n>>> support segsignal otherwise they may build on top of an invalid block.\n>>> While this bip is active users should either upgrade to segsignal or\n>>> wait for additional confirmations when accepting payments.\n>>>\n>>> ==Rationale==\n>>>\n>>> Historically we have used IsSuperMajority() to activate soft forks\n>>> such as BIP66 which has a mandatory signalling requirement for miners\n>>> once activated, this ensures that miners are aware of new rules being\n>>> enforced. This technique can be leveraged to lower the signalling\n>>> threshold of a soft fork while it is in the process of being deployed\n>>> in a backwards compatible way.\n>>>\n>>> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>>> deployment, this BIP can cause the existing \"segwit\" deployment to\n>>> activate without needing to release a new deployment.\n>>>\n>>> ==References==\n>>>\n>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n>>> Mailing list discussion]\n>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>>> P2SH flag day activation]\n>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>>> Version 0 Witness Program]]\n>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>>>\n>>> ==Copyright==\n>>>\n>>> This document is dual licensed as BSD 3-clause, and Creative Commons\n>>> CC0 1.0 Universal.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Wang Chun",
                "date": "2017-05-24T16:02:09",
                "message_text_only": "I think we should go for 75%, same Litecoin. As I have said before, 95% threshold is too high even for unconventional soft forks.\n\n> \u5728 2017\u5e745\u670824\u65e5\uff0c04:58\uff0cAndrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> \u5199\u9053\uff1a\n> \n> Ah. I see now. It wasn't very clear to me that that is what will happen.\n> \n> Also, shouldn't the timeout date be set for before the BIP141 timeout?\n> Otherwise this could lock in but not have enough time for Segwit to be\n> locked in.\n> \n> \n>> On 5/23/2017 4:42 PM, James Hilliard wrote:\n>> That is incorrect, it is compatible with the current segwit\n>> implementation because it triggers a mandatory signalling period that\n>> will activate segwit on existing nodes.\n>> \n>> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> Hi James,\n>>> \n>>> From what I understand, this proposal is incompatible with the current\n>>> segwit implementation with regards to the NODE_WITNESS service bit. I\n>>> believe it could cause network partitioning if the service bit is not\n>>> changed.\n>>> \n>>> Andrew\n>>> \n>>> \n>>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n>>>> I would like to propose an implementation that accomplishes the first\n>>>> part of the Barry Silbert proposal independently from the second:\n>>>> \n>>>> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>>>> in a way that\n>>>> \n>>>> The goal here is to minimize chain split risk and network disruption\n>>>> while maximizing backwards compatibility and still providing for rapid\n>>>> activation of segwit at the 80% threshold using bit 4.\n>>>> \n>>>> By activating segwit immediately and separately from any HF we can\n>>>> scale quickly without risking a rushed combined segwit+HF that would\n>>>> almost certainly cause widespread issues.\n>>>> \n>>>> Draft proposal:\n>>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>>>> \n>>>> Proposal text:\n>>>> <pre>\n>>>>  BIP: segsignal\n>>>>  Layer: Consensus (soft fork)\n>>>>  Title: Reduced signalling threshold activation of existing segwit deployment\n>>>>  Author: James Hilliard <james.hilliard1 at gmail.com>\n>>>>  Status: Draft\n>>>>  Type: Standards Track\n>>>>  Created: 2017-05-22\n>>>>  License: BSD-3-Clause\n>>>>           CC0-1.0\n>>>> </pre>\n>>>> \n>>>> ==Abstract==\n>>>> \n>>>> This document specifies a method to activate the existing BIP9 segwit\n>>>> deployment with a majority hashpower less than 95%.\n>>>> \n>>>> ==Definitions==\n>>>> \n>>>> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>>>> using bit 1, between November 15th 2016 and November 15th 2017 to\n>>>> activate BIP141, BIP143 and BIP147.\n>>>> \n>>>> ==Motivation==\n>>>> \n>>>> Segwit increases the blocksize, fixes transaction malleability, and\n>>>> makes scripting easier to upgrade as well as bringing many other\n>>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>>>> \n>>>> This BIP provides a way for a simple majority of miners to coordinate\n>>>> activation of the existing segwit deployment with less than 95%\n>>>> hashpower. For a number of reasons a complete redeployment of segwit\n>>>> is difficulty to do until the existing deployment expires. This is due\n>>>> to 0.13.1+ having many segwit related features active already,\n>>>> including all the P2P components, the new network service flag, the\n>>>> witness-tx and block messages, compact blocks v2 and preferential\n>>>> peering. A redeployment of segwit will need to redefine all these\n>>>> things and doing so before expiry would greatly complicate testing.\n>>>> \n>>>> ==Specification==\n>>>> \n>>>> While this BIP is active, all blocks must set the nVersion header top\n>>>> 3 bits to 001 together with bit field (1<<1) (according to the\n>>>> existing segwit deployment). Blocks that do not signal as required\n>>>> will be rejected.\n>>>> \n>>>> ==Deployment==\n>>>> \n>>>> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>>>> adjusted if desired) activation threshold BIP9 with the name\n>>>> \"segsignal\" and using bit 4.\n>>>> \n>>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n>>>> 1510704000). This BIP will cease to be active when segwit is\n>>>> locked-in.\n>>>> \n>>>> === Reference implementation ===\n>>>> \n>>>> <pre>\n>>>> // Check if Segregated Witness is Locked In\n>>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>>>> Consensus::Params& params)\n>>>> {\n>>>>    LOCK(cs_main);\n>>>>    return (VersionBitsState(pindexPrev, params,\n>>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>>>> THRESHOLD_LOCKED_IN);\n>>>> }\n>>>> \n>>>> // SEGSIGNAL mandatory segwit signalling.\n>>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>>>> &&\n>>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>>>> // Segwit is not locked in\n>>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>>>> and is not active.\n>>>> {\n>>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>>>> VERSIONBITS_TOP_BITS;\n>>>>    bool fSegbit = (pindex->nVersion &\n>>>> VersionBitsMask(chainparams.GetConsensus(),\n>>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>>>>    if (!(fVersionBits && fSegbit)) {\n>>>>        return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>>>> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>>>>    }\n>>>> }\n>>>> </pre>\n>>>> \n>>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>>>> \n>>>> ==Backwards Compatibility==\n>>>> \n>>>> This deployment is compatible with the existing \"segwit\" bit 1\n>>>> deployment scheduled between midnight November 15th, 2016 and midnight\n>>>> November 15th, 2017. Miners will need to upgrade their nodes to\n>>>> support segsignal otherwise they may build on top of an invalid block.\n>>>> While this bip is active users should either upgrade to segsignal or\n>>>> wait for additional confirmations when accepting payments.\n>>>> \n>>>> ==Rationale==\n>>>> \n>>>> Historically we have used IsSuperMajority() to activate soft forks\n>>>> such as BIP66 which has a mandatory signalling requirement for miners\n>>>> once activated, this ensures that miners are aware of new rules being\n>>>> enforced. This technique can be leveraged to lower the signalling\n>>>> threshold of a soft fork while it is in the process of being deployed\n>>>> in a backwards compatible way.\n>>>> \n>>>> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>>>> deployment, this BIP can cause the existing \"segwit\" deployment to\n>>>> activate without needing to release a new deployment.\n>>>> \n>>>> ==References==\n>>>> \n>>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n>>>> Mailing list discussion]\n>>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>>>> P2SH flag day activation]\n>>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>>>> Version 0 Witness Program]]\n>>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n>>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n>>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>>>> \n>>>> ==Copyright==\n>>>> \n>>>> This document is dual licensed as BSD 3-clause, and Creative Commons\n>>>> CC0 1.0 Universal.\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-24T16:36:03",
                "message_text_only": "I would be fine with that, since segwit is widely deployed on the\nnetwork already a lower activation threshold should be safe.\n\nOn Wed, May 24, 2017 at 12:02 PM, Wang Chun <1240902 at gmail.com> wrote:\n> I think we should go for 75%, same Litecoin. As I have said before, 95% threshold is too high even for unconventional soft forks.\n>\n>> \u5728 2017\u5e745\u670824\u65e5\uff0c04:58\uff0cAndrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> \u5199\u9053\uff1a\n>>\n>> Ah. I see now. It wasn't very clear to me that that is what will happen.\n>>\n>> Also, shouldn't the timeout date be set for before the BIP141 timeout?\n>> Otherwise this could lock in but not have enough time for Segwit to be\n>> locked in.\n>>\n>>\n>>> On 5/23/2017 4:42 PM, James Hilliard wrote:\n>>> That is incorrect, it is compatible with the current segwit\n>>> implementation because it triggers a mandatory signalling period that\n>>> will activate segwit on existing nodes.\n>>>\n>>> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev\n>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>> Hi James,\n>>>>\n>>>> From what I understand, this proposal is incompatible with the current\n>>>> segwit implementation with regards to the NODE_WITNESS service bit. I\n>>>> believe it could cause network partitioning if the service bit is not\n>>>> changed.\n>>>>\n>>>> Andrew\n>>>>\n>>>>\n>>>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n>>>>> I would like to propose an implementation that accomplishes the first\n>>>>> part of the Barry Silbert proposal independently from the second:\n>>>>>\n>>>>> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>>>>> in a way that\n>>>>>\n>>>>> The goal here is to minimize chain split risk and network disruption\n>>>>> while maximizing backwards compatibility and still providing for rapid\n>>>>> activation of segwit at the 80% threshold using bit 4.\n>>>>>\n>>>>> By activating segwit immediately and separately from any HF we can\n>>>>> scale quickly without risking a rushed combined segwit+HF that would\n>>>>> almost certainly cause widespread issues.\n>>>>>\n>>>>> Draft proposal:\n>>>>> https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.mediawiki\n>>>>>\n>>>>> Proposal text:\n>>>>> <pre>\n>>>>>  BIP: segsignal\n>>>>>  Layer: Consensus (soft fork)\n>>>>>  Title: Reduced signalling threshold activation of existing segwit deployment\n>>>>>  Author: James Hilliard <james.hilliard1 at gmail.com>\n>>>>>  Status: Draft\n>>>>>  Type: Standards Track\n>>>>>  Created: 2017-05-22\n>>>>>  License: BSD-3-Clause\n>>>>>           CC0-1.0\n>>>>> </pre>\n>>>>>\n>>>>> ==Abstract==\n>>>>>\n>>>>> This document specifies a method to activate the existing BIP9 segwit\n>>>>> deployment with a majority hashpower less than 95%.\n>>>>>\n>>>>> ==Definitions==\n>>>>>\n>>>>> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>>>>> using bit 1, between November 15th 2016 and November 15th 2017 to\n>>>>> activate BIP141, BIP143 and BIP147.\n>>>>>\n>>>>> ==Motivation==\n>>>>>\n>>>>> Segwit increases the blocksize, fixes transaction malleability, and\n>>>>> makes scripting easier to upgrade as well as bringing many other\n>>>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>>>>>\n>>>>> This BIP provides a way for a simple majority of miners to coordinate\n>>>>> activation of the existing segwit deployment with less than 95%\n>>>>> hashpower. For a number of reasons a complete redeployment of segwit\n>>>>> is difficulty to do until the existing deployment expires. This is due\n>>>>> to 0.13.1+ having many segwit related features active already,\n>>>>> including all the P2P components, the new network service flag, the\n>>>>> witness-tx and block messages, compact blocks v2 and preferential\n>>>>> peering. A redeployment of segwit will need to redefine all these\n>>>>> things and doing so before expiry would greatly complicate testing.\n>>>>>\n>>>>> ==Specification==\n>>>>>\n>>>>> While this BIP is active, all blocks must set the nVersion header top\n>>>>> 3 bits to 001 together with bit field (1<<1) (according to the\n>>>>> existing segwit deployment). Blocks that do not signal as required\n>>>>> will be rejected.\n>>>>>\n>>>>> ==Deployment==\n>>>>>\n>>>>> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>>>>> adjusted if desired) activation threshold BIP9 with the name\n>>>>> \"segsignal\" and using bit 4.\n>>>>>\n>>>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>>>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n>>>>> 1510704000). This BIP will cease to be active when segwit is\n>>>>> locked-in.\n>>>>>\n>>>>> === Reference implementation ===\n>>>>>\n>>>>> <pre>\n>>>>> // Check if Segregated Witness is Locked In\n>>>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>>>>> Consensus::Params& params)\n>>>>> {\n>>>>>    LOCK(cs_main);\n>>>>>    return (VersionBitsState(pindexPrev, params,\n>>>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>>>>> THRESHOLD_LOCKED_IN);\n>>>>> }\n>>>>>\n>>>>> // SEGSIGNAL mandatory segwit signalling.\n>>>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>>>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>>>>> &&\n>>>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>>>>> // Segwit is not locked in\n>>>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>>>>> and is not active.\n>>>>> {\n>>>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>>>>> VERSIONBITS_TOP_BITS;\n>>>>>    bool fSegbit = (pindex->nVersion &\n>>>>> VersionBitsMask(chainparams.GetConsensus(),\n>>>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>>>>>    if (!(fVersionBits && fSegbit)) {\n>>>>>        return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>>>>> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>>>>>    }\n>>>>> }\n>>>>> </pre>\n>>>>>\n>>>>> https://github.com/bitcoin/bitcoin/compare/0.14...jameshilliard:segsignal-v0.14.1\n>>>>>\n>>>>> ==Backwards Compatibility==\n>>>>>\n>>>>> This deployment is compatible with the existing \"segwit\" bit 1\n>>>>> deployment scheduled between midnight November 15th, 2016 and midnight\n>>>>> November 15th, 2017. Miners will need to upgrade their nodes to\n>>>>> support segsignal otherwise they may build on top of an invalid block.\n>>>>> While this bip is active users should either upgrade to segsignal or\n>>>>> wait for additional confirmations when accepting payments.\n>>>>>\n>>>>> ==Rationale==\n>>>>>\n>>>>> Historically we have used IsSuperMajority() to activate soft forks\n>>>>> such as BIP66 which has a mandatory signalling requirement for miners\n>>>>> once activated, this ensures that miners are aware of new rules being\n>>>>> enforced. This technique can be leveraged to lower the signalling\n>>>>> threshold of a soft fork while it is in the process of being deployed\n>>>>> in a backwards compatible way.\n>>>>>\n>>>>> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>>>>> deployment, this BIP can cause the existing \"segwit\" deployment to\n>>>>> activate without needing to release a new deployment.\n>>>>>\n>>>>> ==References==\n>>>>>\n>>>>> *[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html\n>>>>> Mailing list discussion]\n>>>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>>>>> P2SH flag day activation]\n>>>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>>>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>>>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>>>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>>>>> Version 0 Witness Program]]\n>>>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n>>>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n>>>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>>>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n>>>>>\n>>>>> ==Copyright==\n>>>>>\n>>>>> This document is dual licensed as BSD 3-clause, and Creative Commons\n>>>>> CC0 1.0 Universal.\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-24T16:44:55",
                "message_text_only": "Yes, 75% seems fine - given that there is a already a wide deployment of\nsegwit enforcing nodes\n\nThis implementation is 100% compatible with a \"UASF movement\" since, if\ntriggered, it essentially turns all supporting miners into equivalent\nBIP148 enforcers.   This should allay any fears that this would subvert a\nUASF.\n\nThe proposed \"agreement\" which was reached without input from the\ndevelopment community also apparently requires that a hard fork be locked\nin on the same bit (bit 4).\n\nIdeally, such a 2MB increase should be scheduled using BIP103-esqe logic:\nGradually increasing from 1MB to 2MB over the course of at least a couple\nyears, beginning 6 months from lock-in.\n\nThis will give developers ample time to evaluate and react to network\nimpacts.\n\n\nOn Wed, May 24, 2017 at 12:02 PM, Wang Chun via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I think we should go for 75%, same Litecoin. As I have said before, 95%\n> threshold is too high even for unconventional soft forks.\n>\n> > \u5728 2017\u5e745\u670824\u65e5\uff0c04:58\uff0cAndrew Chow via bitcoin-dev <bitcoin-dev at lists.\n> linuxfoundation.org> \u5199\u9053\uff1a\n> >\n> > Ah. I see now. It wasn't very clear to me that that is what will happen.\n> >\n> > Also, shouldn't the timeout date be set for before the BIP141 timeout?\n> > Otherwise this could lock in but not have enough time for Segwit to be\n> > locked in.\n> >\n> >\n> >> On 5/23/2017 4:42 PM, James Hilliard wrote:\n> >> That is incorrect, it is compatible with the current segwit\n> >> implementation because it triggers a mandatory signalling period that\n> >> will activate segwit on existing nodes.\n> >>\n> >> On Tue, May 23, 2017 at 4:39 PM, Andrew Chow via bitcoin-dev\n> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>> Hi James,\n> >>>\n> >>> From what I understand, this proposal is incompatible with the current\n> >>> segwit implementation with regards to the NODE_WITNESS service bit. I\n> >>> believe it could cause network partitioning if the service bit is not\n> >>> changed.\n> >>>\n> >>> Andrew\n> >>>\n> >>>\n> >>>> On 5/22/2017 6:40 PM, James Hilliard via bitcoin-dev wrote:\n> >>>> I would like to propose an implementation that accomplishes the first\n> >>>> part of the Barry Silbert proposal independently from the second:\n> >>>>\n> >>>> \"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n> >>>> in a way that\n> >>>>\n> >>>> The goal here is to minimize chain split risk and network disruption\n> >>>> while maximizing backwards compatibility and still providing for rapid\n> >>>> activation of segwit at the 80% threshold using bit 4.\n> >>>>\n> >>>> By activating segwit immediately and separately from any HF we can\n> >>>> scale quickly without risking a rushed combined segwit+HF that would\n> >>>> almost certainly cause widespread issues.\n> >>>>\n> >>>> Draft proposal:\n> >>>> https://github.com/jameshilliard/bips/blob/bip-\n> segsignal/bip-segsignal.mediawiki\n> >>>>\n> >>>> Proposal text:\n> >>>> <pre>\n> >>>>  BIP: segsignal\n> >>>>  Layer: Consensus (soft fork)\n> >>>>  Title: Reduced signalling threshold activation of existing segwit\n> deployment\n> >>>>  Author: James Hilliard <james.hilliard1 at gmail.com>\n> >>>>  Status: Draft\n> >>>>  Type: Standards Track\n> >>>>  Created: 2017-05-22\n> >>>>  License: BSD-3-Clause\n> >>>>           CC0-1.0\n> >>>> </pre>\n> >>>>\n> >>>> ==Abstract==\n> >>>>\n> >>>> This document specifies a method to activate the existing BIP9 segwit\n> >>>> deployment with a majority hashpower less than 95%.\n> >>>>\n> >>>> ==Definitions==\n> >>>>\n> >>>> \"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n> >>>> using bit 1, between November 15th 2016 and November 15th 2017 to\n> >>>> activate BIP141, BIP143 and BIP147.\n> >>>>\n> >>>> ==Motivation==\n> >>>>\n> >>>> Segwit increases the blocksize, fixes transaction malleability, and\n> >>>> makes scripting easier to upgrade as well as bringing many other\n> >>>> [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n> >>>>\n> >>>> This BIP provides a way for a simple majority of miners to coordinate\n> >>>> activation of the existing segwit deployment with less than 95%\n> >>>> hashpower. For a number of reasons a complete redeployment of segwit\n> >>>> is difficulty to do until the existing deployment expires. This is due\n> >>>> to 0.13.1+ having many segwit related features active already,\n> >>>> including all the P2P components, the new network service flag, the\n> >>>> witness-tx and block messages, compact blocks v2 and preferential\n> >>>> peering. A redeployment of segwit will need to redefine all these\n> >>>> things and doing so before expiry would greatly complicate testing.\n> >>>>\n> >>>> ==Specification==\n> >>>>\n> >>>> While this BIP is active, all blocks must set the nVersion header top\n> >>>> 3 bits to 001 together with bit field (1<<1) (according to the\n> >>>> existing segwit deployment). Blocks that do not signal as required\n> >>>> will be rejected.\n> >>>>\n> >>>> ==Deployment==\n> >>>>\n> >>>> This BIP will be deployed by a \"version bits\" with an 80%(this can be\n> >>>> adjusted if desired) activation threshold BIP9 with the name\n> >>>> \"segsignal\" and using bit 4.\n> >>>>\n> >>>> This BIP will have a start time of midnight June 1st, 2017 (epoch time\n> >>>> 1496275200) and timeout on midnight November 15th 2017 (epoch time\n> >>>> 1510704000). This BIP will cease to be active when segwit is\n> >>>> locked-in.\n> >>>>\n> >>>> === Reference implementation ===\n> >>>>\n> >>>> <pre>\n> >>>> // Check if Segregated Witness is Locked In\n> >>>> bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n> >>>> Consensus::Params& params)\n> >>>> {\n> >>>>    LOCK(cs_main);\n> >>>>    return (VersionBitsState(pindexPrev, params,\n> >>>> Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n> >>>> THRESHOLD_LOCKED_IN);\n> >>>> }\n> >>>>\n> >>>> // SEGSIGNAL mandatory segwit signalling.\n> >>>> if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n> >>>> Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) ==\n> THRESHOLD_ACTIVE\n> >>>> &&\n> >>>>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n> >>>> // Segwit is not locked in\n> >>>>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n> >>>> and is not active.\n> >>>> {\n> >>>>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n> >>>> VERSIONBITS_TOP_BITS;\n> >>>>    bool fSegbit = (pindex->nVersion &\n> >>>> VersionBitsMask(chainparams.GetConsensus(),\n> >>>> Consensus::DEPLOYMENT_SEGWIT)) != 0;\n> >>>>    if (!(fVersionBits && fSegbit)) {\n> >>>>        return state.DoS(0, error(\"ConnectBlock(): relayed block must\n> >>>> signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n> >>>>    }\n> >>>> }\n> >>>> </pre>\n> >>>>\n> >>>> https://github.com/bitcoin/bitcoin/compare/0.14...\n> jameshilliard:segsignal-v0.14.1\n> >>>>\n> >>>> ==Backwards Compatibility==\n> >>>>\n> >>>> This deployment is compatible with the existing \"segwit\" bit 1\n> >>>> deployment scheduled between midnight November 15th, 2016 and midnight\n> >>>> November 15th, 2017. Miners will need to upgrade their nodes to\n> >>>> support segsignal otherwise they may build on top of an invalid block.\n> >>>> While this bip is active users should either upgrade to segsignal or\n> >>>> wait for additional confirmations when accepting payments.\n> >>>>\n> >>>> ==Rationale==\n> >>>>\n> >>>> Historically we have used IsSuperMajority() to activate soft forks\n> >>>> such as BIP66 which has a mandatory signalling requirement for miners\n> >>>> once activated, this ensures that miners are aware of new rules being\n> >>>> enforced. This technique can be leveraged to lower the signalling\n> >>>> threshold of a soft fork while it is in the process of being deployed\n> >>>> in a backwards compatible way.\n> >>>>\n> >>>> By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n> >>>> deployment, this BIP can cause the existing \"segwit\" deployment to\n> >>>> activate without needing to release a new deployment.\n> >>>>\n> >>>> ==References==\n> >>>>\n> >>>> *[https://lists.linuxfoundation.org/pipermail/\n> bitcoin-dev/2017-March/013714.html\n> >>>> Mailing list discussion]\n> >>>> *[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.\n> cpp#L1281-L1283\n> >>>> P2SH flag day activation]\n> >>>> *[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n> >>>> *[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n> >>>> *[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n> >>>> *[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n> >>>> Version 0 Witness Program]]\n> >>>> *[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element\n> malleability]]\n> >>>> *[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit\n> deployment]]\n> >>>> *[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n> >>>> *[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit\n> benefits]\n> >>>>\n> >>>> ==Copyright==\n> >>>>\n> >>>> This document is dual licensed as BSD 3-clause, and Creative Commons\n> >>>> CC0 1.0 Universal.\n> >>>> _______________________________________________\n> >>>> bitcoin-dev mailing list\n> >>>> bitcoin-dev at lists.linuxfoundation.org\n> >>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>> _______________________________________________\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/c635f01f/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-23T04:00:53",
                "message_text_only": "Seems like it would work fine.  But why would we expect 80pct to signal for\nthe exact same implementation - when we can't get 40pct.\n\nIt will be contingent on some HF code that allows him to continue using\nasicboost,  or is too aggressive,  or some other unreasonable request.\n\n\n\nOn May 22, 2017 6:43 PM, \"Matt Corallo via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nGiven the overwhelming support for SegWit across the ecosystem of\nbusinesses and users, this seems reasonable to me.\n\nOn May 22, 2017 6:40:13 PM EDT, James Hilliard via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n>I would like to propose an implementation that accomplishes the first\n>part of the Barry Silbert proposal independently from the second:\n>\n>\"Activate Segregated Witness at an 80% threshold, signaling at bit 4\"\n>in a way that\n>\n>The goal here is to minimize chain split risk and network disruption\n>while maximizing backwards compatibility and still providing for rapid\n>activation of segwit at the 80% threshold using bit 4.\n>\n>By activating segwit immediately and separately from any HF we can\n>scale quickly without risking a rushed combined segwit+HF that would\n>almost certainly cause widespread issues.\n>\n>Draft proposal:\n>https://github.com/jameshilliard/bips/blob/bip-segsignal/bip-segsignal.\nmediawiki\n>\n>Proposal text:\n><pre>\n>  BIP: segsignal\n>  Layer: Consensus (soft fork)\n>Title: Reduced signalling threshold activation of existing segwit\n>deployment\n>  Author: James Hilliard <james.hilliard1 at gmail.com>\n>  Status: Draft\n>  Type: Standards Track\n>  Created: 2017-05-22\n>  License: BSD-3-Clause\n>           CC0-1.0\n></pre>\n>\n>==Abstract==\n>\n>This document specifies a method to activate the existing BIP9 segwit\n>deployment with a majority hashpower less than 95%.\n>\n>==Definitions==\n>\n>\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment\n>using bit 1, between November 15th 2016 and November 15th 2017 to\n>activate BIP141, BIP143 and BIP147.\n>\n>==Motivation==\n>\n>Segwit increases the blocksize, fixes transaction malleability, and\n>makes scripting easier to upgrade as well as bringing many other\n>[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n>\n>This BIP provides a way for a simple majority of miners to coordinate\n>activation of the existing segwit deployment with less than 95%\n>hashpower. For a number of reasons a complete redeployment of segwit\n>is difficulty to do until the existing deployment expires. This is due\n>to 0.13.1+ having many segwit related features active already,\n>including all the P2P components, the new network service flag, the\n>witness-tx and block messages, compact blocks v2 and preferential\n>peering. A redeployment of segwit will need to redefine all these\n>things and doing so before expiry would greatly complicate testing.\n>\n>==Specification==\n>\n>While this BIP is active, all blocks must set the nVersion header top\n>3 bits to 001 together with bit field (1<<1) (according to the\n>existing segwit deployment). Blocks that do not signal as required\n>will be rejected.\n>\n>==Deployment==\n>\n>This BIP will be deployed by a \"version bits\" with an 80%(this can be\n>adjusted if desired) activation threshold BIP9 with the name\n>\"segsignal\" and using bit 4.\n>\n>This BIP will have a start time of midnight June 1st, 2017 (epoch time\n>1496275200) and timeout on midnight November 15th 2017 (epoch time\n>1510704000). This BIP will cease to be active when segwit is\n>locked-in.\n>\n>=== Reference implementation ===\n>\n><pre>\n>// Check if Segregated Witness is Locked In\n>bool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const\n>Consensus::Params& params)\n>{\n>    LOCK(cs_main);\n>    return (VersionBitsState(pindexPrev, params,\n>Consensus::DEPLOYMENT_SEGWIT, versionbitscache) ==\n>THRESHOLD_LOCKED_IN);\n>}\n>\n>// SEGSIGNAL mandatory segwit signalling.\n>if ( VersionBitsState(pindex->pprev, chainparams.GetConsensus(),\n>Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE\n>&&\n>     !IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&\n>// Segwit is not locked in\n>     !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) ) //\n>and is not active.\n>{\n>    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) ==\n>VERSIONBITS_TOP_BITS;\n>    bool fSegbit = (pindex->nVersion &\n>VersionBitsMask(chainparams.GetConsensus(),\n>Consensus::DEPLOYMENT_SEGWIT)) != 0;\n>    if (!(fVersionBits && fSegbit)) {\n>        return state.DoS(0, error(\"ConnectBlock(): relayed block must\n>signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n>    }\n>}\n></pre>\n>\n>https://github.com/bitcoin/bitcoin/compare/0.14...\njameshilliard:segsignal-v0.14.1\n>\n>==Backwards Compatibility==\n>\n>This deployment is compatible with the existing \"segwit\" bit 1\n>deployment scheduled between midnight November 15th, 2016 and midnight\n>November 15th, 2017. Miners will need to upgrade their nodes to\n>support segsignal otherwise they may build on top of an invalid block.\n>While this bip is active users should either upgrade to segsignal or\n>wait for additional confirmations when accepting payments.\n>\n>==Rationale==\n>\n>Historically we have used IsSuperMajority() to activate soft forks\n>such as BIP66 which has a mandatory signalling requirement for miners\n>once activated, this ensures that miners are aware of new rules being\n>enforced. This technique can be leveraged to lower the signalling\n>threshold of a soft fork while it is in the process of being deployed\n>in a backwards compatible way.\n>\n>By orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\"\n>deployment, this BIP can cause the existing \"segwit\" deployment to\n>activate without needing to release a new deployment.\n>\n>==References==\n>\n>*[https://lists.linuxfoundation.org/pipermail/\nbitcoin-dev/2017-March/013714.html\n>Mailing list discussion]\n>*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283\n>P2SH flag day activation]\n>*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n>*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n>*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n>*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for\n>Version 0 Witness Program]]\n>*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element\n>malleability]]\n>*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit\n>deployment]]\n>*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n>*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit\n>benefits]\n>\n>==Copyright==\n>\n>This document is dual licensed as BSD 3-clause, and Creative Commons\n>CC0 1.0 Universal.\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/9ed12432/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Reduced signalling threshold activation of existing segwit deployment",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "James Hilliard",
                "Erik Aronesty",
                "Wang Chun",
                "Kekcoin",
                "Matt Corallo",
                "Andrew Chow"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 85105
        }
    },
    {
        "title": "[bitcoin-dev] Proposal to allow users to configure the maximum block weight based on a support threshold",
        "thread_messages": [
            {
                "author": "Tomas",
                "date": "2017-05-23T10:50:37",
                "message_text_only": "I have a proposal that would allow each user to optionally configure the\nmaximum block weight at a support threshold.\n\nIt recognizes that there is no need for off chain bickering, by\nproviding a mechanism that lets each users freely choose their own\nparameters while still maintaining full coordination of any changes.\n\nThe BIP can be found here: \n\nhttps://github.com/tomasvdw/bips/blob/master/bip-changing-the-maximum-block%20weight-based-on-a-support-threshold.mediawiki\n\nIt is worth noting that this proposal does neither gives more power to\nminers nor reduces decentralization. Miners still rely on their blocks\nbeing accepted by economic nodes to sell their minted coins. This\nproposal doesn't change that. \n\nRegards,\nTomas van der Wansem\nbitcrust"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-24T02:42:30",
                "message_text_only": "Instead of block thresholds, use utxo bits to coordinate size changes\n(larger and smaller should be allowed).\n\nThere is no reason for miners to be involved in a decision to change this\naspects of the protocol.   Plenty of other ways to coordinate.\n\nOtherwise someone can make it seem to a miner like 99pct of nodes are ready\nfor a larger weight.... even though that's false.\n\nOn May 23, 2017 8:03 AM, \"Tomas via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have a proposal that would allow each user to optionally configure the\n> maximum block weight at a support threshold.\n>\n> It recognizes that there is no need for off chain bickering, by\n> providing a mechanism that lets each users freely choose their own\n> parameters while still maintaining full coordination of any changes.\n>\n> The BIP can be found here:\n>\n> https://github.com/tomasvdw/bips/blob/master/bip-changing-\n> the-maximum-block%20weight-based-on-a-support-threshold.mediawiki\n>\n> It is worth noting that this proposal does neither gives more power to\n> miners nor reduces decentralization. Miners still rely on their blocks\n> being accepted by economic nodes to sell their minted coins. This\n> proposal doesn't change that.\n>\n> Regards,\n> Tomas van der Wansem\n> bitcrust\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/e6d5a95f/attachment.html>"
            },
            {
                "author": "Tomas",
                "date": "2017-05-24T08:34:10",
                "message_text_only": "On Wed, May 24, 2017, at 04:42, Erik Aronesty wrote:\n> Instead of block thresholds, use utxo bits to coordinate size changes\n> (larger and smaller should be allowed).> \n> There is no reason for miners to be involved in a decision to change\n> this aspects of the protocol.   Plenty of other ways to coordinate.\nMiners cannot change the block size or any other rule without support of\nthe users, because their blocks and coins would be rejected. This\nmechanism that Bitcoin brought us, has been working fine and I see no\nreason to change it with utxo bits.\nI *only* propose an optional way  to synchronize changes without the\nneed of off chain agreements, which seems like a simple improvement over\nthe current situation.\n\n> \n> Otherwise someone can make it seem to a miner like 99pct of nodes are\n> ready for a larger weight.... even though that's false.\nI agree that the user agent signalling isn't very important, and I think\nthat most of us aware that you cannot rely on counting them.\n> \n> On May 23, 2017 8:03 AM, \"Tomas via bitcoin-dev\" <bitcoin-\n> dev at lists.linuxfoundation.org> wrote:>> I have a proposal that would allow each user to optionally\n>> configure the>>  maximum block weight at a support threshold.\n>> \n>>  It recognizes that there is no need for off chain bickering, by\n>>  providing a mechanism that lets each users freely choose their own\n>>  parameters while still maintaining full coordination of any changes.>> \n>>  The BIP can be found here:\n>> \n>> https://github.com/tomasvdw/bips/blob/master/bip-changing-the-maximum-block%20weight-based-on-a-support-threshold.mediawiki>> \n>>  It is worth noting that this proposal does neither gives more\n>>  power to>>  miners nor reduces decentralization. Miners still rely on their\n>>  blocks>>  being accepted by economic nodes to sell their minted coins. This\n>>  proposal doesn't change that.\n>> \n>>  Regards,\n>>  Tomas van der Wansem\n>>  bitcrust\n>>  _______________________________________________\n>>  bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170524/648bb861/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal to allow users to configure the maximum block weight based on a support threshold",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tomas",
                "Erik Aronesty"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4684
        }
    },
    {
        "title": "[bitcoin-dev] A BIP proposal for conveniently referring to confirmed transactions",
        "thread_messages": [
            {
                "author": "\u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432",
                "date": "2017-05-23T15:30:58",
                "message_text_only": "Hello List,\n\nI would like to propose a BIP that specifies a way of referring to transactions that have been successfully inserted into the blockchain.\n\nThe format makes use of the excellent Bech32 encoding, and is designed to be short and useful for human use. A C reference implementation is included.\n\nSpecial care has been taken so this BIP is naturally extendable to support future upgrades to Bitcoin, Bitcoin Sidechains, or even from other blockchain projects. However, only support for the Bitcoin Main Chain, and the Test Network is specified in this draft.\n\nI hope that the participants of the bitcoin-development mailing list find this draft BIP both interesting and useful. You are welcomed to read the full text here: https://github.com/veleslavs/bips/blob/Bech32_Encoded_TxRef/bip-XXXX-Bech32_Encoded_Transaction_Postion_References.mediawiki\n\nIf assigned with a BIP number some small updates to the specification will be made in accommodation.\n\n\u0421 \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0438\u043c\u0438 \u043f\u043e\u0436\u0435\u043b\u0430\u043d\u0438\u044f\u043c\u0438,\n\n\u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/101898b8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "A BIP proposal for conveniently referring to confirmed transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "\u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1176
        }
    },
    {
        "title": "[bitcoin-dev] BIP149 timeout-- why so far in the future?",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2017-05-23T17:50:12",
                "message_text_only": "Based on how fast we saw segwit adoption, why is the BIP149 timeout so\nfar in the future?\n\nIt seems to me that it could be six months after release and hit the\nkind of density required to make a stable transition.\n\n(If it were a different proposal and not segwit where we already have\nseen what network penetration looks like-- that would be another\nmatter.)"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-24T04:26:56",
                "message_text_only": "Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Based on how fast we saw segwit adoption, why is the BIP149 timeout so\n> far in the future?\n>\n> It seems to me that it could be six months after release and hit the\n> kind of density required to make a stable transition.\n\nAgreed, I would suggest 16th December, 2017 (otherwise, it should be\n16th January 2018; during EOY holidays seems a bad idea).\n\nThis means this whole debacle has delayed segwit exactly 1 (2) month(s)\nbeyond what we'd have if it used BIP8 in the first place.\n\nCheers,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2017-05-26T20:04:58",
                "message_text_only": "A more important consideration than segwit's timeout is when code can be\nreleased, which will no doubt be several months after SegWit's current\ntimeout.\n\nGreg's proposed 6 months seems much more reasonable to me, assuming its\nstill many months after the formal release of code implementing it.\n\nMatt\n\nOn 05/24/17 04:26, Rusty Russell via bitcoin-dev wrote:\n> Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> writes:\n>> Based on how fast we saw segwit adoption, why is the BIP149 timeout so\n>> far in the future?\n>>\n>> It seems to me that it could be six months after release and hit the\n>> kind of density required to make a stable transition.\n> \n> Agreed, I would suggest 16th December, 2017 (otherwise, it should be\n> 16th January 2018; during EOY holidays seems a bad idea).\n> \n> This means this whole debacle has delayed segwit exactly 1 (2) month(s)\n> beyond what we'd have if it used BIP8 in the first place.\n> \n> Cheers,\n> Rusty.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2017-05-27T01:19:33",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> A more important consideration than segwit's timeout is when code can be\n> released, which will no doubt be several months after SegWit's current\n> timeout.\n\nI was assuming it would be included in the next point release.\n\nCheers,\nRusty."
            },
            {
                "author": "shaolinfry",
                "date": "2017-05-26T07:28:09",
                "message_text_only": "I agree the date can be brought forward. FWIW, I originally set the date far out enough that people wouldn't immediately fixate on the date and rather look at the meat of the proposal instead.\n\nGiven that we saw around 70% of nodes upgrade to BIP141 in around 5/6 months, I dont see any reason why we cant reduce the date to being 6 months or less from Nov. Given people are starving for segwit to the point of running BIP148, there is good evidence the community will upgrade in record time to BIP149.\n\nSent from [ProtonMail](https://protonmail.com), Swiss-based encrypted email.\n\n-------- Original Message --------\n\nBased on how fast we saw segwit adoption, why is the BIP149 timeout so\nfar in the future?\n\nIt seems to me that it could be six months after release and hit the\nkind of density required to make a stable transition.\n\n(If it were a different proposal and not segwit where we already have\nseen what network penetration looks like-- that would be another\nmatter.)\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/6d046307/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP149 timeout-- why so far in the future?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Gregory Maxwell",
                "shaolinfry",
                "Matt Corallo"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 3714
        }
    },
    {
        "title": "[bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2017-05-23T20:23:40",
                "message_text_only": "In light of some recent discussions, I wrote up this BIP for a real 2 MB block \nsize hardfork following Segwit BIP148 activation. This is not part of any \nagreement I am party to, nor anything of that sort. Just something to throw \nout there as a possible (and realistic) option.\n\nNote that I cannot recommend this to be adopted, since frankly 1 MB blocks \nreally are still too large, and this blunt-style hardfork quite risky even \nwith consensus. But if the community wishes to adopt (by unanimous consensus) \na 2 MB block size hardfork, this is probably the best way to do it right now. \nThe only possible way to improve on this IMO would be to integrate it into \nMMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size HF \nimprovements).\n\nI have left Author blank, as I do not intend to personally champion this. \nBefore it may be assigned a BIP number, someone else will need to step up to \ntake on that role. Motivation and Rationale are blank because I do not \npersonally think there is any legitimate rationale for such a hardfork at this \ntime; if someone adopts this BIP, they should complete these sections. (I can \npush a git branch with the BIP text if someone wants to fork it.)\n\n<pre>\nBIP: ?\nLayer: Consensus (hard fork)\nTitle: Post-segwit 2 MB block size hardfork\nAuthor: FIXME\nComments-Summary: No comments yet.\nComments-URI: ?\nStatus: Draft\nType: Standards Track\nCreated: 2017-05-22\nLicense: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nLegacy Bitcoin transactions are given the witness discount, and a block size \nlimit of 2 MB is imposed.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Specification==\n\nUpon activation, a block size limit of 2000000 bytes is enforced.\nThe block weight limit remains at 4000000 WU.\n\nThe calculation of block weight is modified:\nall witness data, including both scriptSig (used by pre-segwit inputs) and \nsegwit witness data, is measured as 1 weight-unit (WU), while all other data \nin the block is measured as 4 WU.\n\nThe witness commitment in the generation transaction is no longer required, \nand instead the txid merkle root in the block header is replaced with a hash \nof:\n\n1. The witness reserved value.\n2. The witness merkle root hash.\n3. The transaction ID merkle root hash.\n\nThe maximum size of a transaction stripped of witness data is limited to 1 MB.\n\n===Deployment===\n\nThis BIP is deployed by flag day, in the block where the median-past time \nsurpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n\nIt is assumed that when this flag day has been reached, Segwit has been \nactivated via BIP141 and/or BIP148.\n\n==Motivation==\n\nFIXME\n\n==Rationale==\n\nFIXME\n\n==Backwards compatibility==\n\nThis is a hardfork, and as such not backward compatible.\nIt should not be deployed without consent of the entire Bitcoin community.\nActivation is scheduled for 18 months from the creation date of this BIP, \nintended to give 6 months to establish consensus, and 12 months for \ndeployment.\n\n==Reference implementation==\n\nFIXME"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-23T23:07:41",
                "message_text_only": "Personally, I would prefer if a 2MB lock-in that uses BIP103 for the\ntiming.\n\nI think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM\ngrowth, of which bandwidth seems the most constraining.\n\n- Erik\n\n\nOn Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> In light of some recent discussions, I wrote up this BIP for a real 2 MB\n> block\n> size hardfork following Segwit BIP148 activation. This is not part of any\n> agreement I am party to, nor anything of that sort. Just something to throw\n> out there as a possible (and realistic) option.\n>\n> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks\n> really are still too large, and this blunt-style hardfork quite risky even\n> with consensus. But if the community wishes to adopt (by unanimous\n> consensus)\n> a 2 MB block size hardfork, this is probably the best way to do it right\n> now.\n> The only possible way to improve on this IMO would be to integrate it into\n> MMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size HF\n> improvements).\n>\n> I have left Author blank, as I do not intend to personally champion this.\n> Before it may be assigned a BIP number, someone else will need to step up\n> to\n> take on that role. Motivation and Rationale are blank because I do not\n> personally think there is any legitimate rationale for such a hardfork at\n> this\n> time; if someone adopts this BIP, they should complete these sections. (I\n> can\n> push a git branch with the BIP text if someone wants to fork it.)\n>\n> <pre>\n> BIP: ?\n> Layer: Consensus (hard fork)\n> Title: Post-segwit 2 MB block size hardfork\n> Author: FIXME\n> Comments-Summary: No comments yet.\n> Comments-URI: ?\n> Status: Draft\n> Type: Standards Track\n> Created: 2017-05-22\n> License: BSD-2-Clause\n> </pre>\n>\n> ==Abstract==\n>\n> Legacy Bitcoin transactions are given the witness discount, and a block\n> size\n> limit of 2 MB is imposed.\n>\n> ==Copyright==\n>\n> This BIP is licensed under the BSD 2-clause license.\n>\n> ==Specification==\n>\n> Upon activation, a block size limit of 2000000 bytes is enforced.\n> The block weight limit remains at 4000000 WU.\n>\n> The calculation of block weight is modified:\n> all witness data, including both scriptSig (used by pre-segwit inputs) and\n> segwit witness data, is measured as 1 weight-unit (WU), while all other\n> data\n> in the block is measured as 4 WU.\n>\n> The witness commitment in the generation transaction is no longer required,\n> and instead the txid merkle root in the block header is replaced with a\n> hash\n> of:\n>\n> 1. The witness reserved value.\n> 2. The witness merkle root hash.\n> 3. The transaction ID merkle root hash.\n>\n> The maximum size of a transaction stripped of witness data is limited to 1\n> MB.\n>\n> ===Deployment===\n>\n> This BIP is deployed by flag day, in the block where the median-past time\n> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n>\n> It is assumed that when this flag day has been reached, Segwit has been\n> activated via BIP141 and/or BIP148.\n>\n> ==Motivation==\n>\n> FIXME\n>\n> ==Rationale==\n>\n> FIXME\n>\n> ==Backwards compatibility==\n>\n> This is a hardfork, and as such not backward compatible.\n> It should not be deployed without consent of the entire Bitcoin community.\n> Activation is scheduled for 18 months from the creation date of this BIP,\n> intended to give 6 months to establish consensus, and 12 months for\n> deployment.\n>\n> ==Reference implementation==\n>\n> FIXME\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170523/3e593f57/attachment-0001.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-30T13:27:58",
                "message_text_only": "Why not simply remove the (redundant after sw activation) 1 mb size\nlimit check and increasing the weight limit without changing the\ndiscount or having 2 limits?\n\n\nOn Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.\n>\n> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM\n> growth, of which bandwidth seems the most constraining.\n>\n> - Erik\n>\n>\n> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> In light of some recent discussions, I wrote up this BIP for a real 2 MB\n>> block\n>> size hardfork following Segwit BIP148 activation. This is not part of any\n>> agreement I am party to, nor anything of that sort. Just something to\n>> throw\n>> out there as a possible (and realistic) option.\n>>\n>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks\n>> really are still too large, and this blunt-style hardfork quite risky even\n>> with consensus. But if the community wishes to adopt (by unanimous\n>> consensus)\n>> a 2 MB block size hardfork, this is probably the best way to do it right\n>> now.\n>> The only possible way to improve on this IMO would be to integrate it into\n>> MMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size\n>> HF\n>> improvements).\n>>\n>> I have left Author blank, as I do not intend to personally champion this.\n>> Before it may be assigned a BIP number, someone else will need to step up\n>> to\n>> take on that role. Motivation and Rationale are blank because I do not\n>> personally think there is any legitimate rationale for such a hardfork at\n>> this\n>> time; if someone adopts this BIP, they should complete these sections. (I\n>> can\n>> push a git branch with the BIP text if someone wants to fork it.)\n>>\n>> <pre>\n>> BIP: ?\n>> Layer: Consensus (hard fork)\n>> Title: Post-segwit 2 MB block size hardfork\n>> Author: FIXME\n>> Comments-Summary: No comments yet.\n>> Comments-URI: ?\n>> Status: Draft\n>> Type: Standards Track\n>> Created: 2017-05-22\n>> License: BSD-2-Clause\n>> </pre>\n>>\n>> ==Abstract==\n>>\n>> Legacy Bitcoin transactions are given the witness discount, and a block\n>> size\n>> limit of 2 MB is imposed.\n>>\n>> ==Copyright==\n>>\n>> This BIP is licensed under the BSD 2-clause license.\n>>\n>> ==Specification==\n>>\n>> Upon activation, a block size limit of 2000000 bytes is enforced.\n>> The block weight limit remains at 4000000 WU.\n>>\n>> The calculation of block weight is modified:\n>> all witness data, including both scriptSig (used by pre-segwit inputs) and\n>> segwit witness data, is measured as 1 weight-unit (WU), while all other\n>> data\n>> in the block is measured as 4 WU.\n>>\n>> The witness commitment in the generation transaction is no longer\n>> required,\n>> and instead the txid merkle root in the block header is replaced with a\n>> hash\n>> of:\n>>\n>> 1. The witness reserved value.\n>> 2. The witness merkle root hash.\n>> 3. The transaction ID merkle root hash.\n>>\n>> The maximum size of a transaction stripped of witness data is limited to 1\n>> MB.\n>>\n>> ===Deployment===\n>>\n>> This BIP is deployed by flag day, in the block where the median-past time\n>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n>>\n>> It is assumed that when this flag day has been reached, Segwit has been\n>> activated via BIP141 and/or BIP148.\n>>\n>> ==Motivation==\n>>\n>> FIXME\n>>\n>> ==Rationale==\n>>\n>> FIXME\n>>\n>> ==Backwards compatibility==\n>>\n>> This is a hardfork, and as such not backward compatible.\n>> It should not be deployed without consent of the entire Bitcoin community.\n>> Activation is scheduled for 18 months from the creation date of this BIP,\n>> intended to give 6 months to establish consensus, and 12 months for\n>> deployment.\n>>\n>> ==Reference implementation==\n>>\n>> FIXME\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2017-05-30T20:10:04",
                "message_text_only": "I'd like to know this too.  Is it just that a 4MB blockmaxweight would\ntheoretically allow ~4MB blocks (if ~all witness data), which is too big?\nOr is there a more subtle reason we still need blockmaxsize after a HF?\n\n\nOn May 30, 2017 9:28 AM, \"Jorge Tim\u00f3n via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\nWhy not simply remove the (redundant after sw activation) 1 mb size\nlimit check and increasing the weight limit without changing the\ndiscount or having 2 limits?\n\n\nOn Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the\ntiming.\n>\n> I think up to 20% per year can be absorbed by averages in\nbandwidth/CPU/RAM\n> growth, of which bandwidth seems the most constraining.\n>\n> - Erik\n>\n>\n> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> In light of some recent discussions, I wrote up this BIP for a real 2 MB\n>> block\n>> size hardfork following Segwit BIP148 activation. This is not part of any\n>> agreement I am party to, nor anything of that sort. Just something to\n>> throw\n>> out there as a possible (and realistic) option.\n>>\n>> Note that I cannot recommend this to be adopted, since frankly 1 MB\nblocks\n>> really are still too large, and this blunt-style hardfork quite risky\neven\n>> with consensus. But if the community wishes to adopt (by unanimous\n>> consensus)\n>> a 2 MB block size hardfork, this is probably the best way to do it right\n>> now.\n>> The only possible way to improve on this IMO would be to integrate it\ninto\n>> MMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size\n>> HF\n>> improvements).\n>>\n>> I have left Author blank, as I do not intend to personally champion this.\n>> Before it may be assigned a BIP number, someone else will need to step up\n>> to\n>> take on that role. Motivation and Rationale are blank because I do not\n>> personally think there is any legitimate rationale for such a hardfork at\n>> this\n>> time; if someone adopts this BIP, they should complete these sections. (I\n>> can\n>> push a git branch with the BIP text if someone wants to fork it.)\n>>\n>> <pre>\n>> BIP: ?\n>> Layer: Consensus (hard fork)\n>> Title: Post-segwit 2 MB block size hardfork\n>> Author: FIXME\n>> Comments-Summary: No comments yet.\n>> Comments-URI: ?\n>> Status: Draft\n>> Type: Standards Track\n>> Created: 2017-05-22\n>> License: BSD-2-Clause\n>> </pre>\n>>\n>> ==Abstract==\n>>\n>> Legacy Bitcoin transactions are given the witness discount, and a block\n>> size\n>> limit of 2 MB is imposed.\n>>\n>> ==Copyright==\n>>\n>> This BIP is licensed under the BSD 2-clause license.\n>>\n>> ==Specification==\n>>\n>> Upon activation, a block size limit of 2000000 bytes is enforced.\n>> The block weight limit remains at 4000000 WU.\n>>\n>> The calculation of block weight is modified:\n>> all witness data, including both scriptSig (used by pre-segwit inputs)\nand\n>> segwit witness data, is measured as 1 weight-unit (WU), while all other\n>> data\n>> in the block is measured as 4 WU.\n>>\n>> The witness commitment in the generation transaction is no longer\n>> required,\n>> and instead the txid merkle root in the block header is replaced with a\n>> hash\n>> of:\n>>\n>> 1. The witness reserved value.\n>> 2. The witness merkle root hash.\n>> 3. The transaction ID merkle root hash.\n>>\n>> The maximum size of a transaction stripped of witness data is limited to\n1\n>> MB.\n>>\n>> ===Deployment===\n>>\n>> This BIP is deployed by flag day, in the block where the median-past time\n>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n>>\n>> It is assumed that when this flag day has been reached, Segwit has been\n>> activated via BIP141 and/or BIP148.\n>>\n>> ==Motivation==\n>>\n>> FIXME\n>>\n>> ==Rationale==\n>>\n>> FIXME\n>>\n>> ==Backwards compatibility==\n>>\n>> This is a hardfork, and as such not backward compatible.\n>> It should not be deployed without consent of the entire Bitcoin\ncommunity.\n>> Activation is scheduled for 18 months from the creation date of this BIP,\n>> intended to give 6 months to establish consensus, and 12 months for\n>> deployment.\n>>\n>> ==Reference implementation==\n>>\n>> FIXME\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/060fafbb/attachment.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2017-05-30T21:24:20",
                "message_text_only": "The 1MB classic block size is not redundant after segwit activation.\nSegwit prevents the quadratic hashing problems, but only for segwit\noutputs. The 1MB classic block size prevents quadratic hashing\nproblems from being any worse than they are today.\n\nMark\n\nOn Tue, May 30, 2017 at 6:27 AM, Jorge Tim\u00f3n via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Why not simply remove the (redundant after sw activation) 1 mb size\n> limit check and increasing the weight limit without changing the\n> discount or having 2 limits?\n>\n>\n> On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.\n>>\n>> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM\n>> growth, of which bandwidth seems the most constraining.\n>>\n>> - Erik\n>>\n>>\n>> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> In light of some recent discussions, I wrote up this BIP for a real 2 MB\n>>> block\n>>> size hardfork following Segwit BIP148 activation. This is not part of any\n>>> agreement I am party to, nor anything of that sort. Just something to\n>>> throw\n>>> out there as a possible (and realistic) option.\n>>>\n>>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks\n>>> really are still too large, and this blunt-style hardfork quite risky even\n>>> with consensus. But if the community wishes to adopt (by unanimous\n>>> consensus)\n>>> a 2 MB block size hardfork, this is probably the best way to do it right\n>>> now.\n>>> The only possible way to improve on this IMO would be to integrate it into\n>>> MMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size\n>>> HF\n>>> improvements).\n>>>\n>>> I have left Author blank, as I do not intend to personally champion this.\n>>> Before it may be assigned a BIP number, someone else will need to step up\n>>> to\n>>> take on that role. Motivation and Rationale are blank because I do not\n>>> personally think there is any legitimate rationale for such a hardfork at\n>>> this\n>>> time; if someone adopts this BIP, they should complete these sections. (I\n>>> can\n>>> push a git branch with the BIP text if someone wants to fork it.)\n>>>\n>>> <pre>\n>>> BIP: ?\n>>> Layer: Consensus (hard fork)\n>>> Title: Post-segwit 2 MB block size hardfork\n>>> Author: FIXME\n>>> Comments-Summary: No comments yet.\n>>> Comments-URI: ?\n>>> Status: Draft\n>>> Type: Standards Track\n>>> Created: 2017-05-22\n>>> License: BSD-2-Clause\n>>> </pre>\n>>>\n>>> ==Abstract==\n>>>\n>>> Legacy Bitcoin transactions are given the witness discount, and a block\n>>> size\n>>> limit of 2 MB is imposed.\n>>>\n>>> ==Copyright==\n>>>\n>>> This BIP is licensed under the BSD 2-clause license.\n>>>\n>>> ==Specification==\n>>>\n>>> Upon activation, a block size limit of 2000000 bytes is enforced.\n>>> The block weight limit remains at 4000000 WU.\n>>>\n>>> The calculation of block weight is modified:\n>>> all witness data, including both scriptSig (used by pre-segwit inputs) and\n>>> segwit witness data, is measured as 1 weight-unit (WU), while all other\n>>> data\n>>> in the block is measured as 4 WU.\n>>>\n>>> The witness commitment in the generation transaction is no longer\n>>> required,\n>>> and instead the txid merkle root in the block header is replaced with a\n>>> hash\n>>> of:\n>>>\n>>> 1. The witness reserved value.\n>>> 2. The witness merkle root hash.\n>>> 3. The transaction ID merkle root hash.\n>>>\n>>> The maximum size of a transaction stripped of witness data is limited to 1\n>>> MB.\n>>>\n>>> ===Deployment===\n>>>\n>>> This BIP is deployed by flag day, in the block where the median-past time\n>>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n>>>\n>>> It is assumed that when this flag day has been reached, Segwit has been\n>>> activated via BIP141 and/or BIP148.\n>>>\n>>> ==Motivation==\n>>>\n>>> FIXME\n>>>\n>>> ==Rationale==\n>>>\n>>> FIXME\n>>>\n>>> ==Backwards compatibility==\n>>>\n>>> This is a hardfork, and as such not backward compatible.\n>>> It should not be deployed without consent of the entire Bitcoin community.\n>>> Activation is scheduled for 18 months from the creation date of this BIP,\n>>> intended to give 6 months to establish consensus, and 12 months for\n>>> deployment.\n>>>\n>>> ==Reference implementation==\n>>>\n>>> FIXME\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-30T22:26:20",
                "message_text_only": "My understanding is that you cannot possibly violate the 1 MB block\nsize rule without also violating the 4 MB weight rule.\nRegarding size alone, the only check we care about if we accept segwit is:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2891 [size4]\n\nIf that doesn't fail due to excessive non-witness data, then there's no way that\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2681 [size1]\n\nwould have failed before due to excessive non-witness data.\nIf I understood it correctly when I was explained, if I remember\ncorrectly, that last check is really just an optimization or a\nprotection against DoS invalid blocks. If the size without any witness\ndata is bigger than 1/4 the max_weight, then the max_weight check is\ncertain to fail as well without having to look at any witness data at\nthat validation stage (assuming the failure is due to excessive\nnon-witness data).\n\nI think you are not referring to the 1 mb size limit but to related\none for sigops:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L2704\n[sigops1]\n\nwhose segwit parallel is in:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661\n[sigops4]\n\nI believe the situation is similar in checking before knowing anything\nabout the witness data just in case that's already too much. In fact,\nhere is clearer because MAX_BLOCK_SIGOPS_COST is used for both (and\nWITNESS_SCALE_FACTOR is used for the optimization case).\n\nSo what I would do in a hardfork after segwit activation would be to\nsimply equal MAX_BLOCK_BASE_SIZE=MAX_BLOCK_WEIGHT/WITNESS_SCALE_FACTOR\nfor size1, and increase MAX_BLOCK_WEIGHT and MAX_BLOCK_ SIGOPS_COST\nproportionally for size4 and sigops4 respectively (well, the sigops\nconst for sigops1 as well).\n\nIf I understood segwit correctly, I believe that even though it is not\nactivated yet, you could remove both the size1 and sigops1 checks and\nyour node would still not accept invalid blocks by pre-bip141 rules,\nyour node would just spend more time on invalid blocks due to\ncurrently excessive size/sigops, because it would only realize at a\nlater validation stage. Sorry for the redundancy about the validation\nstage.\n\nBut it is not unlikely that I'm missing something. If I am wrong about\nthis I am spreading misinformation about segwit in several channels,\nso I'm very interested in corrections to my statements in this mail.\n\nOn Tue, May 30, 2017 at 11:24 PM, Mark Friedenbach <mark at friedenbach.org> wrote:\n> The 1MB classic block size is not redundant after segwit activation.\n> Segwit prevents the quadratic hashing problems, but only for segwit\n> outputs. The 1MB classic block size prevents quadratic hashing\n> problems from being any worse than they are today.\n>\n> Mark\n>\n> On Tue, May 30, 2017 at 6:27 AM, Jorge Tim\u00f3n via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Why not simply remove the (redundant after sw activation) 1 mb size\n>> limit check and increasing the weight limit without changing the\n>> discount or having 2 limits?\n>>\n>>\n>> On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> Personally, I would prefer if a 2MB lock-in that uses BIP103 for the timing.\n>>>\n>>> I think up to 20% per year can be absorbed by averages in bandwidth/CPU/RAM\n>>> growth, of which bandwidth seems the most constraining.\n>>>\n>>> - Erik\n>>>\n>>>\n>>> On Tue, May 23, 2017 at 4:23 PM, Luke Dashjr via bitcoin-dev\n>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>> In light of some recent discussions, I wrote up this BIP for a real 2 MB\n>>>> block\n>>>> size hardfork following Segwit BIP148 activation. This is not part of any\n>>>> agreement I am party to, nor anything of that sort. Just something to\n>>>> throw\n>>>> out there as a possible (and realistic) option.\n>>>>\n>>>> Note that I cannot recommend this to be adopted, since frankly 1 MB blocks\n>>>> really are still too large, and this blunt-style hardfork quite risky even\n>>>> with consensus. But if the community wishes to adopt (by unanimous\n>>>> consensus)\n>>>> a 2 MB block size hardfork, this is probably the best way to do it right\n>>>> now.\n>>>> The only possible way to improve on this IMO would be to integrate it into\n>>>> MMHF/\"spoonnet\" style hardfork (and/or add other unrelated-to-block-size\n>>>> HF\n>>>> improvements).\n>>>>\n>>>> I have left Author blank, as I do not intend to personally champion this.\n>>>> Before it may be assigned a BIP number, someone else will need to step up\n>>>> to\n>>>> take on that role. Motivation and Rationale are blank because I do not\n>>>> personally think there is any legitimate rationale for such a hardfork at\n>>>> this\n>>>> time; if someone adopts this BIP, they should complete these sections. (I\n>>>> can\n>>>> push a git branch with the BIP text if someone wants to fork it.)\n>>>>\n>>>> <pre>\n>>>> BIP: ?\n>>>> Layer: Consensus (hard fork)\n>>>> Title: Post-segwit 2 MB block size hardfork\n>>>> Author: FIXME\n>>>> Comments-Summary: No comments yet.\n>>>> Comments-URI: ?\n>>>> Status: Draft\n>>>> Type: Standards Track\n>>>> Created: 2017-05-22\n>>>> License: BSD-2-Clause\n>>>> </pre>\n>>>>\n>>>> ==Abstract==\n>>>>\n>>>> Legacy Bitcoin transactions are given the witness discount, and a block\n>>>> size\n>>>> limit of 2 MB is imposed.\n>>>>\n>>>> ==Copyright==\n>>>>\n>>>> This BIP is licensed under the BSD 2-clause license.\n>>>>\n>>>> ==Specification==\n>>>>\n>>>> Upon activation, a block size limit of 2000000 bytes is enforced.\n>>>> The block weight limit remains at 4000000 WU.\n>>>>\n>>>> The calculation of block weight is modified:\n>>>> all witness data, including both scriptSig (used by pre-segwit inputs) and\n>>>> segwit witness data, is measured as 1 weight-unit (WU), while all other\n>>>> data\n>>>> in the block is measured as 4 WU.\n>>>>\n>>>> The witness commitment in the generation transaction is no longer\n>>>> required,\n>>>> and instead the txid merkle root in the block header is replaced with a\n>>>> hash\n>>>> of:\n>>>>\n>>>> 1. The witness reserved value.\n>>>> 2. The witness merkle root hash.\n>>>> 3. The transaction ID merkle root hash.\n>>>>\n>>>> The maximum size of a transaction stripped of witness data is limited to 1\n>>>> MB.\n>>>>\n>>>> ===Deployment===\n>>>>\n>>>> This BIP is deployed by flag day, in the block where the median-past time\n>>>> surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).\n>>>>\n>>>> It is assumed that when this flag day has been reached, Segwit has been\n>>>> activated via BIP141 and/or BIP148.\n>>>>\n>>>> ==Motivation==\n>>>>\n>>>> FIXME\n>>>>\n>>>> ==Rationale==\n>>>>\n>>>> FIXME\n>>>>\n>>>> ==Backwards compatibility==\n>>>>\n>>>> This is a hardfork, and as such not backward compatible.\n>>>> It should not be deployed without consent of the entire Bitcoin community.\n>>>> Activation is scheduled for 18 months from the creation date of this BIP,\n>>>> intended to give 6 months to establish consensus, and 12 months for\n>>>> deployment.\n>>>>\n>>>> ==Reference implementation==\n>>>>\n>>>> FIXME\n>>>>\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "James MacWhyte",
                "date": "2017-05-30T23:50:01",
                "message_text_only": ">  The 1MB classic block size prevents quadratic hashing\n> problems from being any worse than they are today.\n>\n>\nAdd a transaction-size limit of, say, 10kb and the quadratic hashing\nproblem is a non-issue. Donezo.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/359bc4e6/attachment.html>"
            },
            {
                "author": "Jean-Paul Kogelman",
                "date": "2017-05-31T01:09:26",
                "message_text_only": "That would invalidate any pre-signed transactions that are currently out there. You can't just change the rules out from under people.\n\n\n> On May 30, 2017, at 4:50 PM, James MacWhyte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>  \n>>  The 1MB classic block size prevents quadratic hashing\n>> problems from being any worse than they are today.\n>> \n> \n> Add a transaction-size limit of, say, 10kb and the quadratic hashing problem is a non-issue. Donezo.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/aa4c361d/attachment.html>"
            },
            {
                "author": "Jacob Eliosoff",
                "date": "2017-05-31T03:07:43",
                "message_text_only": "Maybe there's some hole in Jorge's logic and scrapping blockmaxsize has\nquadratic hashing risks, and maybe James' 10KB is too ambitious; but even\nif so, a simple 1MB tx size limit would clearly do the trick.  The broader\npoint is that quadratic hashing is not a compelling reason to keep\nblockmaxsize post-HF: does someone have a better one?\n\n\nOn May 30, 2017 9:46 PM, \"Jean-Paul Kogelman via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> That would invalidate any pre-signed transactions that are currently out\n> there. You can't just change the rules out from under people.\n>\n>\n> On May 30, 2017, at 4:50 PM, James MacWhyte via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>\n>\n>>  The 1MB classic block size prevents quadratic hashing\n>> problems from being any worse than they are today.\n>>\n>>\n> Add a transaction-size limit of, say, 10kb and the quadratic hashing\n> problem is a non-issue. Donezo.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/a232820b/attachment.html>"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-31T01:22:44",
                "message_text_only": "On Wed, May 31, 2017 at 1:50 AM, James MacWhyte <macwhyte at gmail.com> wrote:\n>\n>>\n>>  The 1MB classic block size prevents quadratic hashing\n>> problems from being any worse than they are today.\n>>\n>\n> Add a transaction-size limit of, say, 10kb and the quadratic hashing problem\n> is a non-issue. Donezo.\n\nWhy is it https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661\nnot enough at this point?\nWhy the need for a transaction size limit?"
            },
            {
                "author": "Luke Dashjr",
                "date": "2017-05-31T04:14:25",
                "message_text_only": "On Wednesday 31 May 2017 1:22:44 AM Jorge Tim\u00f3n via bitcoin-dev wrote:\n> Why is it\n> https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1661\n> not enough at this point?\n> Why the need for a transaction size limit?\n\nBecause the bottleneck is hashing the transaction, which costs (in CPU time) \nbased on its size. Maybe it would make sense to factor sigops into the limit, \nthough?\n\nOn Wednesday 31 May 2017 1:09:26 AM Jean-Paul Kogelman via bitcoin-dev wrote:\n> On May 30, 2017, at 4:50 PM, James MacWhyte wrote:\n> > Add a transaction-size limit of, say, 10kb and the quadratic hashing\n> > problem is a non-issue. Donezo.\n>\n> That would invalidate any pre-signed transactions that are currently out\n> there. You can't just change the rules out from under people.\n\nMake it 100kB and I think we'd be okay. Those have always been policy-\nforbidden so there should be no expectation they'd be acceptable in the \nfuture.\n\nWhile we're at it, I suggest also specifying a minimum transaction size as \nwell. The raw minimum possible is 60 bytes, but any sane output would need at \nleast a hash, so I'd say make the minimum be 8 (60 + 160-bit hash) bytes?\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "Hypothetical 2 MB hardfork to follow BIP148",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jean-Paul Kogelman",
                "Jorge Tim\u00f3n",
                "Luke Dashjr",
                "Erik Aronesty",
                "James MacWhyte",
                "Mark Friedenbach",
                "Jacob Eliosoff"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 33070
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: Re:  Drivechain -- Request for Discussion",
        "thread_messages": [
            {
                "author": "Paul Sztorc",
                "date": "2017-05-24T13:43:49",
                "message_text_only": "Responses below.\n\n\nOn 5/23/2017 7:26 PM, ZmnSCPxj wrote:\n> Good morning,\n> \n> \n>>>\n>>> How is OP_BRIBE superior to just using a <h*> OP_RETURN script? Cannot\n>>> a sidechain scan the block for OP_RETURN attesting that the block hash\n>>> is present in the block?\n>>\n>>The sidechain software can indeed, but the mainchain software cannot\n>>(without making validation of both chains part of the mainchain, which\n>>defeats the original purpose of sidechains).\n>>\n>>The purpose of OP_BRIBE is to allow \"Sam\" (on the sidechain) and \"Mary\"\n>>(a mainchain miner) to work together. Sam would pay X BTC to Mary, if\n>>Mary could provide Sam with some guarantee that Sam's sidechain block\n>>[defined by h*] would make it into the largest chain.\n> \n> Regarding \"largest chain\", do you mean mainchain or sidechain?\n\nSidechain. Sam is paying himself the revenues of the sidechain's block.\nThese are side:btc, that he gets, if this block is part of the largest\nchain.\n> \n> An OP_RETURN is still some guarantee that it will make it into the\n> longest mainchain.  If OP_RETURN tx is in a shorter mainchain but not on\n> the longer mainchain, then on the longer mainchain, the utxo's funding\n> the OP_RETURN tx is still unspent and the OP_RETURN tx will still be\n> mineable by any miner following the longer mainchain.  The X BTC would\n> be the OP_RETURN transaction's fee, which Mary would still want to mine\n> into the longest mainchain, as it is still money on the table if it is\n> not mined on the longest mainchain.\n\nAs you say below, it is about the sidechain, not mainchain. (Anything\nnot in the longest mainchain is just discarded by everyone, as always.)\n> \n> Or, does OP_BRIBE somehow assure that Sam's block goes onto the longer\n> sidechain?  But then, do not side blocks refer to their previous side\n> block to define the sidechain?\n\nYes, there is a new construction for this, which might be called \"SPV\nsquared\". Classical merged mining (ie Namecoin) does not require the\nmainchain to do anything, except occasionally keep track of an ordered\nlist of hash commitments. BMM is different, it does require the\nmainchain to keep track of a minimal amount of things. One is the total\nnumber of sidechains, but the second is what you have hit on here.\n\nIn addition to a list of commitments (ideally, one commitment per\nblock), the mainchain also keeps track of the block number ( ..or, as\nyou'll see, perhaps \"block number modulo x\".. ) of recent sidechain\nblocks (for the last x=65,536 mainchain blocks). It then subsets the\nmost recent y=4000 of these, and only allows new sidechain blocks to\nappear if they have a blocknumber equal to a member of set Y', where Y'\nis the set of all sidechain blocknumbers y blocks ago + 1.\n\nThen, the sidechain nodes simply reject the block if the h* commitment\nrefers to a side:blockheader that has a different block number.\n\nPerhaps these notes..\n\nhttp://www.truthcoin.info/images/bmm-outline.txt\n\n..would be helpful. Looking back, this is probably the hackiest part of\nthe entire system, by a wide margin, so it is good that you bring it up.\n\n> \n> \n> Is there some predictable schedule for side->main withdrawals?  If a\n> withdrawal is imminent, or if some actor can get \"insider information\"\n> about whether a withdrawal is imminent, cannot some actor induce the\n> above, with potentially shorter time to reach step 3?\n\nYes, these delays are parameters, which are defined per sidechain. So\nonce the sidechain has been 'added' to bitcoin, the schedule would be\nfully predictable.\n\n> \n> From my reading, Blockstream's sidechains proposal supports a reorg\n> proof after a side->main withdrawal on the mainchain side, with a reorg\n> proof burn window after the main:side->main withdrawal, preventing its\n> utxo from being used.  If the reorg proof is published and shows that a\n> sidechain reorg invalidates a particular side->main withdrawal, then the\n> main:side->main withdrawal's utxo is burned.\n\nIn this, there is no reorg proof (the miners would simply prevent the\nwithdrawal from accumulating enough ACKs). A 51% miner coalition can\nalways filter any message they like from the blockchain, including the\nreorg proofs.\n\n> \n>>For extraordinary DAO-like situations, disinterested mainchain miners\n>>merely need a single bit of information (per sidechain), which is\n>>\"distress=true\", and indicates to them to temporarily stop ACKing\n>>withdrawals from the sidechain. This alone is enough to give the reorg\n>>an unlimited amount of time to work itself out.\n> \n> Do you have some document containing these details?  I cannot find this\n> in the blog posts I've read so far.\n\nThis specific detail is not documented. I feel it is comparable to, for\nexample, the March 2013 chain fork.\n\n> \n>>>>I feel that my proposal is more secure, as it can operate healthily and\n>>> quickly while using spv proofs which are much slower and much much\n>>> easier to audit.\n>>>\n>>> I don't quite understand how Drivechain handles sidechain reorgs, while\n>>> keeping Bitcoin miners blinded. It seems sidechains need to be known\n>>> (\"seen\") by the miner, so I don't see what is being blinded by blinded\n>>> merge mining.\n>>\n>>Mainchain miners do need to maintain some data about the sidechains, but\n>>this is very minimal, and certainly does not include the transaction\n>>data (or arbitrary messages) of the sidechain.\n> \n> As above, do you have document containing what data mainchain needs to\n> track?\n\nYes, I think the notes (above) may be helpful.\n\n> \n>>>>>Blind merged mining seems strictly inferior ... a rich attacker can\n>>> simply reorg the sidechain outright without playing such games.\n>>>>\n>>>>In the future, when there is no block subsidy, a rich attacker can also\n>>> do that in mainchain Bitcoin.\n>>>\n>>> I see. However, block subsidies will drop far in the future, do you\n>>> mean to say, that sidechains will be used only in the far future?\n>>\n>>In one sense, I mean \"you have already endorsed this 'fees only will\n>>work' premise, by endorsing Bitcoin\".\n> \n> I endorse this on the basis of Greg Maxwell's analysis that a block size\n> limit is necessary to have a fee market.\n\nEven were that the case, the limit does not need to be imposed by nodes.\nMiners are likely to self-impose a limit, on nodes and each other, in\norder to maximize their total revenues. In fact they will eventually be\nrequired to do so (even though they do not now, beyond the naive\nmaximization of imposing minimum tx fee requirements).\n\nIn fact, in that case, the larger the range of possible blocksizes, the\ngreater the ability of miners to extract fees from users -- ie the less\nlimited the blocksize, the more hashpower security.\n\nSimply, if revenue = R = f(demand, supply), and miners choose the supply\nwhich argmax R , then R can only go down as supply is constrained.\n\nAnd, the effect is even more beneficial to security than _that_ ...if\nthe sidechains are different from each other, such that blockspace in\none chain is _not_ a perfect substitute for blockspace in another. In\nthis case miners can choke up on some (or each) individual S_i, forcing\nsum(R_i) to go even higher.\n\n\n> \n> \n>>That mechanism is enforced by drivechain itself, not OP_BRIBE. (OP Bribe\n>>is itself only ~half of BMM. I admit it is getting a little confusing.)\n> \n> Can you provide the details of this mechanism?  For example, does h*\n> actually include some information identifying the sidechain and OP_BRIBE\n> is supposed to do some additional checking not shown in your current\n> code, or ....?\n\nYes. Yes.\n\nThis is what we nicknamed the \"ratchet\", I cannot easily check the code\nright now but will get back to you.\n\nhttps://github.com/drivechain-project/bitcoin/commit/c4fe067e298f57252789c28161272db3d7483dca#diff-be5f6bb690c9898e44cbd7e78c465e43R83\n\n\n\n> \n>>Drivechain requires a soft fork to add each new sidechain\n> \n> Oh.\n> \n> My understanding is that with Blockstream's zk-SNARKs, a new sidechain\n> would not require a soft fork at all (or even miner voting on the\n> validity of WT^: the validity of side:side->main transactions is assured\n> by proof that the zk-SNARK checking that transaction was executed\n> correctly, and the lack of a reorg proof during the burn window after\n> the main:side->main).\n> \n> Is your model then, that each sidechain maintainer has to maintain a\n> patchset or some plugin system to Core?  And miners who want to support\n> particular sidechains to modify their software, applying the patch for\n> each sidechain they want to support?\n\nNot necessarily, but I think \"plugins\" are a good metaphor.\n\n> \n> It seems this is somewhat brittle and may cause sidechain coding\n> problems to leak into mainchain.\n> \n> I think, it is much less interesting to have to softfork in every\n> sidechain, rather than to support a general mechanism (zk-SNARK) to\n> allow sidechains to be launched without any modification to Core code.\n> \n\nI completely disagree. Unrestrained smart contract execution will be the\ndeath of most of the interesting applications of sidechains, and would\nprobably destabilize Bitcoin itself.\n\nI would be as if your body \"added\" the ability to synthesize any\nprotein, including prions. Then you make one prion and your entire body\ndies.\n\nI thought this would come up, I have a presentation on this:\nhttps://www.youtube.com/watch?v=xGu0o8HH10U&list=PLw8-6ARlyVciMH79ZyLOpImsMug3LgNc4&index=1\n\nYou don't need to watch the whole thing, maybe just parts 1 and 5.\n\n> \n>>. It requires\n>>this literally for a few good reasons...but the best is: there is an\n>>implicit requirement that the miners not steal from the sidechain\n>>anyway. In this way drivechain knows how to keep track of what it should\n>>expect.\n> \n> It seems to be, more of \"completely sighted merged mining\" than \"blind\n> merge mining\".\n\nYou can call it microscope mining if you like..it attempts to address\nthe concerns that were raised earlier in the peer review process.\n\n> \n> \n> \n>>> Perhaps the datacenter point is simply that your proposal suggests to\n>>> reduce the size of the datacenter by removing surge suppressors and\n>>> UPS's, to avoid some definition of \"datacenter is a room with >$XXX of\n>>> equipment\".\n>>\n>>I hope that my replies above already help with these. If not, let me know.\n> \n> I find this point now moot, as drivechains require a softfork for each\n> sidechain, and the size of the datacenter is pointless if there is some\n> need to softfork in every sidechain.\n\nYou might be confused...miners can soft fork in a sidechain that they\nhave *no* intention of merged mining, or BMM ing. I do not know why, as\nthey would be leaving money on the table, but it is possible. Perhaps\nonly 5% of miners want to bother with it. The point is that the other\n90% hashpower has no inherent reason *not* to allow that the experiment\nbe run.\n\n> \n> Regards,\n> ZmnXCPxj"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Re:  Drivechain -- Request for Discussion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Paul Sztorc"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 10760
        }
    },
    {
        "title": "[bitcoin-dev] Suggested changes to bip8",
        "thread_messages": [
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2017-05-25T19:53:29",
                "message_text_only": "Hi, I didn't want to comment on\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013643.html\nbecause it seemed to me that thread was more broad.\n\nI like bip8 very much as an extension to bip9, but I think it could be better.\nWith bip9, a bip9-ready node that sees a softfork activated that he is\nnot aware of will see a warning. See the implementation:\n\nhttps://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L1832\n\nBut with bip8, if a deployment is made at the end of the period\ninstead of through 95% signaling, nodes that implement bip8 but don't\nimplement a certain deployment that is activated can't receive such a\nwarning.\n\nThe solution that comes to mind is to reserve one of the nVersion for\nthe specific purpose of requiring that the bit is active for one block\nwhen a deployment is locked in in this way (or maybe also when it's\nactivated with miners' signaling too, maybe that can be used to\nsimplify the way the current warnings are checked).\n\nI expect the code changes to do this to be simple, and I'm happy to\nhelp with it."
            }
        ],
        "thread_summary": {
            "title": "Suggested changes to bip8",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jorge Tim\u00f3n"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1069
        }
    },
    {
        "title": "[bitcoin-dev] Emergency Deployment of SegWit as a partial mitigation of CVE-2017-9230",
        "thread_messages": [
            {
                "author": "Cameron Garnham",
                "date": "2017-05-26T06:30:08",
                "message_text_only": "Hello Bitcoin-Dev,\n\nCVE-2017-9230 (1) (2), or commonly known as \u2018ASICBOOST\u2019 is a severe (3) (4) and actively exploited (5) security vulnerability.\n \nTo learn more about this vulnerability please read Jeremy Rubin\u2019s detailed report:\nhttp://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n \nAndreas Antonopoulos has an excellent presentation on why asicboost is dangerous:\nhttps://www.youtube.com/watch?v=t6jJDD2Aj8k\n\nIn decisions on the #bitcoin-core-dev IRC channel; It was proposed, without negative feedback, that SegWit be used as a partial-mitigation of CVE-2017-9230.\n\nSegWit partially mitigates asicboost with the common reasonable assumption that any block that doesn\u2019t include a witness commit in it's coinbase transaction was mined using covert asicboost.  Making the use of covert asicboost far more conspicuous.\n\nIt was also proposed that this partial mitigation should be quickly strengthened via another soft-fork that makes the inclusion of witness commits mandatory, without negative feedback.\n\nThe security trade-offs of deploying a partial-mitigation to CVE-2017-9230 quickly vs more slowly but more conservatively is under intense debate.  The author of this post has a strong preference to the swiftest viable option.\n\nCameron.\n\n\n(1) CVE Entry:\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230\n\n(2) Announcement of CVE to Mailing List:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.html\n\n(3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:\n https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html\n\n(4) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:\n https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html\n\n(5) Evidence of Active Exploit by Gregory Maxwell:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html"
            },
            {
                "author": "Andreas M. Antonopoulos",
                "date": "2017-05-26T06:52:26",
                "message_text_only": "I rarely post here, out of respect to the mailing list. But since my name\nwas mentioned...\n\nI much prefer Gregory Maxwell's proposal to defuse covert ASICBOOST (only)\nwith a segwit-like commitment to the coinbase which does not obligate\nminers to signal Segwit or implement Segwit, thus disarming any suspicion\nthat the issue is being exploited only to activate Segwit.\n\nThis proposal is unnecessarily conflating two contentious issues and will\nattract criticism of self serving motivation.\n\nPoliticising CVE  is damaging to the long term bitcoin development and to\nits security. Not claiming that is the intent here, but the damage is done\nby the mere appearance of motive.\n\n\n\nOn May 26, 2017 16:30, \"Cameron Garnham via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Bitcoin-Dev,\n>\n> CVE-2017-9230 (1) (2), or commonly known as \u2018ASICBOOST\u2019 is a severe (3)\n> (4) and actively exploited (5) security vulnerability.\n>\n> To learn more about this vulnerability please read Jeremy Rubin\u2019s detailed\n> report:\n> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n>\n> Andreas Antonopoulos has an excellent presentation on why asicboost is\n> dangerous:\n> https://www.youtube.com/watch?v=t6jJDD2Aj8k\n>\n> In decisions on the #bitcoin-core-dev IRC channel; It was proposed,\n> without negative feedback, that SegWit be used as a partial-mitigation of\n> CVE-2017-9230.\n>\n> SegWit partially mitigates asicboost with the common reasonable assumption\n> that any block that doesn\u2019t include a witness commit in it's coinbase\n> transaction was mined using covert asicboost.  Making the use of covert\n> asicboost far more conspicuous.\n>\n> It was also proposed that this partial mitigation should be quickly\n> strengthened via another soft-fork that makes the inclusion of witness\n> commits mandatory, without negative feedback.\n>\n> The security trade-offs of deploying a partial-mitigation to CVE-2017-9230\n> quickly vs more slowly but more conservatively is under intense debate.\n> The author of this post has a strong preference to the swiftest viable\n> option.\n>\n> Cameron.\n>\n>\n> (1) CVE Entry:\n> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230\n>\n> (2) Announcement of CVE to Mailing List:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-May/014416.html\n>\n> (3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan\n> Grant:\n>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-May/014352.html\n>\n> (4) Discussion of ASICBOOST's non-independent PoW calculation by Tier\n> Nolan:\n>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-May/014351.html\n>\n> (5) Evidence of Active Exploit by Gregory Maxwell:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-April/013996.html\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/36b6ccb4/attachment.html>"
            },
            {
                "author": "Cameron Garnham",
                "date": "2017-05-26T08:02:27",
                "message_text_only": "Thank you for your reply Andreas,\n\nI can assure you that I have many motivations for activating SegWit.\n\nBefore studding ASICBOOST I wanted to activate SegWit as it is a wonderful upgrade for Bitcoin. It seems to me that virtually the entire Bitcoin Ecosystem agrees with me.  Except for around 67% of the mining hash-rate who very conspicuously refuse to signal for it\u2019s activation. \n\nSo, I started searching for the motivations of such a large amount of the mining hash-rate holding a position that isn\u2019t at-all represented in the wider Bitcoin Community. My study of ASICBOOST lead to a \u2018bingo\u2019 moment:  If one assumes that the 67% of the hash rate that refuse to signal for SegWit are using ASICBOOST. The entire picture of this political stalemate became much more understandable.\n\nThis only strengthened my resolve to activate SegWit: not only is SegWit great, it partially mitigates a very serious security vulnerability.\n\nThis is why I call into question why you would suggest:\n\n\u201cThis proposal is unnecessarily conflating two contentious issues and will attract criticism of self serving motivation.\u201d\n\n1. I am not conflating the issues.  I would argue that very fact that SegWit has not been activated yet is directly because of CVE-2017-9230.\n2. I have no reason to believe that SegWit is contentious, except for the attackers who it would frustrate.\n3. I have no negative responses to my endeavours to get ASICBOOST as regarded as a legitimate security vulnerability.  This would suggest that it is not contentious in the wider technical community.\n\nIf SegWit is NOT contentious within the technical community and it is NOT contentious to regard CVE-2017-9230 as a credible security vulnerability. Then using it as partial security fix for a security vulnerability SHOULD NOT be contentious.\n\nIf you believe that SegWit is contentious within the technical community.  Or you believe CVE-2017-9230 should not be regarded as a credible security vulnerability. Then I would logically agree with you that we should separate the issues so that we may gain consensus. However, I just don\u2019t see this as the case.\n\nCameron.\n\n\n> On 26 May 2017, at 09:52 , Andreas M. Antonopoulos <andreas at antonopoulos.com> wrote:\n> \n> I rarely post here, out of respect to the mailing list. But since my name was mentioned... \n> \n> I much prefer Gregory Maxwell's proposal to defuse covert ASICBOOST (only) with a segwit-like commitment to the coinbase which does not obligate miners to signal Segwit or implement Segwit, thus disarming any suspicion that the issue is being exploited only to activate Segwit.\n> \n> This proposal is unnecessarily conflating two contentious issues and will attract criticism of self serving motivation.\n> \n> Politicising CVE  is damaging to the long term bitcoin development and to its security. Not claiming that is the intent here, but the damage is done by the mere appearance of motive. \n> \n> \n> \n> On May 26, 2017 16:30, \"Cameron Garnham via bitcoin-dev\" <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hello Bitcoin-Dev,\n> \n> CVE-2017-9230 (1) (2), or commonly known as \u2018ASICBOOST\u2019 is a severe (3) (4) and actively exploited (5) security vulnerability.\n> \n> To learn more about this vulnerability please read Jeremy Rubin\u2019s detailed report:\n> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n> \n> Andreas Antonopoulos has an excellent presentation on why asicboost is dangerous:\n> https://www.youtube.com/watch?v=t6jJDD2Aj8k\n> \n> In decisions on the #bitcoin-core-dev IRC channel; It was proposed, without negative feedback, that SegWit be used as a partial-mitigation of CVE-2017-9230.\n> \n> SegWit partially mitigates asicboost with the common reasonable assumption that any block that doesn\u2019t include a witness commit in it's coinbase transaction was mined using covert asicboost.  Making the use of covert asicboost far more conspicuous.\n> \n> It was also proposed that this partial mitigation should be quickly strengthened via another soft-fork that makes the inclusion of witness commits mandatory, without negative feedback.\n> \n> The security trade-offs of deploying a partial-mitigation to CVE-2017-9230 quickly vs more slowly but more conservatively is under intense debate.  The author of this post has a strong preference to the swiftest viable option.\n> \n> Cameron.\n> \n> \n> (1) CVE Entry:\n> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230\n> \n> (2) Announcement of CVE to Mailing List:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.html\n> \n> (3) Discussion of the perverse incentives created by 'ASICBOOST' by Ryan Grant:\n>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.html\n> \n> (4) Discussion of ASICBOOST's non-independent PoW calculation by Tier Nolan:\n>  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.html\n> \n> (5) Evidence of Active Exploit by Gregory Maxwell:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013996.html\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-26T08:15:56",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nHi Cameron,\n\nPresumably the \"very serious security vulnerability\" posed is one of\nincreased centralization of hash power. Would this danger exist\nwithout the patent risk?\n\ne\n\nOn 05/26/2017 01:02 AM, Cameron Garnham via bitcoin-dev wrote:\n> Thank you for your reply Andreas,\n> \n> I can assure you that I have many motivations for activating\n> SegWit.\n> \n> Before studding ASICBOOST I wanted to activate SegWit as it is a\nwonderful upgrade for Bitcoin. It seems to me that virtually the\nentire Bitcoin Ecosystem agrees with me.  Except for around 67% of the\nmining hash-rate who very conspicuously refuse to signal for it\u2019s\nactivation.\n> \n> So, I started searching for the motivations of such a large amount\nof the mining hash-rate holding a position that isn\u2019t at-all\nrepresented in the wider Bitcoin Community. My study of ASICBOOST lead\nto a \u2018bingo\u2019 moment:  If one assumes that the 67% of the hash rate\nthat refuse to signal for SegWit are using ASICBOOST. The entire\npicture of this political stalemate became much more understandable.\n> \n> This only strengthened my resolve to activate SegWit: not only is\nSegWit great, it partially mitigates a very serious security\nvulnerability.\n> \n> This is why I call into question why you would suggest:\n> \n> \u201cThis proposal is unnecessarily conflating two contentious issues\nand will attract criticism of self serving motivation.\u201d\n> \n> 1. I am not conflating the issues.  I would argue that very fact\nthat SegWit has not been activated yet is directly because of\nCVE-2017-9230.\n> 2. I have no reason to believe that SegWit is contentious, except\nfor the attackers who it would frustrate.\n> 3. I have no negative responses to my endeavours to get ASICBOOST\n> as\nregarded as a legitimate security vulnerability.  This would suggest\nthat it is not contentious in the wider technical community.\n> \n> If SegWit is NOT contentious within the technical community and it\nis NOT contentious to regard CVE-2017-9230 as a credible security\nvulnerability. Then using it as partial security fix for a security\nvulnerability SHOULD NOT be contentious.\n> \n> If you believe that SegWit is contentious within the technical\ncommunity.  Or you believe CVE-2017-9230 should not be regarded as a\ncredible security vulnerability. Then I would logically agree with you\nthat we should separate the issues so that we may gain consensus.\nHowever, I just don\u2019t see this as the case.\n> \n> Cameron.\n> \n> \n>> On 26 May 2017, at 09:52 , Andreas M. Antonopoulos\n<andreas at antonopoulos.com> wrote:\n>> \n>> I rarely post here, out of respect to the mailing list. But\n>> since\nmy name was mentioned...\n>> \n>> I much prefer Gregory Maxwell's proposal to defuse covert\n>> ASICBOOST\n(only) with a segwit-like commitment to the coinbase which does not\nobligate miners to signal Segwit or implement Segwit, thus disarming\nany suspicion that the issue is being exploited only to activate Segwit.\n>> \n>> This proposal is unnecessarily conflating two contentious issues\nand will attract criticism of self serving motivation.\n>> \n>> Politicising CVE  is damaging to the long term bitcoin\n>> development\nand to its security. Not claiming that is the intent here, but the\ndamage is done by the mere appearance of motive.\n>> \n>> \n>> \n>> On May 26, 2017 16:30, \"Cameron Garnham via bitcoin-dev\"\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Hello Bitcoin-Dev,\n>> \n>> CVE-2017-9230 (1) (2), or commonly known as \u2018ASICBOOST\u2019 is a\n>> severe\n(3) (4) and actively exploited (5) security vulnerability.\n>> \n>> To learn more about this vulnerability please read Jeremy\n>> Rubin\u2019s\ndetailed report:\n>> http://www.mit.edu/~jlrubin//public/pdfs/Asicboost.pdf\n>> \n>> Andreas Antonopoulos has an excellent presentation on why\n>> asicboost\nis dangerous:\n>> https://www.youtube.com/watch?v=t6jJDD2Aj8k\n>> \n>> In decisions on the #bitcoin-core-dev IRC channel; It was\n>> proposed,\nwithout negative feedback, that SegWit be used as a partial-mitigation\nof CVE-2017-9230.\n>> \n>> SegWit partially mitigates asicboost with the common reasonable\nassumption that any block that doesn\u2019t include a witness commit in\nit's coinbase transaction was mined using covert asicboost.  Making\nthe use of covert asicboost far more conspicuous.\n>> \n>> It was also proposed that this partial mitigation should be\n>> quickly\nstrengthened via another soft-fork that makes the inclusion of witness\ncommits mandatory, without negative feedback.\n>> \n>> The security trade-offs of deploying a partial-mitigation to\nCVE-2017-9230 quickly vs more slowly but more conservatively is under\nintense debate.  The author of this post has a strong preference to\nthe swiftest viable option.\n>> \n>> Cameron.\n>> \n>> \n>> (1) CVE Entry: \n>> https://cve.mitre.org/cgi-bin/cvename.cgi?name=+CVE-2017-9230\n>> \n>> (2) Announcement of CVE to Mailing List:\n>> \nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014416.\nhtml\n>> \n>> (3) Discussion of the perverse incentives created by 'ASICBOOST'\n>> by\nRyan Grant:\n>> \nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014352.\nhtml\n>> \n>> (4) Discussion of ASICBOOST's non-independent PoW calculation by\nTier Nolan:\n>> \nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014351.\nhtml\n>> \n>> (5) Evidence of Active Exploit by Gregory Maxwell:\n>> \nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/01399\n6.html\n\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZJ+Q1AAoJEDzYwH8LXOFOqakH/R1YCifIGjV07vnnsxeC/77x\nd6w5tBmtEd5MLzrX/6VtMoI8UzgLEcDM1WfFox3jDVz/HurkTVorliyJrr14BVsc\nrL2nTbfychYh1rAdTIsNwFt15Wgjcp/5eAq7Lw5TM5OJ3YbPn2zWJY19QmjEAJ+M\nkGz26R+IJL1095yed5RN2JoN8O9x+HVdtIjaHJJRJzLsy+3g22zMWgN1nZN0olhX\nmFQJZbvS0gQyiRGJmNku3zP5Qg2cFzWt+VBtFrzNu1QTTkbK2e1owHOmpgfygTD3\ng3F4VoDfyA7pBnpMMMjjTaCaG34Am3CvYu8iYnZXy85s2ZjC+XeKgqMkBLj4+q8=\n=A3ne\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Cameron Garnham",
                "date": "2017-05-26T19:20:42",
                "message_text_only": "Hello Eric,\n\nThank you for your question and your time off-list clarifying your position. I\u2019m posting to the list so that a wider audience may benefit.\n\nOriginal Question: \u2018Presumably the \"very serious security vulnerability\" posed is one of increased centralization of hash power. Would this danger exist without the patent risk?\u2019\n\nI would postulate that if ASICBOOST was originally released without the patent risk, then much of the risk would have been avoided; all of the mining manufactures would have implemented ASICBOOST and had a similar advantage. However, now time has passed and the damage of the patent monopoly exploiting CVE-2017-9230 has been already done. If the ASICBOOST patent was released to the public for free today, while a good thing, it wouldn\u2019t soften the severity of the vulnerability we face today.\n\nThe ASICBOOST PATENT provides a miner with a constant-factor advantage. This is a huge problem with zero-sum games, such as mining. In game-theory, a constant factor advantage gives an exponential advantage over the time period maintained.\n\nThis explains why the Bitcoin Community initially took very little notice to ASICBOOST: The effects of ASICBOOST stated at virtually nothing, and it took a while for the advantage to been seen over the normal variance of mining. However, it\u2019s influence has been exponentially growing since then: creating an emergency problem that we now face.\n\nThe result of ASICBOOST going unchecked is that very quickly from now, surprisingly quickly, the only profitable miners will be the miners who make use of ASICBOOST.  This is a grave concern.\n\nI will again reiterate that the virtue-signalling over perceived political motivations is ridiculous in the light what I consider a looming catastrophe, we should be judging by what is real not just perceived.\n\nThe catastrophe that I fear is one company (or a single politically connected group) gaining a virtual complete monopoly of Bitcoin Mining. This is more important to me than avoiding chain-splits.  Without a well-distributed set of miners Bitcoin isn\u2019t Bitcoin.\n\nCameron.\n\n\nPS.\n\nThis attack is part of a larger set of licensing attacks, where patens are just one form of licensing attack. These attacks are particularly damaging in competitive markets such as mining. We should be vigilant for other attempts to create state-enforced licensing around mathematical algorithms.  ASICBOOST is an illustrative example of what the Bitcoin Community needs to defend against.\n\n\n\n> On 26 May 2017, at 11:15 , Eric Voskuil <eric at voskuil.org> wrote:\n> \n> Signed PGP part\n> Hi Cameron,\n> \n> Presumably the \"very serious security vulnerability\" posed is one of\n> increased centralization of hash power. Would this danger exist\n> without the patent risk?\n> \n> e\n>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-26T09:21:55",
                "message_text_only": "On Friday, 26 May 2017 10:02:27 CEST Cameron Garnham via bitcoin-dev wrote:\n> So, I started searching for the motivations of such a large amount of the\n> mining hash-rate holding a position that isn\u2019t at-all represented in the\n> wider Bitcoin Community. My study of ASICBOOST lead to a \u2018bingo\u2019 moment: \n> If one assumes that the 67% of the hash rate that refuse to signal for\n> SegWit are using ASICBOOST. The entire picture of this political\n> stalemate became much more understandable.\n\nI\u2019m uncomfortable with your \u201cbingo\u201d moment, and your huge assumption to get \nto make it fit.\nThe reality is that we have seen repeatedly that the miners are stating they \nare Ok with an ASICBOOST disabling change.\nThe larger mining industry has just this week come to consensus about a \nbetter way to activate SegWit! Referring to the New York consensus meeting!!\nhttps://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77\n\nI question your conclusions of miners not supporting SegWit because of \nASICBOOST, the evidence shows this accusation to be false.\n\nYou openly admitting here that you use ASICBOOST as a tool to push SegWit is \nfurther making me uncomfortable. Your intention may be pure, but the methods \nare not.\nAnd on that I agree with Andreas, that taints this proposal.\n\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-26T14:39:30",
                "message_text_only": "Linking a bit4 MASF with a bit4 \"lock in of a hard fork in 6 months\" is\nsomething that will simply never happen for basic engineering reasons.\n\nSpoonet, an oft-quoted hard fork that actually has some strong support, is\na much better candidate for the code base - but not of the supposed\nsupporters of bit4 MASF seem to be ready to roll up their sleeves and do\nany work at all.   I mean, if they really had \"millions\" for development,\nthey could just hire dome developers and built it correctly, right?   But\nthey aren't ... instead they are pumping money into \"bcoin\", which doesn't\nyet have any of the protections needed to get consensus.   Maybe it will\nsome day.\n\nClaiming that miners support segwit is disingenuous ... considering that if\nthey supported it, they would be signaling for it today... instead of\ndistracting the community with fake proposals that have no peer-reviewed\ncode.\n\n\nOn Fri, May 26, 2017 at 5:21 AM, Tom Zander via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Friday, 26 May 2017 10:02:27 CEST Cameron Garnham via bitcoin-dev wrote:\n> > So, I started searching for the motivations of such a large amount of the\n> > mining hash-rate holding a position that isn\u2019t at-all represented in the\n> > wider Bitcoin Community. My study of ASICBOOST lead to a \u2018bingo\u2019 moment:\n> > If one assumes that the 67% of the hash rate that refuse to signal for\n> > SegWit are using ASICBOOST. The entire picture of this political\n> > stalemate became much more understandable.\n>\n> I\u2019m uncomfortable with your \u201cbingo\u201d moment, and your huge assumption to get\n> to make it fit.\n> The reality is that we have seen repeatedly that the miners are stating\n> they\n> are Ok with an ASICBOOST disabling change.\n> The larger mining industry has just this week come to consensus about a\n> better way to activate SegWit! Referring to the New York consensus\n> meeting!!\n> https://medium.com/@DCGco/bitcoin-scaling-agreement-at-\n> consensus-2017-133521fe9a77\n>\n> I question your conclusions of miners not supporting SegWit because of\n> ASICBOOST, the evidence shows this accusation to be false.\n>\n> You openly admitting here that you use ASICBOOST as a tool to push SegWit\n> is\n> further making me uncomfortable. Your intention may be pure, but the\n> methods\n> are not.\n> And on that I agree with Andreas, that taints this proposal.\n>\n> --\n> Tom Zander\n> Blog: https://zander.github.io\n> Vlog: https://vimeo.com/channels/tomscryptochannel\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170526/848dfb63/attachment.html>"
            },
            {
                "author": "Tom Zander",
                "date": "2017-05-26T14:54:03",
                "message_text_only": "On Friday, 26 May 2017 16:39:30 CEST Erik Aronesty wrote:\n> Linking a bit4 MASF with a bit4 \"lock in of a hard fork in 6 months\" is\n> something that will simply never happen for basic engineering reasons.\n\nThe modifications to Bitcoin Core would take at most a day to do, plus a week \nto test.\nI\u2019m not very happy with the full compromise myself, but can we please not \nstomp on actual progress with nebulous problems?\nI mean, you want SegWit, right?\n\n> Claiming that miners support segwit is disingenuous ... considering that\n> if they supported it, they would be signaling for it today... instead of\n> distracting the community with fake proposals that have no peer-reviewed\n> code.\n\nThe nature of a compromise like the one that happened in New York is that \nboth parties do something they are not the most happy with in exchange for \nthe thing they want.\nMiners have agreed to the SegWit part of this compromise. Calling that \ndisingenuous is not helpful...\n-- \nTom Zander\nBlog: https://zander.github.io\nVlog: https://vimeo.com/channels/tomscryptochannel"
            },
            {
                "author": "Anthony Towns",
                "date": "2017-05-27T06:37:26",
                "message_text_only": "On Fri, May 26, 2017 at 11:02:27AM +0300, Cameron Garnham via bitcoin-dev wrote:\n> If one assumes that the 67% of the hash rate that refuse to signal\n> for SegWit are using ASICBOOST. The entire picture of this political\n> stalemate became much more understandable.\n\nA couple of bits of math that might be of interest:\n\n * if 67% of the hash rate is running ASICBoost, and ASICBoost gives a\n   20% performance improvement as stated on asicboost.com and in\n   Greg's BIP proposal, then blocking ASICBoost would change the\n   balance of miners from 67%/33% to 62.8%/37.2%; resulting in a 6.3%\n   loss for income for ASICBoost miners (not 20%), and a 12.7% gain for\n   non-ASICBoost miners.  In this case, total apparent hashrate reduces\n   to 88.8% of what it originally was when ASICBoost is blocked (though\n   the actual security either stays the same or increases, depending on\n   your attack model) [0]\n\n * if ASICBoost use is lower than that, say 33% (eg made up of\n   AntPool 18%, BTC.top 10%, ViaBTC 5%), then the shift is from 33%/67%\n   to 29.1%/70.9%, and results in a 13% loss for ASICBoost miners,\n   versus a 6% gain for non-ASICBoost miners. In these cases, a price\n   rise in the region of 7% to 15% due to blocking ASICBoost would be\n   enough to make everyone better off [1].\n\n * AIUI there are three feasible ways of doing ASICBoost: overt via\n   the version field, semi-covert via mining an empty block and grinding\n   the coinbase extra nonce, and fully covert by reordering the block\n   transaction merkle tree. If the fully covert method is made infeasible\n   via a secondary merkle commitment in the coinbase a la segwit, and for\n   whatever reason overt ASICBoost isn't used, then empty block mining is\n   still plausible, though presumably becomes unprofitable when the extra\n   20% of block subsidy is less than the fees for a block.  That's adds\n   up to fees per block totalling greater than 2.5BTC, and 2.5BTC/1MB is\n   250 satoshis per byte, which actually seems to be where fees are these\n   days, so unless they're getting more than the claimed 20% benefit,\n   people mining empty blocks are already losing money compared to just\n   mining normally... (Of course, 250 satoshis per byte is already fairly\n   painful, and only gets more so as the price rises)\n\nPersonally, I expect any technical attempt to block ASICBoost use to fail\nor result in a chain split -- 67% of miners losing 6% of income is on\nthe order of $5M a month at current prices. Having an approach that is as\nsimple as possible (ie, independent from segwit, carefully targetted, and\nimpossible to oppose for any reason other than wanting to use ASICBoost)\nseems optimal to me, both in that it has the highest chance to succeed,\nand provides the most conclusive information if/when it fails.\n\nCheers,\naj\n\n[0] Assuming ASICBoost miners have hardware capable of doing A hashes with\n    ASICBoost turned off, or A*B (B=1.2) with ASICBoost turned on, and\n    the remainder of miners have a total hashrate of R. Then overall\n    hashrate is currently H=A*B+R, and ASICBoost hashrate is a = A*B/(A*B+R),\n    with a = 67% if the quoted claim is on the money. Rearranging:\n\n           a = A*B/(A*B+R)\n           a*(A*B+R) = A*B\n           a*A*B + a*R = A*B\n           a*R = (1-a)*A*B\n           R = (1/a-1)*A*B\n\n    So a' = A/(A+R), the ASICBoost miner's hashrate if they're forced to\n    turn ASICBoost off, is:\n\n           a' = A/(A+R)\n           a' = A/(A+(1/a-1)*A*B)\n              = 1/(1+(1/a-1)*B)\n\n    But if a=0.67 and B=1.2, then a' = 0.628.\n\n    The ratio of what they are getting to what they would getting is\n    just a/a',\n\n           a/a' = a*(1+(1/a-1)*B)\n                = (a+(1-a)*B)\n\n    and their loss is a/a'-1, which is:\n\n         a/a'-1 = (a+(1-a)*B) - 1\n                = (a+(1-a)*B) - (a+1-a)\n                = (1-a)*(B-1)\n\n    which is only 20% (B-1) when a is almost zero. When a increases (ie,\n    there is a higher percentage of ASICBoost miners, as sure seems to\n    be the case) the potential loss from disabling ASICBoost dwindles\n    to nothing (because 1-a goes to zero and B-1 is just a constant).\n\n    Note that this is the case even with mining centralisation -- if you\n    have 99% of the hashrate with ASICBoost, you'll still have 98.8% of\n    the hashrate without it, making a 0.2% loss (though of course your\n    competitors with 1% hashrate will go to 1.2%, making a 20% gain).\n    The reason is you're competing with all the ASICBoost miners,\n    *including your own*, for the next block, and the size of the reward\n    you'll get for winning doesn't change.\n\n    Total apparent hashrate is A+R versus A*B+R, so\n\n        (A+R)/(A*B+R) = 1/(A/(A+R)) * (A*B/(A*B+R))/B\n                      = 1/a' * a/B\n                      = a/a' / B\n                      = (a+(1-a)*B) / B\n                      = a/B + (1-a)\n\n    (yeah, so that formula's kind of obvious...)\n\n[1] Except maybe the patent holders (err, applicants). Though per the\n    recent open letter it doesn't seem like anyone's actually paying for\n    the patents in the first place. If miners were, then coordinated\n    disarmament might already be profitable; if you're paying say 10%\n    of your mining income in licensing fees or similar, that might seem\n    sensible in order to make 20% more profit; but if blocking everyone\n    from using ASICBoost would reduce your licensing fees by 10% of your\n    income, but only reduce your income by 6.3%, then that adds up to\n    a 3.7% gain and a bunch less hassle.\n\n    I think if the ASICBoost patent holders were able to charge perfectly\n    optimally, they'd charge royalty fees of about 8.3% of miner's\n    income (so ASICBoost miners would make 10% net, rather than 20%),\n    and allow no more than 50% of miners to use it (so the effective\n    ASICBoost hashrate would be about 55%). That way the decision to\n    block ASICBoost would be:\n\n        X * 1.2 * (1-0.083) / (0.5 * 1.2 + 0.5)  -- ASICBoost allowed\n      = X * 1.1004 / 1.1\n      > X\n    vs\n        X / (0.5 + 0.5) -- ASICBoost banned\n      = X\n\n    and ASICBoost wouldn't be disabled, but the patent holders would\n    still be receiving 4.15% (50%*8.3%) of all mining income. If more\n    than 50% of hashpower was boosted, the formula would change to, eg,\n\n        X * 1.2 * (1-0.083) / (0.51 * 1.2 + 0.49)\n      = X * 1.1004 / 1.102\n      < X\n\n    and similarly if the fee was slightly increased, and in that case all\n    miners would benefit from disabling ASICBoost. Around these figures\n    ASICBoost miners would only gain/lose very slightly from ASICBoost\n    getting blocked; the big losers would be the patent holders, who'd\n    go from raking in 4.15% of all mining income to nothing, and the\n    big winners would be the non-ASICBoost miners, who'd gain that 4.15%\n    of income. The possibility of transfer payments from non-ASICBoost\n    miners to ASICBoost miners to block ASICBoost might change that\n    equation, probably towards lower fees and higher hashrate.\n\n    For comparison, if 67% of hashrate is using ASICBoost, they can't\n    charge them all more than 5.5% of their mining income, or miners\n    would prefer to block ASICBoost, and that would only give the patent\n    holders 3.7% of all mining income, much less.\n\n    If patent holders can convince miners not to communicate with each\n    other so that they think that a smaller amount of hashpower is using\n    ASICBoost than actually is, that might also allow collecting more\n    royalties without risking collective action to block ASICBoost.\n\n    Of course, this is assuming they can charge all miners optimally\n    and no one infringes patents, and that if you're prevented from\n    using ASICBoost you don't have to keep paying royalties anyway,\n    and so on. Just completely realistic, plausible assumptions like that."
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-27T20:07:58",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nAnthony,\n\nFor the sake of argument:\n\n(1) What would the situation look like if there was no patent?\n\n(2) Would the same essential formulation exist if there had been a\npatent on bitcoin mining ASICs in general?\n\n(3) Would an unforeseen future patented mining optimization exhibit\nthe same characteristics?\n\n(4) Given that patent is a state grant of monopoly privilege, could a\nstate licensing regime for miners, applied in the same scope as a\npatent, but absent any patent, have the same effect?\n\ne\n\nOn 05/26/2017 11:37 PM, Anthony Towns via bitcoin-dev wrote:\n> On Fri, May 26, 2017 at 11:02:27AM +0300, Cameron Garnham via\n> bitcoin-dev wrote:\n>> If one assumes that the 67% of the hash rate that refuse to\n>> signal for SegWit are using ASICBOOST. The entire picture of this\n>> political stalemate became much more understandable.\n> \n> A couple of bits of math that might be of interest:\n> \n> * if 67% of the hash rate is running ASICBoost, and ASICBoost gives\n> a 20% performance improvement as stated on asicboost.com and in \n> Greg's BIP proposal, then blocking ASICBoost would change the \n> balance of miners from 67%/33% to 62.8%/37.2%; resulting in a 6.3% \n> loss for income for ASICBoost miners (not 20%), and a 12.7% gain\n> for non-ASICBoost miners.  In this case, total apparent hashrate\n> reduces to 88.8% of what it originally was when ASICBoost is\n> blocked (though the actual security either stays the same or\n> increases, depending on your attack model) [0]\n> \n> * if ASICBoost use is lower than that, say 33% (eg made up of \n> AntPool 18%, BTC.top 10%, ViaBTC 5%), then the shift is from\n> 33%/67% to 29.1%/70.9%, and results in a 13% loss for ASICBoost\n> miners, versus a 6% gain for non-ASICBoost miners. In these cases,\n> a price rise in the region of 7% to 15% due to blocking ASICBoost\n> would be enough to make everyone better off [1].\n> \n> * AIUI there are three feasible ways of doing ASICBoost: overt via \n> the version field, semi-covert via mining an empty block and\n> grinding the coinbase extra nonce, and fully covert by reordering\n> the block transaction merkle tree. If the fully covert method is\n> made infeasible via a secondary merkle commitment in the coinbase a\n> la segwit, and for whatever reason overt ASICBoost isn't used, then\n> empty block mining is still plausible, though presumably becomes\n> unprofitable when the extra 20% of block subsidy is less than the\n> fees for a block.  That's adds up to fees per block totalling\n> greater than 2.5BTC, and 2.5BTC/1MB is 250 satoshis per byte, which\n> actually seems to be where fees are these days, so unless they're\n> getting more than the claimed 20% benefit, people mining empty\n> blocks are already losing money compared to just mining normally...\n> (Of course, 250 satoshis per byte is already fairly painful, and\n> only gets more so as the price rises)\n> \n> Personally, I expect any technical attempt to block ASICBoost use\n> to fail or result in a chain split -- 67% of miners losing 6% of\n> income is on the order of $5M a month at current prices. Having an\n> approach that is as simple as possible (ie, independent from\n> segwit, carefully targetted, and impossible to oppose for any\n> reason other than wanting to use ASICBoost) seems optimal to me,\n> both in that it has the highest chance to succeed, and provides the\n> most conclusive information if/when it fails.\n> \n> Cheers, aj\n> \n> [0] Assuming ASICBoost miners have hardware capable of doing A\n> hashes with ASICBoost turned off, or A*B (B=1.2) with ASICBoost\n> turned on, and the remainder of miners have a total hashrate of R.\n> Then overall hashrate is currently H=A*B+R, and ASICBoost hashrate\n> is a = A*B/(A*B+R), with a = 67% if the quoted claim is on the\n> money. Rearranging:\n> \n> a = A*B/(A*B+R) a*(A*B+R) = A*B a*A*B + a*R = A*B a*R = (1-a)*A*B R\n> = (1/a-1)*A*B\n> \n> So a' = A/(A+R), the ASICBoost miner's hashrate if they're forced\n> to turn ASICBoost off, is:\n> \n> a' = A/(A+R) a' = A/(A+(1/a-1)*A*B) = 1/(1+(1/a-1)*B)\n> \n> But if a=0.67 and B=1.2, then a' = 0.628.\n> \n> The ratio of what they are getting to what they would getting is \n> just a/a',\n> \n> a/a' = a*(1+(1/a-1)*B) = (a+(1-a)*B)\n> \n> and their loss is a/a'-1, which is:\n> \n> a/a'-1 = (a+(1-a)*B) - 1 = (a+(1-a)*B) - (a+1-a) = (1-a)*(B-1)\n> \n> which is only 20% (B-1) when a is almost zero. When a increases\n> (ie, there is a higher percentage of ASICBoost miners, as sure\n> seems to be the case) the potential loss from disabling ASICBoost\n> dwindles to nothing (because 1-a goes to zero and B-1 is just a\n> constant).\n> \n> Note that this is the case even with mining centralisation -- if\n> you have 99% of the hashrate with ASICBoost, you'll still have\n> 98.8% of the hashrate without it, making a 0.2% loss (though of\n> course your competitors with 1% hashrate will go to 1.2%, making a\n> 20% gain). The reason is you're competing with all the ASICBoost\n> miners, *including your own*, for the next block, and the size of\n> the reward you'll get for winning doesn't change.\n> \n> Total apparent hashrate is A+R versus A*B+R, so\n> \n> (A+R)/(A*B+R) = 1/(A/(A+R)) * (A*B/(A*B+R))/B = 1/a' * a/B = a/a' /\n> B = (a+(1-a)*B) / B = a/B + (1-a)\n> \n> (yeah, so that formula's kind of obvious...)\n> \n> [1] Except maybe the patent holders (err, applicants). Though per\n> the recent open letter it doesn't seem like anyone's actually\n> paying for the patents in the first place. If miners were, then\n> coordinated disarmament might already be profitable; if you're\n> paying say 10% of your mining income in licensing fees or similar,\n> that might seem sensible in order to make 20% more profit; but if\n> blocking everyone from using ASICBoost would reduce your licensing\n> fees by 10% of your income, but only reduce your income by 6.3%,\n> then that adds up to a 3.7% gain and a bunch less hassle.\n> \n> I think if the ASICBoost patent holders were able to charge\n> perfectly optimally, they'd charge royalty fees of about 8.3% of\n> miner's income (so ASICBoost miners would make 10% net, rather than\n> 20%), and allow no more than 50% of miners to use it (so the\n> effective ASICBoost hashrate would be about 55%). That way the\n> decision to block ASICBoost would be:\n> \n> X * 1.2 * (1-0.083) / (0.5 * 1.2 + 0.5)  -- ASICBoost allowed = X *\n> 1.1004 / 1.1\n>> X\n> vs X / (0.5 + 0.5) -- ASICBoost banned = X\n> \n> and ASICBoost wouldn't be disabled, but the patent holders would \n> still be receiving 4.15% (50%*8.3%) of all mining income. If more \n> than 50% of hashpower was boosted, the formula would change to,\n> eg,\n> \n> X * 1.2 * (1-0.083) / (0.51 * 1.2 + 0.49) = X * 1.1004 / 1.102 < X\n> \n> and similarly if the fee was slightly increased, and in that case\n> all miners would benefit from disabling ASICBoost. Around these\n> figures ASICBoost miners would only gain/lose very slightly from\n> ASICBoost getting blocked; the big losers would be the patent\n> holders, who'd go from raking in 4.15% of all mining income to\n> nothing, and the big winners would be the non-ASICBoost miners,\n> who'd gain that 4.15% of income. The possibility of transfer\n> payments from non-ASICBoost miners to ASICBoost miners to block\n> ASICBoost might change that equation, probably towards lower fees\n> and higher hashrate.\n> \n> For comparison, if 67% of hashrate is using ASICBoost, they can't \n> charge them all more than 5.5% of their mining income, or miners \n> would prefer to block ASICBoost, and that would only give the\n> patent holders 3.7% of all mining income, much less.\n> \n> If patent holders can convince miners not to communicate with each \n> other so that they think that a smaller amount of hashpower is\n> using ASICBoost than actually is, that might also allow collecting\n> more royalties without risking collective action to block\n> ASICBoost.\n> \n> Of course, this is assuming they can charge all miners optimally \n> and no one infringes patents, and that if you're prevented from \n> using ASICBoost you don't have to keep paying royalties anyway, and\n> so on. Just completely realistic, plausible assumptions like that.\n> \n> _______________________________________________ bitcoin-dev mailing\n> list bitcoin-dev at lists.linuxfoundation.org \n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2.0.22 (GNU/Linux)\n\niQEcBAEBCAAGBQJZKdyaAAoJEDzYwH8LXOFO83IH/2FNwxjg1x9mlYMCLntShQZ+\n2eA3M/0Hg+Zys9JfkHeRfaXr8qIC4inAJ88dDZ8EoVwKlAobmVk9iBEb/+3IS2ol\nXKVSloe12AG3z0zi09bDtSu3b49Z11ZCw10uveHKbxxKqaiT1wohgX8eefHox1OJ\niGni8mGZhm3q4XTCtf5DrwTLAyplfHIeYtniXmlgkSpPjujJEB0H8viWs0QmghVc\nudQqz5MfcBu1Rf9TukpT+lhOWDw189mTkomNy/npJaiJFalBIIzT6iMIU22FRS6j\nxibIgdfq+3zAlZj4YAtyoIXSqdOnN2LKieY2hiLSjXwjk1xjnrqIc4ApDuW+dfk=\n=NeOF\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Anthony Towns",
                "date": "2017-05-29T11:19:14",
                "message_text_only": "On Sat, May 27, 2017 at 01:07:58PM -0700, Eric Voskuil via bitcoin-dev wrote:\n> Anthony,\n> For the sake of argument:\n\n(That seems like the cue to move any further responses to bitcoin-discuss)\n\n> (1) What would the situation look like if there was no patent?\n\nIf there were no patent, and it were easy enough to implement it, then\neveryone would use it. So blocking ASICBoost would decrease everyone's\nhashrate by the same amount, and you'd just have a single retarget period\nwith everyone earning a little less, and then everyone would be back to\nmaking the same profit.\n\nBut even without a patent, entry costs might be high (redesigning an\nASIC, making software that shuffles transactions so you can use the\nASIC's features) and how that works out seems hard to analyse...\n\n> (2) Would the same essential formulation exist if there had been a\n> patent on bitcoin mining ASICs in general?\n\nNot really; for the formulation to apply you'd have to have some way\nto block ASIC use via consensus rules, in a way that doesn't just block\nASICs completely, but just removes their advantage, ie makes them perform\ncomparably to GPUs/FPGAs or whatever everyone else is using.\n\nReportedly, ASICBoost is an option you can turn on or off on some mining\nhardware, so this seems valid (I'm assuming not using the option either\nincreases your electricity use by ~20% due to activating extra circuitry,\nor decreases your hashrate by ~20% and maybe also decreases your\nelectricity use by less than that by not activating some circuitry); but\n\"being an ASIC\" isn't something you can turn off and on in that manner.\n\n> (3) Would an unforeseen future patented mining optimization exhibit\n> the same characteristics?\n\nMaybe? It depends on whether the optimisation's use (or lack thereof)\ncan be detected (enforced) via consensus rules. If you've got a patent\non a 10nm process, and you build a bitcoin ASIC with it, there's no way\nto stop you via consensus rules that I can think of.\n\n> (4) Given that patent is a state grant of monopoly privilege, could a\n> state licensing regime for miners, applied in the same scope as a\n> patent, but absent any patent, have the same effect?\n\nI don't think that scenario's any different from charging miners income\ntax, is it? If you don't pay the licensing fee / income tax, you get put\nout of business; if you do, you have less profit. There's no way to block\neither via consensus mechanisms, at least in general...\n\nI think it's the case that any optional technology with license fees can't\nbe made available to all miners on equal terms, though, provided there is\nany way for it to be blocked via consensus mechanisms. If it were, the\nchoice would be:\n\n my percentage of the hashrate is h (0<h, h much less than 1), total\n hashrate is 1=100%, licensing fee is uniform per hashrate, so h*X,\n advantage of using technology is a factor of r (0<r, r*h much less\n than 1)\n\n - technology allowed, I use it:\n     I make r*h but pay X*h, so revenue is proportional to (r-X)*h\n - technology allowed, I don't use it:\n     I make h, pay nothing, so revenue is proportional to h\n\n Provides the licensor sets X<r, of these choices I always chose to use\n the technology, and so does everyone else. So base hashrate if no one\n were to use the technology is H=1/r.\n\n - technology not allowed, no one uses it:\n     I make h blocks, but total hashrate is 1/r, so revenue is proportional\n     to h/(1/r)=rh\n\n But rh>(r-X)*h provided X>0, so all miners are better off if the\n technology is not allowed (because they all suffer equally in loss of\n hashrate, which is cancelled out in a retarget period; and they all\n benefit equally by not having to pay licensing fees).\n\nSadly, the solution to this argument is to use discriminatory terms,\neither not offering the technology to everyone, or offering varying fees\nfor miners with different hashrates. Unless somehow it works to make it\nmore expensive for higher hashrate miners, this makes decentralisation\nworse.\n\nCheers,\naj"
            },
            {
                "author": "Eric Voskuil",
                "date": "2017-05-31T06:17:59",
                "message_text_only": "On 05/29/2017 04:19 AM, Anthony Towns wrote:\n> On Sat, May 27, 2017 at 01:07:58PM -0700, Eric Voskuil via bitcoin-dev wrote:\n>> Anthony,\n>> For the sake of argument:\n> \n> (That seems like the cue to move any further responses to bitcoin-discuss)\n\nI didn't meant to imply that the point was academic, just to ask your\nindulgence before making my point. Thanks for the detailed and\nthoughtful reply.\n\n>> (1) What would the situation look like if there was no patent?\n> \n> If there were no patent, and it were easy enough to implement it, then\n> everyone would use it. So blocking ASICBoost would decrease everyone's\n> hashrate by the same amount, and you'd just have a single retarget period\n> with everyone earning a little less, and then everyone would be back to\n> making the same profit.\n>...\n\nI don't accept that the ease (absolute cost) of implementing the\nASICBOOST optimization is relevant. The cost of implementation is offset\nby its returns. Given that people are presumed to be using it profitably\nI consider this point settled.\n\nThe important point is that if people widely use the optimization, it\ndoes not constitute any risk whatsoever.\n\n>> (2) Would the same essential formulation exist if there had been a\n>> patent on bitcoin mining ASICs in general?\n> \n> Not really; for the formulation to apply you'd have to have some way\n> to block ASIC use via consensus rules, in a way that doesn't just block\n> ASICs completely, but just removes their advantage, ie makes them perform\n> comparably to GPUs/FPGAs or whatever everyone else is using.\n>...\n\nI realize that the term \"same essential formulation\" was misleading, but\nmy aim was the *source* of harm (unblocked) in an ASIC patent as\ncompared to an ASICBOOST patent. It seems that you agree that this harm\nin both cases results from the patent, not the optimization.\n\nNobody is suggesting that ASICs are a problem despite the significant\noptimization. It is worth considering an alternate history where ASIC\nmining had been patented, given that blocking it would not have been an\noption. More on this below.\n\nI agree that the optimizations differ in that there is no known way to\nblock the ASIC advantage, except for all people to use it. But correctly\nattributing the source of harm is critical to useful threat modeling. As\nthe ASIC example is meant to show, it is very possible that an\nunblockable patent advantage can arise in the future.\n\n>> (3) Would an unforeseen future patented mining optimization exhibit\n>> the same characteristics?\n> \n> Maybe? It depends on whether the optimisation's use (or lack thereof)\n> can be detected (enforced) via consensus rules. If you've got a patent\n> on a 10nm process, and you build a bitcoin ASIC with it, there's no way\n> to stop you via consensus rules that I can think of.\n\nQuite clearly then there is a possibility (if not a certainty) that\nBitcoin will eventually be faced with an unblockable mining patent\nadvantage.\n\n>> (4) Given that patent is a state grant of monopoly privilege, could a\n>> state licensing regime for miners, applied in the same scope as a\n>> patent, but absent any patent, have the same effect?\n> \n> I don't think that scenario's any different from charging miners income\n> tax, is it? If you don't pay the licensing fee / income tax, you get put\n> out of business; if you do, you have less profit. There's no way to block\n> either via consensus mechanisms, at least in general...\n\nPrecisely. This is a proper generalization of the threats above. A\npatent is a state grant of monopoly privilege. The state's agent (patent\nholder) extracts licensing fees from miners. The state does this for its\nown perceived benefit (social, economic or otherwise). Extracting money\nin exchange for permission to use an optimization is a tax on the\noptimization.\n\n> I think it's the case that any optional technology with license fees can't\n> be made available to all miners on equal terms...\n\nThis is an important point. Consider also that a subsidy has the same\neffect as a tax. A disproportionate tax on competing miners amounts to a\nsubsidy. A disproportionate subsidy amounts to a tax on competitors.\n\nIf the state wants to put its finger on the scale it can do so in either\ndirection. It can compel licensing fees from miners with no need for a\npatent. It can also subsidize mining via subsidized energy costs (for\nexample), intentionally or otherwise.\n\n> Sadly, the solution to this argument is to use discriminatory terms,\n> either not offering the technology to everyone, or offering varying fees\n> for miners with different hashrates...\n\nThat sounds more like a central authority than a solution.\n\nSo, my point:\n\nMis-attributing the threat is not helpful. This is not an issue of an\nunforeseen bug, security vulnerability, bad miners, or evil\npatent-holders. This is one narrow example of the general, foreseen,\nprimary threat to Bitcoin - or any hard money.\n\nBitcoin's sole defense is decentralization. People parrot this idea\nwithout considering the implication. How does decentralization work? It\nworks by broadly spreading the risk of state attack. But this implies\nthat some people are actually taking the risk.\n\nBy analogy, BitTorrent is estimated to have 250 million active users in\na month, and 200,000 have been sued in the US since 2010.\nDecentralization works because it reduces risk through risk-sharing.\n\nBitcoin cannot generally prevent state patent/licensing/tax regimes.\nLicensing is a ban that is lifted in exchange for payment. What is the\nBitcoin solution to a global ban on mining? On wallets? On exchange?\n\nThe Bitcoin defense against a patent is to ignore the patent. Berating\npeople for doing so seems entirely counterproductive.\n\ne\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/5be3c7bc/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Emergency Deployment of SegWit as a partial mitigation of CVE-2017-9230",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Andreas M. Antonopoulos",
                "Anthony Towns",
                "Tom Zander",
                "Erik Aronesty",
                "Cameron Garnham"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 50686
        }
    },
    {
        "title": "[bitcoin-dev] Compatibility-Oriented Omnibus Proposal",
        "thread_messages": [
            {
                "author": "CalvinRechner",
                "date": "2017-05-29T01:18:13",
                "message_text_only": "This proposal is written under the assumption that the signatories to the Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms of the agreement, and intend to enact the updates described therein. As such, criticisms pertaining to the chosen deployment timeline or hard fork upgrade path should be treated as out-of-scope during the initial discussion of this proposal.\n\nBecause it includes the activation of a hard fork for which community consensus does not yet exist, this proposal is not likely to be merged into Bitcoin Core in the immediate future, and must instead be maintained and reviewed in a separate downstream repository. However, it is written with the intent to remain cleanly compatible with future network updates and changes, to allow for the option of a straightforward upstream merge if community consensus for the proposal is successfully achieved in the following months.\n\n<pre>\nBIP: ?\nLayer: Consensus\nTitle: Compatibility-oriented omnibus proposal\nAuthor: Calvin Rechner <calvinrechner at protonmail.com>\nComments-Summary: No comments yet.\nComments-URI: ?\nStatus: Draft\nType: Standards Track\nCreated: 2017-05-28\nLicense: PD\n</pre>\n\n===Abstract===\n\nThis document describes a virtuous combination of James Hilliard\u2019s \u201cReduced signalling threshold activation of existing segwit deployment\u201d[2], Shaolin Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3], Sergio Demian Lerner\u2019s \u201cSegwit2Mb\u201d[4] proposal, Luke Dashjr\u2019s \u201cPost-segwit 2 MB block size hardfork\u201d[5], and hard fork safety mechanisms from Johnson Lau\u2019s \u201cSpoonnet\u201d[6][7] into a single omnibus proposal and patchset.\n\n===Motivation===\n\nThe Consensus 2017 Scaling Agreement[1] stipulated the following commitments:\n\n\u2022 Activate Segregated Witness at an 80% threshold, signaling at bit 4\n\u2022 Activate a 2 MB hard fork within six months\n\nThis proposal seeks to fulfill these criteria while retaining maximum compatibility with existing deployment approaches, thereby minimizing the risks of a destructive chain split. Additionally, subsequent indications of implied criteria and expectations of the Agreement[8][9] are satisfied.\n\nThe proposed hard fork incorporates a legacy witness discount and 2MB blocksize limit along with the enactment of Spoonnet-derived protectionary measures, to ensure the safest possible fork activation within the constraints of the requirements outlined in the Scaling Agreement.\n\n===Rationale===\n\nTo the extent possible, this represents an effort at a best-of-all-worlds proposal, intended to provide a common foundation from which all mutually-inclusive goals can be achieved while risks are minimized.\n\nThe individual constituent proposals include the following respective rationales:\n\nJames Hilliard\u2019s \u201cReduced signalling threshold activation of existing segwit deployment\u201d[2] explains:\n\n> The goal here is to minimize chain split risk and network disruption while maximizing backwards compatibility and still providing for rapid activation of segwit at the 80% threshold using bit 4.\n\nShaolin Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3] is included to:\n\n> cause the existing \"segwit\" deployment to activate without needing to release a new deployment.\n\nBoth of the aforementioned activation options (\u201cfast-activation\u201d and \u201cflag-day activation\u201d) serve to prevent unnecessary delays in the network upgrade process, addressing a common criticism of the Scaling Agreement and providing an opportunity for cooperation and unity instead.\n\nSergio Demian Lerner\u2019s \u201cSegwit2Mb\u201d[4] proposal explains the reasoning behind linking SegWit\u2019s activation with that of a later hard fork block size increase:\n\n> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB block size hard-fork activated ONLY if segwit activates (95% of miners signaling ... to re-unite the Bitcoin community and avoid a cryptocurrency split.\n\nLuke Dashjr\u2019s \u201cPost-segwit 2 MB block size hardfork\u201d[5] suggestions are included to reduce the marginal risks that such an increase in the block size might introduce:\n\n> if the community wishes to adopt (by unanimous consensus) a 2 MB block size hardfork, this is probably the best way to do it right now... Legacy Bitcoin transactions are given the witness discount, and a block size limit of 2 MB is imposed.\n\nJohnson Lau\u2019s anti-replay and network version updates[6][7] are included as general hard fork safety measures:\n\n> In a blockchain split, however, since both forks share the same historical ledger, replay attack would be possible, unless some precautions are taken.\n\n===Copyright===\n\nThis document is placed in the public domain.\n\n===Specification===\n\n###Proposal Signaling###\n\nThe string \u201cCOOP\u201d is included anywhere in the txn-input (scriptSig) of the coinbase-txn to signal compatibility and support.\n\n###Soft Fork###\n\nFast-activation (segsignal): deployed by a \"version bits\" with an 80% activation threshold BIP9 with the name \"segsignal\" and using bit 4... [with a] start time of midnight June 1st, 2017 (epoch time 1496275200) and timeout on midnight November 15th 2017 (epoch time 1510704000). This BIP will cease to be active when segwit is locked-in.[2]\n\nFlag-day activation (BIP148): While this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected... This BIP will be active between midnight August 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch time 1510704000) if the existing segwit deployment is not locked-in or activated before epoch time 1501545600. This BIP will cease to be active when segwit is locked-in. While this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected.[3]\n\n###Hard Fork###\n\nThe hard fork deployment is scheduled to occur 6 months after SegWit activates:\n\n(HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)\n\nFor blocks equal to or higher than HardForkHeight, Luke-Jr\u2019s legacy witness discount and 2MB limit are enacted, along with the following Spoonnet-based improvements[6][7]:\n\n* A \"hardfork signalling block\" is a block with the sign bit of header nVersion is set [Clearly invalid for old nodes; easy opt-out for light wallets]\n\n* If the median-time-past of the past 11 blocks is smaller than the HardForkHeight... a hardfork signalling block is invalid.\n\n* Child of a hardfork signalling block MUST also be a hardfork signalling block\n\n* Hardfork network version bit is 0x02000000. A tx is invalid if the highest nVersion byte is not zero, and the network version bit is not set.\n\n===Deployment===\n\nDeployment of the \u201cfast-activation\u201d soft fork is exactly identical to Hilliard\u2019s segsignal proposal[2]. Deployment of the \u201cflag-day\u201d soft fork is exactly identical to Fry\u2019s BIP148 proposal[3]. HardForkHeight is defined as 26280 blocks after SegWit is set to ACTIVE. All blocks with height greater than or equal to this value must adhere to the consensus rules of the 2MB hard fork.\n\n===Backwards compatibility===\n\nThis deployment is compatible with the existing \"segwit\" bit 1 deployment scheduled between midnight November 15th, 2016 and midnight November 15th, 2017.\n\nTo prevent the risk of building on top of invalid blocks, miners should upgrade their nodes to support segsignal as well as BIP148.\n\nThe intent of this proposal is to maintain full legacy consensus compatibility for users up until the HardForkHeight block height, after which backwards compatibility is waived as enforcement of the hard fork consensus ruleset begins.\n\n===References===\n\n[1] https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014380.html\n[3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\n[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013921.html\n[5] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014399.html\n[6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013542.html\n[7] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html\n[8] https://twitter.com/sysmannet/status/867124645279006720\n[9] https://twitter.com/JihanWu/status/867139046786465792\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170528/7696e13f/attachment-0001.html>"
            },
            {
                "author": "James Hilliard",
                "date": "2017-05-29T10:19:18",
                "message_text_only": "For the reasons listed\nhere(https://github.com/bitcoin/bips/blob/master/bip-0091.mediawiki#Motivation)\nyou should have it so that the HF can not lock in unless the existing\nBIP141 segwit deployment is activated.\n\nThe biggest issue is that a safe HF is very unlikely to be able to be\ncoded and tested within 6 months.\n\nOn Sun, May 28, 2017 at 8:18 PM, CalvinRechner via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> This proposal is written under the assumption that the signatories to the\n> Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms of\n> the agreement, and intend to enact the updates described therein. As such,\n> criticisms pertaining to the chosen deployment timeline or hard fork upgrade\n> path should be treated as out-of-scope during the initial discussion of this\n> proposal.\n>\n> Because it includes the activation of a hard fork for which community\n> consensus does not yet exist, this proposal is not likely to be merged into\n> Bitcoin Core in the immediate future, and must instead be maintained and\n> reviewed in a separate downstream repository. However, it is written with\n> the intent to remain cleanly compatible with future network updates and\n> changes, to allow for the option of a straightforward upstream merge if\n> community consensus for the proposal is successfully achieved in the\n> following months.\n>\n>\n> <pre>\n> BIP: ?\n> Layer: Consensus\n> Title: Compatibility-oriented omnibus proposal\n> Author: Calvin Rechner <calvinrechner at protonmail.com>\n> Comments-Summary: No comments yet.\n> Comments-URI: ?\n> Status: Draft\n> Type: Standards Track\n> Created: 2017-05-28\n> License: PD\n> </pre>\n>\n>\n> ===Abstract===\n>\n> This document describes a virtuous combination of James Hilliard\u2019s \u201cReduced\n> signalling threshold activation of existing segwit deployment\u201d[2], Shaolin\n> Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3], Sergio Demian Lerner\u2019s\n> \u201cSegwit2Mb\u201d[4] proposal, Luke Dashjr\u2019s \u201cPost-segwit 2 MB block size\n> hardfork\u201d[5], and hard fork safety mechanisms from Johnson Lau\u2019s\n> \u201cSpoonnet\u201d[6][7] into a single omnibus proposal and patchset.\n>\n>\n> ===Motivation===\n>\n> The Consensus 2017 Scaling Agreement[1] stipulated the following\n> commitments:\n>\n> \u2022 Activate Segregated Witness at an 80% threshold, signaling at bit 4\n> \u2022 Activate a 2 MB hard fork within six months\n>\n> This proposal seeks to fulfill these criteria while retaining maximum\n> compatibility with existing deployment approaches, thereby minimizing the\n> risks of a destructive chain split. Additionally, subsequent indications of\n> implied criteria and expectations of the Agreement[8][9] are satisfied.\n>\n> The proposed hard fork incorporates a legacy witness discount and 2MB\n> blocksize limit along with the enactment of Spoonnet-derived protectionary\n> measures, to ensure the safest possible fork activation within the\n> constraints of the requirements outlined in the Scaling Agreement.\n>\n>\n> ===Rationale===\n>\n> To the extent possible, this represents an effort at a best-of-all-worlds\n> proposal, intended to provide a common foundation from which all\n> mutually-inclusive goals can be achieved while risks are minimized.\n>\n> The individual constituent proposals include the following respective\n> rationales:\n>\n> James Hilliard\u2019s \u201cReduced signalling threshold activation of existing segwit\n> deployment\u201d[2] explains:\n>\n>> The goal here is to minimize chain split risk and network disruption while\n>> maximizing backwards compatibility and still providing for rapid activation\n>> of segwit at the 80% threshold using bit 4.\n>\n> Shaolin Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3] is included to:\n>\n>> cause the existing \"segwit\" deployment to activate without needing to\n>> release a new deployment.\n>\n> Both of the aforementioned activation options (\u201cfast-activation\u201d and\n> \u201cflag-day activation\u201d) serve to prevent unnecessary delays in the network\n> upgrade process, addressing a common criticism of the Scaling Agreement and\n> providing an opportunity for cooperation and unity instead.\n>\n> Sergio Demian Lerner\u2019s \u201cSegwit2Mb\u201d[4] proposal explains the reasoning behind\n> linking SegWit\u2019s activation with that of a later hard fork block size\n> increase:\n>\n>> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB block\n>> size hard-fork activated ONLY if segwit activates (95% of miners signaling\n>> ... to re-unite the Bitcoin community and avoid a cryptocurrency split.\n>\n> Luke Dashjr\u2019s \u201cPost-segwit 2 MB block size hardfork\u201d[5] suggestions are\n> included to reduce the marginal risks that such an increase in the block\n> size might introduce:\n>\n>> if the community wishes to adopt (by unanimous consensus) a 2 MB block\n>> size hardfork, this is probably the best way to do it right now... Legacy\n>> Bitcoin transactions are given the witness discount, and a block size limit\n>> of 2 MB is imposed.\n>\n> Johnson Lau\u2019s anti-replay and network version updates[6][7] are included as\n> general hard fork safety measures:\n>\n>> In a blockchain split, however, since both forks share the same historical\n>> ledger, replay attack would be possible, unless some precautions are taken.\n>\n>\n> ===Copyright===\n>\n> This document is placed in the public domain.\n>\n>\n> ===Specification===\n>\n> ###Proposal Signaling###\n>\n> The string \u201cCOOP\u201d is included anywhere in the txn-input (scriptSig) of the\n> coinbase-txn to signal compatibility and support.\n>\n> ###Soft Fork###\n>\n> Fast-activation (segsignal):  deployed by a \"version bits\" with an 80%\n> activation threshold BIP9 with the name \"segsignal\" and using bit 4... [with\n> a] start time of midnight June 1st, 2017 (epoch time 1496275200) and timeout\n> on midnight November 15th 2017 (epoch time 1510704000). This BIP will cease\n> to be active when segwit is locked-in.[2]\n>\n> Flag-day activation (BIP148): While this BIP is active, all blocks must set\n> the nVersion header top 3 bits to 001 together with bit field (1<<1)\n> (according to the existing segwit deployment). Blocks that do not signal as\n> required will be rejected... This BIP will be active between midnight August\n> 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch time\n> 1510704000) if the existing segwit deployment is not locked-in or activated\n> before epoch time 1501545600. This BIP will cease to be active when segwit\n> is locked-in. While this BIP is active, all blocks must set the nVersion\n> header top 3 bits to 001 together with bit field (1<<1) (according to the\n> existing segwit deployment). Blocks that do not signal as required will be\n> rejected.[3]\n>\n> ###Hard Fork###\n>\n> The hard fork deployment is scheduled to occur 6 months after SegWit\n> activates:\n>\n> (HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)\n>\n> For blocks equal to or higher than HardForkHeight, Luke-Jr\u2019s legacy witness\n> discount and 2MB limit are enacted, along with the following Spoonnet-based\n> improvements[6][7]:\n>\n> * A \"hardfork signalling block\" is a block with the sign bit of header\n> nVersion is set [Clearly invalid for old nodes; easy opt-out for light\n> wallets]\n>\n> * If the median-time-past of the past 11 blocks is smaller than the\n> HardForkHeight... a hardfork signalling block is invalid.\n>\n> * Child of a hardfork signalling block MUST also be a hardfork signalling\n> block\n>\n> * Hardfork network version bit is 0x02000000. A tx is invalid if the highest\n> nVersion byte is not zero, and the network version bit is not set.\n>\n>\n> ===Deployment===\n>\n> Deployment of the \u201cfast-activation\u201d soft fork is exactly identical to\n> Hilliard\u2019s segsignal proposal[2]. Deployment of the \u201cflag-day\u201d soft fork is\n> exactly identical to Fry\u2019s BIP148 proposal[3]. HardForkHeight is defined as\n> 26280 blocks after SegWit is set to ACTIVE. All blocks with height greater\n> than or equal to this value must adhere to the consensus rules of the 2MB\n> hard fork.\n>\n>\n> ===Backwards compatibility===\n>\n> This deployment is compatible with the existing \"segwit\" bit 1 deployment\n> scheduled between midnight November 15th, 2016 and midnight November 15th,\n> 2017.\n>\n> To prevent the risk of building on top of invalid blocks, miners should\n> upgrade their nodes to support segsignal as well as BIP148.\n>\n> The intent of this proposal is to maintain full legacy consensus\n> compatibility for users up until the HardForkHeight block height, after\n> which backwards compatibility is waived as enforcement of the hard fork\n> consensus ruleset begins.\n>\n>\n> ===References===\n>\n> [1]\n> https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77\n> [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014380.html\n> [3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\n> [4]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013921.html\n> [5]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014399.html\n> [6]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013542.html\n> [7]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html\n> [8] https://twitter.com/sysmannet/status/867124645279006720\n> [9] https://twitter.com/JihanWu/status/867139046786465792\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-29T22:52:36",
                "message_text_only": "I can't think of any resistance to this, but the code, on a tight timeline,\nisn't going to be easy.   Is anyone volunteering for this?\n\nOn May 29, 2017 6:19 AM, \"James Hilliard via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> For the reasons listed\n> here(https://github.com/bitcoin/bips/blob/master/bip-\n> 0091.mediawiki#Motivation)\n> you should have it so that the HF can not lock in unless the existing\n> BIP141 segwit deployment is activated.\n>\n> The biggest issue is that a safe HF is very unlikely to be able to be\n> coded and tested within 6 months.\n>\n> On Sun, May 28, 2017 at 8:18 PM, CalvinRechner via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > This proposal is written under the assumption that the signatories to the\n> > Consensus 2017 Scaling Agreement[1] are genuinely committed to the terms\n> of\n> > the agreement, and intend to enact the updates described therein. As\n> such,\n> > criticisms pertaining to the chosen deployment timeline or hard fork\n> upgrade\n> > path should be treated as out-of-scope during the initial discussion of\n> this\n> > proposal.\n> >\n> > Because it includes the activation of a hard fork for which community\n> > consensus does not yet exist, this proposal is not likely to be merged\n> into\n> > Bitcoin Core in the immediate future, and must instead be maintained and\n> > reviewed in a separate downstream repository. However, it is written with\n> > the intent to remain cleanly compatible with future network updates and\n> > changes, to allow for the option of a straightforward upstream merge if\n> > community consensus for the proposal is successfully achieved in the\n> > following months.\n> >\n> >\n> > <pre>\n> > BIP: ?\n> > Layer: Consensus\n> > Title: Compatibility-oriented omnibus proposal\n> > Author: Calvin Rechner <calvinrechner at protonmail.com>\n> > Comments-Summary: No comments yet.\n> > Comments-URI: ?\n> > Status: Draft\n> > Type: Standards Track\n> > Created: 2017-05-28\n> > License: PD\n> > </pre>\n> >\n> >\n> > ===Abstract===\n> >\n> > This document describes a virtuous combination of James Hilliard\u2019s\n> \u201cReduced\n> > signalling threshold activation of existing segwit deployment\u201d[2],\n> Shaolin\n> > Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3], Sergio Demian\n> Lerner\u2019s\n> > \u201cSegwit2Mb\u201d[4] proposal, Luke Dashjr\u2019s \u201cPost-segwit 2 MB block size\n> > hardfork\u201d[5], and hard fork safety mechanisms from Johnson Lau\u2019s\n> > \u201cSpoonnet\u201d[6][7] into a single omnibus proposal and patchset.\n> >\n> >\n> > ===Motivation===\n> >\n> > The Consensus 2017 Scaling Agreement[1] stipulated the following\n> > commitments:\n> >\n> > \u2022 Activate Segregated Witness at an 80% threshold, signaling at bit 4\n> > \u2022 Activate a 2 MB hard fork within six months\n> >\n> > This proposal seeks to fulfill these criteria while retaining maximum\n> > compatibility with existing deployment approaches, thereby minimizing the\n> > risks of a destructive chain split. Additionally, subsequent indications\n> of\n> > implied criteria and expectations of the Agreement[8][9] are satisfied.\n> >\n> > The proposed hard fork incorporates a legacy witness discount and 2MB\n> > blocksize limit along with the enactment of Spoonnet-derived\n> protectionary\n> > measures, to ensure the safest possible fork activation within the\n> > constraints of the requirements outlined in the Scaling Agreement.\n> >\n> >\n> > ===Rationale===\n> >\n> > To the extent possible, this represents an effort at a best-of-all-worlds\n> > proposal, intended to provide a common foundation from which all\n> > mutually-inclusive goals can be achieved while risks are minimized.\n> >\n> > The individual constituent proposals include the following respective\n> > rationales:\n> >\n> > James Hilliard\u2019s \u201cReduced signalling threshold activation of existing\n> segwit\n> > deployment\u201d[2] explains:\n> >\n> >> The goal here is to minimize chain split risk and network disruption\n> while\n> >> maximizing backwards compatibility and still providing for rapid\n> activation\n> >> of segwit at the 80% threshold using bit 4.\n> >\n> > Shaolin Fry\u2019s \u201cMandatory activation of segwit deployment\u201d[3] is included\n> to:\n> >\n> >> cause the existing \"segwit\" deployment to activate without needing to\n> >> release a new deployment.\n> >\n> > Both of the aforementioned activation options (\u201cfast-activation\u201d and\n> > \u201cflag-day activation\u201d) serve to prevent unnecessary delays in the network\n> > upgrade process, addressing a common criticism of the Scaling Agreement\n> and\n> > providing an opportunity for cooperation and unity instead.\n> >\n> > Sergio Demian Lerner\u2019s \u201cSegwit2Mb\u201d[4] proposal explains the reasoning\n> behind\n> > linking SegWit\u2019s activation with that of a later hard fork block size\n> > increase:\n> >\n> >> Segwit2Mb combines segwit as it is today in Bitcoin 0.14+ with a 2MB\n> block\n> >> size hard-fork activated ONLY if segwit activates (95% of miners\n> signaling\n> >> ... to re-unite the Bitcoin community and avoid a cryptocurrency split.\n> >\n> > Luke Dashjr\u2019s \u201cPost-segwit 2 MB block size hardfork\u201d[5] suggestions are\n> > included to reduce the marginal risks that such an increase in the block\n> > size might introduce:\n> >\n> >> if the community wishes to adopt (by unanimous consensus) a 2 MB block\n> >> size hardfork, this is probably the best way to do it right now...\n> Legacy\n> >> Bitcoin transactions are given the witness discount, and a block size\n> limit\n> >> of 2 MB is imposed.\n> >\n> > Johnson Lau\u2019s anti-replay and network version updates[6][7] are included\n> as\n> > general hard fork safety measures:\n> >\n> >> In a blockchain split, however, since both forks share the same\n> historical\n> >> ledger, replay attack would be possible, unless some precautions are\n> taken.\n> >\n> >\n> > ===Copyright===\n> >\n> > This document is placed in the public domain.\n> >\n> >\n> > ===Specification===\n> >\n> > ###Proposal Signaling###\n> >\n> > The string \u201cCOOP\u201d is included anywhere in the txn-input (scriptSig) of\n> the\n> > coinbase-txn to signal compatibility and support.\n> >\n> > ###Soft Fork###\n> >\n> > Fast-activation (segsignal):  deployed by a \"version bits\" with an 80%\n> > activation threshold BIP9 with the name \"segsignal\" and using bit 4...\n> [with\n> > a] start time of midnight June 1st, 2017 (epoch time 1496275200) and\n> timeout\n> > on midnight November 15th 2017 (epoch time 1510704000). This BIP will\n> cease\n> > to be active when segwit is locked-in.[2]\n> >\n> > Flag-day activation (BIP148): While this BIP is active, all blocks must\n> set\n> > the nVersion header top 3 bits to 001 together with bit field (1<<1)\n> > (according to the existing segwit deployment). Blocks that do not signal\n> as\n> > required will be rejected... This BIP will be active between midnight\n> August\n> > 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch\n> time\n> > 1510704000) if the existing segwit deployment is not locked-in or\n> activated\n> > before epoch time 1501545600. This BIP will cease to be active when\n> segwit\n> > is locked-in. While this BIP is active, all blocks must set the nVersion\n> > header top 3 bits to 001 together with bit field (1<<1) (according to the\n> > existing segwit deployment). Blocks that do not signal as required will\n> be\n> > rejected.[3]\n> >\n> > ###Hard Fork###\n> >\n> > The hard fork deployment is scheduled to occur 6 months after SegWit\n> > activates:\n> >\n> > (HardForkHeight = SEGWIT_ACTIVE_BLOCK_HEIGHT + 26280)\n> >\n> > For blocks equal to or higher than HardForkHeight, Luke-Jr\u2019s legacy\n> witness\n> > discount and 2MB limit are enacted, along with the following\n> Spoonnet-based\n> > improvements[6][7]:\n> >\n> > * A \"hardfork signalling block\" is a block with the sign bit of header\n> > nVersion is set [Clearly invalid for old nodes; easy opt-out for light\n> > wallets]\n> >\n> > * If the median-time-past of the past 11 blocks is smaller than the\n> > HardForkHeight... a hardfork signalling block is invalid.\n> >\n> > * Child of a hardfork signalling block MUST also be a hardfork signalling\n> > block\n> >\n> > * Hardfork network version bit is 0x02000000. A tx is invalid if the\n> highest\n> > nVersion byte is not zero, and the network version bit is not set.\n> >\n> >\n> > ===Deployment===\n> >\n> > Deployment of the \u201cfast-activation\u201d soft fork is exactly identical to\n> > Hilliard\u2019s segsignal proposal[2]. Deployment of the \u201cflag-day\u201d soft fork\n> is\n> > exactly identical to Fry\u2019s BIP148 proposal[3]. HardForkHeight is defined\n> as\n> > 26280 blocks after SegWit is set to ACTIVE. All blocks with height\n> greater\n> > than or equal to this value must adhere to the consensus rules of the 2MB\n> > hard fork.\n> >\n> >\n> > ===Backwards compatibility===\n> >\n> > This deployment is compatible with the existing \"segwit\" bit 1 deployment\n> > scheduled between midnight November 15th, 2016 and midnight November\n> 15th,\n> > 2017.\n> >\n> > To prevent the risk of building on top of invalid blocks, miners should\n> > upgrade their nodes to support segsignal as well as BIP148.\n> >\n> > The intent of this proposal is to maintain full legacy consensus\n> > compatibility for users up until the HardForkHeight block height, after\n> > which backwards compatibility is waived as enforcement of the hard fork\n> > consensus ruleset begins.\n> >\n> >\n> > ===References===\n> >\n> > [1]\n> > https://medium.com/@DCGco/bitcoin-scaling-agreement-at-\n> consensus-2017-133521fe9a77\n> > [2]\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-May/014380.html\n> > [3] https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki\n> > [4]\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-March/013921.html\n> > [5]\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-May/014399.html\n> > [6]\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-February/013542.html\n> > [7]\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2017-January/013473.html\n> > [8] https://twitter.com/sysmannet/status/867124645279006720\n> > [9] https://twitter.com/JihanWu/status/867139046786465792\n> >\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/7373974e/attachment-0001.html>"
            },
            {
                "author": "Oliver Petruzel",
                "date": "2017-05-29T23:49:59",
                "message_text_only": ">>if the community wishes to adopt (by unanimous consensus) a 2 MB block\nsize hardfork, this is probably the best way to do it right now... Legacy\nBitcoin transactions are given the witness discount, and a block size limit\nof 2 MB is imposed.<<\n\n\nThe above decision may quickly become very controversial. I don't think it's\nwhat most users had/have in mind when they discuss a \"2MB+SegWit\" solution.\n\nWith the current 1MB+SegWit, testing has shown us that normal usage results\nin ~2 or 2.1MB blocks.\n\nI think most users will expect a linear increase when Base Size is\nincreased to 2000000 bytes and Total Weight is increased to 8000000 bytes.\nWith normal usage, the expected results would then be ~4 or 4.2MB blocks.\n\nAm I missing something here, or does Luke's suggested 2MB cap completely\nnullify that expected linear increase? If so, why? What's the logic behind\nthis decision?\n\nI'd love to be armed with a good answer should my colleagues ask me the\nsame obvious question, so thank you ahead of time!\n\nRespectfully,\nOliver Petruzel\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170529/069bfb26/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2017-05-30T15:51:17",
                "message_text_only": "- We now are witnessing this... COOP vs LukeJr COOP, vs BIP148 vs BIP149 vs\nBIP91 ... how many are there?:\n\nhttps://xkcd.com/927\n\n- If some miners and exchanges collude to enact a rapid 2MB+Segwit hard\nfork coin... and calling it \"bitcoin\" on major exchanges this could swiftly\nfragment the network.\n\n- If this fork fails to contain an ASICBOOST defense, then this is\nessentially an example of core failing to appropriately respond to the CVE\nsecurity vulnerability in time.\n\n- A swift BIP148 release in core seems necessary to defend against this.\nI am no longer in favor of adding a BIP148 option with default \"false\"..\nI think it should be merged in...enabled, and released ASAP to defend\nagainst these attacks.\n\n\nOn Mon, May 29, 2017 at 7:49 PM, Oliver Petruzel via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> >>if the community wishes to adopt (by unanimous consensus) a 2 MB block\n> size hardfork, this is probably the best way to do it right now... Legacy\n> Bitcoin transactions are given the witness discount, and a block size limit\n> of 2 MB is imposed.<<\n>\n>\n> The above decision may quickly become very controversial. I don't think it's\n> what most users had/have in mind when they discuss a \"2MB+SegWit\" solution.\n>\n> With the current 1MB+SegWit, testing has shown us that normal usage\n> results in ~2 or 2.1MB blocks.\n>\n> I think most users will expect a linear increase when Base Size is\n> increased to 2000000 bytes and Total Weight is increased to 8000000 bytes.\n> With normal usage, the expected results would then be ~4 or 4.2MB blocks.\n>\n> Am I missing something here, or does Luke's suggested 2MB cap completely\n> nullify that expected linear increase? If so, why? What's the logic behind\n> this decision?\n>\n> I'd love to be armed with a good answer should my colleagues ask me the\n> same obvious question, so thank you ahead of time!\n>\n> Respectfully,\n> Oliver Petruzel\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/127b8af6/attachment-0001.html>"
            },
            {
                "author": "CalvinRechner",
                "date": "2017-05-30T22:20:25",
                "message_text_only": "In principle, there is complete flexibility when it comes to the specific consensus details of the hard fork. One common suggestion has been to phase in a gradual blocksize increase beyond the initial 2MB cap included in Luke-Jr's proposal (a la BIP103); this would certainly be a welcome inclusion in the Omnibus Proposal, provided that is what we want. The reasoning behind incorporating Luke-Jr's 2MB limit and discount-rebalancing was to satisfy the conditions of the Scaling Agreement while ensuring maximum safety, minimum code discrepancies, and minimum controversy among the community; these priorities seem imperative, considering the extreme timeline constraints we are working under and the goals of the proposal. To put it more simply, the intent of the proposal was to serve as a template for the minimum viable fork that can achieve true consensus. A gradual increase to a larger size cap, especially if it were reasonably conservative, would be wholly in accordance with the Omnibus Proposal if that is what it takes to achieve the cooperation between community, industry, and developers in this critical moment of Bitcoin's history.\n\nThe purpose of the Omnibus Proposal is singlefold: to achieve the goals of the Consensus 2017 Scaling Agreement in the most maximally-compatible way. We can minimize disruption and loss potential all around by solving these problems in a compatibility-oriented manner. It is possible to fulfill both the letter and the spirit of the Scaling Agreement, to the complete satisfaction of all involved, while preventing chain-split risks in the meantime.\n\nThere is no justification for incompatibility with existing deployment approaches, when there is the possibility to work together towards our mutual goals instead. The most rational option is to join forces and avoid any chain-split potential for as long as possible. Under the Omnibus Proposal, once SegWit is activated, the terms of the hard fork are locked in automatically, set to activate 6 months later. The proposal guarantees that a successful SegWit activation is followed by a hard fork. Beyond enforcing the hard fork rules beginning at block height HardForkHeight, the Omnibus Proposal simply represents compatibility with the existing SegWit-activation deployment approaches.\n\nBy committing to this proposal, we can ensure unity, at least for now. There do not appear to be any arguments to the contrary. Why squander this opportunity for consensus and harmony? We can leverage the momentum of several disparate movements, and perhaps enjoy some much-needed social solidarity. In a way, everyone can get what they want, and through cooperation, we avoid the risk of a costly fracture.\n\nThe Segwit2x Team has begun work on an implementation of the Consensus Scaling Agreement, their operational timeline including the publication of a BIP on June 16, 2017.[1] I call upon the developers and maintainers of this initiative to consider and honor the Omnibus Proposal, extended or modified as needed, as the guiding approach to your development effort. Almost every component of the code exists, in some form or fashion, in the various constituent proposals' reference implementations, most of which have already undergone a significant degree of peer review.\n\nWe cannot afford to delay, nor to reimplement; the launch timeline is aggressively optimistic as it is. The quickest and safest approach to achieving the goals set forth at Consensus 2017 is to leverage the existing tools and proposals for the job. We can solve our problems properly, cooperatively.\n\nI humbly ask that Jeff Garzik, Barry Silbert, Mike Belshe, and all of the other wonderful, intelligent collaborators on this project step forward and support the cooperative, compatibility-oriented approach of the Omnibus Proposal.\n\nThis is the best way to maximize value for everyone. We have a real opportunity to collaborate and work together on the same team. The Omnibus Proposal, designed in exact accordance with a powerful industry agreement and incorporating the feedback and suggestions provided from within both the developer community and the community-at-large, stands the best chance of uniting everyone under a common front.\n\nPlease, for the love of Bitcoin, let us do our best to cooperate.\n\n[1] https://imgur.com/a/a2oPs\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n-------- Original Message --------\nSubject: Re: [bitcoin-dev] Compatibility-Oriented Omnibus Proposal\nLocal Time: May 29, 2017 6:49 PM\nUTC Time: May 29, 2017 11:49 PM\nFrom: opetruzel at gmail.com\nTo: CalvinRechner <calvinrechner at protonmail.com>\nBitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n\n>>if the community wishes to adopt (by unanimous consensus) a 2 MB block size hardfork, this is probably the best way to do it right now... Legacy Bitcoin transactions are given the witness discount, and a block size limit of 2 MB is imposed.<<\n\nThe above decision may quickly become very controversial. I don't think it's what most users had/have in mind when they discuss a \"2MB+SegWit\" solution.\n\nWith the current 1MB+SegWit, testing has shown us that normal usage results in ~2 or 2.1MB blocks.\n\nI think most users will expect a linear increase when Base Size is increased to 2000000 bytes and Total Weight is increased to 8000000 bytes. With normal usage, the expected results would then be ~4 or 4.2MB blocks.\n\nAm I missing something here, or does Luke's suggested 2MB cap completely nullify that expected linear increase? If so, why? What's the logic behind this decision?\n\nI'd love to be armed with a good answer should my colleagues ask me the same obvious question, so thank you ahead of time!\n\nRespectfully,\nOliver Petruzel\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/8b73d5b3/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Compatibility-Oriented Omnibus Proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Erik Aronesty",
                "Oliver Petruzel",
                "CalvinRechner",
                "James Hilliard"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 37916
        }
    },
    {
        "title": "[bitcoin-dev] Improvement Proposal",
        "thread_messages": [
            {
                "author": "Yann Carlier",
                "date": "2017-05-30T13:48:30",
                "message_text_only": "Improvement Proposal\n\nTo allow users devices  (including mobile and/or IoT devices). to connect\nand some how participate in the same BTC bock chain network without mining.\n\nThe incentive for this participants can be a lottery schema, running in\n\"parallel to mining in the same network\" and in the block-chain.\nRewarding some lucky participant user (and/or miner?) randomly every\nspecific period of time.\n\nParticipants will pay the price on each connection round.\n\nYann\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/ef3602d1/attachment.html>"
            },
            {
                "author": "praxeology_guy",
                "date": "2017-05-30T17:30:55",
                "message_text_only": "Yann, Unfortunately sybil attacks [[https://en.wikipedia.org/wiki/Sybil_attack#Description]](https://en.wikipedia.org/wiki/Sybil_attack#Description) would prevent this from working... even if there was some way to prove that an entity performed the transaction validation. Proving the relay of transaction data to others is also vulnerable to sybil attack.\n\n-------- Original Message --------\nSubject: [bitcoin-dev] Improvement Proposal\nLocal Time: May 30, 2017 8:48 AM\nUTC Time: May 30, 2017 1:48 PM\nFrom: bitcoin-dev at lists.linuxfoundation.org\nTo: bitcoin-dev at lists.linuxfoundation.org\n\nImprovement Proposal\n\nTo allow users devices  (including mobile and/or IoT devices). to connect and some how participate in the same BTC bock chain network without mining.\n\nThe incentive for this participants can be a lottery schema, running in \"parallel to mining in the same network\" and in the block-chain.\nRewarding some lucky participant user (and/or miner?) randomly every specific period of time.\n\nParticipants will pay the price on each connection round.\n\nYann\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170530/773e2132/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Improvement Proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Yann Carlier",
                "praxeology_guy"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1901
        }
    }
]