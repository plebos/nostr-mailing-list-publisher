[
    {
        "title": "[bitcoin-dev] Adding xpub field to PSBT to make multisig more secure",
        "thread_messages": [
            {
                "author": "Andrew Chow",
                "date": "2019-05-01T16:57:38",
                "message_text_only": "Hi Stepan,\n\nI think that this would be a good extension.\n\nJust for clairty, by xpub, do you mean the extended serialization format \ndefined in BIP 32 or the Base58 check encoded string of that serialization?\n\nAndrew\n\nOn 4/26/19 11:21 AM, Stepan Snigirev via bitcoin-dev wrote:\n> Hi list,\n>\n> I was looking at the bip174 PSBT specs, in particular for \n> multisignature setup, and I think with current spec there is a way to \n> steal user funds in M of N setup with M \u2264 N/2.\n>\n> I made a small write-up on this: \n> https://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md\n>\n> To compress:\n>\n> Currently in PSBT there is no way to reliably say if the output uses \n> the keys derived from the same root keys as the inputs aside from the \n> key owned by the signer => there is no way to verify that the output \n> is a change output in multisig setup.\n>\n> Therefore an attacker can replace half of the keys in the change \n> address by his own keys and still get the transaction signed.\n>\n> I suggest to add an xpub field to the inputs and outputs metadata, \n> then signers can verify that the same xpubs are used for public keys \n> in inputs and outputs => output is indeed a change.\n>\n> Normally change and receiving addresses are derived from the same xpub \n> with non-hardened derivation pathes, so providing xpub after the last \n> hardened index should be enough to see that public keys of inputs and \n> change output are derived from the same xpub.\n>\n> I suggest to add the following key-value pairs to PSBT:\n>\n> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`\n> - Key: derivation path for xpub\n> \u00a0 `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n> - Value: 78-byte xpub value\n> \u00a0 `{xpub}`\n>\n> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`\n> - Key: derivation path for xpub\n> \u00a0 `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n> - Value: 78-byte xpub value\n> \u00a0 `{xpub}`\n>\n> Derivation paths are in the key of the key-value pair as they are used \n> for lookup, and xpub itself is the actual value being looked up.\n>\n> I also want to mention that Trezor for example doesn't suffer from \n> this problem as they use xpubs to verify change outputs. So it may \n> make sense to go through the communication protocols of existing \n> hardware / multisignature wallets and see if there is something else \n> we are missing.\n>\n> If everyone is happy about the proposal I would prepare a pull request \n> to the bip.\n>\n> Best regards,\n> Stepan Snigirev.\n>"
            },
            {
                "author": "Peter D. Gray",
                "date": "2019-05-03T13:29:45",
                "message_text_only": "On Fri, Apr 26, 2019 at 05:21:06PM +0200, Stepan Snigirev wrote:\n...\n> Currently in PSBT there is no way to reliably say if the output uses the\n> keys derived from the same root keys as the inputs aside from the key owned\n\nWriting the multisig support for Coldcard, I've come to the same conclusion. I've\nexchanged some helpful mail with Andrew Chow on this subject.\n\n...\n> I suggest to add the following key-value pairs to PSBT:\n> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`\n...\n> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`\n\nI'd rather see the xpubs shared in the global section of the file,\nwith the restriction that they must/should only include the hardened\nprefix of the path. The existing bip32 derivation path included in\nindividual inputs and outputs be merged in as needed.\n\nAfter all in a typical PSBT, we would expect the same master keys\nto be used on all inputs, and at least one output, and there might\nbe as many as 20 co-signers. No need to repeat all that information.\n\nEven with this additions to the PSBT format, I think PSBT-signing\ndevices still need to store the xpubs of their co-signers. It's not\npossible to safely show an incoming address to the user without a\nfull understanding of the other keys in a \"multisig wallet\". Also,\nit represents data that should not change between PSBT instances\n(ie. tomorrow's co-signers should match today's).\n\nHaving said that, the xpubs in the PSBT would allow a \"trust on first\nuse\" which I think can be a good feature.\n\n---\nPeter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10\n\n\n> Hi list,\n> \n> I was looking at the bip174 PSBT specs, in particular for multisignature\n> setup, and I think with current spec there is a way to steal user funds in\n> M of N setup with M \u2264 N/2.\n> \n> I made a small write-up on this:\n> https://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md\n> \n> To compress:\n> \n> Currently in PSBT there is no way to reliably say if the output uses the\n> keys derived from the same root keys as the inputs aside from the key owned\n> by the signer => there is no way to verify that the output is a change\n> output in multisig setup.\n> \n> Therefore an attacker can replace half of the keys in the change address by\n> his own keys and still get the transaction signed.\n> \n> I suggest to add an xpub field to the inputs and outputs metadata, then\n> signers can verify that the same xpubs are used for public keys in inputs\n> and outputs => output is indeed a change.\n> \n> Normally change and receiving addresses are derived from the same xpub with\n> non-hardened derivation pathes, so providing xpub after the last hardened\n> index should be enough to see that public keys of inputs and change output\n> are derived from the same xpub.\n> \n> I suggest to add the following key-value pairs to PSBT:\n> \n> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`\n> - Key: derivation path for xpub\n>   `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n> - Value: 78-byte xpub value\n>   `{xpub}`\n> \n> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`\n> - Key: derivation path for xpub\n>   `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`\n> - Value: 78-byte xpub value\n>   `{xpub}`\n> \n> Derivation paths are in the key of the key-value pair as they are used for\n> lookup, and xpub itself is the actual value being looked up.\n> \n> I also want to mention that Trezor for example doesn't suffer from this\n> problem as they use xpubs to verify change outputs. So it may make sense to\n> go through the communication protocols of existing hardware /\n> multisignature wallets and see if there is something else we are missing.\n> \n> If everyone is happy about the proposal I would prepare a pull request to\n> the bip.\n> \n> Best regards,\n> Stepan Snigirev."
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-05-07T09:23:44",
                "message_text_only": "> I'd rather see the xpubs shared in the global section of the file,\n> with the restriction that they must/should only include the hardened\n> prefix of the path. The existing bip32 derivation path included in\n> individual inputs and outputs be merged in as needed.\n> After all in a typical PSBT, we would expect the same master keys\n> to be used on all inputs, and at least one output, and there might\n> be as many as 20 co-signers. No need to repeat all that information.\n\nI agree that it makes sense to put xpubs to the global scope.\nBut I am not sure that restricting xpubs to have only hardened derivation\nis necessary.\nPeople may want to share non-hardened xpubs with co-signers and keep parent\nxpub on there watch-only wallet.\nFor example, in bip45 cosigner_index is not hardened, and sharing top level\nxpub is not necessary.\n\n> Even with this additions to the PSBT format, I think PSBT-signing\n> devices still need to store the xpubs of their co-signers. It's not\n> possible to safely show an incoming address to the user without a\n> full understanding of the other keys in a \"multisig wallet\". Also,\n> it represents data that should not change between PSBT instances\n> (ie. tomorrow's co-signers should match today's).\n\nI would like to keep hardware wallets state-less, otherwise wiping and\nrecovering them would be problematic.\nAt the setup phase the user can verify a multisignature address (or xpub)\non the screens of all devices,\nafter that we just need to verify that xpubs in the inputs and in the\nchange output are the same.\n\nAndrew, regarding your question:\n> Just for clairty, by xpub, do you mean the extended serialization format\n> defined in BIP 32 or the Base58 check encoded string of that\nserialization?\n\nAs PSBT is a binary format I think it makes sense to use extension\nserialization format without any encodings.\nI am not sure if we need the whole xpub or keeping chain_code and\npublic_key is enough, but I would suggest to keep other data\njust in case. For example, keeping prefix that defines if the key is used\nfor testnet or mainnet may be useful.\n\nBest regards,\nStepan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190507/8cc9e1f1/attachment.html>"
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-05-07T13:40:34",
                "message_text_only": "> > Even with this additions to the PSBT format, I think PSBT-signing\n> > devices still need to store the xpubs of their co-signers. It's not\n> > possible to safely show an incoming address to the user without a\n> > full understanding of the other keys in a \"multisig wallet\". Also,\n> > it represents data that should not change between PSBT instances\n> > (ie. tomorrow's co-signers should match today's).\n> \n> I would like to keep hardware wallets state-less, otherwise wiping and\n> recovering them would be problematic.\n> At the setup phase the user can verify a multisignature address (or\n> xpub) on the screens of all devices,\n> after that we just need to verify that xpubs in the inputs and in the\n> change output are the same.\n\nAt the setup phase, hardware wallet can sign a message that consists of\nxpubs of participants, and some auxiliary text. It can use the key\nderived from the master key, with path chosen specifically for this\npurpose.\n\nHardware wallet then gives out this signature to the software.\n\nThe software will store the message and the signature (or maybe it can\ntake xpubs from PSBT), and will send this 'trusted-xpub-package' to\nhardware wallet along with the transaction.\n\nHardware wallet can then verify that the message is indeed signed by\nthe key for that purpose, and then can mark the ouputs that use the\npubkeys derived from 'verified' xpubs as 'trusted' outputs. It can also\ndisplay the auxiliary text along with the information about the\n'trusted' output.\n\nThis way, hardware wallet does not need to store anything extra besides\nthe master key.\n\nThis would allow to distinguish the trusted output even if the inputs\nare not all derived from the same set of xpubs, that could happen in\nmore complex scenarios (batching, key rotation, etc.), and can possibly\nbe used to have several different types of 'trusted' outputs.\n\nIf the user loses the signature for trusted-xpub-package, the signature\ncan be re-created again - but maybe the procedure should be more\ninvolved than ordinary signing, because creating creating such\n'trusted-xpub-package' with malicious keys can enable attackers to\nbypass these checks."
            },
            {
                "author": "jan matejek",
                "date": "2019-05-08T07:54:53",
                "message_text_only": "hello,\n\nOn 07. 05. 19 15:40, Dmitry Petukhov via bitcoin-dev wrote:\n> At the setup phase, hardware wallet can sign a message that consists of\n> xpubs of participants, and some auxiliary text. It can use the key\n> derived from the master key, with path chosen specifically for this\n> purpose.\n\nThis seems overly complicated.\n\nWhat is your threat model?\n\nIIUC, each individual multisig signature also signs the set of signers\n(through signing redeem-script (or scriptPubKey in address-based multisig))\nSo if an attacker gives me bad xpubs, i will sign them, but the\nsignature won't be valid for the given multisig output - even if the\nattacker manages to trick 2 of 3 signers and recombine their signatures.\n\nTherefore, the input==output check is sufficient: if I use the same set\nof signers for an input and an output, I can be sure that the change\ngoes to the same multisig wallet.\n\nOr is there something I'm missing?\n\nThe weak spot is the part where you generate receiving address, because\nthat \"creates\" the particular multisig wallet. But that's nothing to do\nwith PSBT.\n\n> This would allow to distinguish the trusted output even if the inputs\n> are not all derived from the same set of xpubs, that could happen in\n> more complex scenarios (batching, key rotation, etc.), and can possibly\n> be used to have several different types of 'trusted' outputs.\n\nThis seems to be an attempt at a different, much broader problem. And it\nwon't help if the attacker can replay a different trusted-xpub package\n(e.g., one that contains a revoked previously compromised key).\n\nregards\nm."
            },
            {
                "author": "Dmitry Petukhov",
                "date": "2019-05-09T17:08:47",
                "message_text_only": "> Therefore, the input==output check is sufficient: if I use the same\n> set of signers for an input and an output, I can be sure that the\n> change goes to the same multisig wallet.\n\nThis is sufficient, in a simple case.\n\nI consider cases where spending from different wallets ('wallet\ncompartments') can be aggregated into one transaction, for efficiency\nand convenience in certain circumstances. (ex: legacy addresses that\ncannot be abandoned due to users still sending to them, but managing\nthem separately is inconvenient; wallet 'compartments' that each have\ndifferent multisig policies and spending priorities, and change would\ngo to most secure compartment used, etc.)\n\nThis is most likely a 'borader problem', as you said, but this is just\nwhat my code already does, although with stateful signers that\nstore trusted xpubs. I had an idea how to apply this to stateless hw\nwallets, and shared it.\n\n> > This would allow to distinguish the trusted output even if the\n> > inputs are not all derived from the same set of xpubs, that could\n> > happen in more complex scenarios (batching, key rotation, etc.),\n> > and can possibly be used to have several different types of\n> > 'trusted' outputs.\n> \n> This seems to be an attempt at a different, much broader problem. And\n> it won't help if the attacker can replay a different trusted-xpub\n> package (e.g., one that contains a revoked previously compromised\n> key).\n\nThe auxiliary text can be constructed to include some code word that\nwould mark 'epoch' of the package, and will be displayed prominently.\nUpon compromise, new trusted-xpub packages would use different 'epoch'\ncode word. This is one method to make it stateless (stateful way would\nbe to just have a counter inside hw wallet and check package version\nagainst it)."
            }
        ],
        "thread_summary": {
            "title": "Adding xpub field to PSBT to make multisig more secure",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Stepan Snigirev",
                "Peter D. Gray",
                "jan matejek",
                "Andrew Chow",
                "Dmitry Petukhov"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 14089
        }
    },
    {
        "title": "[bitcoin-dev] IsStandard",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-02T00:10:37",
                "message_text_only": "Good morning Aymeric,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n\n> I must badly explain my point (or just wondering things that do not\n> exist finally), the question is indeed whether nodes will relay non\n> usual transactions or not and how to know what they will accept or not:\n>\n> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem\n>     script, the redeem script still matches scriptpubkey and scriptsig will\n>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH\n>\n> -   bch segwit recovery: it's a p2sh transaction without any signature\n>     verification, as far as I remember there was a story that it could not\n>     propagate in the network (even taking the risk to be stolen) and that\n>     people had to contact a (honest) miner\n>\n> -   sha bounties: same as above, p2sh transactions without signatures\n>\n>     etc\n>\n>     Will all of those transactions propagate normally? And then the rule is\n>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates\n>     whatever scripts you put inside?\n\nP2PKH and P2WPKH cannot have custom script.\nHowever, yes, any custom script can be wrapped in P2SH and P2WSH and it will be propagated.\nThe P2SH/P2WSH hides the details of your custom script so cannot be filtered based on your custom script.\nDo realize that once a claim on your modified x-of-3 is propagated your `redeemScript` is known and someone can attempt to RBF (or coordinate with a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.\n(I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of your signatories could make it a 1-of-3 and bribe a miner to get it claimed)\n\nI cannot answer for BCH; arguably that is off-topic here.\n\nThe old SHA bounty transactions were propagated in the days before `isStandard` I think.\nEither that or they were put in by miners.\nAn SHA bounty can still be propagated today if they are wrapped in a P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some other method.\nOr bribe a miner if the transaction is not time-sensitive (for an SHA bounty, unlikely to be time-sensitive).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-02T10:01:54",
                "message_text_only": "Thanks for the answer, indeed for the redeem script and someone\nattempting a 0/1 of 3, good example\n\nSo to summarize everything is standard as long as it matches P2PKH,\nP2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in\nop_return\n\nStill the case of bch is unclear (it's related since based on bitcoin\ncode unless they changed the policy), was the story that nodes would not\npropagate the fix or that people did not want to take the risk to\npropagate it? And why a non segwit old bitcoin node would not accept it\neither?\n\nLe 02/05/2019 \u00e0 02:10, ZmnSCPxj a \u00e9crit\u00a0:\n> Good morning Aymeric,\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>\n>> I must badly explain my point (or just wondering things that do not\n>> exist finally), the question is indeed whether nodes will relay non\n>> usual transactions or not and how to know what they will accept or not:\n>>\n>> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem\n>>     script, the redeem script still matches scriptpubkey and scriptsig will\n>>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH\n>>\n>> -   bch segwit recovery: it's a p2sh transaction without any signature\n>>     verification, as far as I remember there was a story that it could not\n>>     propagate in the network (even taking the risk to be stolen) and that\n>>     people had to contact a (honest) miner\n>>\n>> -   sha bounties: same as above, p2sh transactions without signatures\n>>\n>>     etc\n>>\n>>     Will all of those transactions propagate normally? And then the rule is\n>>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates\n>>     whatever scripts you put inside?\n> P2PKH and P2WPKH cannot have custom script.\n> However, yes, any custom script can be wrapped in P2SH and P2WSH and it will be propagated.\n> The P2SH/P2WSH hides the details of your custom script so cannot be filtered based on your custom script.\n> Do realize that once a claim on your modified x-of-3 is propagated your `redeemScript` is known and someone can attempt to RBF (or coordinate with a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.\n> (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of your signatories could make it a 1-of-3 and bribe a miner to get it claimed)\n>\n> I cannot answer for BCH; arguably that is off-topic here.\n>\n> The old SHA bounty transactions were propagated in the days before `isStandard` I think.\n> Either that or they were put in by miners.\n> An SHA bounty can still be propagated today if they are wrapped in a P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some other method.\n> Or bribe a miner if the transaction is not time-sensitive (for an SHA bounty, unlikely to be time-sensitive).\n>\n> Regards,\n> ZmnSCPxj\n\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "James Prestwich",
                "date": "2019-05-02T23:33:09",
                "message_text_only": "Hi Aymeric,\n\nAs Luke and ZmnSCPxj have pointed out, documenting standardness is\nsisyphean, as it varies from version to version. I recently put together a\nreference for default TX_NONSTANDARD policies in v0.18, which can be found\nhere: https://prestwi.ch/the-bitcoin-nonstandard/\n\nIt applies only to v0.18, and may already be outdated.\n\nBest,\nJames\n\nOn Thu, May 2, 2019 at 4:29 PM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for the answer, indeed for the redeem script and someone\n> attempting a 0/1 of 3, good example\n>\n> So to summarize everything is standard as long as it matches P2PKH,\n> P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in\n> op_return\n>\n> Still the case of bch is unclear (it's related since based on bitcoin\n> code unless they changed the policy), was the story that nodes would not\n> propagate the fix or that people did not want to take the risk to\n> propagate it? And why a non segwit old bitcoin node would not accept it\n> either?\n>\n> Le 02/05/2019 \u00e0 02:10, ZmnSCPxj a \u00e9crit :\n> > Good morning Aymeric,\n> >\n> >\n> > Sent with ProtonMail Secure Email.\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <\n> vitteaymeric at gmail.com> wrote:\n> >\n> >> I must badly explain my point (or just wondering things that do not\n> >> exist finally), the question is indeed whether nodes will relay non\n> >> usual transactions or not and how to know what they will accept or not:\n> >>\n> >> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem\n> >>     script, the redeem script still matches scriptpubkey and scriptsig\n> will\n> >>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH\n> >>\n> >> -   bch segwit recovery: it's a p2sh transaction without any signature\n> >>     verification, as far as I remember there was a story that it could\n> not\n> >>     propagate in the network (even taking the risk to be stolen) and\n> that\n> >>     people had to contact a (honest) miner\n> >>\n> >> -   sha bounties: same as above, p2sh transactions without signatures\n> >>\n> >>     etc\n> >>\n> >>     Will all of those transactions propagate normally? And then the\n> rule is\n> >>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates\n> >>     whatever scripts you put inside?\n> > P2PKH and P2WPKH cannot have custom script.\n> > However, yes, any custom script can be wrapped in P2SH and P2WSH and it\n> will be propagated.\n> > The P2SH/P2WSH hides the details of your custom script so cannot be\n> filtered based on your custom script.\n> > Do realize that once a claim on your modified x-of-3 is propagated your\n> `redeemScript` is known and someone can attempt to RBF (or coordinate with\n> a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.\n> > (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of\n> your signatories could make it a 1-of-3 and bribe a miner to get it claimed)\n> >\n> > I cannot answer for BCH; arguably that is off-topic here.\n> >\n> > The old SHA bounty transactions were propagated in the days before\n> `isStandard` I think.\n> > Either that or they were put in by miners.\n> > An SHA bounty can still be propagated today if they are wrapped in a\n> P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some\n> other method.\n> > Or bribe a miner if the transaction is not time-sensitive (for an SHA\n> bounty, unlikely to be time-sensitive).\n> >\n> > Regards,\n> > ZmnSCPxj\n>\n> --\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple:\n> https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist:\n> http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor <https://github.com/Ayms/torrent-livenode-Tor> :\n> https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190502/4a39edaa/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-03T09:51:25",
                "message_text_only": "Great doc, thanks, then my previous summarized conclusion was wrong,\ntrying on my side to write a \"demistifying (simply) once for all bitcoin\nscripting\", not sure that \"simply\" can stay in the title at the end...\n\nSo my multisig modification is non standard, now I am still puzzled by\nsomething, mainly the fact that we have op_pushdata inside op_pushdata,\nmaybe I am misreading the specs, but in case of p2sh only the last\nop_pushdata (called {serialized script} (or redeem script) is executed,\nthen if succesfull it comes back onto the stack and scriptpubkey is executed\n\nSo, let's take again the BCH recovery example, scriptSig was OP_PUSHDATA\n0014<hash160 of pubkey>, and scriptPubKey OP_HASH160 <hash160 of\n0014<hash160 of pubkey> OP_EQUAL, then scriptSig executes pushing\nnothing and <hash160 of pubkey> into the stack, then scriptSig is pushed\nagain and executed with scriptPubKey, at the end we get nothing +\n<hash160 of pubkey> + 1 in the stack, then cleanstack (maybe among\nothers, I have to read in more details your doc) says it is a correct\ntransaction but non standard, is this correct?\n\nLe 03/05/2019 \u00e0 01:33, James Prestwich a \u00e9crit\u00a0:\n> Hi Aymeric,\u00a0\n>\n> As Luke and ZmnSCPxj have pointed out, documenting standardness is\n> sisyphean, as it varies from version to version. I recently put\n> together a reference for default TX_NONSTANDARD policies in v0.18,\n> which can be found here:\u00a0https://prestwi.ch/the-bitcoin-nonstandard/\u00a0\n>\n> It applies only to v0.18, and may already be outdated.\n>\n> Best,\n> James\n>\n> On Thu, May 2, 2019 at 4:29 PM Aymeric Vitte via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     Thanks for the answer, indeed for the redeem script and someone\n>     attempting a 0/1 of 3, good example\n>\n>     So to summarize everything is standard as long as it matches P2PKH,\n>     P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in\n>     op_return\n>\n>     Still the case of bch is unclear (it's related since based on bitcoin\n>     code unless they changed the policy), was the story that nodes\n>     would not\n>     propagate the fix or that people did not want to take the risk to\n>     propagate it? And why a non segwit old bitcoin node would not\n>     accept it\n>     either?\n>\n>     Le 02/05/2019 \u00e0 02:10, ZmnSCPxj a \u00e9crit\u00a0:\n>     > Good morning Aymeric,\n>     >\n>     >\n>     > Sent with ProtonMail Secure Email.\n>     >\n>     > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>     > On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte\n>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:\n>     >\n>     >> I must badly explain my point (or just wondering things that do not\n>     >> exist finally), the question is indeed whether nodes will relay non\n>     >> usual transactions or not and how to know what they will accept\n>     or not:\n>     >>\n>     >> -\u00a0 \u00a0my modified multisig 2 of 3: I did put OP_2 out of the\n>     usual redeem\n>     >>\u00a0 \u00a0 \u00a0script, the redeem script still matches scriptpubkey and\n>     scriptsig will\n>     >>\u00a0 \u00a0 \u00a0execute succesfully, that's a normal legacy P2SH or segwit\n>     P2WSH\n>     >>\n>     >> -\u00a0 \u00a0bch segwit recovery: it's a p2sh transaction without any\n>     signature\n>     >>\u00a0 \u00a0 \u00a0verification, as far as I remember there was a story that\n>     it could not\n>     >>\u00a0 \u00a0 \u00a0propagate in the network (even taking the risk to be\n>     stolen) and that\n>     >>\u00a0 \u00a0 \u00a0people had to contact a (honest) miner\n>     >>\n>     >> -\u00a0 \u00a0sha bounties: same as above, p2sh transactions without\n>     signatures\n>     >>\n>     >>\u00a0 \u00a0 \u00a0etc\n>     >>\n>     >>\u00a0 \u00a0 \u00a0Will all of those transactions propagate normally? And then\n>     the rule is\n>     >>\u00a0 \u00a0 \u00a0just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH\n>     templates\n>     >>\u00a0 \u00a0 \u00a0whatever scripts you put inside?\n>     > P2PKH and P2WPKH cannot have custom script.\n>     > However, yes, any custom script can be wrapped in P2SH and P2WSH\n>     and it will be propagated.\n>     > The P2SH/P2WSH hides the details of your custom script so cannot\n>     be filtered based on your custom script.\n>     > Do realize that once a claim on your modified x-of-3 is\n>     propagated your `redeemScript` is known and someone can attempt to\n>     RBF (or coordinate with a miner) with a modified `witness` stack\n>     or `scriptSig` to claim your UTXO.\n>     > (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at\n>     least one of your signatories could make it a 1-of-3 and bribe a\n>     miner to get it claimed)\n>     >\n>     > I cannot answer for BCH; arguably that is off-topic here.\n>     >\n>     > The old SHA bounty transactions were propagated in the days\n>     before `isStandard` I think.\n>     > Either that or they were put in by miners.\n>     > An SHA bounty can still be propagated today if they are wrapped\n>     in a P2SH or P2WSH, but you have to publish the `redeemScript`\n>     yourself in some other method.\n>     > Or bribe a miner if the transaction is not time-sensitive (for\n>     an SHA bounty, unlikely to be time-sensitive).\n>     >\n>     > Regards,\n>     > ZmnSCPxj\n>\n>     -- \n>     Move your coins by yourself (browser version):\n>     https://peersm.com/wallet\n>     Bitcoin transactions made simple:\n>     https://github.com/Ayms/bitcoin-transactions\n>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n>     Check the 10 M passwords list: http://peersm.com/findmyass\n>     Anti-spies and private torrents, dynamic blocklist:\n>     http://torrent-live.org\n>     Peersm : http://www.peersm.com\n>     torrent-live: https://github.com/Ayms/torrent-live\n>     node-Tor <https://github.com/Ayms/torrent-livenode-Tor> :\n>     https://www.github.com/Ayms/node-Tor\n>     GitHub : https://www.github.com/Ayms\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190503/fa40d55f/attachment-0001.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-05-02T23:35:06",
                "message_text_only": "On Thu, 2 May 2019 at 16:28, Aymeric Vitte via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Thanks for the answer, indeed for the redeem script and someone\n> attempting a 0/1 of 3, good example\n>\n> So to summarize everything is standard as long as it matches P2PKH,\n> P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in\n> op_return\n\nGenerally, all spends of P2SH/P2WSH is standard, with the following exceptions:\n* Non-push operations in the scriptSig\n* Resource limitations (too large scripts or items on the stack)\n* Protections against known attack vectors (low s rule, cleanstack\nrule, minimally encoded numbers rule, codesep usage, ...)\n* Usage of unconditionally spendable constructions intended for future\nextensions, such as spending future segwit versions.\n\nCheers,\n\n-- \nPieter"
            }
        ],
        "thread_summary": {
            "title": "IsStandard",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Pieter Wuille",
                "James Prestwich",
                "Aymeric Vitte"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 18277
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.18.0 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2019-05-02T08:11:03",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.18.0 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.18.0/>\n\nor through bittorrent:\n\n    magnet:?xt=urn:btih:a25c86ffa7a512b6d074287f74762b77f91cef4c&dn=bitcoin-core-0.18.0&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n\nThis is a new major version release, including new features, various bug\nfixes and performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has\ncompletely shut down (which might take a few minutes for older\nversions), then run the installer (on Windows) or just copy over\n`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on\nLinux).\n\nThe first time you run version 0.15.0 or newer, your chainstate database\nwill be converted to a new format, which will take anywhere from a few\nminutes to half an hour, depending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and\nthere is no automatic upgrade code from before version 0.8 to version\n0.15.0 or later. Upgrading directly from 0.7.x and earlier without\nredownloading the blockchain is not supported.  However, as usual, old\nwallet versions are still supported.\n\nCompatibility\n==============\n\nBitcoin Core is supported and extensively tested on operating systems\nusing the Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not\nrecommended to use Bitcoin Core on unsupported systems.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nas frequently tested on them.\n\n- From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is\nbuilt using Qt 5.9.x, which doesn't support versions of macOS older than\n10.10. Additionally, Bitcoin Core does not yet change appearance when\nmacOS \"dark mode\" is activated.\n\nIn addition to previously-supported CPU platforms, this release's\npre-compiled distribution also provides binaries for the RISC-V\nplatform.\n\nIf you are using the `systemd` unit configuration file located at\n`contrib/init/bitcoind.service`, it has been changed to use\n`/var/lib/bitcoind` as the data directory instead of\n`~bitcoin/.bitcoin`. When switching over to the new configuration file,\nplease make sure that the filesystem on which `/var/lib/bitcoind` will\nexist has enough space (check using `df -h /var/lib/bitcoind`), and\noptionally copy over your existing data directory. See the [systemd init\nfile section](#systemd-init-file) for more details.\n\nKnown issues\n============\n\nWallet GUI\n- ----------\n\nFor advanced users who have both (1) enabled coin control features, and\n(2) are using multiple wallets loaded at the same time: The coin control\ninput selection dialog can erroneously retain wrong-wallet state when\nswitching wallets using the dropdown menu. For now, it is recommended\nnot to use coin control features with multiple wallets loaded.\n\nNotable changes\n===============\n\nMining\n- ------\n\n- - Calls to `getblocktemplate` will fail if the segwit rule is not\n  specified.  Calling `getblocktemplate` without segwit specified is\n  almost certainly a misconfiguration since doing so results in lower\n  rewards for the miner.  Failed calls will produce an error message\n  describing how to enable the segwit rule.\n\nConfiguration option changes\n- ----------------------------\n\n- - A warning is printed if an unrecognized section name is used in the\n  configuration file.  Recognized sections are `[test]`, `[main]`, and\n  `[regtest]`.\n\n- - Four new options are available for configuring the maximum number of\n  messages that ZMQ will queue in memory (the \"high water mark\") before\n  dropping additional messages.  The default value is 1,000, the same as\n  was used for previous releases.  See the [ZMQ\n  documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/zmq.md#usage)\n  for details.\n\n- - The `rpcallowip` option can no longer be used to automatically listen\n  on all network interfaces.  Instead, the `rpcbind` parameter must be\n  used to specify the IP addresses to listen on.  Listening for RPC\n  commands over a public network connection is insecure and should be\n  disabled, so a warning is now printed if a user selects such a\n  configuration.  If you need to expose RPC in order to use a tool like\n  Docker, ensure you only bind RPC to your localhost, e.g. `docker run\n  [...] -p 127.0.0.1:8332:8332` (this is an extra `:8332` over the\n  normal Docker port specification).\n\n- - The `rpcpassword` option now causes a startup error if the password\n  set in the configuration file contains a hash character (#), as it's\n  ambiguous whether the hash character is meant for the password or as a\n  comment.\n\n- - The `whitelistforcerelay` option is used to relay transactions from\n  whitelisted peers even when not accepted to the mempool. This option\n  now defaults to being off, so that changes in policy and\n  disconnect/ban behavior will not cause a node that is whitelisting\n  another to be dropped by peers.  Users can still explicitly enable\n  this behavior with the command line option (and may want to consider\n  [contacting](https://bitcoincore.org/en/contact/) the Bitcoin Core\n  project to let us know about their use-case, as this feature could be\n  deprecated in the future).\n\nsystemd init file\n- -----------------\n\nThe systemd init file (`contrib/init/bitcoind.service`) has been changed\nto use `/var/lib/bitcoind` as the data directory instead of\n`~bitcoin/.bitcoin`. This change makes Bitcoin Core more consistent with\nother services, and makes the systemd init config more consistent with\nexisting Upstart and OpenRC configs.\n\nThe configuration, PID, and data directories are now completely managed\nby systemd, which will take care of their creation, permissions, etc.\nSee [`systemd.exec(5)`](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RuntimeDirectory=)\nfor more details.\n\nWhen using the provided init files under `contrib/init`, overriding the\n`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect.\nThis is because the command line arguments specified in the init files\ntake precedence over the options specified in\n`/etc/bitcoin/bitcoin.conf`.\n\n\nDocumentation\n- -------------\n\n- - A new short [document](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)\n  about the JSON-RPC interface describes cases where the results of an\n  RPC might contain inconsistencies between data sourced from different\n  subsystems, such as wallet state and mempool state.  A note is added\n  to the [REST interface documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md)\n  indicating that the same rules apply.\n\n- - Further information is added to the [JSON-RPC\n  documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)\n  about how to secure this interface.\n\n- - A new [document](https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md)\n  about the `bitcoin.conf` file describes how to use it to configure\n  Bitcoin Core.\n\n- - A new document introduces Bitcoin Core's BIP174 [Partially-Signed\n  Bitcoin Transactions\n  (PSBT)](https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md)\n  interface, which is used to allow multiple programs to collaboratively\n  work to create, sign, and broadcast new transactions.  This is useful\n  for offline (cold storage) wallets, multisig wallets, coinjoin\n  implementations, and many other cases where two or more programs need\n  to interact to generate a complete transaction.\n\n- - The [output script\n  descriptor](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)\n  documentation has been updated with information about new features in\n  this still-developing language for describing the output scripts that\n  a wallet or other program wants to receive notifications for, such as\n  which addresses it wants to know received payments.  The language is\n  currently used in multiple new and updated RPCs described in these\n  release notes and is expected to be adapted to other RPCs and to the\n  underlying wallet structure.\n\nBuild system changes\n- --------------------\n\n- - A new `--disable-bip70` option may be passed to `./configure` to\n  prevent Bitcoin-Qt from being built with support for the BIP70 payment\n  protocol or from linking libssl.  As the payment protocol has exposed\n  Bitcoin Core to libssl vulnerabilities in the past, builders who don't\n  need BIP70 support are encouraged to use this option to reduce their\n  exposure to future vulnerabilities.\n\n- - The minimum required version of Qt (when building the GUI) has been\n  increased from 5.2 to 5.5.1 (the [depends\n  system](https://github.com/bitcoin/bitcoin/blob/master/depends/README.md)\n  provides 5.9.7)\n\nNew RPCs\n- --------\n\n- - `getnodeaddresses` returns peer addresses known to this node. It may\n  be used to find nodes to connect to without using a DNS seeder.\n\n- - `listwalletdir` returns a list of wallets in the wallet directory\n  (either the default wallet directory or the directory configured by\n  the `-walletdir` parameter).\n\n- - `getrpcinfo` returns runtime details of the RPC server. At the moment,\n  it returns an array of the currently active commands and how long\n  they've been running.\n\n- - `deriveaddresses` returns one or more addresses corresponding to an\n  [output descriptor](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).\n\n- - `getdescriptorinfo` accepts a descriptor and returns information about\n  it, including its computed checksum.\n\n- - `joinpsbts` merges multiple distinct PSBTs into a single PSBT. The\n  multiple PSBTs must have different inputs. The resulting PSBT will\n  contain every input and output from all of the PSBTs. Any signatures\n  provided in any of the PSBTs will be dropped.\n\n- - `analyzepsbt` examines a PSBT and provides information about what\n  the PSBT contains and the next steps that need to be taken in order\n  to complete the transaction. For each input of a PSBT, `analyzepsbt`\n  provides information about what information is missing for that\n  input, including whether a UTXO needs to be provided, what pubkeys\n  still need to be provided, which scripts need to be provided, and\n  what signatures are still needed. Every input will also list which\n  role is needed to complete that input, and `analyzepsbt` will also\n  list the next role in general needed to complete the PSBT.\n  `analyzepsbt` will also provide the estimated fee rate and estimated\n  virtual size of the completed transaction if it has enough\n  information to do so.\n\n- - `utxoupdatepsbt` searches the set of Unspent Transaction Outputs\n  (UTXOs) to find the outputs being spent by the partial transaction.\n  PSBTs need to have the UTXOs being spent to be provided because\n  the signing algorithm requires information from the UTXO being spent.\n  For segwit inputs, only the UTXO itself is necessary.  For\n  non-segwit outputs, the entire previous transaction is needed so\n  that signers can be sure that they are signing the correct thing.\n  Unfortunately, because the UTXO set only contains UTXOs and not full\n  transactions, `utxoupdatepsbt` will only add the UTXO for segwit\n  inputs.\n\nUpdated RPCs\n- ------------\n\nNote: some low-level RPC changes mainly useful for testing are described\nin the Low-level Changes section below.\n\n- - `getpeerinfo` now returns an additional `minfeefilter` field set to\n  the peer's BIP133 fee filter.  You can use this to detect that you\n  have peers that are willing to accept transactions below the default\n  minimum relay fee.\n\n- - The mempool RPCs, such as `getrawmempool` with `verbose=true`, now\n  return an additional \"bip125-replaceable\" value indicating whether the\n  transaction (or its unconfirmed ancestors) opts-in to asking nodes and\n  miners to replace it with a higher-feerate transaction spending any of\n  the same inputs.\n\n- - `settxfee` previously silently ignored attempts to set the fee below\n  the allowed minimums.  It now prints a warning.  The special value of\n  \"0\" may still be used to request the minimum value.\n\n- - `getaddressinfo` now provides an `ischange` field indicating whether\n  the wallet used the address in a change output.\n\n- - `importmulti` has been updated to support P2WSH, P2WPKH, P2SH-P2WPKH,\n  and P2SH-P2WSH. Requests for P2WSH and P2SH-P2WSH accept an additional\n  `witnessscript` parameter.\n\n- - `importmulti` now returns an additional `warnings` field for each\n  request with an array of strings explaining when fields are being\n  ignored or are inconsistent, if there are any.\n\n- - `getaddressinfo` now returns an additional `solvable` boolean field\n  when Bitcoin Core knows enough about the address's scriptPubKey,\n  optional redeemScript, and optional witnessScript in order for the\n  wallet to be able to generate an unsigned input spending funds sent to\n  that address.\n\n- - The `getaddressinfo`, `listunspent`, and `scantxoutset` RPCs now\n  return an additional `desc` field that contains an output descriptor\n  containing all key paths and signing information for the address\n  (except for the private key).  The `desc` field is only returned for\n  `getaddressinfo` and `listunspent` when the address is solvable.\n\n- - `importprivkey` will preserve previously-set labels for addresses or\n  public keys corresponding to the private key being imported.  For\n  example, if you imported a watch-only address with the label \"cold\n  wallet\" in earlier releases of Bitcoin Core, subsequently importing\n  the private key would default to resetting the address's label to the\n  default empty-string label (\"\").  In this release, the previous label\n  of \"cold wallet\" will be retained.  If you optionally specify any\n  label besides the default when calling `importprivkey`, the new label\n  will be applied to the address.\n\n- - See the [Mining](#mining) section for changes to `getblocktemplate`.\n\n- - `getmininginfo` now omits `currentblockweight` and `currentblocktx`\n  when a block was never assembled via RPC on this node.\n\n- - The `getrawtransaction` RPC & REST endpoints no longer check the\n  unspent UTXO set for a transaction. The remaining behaviors are as\n  follows: 1. If a blockhash is provided, check the corresponding block.\n  2. If no blockhash is provided, check the mempool. 3. If no blockhash\n  is provided but txindex is enabled, also check txindex.\n\n- - `unloadwallet` is now synchronous, meaning it will not return until\n  the wallet is fully unloaded.\n\n- - `importmulti` now supports importing of addresses from descriptors. A\n  \"desc\" parameter can be provided instead of the \"scriptPubKey\" in a\n  request, as well as an optional range for ranged descriptors to\n  specify the start and end of the range to import. Descriptors with key\n  origin information imported through `importmulti` will have their key\n  origin information stored in the wallet for use with creating PSBTs.\n  More information about descriptors can be found\n  [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).\n\n- - `listunspent` has been modified so that it also returns\n  `witnessScript`, the witness script in the case of a P2WSH or\n  P2SH-P2WSH output.\n\n- - `createwallet` now has an optional `blank` argument that can be used\n  to create a blank wallet. Blank wallets do not have any keys or HD\n  seed.  They cannot be opened in software older than 0.18. Once a blank\n  wallet has a HD seed set (by using `sethdseed`) or private keys,\n  scripts, addresses, and other watch only things have been imported,\n  the wallet is no longer blank and can be opened in 0.17.x. Encrypting\n  a blank wallet will also set a HD seed for it.\n\nDeprecated or removed RPCs\n- --------------------------\n\n- - `signrawtransaction` is removed after being deprecated and hidden\n  behind a special configuration option in version 0.17.0.\n\n- - The 'account' API is removed after being deprecated in v0.17.  The\n  'label' API was introduced in v0.17 as a replacement for accounts.\n  See the [release notes from\n  v0.17](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.17.0.md#label-and-account-apis-for-wallet)\n  for a full description of the changes from the 'account' API to the\n  'label' API.\n\n- - `addwitnessaddress` is removed after being deprecated in version\n  0.16.0.\n\n- - `generate` is deprecated and will be fully removed in a subsequent\n  major version.  This RPC is only used for testing, but its\n  implementation reached across multiple subsystems (wallet and mining),\n  so it is being deprecated to simplify the wallet-node interface.\n  Projects that are using `generate` for testing purposes should\n  transition to using the `generatetoaddress` RPC, which does not\n  require or use the wallet component. Calling `generatetoaddress` with\n  an address returned by the `getnewaddress` RPC gives the same\n  functionality as the old `generate` RPC.  To continue using `generate`\n  in this version, restart bitcoind with the `-deprecatedrpc=generate`\n  configuration option.\n\n- - Be reminded that parts of the `validateaddress` command have been\n  deprecated and moved to `getaddressinfo`. The following deprecated\n  fields have moved to `getaddressinfo`: `ismine`, `iswatchonly`,\n  `script`, `hex`, `pubkeys`, `sigsrequired`, `pubkey`, `embedded`,\n  `iscompressed`, `label`, `timestamp`, `hdkeypath`, `hdmasterkeyid`.\n\n- - The `addresses` field has been removed from the `validateaddress`\n  and `getaddressinfo` RPC methods.  This field was confusing since\n  it referred to public keys using their P2PKH address.  Clients\n  should use the `embedded.address` field for P2SH or P2WSH wrapped\n  addresses, and `pubkeys` for inspecting multisig participants.\n\nREST changes\n- ------------\n\n- - A new `/rest/blockhashbyheight/` endpoint is added for fetching the\n  hash of the block in the current best blockchain based on its height\n  (how many blocks it is after the Genesis Block).\n\nGraphical User Interface (GUI)\n- ------------------------------\n\n- - A new Window menu is added alongside the existing File, Settings, and\n  Help menus.  Several items from the other menus that opened new\n  windows have been moved to this new Window menu.\n\n- - In the Send tab, the checkbox for \"pay only the required fee\" has been\n  removed.  Instead, the user can simply decrease the value in the\n  Custom Feerate field all the way down to the node's configured minimum\n  relay fee.\n\n- - In the Overview tab, the watch-only balance will be the only balance\n  shown if the wallet was created using the `createwallet` RPC and the\n  `disable_private_keys` parameter was set to true.\n\n- - The launch-on-startup option is no longer available on macOS if\n  compiled with macosx min version greater than 10.11 (use\n  CXXFLAGS=\"-mmacosx-version-min=10.11\"\n  CFLAGS=\"-mmacosx-version-min=10.11\" for setting the deployment sdk\n  version)\n\nTools\n- -----\n\n- - A new `bitcoin-wallet` tool is now distributed alongside Bitcoin\n  Core's other executables.  Without needing to use any RPCs, this tool\n  can currently create a new wallet file or display some basic\n  information about an existing wallet, such as whether the wallet is\n  encrypted, whether it uses an HD seed, how many transactions it\n  contains, and how many address book entries it has.\n\nPlanned changes\n===============\n\nThis section describes planned changes to Bitcoin Core that may affect\nother Bitcoin software and services.\n\n- - Since version 0.16.0, Bitcoin Core\u2019s built-in wallet has defaulted to\n  generating P2SH-wrapped segwit addresses when users want to receive\n  payments. These addresses are backwards compatible with all\n  widely-used software.  Starting with Bitcoin Core 0.20 (expected about\n  a year after 0.18), Bitcoin Core will default to native segwit\n  addresses (bech32) that provide additional fee savings and other\n  benefits. Currently, many wallets and services already support sending\n  to bech32 addresses, and if the Bitcoin Core project sees enough\n  additional adoption, it will instead default to bech32 receiving\n  addresses in Bitcoin Core 0.19 (approximately November 2019).\n  P2SH-wrapped segwit addresses will continue to be provided if the user\n  requests them in the GUI or by RPC, and anyone who doesn\u2019t want the\n  update will be able to configure their default address type.\n  (Similarly, pioneering users who want to change their default now may\n  set the `addresstype=bech32` configuration option in any Bitcoin Core\n  release from 0.16.0 up.)\n\nDeprecated P2P messages\n- -----------------------\n\n- - BIP 61 reject messages are now deprecated. Reject messages have no use\n  case on the P2P network and are only logged for debugging by most\n  network nodes. Furthermore, they increase bandwidth and can be harmful\n  for privacy and security. It has been possible to disable BIP 61\n  messages since v0.17 with the `-enablebip61=0` option. BIP 61 messages\n  will be disabled by default in a future version, before being removed\n  entirely.\n\nLow-level changes\n=================\n\nThis section describes RPC changes mainly useful for testing, mostly not\nrelevant in production. The changes are mentioned for completeness.\n\nRPC\n- ---\n\n- - The `submitblock` RPC previously returned the reason a rejected block\n  was invalid the first time it processed that block, but returned a\n  generic \"duplicate\" rejection message on subsequent occasions it\n  processed the same block.  It now always returns the fundamental\n  reason for rejecting an invalid block and only returns \"duplicate\" for\n  valid blocks it has already accepted.\n\n- - A new `submitheader` RPC allows submitting block headers independently\n  from their block.  This is likely only useful for testing.\n\n- - The `signrawtransactionwithkey` and `signrawtransactionwithwallet`\n  RPCs have been modified so that they also optionally accept a\n  `witnessScript`, the witness script in the case of a P2WSH or\n  P2SH-P2WSH output. This is compatible with the change to\n  `listunspent`.\n\n- - For the `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs, if the\n  `bip32derivs` parameter is set to true but the key metadata for a\n  public key has not been updated yet, then that key will have a\n  derivation path as if it were just an independent key (i.e. no\n  derivation path and its master fingerprint is itself).\n\nConfiguration\n- -------------\n\n- - The `-usehd` configuration option was removed in version 0.16. From\n  that version onwards, all new wallets created are hierarchical\n  deterministic wallets. This release makes specifying `-usehd` an\n  invalid configuration option.\n\nNetwork\n- -------\n\n- - This release allows peers that your node automatically disconnected\n  for misbehavior (e.g. sending invalid data) to reconnect to your node\n  if you have unused incoming connection slots.  If your slots fill up,\n  a misbehaving node will be disconnected to make room for nodes without\n  a history of problems (unless the misbehaving node helps your node in\n  some other way, such as by connecting to a part of the Internet from\n  which you don't have many other peers).  Previously, Bitcoin Core\n  banned the IP addresses of misbehaving peers for a period of time\n  (default of 1 day); this was easily circumvented by attackers with\n  multiple IP addresses. If you manually ban a peer, such as by using\n  the `setban` RPC, all connections from that peer will still be\n  rejected.\n\nWallet\n- -------\n\n- - The key metadata will need to be upgraded the first time that the HD\n  seed is available.  For unencrypted wallets this will occur on wallet\n  loading.  For encrypted wallets this will occur the first time the\n  wallet is unlocked.\n\n- - Newly encrypted wallets will no longer require restarting the\n  software. Instead such wallets will be completely unloaded and\n  reloaded to achieve the same effect.\n\n- - A sub-project of Bitcoin Core now provides Hardware Wallet Interaction\n  (HWI) scripts that allow command-line users to use several popular\n  hardware key management devices with Bitcoin Core.  See their [project\n  page](https://github.com/bitcoin-core/HWI#readme) for details.\n\nSecurity\n- --------\n\n- - This release changes the Random Number Generator (RNG) used from\n  OpenSSL to Bitcoin Core's own implementation, although entropy\n  gathered by Bitcoin Core is fed out to OpenSSL and then read back in\n  when the program needs strong randomness. This moves Bitcoin Core a\n  little closer to no longer needing to depend on OpenSSL, a dependency\n  that has caused security issues in the past.  The new implementation\n  gathers entropy from multiple sources, including from hardware\n  supporting the rdseed CPU instruction.\n\nChanges for particular platforms\n- --------------------------------\n\n- - On macOS, Bitcoin Core now opts out of application CPU throttling\n  (\"app nap\") during initial blockchain download, when catching up from\n  over 100 blocks behind the current chain tip, or when reindexing chain\n  data. This helps prevent these operations from taking an excessively\n  long time because the operating system is attempting to conserve\n  power.\n\n0.18.0 change log\n=================\n\n### Consensus\n- - #14247 Fix crash bug with duplicate inputs within a transaction (TheBlueMatt)\n\n### Mining\n- - #14811 Mining: Enforce that segwit option must be set in GBT (jnewbery)\n\n### Block and transaction handling\n- - #13310 Report progress in ReplayBlocks while rolling forward (promag)\n- - #13783 validation: Pass tx pool reference into CheckSequenceLocks (MarcoFalke)\n- - #14834 validation: Assert that pindexPrev is non-null when required (kallewoof)\n- - #14085 index: Fix for indexers skipping genesis block (jimpo)\n- - #14963 mempool, validation: Explain `cs_main` locking semantics (MarcoFalke)\n- - #15193 Default `-whitelistforcerelay` to off (sdaftuar)\n- - #15429 Update `assumevalid`, `minimumchainwork`, and `getchaintxstats` to height 563378 (gmaxwell)\n- - #15552 Granular invalidateblock and RewindBlockIndex (MarcoFalke)\n- - #14841 Move CheckBlock() call to critical section (hebasto)\n\n### P2P protocol and network code\n- - #14025 Remove dead code for nVersion=10300 (MarcoFalke)\n- - #12254 BIP 158: Compact Block Filters for Light Clients (jimpo)\n- - #14073 blockfilter: Avoid out-of-bounds script access (jimpo)\n- - #14140 Switch nPrevNodeCount to vNodesSize (pstratem)\n- - #14027 Skip stale tip checking if outbound connections are off or if reindexing (gmaxwell)\n- - #14532 Never bind `INADDR_ANY` by default, and warn when doing so explicitly (luke-jr)\n- - #14733 Make peer timeout configurable, speed up very slow test and ensure correct code path tested (zallarak)\n- - #14336 Implement poll (pstratem)\n- - #15051 IsReachable is the inverse of IsLimited (DRY). Includes unit tests (mmachicao)\n- - #15138 Drop IsLimited in favor of IsReachable (Empact)\n- - #14605 Return of the Banman (dongcarl)\n- - #14970 Add dnsseed.emzy.de to DNS seeds (Emzy)\n- - #14929 Allow connections from misbehavior banned peers (gmaxwell)\n- - #15345 Correct comparison of addr count (dongcarl)\n- - #15201 Add missing locking annotation for vNodes. vNodes is guarded by cs_vNodes (practicalswift)\n- - #14626 Select orphan transaction uniformly for eviction (sipa)\n- - #15486 Ensure tried collisions resolve, and allow feeler connections to existing outbound netgroups (sdaftuar)\n\n### Wallet\n- - #13962 Remove unused `dummy_tx` variable from FillPSBT (dongcarl)\n- - #13967 Don't report `minversion` wallet entry as unknown (instagibbs)\n- - #13988 Add checks for settxfee reasonableness (ajtowns)\n- - #12559 Avoid locking `cs_main` in some wallet RPC (promag)\n- - #13631 Add CMerkleTx::IsImmatureCoinBase method (Empact)\n- - #14023 Remove accounts RPCs (jnewbery)\n- - #13825 Kill accounts (jnewbery)\n- - #10605 Add AssertLockHeld assertions in CWallet::ListCoins (ryanofsky)\n- - #12490 Remove deprecated wallet rpc features from `bitcoin_server` (jnewbery)\n- - #14138 Set `encrypted_batch` to nullptr after delete. Avoid double free in the case of NDEBUG (practicalswift)\n- - #14168 Remove `ENABLE_WALLET` from `libbitcoin_server.a` (jnewbery)\n- - #12493 Reopen CDBEnv after encryption instead of shutting down (achow101)\n- - #14282 Remove `-usehd` option (jnewbery)\n- - #14146 Remove trailing separators from `-walletdir` arg (PierreRochard)\n- - #14291 Add ListWalletDir utility function (promag)\n- - #14468 Deprecate `generate` RPC method (jnewbery)\n- - #11634 Add missing `cs_wallet`/`cs_KeyStore` locks to wallet (practicalswift)\n- - #14296 Remove `addwitnessaddress` (jnewbery)\n- - #14451 Add BIP70 deprecation warning and allow building GUI without BIP70 support (jameshilliard)\n- - #14320 Fix duplicate fileid detection (ken2812221)\n- - #14561 Remove `fs::relative` call and fix listwalletdir tests (promag)\n- - #14454 Add SegWit support to importmulti (MeshCollider)\n- - #14410 rpcwallet: `ischange` field for `getaddressinfo` RPC (mrwhythat)\n- - #14350 Add WalletLocation class (promag)\n- - #14689 Require a public key to be retrieved when signing a P2PKH input (achow101)\n- - #14478 Show error to user when corrupt wallet unlock fails (MeshCollider)\n- - #14411 Restore ability to list incoming transactions by label (ryanofsky)\n- - #14552 Detect duplicate wallet by comparing the db filename (ken2812221)\n- - #14678 Remove redundant KeyOriginInfo access, already done in CreateSig (instagibbs)\n- - #14477 Add ability to convert solvability info to descriptor (sipa)\n- - #14380 Fix assert crash when specified change output spend size is unknown (instagibbs)\n- - #14760 Log env path in `BerkeleyEnvironment::Flush` (promag)\n- - #14646 Add expansion cache functions to descriptors (unused for now) (sipa)\n- - #13076 Fix ScanForWalletTransactions to return an enum indicating scan result: `success` / `failure` / `user_abort` (Empact)\n- - #14821 Replace CAffectedKeysVisitor with descriptor based logic (sipa)\n- - #14957 Initialize `stop_block` in CWallet::ScanForWalletTransactions (Empact)\n- - #14565 Overhaul `importmulti` logic (sipa)\n- - #15039 Avoid leaking nLockTime fingerprint when anti-fee-sniping (MarcoFalke)\n- - #14268 Introduce SafeDbt to handle Dbt with free or `memory_cleanse` raii-style (Empact)\n- - #14711 Remove uses of chainActive and mapBlockIndex in wallet code (ryanofsky)\n- - #15279 Clarify rescanblockchain doc (MarcoFalke)\n- - #15292 Remove `boost::optional`-related false positive -Wmaybe-uninitialized warnings on GCC compiler (hebasto)\n- - #13926 [Tools] bitcoin-wallet - a tool for creating and managing wallets offline (jnewbery)\n- - #11911 Free BerkeleyEnvironment instances when not in use (ryanofsky)\n- - #15235 Do not import private keys to wallets with private keys disabled (achow101)\n- - #15263 Descriptor expansions only need pubkey entries for PKH/WPKH (sipa)\n- - #15322 Add missing `cs_db` lock (promag)\n- - #15297 Releases dangling files on `BerkeleyEnvironment::Close` (promag)\n- - #14491 Allow descriptor imports with importmulti (MeshCollider)\n- - #15365 Add lock annotation for mapAddressBook (MarcoFalke)\n- - #15226 Allow creating blank (empty) wallets (alternative) (achow101)\n- - #15390 [wallet-tool] Close bdb when flushing wallet (jnewbery)\n- - #15334 Log absolute paths for the wallets (hebasto)\n- - #14978 Factor out PSBT utilities from RPCs for use in GUI code; related refactoring (gwillen)\n- - #14481 Add P2SH-P2WSH support to listunspent RPC (MeshCollider)\n- - #14021 Import key origin data through descriptors in importmulti (achow101)\n- - #14075 Import watch only pubkeys to the keypool if private keys are disabled (achow101)\n- - #15368 Descriptor checksums (sipa)\n- - #15433 Use a single wallet batch for `UpgradeKeyMetadata` (jonasschnelli)\n- - #15408 Remove unused `TransactionError` constants (MarcoFalke)\n- - #15583 Log and ignore errors in ListWalletDir and IsBerkeleyBtree (promag)\n- - #14195 Pass privkey export DER compression flag correctly (fingera)\n- - #15299 Fix assertion in `CKey::SignCompact` (promag)\n- - #14437 Start to separate wallet from node (ryanofsky)\n- - #15749 Fix: importmulti only imports origin info for PKH outputs (sipa)\n\n### RPC and other APIs\n- - #12842 Prevent concurrent `savemempool` (promag)\n- - #13987 Report `minfeefilter` value in `getpeerinfo` RPC (ajtowns)\n- - #13891 Remove getinfo deprecation warning (jnewbery)\n- - #13399 Add `submitheader` (MarcoFalke)\n- - #12676 Show `bip125-replaceable` flag, when retrieving mempool entries (dexX7)\n- - #13723 PSBT key path cleanups (sipa)\n- - #14008 Preserve a format of RPC command definitions (kostyantyn)\n- - #9332 Let wallet `importmulti` RPC accept labels for standard scriptPubKeys (ryanofsky)\n- - #13983 Return more specific reject reason for submitblock (MarcoFalke)\n- - #13152 Add getnodeaddresses RPC command (chris-belcher)\n- - #14298 rest: Improve performance for JSON calls (alecalve)\n- - #14297 Remove warning for removed estimatefee RPC (jnewbery)\n- - #14373 Consistency fixes for RPC descriptions (ch4ot1c)\n- - #14150 Add key origin support to descriptors (sipa)\n- - #14518 Always throw in getblockstats if `-txindex` is required (promag)\n- - #14060 ZMQ: add options to configure outbound message high water mark, aka SNDHWM (mruddy)\n- - #13381 Add possibility to preserve labels on importprivkey (marcoagner)\n- - #14530 Use `RPCHelpMan` to generate RPC doc strings (MarcoFalke)\n- - #14720 Correctly name RPC arguments (MarcoFalke)\n- - #14726 Use `RPCHelpMan` for all RPCs (MarcoFalke)\n- - #14796 Pass argument descriptions to `RPCHelpMan` (MarcoFalke)\n- - #14670 http: Fix HTTP server shutdown (promag)\n- - #14885 Assert that named arguments are unique in `RPCHelpMan` (promag)\n- - #14877 Document default values for optional arguments (MarcoFalke)\n- - #14875 RPCHelpMan: Support required arguments after optional ones (MarcoFalke)\n- - #14993 Fix data race (UB) in InterruptRPC() (practicalswift)\n- - #14653 rpcwallet: Add missing transaction categories to RPC helptexts (andrewtoth)\n- - #14981 Clarify RPC `getrawtransaction`'s time help text (benthecarman)\n- - #12151 Remove `cs_main` lock from blockToJSON and blockheaderToJSON (promag)\n- - #15078 Document `bytessent_per_msg` and `bytesrecv_per_msg` (MarcoFalke)\n- - #15057 Correct `reconsiderblock `help text, add test (MarcoFalke)\n- - #12153 Avoid permanent `cs_main` lock in `getblockheader` (promag)\n- - #14982 Add `getrpcinfo` command (promag)\n- - #15122 Expand help text for `importmulti` changes (jnewbery)\n- - #15186 remove duplicate solvable field from `getaddressinfo` (fanquake)\n- - #15209 zmq: log outbound message high water mark when reusing socket (fanquake)\n- - #15177 rest: Improve tests and documention of /headers and /block (promag)\n- - #14353 rest: Add blockhash call, fetch blockhash by height (jonasschnelli)\n- - #15248 Compile on GCC4.8 (MarcoFalke)\n- - #14987 RPCHelpMan: Pass through Result and Examples (MarcoFalke)\n- - #15159 Remove lookup to UTXO set from GetTransaction (amitiuttarwar)\n- - #15245 remove deprecated mentions of signrawtransaction from fundraw help (instagibbs)\n- - #14667 Add `deriveaddresses` RPC util method (Sjors)\n- - #15357 Don't ignore `-maxtxfee` when wallet is disabled (JBaczuk)\n- - #15337 Fix for segfault if combinepsbt called with empty inputs (benthecarman)\n- - #14918 RPCHelpMan: Check default values are given at compile-time (MarcoFalke)\n- - #15383 mining: Omit uninitialized currentblockweight, currentblocktx (MarcoFalke)\n- - #13932 Additional utility RPCs for PSBT (achow101)\n- - #15401 Actually throw help when passed invalid number of params (MarcoFalke)\n- - #15471 rpc/gui: Remove 'Unknown block versions being mined' warning (laanwj)\n- - #15497 Consistent range arguments in scantxoutset/importmulti/deriveaddresses (sipa)\n- - #15510 deriveaddresses: add range to CRPCConvertParam (Sjors)\n- - #15582 Fix overflow bug in analyzepsbt fee: CAmount instead of int (sipa)\n- - #13424 Consistently validate txid / blockhash length and encoding in rpc calls (Empact)\n- - #15750 Remove the addresses field from the getaddressinfo return object (jnewbery)\n\n### GUI\n- - #13634 Compile `boost::signals2` only once (MarcoFalke)\n- - #13248 Make proxy icon from statusbar clickable (mess110)\n- - #12818 TransactionView: highlight replacement tx after fee bump (Sjors)\n- - #13529 Use new Qt5 connect syntax (promag)\n- - #14162 Also log and print messages or questions like bitcoind (MarcoFalke)\n- - #14385 Avoid system harfbuzz and bz2 (theuni)\n- - #14450 Fix QCompleter popup regression (hebasto)\n- - #14177 Set C locale for amountWidget (hebasto)\n- - #14374 Add `Blocksdir` to Debug window (hebasto)\n- - #14554 Remove unused `adjustedTime` parameter (hebasto)\n- - #14228 Enable system tray icon by default if available (hebasto)\n- - #14608 Remove the \"Pay only required fee\u2026\" checkbox (hebasto)\n- - #14521 qt, docs: Fix `bitcoin-qt -version` output formatting (hebasto)\n- - #13966 When private key is disabled, only show watch-only balance (ken2812221)\n- - #14828 Remove hidden columns in coin control dialog (promag)\n- - #14783 Fix `boost::signals2::no_slots_error` in early calls to InitWarning (promag)\n- - #14854 Cleanup SplashScreen class (hebasto)\n- - #14801 Use window() instead of obsolete topLevelWidget() (hebasto)\n- - #14573 Add Window menu (promag)\n- - #14979 Restore < Qt5.6 compatibility for addAction (jonasschnelli)\n- - #14975 Refactoring with QString::toNSString() (hebasto)\n- - #15000 Fix broken notificator on GNOME (hebasto)\n- - #14375 Correct misleading \"overridden options\" label (hebasto)\n- - #15007 Notificator class refactoring (hebasto)\n- - #14784 Use `WalletModel*` instead of the wallet name as map key (promag)\n- - #11625 Add BitcoinApplication & RPCConsole tests (ryanofsky)\n- - #14517 Fix start with the `-min` option (hebasto)\n- - #13216 implements concept for different disk sizes on intro (marcoagner)\n- - #15114 Replace remaining 0 with nullptr (Empact)\n- - #14594 Fix minimized window bug on Linux (hebasto)\n- - #14556 Fix confirmed transaction labeled \"open\" (#13299) (hebasto)\n- - #15149 Show current wallet name in window title (promag)\n- - #15136 \"Peers\" tab overhaul (hebasto)\n- - #14250 Remove redundant stopThread() and stopExecutor() signals (hebasto)\n- - #15040 Add workaround for QProgressDialog bug on macOS (hebasto)\n- - #15101 Add WalletController (promag)\n- - #15178 Improve \"help-console\" message (hebasto)\n- - #15210 Fix window title update (promag)\n- - #15167 Fix wallet selector size adjustment (hebasto)\n- - #15208 Remove macOS launch-at-startup when compiled with > macOS 10.11, fix memory mismanagement (jonasschnelli)\n- - #15163 Correct units for \"-dbcache\" and \"-prune\" (hebasto)\n- - #15225 Change the receive button to respond to keypool state changing (achow101)\n- - #15280 Fix shutdown order (promag)\n- - #15203 Fix issue #9683 \"gui, wallet: random abort (segmentation fault) (dooglus)\n- - #15091 Fix model overlay header sync (jonasschnelli)\n- - #15153 Add Open Wallet menu (promag)\n- - #15183 Fix `m_assumed_blockchain_size` variable value (marcoagner)\n- - #15063 If BIP70 is disabled, attempt to fall back to BIP21 parsing (luke-jr)\n- - #15195 Add Close Wallet action (promag)\n- - #15462 Fix async open wallet call order (promag)\n- - #15801 Bugfix: GUI: Options: Initialise prune setting range before loading current value, and remove upper bound limit (luke-jr)\n\n### Build system\n- - #13955 gitian: Bump descriptors for (0.)18 (fanquake)\n- - #13899 Enable -Wredundant-decls where available. Remove redundant redeclarations (practicalswift)\n- - #13665 Add RISC-V support to gitian (ken2812221)\n- - #14062 Generate MSVC project files via python script (ken2812221)\n- - #14037 Add README.md to linux release tarballs (hebasto)\n- - #14183 Remove unused Qt 4 dependencies (ken2812221)\n- - #14127 Avoid getifaddrs when unavailable (greenaddress)\n- - #14184 Scripts and tools: increased timeout downloading (cisba)\n- - #14204 Move `interfaces/*` to `libbitcoin_server` (laanwj)\n- - #14208 Actually remove `ENABLE_WALLET` (jnewbery)\n- - #14212 Remove libssl from LDADD unless GUI (MarcoFalke)\n- - #13578 Upgrade zeromq to 4.2.5 and avoid deprecated zeromq API functions (mruddy)\n- - #14281 lcov: filter /usr/lib/ from coverage reports (MarcoFalke)\n- - #14325 gitian: Use versioned unsigned tarballs instead of generically named ones (achow101)\n- - #14253 During 'make clean', remove some files that are currently missed (murrayn)\n- - #14455 Unbreak `make clean` (jamesob)\n- - #14495 Warn (don't fail!) on spelling errors (practicalswift)\n- - #14496 Pin to specific versions of Python packages we install from PyPI in Travis (practicalswift)\n- - #14568 Fix Qt link order for Windows build (ken2812221)\n- - #14252 Run functional tests and benchmarks under the undefined behaviour sanitizer (UBSan) (practicalswift)\n- - #14612 Include full version number in released file names (achow101)\n- - #14840 Remove duplicate libconsensus linking in test make (AmirAbrams)\n- - #14564 Adjust configure so that only BIP70 is disabled when protobuf is missing instead of the GUI (jameshilliard)\n- - #14883 Add `--retry 5` to curl opts in `install_db4.sh` (qubenix)\n- - #14701 Add `CLIENT_VERSION_BUILD` to CFBundleGetInfoString (fanquake)\n- - #14849 Qt 5.9.7 (fanquake)\n- - #15020 Add names to Travis jobs (gkrizek)\n- - #15047 Allow to configure --with-sanitizers=fuzzer (MarcoFalke)\n- - #15154 Configure: bitcoin-tx doesn't need libevent, so don't pull it in (luke-jr)\n- - #15175 Drop macports support (Empact)\n- - #15308 Restore compatibility with older boost (Empact)\n- - #15407 msvc: Fix silent merge conflict between #13926 and #14372 part II (ken2812221)\n- - #15388 Makefile.am: add rule for src/bitcoin-wallet (Sjors)\n- - #15393 Bump minimum Qt version to 5.5.1 (Sjors)\n- - #15285 Prefer Python 3.4 even if newer versions are present on the system (Sjors)\n- - #15398 msvc: Add rapidcheck property tests (ken2812221)\n- - #15431 msvc: scripted-diff: Remove NDEBUG pre-define in project file (ken2812221)\n- - #15549 gitian: Improve error handling (laanwj)\n- - #15548 use full version string in setup.exe (MarcoFalke)\n- - #11526 Visual Studio build configuration for Bitcoin Core (sipsorcery)\n- - #15110 build\\_msvc: Fix the build problem in `libbitcoin_server` (Mr-Leshiy)\n- - #14372 msvc: build secp256k1 and leveldb locally (ken2812221)\n- - #15325 msvc: Fix silent merge conflict between #13926 and #14372 (ken2812221)\n- - #15391 Add compile time verification of assumptions we're currently making implicitly/tacitly (practicalswift)\n- - #15503 msvc: Use a single file to specify the include path (ken2812221)\n- - #13765 contrib: Add gitian build support for github pull request (ken2812221)\n- - #15809 gitignore: plist and dat (jamesob)\n\n### Tests and QA\n- - #15405 appveyor: Clean cache when build configuration changes (Sjors)\n- - #13953 Fix deprecation in bitcoin-util-test.py (isghe)\n- - #13963 Replace usage of tostring() with tobytes() (dongcarl)\n- - #13964 ci: Add appveyor ci (ken2812221)\n- - #13997 appveyor: fetch the latest port data (ken2812221)\n- - #13707 Add usage note to check-rpc-mappings.py (masonicboom)\n- - #14036 travis: Run unit tests --with-sanitizers=undefined (MarcoFalke)\n- - #13861 Add testing of `value_ret` for SelectCoinsBnB (Empact)\n- - #13863 travis: Move script sections to files in `.travis/` subject to shellcheck (scravy)\n- - #14081 travis: Fix missing differentiation between unit and functional tests (scravy)\n- - #14042 travis: Add cxxflags=-wno-psabi at arm job (ken2812221)\n- - #14051 Make `combine_logs.py` handle multi-line logs (jnewbery)\n- - #14093 Fix accidental trunction from int to bool (practicalswift)\n- - #14108 Add missing locking annotations and locks (`g_cs_orphans`) (practicalswift)\n- - #14088 Don't assert(\u2026) with side effects (practicalswift)\n- - #14086 appveyor: Use clcache to speed up build (ken2812221)\n- - #13954 Warn (don't fail!) on spelling errors. Fix typos reported by codespell (practicalswift)\n- - #12775 Integration of property based testing into Bitcoin Core (Christewart)\n- - #14119 Read reject reasons from debug log, not P2P messages (MarcoFalke)\n- - #14189 Fix silent merge conflict in `wallet_importmulti` (MarcoFalke)\n- - #13419 Speed up `knapsack_solver_test` by not recreating wallet 100 times (lucash-dev)\n- - #14199 Remove redundant BIP174 test from `rpc_psbt.json` (araspitzu)\n- - #14179 Fixups to \"Run all tests even if wallet is not compiled\" (MarcoFalke)\n- - #14225 Reorder tests and move most of extended tests up to normal tests (ken2812221)\n- - #14236 `generate` --> `generatetoaddress` change to allow tests run without wallet (sanket1729)\n- - #14287 Use MakeUnique to construct objects owned by `unique_ptrs` (practicalswift)\n- - #14007 Run functional test on Windows and enable it on Appveyor (ken2812221)\n- - #14275 Write the notification message to different files to avoid race condition in `feature_notifications.py` (ken2812221)\n- - #14306 appveyor: Move AppVeyor YAML to dot-file-style YAML (MitchellCash)\n- - #14305 Enforce critical class instance attributes in functional tests, fix segwit test specificity (JustinTArthur)\n- - #12246 Bugfix: Only run bitcoin-tx tests when bitcoin-tx is enabled (luke-jr)\n- - #14316 Exclude all tests with difference parameters in `--exclude` list (ken2812221)\n- - #14381 Add missing call to `skip_if_no_cli()` (practicalswift)\n- - #14389 travis: Set codespell version to avoid breakage (MarcoFalke)\n- - #14398 Don't access out of bounds array index: array[sizeof(array)] (Empact)\n- - #14419 Remove `rpc_zmq.py` (jnewbery)\n- - #14241 appveyor: Script improvement (ken2812221)\n- - #14413 Allow closed RPC handler in `assert_start_raises_init_error` (ken2812221)\n- - #14324 Run more tests with wallet disabled (MarcoFalke)\n- - #13649 Allow arguments to be forwarded to flake8 in lint-python.sh (jamesob)\n- - #14465 Stop node before removing the notification file (ken2812221)\n- - #14460 Improve 'CAmount' tests (hebasto)\n- - #14456 forward timeouts properly in `send_blocks_and_test` (jamesob)\n- - #14527 Revert \"Make qt wallet test compatible with qt4\" (MarcoFalke)\n- - #14504 Show the progress of functional tests (isghe)\n- - #14559 appveyor: Enable multiwallet tests (ken2812221)\n- - #13515 travis: Enable qt for all jobs (ken2812221)\n- - #14571 Test that nodes respond to `getdata` with `notfound` (MarcoFalke)\n- - #14569 Print dots by default in functional tests (ken2812221)\n- - #14631 Move deterministic address import to `setup_nodes` (jnewbery)\n- - #14630 test: Remove travis specific code (MarcoFalke)\n- - #14528 travis: Compile once on xenial (MarcoFalke)\n- - #14092 Dry run `bench_bitcoin` as part `make check` to allow for quick identification of assertion/sanitizer failures in benchmarking code (practicalswift)\n- - #14664 `example_test.py`: fixup coinbase height argument, derive number clearly (instagibbs)\n- - #14522 Add invalid P2P message tests (jamesob)\n- - #14619 Fix value display name in `test_runner` help text (merland)\n- - #14672 Send fewer spam messages in `p2p_invalid_messages` (jamesob)\n- - #14673 travis: Fail the ubsan travis build in case of newly introduced ubsan errors (practicalswift)\n- - #14665 appveyor: Script improvement part II (ken2812221)\n- - #14365 Add Python dead code linter (vulture) to Travis (practicalswift)\n- - #14693 `test_node`: `get_mem_rss` fixups (MarcoFalke)\n- - #14714 util.h: explicitly include required QString header (1Il1)\n- - #14705 travis: Avoid timeout on verify-commits check (MarcoFalke)\n- - #14770 travis: Do not specify sudo in `.travis` (scravy)\n- - #14719 Check specific reject reasons in `feature_block` (MarcoFalke)\n- - #14771 Add `BOOST_REQUIRE` to getters returning optional (MarcoFalke)\n- - #14777 Add regtest for JSON-RPC batch calls (domob1812)\n- - #14764 travis: Run thread sanitizer on unit tests (MarcoFalke)\n- - #14400 Add Benchmark to test input de-duplication worst case (JeremyRubin)\n- - #14812 Fix `p2p_invalid_messages` on macOS (jamesob)\n- - #14813 Add `wallet_encryption` error tests (MarcoFalke)\n- - #14820 Fix `descriptor_tests` not checking ToString output of public descriptors (ryanofsky)\n- - #14794 Add AddressSanitizer (ASan) Travis build (practicalswift)\n- - #14819 Bugfix: `test/functional/mempool_accept`: Ensure oversize transaction is actually oversize (luke-jr)\n- - #14822 bench: Destroy wallet txs instead of leaking their memory (MarcoFalke)\n- - #14683 Better `combine_logs.py` behavior (jamesob)\n- - #14231 travis: Save cache even when build or test fail (ken2812221)\n- - #14816 Add CScriptNum decode python implementation in functional suite (instagibbs)\n- - #14861 Modify `rpc_bind` to conform to #14532 behaviour (dongcarl)\n- - #14864 Run scripted-diff in subshell (dongcarl)\n- - #14795 Allow `test_runner` command line to receive parameters for each test (marcoagner)\n- - #14788 Possible fix the permission error when the tests open the cookie file (ken2812221)\n- - #14857 `wallet_keypool_topup.py`: Test for all keypool address types (instagibbs)\n- - #14886 Refactor importmulti tests (jnewbery)\n- - #14908 Removed implicit CTransaction constructor calls from tests and benchmarks (lucash-dev)\n- - #14903 Handle ImportError explicitly, improve comparisons against None (daniel-s-ingram)\n- - #14884 travis: Enforce python 3.4 support through linter (Sjors)\n- - #14940 Add test for truncated pushdata script (MarcoFalke)\n- - #14926 consensus: Check that final transactions are valid (MarcoFalke)\n- - #14937 travis: Fix travis would always be green even if it fail (ken2812221)\n- - #14953 Make `g_insecure_rand_ctx` `thread_local` (MarcoFalke)\n- - #14931 mempool: Verify prioritization is dumped correctly (MarcoFalke)\n- - #14935 Test for expected return values when calling functions returning a success code (practicalswift)\n- - #14969 Fix `cuckoocache_tests` TSAN failure introduced in 14935 (practicalswift)\n- - #14964 Fix race in `mempool_accept` (MarcoFalke)\n- - #14829 travis: Enable functional tests in the threadsanitizer (tsan) build job (practicalswift)\n- - #14985 Remove `thread_local` from `test_bitcoin` (MarcoFalke)\n- - #15005 Bump timeout to run tests in travis thread sanitizer (MarcoFalke)\n- - #15013 Avoid race in `p2p_timeouts` (MarcoFalke)\n- - #14960 lint/format-strings: Correctly exclude escaped percent symbols (luke-jr)\n- - #14930 pruning: Check that verifychain can be called when pruned (MarcoFalke)\n- - #15022 Upgrade Travis OS to Xenial (gkrizek)\n- - #14738 Fix running `wallet_listtransactions.py` individually through `test_runner.py` (kristapsk)\n- - #15026 Rename `rpc_timewait` to `rpc_timeout` (MarcoFalke)\n- - #15069 Fix `rpc_net.py` `pong` race condition (Empact)\n- - #14790 Allow running `rpc_bind.py` --nonloopback test without IPv6 (kristapsk)\n- - #14457 add invalid tx templates for use in functional tests (jamesob)\n- - #14855 Correct ineffectual WithOrVersion from `transactions_tests` (Empact)\n- - #15099 Use `std::vector` API for construction of test data (domob1812)\n- - #15102 Run `invalid_txs.InputMissing` test in `feature_block` (MarcoFalke)\n- - #15059 Add basic test for BIP34 (MarcoFalke)\n- - #15108 Tidy up `wallet_importmulti.py` (amitiuttarwar)\n- - #15164 Ignore shellcheck warning SC2236 (promag)\n- - #15170 refactor/lint: Add ignored shellcheck suggestions to an array (koalaman)\n- - #14958 Remove race between connecting and shutdown on separate connections (promag)\n- - #15166 Pin shellcheck version (practicalswift)\n- - #15196 Update all `subprocess.check_output` functions to be Python 3.4 compatible (gkrizek)\n- - #15043 Build fuzz targets into seperate executables (MarcoFalke)\n- - #15276 travis: Compile once on trusty (MarcoFalke)\n- - #15246 Add tests for invalid message headers (MarcoFalke)\n- - #15301 When testing with --usecli, unify RPC arg to cli arg conversion and handle dicts and lists (achow101)\n- - #15247 Use wallet to retrieve raw transactions (MarcoFalke)\n- - #15303 travis: Remove unused `functional_tests_config` (MarcoFalke)\n- - #15330 Fix race in `p2p_invalid_messages` (MarcoFalke)\n- - #15324 Make bloom tests deterministic (MarcoFalke)\n- - #15328 travis: Revert \"run extended tests once daily\" (MarcoFalke)\n- - #15327 Make test `updatecoins_simulation_test` deterministic (practicalswift)\n- - #14519 add utility to easily profile node performance with perf (jamesob)\n- - #15349 travis: Only exit early if compilation took longer than 30 min (MarcoFalke)\n- - #15350 Drop RPC connection if --usecli (promag)\n- - #15370 test: Remove unused --force option (MarcoFalke)\n- - #14543 minor `p2p_sendheaders` fix of height in coinbase (instagibbs)\n- - #13787 Test for Windows encoding issue (ken2812221)\n- - #15378 Added missing tests for RPC wallet errors (benthecarman)\n- - #15238 remove some magic mining constants in functional tests (instagibbs)\n- - #15411 travis: Combine --disable-bip70 into existing job (MarcoFalke)\n- - #15295 fuzz: Add `test/fuzz/test_runner.py` and run it in travis (MarcoFalke)\n- - #15413 Add missing `cs_main` locks required when accessing pcoinsdbview, pcoinsTip or pblocktree (practicalswift)\n- - #15399 fuzz: Script validation flags (MarcoFalke)\n- - #15410 txindex: interrupt threadGroup before calling destructor (MarcoFalke)\n- - #15397 Remove manual byte editing in `wallet_tx_clone` func test (instagibbs)\n- - #15415 functional: allow custom cwd, use tmpdir as default (Sjors)\n- - #15404 Remove `-txindex` to start nodes (amitiuttarwar)\n- - #15439 remove `byte.hex()` to keep compatibility (AkioNak)\n- - #15419 Always refresh cache to be out of ibd (MarcoFalke)\n- - #15507 Bump timeout on tests that timeout on windows (MarcoFalke)\n- - #15506 appveyor: fix cache issue and reduce dependencies build time (ken2812221)\n- - #15485 add `rpc_misc.py`, mv test getmemoryinfo, add test mallocinfo (adamjonas)\n- - #15321 Add `cs_main` lock annotations for mapBlockIndex (MarcoFalke)\n- - #14128 lint: Make sure we read the command line inputs using UTF-8 decoding in python (ken2812221)\n- - #14115 lint: Make all linters work under the default macos dev environment (build-osx.md) (practicalswift)\n- - #15219 lint: Enable python linters via an array (Empact)\n\n### Platform support\n- - #13866 utils: Use `_wfopen` and `_wfreopen` on windows (ken2812221)\n- - #13886 utils: Run commands using UTF-8 string on windows (ken2812221)\n- - #14192 utils: Convert `fs::filesystem_error` messages from local multibyte to UTF-8 on windows (ken2812221)\n- - #13877 utils: Make fs::path::string() always return UTF-8 string on windows (ken2812221)\n- - #13883 utils: Convert windows args to UTF-8 string (ken2812221)\n- - #13878 utils: Add fstream wrapper to allow to pass unicode filename on windows (ken2812221)\n- - #14426 utils: Fix broken windows filelock (ken2812221)\n- - #14686 Fix windows build error if `--disable-bip70` (ken2812221)\n- - #14922 windows: Set `_WIN32_WINNT` to 0x0601 (Windows 7) (ken2812221)\n- - #13888 Call unicode API on Windows (ken2812221)\n- - #15468 Use `fsbridge::ifstream` to fix Windows path issue (ken2812221)\n- - #13734 Drop `boost::scoped_array` and use `wchar_t` API explicitly on Windows (ken2812221)\n- - #13884 Enable bdb unicode support for Windows (ken2812221)\n\n### Miscellaneous\n- - #13935 contrib: Adjust output to current test format (AkioNak)\n- - #14097 validation: Log FormatStateMessage on ConnectBlock error in ConnectTip (MarcoFalke)\n- - #13724 contrib: Support ARM and RISC-V symbol check (ken2812221)\n- - #13159 Don't close old debug log file handle prematurely when trying to re-open (on SIGHUP) (practicalswift)\n- - #14186 bitcoin-cli: don't translate command line options (HashUnlimited)\n- - #14057 logging: Only log `using config file path_to_bitcoin.conf` message on startup if conf file exists (leishman)\n- - #14164 Update univalue subtree (MarcoFalke)\n- - #14272 init: Remove deprecated args from hidden args (MarcoFalke)\n- - #14494 Error if # is used in rpcpassword in conf (MeshCollider)\n- - #14742 Properly generate salt in rpcauth.py (dongcarl)\n- - #14708 Warn unrecognised sections in the config file (AkioNak)\n- - #14756 Improve rpcauth.py by using argparse and getpass modules (promag)\n- - #14785 scripts: Fix detection of copyright holders (cornelius)\n- - #14831 scripts: Use `#!/usr/bin/env bash` instead of `#!/bin/bash` (vim88)\n- - #14869 Scripts: Add trusted key for samuel dobson (laanwj)\n- - #14809 Tools: improve verify-commits.py script (jlopp)\n- - #14624 Some simple improvements to the RNG code (sipa)\n- - #14947 scripts: Remove python 2 import workarounds (practicalswift)\n- - #15087 Error if rpcpassword contains hash in conf sections (MeshCollider)\n- - #14433 Add checksum in gitian build scripts for ossl (TheCharlatan)\n- - #15165 contrib: Allow use of github api authentication in github-merge (laanwj)\n- - #14409 utils and libraries: Make 'blocksdir' always net specific (hebasto)\n- - #14839 threads: Fix unitialized members in `sched_param` (fanquake)\n- - #14955 Switch all RNG code to the built-in PRNG (sipa)\n- - #15258 Scripts and tools: Fix `devtools/copyright_header.py` to always honor exclusions (Empact)\n- - #12255 Update bitcoin.service to conform to init.md (dongcarl)\n- - #15266 memory: Construct globals on first use (MarcoFalke)\n- - #15347 Fix build after pr 15266 merged (hebasto)\n- - #15351 Update linearize-hashes.py (OverlordQ)\n- - #15358 util: Add setuphelpoptions() (MarcoFalke)\n- - #15216 Scripts and tools: Replace script name with a special parameter (hebasto)\n- - #15250 Use RdSeed when available, and reduce RdRand load (sipa)\n- - #15278 Improve PID file error handling (hebasto)\n- - #15270 Pull leveldb subtree (MarcoFalke)\n- - #15456 Enable PID file creation on WIN (riordant)\n- - #12783 macOS: disable AppNap during sync (krab)\n- - #13910 Log progress while verifying blocks at level 4 (domob1812)\n- - #15124 Fail AppInitMain if either disk space check fails (Empact)\n- - #15117 Fix invalid memory write in case of failing mmap(\u2026) in PosixLockedPageAllocator::AllocateLocked (practicalswift)\n- - #14357 streams: Fix broken `streams_vector_reader` test. Remove unused `seek(size_t)`\n- - #11640 Make `LOCK`, `LOCK2`, `TRY_LOCK` work with CWaitableCriticalSection (ryanofsky)\n- - #14074 Use `std::unordered_set` instead of `set` in blockfilter interface (jimpo)\n- - #15275 Add gitian PGP key for hebasto (hebasto)\n\n### Documentation\n- - #14120 Notes about control port and read access to cookie (JBaczuk)\n- - #14135 correct GetDifficulty doc after #13288 (fanquake)\n- - #14013 Add new regtest ports in man following #10825 ports reattributions (ariard)\n- - #14149 Remove misleading checkpoints comment in CMainParams (MarcoFalke)\n- - #14153 Add disable-wallet section to OSX build instructions, update line in Unix instructions (bitstein)\n- - #13662 Explain when reindex-chainstate can be used instead of reindex (Sjors)\n- - #14207 `-help-debug` implies `-help` (laanwj)\n- - #14213 Fix reference to lint-locale-dependence.sh (hebasto)\n- - #14206 Document `-checklevel` levels (laanwj)\n- - #14217 Add GitHub PR template (MarcoFalke)\n- - #14331 doxygen: Fix member comments (MarcoFalke)\n- - #14264 Split depends installation instructions per arch (MarcoFalke)\n- - #14393 Add missing apt-get install (poiuty)\n- - #14428 Fix macOS files description in qt/README.md (hebasto)\n- - #14390 release process: RPC documentation (karel-3d)\n- - #14472 getblocktemplate: use SegWit in example (Sjors)\n- - #14497 Add doc/bitcoin-conf.md (hebasto)\n- - #14526 Document lint tests (fanquake)\n- - #14511 Remove explicit storage requirement from README.md (merland)\n- - #14600 Clarify commit message guidelines (merland)\n- - #14617 FreeBSD: Document Python 3 requirement for 'gmake check' (murrayn)\n- - #14592 Add external interface consistency guarantees (MarcoFalke)\n- - #14625 Make clear function argument case in dev notes (dongcarl)\n- - #14515 Update OpenBSD build guide for 6.4 (fanquake)\n- - #14436 Add comment explaining recentRejects-DoS behavior (jamesob)\n- - #14684 conf: Remove deprecated options from docs, Other cleanup (MarcoFalke)\n- - #14731 Improve scripted-diff developer docs (dongcarl)\n- - #14778 A few minor formatting fixes and clarifications to descriptors.md (jnewbery)\n- - #14448 Clarify rpcwallet flag url change (JBaczuk)\n- - #14808 Clarify RPC rawtransaction documentation (jlopp)\n- - #14804 Less confusing documentation for `torpassword` (fanquake)\n- - #14848 Fix broken Gmane URL in security-check.py (cyounkins-bot)\n- - #14882 developer-notes.md: Point out that UniValue deviates from upstream (Sjors)\n- - #14909 Update minimum required Qt (fanquake)\n- - #14914 Add nice table to files.md (emilengler)\n- - #14741 Indicate `-rpcauth` option password hashing alg (dongcarl)\n- - #14950 Add NSIS setup/install steps to windows docs (fanquake)\n- - #13930 Better explain GetAncestor check for `m_failed_blocks` in AcceptBlockHeader (Sjors)\n- - #14973 Improve Windows native build instructions (murrayn)\n- - #15073 Botbot.me (IRC logs) not available anymore (anduck)\n- - #15038 Get more info about GUI-related issue on Linux (hebasto)\n- - #14832 Add more Doxygen information to Developer Notes (ch4ot1c)\n- - #15128 Fix download link in doc/README.md (merland)\n- - #15127 Clarifying testing instructions (benthecarman)\n- - #15132 Add FreeBSD build notes link to doc/README.md (fanquake)\n- - #15173 Explain what .python-version does (Sjors)\n- - #15223 Add information about security to the JSON-RPC doc (harding)\n- - #15249 Update python docs to reflect that wildcard imports are disallowed (Empact)\n- - #15176 Get rid of badly named `doc/README_osx.md` (merland)\n- - #15272 Correct logging return type and RPC example (fanquake)\n- - #15244 Gdb attaching to process during tests has non-sudo solution (instagibbs)\n- - #15332 Small updates to `getrawtransaction` description (amitiuttarwar)\n- - #15354 Add missing `bitcoin-wallet` tool manpages (MarcoFalke)\n- - #15343 netaddress: Make IPv4 loopback comment more descriptive (dongcarl)\n- - #15353 Minor textual improvements in `translation_strings_policy.md` (merland)\n- - #15426 importmulti: add missing description of keypool option (harding)\n- - #15425 Add missing newline to listunspent help for witnessScript (harding)\n- - #15348 Add separate productivity notes document (dongcarl)\n- - #15416 Update FreeBSD build guide for 12.0 (fanquake)\n- - #15222 Add info about factors that affect dependency list (merland)\n- - #13676 Explain that mempool memory is added to `-dbcache` (Sjors)\n- - #15273 Slight tweak to the verify-commits script directions (droark)\n- - #15477 Remove misleading hint in getrawtransaction (MarcoFalke)\n- - #15489 Update release process for snap package (MarcoFalke)\n- - #15524 doc: Remove berkeleydb PPA from linux build instructions (MarcoFalke)\n- - #15559 Correct `analyzepsbt` rpc doc (fanquake)\n- - #15194 Add comment describing `fDisconnect` behavior (dongcarl)\n- - #15754 getrpcinfo docs (benthecarman)\n- - #15763 Update bips.md for 0.18.0 (sipa)\n- - #15757 List new RPCs in psbt.md and descriptors.md (sipa)\n- - #15765 correct bitcoinconsensus_version in shared-libraries.md (fanquake)\n- - #15792 describe onlynet option in doc/tor.md (jonatack)\n- - #15802 mention creating application support bitcoin folder on OSX (JimmyMow)\n- - #15799 Clarify RPC versioning (MarcoFalke)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - 1Il1\n- - 251\n- - Aaron Clauson\n- - Adam Jonas\n- - Akio Nakamura\n- - Alexander Leishman\n- - Alexey Ivanov\n- - Alexey Poghilenkov\n- - Amir Abrams\n- - Amiti Uttarwar\n- - Andrew Chow\n- - andrewtoth\n- - Anthony Towns\n- - Antoine Le Calvez\n- - Antoine Riard\n- - Antti Majakivi\n- - araspitzu\n- - Arvid Norberg\n- - Ben Carman\n- - Ben Woosley\n- - benthecarman\n- - bitcoinhodler\n- - Carl Dong\n- - Chakib Benziane\n- - Chris Moore\n- - Chris Stewart\n- - chris-belcher\n- - Chun Kuan Lee\n- - Cornelius Schumacher\n- - Cory Fields\n- - Craig Younkins\n- - Cristian Mircea Messel\n- - Damian Mee\n- - Daniel Ingram\n- - Daniel Kraft\n- - David A. Harding\n- - DesWurstes\n- - dexX7\n- - Dimitri Deijs\n- - Dimitris Apostolou\n- - Douglas Roark\n- - DrahtBot\n- - Emanuele Cisbani\n- - Emil Engler\n- - Eric Scrivner\n- - fridokus\n- - Gal Buki\n- - Gleb Naumenko\n- - Glenn Willen\n- - Graham Krizek\n- - Gregory Maxwell\n- - Gregory Sanders\n- - gustavonalle\n- - Harry Moreno\n- - Hennadii Stepanov\n- - Isidoro Ghezzi\n- - Jack Mallers\n- - James Hilliard\n- - James O'Beirne\n- - Jameson Lopp\n- - Jeremy Rubin\n- - Jesse Cohen\n- - Jim Posen\n- - John Newbery\n- - Jon Layton\n- - Jonas Schnelli\n- - Jo\u00e3o Barbosa\n- - Jordan Baczuk\n- - Jorge Tim\u00f3n\n- - Julian Fleischer\n- - Justin Turner Arthur\n- - Karel B\u00edlek\n- - Karl-Johan Alm\n- - Kaz Wesley\n- - ken2812221\n- - Kostiantyn Stepaniuk\n- - Kristaps Kaupe\n- - Lawrence Nahum\n- - Lenny Maiorani\n- - liuyujun\n- - lucash-dev\n- - luciana\n- - Luke Dashjr\n- - marcaiaf\n- - marcoagner\n- - MarcoFalke\n- - Martin Erlandsson\n- - Marty Jones\n- - Mason Simon\n- - Michael Ford\n- - Michael Goldstein\n- - Michael Polzer\n- - Mitchell Cash\n- - mruddy\n- - Murray Nesbitt\n- - OverlordQ\n- - Patrick Strateman\n- - Pierre Rochard\n- - Pieter Wuille\n- - poiuty\n- - practicalswift\n- - priscoan\n- - qubenix\n- - riordant\n- - Russell Yanofsky\n- - Samuel Dobson\n- - sanket1729\n- - Sjors Provoost\n- - Stephan Oeste\n- - Steven Roose\n- - Suhas Daftuar\n- - TheCharlatan\n- - Tim Ruffing\n- - Vidar Holen\n- - vim88\n- - Walter\n- - whythat\n- - Wladimir J. van der Laan\n- - Zain Iqbal Allarakhia\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\n\niQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAlzKpd8ACgkQHkrtYphs\n0l2kkQgAiQPVcgcckNxZt3fy4SriLnL2E2lR5CCUC3UA1Aeq1m22NoZOX2oOJXE2\nYHqq94ufCOiAracJ/38OB60hbVZaWhsXMWgfuMIFtG1SMQMmOT4sEIG639kiFPoy\nJ+c045GI9Kasje3beJZCQUMleYroIb7n2H8yGZG5x1S+/H8htx2NPHp54MzQHBbj\nSWclp1aLtff3qfgk8slWI1AC7eopw2nqeunNktwauc35CUZun9S4C+g+q0d3w3wH\n9N4hK0BCEptA9jKiMLoPEKcihiyKod2RjSe3m5vZTGNOJ6fz4F7LhzkYBGe5Rt5d\ng3n/Anm3fVRNU0HHPoJUZT21LHwjCg==\n=l+2W\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.18.0 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 66153
        }
    },
    {
        "title": "[bitcoin-dev] [bitcoin-core-dev] Bitcoin Core 0.18.0 released",
        "thread_messages": [
            {
                "author": "Marco Falke",
                "date": "2019-05-02T16:16:08",
                "message_text_only": "Two addenda from me:\n\n* Beginning with Bitcoin Core 0.18.0, Windows builds for 32-bit\nWindows will no longer be provided. Please let us know if and why you\ncan not use the 64-bit build.\n* There is an experimental Bitcoin Core snap package in the snap\nstore. There should be a \"track\" for the latest release and a track\nfor each major version branch that is not yet EOL. While the snap\npackage uses the signed release binaries, I am not aware of a way to\ngenerate the hash of binaries in an installed snap that works on any\nLinux distribution. (On some distributions, a call to `sha256sum\n/var/lib/snapd/snap/bitcoin-core/current/{bin/*,snap/snapcraft.yaml}`\ngenerates the hashes that you can then compare to the signed ones as\nusual)\n\nMarco"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.18.0 released",
            "categories": [
                "bitcoin-dev",
                "bitcoin-core-dev"
            ],
            "authors": [
                "Marco Falke"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 740
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Knots 0.18.0.knots20190502 released",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2019-05-04T02:50:02",
                "message_text_only": "Bitcoin Knots version *0.18.0.knots20190502* is now available from:\n\n  <https://bitcoinknots.org/files/0.18.x/0.18.0.knots20190502/>\n\nThis is a new major version release, including new features, various bug\nfixes and performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoinknots/bitcoin/issues>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has\ncompletely shut down (which might take a few minutes for older\nversions), then run the installer (on Windows) or just copy over\n`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on\nLinux).\n\nThe first time you run version 0.15.0 or newer, your chainstate database\nwill be converted to a new format, which will take anywhere from a few\nminutes to half an hour, depending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and\nthere is no automatic upgrade code from before version 0.8 to version\n0.15.0 or later. Upgrading directly from 0.7.x and earlier without\nredownloading the blockchain is not supported.  However, as usual, old\nwallet versions are still supported.\n\nCompatibility\n==============\n\nBitcoin Knots is supported on operating systems using the Linux kernel,\nmacOS 10.10+, and Windows 7 and newer. It is not recommended to use\nBitcoin Knots on unsupported systems.\n\nFrom 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is\nbuilt using Qt 5.9.x, which doesn't support versions of macOS older than\n10.10. Additionally, Bitcoin Knots does not yet change appearance when\nmacOS \"dark mode\" is activated.\n\nIn addition to previously-supported CPU platforms, this release's\npre-compiled distribution also provides binaries for the RISC-V\nplatform.\n\nIf you are using the `systemd` unit configuration file located at\n`contrib/init/bitcoind.service`, it has been changed to use\n`/var/lib/bitcoind` as the data directory instead of\n`~bitcoin/.bitcoin`. When switching over to the new configuration file,\nplease make sure that the filesystem on which `/var/lib/bitcoind` will\nexist has enough space (check using `df -h /var/lib/bitcoind`), and\noptionally copy over your existing data directory. See the [systemd init\nfile section](#systemd-init-file) for more details.\n\nKnown issues\n============\n\nWallet GUI\n----------\n\nFor advanced users who have both (1) enabled coin control features, and\n(2) are using multiple wallets loaded at the same time: The coin control\ninput selection dialog can erroneously retain wrong-wallet state when\nswitching wallets using the dropdown menu. For now, it is recommended\nnot to use coin control features with multiple wallets loaded.\n\nNotable changes\n===============\n\nPolicy\n------\n\n- Previously, transactions sending to future Bech32 address versions\n  would be rejected, which could lead to stuck transactions, locking\n  up change. This has been relaxed by default to mitigate the issue.\n  For 0.18.0, the `-sendtofuture=0` option (also available in the\n  GUI Mempool Settings tab) can restore the old policy, but this is\n  discouraged, and will be removed in the future.\n\nMining\n------\n\n- Calls to `getblocktemplate` will fail if the segwit rule is not\n  specified.  Calling `getblocktemplate` without segwit specified is\n  almost certainly a misconfiguration since doing so results in lower\n  rewards for the miner.  Failed calls will produce an error message\n  describing how to enable the segwit rule.\n\n- By default, blocks mined with Bitcoin Knots will be limited to 300k\n  in size, or 1.5 MWU in weight. Note these defaults are just healthy\n  recommendations, and can be overridden with the `-blockmaxsize` and\n  `-blockmaxweight` options.\n\nConfiguration option changes\n----------------------------\n\n- A warning is printed if an unrecognized section name is used in the\n  configuration file.  Recognized sections are `[test]`, `[main]`, and\n  `[regtest]`.\n\n- The `rpcallowip` option can no longer be used to automatically listen\n  on all network interfaces.  Instead, the `rpcbind` parameter must be\n  used to specify the IP addresses to listen on.  Listening for RPC\n  commands over a public network connection is insecure and should be\n  disabled, so a warning is now printed if a user selects such a\n  configuration.  If you need to expose RPC in order to use a tool like\n  Docker, ensure you only bind RPC to your localhost, e.g. `docker run\n  [...] -p 127.0.0.1:8332:8332` (this is an extra `:8332` over the\n  normal Docker port specification).\n\n- The `rpcpassword` option now causes a startup error if the password\n  set in the configuration file contains a hash character (#), as it's\n  ambiguous whether the hash character is meant for the password or as a\n  comment.\n\n- The `whitelistforcerelay` option is used to relay transactions from\n  whitelisted peers even when not accepted to the mempool. This option\n  now defaults to being off, so that changes in policy and\n  disconnect/ban behavior will not cause a node that is whitelisting\n  another to be dropped by peers.  Users can still explicitly enable\n  this behavior with the command line option (and may want to consider\n  [contacting](https://bitcoincore.org/en/contact/) the Bitcoin Core\n  project to let us know about their use-case, as this feature could be\n  deprecated in the future).\n\n- The `startupnotify` option is used to specify a command to execute when\n  Bitcoin Knots has finished with its startup sequence.\n\nsystemd init file\n-----------------\n\nThe systemd init file (`contrib/init/bitcoind.service`) has been changed\nto use `/var/lib/bitcoind` as the data directory instead of\n`~bitcoin/.bitcoin`. This change makes Bitcoin Knots more consistent with\nother services, and makes the systemd init config more consistent with\nexisting Upstart and OpenRC configs.\n\nThe configuration, PID, and data directories are now completely managed\nby systemd, which will take care of their creation, permissions, etc.\nSee [`systemd.exec(5)`]\n(https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RuntimeDirectory=)\nfor more details.\n\nWhen using the provided init files under `contrib/init`, overriding the\n`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect.\nThis is because the command line arguments specified in the init files\ntake precedence over the options specified in\n`/etc/bitcoin/bitcoin.conf`.\n\n\nDocumentation\n-------------\n\n- A new short [document]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)\n  about the JSON-RPC interface describes cases where the results of an\n  RPC might contain inconsistencies between data sourced from different\n  subsystems, such as wallet state and mempool state.  A note is added\n  to the [REST interface documentation]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md)\n  indicating that the same rules apply.\n\n- Further information is added to the [JSON-RPC\n  documentation]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)\n  about how to secure this interface.\n\n- A new [document]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md)\n  about the `bitcoin.conf` file describes how to use it to configure\n  Bitcoin Knots.\n\n- A new document introduces Bitcoin Knots's BIP174 [Partially-Signed\n  Bitcoin Transactions\n  (PSBT)](https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md)\n  interface, which is used to allow multiple programs to collaboratively\n  work to create, sign, and broadcast new transactions.  This is useful\n  for offline (cold storage) wallets, multisig wallets, coinjoin\n  implementations, and many other cases where two or more programs need\n  to interact to generate a complete transaction.\n\n- The [output script\n  descriptor]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)\n  documentation has been updated with information about new features in\n  this still-developing language for describing the output scripts that\n  a wallet or other program wants to receive notifications for, such as\n  which addresses it wants to know received payments.  The language is\n  currently used in multiple new and updated RPCs described in these\n  release notes and is expected to be adapted to other RPCs and to the\n  underlying wallet structure.\n\nBuild system changes\n--------------------\n\n- The minimum required version of Qt (when building the GUI) has been\n  increased from 5.2 to 5.5.1 (the [depends\n  system](https://github.com/bitcoin/bitcoin/blob/master/depends/README.md)\n  provides 5.9.7)\n\nNew RPCs\n--------\n\n- `listwalletdir` returns a list of wallets in the wallet directory\n  (either the default wallet directory or the directory configured by\n  the `-walletdir` parameter).\n\n- `getrpcinfo` returns runtime details of the RPC server. At the moment,\n  it returns an array of the currently active commands and how long\n  they've been running.\n\n- `deriveaddresses` returns one or more addresses corresponding to an\n  [output descriptor]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).\n\n- `getdescriptorinfo` accepts a descriptor and returns information about\n  it, including its computed checksum.\n\n- `joinpsbts` merges multiple distinct PSBTs into a single PSBT. The\n  multiple PSBTs must have different inputs. The resulting PSBT will\n  contain every input and output from all of the PSBTs. Any signatures\n  provided in any of the PSBTs will be dropped.\n\n- `analyzepsbt` examines a PSBT and provides information about what\n  the PSBT contains and the next steps that need to be taken in order\n  to complete the transaction. For each input of a PSBT, `analyzepsbt`\n  provides information about what information is missing for that\n  input, including whether a UTXO needs to be provided, what pubkeys\n  still need to be provided, which scripts need to be provided, and\n  what signatures are still needed. Every input will also list which\n  role is needed to complete that input, and `analyzepsbt` will also\n  list the next role in general needed to complete the PSBT.\n  `analyzepsbt` will also provide the estimated fee rate and estimated\n  virtual size of the completed transaction if it has enough\n  information to do so.\n\n- `utxoupdatepsbt` searches the set of Unspent Transaction Outputs\n  (UTXOs) to find the outputs being spent by the partial transaction.\n  PSBTs need to have the UTXOs being spent to be provided because\n  the signing algorithm requires information from the UTXO being spent.\n  For segwit inputs, only the UTXO itself is necessary.  For\n  non-segwit outputs, the entire previous transaction is needed so\n  that signers can be sure that they are signing the correct thing.\n  Unfortunately, because the UTXO set only contains UTXOs and not full\n  transactions, `utxoupdatepsbt` will only add the UTXO for segwit\n  inputs.\n\nUpdated RPCs\n------------\n\nNote: some low-level RPC changes mainly useful for testing are described\nin the Low-level Changes section below.\n\n- The mempool RPCs, such as `getrawmempool` with `verbose=true`, now\n  return an additional \"bip125-replaceable\" value indicating whether the\n  transaction (or its unconfirmed ancestors) opts-in to asking nodes and\n  miners to replace it with a higher-feerate transaction spending any of\n  the same inputs.\n\n- `settxfee` previously silently ignored attempts to set the fee below\n  the allowed minimums.  It now prints a warning.  The special value of\n  \"0\" may still be used to request the minimum value.\n\n- `importmulti` has been updated to support P2WSH, P2WPKH, P2SH-P2WPKH,\n  and P2SH-P2WSH. Requests for P2WSH and P2SH-P2WSH accept an additional\n  `witnessscript` parameter.\n\n- `importmulti` now returns an additional `warnings` field for each\n  request with an array of strings explaining when fields are being\n  ignored or are inconsistent, if there are any.\n\n- `getaddressinfo` now returns an additional `solvable` boolean field\n  when Bitcoin Knots knows enough about the address's scriptPubKey,\n  optional redeemScript, and optional witnessScript in order for the\n  wallet to be able to generate an unsigned input spending funds sent to\n  that address.\n\n- The `getaddressinfo`, `listunspent`, and `scantxoutset` RPCs now\n  return an additional `desc` field that contains an output descriptor\n  containing all key paths and signing information for the address\n  (except for the private key).  The `desc` field is only returned for\n  `getaddressinfo` and `listunspent` when the address is solvable.\n\n- `importprivkey` will preserve previously-set labels for addresses or\n  public keys corresponding to the private key being imported.  For\n  example, if you imported a watch-only address with the label \"cold\n  wallet\" in earlier releases of Bitcoin Knots, subsequently importing\n  the private key would default to resetting the address's label to the\n  default empty-string label (\"\").  In this release, the previous label\n  of \"cold wallet\" will be retained.  If you optionally specify any\n  label besides the default when calling `importprivkey`, the new label\n  will be applied to the address.\n\n- See the [Mining](#mining) section for changes to `getblocktemplate`.\n\n- `getmininginfo` now omits `currentblocksize`, `currentblockweight` and\n  `currentblocktx` when a block was never assembled via RPC on this node.\n  `currentblocksize` is also omitted if the `-blockmaxsize` option is\n  set to 4 MB or larger (and therefore ineffective).\n\n- The `getrawtransaction` RPC & REST endpoints no longer check the\n  unspent UTXO set for a transaction. The remaining behaviors are as\n  follows: 1. If a blockhash is provided, check the corresponding block.\n  2. If no blockhash is provided, check the mempool. 3. If no blockhash\n  is provided but txindex is enabled, also check txindex.\n\n- `unloadwallet` is now synchronous, meaning it will not return until\n  the wallet is fully unloaded.\n\n- `importmulti` now supports importing of addresses from descriptors. A\n  \"desc\" parameter can be provided instead of the \"scriptPubKey\" in a\n  request, as well as an optional range for ranged descriptors to\n  specify the start and end of the range to import. Descriptors with key\n  origin information imported through `importmulti` will have their key\n  origin information stored in the wallet for use with creating PSBTs.\n  More information about descriptors can be found\n  [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).\n\n- `listunspent` has been modified so that it also returns\n  `witnessScript`, the witness script in the case of a P2WSH or\n  P2SH-P2WSH output.\n\n- `createwallet` now has an optional `blank` argument that can be used\n  to create a blank wallet. Blank wallets do not have any keys or HD\n  seed.  They cannot be opened in software older than 0.18. Once a blank\n  wallet has a HD seed set (by using `sethdseed`) or private keys,\n  scripts, addresses, and other watch only things have been imported,\n  the wallet is no longer blank and can be opened in 0.17.x. Encrypting\n  a blank wallet will also set a HD seed for it.\n\n- `walletcreatefundedpsbt` now respects the `-walletrbf` option for its\n  default BIP125 RBF parameter.\n\n- `testmempoolaccept` and `sendrawtransaction` now accept a new `maxfeerate`\n  parameter to help avoid accidentally exceeding a given fee rate.\n\n- `getmempoolinfo` now has a `loaded` key in the result to indicate\n  completed loading of the saved mempool cache (or that it was skipped or\n  absent).\n\n- `getmempoolinfo` now accepts an optional parameter to get a fee histogram\n  in the result.\n\n- `getwalletinfo` includes a `scanning` key in its result, which will be\n  either `false` (to indicate no scanning in progress), or progress\n  information.\n\nDeprecated or removed RPCs\n--------------------------\n\n- `signrawtransaction` is removed after being deprecated and hidden\n  behind a special configuration option in version 0.17.0.\n\n- The 'account' API is removed after being deprecated in v0.17.  The\n  'label' API was introduced in v0.17 as a replacement for accounts.\n  See the [release notes from\n  v0.17]\n(https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.17.0.md#label-and-account-apis-for-wallet)\n  for a full description of the changes from the 'account' API to the\n  'label' API.\n\n- `addwitnessaddress` is removed after being deprecated in version\n  0.16.0.\n\n- `generate` is deprecated and will be fully removed in a subsequent\n  major version.  This RPC is only used for testing, but its\n  implementation reached across multiple subsystems (wallet and mining),\n  so it is being deprecated to simplify the wallet-node interface.\n  Projects that are using `generate` for testing purposes should\n  transition to using the `generatetoaddress` RPC, which does not\n  require or use the wallet component. Calling `generatetoaddress` with\n  an address returned by the `getnewaddress` RPC gives the same\n  functionality as the old `generate` RPC.  To continue using `generate`\n  in this version, restart bitcoind with the `-deprecatedrpc=generate`\n  configuration option.\n\n- Be reminded that parts of the `validateaddress` command have been\n  deprecated and moved to `getaddressinfo`. The following deprecated\n  fields have moved to `getaddressinfo`: `ismine`, `iswatchonly`,\n  `script`, `hex`, `pubkeys`, `sigsrequired`, `pubkey`, `embedded`,\n  `iscompressed`, `label`, `timestamp`, `hdkeypath`, `hdmasterkeyid`.\n\n- The `addresses` field has been removed from the `validateaddress`\n  and `getaddressinfo` RPC methods.  This field was confusing since\n  it referred to public keys using their P2PKH address.  Clients\n  should use the `embedded.address` field for P2SH or P2WSH wrapped\n  addresses, and `pubkeys` for inspecting multisig participants.\n\n- Due to apparent lack of interest, the `verifyscript` method has been\n  removed.\n\nREST changes\n------------\n\n- A new `/rest/blockhashbyheight/` endpoint is added for fetching the\n  hash of the block in the current best blockchain based on its height\n  (how many blocks it is after the Genesis Block). This replaces the\n  older `/rest/blockhash/` endpoint which did the same thing, and is\n  now deprecated. Note that the new API uses a HTTP 404 Not Found\n  response for heights beyond the current chain length, has inverted\n  the order of bytes for hex format, and uses a \"blockhash\" key for\n  JSON format.\n\n- The `/rest/mempool/info.json` endpoint now has a `loaded` key in the\n  result to indicate completed loading of the saved mempool cache (or that\n  it was skipped or absent).\n\n- A new REST `/rest/mempool/info/with_fee_histogram` endpoint parallels\n  `/rest/mempool/info`, but adds a fee histogram to the result.\n\nGraphical User Interface (GUI)\n------------------------------\n\n- In the Send tab, the checkbox for \"pay only the required fee\" has been\n  removed.  Instead, the user can simply decrease the value in the\n  Custom Feerate field all the way down to the node's configured minimum\n  relay fee.\n\n- The special send-to-self transaction record type has been removed.\n  Instead, all such transactions (including old transactions) will now\n  be displayed as a pair of send and receive (or possibly multiple\n  receives, in some circumstances).\n\n- A new experimental Pairing tab has been added to assist in linking\n  other wallet software (for example, such as you might have on your\n  phone) with your node. Note that it is likely the pairing address\n  displayed will change in future versions, possibly requiring\n  re-pairing.\n\n- In the Overview tab, the watch-only balance will be the only balance\n  shown if the wallet was created using the `createwallet` RPC and the\n  `disable_private_keys` parameter was set to true.\n\n- The launch-on-startup option is no longer available on macOS if\n  compiled with macosx min version greater than 10.11 (use\n  CXXFLAGS=\"-mmacosx-version-min=10.11\"\n  CFLAGS=\"-mmacosx-version-min=10.11\" for setting the deployment sdk\n  version)\n\n- Tonal Bitcoin support is now stricter with font detection. If you\n  use Tonal Bitcoin and no longer have TBC unit options visible, try\n  another font and/or open an issue on GitHub.\n\nTools\n-----\n\n- A new `bitcoin-wallet` tool is now distributed alongside Bitcoin\n  Knots's other executables.  Without needing to use any RPCs, this tool\n  can currently create a new wallet file or display some basic\n  information about an existing wallet, such as whether the wallet is\n  encrypted, whether it uses an HD seed, how many transactions it\n  contains, and how many address book entries it has.\n\n- Due to apparent lack of interest, support for Script debugging has been\n  removed from libbitcoinconsensus.\n\nPlanned changes\n===============\n\nThis section describes planned changes to Bitcoin Knots that may affect\nother Bitcoin software and services.\n\nDeprecated P2P messages\n-----------------------\n\n- BIP 61 reject messages are now deprecated. Reject messages have no use\n  case on the P2P network and are only logged for debugging by most\n  network nodes. Furthermore, they increase bandwidth and can be harmful\n  for privacy and security. It has been possible to disable BIP 61\n  messages since v0.17 with the `-enablebip61=0` option. BIP 61 messages\n  will be disabled by default in a future version, before being removed\n  entirely.\n\nLow-level changes\n=================\n\nThis section describes RPC changes mainly useful for testing, mostly not\nrelevant in production. The changes are mentioned for completeness.\n\nRPC\n---\n\n- The `submitblock` RPC previously returned the reason a rejected block\n  was invalid the first time it processed that block, but returned a\n  generic \"duplicate\" rejection message on subsequent occasions it\n  processed the same block.  It now always returns the fundamental\n  reason for rejecting an invalid block and only returns \"duplicate\" for\n  valid blocks it has already accepted.\n\n- A new `submitheader` RPC allows submitting block headers independently\n  from their block.  This is likely only useful for testing.\n\n- The `signrawtransactionwithkey` and `signrawtransactionwithwallet`\n  RPCs have been modified so that they also optionally accept a\n  `witnessScript`, the witness script in the case of a P2WSH or\n  P2SH-P2WSH output. This is compatible with the change to\n  `listunspent`.\n\n- For the `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs, if the\n  `bip32derivs` parameter is set to true but the key metadata for a\n  public key has not been updated yet, then that key will have a\n  derivation path as if it were just an independent key (i.e. no\n  derivation path and its master fingerprint is itself).\n\nConfiguration\n-------------\n\n- The `-usehd` configuration option was removed in version 0.16. From\n  that version onwards, all new wallets created are hierarchical\n  deterministic wallets. This release makes specifying `-usehd` an\n  invalid configuration option.\n\nNetwork\n-------\n\n- This release allows peers that your node automatically disconnected\n  for misbehavior (e.g. sending invalid data) to reconnect to your node\n  if you have unused incoming connection slots.  If your slots fill up,\n  a misbehaving node will be disconnected to make room for nodes without\n  a history of problems (unless the misbehaving node helps your node in\n  some other way, such as by connecting to a part of the Internet from\n  which you don't have many other peers).  Previously, Bitcoin Knots\n  banned the IP addresses of misbehaving peers for a period of time\n  (default of 1 day); this was easily circumvented by attackers with\n  multiple IP addresses. If you manually ban a peer, such as by using\n  the `setban` RPC, all connections from that peer will still be\n  rejected.\n\nWallet\n-------\n\n- The key metadata will need to be upgraded the first time that the HD\n  seed is available.  For unencrypted wallets this will occur on wallet\n  loading.  For encrypted wallets this will occur the first time the\n  wallet is unlocked.\n\n- Newly encrypted wallets will no longer require restarting the\n  software. Instead such wallets will be completely unloaded and\n  reloaded to achieve the same effect.\n\n- A sub-project of Bitcoin Core now provides Hardware Wallet Interaction\n  (HWI) scripts that allow command-line users to use several popular\n  hardware key management devices with Bitcoin Knots.  See their [project\n  page](https://github.com/bitcoin-core/HWI#readme) for details.\n\nSecurity\n--------\n\n- This release changes the Random Number Generator (RNG) used from\n  OpenSSL to Bitcoin Core's implementation, although entropy gathered\n  by Bitcoin Knots is fed out to OpenSSL and then read back in when the\n  program needs strong randomness. This moves Bitcoin Knots a little\n  closer to no longer needing to depend on OpenSSL, a dependency that\n  has caused security issues in the past.  The new implementation\n  gathers entropy from multiple sources, including from hardware\n  supporting the rdseed CPU instruction.\n\n0.18.0 change log\n=================\n\n### Consensus\n- n/a *Update checkpoints and chain params, adding a new checkpoint at block \n571,392 (luke-jr)\n\n### Policy\n- #15846 *Policy-accept sending to future native witness outputs \nwith -sendtofuture=1 (luke-jr)\n- #15846 *Policy: Enable -sendtofuture=1 by default (except with -corepolicy) \n(luke-jr)\n- n/a *Reduce default block size/weight to a safer 300kB/1.5MWU (luke-jr)\n\n### Mining\n- #14811 Mining: Enforce that segwit option must be set in GBT (jnewbery)\n\n### Block and transaction handling\n- #13310 Report progress in ReplayBlocks while rolling forward (promag)\n- #13783 validation: Pass tx pool reference into CheckSequenceLocks \n(MarcoFalke)\n- #14834 validation: Assert that pindexPrev is non-null when required \n(kallewoof)\n- #14085 index: Fix for indexers skipping genesis block (jimpo)\n- #14963 mempool, validation: Explain `cs_main` locking semantics (MarcoFalke)\n- #15193 Default `-whitelistforcerelay` to off (sdaftuar)\n- #15552 Granular invalidateblock and RewindBlockIndex (MarcoFalke)\n- #14841 Move CheckBlock() call to critical section (hebasto)\n- #15218 *validation: flush state after initial sync (andrewtoth)\n\n### P2P protocol and network code\n- #14025 Remove dead code for nVersion=10300 (MarcoFalke)\n- #12254 BIP 158: Compact Block Filters for Light Clients (jimpo)\n- #14073 blockfilter: Avoid out-of-bounds script access (jimpo)\n- #14140 Switch nPrevNodeCount to vNodesSize (pstratem)\n- #14027 Skip stale tip checking if outbound connections are off or if \nreindexing (gmaxwell)\n- #14532 Never bind `INADDR_ANY` by default, and warn when doing so explicitly \n(luke-jr)\n- #14733 Make peer timeout configurable, speed up very slow test and ensure \ncorrect code path tested (zallarak)\n- #14336 Implement poll (pstratem)\n- #15051 IsReachable is the inverse of IsLimited (DRY). Includes unit tests \n(mmachicao)\n- #15138 Drop IsLimited in favor of IsReachable (Empact)\n- #14605 Return of the Banman (dongcarl)\n- #14929 Allow connections from misbehavior banned peers (gmaxwell)\n- #15345 Correct comparison of addr count (dongcarl)\n- #15201 Add missing locking annotation for vNodes. vNodes is guarded by \ncs_vNodes (practicalswift)\n- #14626 Select orphan transaction uniformly for eviction (sipa)\n- #15486 Ensure tried collisions resolve, and allow feeler connections to \nexisting outbound netgroups (sdaftuar)\n- #15558 *Do not query all DNS seed at once (sipa)\n- #15651 *torcontrol: Use the default/standard network port for Tor hidden \nservices, even if the internal port is set differently (luke-jr)\n- #15423 *torcontrol: Query Tor for correct -onion configuration (luke-jr)\n- #15633 *Ignore BIP-152 HB requests from non-witness peers. (gmaxwell)\n\n### Wallet\n- #13962 Remove unused `dummy_tx` variable from FillPSBT (dongcarl)\n- #13967 Don't report `minversion` wallet entry as unknown (instagibbs)\n- #13988 Add checks for settxfee reasonableness (ajtowns)\n- #12559 Avoid locking `cs_main` in some wallet RPC (promag)\n- #13631 Add CMerkleTx::IsImmatureCoinBase method (Empact)\n- #14023 Remove accounts RPCs (jnewbery)\n- #13825 Kill accounts (jnewbery)\n- #10605 Add AssertLockHeld assertions in CWallet::ListCoins (ryanofsky)\n- #12490 Remove deprecated wallet rpc features from `bitcoin_server` \n(jnewbery)\n- #14138 Set `encrypted_batch` to nullptr after delete. Avoid double free in \nthe case of NDEBUG (practicalswift)\n- #14168 Remove `ENABLE_WALLET` from `libbitcoin_server.a` (jnewbery)\n- #12493 Reopen CDBEnv after encryption instead of shutting down (achow101)\n- #14282 Remove `-usehd` option (jnewbery)\n- #14146 Remove trailing separators from `-walletdir` arg (PierreRochard)\n- #14291 Add ListWalletDir utility function (promag)\n- #14468 Deprecate `generate` RPC method (jnewbery)\n- #11634 Add missing `cs_wallet`/`cs_KeyStore` locks to wallet \n(practicalswift)\n- #14296 Remove `addwitnessaddress` (jnewbery)\n- #14451 Add BIP70 deprecation warning (jameshilliard)\n- #14320 Fix duplicate fileid detection (ken2812221)\n- #14561 Remove `fs::relative` call and fix listwalletdir tests (promag)\n- #14454 Add SegWit support to importmulti (MeshCollider)\n- #14350 Add WalletLocation class (promag)\n- #14689 Require a public key to be retrieved when signing a P2PKH input \n(achow101)\n- #14478 Show error to user when corrupt wallet unlock fails (MeshCollider)\n- #14552 Detect duplicate wallet by comparing the db filename (ken2812221)\n- #14678 Remove redundant KeyOriginInfo access, already done in CreateSig \n(instagibbs)\n- #14477 Add ability to convert solvability info to descriptor (sipa)\n- #14760 Log env path in `BerkeleyEnvironment::Flush` (promag)\n- #14646 Add expansion cache functions to descriptors (unused for now) (sipa)\n- #13076 Fix ScanForWalletTransactions to return an enum indicating scan \nresult: `success` / `failure` / `user_abort` (Empact)\n- #14821 Replace CAffectedKeysVisitor with descriptor based logic (sipa)\n- #14957 Initialize `stop_block` in CWallet::ScanForWalletTransactions \n(Empact)\n- #14565 Overhaul `importmulti` logic (sipa)\n- #15039 Avoid leaking nLockTime fingerprint when anti-fee-sniping \n(MarcoFalke)\n- #14268 Introduce SafeDbt to handle Dbt with free or `memory_cleanse` \nraii-style (Empact)\n- #14711 Remove uses of chainActive and mapBlockIndex in wallet code \n(ryanofsky)\n- #15279 Clarify rescanblockchain doc (MarcoFalke)\n- #15292 Remove `boost::optional`-related false positive -Wmaybe-uninitialized \nwarnings on GCC compiler (hebasto)\n- #13926 [Tools] bitcoin-wallet - a tool for creating and managing wallets \noffline (jnewbery)\n- #11911 Free BerkeleyEnvironment instances when not in use (ryanofsky)\n- #15235 Do not import private keys to wallets with private keys disabled \n(achow101)\n- #15263 Descriptor expansions only need pubkey entries for PKH/WPKH (sipa)\n- #15322 Add missing `cs_db` lock (promag)\n- #15297 Releases dangling files on `BerkeleyEnvironment::Close` (promag)\n- #14491 Allow descriptor imports with importmulti (MeshCollider)\n- #15365 Add lock annotation for mapAddressBook (MarcoFalke)\n- #15226 Allow creating blank (empty) wallets (alternative) (achow101)\n- #15390 [wallet-tool] Close bdb when flushing wallet (jnewbery)\n- #15334 Log absolute paths for the wallets (hebasto)\n- #14978 Factor out PSBT utilities from RPCs for use in GUI code; related \nrefactoring (gwillen)\n- #14481 Add P2SH-P2WSH support to listunspent RPC (MeshCollider)\n- #14021 Import key origin data through descriptors in importmulti (achow101)\n- #14075 Import watch only pubkeys to the keypool if private keys are disabled \n(achow101)\n- #15368 Descriptor checksums (sipa)\n- #15433 Use a single wallet batch for `UpgradeKeyMetadata` (jonasschnelli)\n- #15408 Remove unused `TransactionError` constants (MarcoFalke)\n- #15583 Log and ignore errors in ListWalletDir and IsBerkeleyBtree (promag)\n- #14195 Pass privkey export DER compression flag correctly (fingera)\n- #15299 Fix assertion in `CKey::SignCompact` (promag)\n- #14437 Start to separate wallet from node (ryanofsky)\n- #15749 Fix: importmulti only imports origin info for PKH outputs (sipa)\n- #15913 *Bugfix: dummywallet: Add -ignorepartialspends to list of ignored \nwallet options (luke-jr)\n- #15911 *[rpc] walletcreatefundedpsbt: use wallet default RBF (Sjors)\n- #9152 *RPC/Wallet: Use BroadcastTransaction for sweepprivkeys to ensure \nwallet is synced before we return (luke-jr)\n- #13541 *wallet/rpc: add maxfeerate parameter to testmempoolaccept and \nsendrawtransaction (kallewoof)\n\n### RPC and other APIs\n- #12842 Prevent concurrent `savemempool` (promag)\n- #13891 Remove getinfo deprecation warning (jnewbery)\n- #13399 Add `submitheader` (MarcoFalke)\n- #13723 PSBT key path cleanups (sipa)\n- #14008 Preserve a format of RPC command definitions (kostyantyn)\n- #13983 Return more specific reject reason for submitblock (MarcoFalke)\n- #14298 rest: Improve performance for JSON calls (alecalve)\n- #14297 Remove warning for removed estimatefee RPC (jnewbery)\n- #14373 Consistency fixes for RPC descriptions (ch4ot1c)\n- #14150 Add key origin support to descriptors (sipa)\n- #14518 Always throw in getblockstats if `-txindex` is required (promag)\n- #13381 Add possibility to preserve labels on importprivkey (marcoagner)\n- #14530 Use `RPCHelpMan` to generate RPC doc strings (MarcoFalke)\n- #14720 Correctly name RPC arguments (MarcoFalke)\n- #14726 Use `RPCHelpMan` for all RPCs (MarcoFalke)\n- #14796 Pass argument descriptions to `RPCHelpMan` (MarcoFalke)\n- #14670 http: Fix HTTP server shutdown (promag)\n- #14885 Assert that named arguments are unique in `RPCHelpMan` (promag)\n- #14877 Document default values for optional arguments (MarcoFalke)\n- #14875 RPCHelpMan: Support required arguments after optional ones \n(MarcoFalke)\n- #14993 Fix data race (UB) in InterruptRPC() (practicalswift)\n- #14653 rpcwallet: Add missing transaction categories to RPC helptexts \n(andrewtoth)\n- #14981 Clarify RPC `getrawtransaction`'s time help text (benthecarman)\n- #12151 Remove `cs_main` lock from blockToJSON and blockheaderToJSON (promag)\n- #15078 Document `bytessent_per_msg` and `bytesrecv_per_msg` (MarcoFalke)\n- #15057 Correct `reconsiderblock `help text, add test (MarcoFalke)\n- #12153 Avoid permanent `cs_main` lock in `getblockheader` (promag)\n- #14982 Add `getrpcinfo` command (promag)\n- #15122 Expand help text for `importmulti` changes (jnewbery)\n- #15186 remove duplicate solvable field from `getaddressinfo` (fanquake)\n- #15209 zmq: log outbound message high water mark when reusing socket \n(fanquake)\n- #15177 rest: Improve tests and documention of /headers and /block (promag)\n- #14353 rest: Add blockhash call, fetch blockhash by height (jonasschnelli)\n- #15248 Compile on GCC4.8 (MarcoFalke)\n- #14987 RPCHelpMan: Pass through Result and Examples (MarcoFalke)\n- #15159 Remove lookup to UTXO set from GetTransaction (amitiuttarwar)\n- #15245 remove deprecated mentions of signrawtransaction from fundraw help \n(instagibbs)\n- #14667 Add `deriveaddresses` RPC util method (Sjors)\n- #15357 Don't ignore `-maxtxfee` when wallet is disabled (JBaczuk)\n- #15337 Fix for segfault if combinepsbt called with empty inputs \n(benthecarman)\n- #14918 RPCHelpMan: Check default values are given at compile-time \n(MarcoFalke)\n- #15383 mining: Omit uninitialized currentblockweight, currentblocktx \n(MarcoFalke)\n- #13932 Additional utility RPCs for PSBT (achow101)\n- #15401 Actually throw help when passed invalid number of params (MarcoFalke)\n- #15497 Consistent range arguments in \nscantxoutset/importmulti/deriveaddresses (sipa)\n- #15510 deriveaddresses: add range to CRPCConvertParam (Sjors)\n- #15582 Fix overflow bug in analyzepsbt fee: CAmount instead of int (sipa)\n- #13424 Consistently validate txid / blockhash length and encoding in rpc \ncalls (Empact)\n- #15750 Remove the addresses field from the getaddressinfo return object \n(jnewbery)\n- n/a *Bugfix: httpserver: Close listen socket if we fail to make an evhttp \nhandle (luke-jr)\n- #15323 *rpc: Expose g_is_mempool_loaded via getmempoolinfo \nand /rest/mempool/info.json (Empact)\n- #15730 *rpc: Show scanning details in getwalletinfo (promag)\n- #15836 *Add feerate histogram to getmempoolinfo (jonasschnelli)\n- #15861 *rpc/gui: Refactor 'Unknown block versions being mined' warning \n(luke-jr)\n- n/a *Removed verifyscript method (luke-jr)\n- n/a *Removed libbitcoinconsensus Script debugging support (luke-jr)\n- #15932 *rpc: Serialize in getblock without cs_main (MarcoFalke)\n\n### GUI\n- #13634 Compile `boost::signals2` only once (MarcoFalke)\n- #13248 Make proxy icon from statusbar clickable (mess110)\n- #13529 Use new Qt5 connect syntax (promag)\n- #14162 Also log and print messages or questions like bitcoind (MarcoFalke)\n- #14385 Avoid system harfbuzz and bz2 (theuni)\n- #14450 Fix QCompleter popup regression (hebasto)\n- #14177 Set C locale for amountWidget (hebasto)\n- #14374 Add `Blocksdir` to Debug window (hebasto)\n- #14554 Remove unused `adjustedTime` parameter (hebasto)\n- #14608 Remove the \"Pay only required fee\u2026\" checkbox (hebasto)\n- #14521 qt, docs: Fix `bitcoin-qt -version` output formatting (hebasto)\n- #13966 When private key is disabled, only show watch-only balance \n(ken2812221)\n- #14828 Remove hidden columns in coin control dialog (promag)\n- #14783 Fix `boost::signals2::no_slots_error` in early calls to InitWarning \n(promag)\n- #14854 Cleanup SplashScreen class (hebasto)\n- #14801 Use window() instead of obsolete topLevelWidget() (hebasto)\n- #14975 Refactoring with QString::toNSString() (hebasto)\n- #15000 Fix broken notificator on GNOME (hebasto)\n- #14375 Correct misleading \"overridden options\" label (hebasto)\n- #15007 Notificator class refactoring (hebasto)\n- #14784 Use `WalletModel*` instead of the wallet name as map key (promag)\n- #11625 Add BitcoinApplication & RPCConsole tests (ryanofsky)\n- #13216 implements concept for different disk sizes on intro (marcoagner)\n- #15114 Replace remaining 0 with nullptr (Empact)\n- #14594 Fix minimized window bug on Linux (hebasto)\n- #14556 Fix confirmed transaction labeled \"open\" (#13299) (hebasto)\n- #15149 Show current wallet name in window title (promag)\n- #15136 \"Peers\" tab overhaul (hebasto)\n- #14250 Remove redundant stopThread() and stopExecutor() signals (hebasto)\n- #15040 Add workaround for QProgressDialog bug on macOS (hebasto)\n- #15101 Add WalletController (promag)\n- #15178 Improve \"help-console\" message (hebasto)\n- #15210 Fix window title update (promag)\n- #15167 Fix wallet selector size adjustment (hebasto)\n- #15208 Remove macOS launch-at-startup when compiled with > macOS 10.11, fix \nmemory mismanagement (jonasschnelli)\n- #15163 Correct units for \"-dbcache\" and \"-prune\" (hebasto)\n- #15225 Change the receive button to respond to keypool state changing \n(achow101)\n- #15280 Fix shutdown order (promag)\n- #15203 Fix issue #9683 \"gui, wallet: random abort (segmentation fault) \n(dooglus)\n- #15091 Fix model overlay header sync (jonasschnelli)\n- #15153 Add Open Wallet menu (promag)\n- #15183 Fix `m_assumed_blockchain_size` variable value (marcoagner)\n- #15063 If BIP70 is disabled, attempt to fall back to BIP21 parsing (luke-jr)\n- #15195 Add Close Wallet action (promag)\n- #15462 Fix async open wallet call order (promag)\n- #15801 Bugfix: GUI: Options: Initialise prune setting range before loading \ncurrent value, and remove upper bound limit (luke-jr)\n- #11750 *CoinControl: Remove selection-only counter (luke-jr)\n- #15115 *Replace send-to-self with dual send+receive entries (luke-jr)\n- #15371 *Uppercase bech32 addresses in qr codes (benthecarman)\n- #15428 *Add Pairing tab with Tor onion address as copyable text and QR code \n(luke-jr)\n- #7510 *Various improvements for pruning controls (luke-jr)\n- #929 *Bugfix: GUI: bitcoinunits: Don't make unitlist static, since it gets \nrebuilt every call (luke-jr)\n- #929 *tonalutils: For Tonal support detection, check that the font has all \nglyphs and they all have the same sizes (luke-jr)\n- n/a *update receiving address book description to refer to receive tab for \nnew addresses (HatboyWonder)\n- n/a *Qt/Options: Configure sendtofuture using rwconf (luke-jr)\n\n### Build system\n- #13955 gitian: Bump descriptors for (0.)18 (fanquake)\n- #13899 Enable -Wredundant-decls where available. Remove redundant \nredeclarations (practicalswift)\n- #13665 Add RISC-V support to gitian (ken2812221)\n- #14062 Generate MSVC project files via python script (ken2812221)\n- #14037 Add README.md to linux release tarballs (hebasto)\n- #14183 Remove unused Qt 4 dependencies (ken2812221)\n- #14127 Avoid getifaddrs when unavailable (greenaddress)\n- #14184 Scripts and tools: increased timeout downloading (cisba)\n- #14204 Move `interfaces/*` to `libbitcoin_server` (laanwj)\n- #14208 Actually remove `ENABLE_WALLET` (jnewbery)\n- #14212 Remove libssl from LDADD unless GUI (MarcoFalke)\n- #13578 Upgrade zeromq to 4.2.5 and avoid deprecated zeromq API functions \n(mruddy)\n- #14281 lcov: filter /usr/lib/ from coverage reports (MarcoFalke)\n- #14325 gitian: Use versioned unsigned tarballs instead of generically named \nones (achow101)\n- #14253 During 'make clean', remove some files that are currently missed \n(murrayn)\n- #14455 Unbreak `make clean` (jamesob)\n- #14495 Warn (don't fail!) on spelling errors (practicalswift)\n- #14496 Pin to specific versions of Python packages we install from PyPI in \nTravis (practicalswift)\n- #14568 Fix Qt link order for Windows build (ken2812221)\n- #14252 Run functional tests and benchmarks under the undefined behaviour \nsanitizer (UBSan) (practicalswift)\n- #14612 Include full version number in released file names (achow101)\n- #14840 Remove duplicate libconsensus linking in test make (AmirAbrams)\n- #14883 Add `--retry 5` to curl opts in `install_db4.sh` (qubenix)\n- #14701 Add `CLIENT_VERSION_BUILD` to CFBundleGetInfoString (fanquake)\n- #14849 Qt 5.9.7 (fanquake)\n- #15020 Add names to Travis jobs (gkrizek)\n- #15047 Allow to configure --with-sanitizers=fuzzer (MarcoFalke)\n- #15154 Configure: bitcoin-tx doesn't need libevent, so don't pull it in \n(luke-jr)\n- #15175 Drop macports support (Empact)\n- #15308 Restore compatibility with older boost (Empact)\n- #15407 msvc: Fix silent merge conflict between #13926 and #14372 part II \n(ken2812221)\n- #15388 Makefile.am: add rule for src/bitcoin-wallet (Sjors)\n- #15393 Bump minimum Qt version to 5.5.1 (Sjors)\n- #15285 Prefer Python 3.4 even if newer versions are present on the system \n(Sjors)\n- #15398 msvc: Add rapidcheck property tests (ken2812221)\n- #15431 msvc: scripted-diff: Remove NDEBUG pre-define in project file \n(ken2812221)\n- #15549 gitian: Improve error handling (laanwj)\n- #15548 use full version string in setup.exe (MarcoFalke)\n- #11526 Visual Studio build configuration for Bitcoin Core (sipsorcery)\n- #15110 build\\_msvc: Fix the build problem in `libbitcoin_server` (Mr-Leshiy)\n- #14372 msvc: build secp256k1 and leveldb locally (ken2812221)\n- #15325 msvc: Fix silent merge conflict between #13926 and #14372 \n(ken2812221)\n- #15391 Add compile time verification of assumptions we're currently making \nimplicitly/tacitly (practicalswift)\n- #15503 msvc: Use a single file to specify the include path (ken2812221)\n- #13765 contrib: Add gitian build support for github pull request \n(ken2812221)\n- #15809 gitignore: plist and dat (jamesob)\n\n### Tests and QA\n- #15405 appveyor: Clean cache when build configuration changes (Sjors)\n- #13953 Fix deprecation in bitcoin-util-test.py (isghe)\n- #13963 Replace usage of tostring() with tobytes() (dongcarl)\n- #13964 ci: Add appveyor ci (ken2812221)\n- #13997 appveyor: fetch the latest port data (ken2812221)\n- #13707 Add usage note to check-rpc-mappings.py (masonicboom)\n- #13861 Add testing of `value_ret` for SelectCoinsBnB (Empact)\n- #13863 travis: Move script sections to files in `.travis/` subject to \nshellcheck (scravy)\n- #14081 travis: Fix missing differentiation between unit and functional tests \n(scravy)\n- #14042 travis: Add cxxflags=-wno-psabi at arm job (ken2812221)\n- #14051 Make `combine_logs.py` handle multi-line logs (jnewbery)\n- #14093 Fix accidental trunction from int to bool (practicalswift)\n- #14108 Add missing locking annotations and locks (`g_cs_orphans`) \n(practicalswift)\n- #14088 Don't assert(\u2026) with side effects (practicalswift)\n- #14086 appveyor: Use clcache to speed up build (ken2812221)\n- #13954 Warn (don't fail!) on spelling errors. Fix typos reported by \ncodespell (practicalswift)\n- #12775 Integration of property based testing into Bitcoin Core (Christewart)\n- #14119 Read reject reasons from debug log, not P2P messages (MarcoFalke)\n- #14189 Fix silent merge conflict in `wallet_importmulti` (MarcoFalke)\n- #13419 Speed up `knapsack_solver_test` by not recreating wallet 100 times \n(lucash-dev)\n- #14199 Remove redundant BIP174 test from `rpc_psbt.json` (araspitzu)\n- #14179 Fixups to \"Run all tests even if wallet is not compiled\" (MarcoFalke)\n- #14225 Reorder tests and move most of extended tests up to normal tests \n(ken2812221)\n- #14236 `generate` --> `generatetoaddress` change to allow tests run without \nwallet (sanket1729)\n- #14287 Use MakeUnique to construct objects owned by `unique_ptrs` \n(practicalswift)\n- #14007 Run functional test on Windows and enable it on Appveyor (ken2812221)\n- #14275 Write the notification message to different files to avoid race \ncondition in `feature_notifications.py` (ken2812221)\n- #14306 appveyor: Move AppVeyor YAML to dot-file-style YAML (MitchellCash)\n- #14305 Enforce critical class instance attributes in functional tests, fix \nsegwit test specificity (JustinTArthur)\n- #14316 Exclude all tests with difference parameters in `--exclude` list \n(ken2812221)\n- #14381 Add missing call to `skip_if_no_cli()` (practicalswift)\n- #14389 travis: Set codespell version to avoid breakage (MarcoFalke)\n- #14398 Don't access out of bounds array index: array[sizeof(array)] (Empact)\n- #14419 Remove `rpc_zmq.py` (jnewbery)\n- #14241 appveyor: Script improvement (ken2812221)\n- #14413 Allow closed RPC handler in `assert_start_raises_init_error` \n(ken2812221)\n- #14324 Run more tests with wallet disabled (MarcoFalke)\n- #13649 Allow arguments to be forwarded to flake8 in lint-python.sh (jamesob)\n- #14465 Stop node before removing the notification file (ken2812221)\n- #14460 Improve 'CAmount' tests (hebasto)\n- #14456 forward timeouts properly in `send_blocks_and_test` (jamesob)\n- #14527 Revert \"Make qt wallet test compatible with qt4\" (MarcoFalke)\n- #14504 Show the progress of functional tests (isghe)\n- #14559 appveyor: Enable multiwallet tests (ken2812221)\n- #13515 travis: Enable qt for all jobs (ken2812221)\n- #14571 Test that nodes respond to `getdata` with `notfound` (MarcoFalke)\n- #14569 Print dots by default in functional tests (ken2812221)\n- #14631 Move deterministic address import to `setup_nodes` (jnewbery)\n- #14630 test: Remove travis specific code (MarcoFalke)\n- #14528 travis: Compile once on xenial (MarcoFalke)\n- #14092 Dry run `bench_bitcoin` as part `make check` to allow for quick \nidentification of assertion/sanitizer failures in benchmarking code \n(practicalswift)\n- #14664 `example_test.py`: fixup coinbase height argument, derive number \nclearly (instagibbs)\n- #14522 Add invalid P2P message tests (jamesob)\n- #14619 Fix value display name in `test_runner` help text (merland)\n- #14672 Send fewer spam messages in `p2p_invalid_messages` (jamesob)\n- #14673 travis: Fail the ubsan travis build in case of newly introduced ubsan \nerrors (practicalswift)\n- #14665 appveyor: Script improvement part II (ken2812221)\n- #14365 Add Python dead code linter (vulture) to Travis (practicalswift)\n- #14693 `test_node`: `get_mem_rss` fixups (MarcoFalke)\n- #14714 util.h: explicitly include required QString header (1Il1)\n- #14705 travis: Avoid timeout on verify-commits check (MarcoFalke)\n- #14770 travis: Do not specify sudo in `.travis` (scravy)\n- #14719 Check specific reject reasons in `feature_block` (MarcoFalke)\n- #14771 Add `BOOST_REQUIRE` to getters returning optional (MarcoFalke)\n- #14777 Add regtest for JSON-RPC batch calls (domob1812)\n- #14764 travis: Run thread sanitizer on unit tests (MarcoFalke)\n- #14400 Add Benchmark to test input de-duplication worst case (JeremyRubin)\n- #14812 Fix `p2p_invalid_messages` on macOS (jamesob)\n- #14813 Add `wallet_encryption` error tests (MarcoFalke)\n- #14820 Fix `descriptor_tests` not checking ToString output of public \ndescriptors (ryanofsky)\n- #14794 Add AddressSanitizer (ASan) Travis build (practicalswift)\n- #14822 bench: Destroy wallet txs instead of leaking their memory \n(MarcoFalke)\n- #14683 Better `combine_logs.py` behavior (jamesob)\n- #14231 travis: Save cache even when build or test fail (ken2812221)\n- #14816 Add CScriptNum decode python implementation in functional suite \n(instagibbs)\n- #14861 Modify `rpc_bind` to conform to #14532 behaviour (dongcarl)\n- #14864 Run scripted-diff in subshell (dongcarl)\n- #14795 Allow `test_runner` command line to receive parameters for each test \n(marcoagner)\n- #14788 Possible fix the permission error when the tests open the cookie file \n(ken2812221)\n- #14857 `wallet_keypool_topup.py`: Test for all keypool address types \n(instagibbs)\n- #14886 Refactor importmulti tests (jnewbery)\n- #14908 Removed implicit CTransaction constructor calls from tests and \nbenchmarks (lucash-dev)\n- #14903 Handle ImportError explicitly, improve comparisons against None \n(daniel-s-ingram)\n- #14884 travis: Enforce python 3.4 support through linter (Sjors)\n- #14940 Add test for truncated pushdata script (MarcoFalke)\n- #14926 consensus: Check that final transactions are valid (MarcoFalke)\n- #14937 travis: Fix travis would always be green even if it fail (ken2812221)\n- #14953 Make `g_insecure_rand_ctx` `thread_local` (MarcoFalke)\n- #14931 mempool: Verify prioritization is dumped correctly (MarcoFalke)\n- #14935 Test for expected return values when calling functions returning a \nsuccess code (practicalswift)\n- #14969 Fix `cuckoocache_tests` TSAN failure introduced in 14935 \n(practicalswift)\n- #14964 Fix race in `mempool_accept` (MarcoFalke)\n- #14829 travis: Enable functional tests in the threadsanitizer (tsan) build \njob (practicalswift)\n- #14985 Remove `thread_local` from `test_bitcoin` (MarcoFalke)\n- #15005 Bump timeout to run tests in travis thread sanitizer (MarcoFalke)\n- #15013 Avoid race in `p2p_timeouts` (MarcoFalke)\n- #14930 pruning: Check that verifychain can be called when pruned \n(MarcoFalke)\n- #15022 Upgrade Travis OS to Xenial (gkrizek)\n- #14738 Fix running `wallet_listtransactions.py` individually through \n`test_runner.py` (kristapsk)\n- #15026 Rename `rpc_timewait` to `rpc_timeout` (MarcoFalke)\n- #15069 Fix `rpc_net.py` `pong` race condition (Empact)\n- #14790 Allow running `rpc_bind.py` --nonloopback test without IPv6 \n(kristapsk)\n- #14457 add invalid tx templates for use in functional tests (jamesob)\n- #14855 Correct ineffectual WithOrVersion from `transactions_tests` (Empact)\n- #15099 Use `std::vector` API for construction of test data (domob1812)\n- #15102 Run `invalid_txs.InputMissing` test in `feature_block` (MarcoFalke)\n- #15059 Add basic test for BIP34 (MarcoFalke)\n- #15108 Tidy up `wallet_importmulti.py` (amitiuttarwar)\n- #15164 Ignore shellcheck warning SC2236 (promag)\n- #15170 refactor/lint: Add ignored shellcheck suggestions to an array \n(koalaman)\n- #14958 Remove race between connecting and shutdown on separate connections \n(promag)\n- #15166 Pin shellcheck version (practicalswift)\n- #15196 Update all `subprocess.check_output` functions to be Python 3.4 \ncompatible (gkrizek)\n- #15043 Build fuzz targets into seperate executables (MarcoFalke)\n- #15276 travis: Compile once on trusty (MarcoFalke)\n- #15246 Add tests for invalid message headers (MarcoFalke)\n- #15301 When testing with --usecli, unify RPC arg to cli arg conversion and \nhandle dicts and lists (achow101)\n- #15247 Use wallet to retrieve raw transactions (MarcoFalke)\n- #15303 travis: Remove unused `functional_tests_config` (MarcoFalke)\n- #15330 Fix race in `p2p_invalid_messages` (MarcoFalke)\n- #15324 Make bloom tests deterministic (MarcoFalke)\n- #15328 travis: Revert \"run extended tests once daily\" (MarcoFalke)\n- #15327 Make test `updatecoins_simulation_test` deterministic \n(practicalswift)\n- #14519 add utility to easily profile node performance with perf (jamesob)\n- #15349 travis: Only exit early if compilation took longer than 30 min \n(MarcoFalke)\n- #15350 Drop RPC connection if --usecli (promag)\n- #15370 test: Remove unused --force option (MarcoFalke)\n- #14543 minor `p2p_sendheaders` fix of height in coinbase (instagibbs)\n- #13787 Test for Windows encoding issue (ken2812221)\n- #15378 Added missing tests for RPC wallet errors (benthecarman)\n- #15238 remove some magic mining constants in functional tests (instagibbs)\n- #15411 travis: Combine --disable-bip70 into existing job (MarcoFalke)\n- #15295 fuzz: Add `test/fuzz/test_runner.py` and run it in travis \n(MarcoFalke)\n- #15413 Add missing `cs_main` locks required when accessing pcoinsdbview, \npcoinsTip or pblocktree (practicalswift)\n- #15399 fuzz: Script validation flags (MarcoFalke)\n- #15410 txindex: interrupt threadGroup before calling destructor (MarcoFalke)\n- #15397 Remove manual byte editing in `wallet_tx_clone` func test \n(instagibbs)\n- #15415 functional: allow custom cwd, use tmpdir as default (Sjors)\n- #15404 Remove `-txindex` to start nodes (amitiuttarwar)\n- #15439 remove `byte.hex()` to keep compatibility (AkioNak)\n- #15419 Always refresh cache to be out of ibd (MarcoFalke)\n- #15507 Bump timeout on tests that timeout on windows (MarcoFalke)\n- #15506 appveyor: fix cache issue and reduce dependencies build time \n(ken2812221)\n- #15485 add `rpc_misc.py`, mv test getmemoryinfo, add test mallocinfo \n(adamjonas)\n- #15321 Add `cs_main` lock annotations for mapBlockIndex (MarcoFalke)\n- #14128 lint: Make sure we read the command line inputs using UTF-8 decoding \nin python (ken2812221)\n- #14115 lint: Make all linters work under the default macos dev environment \n(build-osx.md) (practicalswift)\n- #15219 lint: Enable python linters via an array (Empact)\n- #15155 *test: Support -cli tests using external bitcoin-cli (luke-jr)\n- #15888 *QA: Add wallet_implicitsegwit to test the ability to transform keys \nbetween address types (luke-jr)\n- #15896 *QA: feature_filelock, interface_bitcoin_cli: Use PACKAGE_NAME in \nmessages rather than hardcoding Bitcoin Core (luke-jr)\n- #15897 *QA/mininode: Send all headers upfront in send_blocks_and_test to \navoid sending an unconnected one (luke-jr)\n- #12911 *test: add test to segwit tests for fee rate when signing raw tx \n(kallewoof)\n- #12146 *QA: wallet_implicitsegwit: Add tests for -walletimplicitsegwit=0 \n(luke-jr)\n\n### Platform support\n- #13866 utils: Use `_wfopen` and `_wfreopen` on windows (ken2812221)\n- #13886 utils: Run commands using UTF-8 string on windows (ken2812221)\n- #14192 utils: Convert `fs::filesystem_error` messages from local multibyte \nto UTF-8 on windows (ken2812221)\n- #13877 utils: Make fs::path::string() always return UTF-8 string on windows \n(ken2812221)\n- #13883 utils: Convert windows args to UTF-8 string (ken2812221)\n- #13878 utils: Add fstream wrapper to allow to pass unicode filename on \nwindows (ken2812221)\n- #14426 utils: Fix broken windows filelock (ken2812221)\n- #14686 Fix windows build error if `--disable-bip70` (ken2812221)\n- #14922 windows: Set `_WIN32_WINNT` to 0x0601 (Windows 7) (ken2812221)\n- #13888 Call unicode API on Windows (ken2812221)\n- #15468 Use `fsbridge::ifstream` to fix Windows path issue (ken2812221)\n- #13734 Drop `boost::scoped_array` and use `wchar_t` API explicitly on \nWindows (ken2812221)\n- #13884 Enable bdb unicode support for Windows (ken2812221)\n- #15600 *lockedpool: When possible, use madvise to avoid including sensitive \ninformation in core dumps or forked process memory spaces (luke-jr)\n- #15650 *Handle the result of posix_fallocate system call (lucayepa)\n\n### Miscellaneous\n- #13935 contrib: Adjust output to current test format (AkioNak)\n- #14097 validation: Log FormatStateMessage on ConnectBlock error in \nConnectTip (MarcoFalke)\n- #14186 bitcoin-cli: don't translate command line options (HashUnlimited)\n- #14057 logging: Only log `using config file path_to_bitcoin.conf` message on \nstartup if conf file exists (leishman)\n- #14164 Update univalue subtree (MarcoFalke)\n- #14272 init: Remove deprecated args from hidden args (MarcoFalke)\n- #14494 Error if # is used in rpcpassword in conf (MeshCollider)\n- #14742 Properly generate salt in rpcauth.py (dongcarl)\n- #14708 Warn unrecognised sections in the config file (AkioNak)\n- #14756 Improve rpcauth.py by using argparse and getpass modules (promag)\n- #14785 scripts: Fix detection of copyright holders (cornelius)\n- #14831 scripts: Use `#!/usr/bin/env bash` instead of `#!/bin/bash` (vim88)\n- #14869 Scripts: Add trusted key for samuel dobson (laanwj)\n- #14809 Tools: improve verify-commits.py script (jlopp)\n- #14624 Some simple improvements to the RNG code (sipa)\n- #14947 scripts: Remove python 2 import workarounds (practicalswift)\n- #15087 Error if rpcpassword contains hash in conf sections (MeshCollider)\n- #14433 Add checksum in gitian build scripts for ossl (TheCharlatan)\n- #15165 contrib: Allow use of github api authentication in github-merge \n(laanwj)\n- #14409 utils and libraries: Make 'blocksdir' always net specific (hebasto)\n- #14839 threads: Fix unitialized members in `sched_param` (fanquake)\n- #14955 Switch all RNG code to the built-in PRNG (sipa)\n- #15258 Scripts and tools: Fix `devtools/copyright_header.py` to always honor \nexclusions (Empact)\n- #12255 Update bitcoin.service to conform to init.md (dongcarl)\n- #15266 memory: Construct globals on first use (MarcoFalke)\n- #15347 Fix build after pr 15266 merged (hebasto)\n- #15351 Update linearize-hashes.py (OverlordQ)\n- #15358 util: Add setuphelpoptions() (MarcoFalke)\n- #15216 Scripts and tools: Replace script name with a special parameter \n(hebasto)\n- #15250 Use RdSeed when available, and reduce RdRand load (sipa)\n- #15278 Improve PID file error handling (hebasto)\n- #15270 Pull leveldb subtree (MarcoFalke)\n- #15456 Enable PID file creation on WIN (riordant)\n- #15124 Fail AppInitMain if either disk space check fails (Empact)\n- #15117 Fix invalid memory write in case of failing mmap(\u2026) in \nPosixLockedPageAllocator::AllocateLocked (practicalswift)\n- #14357 streams: Fix broken `streams_vector_reader` test. Remove unused \n`seek(size_t)`\n- #11640 Make `LOCK`, `LOCK2`, `TRY_LOCK` work with CWaitableCriticalSection \n(ryanofsky)\n- #14074 Use `std::unordered_set` instead of `set` in blockfilter interface \n(jimpo)\n- #15275 Add gitian PGP key for hebasto (hebasto)\n- #8501 *Stats: Fix typing issues in memory management logic (luke-jr)\n- #8501 *Stats: In weird memory management cases, do the best that makes sense \n(luke-jr)\n- #13339 *wallet: Escape wallet name in -walletnotify script (promag)\n- #15367 *feature: Added ability for users to add a startup command \n(benthecarman)\n- #15566 *cli: add chain and return network name as per BIP70. (fanquake)\n\n### Documentation\n- #14120 Notes about control port and read access to cookie (JBaczuk)\n- #14135 correct GetDifficulty doc after #13288 (fanquake)\n- #14013 Add new regtest ports in man following #10825 ports reattributions \n(ariard)\n- #14149 Remove misleading checkpoints comment in CMainParams (MarcoFalke)\n- #14153 Add disable-wallet section to OSX build instructions, update line in \nUnix instructions (bitstein)\n- #13662 Explain when reindex-chainstate can be used instead of reindex \n(Sjors)\n- #14207 `-help-debug` implies `-help` (laanwj)\n- #14213 Fix reference to lint-locale-dependence.sh (hebasto)\n- #14206 Document `-checklevel` levels (laanwj)\n- #14217 Add GitHub PR template (MarcoFalke)\n- #14331 doxygen: Fix member comments (MarcoFalke)\n- #14264 Split depends installation instructions per arch (MarcoFalke)\n- #14393 Add missing apt-get install (poiuty)\n- #14428 Fix macOS files description in qt/README.md (hebasto)\n- #14390 release process: RPC documentation (karel-3d)\n- #14497 Add doc/bitcoin-conf.md (hebasto)\n- #14526 Document lint tests (fanquake)\n- #14511 Remove explicit storage requirement from README.md (merland)\n- #14600 Clarify commit message guidelines (merland)\n- #14617 FreeBSD: Document Python 3 requirement for 'gmake check' (murrayn)\n- #14592 Add external interface consistency guarantees (MarcoFalke)\n- #14625 Make clear function argument case in dev notes (dongcarl)\n- #14515 Update OpenBSD build guide for 6.4 (fanquake)\n- #14436 Add comment explaining recentRejects-DoS behavior (jamesob)\n- #14684 conf: Remove deprecated options from docs, Other cleanup (MarcoFalke)\n- #14731 Improve scripted-diff developer docs (dongcarl)\n- #14778 A few minor formatting fixes and clarifications to descriptors.md \n(jnewbery)\n- #14448 Clarify rpcwallet flag url change (JBaczuk)\n- #14808 Clarify RPC rawtransaction documentation (jlopp)\n- #14804 Less confusing documentation for `torpassword` (fanquake)\n- #14848 Fix broken Gmane URL in security-check.py (cyounkins-bot)\n- #14882 developer-notes.md: Point out that UniValue deviates from upstream \n(Sjors)\n- #14909 Update minimum required Qt (fanquake)\n- #14914 Add nice table to files.md (emilengler)\n- #14741 Indicate `-rpcauth` option password hashing alg (dongcarl)\n- #14950 Add NSIS setup/install steps to windows docs (fanquake)\n- #13930 Better explain GetAncestor check for `m_failed_blocks` in \nAcceptBlockHeader (Sjors)\n- #14973 Improve Windows native build instructions (murrayn)\n- #15073 Botbot.me (IRC logs) not available anymore (anduck)\n- #15038 Get more info about GUI-related issue on Linux (hebasto)\n- #14832 Add more Doxygen information to Developer Notes (ch4ot1c)\n- #15128 Fix download link in doc/README.md (merland)\n- #15127 Clarifying testing instructions (benthecarman)\n- #15132 Add FreeBSD build notes link to doc/README.md (fanquake)\n- #15173 Explain what .python-version does (Sjors)\n- #15223 Add information about security to the JSON-RPC doc (harding)\n- #15249 Update python docs to reflect that wildcard imports are disallowed \n(Empact)\n- #15176 Get rid of badly named `doc/README_osx.md` (merland)\n- #15272 Correct logging return type and RPC example (fanquake)\n- #15244 Gdb attaching to process during tests has non-sudo solution \n(instagibbs)\n- #15332 Small updates to `getrawtransaction` description (amitiuttarwar)\n- #15354 Add missing `bitcoin-wallet` tool manpages (MarcoFalke)\n- #15343 netaddress: Make IPv4 loopback comment more descriptive (dongcarl)\n- #15353 Minor textual improvements in `translation_strings_policy.md` \n(merland)\n- #15426 importmulti: add missing description of keypool option (harding)\n- #15425 Add missing newline to listunspent help for witnessScript (harding)\n- #15348 Add separate productivity notes document (dongcarl)\n- #15416 Update FreeBSD build guide for 12.0 (fanquake)\n- #15222 Add info about factors that affect dependency list (merland)\n- #13676 Explain that mempool memory is added to `-dbcache` (Sjors)\n- #15273 Slight tweak to the verify-commits script directions (droark)\n- #15477 Remove misleading hint in getrawtransaction (MarcoFalke)\n- #15489 Update release process for snap package (MarcoFalke)\n- #15524 doc: Remove berkeleydb PPA from linux build instructions (MarcoFalke)\n- #15559 Correct `analyzepsbt` rpc doc (fanquake)\n- #15194 Add comment describing `fDisconnect` behavior (dongcarl)\n- #15754 getrpcinfo docs (benthecarman)\n- #15763 Update bips.md for 0.18.0 (sipa)\n- #15757 List new RPCs in psbt.md and descriptors.md (sipa)\n- #15765 correct bitcoinconsensus_version in shared-libraries.md (fanquake)\n- #15792 describe onlynet option in doc/tor.md (jonatack)\n- #15802 mention creating application support bitcoin folder on OSX (JimmyMow)\n- #15799 Clarify RPC versioning (MarcoFalke)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- 1Il1\n- 251\n- Aaron Clauson\n- Adam Jonas\n- Akio Nakamura\n- Alexander Leishman\n- Alexey Poghilenkov\n- Amir Abrams\n- Amiti Uttarwar\n- Andrew Chow\n- andrewtoth\n- Anthony Towns\n- Antoine Le Calvez\n- Antoine Riard\n- Antti Majakivi\n- araspitzu\n- Arvid Norberg\n- Ben Carman\n- Ben Woosley\n- benthecarman\n- bitcoinhodler\n- Carl Dong\n- Chakib Benziane\n- Chris Moore\n- Chris Stewart\n- Chun Kuan Lee\n- Cornelius Schumacher\n- Cory Fields\n- Craig Younkins\n- Cristian Mircea Messel\n- Damian Mee\n- Daniel Ingram\n- Daniel Kraft\n- David A. Harding\n- DesWurstes\n- Dimitri Deijs\n- Dimitris Apostolou\n- Douglas Roark\n- DrahtBot\n- Emanuele Cisbani\n- Emil Engler\n- Eric Scrivner\n- fridokus\n- Gal Buki\n- Gleb Naumenko\n- Glenn Willen\n- Graham Krizek\n- Gregory Maxwell\n- Gregory Sanders\n- gustavonalle\n- Harry Moreno\n- Hennadii Stepanov\n- Isidoro Ghezzi\n- Jack Mallers\n- James Hilliard\n- James O'Beirne\n- Jameson Lopp\n- Jeremy Rubin\n- Jesse Cohen\n- Jim Posen\n- John Newbery\n- Jon Layton\n- Jonas Schnelli\n- Jo\u00e3o Barbosa\n- Jordan Baczuk\n- Jorge Tim\u00f3n\n- Julian Fleischer\n- Justin Turner Arthur\n- Karel B\u00edlek\n- Karl-Johan Alm\n- Kaz Wesley\n- ken2812221\n- Kostiantyn Stepaniuk\n- Kristaps Kaupe\n- Lawrence Nahum\n- Lenny Maiorani\n- liuyujun\n- Luca Venturini\n- lucash-dev\n- luciana\n- Luke Dashjr\n- marcaiaf\n- marcoagner\n- MarcoFalke\n- Martin Erlandsson\n- Marty Jones\n- Mason Simon\n- Michael Ford\n- Michael Goldstein\n- Michael Polzer\n- Mitchell Cash\n- mruddy\n- Murray Nesbitt\n- OverlordQ\n- Patrick Strateman\n- Pierre Rochard\n- Pieter Wuille\n- poiuty\n- practicalswift\n- priscoan\n- qubenix\n- riordant\n- Russell Yanofsky\n- Samuel Dobson\n- sanket1729\n- Sjors Provoost\n- Stephan Oeste\n- Steven Roose\n- Suhas Daftuar\n- TheCharlatan\n- Tim Ruffing\n- Tobias Kaderle\n- Vidar Holen\n- vim88\n- Walter\n- Wladimir J. van der Laan\n- Zain Iqbal Allarakhia\n\nAs well as everyone that helped translating on [Transifex]\n(https://www.transifex.com/projects/p/bitcoin/).\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: This is a digitally signed message part.\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190504/f7bc70bc/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Knots 0.18.0.knots20190502 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 65798
        }
    },
    {
        "title": "[bitcoin-dev] Taproot proposal",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2019-05-06T17:57:57",
                "message_text_only": "Hello everyone,\n\nHere are two BIP drafts that specify a proposal for a Taproot\nsoftfork. A number of ideas are included:\n\n* Taproot to make all outputs and cooperative spends indistinguishable\nfrom eachother.\n* Merkle branches to hide the unexecuted branches in scripts.\n* Schnorr signatures enable wallet software to use key\naggregation/thresholds within one input.\n* Improvements to the signature hashing algorithm (including signing\nall input amounts).\n* Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\nbatch validation.\n* Tagged hashing for domain separation (avoiding issues like\nCVE-2012-2459 in Merkle trees).\n* Extensibility through leaf versions, OP_SUCCESS opcodes, and\nupgradable pubkey types.\n\nThe BIP drafts can be found here:\n* https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\nspecifies the transaction input spending rules.\n* https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\nspecifies the changes to Script inside such spends.\n* https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\nis the Schnorr signature proposal that was discussed earlier on this\nlist (See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html)\n\nAn initial reference implementation of the consensus changes, plus\npreliminary construction/signing tests in the Python framework can be\nfound on https://github.com/sipa/bitcoin/commits/taproot. All\ntogether, excluding the Schnorr signature module in libsecp256k1, the\nconsensus changes are around 520 LoC.\n\nWhile many other ideas exist, not everything is incorporated. This\nincludes several ideas that can be implemented separately without loss\nof effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\nwhich we're working on as an independent proposal.\n\nThe document explains basic wallet operations, such as constructing\noutputs and signing. However, a wide variety of more complex\nconstructions exist. Standardizing these is useful, but out of scope\nfor now. It is likely also desirable to define extensions to PSBT\n(BIP174) for interacting with Taproot. That too is not included here.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-05-06T20:17:09",
                "message_text_only": "There are multiple references to \"space savings\", but no rationale for \ntreating \"space\" as something to save or even define. The costs are in CPU \ntime and I/O (which \"space saving\" doesn't necessarily reduce) and bandwidth \n(which can often be reduced without \"space saving\" in commitments). The \nproposal can apparently be made simpler by ignoring this irrelevant \"space \nsaving\" goal.\n\nTagged hashes put the tagging at the start of the hash input. This means \nimplementations can pre-cache SHA2 states, but it also means they can't reuse \nstates to produce data for different contexts. (I'm not sure if there is a \nuse for doing so... but maybe as part of further hiding MAST branches?)\n\nIs there any way to use the Taproot construct here while retaining external \nscript limitations that the involved party(ies) *cannot* agree to override? \nFor example, it is conceivable that one might wish to have an unconditional \nCLTV enforced in all circumstances.\n\nIt may be useful to have a way to add a salt to tap branches.\n\nSome way to sign an additional script (not committed to by the witness \nprogram) seems like it could be a trivial addition.\n\n\nOn Monday 06 May 2019 17:57:57 Pieter Wuille via bitcoin-dev wrote:\n> Hello everyone,\n>\n> Here are two BIP drafts that specify a proposal for a Taproot\n> softfork. A number of ideas are included:\n>\n> * Taproot to make all outputs and cooperative spends indistinguishable\n> from eachother.\n> * Merkle branches to hide the unexecuted branches in scripts.\n> * Schnorr signatures enable wallet software to use key\n> aggregation/thresholds within one input.\n> * Improvements to the signature hashing algorithm (including signing\n> all input amounts).\n> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\n> batch validation.\n> * Tagged hashing for domain separation (avoiding issues like\n> CVE-2012-2459 in Merkle trees).\n> * Extensibility through leaf versions, OP_SUCCESS opcodes, and\n> upgradable pubkey types.\n>\n> The BIP drafts can be found here:\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\n> specifies the transaction input spending rules.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\n> specifies the changes to Script inside such spends.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> is the Schnorr signature proposal that was discussed earlier on this\n> list (See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.ht\n>ml)\n>\n> An initial reference implementation of the consensus changes, plus\n> preliminary construction/signing tests in the Python framework can be\n> found on https://github.com/sipa/bitcoin/commits/taproot. All\n> together, excluding the Schnorr signature module in libsecp256k1, the\n> consensus changes are around 520 LoC.\n>\n> While many other ideas exist, not everything is incorporated. This\n> includes several ideas that can be implemented separately without loss\n> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\n> which we're working on as an independent proposal.\n>\n> The document explains basic wallet operations, such as constructing\n> outputs and signing. However, a wide variety of more complex\n> constructions exist. Standardizing these is useful, but out of scope\n> for now. It is likely also desirable to define extensions to PSBT\n> (BIP174) for interacting with Taproot. That too is not included here.\n>\n> Cheers,"
            },
            {
                "author": "Sjors Provoost",
                "date": "2019-05-07T20:42:58",
                "message_text_only": "Hey Pieter,\n\nI think this is a reasonable collection of changes that make sense in combination. Some initial feedback and questions.\n\nFrom the BIP:\n> If one or more of the spending conditions consist of just a single key (after aggregation),\n> he most likely one should be made the internal key. If no such condition exists, it may\n> be worthwhile adding one that consists of an aggregation of all keys participating in all\n> scripts combined; effectively adding an \"everyone agrees\" branch. If that is inacceptable,\n> pick as internal key a point with unknown discrete logarithm (TODO).\n\nI assume Luke Dashjr referred to the above when saying:\n\n> Is there any way to use the Taproot construct here while retaining external \n> script limitations that the involved party(ies) *cannot* agree to override? \n> For example, it is conceivable that one might wish to have an unconditional \n> CLTV enforced in all circumstances.\n\n\nOne reason why someone would want to avoid a \"everone agrees\" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.\n\nCan this \"unknown discrete logarithm\" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.\n\nPerhaps Lightning devs have an opinion on \"everyone agrees\" with respect to hash pre-images. I suspect there is no benefit in guaranteeing that a pre-image must be revealed or a timeout must be waited for and there's no way around that condition.\n\n\nRegarding usage of Schnorr: do I understand correctly that the \"everyone agrees\" internal key MUST use Schnorr, and that individual branches MAY use Schnorr, but only if they're marked as tapscript spend?\n\nWhy is tapscript not mandatory?\n\n\nMisc details:\n\nIn the Design section under \"Merkle branches\" I suggest adding bullet points with short descriptions of \"various known mechanisms for implementing this\". In addition to \"space savings\" maybe also briefly mention a few other pros and cons, like implementation complexity and privacy. And then point out which one you picked.\n\nIn the Design section, explicitly point out you're no longer using the hash of a public key (can move some explanation up from rationale section). This is a significant change, even if you have good reason to believe it's perfectly safe.\n\nRegarding the 64 byte SHA256(tag) || SHA256(tag) 64-byte long context-specific constant: maybe add that sha-2 block size is 512 bits\n\n\"Conceptually every Taproot output corresponds to\" -> some of this conceptual stuff belongs in or before the Specification section. Try briefly explaining how tagged hashes and script validation (stack) interact, before specifying them in detail. The figure (without the pseudo-code) can be helpful for that. \n\nIn the figure with the merkle tree, the description says there's \"3 script leaves.\". So what's going on in leaf D? If it's a way to indicate an unused leaf, why is E different (or is also TapLeaf)? Maybe emphasize that \"TapLeaf\" tag is there so prove to all signers there's no secret conditions (the CVE-2012-2459 protection you refer to).\n\nSjors\n\n\n> Op 6 mei 2019, om 22:17 heeft Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:\n> \n> There are multiple references to \"space savings\", but no rationale for \n> treating \"space\" as something to save or even define. The costs are in CPU \n> time and I/O (which \"space saving\" doesn't necessarily reduce) and bandwidth \n> (which can often be reduced without \"space saving\" in commitments). The \n> proposal can apparently be made simpler by ignoring this irrelevant \"space \n> saving\" goal.\n> \n> Tagged hashes put the tagging at the start of the hash input. This means \n> implementations can pre-cache SHA2 states, but it also means they can't reuse \n> states to produce data for different contexts. (I'm not sure if there is a \n> use for doing so... but maybe as part of further hiding MAST branches?)\n> \n> Is there any way to use the Taproot construct here while retaining external \n> script limitations that the involved party(ies) *cannot* agree to override? \n> For example, it is conceivable that one might wish to have an unconditional \n> CLTV enforced in all circumstances.\n> \n> It may be useful to have a way to add a salt to tap branches.\n> \n> Some way to sign an additional script (not committed to by the witness \n> program) seems like it could be a trivial addition.\n> \n> \n> On Monday 06 May 2019 17:57:57 Pieter Wuille via bitcoin-dev wrote:\n>> Hello everyone,\n>> \n>> Here are two BIP drafts that specify a proposal for a Taproot\n>> softfork. A number of ideas are included:\n>> \n>> * Taproot to make all outputs and cooperative spends indistinguishable\n>> from eachother.\n>> * Merkle branches to hide the unexecuted branches in scripts.\n>> * Schnorr signatures enable wallet software to use key\n>> aggregation/thresholds within one input.\n>> * Improvements to the signature hashing algorithm (including signing\n>> all input amounts).\n>> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\n>> batch validation.\n>> * Tagged hashing for domain separation (avoiding issues like\n>> CVE-2012-2459 in Merkle trees).\n>> * Extensibility through leaf versions, OP_SUCCESS opcodes, and\n>> upgradable pubkey types.\n>> \n>> The BIP drafts can be found here:\n>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\n>> specifies the transaction input spending rules.\n>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\n>> specifies the changes to Script inside such spends.\n>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n>> is the Schnorr signature proposal that was discussed earlier on this\n>> list (See\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.ht\n>> ml)\n>> \n>> An initial reference implementation of the consensus changes, plus\n>> preliminary construction/signing tests in the Python framework can be\n>> found on https://github.com/sipa/bitcoin/commits/taproot. All\n>> together, excluding the Schnorr signature module in libsecp256k1, the\n>> consensus changes are around 520 LoC.\n>> \n>> While many other ideas exist, not everything is incorporated. This\n>> includes several ideas that can be implemented separately without loss\n>> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\n>> which we're working on as an independent proposal.\n>> \n>> The document explains basic wallet operations, such as constructing\n>> outputs and signing. However, a wide variety of more complex\n>> constructions exist. Standardizing these is useful, but out of scope\n>> for now. It is likely also desirable to define extensions to PSBT\n>> (BIP174) for interacting with Taproot. That too is not included here.\n>> \n>> Cheers,\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-08T04:37:37",
                "message_text_only": "Good morning Sjors,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, May 8, 2019 4:42 AM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hey Pieter,\n>\n> I think this is a reasonable collection of changes that make sense in combination. Some initial feedback and questions.\n>\n> From the BIP:\n>\n> > If one or more of the spending conditions consist of just a single key (after aggregation),\n> > he most likely one should be made the internal key. If no such condition exists, it may\n> > be worthwhile adding one that consists of an aggregation of all keys participating in all\n> > scripts combined; effectively adding an \"everyone agrees\" branch. If that is inacceptable,\n> > pick as internal key a point with unknown discrete logarithm (TODO).\n>\n> I assume Luke Dashjr referred to the above when saying:\n>\n> > Is there any way to use the Taproot construct here while retaining external\n> > script limitations that the involved party(ies) cannot agree to override?\n> > For example, it is conceivable that one might wish to have an unconditional\n> > CLTV enforced in all circumstances.\n>\n> One reason why someone would want to avoid a \"everone agrees\" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.\n>\n> Can this \"unknown discrete logarithm\" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.\n\nAs I understand it, it is possible to take some random data, hash it with SHA256 and acquire a 256-bit number.\nThen treat that number as an X coordinate (or is it Y...), and see if there exists a point on the secp256k1 curve at that coordinate.\nIf not, try another random data, or just hash the same number again.\nAs I understand it, about half the possible X coordinates will have a point on the curve.\n\nI believe this is the \"hash to a point\" technique.\n\nThe scalar behind the above point cannot be known, unless either the hash function is broken, or ECDLP is broken.\n(perhaps a better cryptographer can give the proper qualifications, any corrections, and etc etc)\n\nAs the point is just an arbitrary point on the curve, it is unknown to the rest of the world whether somebody knows the scalar, or nobody knows.\n\n>\n> Perhaps Lightning devs have an opinion on \"everyone agrees\" with respect to hash pre-images. I suspect there is no benefit in guaranteeing that a pre-image must be revealed or a timeout must be waited for and there's no way around that condition.\n\nThe \"everyone agrees\" branch in Lightning is basically the \"cooperative close\" of the channel.\nSo it is not likely we will need an \"everyone agrees\" branch in the actual HTLCs we transfer *within* the channel.\nSo if we need to use hashes still, we will likely use the \"hash to a point\" technique above.\n\nOr just use pubkeys given by both participants, that should be enough to ensure the \"everyone agrees\" branch is never taken if we write our software such that we never agree to sign with it (i.e. just get points from both sides and MuSig them; then each side can just erase the scalar generating it from memory and whatever caches exist on the system; a node might even just generate a single random point from a scalar it subsequently erases, and just use some non-hardened derivation path from that for every HTLC it has to make).\nThis technique is \"sufficiently provably unknown\" since each participant knows that it deliberately erased the only means of knowing the complete discrete log by erasing its share.\nIn short, \"everyone agrees\" is trivially easy to make \"nobody can agree\" by a single participant never agreeing to let itself be ripped off.\n\nDo note that it is likely Lightning will eventually switch to using payment points/scalars instead of hashes/preimages.\nThis will allow us to have path decorrelation, both within a route, and in multiple routes of the same payment.\nThis is enabled by Schnorr, as this requires Scriptless Script.\n(granted 2p-ECDSA also enables Scriptless Script, but we decided to wait for Schnorr to hit base layer instead)\nThis means we would be using the \"everyone agrees\" path only, with everyone agreeing to first create a `nLockTime` backout tx, then everyone agreeing to create a transaction where one side has knowledge of a secret scalar that is learned by the other side upon completion of the signature.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-08T05:16:03",
                "message_text_only": "Good morning Sjors, sorry everyone for the double-posting...\n\n> I believe this is the \"hash to a point\" technique.\n>\n> The scalar behind the above point cannot be known, unless either the hash function is broken, or ECDLP is broken.\n> (perhaps a better cryptographer can give the proper qualifications, any corrections, and etc etc)\n>\n> As the point is just an arbitrary point on the curve, it is unknown to the rest of the world whether somebody knows the scalar, or nobody knows.\n\nNow that I think further, everyone can use *the same* point generated from an arbitrary \"hash to a point\".\nFor example, we can define the \"script-only point\" as the point whose X coordinate (or is it Y...) is equal to SHA256(\"Pieter Wuille is really great!\").\nAdd more \"really \" until we get a point on the curve.\n\nProvided everyone knows what the exact data to hash is, and the exact hash function, the above procedure is sufficient for everybody to verify that Pieter Wuille (and anyone else for that matter) cannot, in fact, spend the coin unilaterally, and that nobody can actually spend the coin, except via a script.\n\nSince the point on the output is tweaked by the script merkle tree root, varying your pubkey for each use will be enough to blind the use of the \"script-only point\" until you have to reveal it during spending anyway.\nIf you *absolutely* insist on reusing your pubkeys, then adding a `OP_PUSH(<salt>) OP_DROP` to at least one script, with a random salt, should be enough to blind the use of the script-only point until you have to reveal the script you want to use.\nOr even just further tweak the point before using it as the taproot internal pubkey, so that not even a coin spend reveals that the \"everyone agrees\" branch was never actually an option.\n\n> Or just use pubkeys given by both participants, that should be enough to ensure the \"everyone agrees\" branch is never taken if we write our software such that we never agree to sign with it (i.e. just get points from both sides and MuSig them; then each side can just erase the scalar generating it from memory and whatever caches exist on the system; a node might even just generate a single random point from a scalar it subsequently erases, and just use some non-hardened derivation path from that for every HTLC it has to make).\n> This technique is \"sufficiently provably unknown\" since each participant knows that it deliberately erased the only means of knowing the complete discrete log by erasing its share.\n> In short, \"everyone agrees\" is trivially easy to make \"nobody can agree\" by a single participant never agreeing to let itself be ripped off.\n>\n\nThe \"taproot assumption\" is that there exists some finite set of participants that is interested in how the coin will be spent.\nUnder the taproot assumption then, any \"truster\" that assigns time-limited control of a coin to a \"trustee\" is part of that finite set interested in the coin spend conditions.\nSo the truster should in fact be asked for a pubkey to be added in the taproot internal pubkey that enables the \"everyone agrees\" branch.\nThen the truster can simply generate a point without knowing its private key, or by forgetting this private key.\n\nIf one is sufficiently schizophrenic, one can split oneself into a \"truster\" and \"trustee\" as above and deliberately forget the truster private key.\nThen one is sufficiently unable to spend under duress by deleting the \"truster\" sub-agent and providing real-world access to the \"trustee\" sub-agent that can only spend under specific SCRIPT-defined conditions.\n\n(the above paragraph should not be taken to mean that I am an agent-based AI)\n\nThat is, it should be enough for everyone to agree to lock the \"everyone agrees\" branch and throw away their own key, to keep that branch locked.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-05-08T23:06:51",
                "message_text_only": "Thanks for the comments so far!\n\nI'm going to respond to some of the comments here. Things which I plan\nto address with changes in the BIP I'll leave for later.\n\nOn Mon, 6 May 2019 at 13:17, Luke Dashjr <luke at dashjr.org> wrote:\n> Tagged hashes put the tagging at the start of the hash input. This means\n> implementations can pre-cache SHA2 states, but it also means they can't reuse\n> states to produce data for different contexts. (I'm not sure if there is a\n> use for doing so... but maybe as part of further hiding MAST branches?)\n\nIt's true you can't cache/precompute things across tags, but I also\nthink there is no need. The type of data hashed in a sighash vs a\nmerkle branch/leaf vs a tweak is fundamentally different. I think this\nis perhaps a good guidance to include about when separate tags are\nwarranted vs. simply making sure the input does not collide: there\nshouldn't be much or any shared data with things that are expected to\nbe inputs under other tags.\n\n> Is there any way to use the Taproot construct here while retaining external\n> script limitations that the involved party(ies) *cannot* agree to override?\n> For example, it is conceivable that one might wish to have an unconditional\n> CLTV enforced in all circumstances.\n\nYes, absolutely - you can use a point with unknown discrete logarithm\nas internal key. This will result in only script path spends being\navailable. For the specific goal you're stating an alternative may be\nusing a valid known private key, using it to pre-sign a timelocked\ntransaction, and destroying the key.\n\n> It may be useful to have a way to add a salt to tap branches.\n\nIf you don't reuse public keys, effectively every branch is\nautomatically salted (and the position in the tree gets randomized\nautomatically when doing so, providing a small additional privacy\nbenefit).\n\n>> Some way to sign an additional script (not committed to by the witness\n>> program) seems like it could be a trivial addition.\n> This would be especially useful for things like OP_CHECKBLOCKATHEIGHT:\n> https://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki\n\nIf you're talking about the ability to sign over the ability to spend\nto another script (\"delegation\"), there are lots of interesting\napplications and ways to implement it. But it overlaps with Graftroot,\nand doing it efficiently in general has some interesting and\nnon-obvious engineering challenges (for example, signing over to a\nscript that enforces \"f(tx)=y\" for some f can be done by only storing\nf and then including y in the sighash).\n\nFor the specific example of BIP115's functionality, that seems like a\nreasonable thing that could be dealt with using the annex construction\nin the proposed BIP. A consensus rule could define a region inside the\nannex that functions as a height-blockhash assertion. The annex is\nincluded in all sighashes, so it can't be removed from the input;\nlater opcodes could include the ability to inspect that assertion\neven.\n\nOn Tue, 7 May 2019 at 13:43, Sjors Provoost <sjors at sprovoost.nl> wrote:\n> One reason why someone would want to avoid a \"everone agrees\" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.>\n\nIndeed, though as I suggested above, you can also use timelocked\ntransactions (but using only CLTV branches is more flexible\ncertainly).\n\n> Can this \"unknown discrete logarithm\" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.\n\nYes, that's a TODO that's left in the draft, but this is absolutely\npossible (using a hash-to-curve operation). As ZmnSCPxj already\nsuggested, there can even be a fixed known constant you can use for\nthis. However, you get better privacy by taking this fixed known\nconstant (call it C) and using as internal key a blinded version of it\n(C+rG, for some random value r, and G the normal secp256k1 generator);\nas long as the DL between G and C is unknown, this is safe (and does\nnot reveal to the world that in fact no key-path was permitted when\nspending).\n\n> Regarding usage of Schnorr: do I understand correctly that the \"everyone agrees\" internal key MUST use Schnorr, and that individual branches MAY use Schnorr, but only if they're marked as tapscript spend?\n>\n> Why is tapscript not mandatory?\n\nSpending using the internal key always uses a single Schnorr signature\nand nothing else. When you spend using a script path, you must reveal\nboth the script and its leaf version. If that leaf version is 0xc0,\nthe script is interpreted as a tapscript (in which only Schnorr\nopcodes exist). If that leaf version is not 0xc0, the script is\nundefined, and is unconditionally valid. This is one of the included\nextension mechanisms, allowing replacing the whole script language\nwith something else, but without revealing it unless a branch using it\nis actually used (different Merkle tree leaves can have a distinct\nleaf versions).\n\nSo the reason that tapscript is not mandatory is because other leaf\nversions are undefined, and left for future extensions (similar to how\nfuture segwit versions at the output level are undefined).\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-18T17:51:16",
                "message_text_only": "Good morning list,\n\n\n> > Can this \"unknown discrete logarithm\" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.\n>\n> Yes, that's a TODO that's left in the draft, but this is absolutely\n> possible (using a hash-to-curve operation). As ZmnSCPxj already\n> suggested, there can even be a fixed known constant you can use for\n> this. However, you get better privacy by taking this fixed known\n> constant (call it C) and using as internal key a blinded version of it\n> (C+rG, for some random value r, and G the normal secp256k1 generator);\n> as long as the DL between G and C is unknown, this is safe (and does\n> not reveal to the world that in fact no key-path was permitted when\n> spending).\n\nGregory Maxwell commented some days ago:\n\n> 2019-05-11T23:35:02  <gmaxwell> sipa: also someone might want to point out to ZmnSCPxj  that his scheme for getting a NUMS point is insecure (it must also commit to G because we don't know how G was generated)\n\nI am assuming that gmax is referring to my description of the \"hash-to-point\" or \"hash-to-curve\" operation.\n\nA little more research shows this: https://crypto.stackexchange.com/a/25603\n\n>From the above, it seems the method that real cryptographers use is:\n\n1.  Generate some random data d.\n2.  Get x = h(G | d) where G is the existing generator for secp256k1.\n3.  Find a point on secp256k1 with X coordinate x.\n4.  If not found, go to 1.\n\nIn any case, I am almost sure that for every case where the \"everyone agrees\" path is unwanted in a taproot address, the simple \"put your own pubkey lock on the door and throw away the privkey\" technique would work without requiring a NUMS point: the same taproot assumption should also work here.\nBut generation of a NUMS point might be of independent interest in any case (e.g. setting up Pedersen commitments).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-08T03:44:29",
                "message_text_only": "Good morning Luke,\n\n\n> Is there any way to use the Taproot construct here while retaining external\n> script limitations that the involved party(ies) cannot agree to override?\n> For example, it is conceivable that one might wish to have an unconditional\n> CLTV enforced in all circumstances.\n\nPerhaps this can be enforced offchain, by participants refusing to sign a transaction unless it has an `nLockTime` of the agreed-upon \"unconditional CLTV\".\nThen the CLTV need only be on branches which have a strict subset of the participants as signers.\n\n>\n> It may be useful to have a way to add a salt to tap branches.\n\nWould not adding `OP_PUSH(<salt>) OP_DROP` to the leaves work?\nIf you enforce always salting with a 32-byte salt, that \"only\" saves 3 bytes of witness data (for the `OP_PUSHDATA1+size` and `OP_DROP` opcodes).\nOr do you refer to always salting every node?\n(I am uncertain, but would not adding a salt to every leaf be sufficient?)\n\n(in any case, if you use different pubkeys for each contract, rather than reusing keys, is that not enough randomization to prevent creating rainbow tables of scripts?)\n\n>\n> Some way to sign an additional script (not committed to by the witness\n> program) seems like it could be a trivial addition.\n\nIt seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-09T16:56:57",
                "message_text_only": "> \n>> \n>> Some way to sign an additional script (not committed to by the witness\n>> program) seems like it could be a trivial addition.\n> \n> It seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.\n\nThis is not possible since the whole annex is signed. It is possible if the signed \u201cscript\u201d does not require further input, like per-input lock-time, relative lock-time, check block hash\n\n\n> \n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-10T05:38:52",
                "message_text_only": "Good morning Johnson,\n\n\n> > > Some way to sign an additional script (not committed to by the witness\n> > > program) seems like it could be a trivial addition.\n> >\n> > It seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.\n>\n> This is not possible since the whole annex is signed. It is possible if the signed \u201cscript\u201d does not require further input, like per-input lock-time, relative lock-time, check block hash\n\nI understand, you are correct.\n\nPossibly the correct way would be to use another leaf version.\nThe \"script\" of such a new leaf version would not actually be a script, but a delegation key.\nThen for this leaf version the actual script and signature from the delegation key attesting that script would be on top of the witness stack that will be used by the actual script.\nThis has the nice property that the existence of a delegation key is hidden from the output, and that if an alternate script is in the MAST (as an alternative to the delegation), use of that alternate script does not reveal that delegation could have been possible.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-05-08T04:49:28",
                "message_text_only": "On Mon, May 06, 2019 at 08:17:09PM +0000, Luke Dashjr via bitcoin-dev wrote:\n> Some way to sign an additional script (not committed to by the witness \n> program) seems like it could be a trivial addition.\n\nAside: if you want to commit to something extra *with* the witness\nprogram, you could use either an unsolvable tapleaf branch (eg, one\nthat uses OP_RETURN and also pushes the data you want to commit to),\nor a p2c construction like:\n\n  Taproot: Q = P + H_TapTweak(P || S)*G\n\n  P2C: P = R + H_\"myp2c\"(R || Contract)*G\n\nIf you don't have any scripts for S, you could set S=[\"OP_RETURN\"]\nto ensure there are no scripts. Having either the TapTweak formula or\nthe H_myp2c hash should be enough to ensure that your contract can't\nget maliciously reinterpreted as a valid tapscript, having both is just\nbelts and suspenders.\n\nBut to address your question: if you want to commit to something extra\nat spending/signing time rather than when creating the address, then\nthat's what the annex should be useful for. eg as a simple example,\nyour annex might be:\n\n    0x50 [flag]\n    0x25 [entry size]\n      0x77 [annex entry id]\n      0x0008c618 [block height == 575000]\n      0x00000000000000000007df59824a0c86d1cc21b90eb25259dd2dba5170cea5f5\n         [block hash for block at 575000]\n\nwhich would allow you to commit to a particular block hash, and there\ncould be a soft fork that added the restriction that such a commitment\ninvalidates the transaction if the block at the given height doesn't\nmatch the provided hash.\n\nYou still need to the soft-fork to do the enforcing, but once you have\nthat, *every* existing taproot address automatically gets \"upgraded\"\nto allow you to make the commitment, including via key path spends,\nwhich seems pretty nice.\n\n(That construction (ie size,id,data) lets you have multiple entries in\nthe annex reasonably efficiently)\n\nCheers,\naj"
            },
            {
                "author": "Luke Dashjr",
                "date": "2019-05-08T13:10:17",
                "message_text_only": "On Monday 06 May 2019 20:17:09 Luke Dashjr via bitcoin-dev wrote:\n> Some way to sign an additional script (not committed to by the witness\n> program) seems like it could be a trivial addition.\n\nThis would be especially useful for things like OP_CHECKBLOCKATHEIGHT:\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-21T17:20:32",
                "message_text_only": "Regarding Tapscript, the specification calls for the final value of the\nstack being a single non-false value:\n\nThe tapscript is executed according to the rules in the following section,\n> with the initial stack as input\n>     II. If the execution results in anything but exactly one element on\n> the stack which evaluates to true with CastToBool(), fail.\n>\n\nPerhaps it is worth taking this opportunity here to remove a minor wart of\nthe Script language and instead require the stack to be exactly empty upon\ncompletion.\n\nIn addition to removing a potential malleability vector, I expect it would\nsimplify development of Bitcoin Script.  A rule requiring an empty stack\nmeans that the conjunction (logical and) of two policies can be implemented\nby the simple concatenation of Bitcoin Scripts.  This combined with the\ntaproot ability to form the disjunction (logical or) of policies by having\nmultiple Merkle branches, means that the translation of a policy written in\ndisjunctive normal form (the logical ors of logical ands of primitive\npolicies) can be straightforwardly translated to a taproot of tapscript.\n\nThat said, I think the developers of miniscript <\nhttp://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better\nposition to comment on whether my above intuition is correct given that\nthey've had to implement a host of various calling conventions.  I\nunderstand that at least some of this complexity is due to Bitcoin Script's\none element stack rule.\n\nScripts under the old one element rule can be translated to the new rule by\nadding an OP_VERIFY operation to the end of the script; however it is\nlikely that this OP_VERIFY can be folded into the previous operation\nyielding an OP_EQUALVERIFY or OP_CHECKSIGVERIFY in many cases.\n\nEven if we choose not to implement the empty stack rule, we should at least\nrequire that the last element be 0x01 to remove a potential malleability\nvector and bring it in line with MINIMAL_IF semantics.\n\nThanks.\n\nOn Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> Here are two BIP drafts that specify a proposal for a Taproot\n> softfork. A number of ideas are included:\n>\n> * Taproot to make all outputs and cooperative spends indistinguishable\n> from eachother.\n> * Merkle branches to hide the unexecuted branches in scripts.\n> * Schnorr signatures enable wallet software to use key\n> aggregation/thresholds within one input.\n> * Improvements to the signature hashing algorithm (including signing\n> all input amounts).\n> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\n> batch validation.\n> * Tagged hashing for domain separation (avoiding issues like\n> CVE-2012-2459 in Merkle trees).\n> * Extensibility through leaf versions, OP_SUCCESS opcodes, and\n> upgradable pubkey types.\n>\n> The BIP drafts can be found here:\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\n> specifies the transaction input spending rules.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\n> specifies the changes to Script inside such spends.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> is the Schnorr signature proposal that was discussed earlier on this\n> list (See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html\n> )\n>\n> An initial reference implementation of the consensus changes, plus\n> preliminary construction/signing tests in the Python framework can be\n> found on https://github.com/sipa/bitcoin/commits/taproot. All\n> together, excluding the Schnorr signature module in libsecp256k1, the\n> consensus changes are around 520 LoC.\n>\n> While many other ideas exist, not everything is incorporated. This\n> includes several ideas that can be implemented separately without loss\n> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\n> which we're working on as an independent proposal.\n>\n> The document explains basic wallet operations, such as constructing\n> outputs and signing. However, a wide variety of more complex\n> constructions exist. Standardizing these is useful, but out of scope\n> for now. It is likely also desirable to define extensions to PSBT\n> (BIP174) for interacting with Taproot. That too is not included here.\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/d6d438b1/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-05-23T02:06:42",
                "message_text_only": "On Tue, 21 May 2019 at 10:20, Russell O'Connor <roconnor at blockstream.io> wrote:\n>\n> Regarding Tapscript, the specification calls for the final value of the stack being a single non-false value:\n>\n>> The tapscript is executed according to the rules in the following section, with the initial stack as input\n>>     II. If the execution results in anything but exactly one element on the stack which evaluates to true with CastToBool(), fail.\n>\n> Perhaps it is worth taking this opportunity here to remove a minor wart of the Script language and instead require the stack to be exactly empty upon completion.\n>\n> In addition to removing a potential malleability vector, I expect it would simplify development of Bitcoin Script.  A rule requiring an empty stack means that the conjunction (logical and) of two policies can be implemented by the simple concatenation of Bitcoin Scripts.  This combined with the taproot ability to form the disjunction (logical or) of policies by having multiple Merkle branches, means that the translation of a policy written in disjunctive normal form (the logical ors of logical ands of primitive policies) can be straightforwardly translated to a taproot of tapscript.\n>\n> That said, I think the developers of miniscript <http://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better position to comment on whether my above intuition is correct given that they've had to implement a host of various calling conventions.  I understand that at least some of this complexity is due to Bitcoin Script's one element stack rule.\n\nIIRC I looked into this a few months ago, and found that the spending\ncost (script size + expected witness size) of the optimal script for\nevery Miniscript policy at most changes by 1 WU (in either direction)\nby requiring an empty stack rather than a true value, though in a\n(admittedly very arbitrarily biased) distribution, more policies were\nimproved by it than degraded. This is not taking Taproot into account\n(as many of those policies in a Taproot-supporting world should\noptimally make use of the internal key and Merkle tree, rather than\nturning everything into a monolithic script). I expect that this may\nmake the impact somewhat larger, but still never more than a 1 WU\ngain.\n\nI don't think the spending cost changes justify this change, so the\nremaining criteria are complexity ones. In my view, the main benefit\nwould be to authors of hand-written scripts where the consistency\nbenefits matter, but this needs to be weighed against the mental cost\nof learning the new semantics. For Miniscript itself, this doesn't\nmake much difference - the top level calling convention would become\n'V' instead of 'T', but 'T' would still exist as a calling convention\nthat may be used internally; it's a few lines change.\n\nSo overall this feels like something with marginal costs, but also at\nmost marginal benefits. Perhaps other people have stronger opinions.\n\n> Even if we choose not to implement the empty stack rule, we should at least require that the last element be 0x01 to remove a potential malleability vector and bring it in line with MINIMAL_IF semantics.\n\nThis feels like the right thing to do; as we're making MINIMALIF part\nof consensus for Tapscript it would make sense to apply the same rule\nto the \"return\" value of the script. There is a downside though,\nnamely that in some places where you'd use \"<n>\nOP_CHECKSEQUENCEVERIFY\" or \"<n> OP_CHECKLOCKTIMEVERIFY\" you now need\nto add an additional OP_0NOTEQUAL to convert the left-over element n\ninto an exact 0x01. I also can't come up with any practical benefits\nthat this would have; if the top stack element in a particular code\npath comes directly from the input, it's insecure regardless; if there\nisn't, it'll generally be a a boolean (or an intentional non-boolean\ntrue value) computed by the script.\n\nOn Tue, 21 May 2019 at 13:05, John Newbery <john at johnnewbery.com> wrote:\n>\n> Hi,\n>\n> > A Taproot output is a SegWit output [...]  with\n> > version number 1, and a 33-byte witness program whose first byte is 0 or 1.\n>\n> Given a secret key k and public key P=(x,y), a signer with the knowledge of k\n> can sign for -P=(x,p-y) since -k is the secret key for that point. Encoding the\n> y value of the public key therefore adds no security.\n\nThat's a good point; without security benefit there's no reason to\nmake pay-to-taproots more expensive. Making them the same cost as\nP2WSH is nice in any case.\n\n> As an alternative to\n> providing the y value of the taproot output key Q when constructing the taproot\n> output, the signer can provide it when signing. We can also restrict the y value\n> of the internal key P to be even (or high, or a quadratic residue). That gives\n> us 4 options for how to set the y signs for P and Q.\n>\n> 1. Q sign is explictly set in the witness program, P sign is explicitly set in the control block\n>     => witness program is 33 bytes, 32 possible leaf versions (one for each pair of 0xc0..0xff)\n> 2. Q sign is explictly set in the witness program, P sign is implicitly even\n>     => witness program is 33 bytes, 64 possible leaf versions (one for each 0xc0..0xff)\n> 3. Q sign is explictly set in the control block, P sign is explicitly set in the control block\n>     => witness program is 32 bytes, 16 possible leaf versions (one for each 4-tuple of 0xc0..0xff)\n> 4. Q sign is explictly set in the control block, P sign is implicitly even\n>     => witness program is 32 bytes, 32 possible leaf versions (one for pair of 0xc0..0xff)\n>\n> The current proposal uses (1). Using (3) or (4) would reduce the size of a\n> taproot output by one byte to be the same size as a P2WSH output. That means\n> that it's not more expensive for senders compared to sending to P2WSH.\n\nI prefer (4). There is a slight complexity in needing a conditional\nsign swap when signing (to make sure the corresponding key is even),\nbut I think it's minimal compared to the other changes needed here\nalready. I'll try to amend the reference code soon to see what impact\nthis idea has.\n\n> > (native or P2SH-nested, see BIP141)\n>\n> I'd prefer to not support P2SH-nested TR. P2SH wrapping was useful for segwit\n> v0 for compatibility reasons. Most wallets/exchanges/services now support sending\n> to native segwit addresses (https://en.bitcoin.it/wiki/Bech32_adoption) and that\n> will be even more true if Schnorr/Taproot activate in 12+ months time.\n\nI'm not sure there is much to gain here. There is perhaps a minimal\nfungibility improvement by not having another bit (P2SH or not) that\ncan leak some information about the software you're using. On the\nother hand, until native taproot outputs are common, choosing P2SH\nwrapped ones leak less information at output creation time. Apart from\nthat, I think it would only minimally impact implementation\ncomplexity. Are there other advantages I'm missing?\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-23T02:32:26",
                "message_text_only": "On Wed, May 22, 2019 at 10:06 PM Pieter Wuille <pieter.wuille at gmail.com>\nwrote:\n\n> On Tue, 21 May 2019 at 10:20, Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n> >\n> > Regarding Tapscript, the specification calls for the final value of the\n> stack being a single non-false value:\n> >\n> >> The tapscript is executed according to the rules in the following\n> section, with the initial stack as input\n> >>     II. If the execution results in anything but exactly one element on\n> the stack which evaluates to true with CastToBool(), fail.\n> >\n> > Perhaps it is worth taking this opportunity here to remove a minor wart\n> of the Script language and instead require the stack to be exactly empty\n> upon completion.\n> >\n> > In addition to removing a potential malleability vector, I expect it\n> would simplify development of Bitcoin Script.  A rule requiring an empty\n> stack means that the conjunction (logical and) of two policies can be\n> implemented by the simple concatenation of Bitcoin Scripts.  This combined\n> with the taproot ability to form the disjunction (logical or) of policies\n> by having multiple Merkle branches, means that the translation of a policy\n> written in disjunctive normal form (the logical ors of logical ands of\n> primitive policies) can be straightforwardly translated to a taproot of\n> tapscript.\n> >\n> > That said, I think the developers of miniscript <\n> http://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better\n> position to comment on whether my above intuition is correct given that\n> they've had to implement a host of various calling conventions.  I\n> understand that at least some of this complexity is due to Bitcoin Script's\n> one element stack rule.\n>\n> IIRC I looked into this a few months ago, and found that the spending\n> cost (script size + expected witness size) of the optimal script for\n> every Miniscript policy at most changes by 1 WU (in either direction)\n> by requiring an empty stack rather than a true value, though in a\n> (admittedly very arbitrarily biased) distribution, more policies were\n> improved by it than degraded. This is not taking Taproot into account\n> (as many of those policies in a Taproot-supporting world should\n> optimally make use of the internal key and Merkle tree, rather than\n> turning everything into a monolithic script). I expect that this may\n> make the impact somewhat larger, but still never more than a 1 WU\n> gain.\n>\n> I don't think the spending cost changes justify this change, so the\n> remaining criteria are complexity ones. In my view, the main benefit\n> would be to authors of hand-written scripts where the consistency\n> benefits matter, but this needs to be weighed against the mental cost\n> of learning the new semantics. For Miniscript itself, this doesn't\n> make much difference - the top level calling convention would become\n> 'V' instead of 'T', but 'T' would still exist as a calling convention\n> that may be used internally; it's a few lines change.\n>\n> So overall this feels like something with marginal costs, but also at\n> most marginal benefits. Perhaps other people have stronger opinions.\n>\n\nThanks for the info.  I'm surprised to learn that 'T' would still exist\ninternally.  That does make my proposed ammendment a somewhat more marginal\nthan I expected.  I still think it would be an improvement, but I guess it\nis acceptable the way it is if that is what other people prefer.\n\n\n> > Even if we choose not to implement the empty stack rule, we should at\n> least require that the last element be 0x01 to remove a potential\n> malleability vector and bring it in line with MINIMAL_IF semantics.\n>\n> This feels like the right thing to do; as we're making MINIMALIF part\n> of consensus for Tapscript it would make sense to apply the same rule\n> to the \"return\" value of the script. There is a downside though,\n> namely that in some places where you'd use \"<n>\n> OP_CHECKSEQUENCEVERIFY\" or \"<n> OP_CHECKLOCKTIMEVERIFY\" you now need\n> to add an additional OP_0NOTEQUAL to convert the left-over element n\n> into an exact 0x01. I also can't come up with any practical benefits\n> that this would have; if the top stack element in a particular code\n> path comes directly from the input, it's insecure regardless; if there\n> isn't, it'll generally be a a boolean (or an intentional non-boolean\n> true value) computed by the script.\n>\n\nThat is a very good argument.  If we were to go with an empty stack we'd\nprobably also want modify to have CSV and CLTV pop their inputs off the\nstack.  But at that point perhaps we'd want to change their opcode values\nto avoid confusion with old style script.  I guess I'm getting more\nconvinced to not touch this stuff just and just bear with the somewhat\nunfortunate legacy behaviour.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/08c86fec/attachment.html>"
            },
            {
                "author": "John Newbery",
                "date": "2019-05-22T14:14:44",
                "message_text_only": "Hi,\n\n> A Taproot output is a SegWit output [...]  with\n> version number 1, and a 33-byte witness program whose first byte is 0 or\n1.\n\nGiven a secret key k and public key P=(x,y), a signer with the knowledge of\nk\ncan sign for -P=(x,p-y) since -k is the secret key for that point. Encoding\nthe\ny value of the public key therefore adds no security. As an alternative to\nproviding the y value of the taproot output key Q when constructing the\ntaproot\noutput, the signer can provide it when signing. We can also restrict the y\nvalue\nof the internal key P to be even (or high, or a quadratic residue). That\ngives\nus 4 options for how to set the y signs for P and Q.\n\n1. Q sign is explictly set in the witness program, P sign is explicitly set\nin the control block\n    => witness program is 33 bytes, 32 possible leaf versions (one for each\npair of 0xc0..0xff)\n2. Q sign is explictly set in the witness program, P sign is implicitly even\n    => witness program is 33 bytes, 64 possible leaf versions (one for each\n0xc0..0xff)\n3. Q sign is explictly set in the control block, P sign is explicitly set\nin the control block\n    => witness program is 32 bytes, 16 possible leaf versions (one for each\n4-tuple of 0xc0..0xff)\n4. Q sign is explictly set in the control block, P sign is implicitly even\n    => witness program is 32 bytes, 32 possible leaf versions (one for pair\nof 0xc0..0xff)\n\nThe current proposal uses (1). Using (3) or (4) would reduce the size of a\ntaproot output by one byte to be the same size as a P2WSH output. That means\nthat it's not more expensive for senders compared to sending to P2WSH.\n\n(Credit to James Chiang for suggesting omitting the y sign from the public\nkey and\nto sipa for pointing out the 4 options above)\n\n> (native or P2SH-nested, see BIP141)\n\nI'd prefer to not support P2SH-nested TR. P2SH wrapping was useful for\nsegwit\nv0 for compatibility reasons. Most wallets/exchanges/services now support\nsending\nto native segwit addresses (https://en.bitcoin.it/wiki/Bech32_adoption) and\nthat\nwill be even more true if Schnorr/Taproot activate in 12+ months time.\n\nOn Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> Here are two BIP drafts that specify a proposal for a Taproot\n> softfork. A number of ideas are included:\n>\n> * Taproot to make all outputs and cooperative spends indistinguishable\n> from eachother.\n> * Merkle branches to hide the unexecuted branches in scripts.\n> * Schnorr signatures enable wallet software to use key\n> aggregation/thresholds within one input.\n> * Improvements to the signature hashing algorithm (including signing\n> all input amounts).\n> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support\n> batch validation.\n> * Tagged hashing for domain separation (avoiding issues like\n> CVE-2012-2459 in Merkle trees).\n> * Extensibility through leaf versions, OP_SUCCESS opcodes, and\n> upgradable pubkey types.\n>\n> The BIP drafts can be found here:\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki\n> specifies the transaction input spending rules.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki\n> specifies the changes to Script inside such spends.\n> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki\n> is the Schnorr signature proposal that was discussed earlier on this\n> list (See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html\n> )\n>\n> An initial reference implementation of the consensus changes, plus\n> preliminary construction/signing tests in the Python framework can be\n> found on https://github.com/sipa/bitcoin/commits/taproot. All\n> together, excluding the Schnorr signature module in libsecp256k1, the\n> consensus changes are around 520 LoC.\n>\n> While many other ideas exist, not everything is incorporated. This\n> includes several ideas that can be implemented separately without loss\n> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,\n> which we're working on as an independent proposal.\n>\n> The document explains basic wallet operations, such as constructing\n> outputs and signing. However, a wide variety of more complex\n> constructions exist. Standardizing these is useful, but out of scope\n> for now. It is likely also desirable to define extensions to PSBT\n> (BIP174) for interacting with Taproot. That too is not included here.\n>\n> Cheers,\n>\n> --\n> Pieter\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/74fc5f35/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Taproot proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "John Newbery",
                "Anthony Towns",
                "Johnson Lau",
                "ZmnSCPxj",
                "Russell O'Connor",
                "Luke Dashjr",
                "Sjors Provoost",
                "Pieter Wuille"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 54946
        }
    },
    {
        "title": "[bitcoin-dev] SIGHASH_ANYPREVOUT proposal",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2019-05-10T20:38:04",
                "message_text_only": "Hi everybody!\n\nHere is a followup BIP draft that enables SIGHASH_ANYPREVOUT and\nSIGHASH_ANYPREVOUTANYSCRIPT on top of taproot/tapscript. (This is NOINPUT,\ndespite the name change)\n\nI don't think we are (or should be) as confident that ANYPREVOUT is\nready for implementation and deployment as we are that taproot is.\nIn particular, we were still coming up with surprising ways that these\nstyle of signatures could maybe cause problems over the past few months,\ndespite \"NOINPUT\" having been around for years, and having been thinking\nseriously about it for most of the last year. In comparison we've had\na roughed out security proof for taproot [0] for over a year now.\n\nSo far, the best approach (in my opinion) that we've come up with to\nlimit the possible negative impacts of these types of signatures is to\nrequire an additional regular signature to accompany every ANYPREVOUT\nsignature. As such, it's included in the BIP draft.\n\nIn theory this ensures that no ANYPREVOUT tx can cause any more problems\nthan some existing tx could; but in practice this assumes that the private\nkey for that signature is maintained in a similar way to the private keys\ncurrently securing transactions are. After passing this around privately,\nI'm not convinced the theory will survive meeting adversarial reality,\nin which case I don't think this draft will be suitable for adoption.\n\nBut maybe I'm too pessimistic, or maybe we can come up with either\na proof that ANYPREVOUT is already safe without any other measures,\nor maybe we can come up with some better measures to ensure it's safe.\nSo in any case I'm still hopeful that publishing the best we've got is\nhelpful, even if that still isn't good enough.\n\nThe BIP draft can be found here:\n https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-anyprevout.mediawiki\n\nA sample implementation based on the taproot branch is here:\n https://github.com/ajtowns/bitcoin/commits/anyprevout\n\nSome interesting features:\n\n * This demonstrates how to upgrade tapscript's existing CHECKSIG,\n   CHECKSIGADD and CHECKSIGVERIFY opcodes for new SIGHASH methods or\n   potentially a new signature scheme, a new elliptic curve or other\n   public key scheme\n * This demonstrates a cheap way of using the taproot internal key\n   as the public key for CHECKSIG operations in script\n * There are two variants, ANYPREVOUT and ANYPREVOUTANYSCRIPT, which\n   seems helpful for eltoo\n * The BIP attempts to describe the security implications of ANYPREVOUT-style\n   signatures\n\nCheers,\naj\n\n[0] https://github.com/apoelstra/taproot/blob/master/main.tex"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-05-22T02:47:31",
                "message_text_only": "Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n\n> Hi everybody!\n>\n> Here is a followup BIP draft that enables SIGHASH_ANYPREVOUT and\n> SIGHASH_ANYPREVOUTANYSCRIPT on top of taproot/tapscript. (This is NOINPUT,\n> despite the name change)\n\nI really like this proposal, and am impressed with how cleanly it\nseparated from taproot/tapscript.\n\nI believe the chaparone signature requirement should be eliminated: I am\naware of four suggested benefits, which I don't believe are addressed\nadaquately enough by chaparones to justify enshrining this complexity\ninto the protocol.\n\n1. \"These features could be used dangerously, and chaparone signatures make\n   them harder to use, thus less likely to be adopted by random wallet\n   authors.\"\n\n   This change is already hard to implement, even once you're on v1\n   segwit; you can't just use it with existing outputs.  I prefer to\n   change the bip introduction to expliclty shout \"THESE SIGNATURE\n   HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.\", and maybe rename it\n   SIGHASH_UNSAFE_ANYPREVOUT.\n\n2. \"Accidental key reuse can make this unsafe.\"\n\n   This is true, but chaparones don't seem to help.  The main purpose of\n   ANYPREV is where you can't re-sign; in particular, in lightning you\n   are co-signing with an untrusted party up-front.  So you have to\n   share the chaparone privkeys with one untrusted party.\n\n   The BIP says \"SHOULD limit the distribution of those private keys\".\n   That seems ridiculously optimistic: don't tell the secret to more\n   than *one* untrusted party?\n\n   In fact, lightning will also need to hand chaparone keys to\n   watchtowers, so we'll probably end up using some fixed known secret.\n\n3. \"Miners can reorg and invalidate downstream txs\".\n\n   There's a principle (ISTR reading it years ago from Greg Maxwell?)\n   that if no spender is malicious, a transaction should generally not\n   become invalid.  With ANYPREV, a miner could reattach a transaction\n   during a reorg, changing its txid and invalidating normal spends from\n   it.\n\n   In practice, I believe this principle will remain just as generally\n   true with ANYPREV:\n\n   1. For lightning the locktime will be fairly high before these txs are\n      generally spendable.\n   2. Doing this would require special software, since I don't see bitcoin\n      core indexing outputs to enable this kind of rewriting.\n   3. We already added such a common possibility with RBF, but before I\n      brought it up I don't believe anyone realized.  We certainly\n      haven't seen any problems in practice, for similar practical\n      reasons.\n\n4. \"Rebinding is a new power in bitcoin, and it makes me uncomfortable\".\n\n   I have a degree of sympathy for this view, but objections must be\n   backed in facts.  If we don't understand it well enough, we should\n   not do it.  If we do understand it, we should be able to point out\n   real problems.\n\nFinally, it seems to me that chaparones can be opt-in, and don't need to\nburden the protocol.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2019-05-22T20:11:31",
                "message_text_only": "On Wed, May 22, 2019 at 12:17:31PM +0930, Rusty Russell wrote:\n>    I prefer to\n>    change the bip introduction to expliclty shout \"THESE SIGNATURE\n>    HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.\", and maybe rename it\n>    SIGHASH_UNSAFE_ANYPREVOUT.\n\n> 4. \"Rebinding is a new power in bitcoin, and it makes me uncomfortable\".\n>    I have a degree of sympathy for this view, but objections must be\n>    backed in facts.  If we don't understand it well enough, we should\n>    not do it.\n\nYeah, that's where I'm at: if we think something is UNSAFE enough to\nneed a warning, then I think it's too unsafe to include in the consensus\nlayer. I would like to find a way of making ANYPREVOUT safe enough that\nit doesn't need scary warnings; a week or two ago, chaperone sigs were\nmy best idea for that.\n\n> Finally, it seems to me that chaparones can be opt-in, and don't need to\n> burden the protocol.\n\nEltoo (and perhaps lightning more generally) seem like the most obvious\nuse case for ANYPREVOUT, so if it isn't going to opt-in (or is going\nto opt-out in any way it can, as you suggest) then they're not a good\nsolution.\n\nI'm not going to argue about any of that here, though I do reserve the\nright to do so later. :)\n\nSo here's something I almost think is an argument that ANYPREVOUT is safe\n(without chaperone sigs or output tagging, etc).\n\n#1. I'm assuming funds are \"safe\" in Bitcoin if they're (a) held in\na cryptographically secured UTXO, (b) under \"enough\" proof of work\nthat a reorg is \"sufficiently\" unlikely. If you don't have both those\nassumptions, your money is not safe in obvious ways; if you do have them\nboth, your money is safe.\n\n#2. My theory is that as long as you, personally, only use ANYPREVOUT\nto sign transactions that are paying the money back to yourself, your\nfunds will remain safe.\n\nIf you follow this rule, then other people replaying your signature is\nnot a problem -- the funds will just move from one of your addresses, to\na different address.\n\nIf other people *fail* to follow this rule, you might receive funds\ndirectly authorised by an ANYPREVOUT signature. But those funds are only\nsecure if they're \"sufficiently\" buried in confirmations anyway, and\nonce they are, they won't disappear. You might be able to reuse that\nsignature against some different UTXO, but that's only to your benefit:\nthey lose funds after violating the rule, but you gain funds.\n\nEltoo naturally meets this requirement, as long as you consider \"paying\nto yourself\" to cover both \"paying to same multisig address\" (for update\ntransactions) and \"splitting funds between members of a group who owned\nthe funds\". If you consider the \"split\" to be \"you get 50% of our funds,\nyou get 20%, you get 30%\", even if the signature gets replayed later\nagainst a different utxo, the percentage split remains true it just\nunexpectedly applies to more funds.\n\n#3. Making ANYPREVOUT only available via script is aligned with this;\nif you'repaying to yourself you probably want complicated rules that\nyou have to encode in script, and there's a mild economic incentive to\ntry to avoid that because the key path is cheaper.\n\n#4. I think this covers the major security property for bitcoin (your\nfunds are yours to decide what to do with), but maybe there are other\nways in which ANYPREVOUT is scary that could be formalised and addressed?\n\n#5. It's probably not compatible with luke's \"malleability proof\" wallet\nidea [0]. Malleability is only a concern for funds that aren't already\n\"sufficiently\" buried, and if you're only spending it to yourself that\ndoesn't help with burying, and if you're spending it to someone else\nimmediately after, doesn't help with making that transaction less\nmalleable. But if the line of argument above's correct, that just\nrecognises that a wallet like that risks losing funds if someone else\nreuses its addresses; it doesn't add any systemic risk. And \"wallet X\nisn't safe\" is a risk category we already deal with.\n\n[0] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012463.html\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2019-05-27T01:26:01",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Wed, May 22, 2019 at 12:17:31PM +0930, Rusty Russell wrote:\n>>    I prefer to\n>>    change the bip introduction to expliclty shout \"THESE SIGNATURE\n>>    HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.\", and maybe rename it\n>>    SIGHASH_UNSAFE_ANYPREVOUT.\n>\n>> 4. \"Rebinding is a new power in bitcoin, and it makes me uncomfortable\".\n>>    I have a degree of sympathy for this view, but objections must be\n>>    backed in facts.  If we don't understand it well enough, we should\n>>    not do it.\n>\n> Yeah, that's where I'm at: if we think something is UNSAFE enough to\n> need a warning, then I think it's too unsafe to include in the consensus\n> layer. I would like to find a way of making ANYPREVOUT safe enough that\n> it doesn't need scary warnings; a week or two ago, chaperone sigs were\n> my best idea for that.\n\nThe DO_NOT_WANT naming is to prevent people who *don't* want to use it\nfrom using it because it's the \"new hotness\".\n\nIt cannot both be powerful enough to do what we need (rebinding) and\nsafe enough for general use (no rebinding).\n\n> So here's something I almost think is an argument that ANYPREVOUT is safe\n> (without chaperone sigs or output tagging, etc).\n>\n> #1. I'm assuming funds are \"safe\" in Bitcoin if they're (a) held in\n> a cryptographically secured UTXO, (b) under \"enough\" proof of work\n> that a reorg is \"sufficiently\" unlikely. If you don't have both those\n> assumptions, your money is not safe in obvious ways; if you do have them\n> both, your money is safe.\n>\n> #2. My theory is that as long as you, personally, only use ANYPREVOUT\n> to sign transactions that are paying the money back to yourself, your\n> funds will remain safe.\n>\n> If you follow this rule, then other people replaying your signature is\n> not a problem -- the funds will just move from one of your addresses, to\n> a different address.\n...\n> Eltoo naturally meets this requirement, as long as you consider \"paying\n> to yourself\" to cover both \"paying to same multisig address\" (for update\n> transactions)\n\nI disagree?  Paying to share with an untrusted party is *insecure*\nwithout further, complex arrangements.  Those arrangements (already a\nrequirement for lightning) worry me far more than the bitcoin-level\nrebinding, TBH.\n\nLightning relies on #1, not #2.  I don't know of any use for #2 in fact;\nin practice if you have control of keys you can generally sign a new tx,\nnot requiring ANYPREVOUT.  If you're trying to blindly spend a tx which\nmay be RBF'd, ANYPREVOUT won't generally help you (amount changes).\n\n> #5. It's probably not compatible with luke's \"malleability proof\" wallet\n> idea [0]. Malleability is only a concern for funds that aren't already\n> \"sufficiently\" buried, and if you're only spending it to yourself that\n> doesn't help with burying, and if you're spending it to someone else\n> immediately after, doesn't help with making that transaction less\n> malleable. But if the line of argument above's correct, that just\n> recognises that a wallet like that risks losing funds if someone else\n> reuses its addresses; it doesn't add any systemic risk. And \"wallet X\n> isn't safe\" is a risk category we already deal with.\n\nYes, I think our primary concern is risk to non-ANYPREVOUT using txs.\nThat would make ANYPREVOUT a bad idea, but seems we're concluding that's\nnot the case.\n\nSecondary, is the accidentally-using-ANYPREVOUT scenario, which I\nconsider unlikely (like accidentally-using-SIGHASHNONE), especially\nsince you need to actually mark your keys now, so you can't do it\npost-hoc to existing outputs.\n\nFinal concern is the using-correctly-but-nasty-gotchas.  This seems to\nbe inherent in rebinding, and is fully addressed by Don't Reuse\nAddresses.  That is already a requirement for lightning (reusing\nrevocation keys is fatal).  Others reusing your addresses is already a\nthing we have to deal with in bitcoin (Enjoy/Sochi).\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "SIGHASH_ANYPREVOUT proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 13527
        }
    },
    {
        "title": "[bitcoin-dev] IBLT & Bitcoin",
        "thread_messages": [
            {
                "author": "Christopher DeLucia",
                "date": "2019-05-12T01:35:38",
                "message_text_only": "Hi all,\n\nWhile in college (2017), I produced this paper on IBLT applications and\nBitcoin that referenced some of the research done by folks like Gavin\nAndresen and Rusty Russell.\n\nThis should come with a disclaimer: I have not really looked at this paper\nnor Bitcoin since 2017.  Additionally, this paper was not peer reviewed; it\nwas just for class.\n\nRegardless, I came across it when I was cleaning out some old docs on my\ndrive and figured I'd send it over to bitcoin-dev in the event it can\ncontribute to anything at all.\n\nThanks,\nChris\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190511/44daa7ae/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: IBLT Memory Pool Paper.pdf\nType: application/pdf\nSize: 522278 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190511/44daa7ae/attachment-0001.pdf>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-13T23:39:51",
                "message_text_only": "Good morning Chris,\n\nAs I understand it, the latest proposal for improved transaction relay is to use Bose-Chaudhuri-Hocquenghem codes for set reconciliation.\nhttps://github.com/sipa/minisketch\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, May 12, 2019 9:35 AM, Christopher DeLucia via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> While in college (2017), I produced this paper on IBLT applications and Bitcoin that referenced some of the research done by folks like Gavin Andresen and Rusty Russell.\u00a0\n>\n> This should come with a disclaimer: I have not really looked at this paper nor Bitcoin since 2017.\u00a0 Additionally, this paper was not peer reviewed; it was just for class.\n>\n> Regardless, I came across it when I was cleaning out some old docs on my drive and figured I'd send it over to bitcoin-dev in the event it can contribute to anything at all.\n>\n> Thanks,\n> Chris"
            }
        ],
        "thread_summary": {
            "title": "IBLT & Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Christopher DeLucia"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1973
        }
    },
    {
        "title": "[bitcoin-dev] Code not following proof of security",
        "thread_messages": [
            {
                "author": "Zawy",
                "date": "2019-05-18T17:40:16",
                "message_text_only": "If MAX_FUTURE_BLOCK_TIME in chain.h is set smaller than\nDEFAULT_MAX_TIME_ADJUSTMENT in timedata.h, the POW security can be\nundermined by a 33% Sybil attack on the nodes. Blocks with accurate\ntimestamps would be rejected which allows various attacks. Code should\nreflect a proof of security, so it should be coded as\n\nDEFAULT_MAX_TIME_ADJUSTMENT = MAX_FUTURE_BLOCK_TIME / 2\n\n(or sufficiently commented) otherwise future developers could make a\nchange that hurts security. \"Unintended consequences due to how\ndisparate code interacts\" is the result of code not following a proof\nof security. I came across this while trying to \"derive\" POW security\nfrom within Lamport's 1982 framework. The problem is that POW security\nrequires clock synchronization. But using median of network time for\nit is a consensus mechanism that is subject to Byzantine attacks. So\nPOW requires an absolute bound on time (enforced by an oracle) that is\nat least as stringent as  the allowed timestamp variation.  The rule\nto revert to node time if network time is >70 minutes off is the real\nbound that honest nodes can impose unilaterally, limiting the\npotential damage of consensus (if MAX_FUTURE_BLOCK_TIME is not too\nsmall). This fail-safe uses node operators as the oracle, who can all\napproximately agree as to what time it is without asking each other. A\n>50% Sybil attack on nodes fails because an honest new node joining\ncan unilaterally reject the chain if the current timestamp is not\nrealistic. Cryptonote appears to have done away with network time\nwithout ill effect. The only other option to \"the node operator is the\noracle\" is to assume all internal clocks have a max drift, but this\nwould disconnect timestamps from real time to the extent of that drift\n(if I'm reading Halpern, etc 1984 IBM correctly). I'm assuming Mike\nHearn was wrong in saying the centralization of NTP (or GPS) is\nacceptable:\n\nhttps://bitcointalk.org/index.php?topic=10241.msg148084#msg148084\n\nThis affects coins who reduced MAX_FUTURE_BLOCK_TIME without either\nremoving the time consensus mechanism or reducing the\nDEFAULT_MAX_TIME_ADJUSTMENT. Many have done this in order to have\nfaster responding difficulty algorithms, otherwise a large\nMAX_FUTURE_BLOCK_TIME allows a sizable manipulation of difficulty.\nTherefore, MAX_FUTURE_BLOCK_TIME should itself should be a function of\nthe size of the difficulty window for proof of security (instead of a\nconstant). I suspect more constants = less proof of security. For\nexample\nMFBT = WindowTimespan / 10 would limit timestamp manipulation to 10% per window."
            }
        ],
        "thread_summary": {
            "title": "Code not following proof of security",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Zawy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2567
        }
    },
    {
        "title": "[bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY proposal",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2019-05-20T20:58:03",
                "message_text_only": "Hello bitcoin-devs,\n\nBelow is a link to a BIP Draft for a new opcode, OP_CHECKOUTPUTSHASHVERIFY.\nThis opcode enables an easy-to-use trustless congestion control techniques\nvia a rudimentary, limited form of covenant which does not bear the same\ntechnical and social risks of prior covenant designs.\n\nCongestion control allows Bitcoin users to confirm payments to many users\nin a single transaction without creating the UTXO on-chain until a later\ntime. This therefore improves the throughput of confirmed payments, at the\nexpense of latency on spendability and increased average block space\nutilization. The BIP covers this use case in detail, and a few other use\ncases lightly.\n\nThe BIP draft is here:\nhttps://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki\n\nThe BIP proposes to deploy the change simultaneously with Taproot as an\nOPSUCCESS, but it could be deployed separately if needed.\n\nAn initial reference implementation of the consensus changes and  tests\nwhich demonstrate how to use it for basic congestion control is available\nat https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The\nchanges are about 74 lines of code on top of sipa's Taproot reference\nimplementation.\n\nBest regards,\n\nJeremy Rubin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190520/63c29c81/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2019-05-21T19:41:22",
                "message_text_only": "If we're going to do covenants (and I think we should), then I think we\nneed to have a flexible solution that provides more features than just\nthis, or we risk adding it only to go through all the effort again when\npeople ask for a better solution.\n\nMatt\n\nOn 5/20/19 8:58 PM, Jeremy via bitcoin-dev wrote:\n> Hello bitcoin-devs,\n> \n> Below is a link to a BIP Draft for a new opcode,\n> OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless\n> congestion control techniques via a rudimentary, limited form of\n> covenant which does not bear the same technical and social risks of\n> prior covenant designs.\n> \n> Congestion control allows Bitcoin users to confirm payments to many\n> users in a single transaction without creating the UTXO on-chain until a\n> later time. This therefore improves the throughput of confirmed\n> payments, at the expense of latency on spendability and increased\n> average block space utilization. The BIP covers this use case in detail,\n> and a few other use cases lightly.\n> \n> The BIP draft is here:\n> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki\n> \n> The BIP proposes to deploy the change simultaneously with Taproot as an\n> OPSUCCESS, but it could be deployed separately if needed.\n> \n> An initial reference implementation of the consensus changes and\u00a0 tests\n> which demonstrate how to use it for basic congestion control is\n> available at\n> https://github.com/JeremyRubin/bitcoin/tree/congestion-control.\u00a0 The\n> changes are about 74 lines of code on top of sipa's Taproot reference\n> implementation.\n> \n> Best regards,\n> \n> Jeremy Rubin\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-22T01:47:11",
                "message_text_only": "I agree a little bit, but I think that logic is somewhat infectious. If\nwe're going to do covenants, we should also do it as a part of a more\ncomprehensive new scripting system that gives us other strong benefits for\nour ability to template scripts. And so on. I'm excited to see what's\npossible!\n\nGiven that this is very simple to implement and has obvious deployable big\nwins with few controversial drawbacks, it makes more sense to streamline\nadoption of something like this for now and work on a more comprehensive\nsolution without urgency.\n\nThe design is also explicitly versioned so short of an eventual full\nredesign it should be easy enough to add more flexible features piecemeal\nas they come up and their use cases are strongly justified as I have shown\nhere for certified post dated utxo creation.\n\nLastly I think that while these are classifiable as covenants in\nimplementation, they are closer in use to multisig pre-signed scripts,\nwithout the requirement of interactive setup. We should think of these as\n'certified checks' instead, which can also describe a pre-signed design\nsatisfactorily. With true covenants we don't want require the satisfying\nconditions to be 'computationally enumerable' (e.g. we can't in\ncomputational limits enumerate all public keys if the covenant expresses a\nspend must be to a public key). And if the covenant is computationally\nenumerable, then we should use this construct and put the spending paths\ninto a Huffman encoded taproot tree.\n\nOn Tue, May 21, 2019, 12:41 PM Matt Corallo <lf-lists at mattcorallo.com>\nwrote:\n\n> If we're going to do covenants (and I think we should), then I think we\n> need to have a flexible solution that provides more features than just\n> this, or we risk adding it only to go through all the effort again when\n> people ask for a better solution.\n>\n> Matt\n>\n> On 5/20/19 8:58 PM, Jeremy via bitcoin-dev wrote:\n> > Hello bitcoin-devs,\n> >\n> > Below is a link to a BIP Draft for a new opcode,\n> > OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless\n> > congestion control techniques via a rudimentary, limited form of\n> > covenant which does not bear the same technical and social risks of\n> > prior covenant designs.\n> >\n> > Congestion control allows Bitcoin users to confirm payments to many\n> > users in a single transaction without creating the UTXO on-chain until a\n> > later time. This therefore improves the throughput of confirmed\n> > payments, at the expense of latency on spendability and increased\n> > average block space utilization. The BIP covers this use case in detail,\n> > and a few other use cases lightly.\n> >\n> > The BIP draft is here:\n> >\n> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki\n> >\n> > The BIP proposes to deploy the change simultaneously with Taproot as an\n> > OPSUCCESS, but it could be deployed separately if needed.\n> >\n> > An initial reference implementation of the consensus changes and  tests\n> > which demonstrate how to use it for basic congestion control is\n> > available at\n> > https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The\n> > changes are about 74 lines of code on top of sipa's Taproot reference\n> > implementation.\n> >\n> > Best regards,\n> >\n> > Jeremy Rubin\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/618bcea2/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-22T02:51:52",
                "message_text_only": "Good morning Jeremy,\n\n>If a sender needs to know the recipient can remove the covenant before spending, they may request a signature of an challenge string from the recipients\n\nThe recipients can always choose to destroy the privkey after providing the above signature.\nIndeed, the recipients can always insist on not cooperating to sign using the taproot branch and thus force spending via the `OP_CHECKOUTPUTSHASHVERIFY`.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-22T05:11:55",
                "message_text_only": "Morning,\n\nYes, in general, Bitcoin does not do anything to prevent users from\ndiscarding their keys.\n\nI don't think this will be fixed anytime soon.\n\nThere are some protocols where, though, knowing that a key was once known\nto the recipients may make it legally valid to inflict a punitive measure\n(e.g., via HTLC), whereas if the key was never known that might be a breach\nof contract for the payment provider.\n\nBest,\n\nJeremy\n\nOn Tue, May 21, 2019 at 7:52 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Jeremy,\n>\n> >If a sender needs to know the recipient can remove the covenant before\n> spending, they may request a signature of an challenge string from the\n> recipients\n>\n> The recipients can always choose to destroy the privkey after providing\n> the above signature.\n> Indeed, the recipients can always insist on not cooperating to sign using\n> the taproot branch and thus force spending via the\n> `OP_CHECKOUTPUTSHASHVERIFY`.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/90cc48e6/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-22T06:04:27",
                "message_text_only": "Good morning,\n\nSome more comments.\n\n* I do not think CoinJoin is much improved by this opcode.\n  Typically, you would sign off only if one of the outputs of the CoinJoin transaction is yours, and this does not really improve this situation.\n* Using this for congestion control increases blockchain usage by one TXO and one input, ending up with *more* bytes onchain, and a UTXO that will be removed later in (we hope) short time.\n  I do not know if this is a good idea, to increase congestion by making unnecessary intermediate transaction outputs, at times when congestion is a problem.\n* I cannot find a way to implement Decker-Russell-Osuntokun (or any offchain update mechanism) on top of this opcode, so I cannot support replacing `SIGHASH_NOINPUT` with this opcode.\n  In particular, while the finite loop support by this opcode appears (at first glance) to be useable as the \"stepper\" for an offchain update mechanism, I cannot find a good way to short-circuit the transaction chain without `SIGHASH_NOINPUT` anyway.\n* Channel factories created by this opcode do not, by themselves, support updates to the channel structure.\n  But such simple \"close only\" channel factories can be done using n-of-n and a pre-signed offchain transaction (especially since the entities interested in the factory are known and enumerable, and thus can be induced to sign in order to enter the factory).\n  More complex channel factories that can update the division of the factory to channels cannot be done without a multiparty offchain update mechanism such as Decker-Wattenhofer or Decker-Russell-Osuntokun.\n  So, similarly to CoinJoin, I do not think it is much improved by this opcode.\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, May 22, 2019 1:11 PM, Jeremy <jlrubin at mit.edu> wrote:\n\n> Morning,\n>\n> Yes, in general, Bitcoin does not do anything to prevent users from discarding their keys.\n>\n> I don't think this will be fixed anytime soon.\n>\n> There are some protocols where, though, knowing that a key was once known to the recipients may make it legally valid to inflict a punitive measure (e.g., via HTLC), whereas if the key was never known that might be a breach of contract for the payment provider.\n>\n> Best,\n>\n> Jeremy\n>\n> On Tue, May 21, 2019 at 7:52 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Jeremy,\n> >\n> > >If a sender needs to know the recipient can remove the covenant before spending, they may request a signature of an challenge string from the recipients\n> >\n> > The recipients can always choose to destroy the privkey after providing the above signature.\n> > Indeed, the recipients can always insist on not cooperating to sign using the taproot branch and thus force spending via the `OP_CHECKOUTPUTSHASHVERIFY`.\n> >\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-22T08:10:23",
                "message_text_only": "> * I do not think CoinJoin is much improved by this opcode.\n>   Typically, you would sign off only if one of the outputs of the\nCoinJoin transaction is yours, and this does not really improve this\nsituation.\n\nCoinjoin benefits a lot I think.\n\n\nCoinjoin is improved because you can fit more users into the protocol and\ncreate many more outputs at lower cost or include more participants.\nIdeally a coinjoin creates a lot of outputs so that the ownership is\nsmeared more, but this has a cost at the time of the coinjoin.\n\nCoinjoin is also improved because you don't reveal the outputs created by\nthe coinjoin until some time, perhaps very far in the future, when you need\nthe coin. In fact, you only need to reveal where you're moving the coins to\nparticipants in your subtree because participants need only verify their\nbranch.\n\nIt also makes the protocol more stable with respect to input choice. This\nis because, similar to how NOINPUT may work, OP_COSHV outputs are spendable\nwithout knowing what the TXID will be. Therefore if someone changes their\ninput or non segwit spend script, it won't break the presigned txns. This\nalso means that all the inputs can be ANYONECANPAY, so there is no need to\nreveal your inputs before anyone else.\n\nThis culminates in being able to open channels from a coinjoin safely, I\nbelieve this is difficult/impossible to do currently.\n\n\n\n\n> * Using this for congestion control increases blockchain usage by one TXO\nand one input, ending up with *more* bytes onchain, and a UTXO that will be\nremoved later in (we hope) short time.\n>   I do not know if this is a good idea, to increase congestion by making\nunnecessary intermediate transaction outputs, at times when congestion is a\nproblem.\n\nThis is a good idea because it improves QoS for most users.\n\nFor receiving money pending spendable but confirmed payment (i.e. certified\nchecks) is superior to having unconfirmed funds.\n\nFor sending money, being able to clear all liabilities in a single txn\ndecreases business exposure to fee variance and confirmation time variance.\nE.g., if I'm doing payroll in Bitcoin I will pay big fines if I am a day\nlate. If I have 10,000 employees this might be painful if fees are\ncurrently up.\n\nIt also helps to have a backlog of low priority txns to support the fee\nmarket.\n\nOverall block bandwidth utilization is fairly spikey, so having long term\nwell known outputs that are not time sensitive can be used to better\nutilize bandwidth.\n\nThe total extra bandwidth btw is really small given the expansion factor\noptimizations available.\n\n\n> * I cannot find a way to implement Decker-Russell-Osuntokun (or any\noffchain update mechanism) on top of this opcode, so I cannot support\nreplacing `SIGHASH_NOINPUT` with this opcode.\n>   In particular, while the finite loop support by this opcode appears (at\nfirst glance) to be useable as the \"stepper\" for an offchain update\nmechanism, I cannot find a good way to short-circuit the transaction chain\nwithout `SIGHASH_NOINPUT` anyway.\n\nI'm not deeply familiar with DRO channels. This opcode isn't a replacement\nfor SIGHASH_NOINPUT -- SIGHASH_NOINPUT is mentioned merely to contrast\nusing SIGHASH_NOINPUT for the uses presented in this BIP.\n\nLastly there's no 'replacing'. Neither NOINPUT nor COSHV are accepted by\nthe community at large yet, and they do different things.\n\n\n> * Channel factories created by this opcode do not, by themselves, support\nupdates to the channel structure.\n>   But such simple \"close only\" channel factories can be done using n-of-n\nand a pre-signed offchain transaction (especially since the entities\ninterested in the factory are known and enumerable, and thus can be induced\nto sign in order to enter the factory).\n\nI'm not really an expert at Bitcoin Lightning, but this basic mechanism\nshould work.\n\nImagine the script at a leaf node:\n\nTaproot([Alice, Bob], [OP_COSHV <H(H(2 coins to uncooperative script))>]\nwhere uncooperative script is:\n\nTaproot([Alice, Bob], [\"1 week\" CHECKSEQUENCEVERIFY DROP OP_COSHV <H(H(Pay\nalice 2 coins))>)\n\nCooperative closing skips the extra transactions. Updates are signed\nagainst the uncooperative script with repudation. E.g.:\n\n    HASH160 <revokehash> EQUAL\n    IF\n        <Bob's pubkey>\n    ELSE\n        \"1 week\" CHECKSEQUENCEVERIFY DROP\n        <Alice's pubkey>\n    ENDIF\n    CHECKSIG\n\nIt can even be optimized by letting the uncooperative script branches in\nthe leaf be blaming Alice or Bob.\n\nDoes that not work?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/671f372d/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-23T03:45:39",
                "message_text_only": "Good morning Jeremy,\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, May 22, 2019 4:10 PM, Jeremy <jlrubin at mit.edu> wrote:\n\n> > * I do not think CoinJoin is much improved by this opcode.\n> > \u00a0 Typically, you would sign off only if one of the outputs of the CoinJoin transaction is yours, and this does not really improve this situation.\n>\n> Coinjoin benefits a lot I think.\n>\n> Coinjoin is improved because you can fit more users into the protocol and create many more outputs at lower cost or include more participants. Ideally a coinjoin creates a lot of outputs so that the ownership is smeared more, but this has a cost at the time of the coinjoin.\n\nBut the separate outputs still need to be published at some point in the future.\nFurther, ideally CoinJoin should be as indistinguishable from normal transactions as possible.\n(admittedly, the equal-sized outputs often recommended for CoinJoin tend to blatantly signal \"this is a CoinJoin!!\", but in any case that \"should\" be fixed with some kind of future Confidential Transactions)\n\n>\n> Coinjoin is also improved because you don't reveal the outputs created by the coinjoin until some time, perhaps very far in the future, when you need the coin. In fact, you only need to reveal where you're moving the coins to participants in your subtree because participants need only verify their branch.\n\nThe same technique of congestion control can still be used with only an \"ordinary\" MuSig of all participant keys on the output of the \"funding\" transaction, forming a sort of very tiny CoinJoinXT.\nThis has the advantage that the MuSig is indistinguishable from 1-of-1 spends, which is important for a privacy technique like CoinJoin.\nEven in the future and we have published the output-side transaction of the CoinJoin, the transaction chain *could* be interpreted as \"one person consolidated all his coins in an ordinary 1-of-1 UTXO, then spent on several things at once\" whereas use of the `OP_CHECKOUTPUTSHASHVERIFY` is a blatant \"several people agreed to put in their coins provided these outputs were on the second transaction, i.e. some kind of attempt at hiding their coins\".\n\n>\n> It also makes the protocol more stable with respect to input choice. This is because, similar to how NOINPUT may work, OP_COSHV outputs are spendable without knowing what the TXID will be. Therefore if someone changes their input or non segwit spend script, it won't break the presigned txns. This also means that all the inputs can be ANYONECANPAY, so there is no need to reveal your inputs before anyone else.\n>\n> This culminates in being able to open channels from a coinjoin safely, I believe this is difficult/impossible to do currently.\n\nThis is already *technically* possible, though no software exists to do so (sorry, we have bugs between interop of c-lightning and lnd that take up our debugging time already, we cannot spare it for this *yet*).\n\nSegWit by itself already allows child transactions to be signed before parent transactions are signed.\nThis safety underlies *all* offchain protocols.\nSee: https://zmnscpxj.github.io/offchain/generalized.html\nThis is sufficient to ensure that channels can be opened from whatever transactions you want, though having to interop with other software that *also* has to coordinate with other participants in a different protocol is much more difficult than having to interop with other software using the same protocol.\n\nFinally, `SIGHASH_ANYPREVOUT` can *also* do this, since the txid becomes mooted.\nAnd `SIGHASH_ANYPREVOUT` *also* enables a better offchain update mechanism (Decker-Russell-Osuntokun, more commonly known as \"eltoo\") whereas I am unable to derive a similar offchain update mechanism using `OP_CHECKOUTPUTSHASHVERIFY` (though possibly for lack of trying).\n\n>\n> > * Using this for congestion control increases blockchain usage by one TXO and one input, ending up with *more* bytes onchain, and a UTXO that will be removed later in (we hope) short time.\n> > \u00a0 I do not know if this is a good idea, to increase congestion by making unnecessary intermediate transaction outputs, at times when congestion is a problem.\n>\n> This is a good idea because it improves QoS for most users.\n>\n> For receiving money pending spendable but confirmed payment (i.e. certified checks) is superior to having unconfirmed funds.\n>\n> For sending money, being able to clear all liabilities in a single txn decreases business exposure to fee variance and confirmation time variance. E.g., if I'm doing payroll in Bitcoin I will pay big fines if I am a day late. If I have 10,000 employees this might be painful if fees are currently up.\n>\n> It also helps to have a backlog of low priority txns to support the fee market.\n>\n> Overall block bandwidth utilization is fairly spikey, so having long term well known outputs that are not time sensitive can be used to better utilize bandwidth.\n>\n> The total extra bandwidth btw is really small given the expansion factor optimizations available.\n\nOkay, you have convinced me regarding this point, at least.\n\n> > * Channel factories created by this opcode do not, by themselves, support updates to the channel structure.\n> > \u00a0 But such simple \"close only\" channel factories can be done using n-of-n and a pre-signed offchain transaction (especially since the entities interested in the factory are known and enumerable, and thus can be induced to sign in order to enter the factory).\n>\n> I'm not really an expert at Bitcoin Lightning, but this basic mechanism should work.\n> Imagine the script at a leaf node:\n>\n> Taproot([Alice, Bob], [OP_COSHV <H(H(2 coins to uncooperative script))>]\n>\n> where uncooperative script is:\n>\n> Taproot([Alice, Bob], [\"1 week\" CHECKSEQUENCEVERIFY DROP  OP_COSHV <H(H(Pay alice 2 coins))>)\n>\n> Cooperative closing skips the extra transactions. Updates are signed against the uncooperative script with repudation. E.g.:\n>\n> \u00a0 \u00a0 HASH160 <revokehash> EQUAL\n> \u00a0 \u00a0 IF\n> \u00a0 \u00a0 \u00a0 \u00a0 <Bob's pubkey>\n> \u00a0 \u00a0 ELSE\n> \u00a0 \u00a0 \u00a0 \u00a0 \"1 week\" CHECKSEQUENCEVERIFY DROP\n> \u00a0 \u00a0 \u00a0 \u00a0 <Alice's pubkey>\n> \u00a0 \u00a0 ENDIF\n> \u00a0 \u00a0 CHECKSIG\n>\n> It can even be optimized by letting the uncooperative script branches in the leaf be blaming Alice or Bob.\n>\n> Does that not work?\n\nPossibly, but the point is that an n-of-n MuSig will work just as well and we would not need to reveal the Taproot key (33 bytes) and the specific script containing the output hash (1+32 bytes) we want, we just have to reveal a single 64-byte signature.\n\nMy objection here is simply that n-of-n already exists, it will work already using that (and it is much more likely to be assured of getting into base layer).\n\nAgain, we only need to use SegWit and sign transactions in reverse order to ensure proper operation.\nThis is already what is done for normal channel opens (the initial commitment transactions are signed first, then the funding transaction is signed and confirmed onchain).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-24T21:15:07",
                "message_text_only": "ZmnSCIPxj,\n\nI think you're missing the general point, so I'm just going to respond to\none point to see if that helps your understanding of why OP_COSHV is better\nthan just pre-signed.\n\nThe reason why MuSig and other distributed signing solutions are not\nacceptable for this case is they all require interaction for guarantee of\npayout.\n\nIn contrast, I can use a OP_COSHV Taproot key to request a withdrawal from\nan exchange which some time later pays out to a lot of people, rather than\nhaving to withdraw multiple times and then pay. The exchange doesn't have\nto know this is what I did. They also don't have to tell me the exact\ninputs they'll spend to me or if I'm batched or not (batching largely\nincompatible with pre-signing unless anyprevout)\n\nThe exchange can take my withdrawal request and aggregate it to other\npayees into a tree as well, without requiring permission from the\nrecipients.\n\nThey can also -- without my permission -- make the payment not directly\ninto me, but into a payment channel between me and the exchange, allowing\nme to undo the withdrawal by routing money back to the exchange over\nlightning.\n\nThe exchange can take some inbound payments to their hot wallet and move\nthem into cold storage with pre-set spending paths. They don't need to use\nephemeral keys (how was that entropy created?) nor do they need to bring on\ntheir cold storage keys to pre-sign the spending paths.\n\nNone of this really works well with just pre-signing because you need to\nask for permission first in order to do these operations, but with OP_COSHV\nyou can, just as the payer without talking to anyone else, or just as the\nrecipient commit your funds to a complex txn structure.\n\nLastly, think about this in terms of DoS. You have a set of N users who\nrequest a payment. You build the tree, collect signatures, and then at the\nLAST step of building the tree, one user drops out. You restart, excluding\nthat user. Then a different user drops. Meanwhile you've had to keep your\nfunds locked up to guarantee those inputs for the txn when it finalizes.\n\nIn contrast, once you receive the requests with OP_COSHV, there's nothing\nelse to do. You just issue the transaction and move on.\n\n\nDoes that make sense as to why a user would prefer this, even if there is\nan emulation with pre-signed txns?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/082629f1/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-05-22T20:49:11",
                "message_text_only": "On Wed, May 22, 2019 at 06:04:27AM +0000, ZmnSCPxj via bitcoin-dev wrote:\n> * I do not think CoinJoin is much improved by this opcode.\n\nI think (especially with cross-input sig aggregation) it makes it easier\nto do a coinjoin during a high fee period -- if you're willing to wait\n'til fees are lower to claim your funds you can still do that, despite\nparticipating now.\n\nOtherwise, I don't think it makes coordination that much easier. \n\nIf the coinjoin groups stays around in a Layer 2-ish protocol, and\ncoordinates to cut-through transactions, that could be a scaling and\nprivacy benefit, but comes with much harder coordination problems. ie:\n\n   A,B,C,D do a coinjoin with outputs of 1 BTC each\n   tx on chain looks like:\n     in: 1 A\n         1 B\n         1 C\n         1 D\n     out: 4 to muSig(A,B,C,D) or COHV(1 A, 1 B, 1 C, 1 D)\n\nbut then A wants to spend 0.2 BTC to E, and B wants to spend 0.1 BTC to\nF, so they agree to update the state and publish:\n\n     in: (above, signed by A+B+C+D)\n     out: \n         0.1 F\n\t 0.2 E\n\t 3.7 to muSig(A,B,C,D) or COHV(0.8 A, 0.9 B, 1 C, 1 D)\n\nand they continue the protocol.\n\n> * I cannot support replacing `SIGHASH_NOINPUT` with this opcode.\n\n(I don't think this in any way replaces ANYPREVOUT or similar)\n\nI think lightning is improved by this in that it makes it cheaper to\ncreate lightning channels during a high fee period. If you're creating\n1000 channels you can do that via a single output with this opcode, and\nthen wait until either there's a low fee period to publish the funding\ntx cheaply; or until the channel fails and you need to extract the funds\nwhich always has the risk of happening during a high fee period.\n\nYou might be able to slightly simplify eltoo (or conceivably some parts of\ncurrent lightning); if your eltoo update tx has as it's output [musig(A,B)\nor (n+1 cltv checksig) or (d CSV COHV(balances))] then your settlement\ntransaction only needs to reveal the 40B script, rather than needing a\n65B ANYPREVOUT signature.\n\nCheers,\naj"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-24T19:12:32",
                "message_text_only": "Functionally, COHV is a proper subset of ANYPREVOUT (NOINPUT). The only justification to do both is better space efficiency when making covenant.\n\nWith eltoo as a clear usecase of ANYPREVOUT, I\u2019m not sure if we really want a very restricted opcode like COHV. But these are my comments, anyway:\n\n1. The \u201cone input\u201d rule could be relaxed to \u201cfirst input\u201d rule. This allows adding more inputs as fees, as an alternative to CPFP. In case the value is insufficient to pay the required outputs, it is also possible to rescue the UTXO by adding more inputs.\n\n2. While there is no reason to use non-minimal push, there is neither a reason to require minimal push. Since minimal push is never a consensus rule, COHV shouldn\u2019t be a special case.\n\n3. As I suggested in a different post (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html>), the argument for requiring a prevout binding signature may also be applicable to COHV\n\n> On 21 May 2019, at 4:58 AM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Hello bitcoin-devs,\n> \n> Below is a link to a BIP Draft for a new opcode, OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless congestion control techniques via a rudimentary, limited form of covenant which does not bear the same technical and social risks of prior covenant designs.\n> \n> Congestion control allows Bitcoin users to confirm payments to many users in a single transaction without creating the UTXO on-chain until a later time. This therefore improves the throughput of confirmed payments, at the expense of latency on spendability and increased average block space utilization. The BIP covers this use case in detail, and a few other use cases lightly.\n> \n> The BIP draft is here:\n> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki <https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki>\n> \n> The BIP proposes to deploy the change simultaneously with Taproot as an OPSUCCESS, but it could be deployed separately if needed.\n> \n> An initial reference implementation of the consensus changes and  tests which demonstrate how to use it for basic congestion control is available at https://github.com/JeremyRubin/bitcoin/tree/congestion-control <https://github.com/JeremyRubin/bitcoin/tree/congestion-control>.  The changes are about 74 lines of code on top of sipa's Taproot reference implementation.\n> \n> Best regards,\n> \n> Jeremy Rubin\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/26541eac/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-24T20:36:03",
                "message_text_only": "Hi Johnson,\n\nThanks for the review. I do agree that OP_COSHV (note the pluralization --\nit would also be possible to do a OP_COHV <index> <hash> to do specific\noutputs).\n\nI think the point of OP_COSHV is that something like ANYPREVOUT is much\nmore controversial. OP_COSHV is a subset by design. The IF on ANYPREVOUT is\nsubstantial, discussion I've seen shows that the safety of ANYPREVOUT is\nfar from fully agreed. (I'll respond to your other email on the subject\ntoo). OP_COSHV is also proposed specifically as a congestion control\nmechanism, and so keeping it very easy to verify and minimal data\n(optimizations allow reducing it to just OP_COSHV with no 32 byte argument)\nsuggest this approach is preferable.\n\nIn an earlier version, rather than have it be the first input restriction,\nI had implemented it an an only one input restriction. This makes it easier\nto work with SIGHASH_SINGLE. This works by having the PrecomputedData have\na atomic test_flag. However I felt that the statefulness between\nverifications was not great and so I simplified it.\n\nThere actually is a reason to require minimal push -- maybe we can change\nthe rule to be non-minimal pushes are ignored, because we can later extend\nit with a different rule. This seems a little error prone. There's also no\nreason to not just treat OP_COSHV as a pushdata 32 itself, and drop the\nextra byte if we don't care about versioning later.\n\nRequiring a signature actually makes COSHV less useful. So I'm against that\n-- such a signature prevents using OP_COSHV for non-interactive\nsetups/uncoordinated setups where the txids are unstable. It also makes\nbuilding the trees more expensive. If you want this feature, a better thing\nto do would be to always tweak leaf nodes of the tx tree entropy so that\nit's unique per key and doesn't impose extra data at every node, only the\nleafs of the expansion tree.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Fri, May 24, 2019 at 12:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:\n\n> Functionally, COHV is a proper subset of ANYPREVOUT (NOINPUT). The only\n> justification to do both is better space efficiency when making covenant.\n>\n> With eltoo as a clear usecase of ANYPREVOUT, I\u2019m not sure if we really\n> want a very restricted opcode like COHV. But these are my comments, anyway:\n>\n> 1. The \u201cone input\u201d rule could be relaxed to \u201cfirst input\u201d rule. This\n> allows adding more inputs as fees, as an alternative to CPFP. In case the\n> value is insufficient to pay the required outputs, it is also possible to\n> rescue the UTXO by adding more inputs.\n>\n> 2. While there is no reason to use non-minimal push, there is neither a\n> reason to require minimal push. Since minimal push is never a consensus\n> rule, COHV shouldn\u2019t be a special case.\n>\n> 3. As I suggested in a different post (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html),\n> the argument for requiring a prevout binding signature may also be\n> applicable to COHV\n>\n> On 21 May 2019, at 4:58 AM, Jeremy via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hello bitcoin-devs,\n>\n> Below is a link to a BIP Draft for a new opcode,\n> OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless\n> congestion control techniques via a rudimentary, limited form of covenant\n> which does not bear the same technical and social risks of prior covenant\n> designs.\n>\n> Congestion control allows Bitcoin users to confirm payments to many users\n> in a single transaction without creating the UTXO on-chain until a later\n> time. This therefore improves the throughput of confirmed payments, at the\n> expense of latency on spendability and increased average block space\n> utilization. The BIP covers this use case in detail, and a few other use\n> cases lightly.\n>\n> The BIP draft is here:\n>\n> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki\n>\n> The BIP proposes to deploy the change simultaneously with Taproot as an\n> OPSUCCESS, but it could be deployed separately if needed.\n>\n> An initial reference implementation of the consensus changes and  tests\n> which demonstrate how to use it for basic congestion control is available\n> at https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The\n> changes are about 74 lines of code on top of sipa's Taproot reference\n> implementation.\n>\n> Best regards,\n>\n> Jeremy Rubin\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/d3863a38/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-25T03:56:22",
                "message_text_only": "Good morning Jeremy,\n\nI believe I have caught the general point.\nIndeed, I agree that this is useful, but it is *not* useful for these cases:\n\n1.  CoinJoin - the initial funding transaction must be signed by the participants anyway after checking that the output is correct.\n    Further any spend that is not a signature spend is going to defeat the purpose of CoinJoin trying to be private by imitating \"typical\" spends: if `OP_CHECKOUTPUTSHASHVERIFY` path is used, you have just lost the CoinJoin privacy by reducing anonymity set.\n2.  Channel Factories - the initial funding transaction must be signed by the participants anyway after each initial sub-channel initial commitment / initial update+state transaction is signed.\n\nIn both above cases, the issue of users dropping out during the step of signing the initial funding transaction is unavoidable even with `OP_CHECKOUTPUTSHASHVERIFY`.\n\nFor congestion control, and for general \"I promise to set this up later\" as in c*stodial-service-directly-to-channel etc., I already agree this is useful.\n\nMy objection lies *only* with the above two cases, wherein `OP_CHECKOUTPUTSHASHVERIFY` does not really improve things, as you *still* need to coordinate multiple signers anyway.\n\nYou have convinced me already that the other cases are good example usages of this opcode.\n\nRegards,\nZmnSCPxj\n\n\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Saturday, May 25, 2019 5:15 AM, Jeremy <jlrubin at mit.edu> wrote:\n\n> ZmnSCIPxj,\n>\n> I think you're missing the general point, so I'm just going to respond to one point to see if that helps your understanding of why OP_COSHV is better than just pre-signed.\n>\n> The reason why MuSig and other distributed signing solutions are not acceptable for this case is they all require interaction for guarantee of payout.\n>\n> In contrast, I can use a OP_COSHV Taproot key to request a withdrawal from an exchange which some time later pays out to a lot of people, rather than having to withdraw multiple times and then pay. The exchange doesn't have to know this is what I did. They also don't have to tell me the exact inputs they'll spend to me or if I'm batched or not (batching largely incompatible with pre-signing unless anyprevout)\n>\n> The exchange can take my withdrawal request and aggregate it to other payees into a tree as well, without requiring permission from the recipients.\n>\n> They can also -- without my permission -- make the payment not directly into me, but into a payment channel between me and the exchange, allowing me to undo the withdrawal by routing money back to the exchange over lightning.\n>\n> The exchange can take some inbound payments to their hot wallet and move them into cold storage with pre-set spending paths. They don't need to use ephemeral keys (how was that entropy created?) nor do they need to bring on their cold storage keys to pre-sign the spending paths.\n>\n> None of this really works well with just pre-signing because you need to ask for permission first in order to do these operations, but with OP_COSHV you can, just as the payer without talking to anyone else, or just as the recipient commit your funds to a complex txn structure.\n>\n> Lastly, think about this in terms of DoS. You have a set of N users who request a payment. You build the tree, collect signatures, and then at the LAST step of building the tree, one user drops out. You restart, excluding that user. Then a different user drops. Meanwhile you've had to keep your funds locked up to guarantee those inputs for the txn when it finalizes.\n>\n> In contrast, once you receive the requests with OP_COSHV, there's nothing else to do. You just issue the transaction and move on.\n>\n> Does that make sense as to why a user would prefer this, even if there is an emulation with pre-signed txns?"
            }
        ],
        "thread_summary": {
            "title": "Congestion Control via OP_CHECKOUTPUTSHASHVERIFY proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Anthony Towns",
                "Johnson Lau",
                "ZmnSCPxj",
                "Matt Corallo"
            ],
            "messages_count": 13,
            "total_messages_chars_count": 38951
        }
    },
    {
        "title": "[bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) without an oracle and 3rd party.",
        "thread_messages": [
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T17:42:35",
                "message_text_only": "Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\nCommodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n\nI think we could do much better than them natively within Bitcoin.\n\nA better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\nA new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into. \nThe output script may then decide comparing that value with a strike which key can spend it. \nThe input of the transaction would be a multi-sig escrow of those who entered the bet. \nThe winner would broadcast. \n\nOnce signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n\nI plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n\nDo you see a fault in this proposal or want to contribute?\n\nTamas Blummer"
            },
            {
                "author": "Jorge Tim\u00f3n",
                "date": "2019-05-23T19:03:09",
                "message_text_only": "The complains I could imagine about this, (apart from being a very\nspecific use case) are the same complains I heard about op_expiry.\nNamely, that in a reorg, the same tx, having been valid in a given\nblock could potentially become invalid in some other block mining it.\nI guess in this case the situation is less likely in this case than\nwith op_expiry, but it is still possible.\nAnother complain I could imagine is this kind of forces the\nimplementation to break some existing encapsulations, but I guess\nthose are just implementation details not that relevant here.\nI personally don't have strong feelings towards this proposal one way\nor the other, I'm just imagining what other people may complain about.\n\nOn Thu, May 23, 2019 at 8:33 PM Tamas Blummer via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>\n> I think we could do much better than them natively within Bitcoin.\n>\n> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n> The output script may then decide comparing that value with a strike which key can spend it.\n> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n> The winner would broadcast.\n>\n> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n>\n> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>\n> Do you see a fault in this proposal or want to contribute?\n>\n> Tamas Blummer\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T19:10:53",
                "message_text_only": "The parameter used is property of the block just like the block height is a property and is already evaluated in scripts,\nso no new kind of dependency or encapsulation break.\n\nThe transaction itself was not invalid in a re-org but evtl. others spending it if the difficulty on that fork is different,\nthis is however intended as then on that fork the other was the winner.\n\nTamas Blummer\n\n> On May 23, 2019, at 21:03, Jorge Tim\u00f3n <jtimon at jtimon.cc> wrote:\n> \n> The complains I could imagine about this, (apart from being a very\n> specific use case) are the same complains I heard about op_expiry.\n> Namely, that in a reorg, the same tx, having been valid in a given\n> block could potentially become invalid in some other block mining it.\n> I guess in this case the situation is less likely in this case than\n> with op_expiry, but it is still possible.\n> Another complain I could imagine is this kind of forces the\n> implementation to break some existing encapsulations, but I guess\n> those are just implementation details not that relevant here.\n> I personally don't have strong feelings towards this proposal one way\n> or the other, I'm just imagining what other people may complain about.\n> \n> On Thu, May 23, 2019 at 8:33 PM Tamas Blummer via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>> \n>> I think we could do much better than them natively within Bitcoin.\n>> \n>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n>> The output script may then decide comparing that value with a strike which key can spend it.\n>> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n>> The winner would broadcast.\n>> \n>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n>> \n>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>> \n>> Do you see a fault in this proposal or want to contribute?\n>> \n>> Tamas Blummer\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/c2fb6e5b/attachment.sig>"
            },
            {
                "author": "Nathan Cook",
                "date": "2019-05-23T19:05:02",
                "message_text_only": "You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke\nDashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki)\nif you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN.\nSee\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html\nand\nthe ensuing thread.\n\nNathan Cook\n\n\nOn Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Difficulty change has profound impact on miner\u2019s production thereby\n> introduce the biggest risk while considering an investment.\n> Commodity markets offer futures and options to hedge risks on traditional\n> trading venues. Some might soon list difficulty futures.\n>\n> I think we could do much better than them natively within Bitcoin.\n>\n> A better solution could be a transaction that uses nLocktime denominated\n> in block height, such that it is valid after the difficulty adjusted block\n> in the future.\n> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty\n> for the block the transaction is included into.\n> The output script may then decide comparing that value with a strike which\n> key can spend it.\n> The input of the transaction would be a multi-sig escrow of those who\n> entered the bet.\n> The winner would broadcast.\n>\n> Once signed by both the transaction would not carry any counterparty risk\n> and would not need an oracle to settle according to the bet.\n>\n> I plan to draft a BIP for this as I think this opcode would serve\n> significant economic interest of Bitcoin economy, and is compatible with\n> Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>\n> Do you see a fault in this proposal or want to contribute?\n>\n> Tamas Blummer\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/3cb49dd5/attachment-0001.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T19:18:06",
                "message_text_only": "That opcode would not help as it fetches block hash and not the content of the header.\n\n> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:\n> \n> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki <https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki>) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html> and the ensuing thread.\n> \n> Nathan Cook\n> \n> \n> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n> \n> I think we could do much better than them natively within Bitcoin.\n> \n> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n> The output script may then decide comparing that value with a strike which key can spend it.\n> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n> The winner would broadcast.\n> \n> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n> \n> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n> \n> Do you see a fault in this proposal or want to contribute?\n> \n> Tamas Blummer\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/e41fcfc1/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/e41fcfc1/attachment.sig>"
            },
            {
                "author": "Nathan Cook",
                "date": "2019-05-23T19:21:39",
                "message_text_only": "It's true that it fetches the block hash; the idea is to compare the block\nhash's numeric value to the desired (uncompressed) difficulty directly,\nusing a 256-bit version of OP_LESSTHAN.\n\nNathan Cook\n\n\nOn Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n\n> That opcode would not help as it fetches block hash and not the content of\n> the header.\n>\n> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:\n>\n> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke\n> Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki)\n> if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN.\n> See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and\n> the ensuing thread.\n>\n> Nathan Cook\n>\n>\n> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Difficulty change has profound impact on miner\u2019s production thereby\n>> introduce the biggest risk while considering an investment.\n>> Commodity markets offer futures and options to hedge risks on traditional\n>> trading venues. Some might soon list difficulty futures.\n>>\n>> I think we could do much better than them natively within Bitcoin.\n>>\n>> A better solution could be a transaction that uses nLocktime denominated\n>> in block height, such that it is valid after the difficulty adjusted block\n>> in the future.\n>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty\n>> for the block the transaction is included into.\n>> The output script may then decide comparing that value with a strike\n>> which key can spend it.\n>> The input of the transaction would be a multi-sig escrow of those who\n>> entered the bet.\n>> The winner would broadcast.\n>>\n>> Once signed by both the transaction would not carry any counterparty risk\n>> and would not need an oracle to settle according to the bet.\n>>\n>> I plan to draft a BIP for this as I think this opcode would serve\n>> significant economic interest of Bitcoin economy, and is compatible with\n>> Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>>\n>> Do you see a fault in this proposal or want to contribute?\n>>\n>> Tamas Blummer\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/af280d71/attachment-0001.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T19:45:58",
                "message_text_only": "I see. The uncompressing needs to be done either to compare. How are chances for that BIP?\n\nThis BIP would be explicitly offering risk managment of miners biggest risk.\nDoing so without relying on external markets or oracle, self cointained would be an impressive and adequate feature.\n\nTamas Blummer\n\n> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:\n> \n> It's true that it fetches the block hash; the idea is to compare the block hash's numeric value to the desired (uncompressed) difficulty directly, using a 256-bit version of OP_LESSTHAN.\n> \n> Nathan Cook\n> \n> \n> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> That opcode would not help as it fetches block hash and not the content of the header.\n> \n>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:\n>> \n>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and the ensuing thread.\n>> \n>> Nathan Cook\n>> \n>> \n>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>> \n>> I think we could do much better than them natively within Bitcoin.\n>> \n>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n>> The output script may then decide comparing that value with a strike which key can spend it.\n>> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n>> The winner would broadcast.\n>> \n>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n>> \n>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>> \n>> Do you see a fault in this proposal or want to contribute?\n>> \n>> Tamas Blummer\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/ac6e377c/attachment.sig>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T19:54:43",
                "message_text_only": "Block hash can suggest much higher difficulty than what is in effect, so OP_CHECKBLOCKATHEIGHT would not work to decide if difficulty is above the level of the bet.\n\n> On May 23, 2019, at 21:45, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n> \n> I see. The uncompressing needs to be done either to compare. How are chances for that BIP?\n> \n> This BIP would be explicitly offering risk managment of miners biggest risk.\n> Doing so without relying on external markets or oracle, self cointained would be an impressive and adequate feature.\n> \n> Tamas Blummer\n> \n>> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:\n>> \n>> It's true that it fetches the block hash; the idea is to compare the block hash's numeric value to the desired (uncompressed) difficulty directly, using a 256-bit version of OP_LESSTHAN.\n>> \n>> Nathan Cook\n>> \n>> \n>> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n>> That opcode would not help as it fetches block hash and not the content of the header.\n>> \n>>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:\n>>> \n>>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and the ensuing thread.\n>>> \n>>> Nathan Cook\n>>> \n>>> \n>>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n>>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>>> \n>>> I think we could do much better than them natively within Bitcoin.\n>>> \n>>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n>>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n>>> The output script may then decide comparing that value with a strike which key can spend it.\n>>> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n>>> The winner would broadcast.\n>>> \n>>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n>>> \n>>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n>>> \n>>> Do you see a fault in this proposal or want to contribute?\n>>> \n>>> Tamas Blummer\n>>> \n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> \n> \n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/7a642174/attachment.sig>"
            },
            {
                "author": "Nathan Cook",
                "date": "2019-05-23T20:07:30",
                "message_text_only": "You're right, I didn't remember the whole procedure. You provide the\n80-byte header in the spend script, duplicate it on the stack, hash it, and\ncompare to what OP_CHECKBLOCKATHEIGHT gives you. Then you do bit masking on\nthe header with OP_AND to extract the difficulty. You can compare two\ncompressed difficulties directly by using more bit masking to separate the\nexponent and mantissa.\n\nOn Thu, 23 May 2019 at 22:54, Tamas Blummer <tamas.blummer at gmail.com> wrote:\n\n> Block hash can suggest much higher difficulty than what is in effect, so\n> OP_CHECKBLOCKATHEIGHT would not work to decide if difficulty is above the\n> level of the bet.\n>\n> > On May 23, 2019, at 21:45, Tamas Blummer <tamas.blummer at gmail.com>\n> wrote:\n> >\n> > I see. The uncompressing needs to be done either to compare. How are\n> chances for that BIP?\n> >\n> > This BIP would be explicitly offering risk managment of miners biggest\n> risk.\n> > Doing so without relying on external markets or oracle, self cointained\n> would be an impressive and adequate feature.\n> >\n> > Tamas Blummer\n> >\n> >> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:\n> >>\n> >> It's true that it fetches the block hash; the idea is to compare the\n> block hash's numeric value to the desired (uncompressed) difficulty\n> directly, using a 256-bit version of OP_LESSTHAN.\n> >>\n> >> Nathan Cook\n> >>\n> >>\n> >> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com>\n> wrote:\n> >> That opcode would not help as it fetches block hash and not the content\n> of the header.\n> >>\n> >>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:\n> >>>\n> >>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by\n> Luke Dashjr (\n> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you\n> also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html\n> and the ensuing thread.\n> >>>\n> >>> Nathan Cook\n> >>>\n> >>>\n> >>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>> Difficulty change has profound impact on miner\u2019s production thereby\n> introduce the biggest risk while considering an investment.\n> >>> Commodity markets offer futures and options to hedge risks on\n> traditional trading venues. Some might soon list difficulty futures.\n> >>>\n> >>> I think we could do much better than them natively within Bitcoin.\n> >>>\n> >>> A better solution could be a transaction that uses nLocktime\n> denominated in block height, such that it is valid after the difficulty\n> adjusted block in the future.\n> >>> A new OP_DIFFICULTY opcode would put onto stack the value of\n> difficulty for the block the transaction is included into.\n> >>> The output script may then decide comparing that value with a strike\n> which key can spend it.\n> >>> The input of the transaction would be a multi-sig escrow of those who\n> entered the bet.\n> >>> The winner would broadcast.\n> >>>\n> >>> Once signed by both the transaction would not carry any counterparty\n> risk and would not need an oracle to settle according to the bet.\n> >>>\n> >>> I plan to draft a BIP for this as I think this opcode would serve\n> significant economic interest of Bitcoin economy, and is compatible with\n> Bitcoin\u2019s aim not to introduce 3rd party to do so.\n> >>>\n> >>> Do you see a fault in this proposal or want to contribute?\n> >>>\n> >>> Tamas Blummer\n> >>>\n> >>> _______________________________________________\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n> >\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/d5bd334b/attachment-0001.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-05-23T19:45:37",
                "message_text_only": "On Thu, 23 May 2019 at 11:33, Tamas Blummer via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>\n> I think we could do much better than them natively within Bitcoin.\n>\n> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n> The output script may then decide comparing that value with a strike which key can spend it.\n> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n> The winner would broadcast.\n\nIf the difficulty can be directly observed by the script language, you\nwould need to re-evaluate all scripts in unconfirmed transactions\nwhenever the difficulty changes. This complicates implementation of\nmempools, but it also makes reasoning about validity of (chains of)\nunconfirmed transactions harder, as an unconfirmed predecessor may\nhave conditions that change over time.\n\nFor things like block time/height, this is solved by not having the\nscript itself observe the context state directly, but instead having\nan assertion on the state outside of script (nLockTime for absolute\ntime/height and nSequence for relative), and then having opcodes\ninside script that observe the assertion (OP_CLTV and OP_CSV). By\ndoing so, script validity is a single context-free yes or not that can\nbe evaluated once, and the variable part is just transaction-level\nreasoning that doesn't involve a full script interpreter.\nAdditionally, the supported assertions are restricted in such a way\nthat if they are true within a particular block, they're also true in\nany descendant, removing the complexity of reasoning about validity\n(apart from the inevitable reasoning about possible double-spend\nbefore confirmation).\n\nI feel a similar construction is needed for observing block\ndifficulty. This can be done by either having an opcode that as a side\neffect of execution \"posts\" an assertion (e.g. \"difficulty at block\nheight X is at least Y\"), instead of putting the difficulty on the\nstack. An alternative is having the assertion be part of the\ntransaction structure (for example in the annex we propose in\nbip-taproot), and having an opcode that observes the difficulty\nassertion inside script.\n\nI don't have a strong opinion either way on the usefulness of having\ndifficulty-dependent transaction/scripts.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-23T20:26:49",
                "message_text_only": "> On May 23, 2019, at 21:45, Pieter Wuille <pieter.wuille at gmail.com> wrote:\n> \n> On Thu, 23 May 2019 at 11:33, Tamas Blummer via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n>> \n>> I think we could do much better than them natively within Bitcoin.\n>> \n>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.\n>> The output script may then decide comparing that value with a strike which key can spend it.\n>> The input of the transaction would be a multi-sig escrow of those who entered the bet.\n>> The winner would broadcast.\n> \n> If the difficulty can be directly observed by the script language, you\n> would need to re-evaluate all scripts in unconfirmed transactions\n> whenever the difficulty changes. This complicates implementation of\n> mempools, but it also makes reasoning about validity of (chains of)\n> unconfirmed transactions harder, as an unconfirmed predecessor may\n> have conditions that change over time.\n> \n> For things like block time/height, this is solved by not having the\n> script itself observe the context state directly, but instead having\n> an assertion on the state outside of script (nLockTime for absolute\n> time/height and nSequence for relative), and then having opcodes\n> inside script that observe the assertion (OP_CLTV and OP_CSV). By\n> doing so, script validity is a single context-free yes or not that can\n> be evaluated once, and the variable part is just transaction-level\n> reasoning that doesn't involve a full script interpreter.\n> Additionally, the supported assertions are restricted in such a way\n> that if they are true within a particular block, they're also true in\n> any descendant, removing the complexity of reasoning about validity\n> (apart from the inevitable reasoning about possible double-spend\n> before confirmation).\n> \n> I feel a similar construction is needed for observing block\n> difficulty. This can be done by either having an opcode that as a side\n> effect of execution \"posts\" an assertion (e.g. \"difficulty at block\n> height X is at least Y\"), instead of putting the difficulty on the\n> stack. An alternative is having the assertion be part of the\n> transaction structure (for example in the annex we propose in\n> bip-taproot), and having an opcode that observes the difficulty\n> assertion inside script.\n\nThanks for these suggestions I will follow up while preparing the BIP.\n\n> \n> I don't have a strong opinion either way on the usefulness of having\n> difficulty-dependent transaction/scripts.\n> \n\nThis is the best reception I could have hoped for :)\n\n> Cheers,\n> \n> --\n> Pieter\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/9b03f58a/attachment.sig>"
            },
            {
                "author": "Natanael",
                "date": "2019-05-24T08:36:14",
                "message_text_only": "On Thu, May 23, 2019 at 9:58 PM Pieter Wuille via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If the difficulty can be directly observed by the script language, you\n> would need to re-evaluate all scripts in unconfirmed transactions\n> whenever the difficulty changes. This complicates implementation of\n> mempools, but it also makes reasoning about validity of (chains of)\n> unconfirmed transactions harder, as an unconfirmed predecessor may\n> have conditions that change over time.\n\n\nTo deal with potentially wildly varying difficulty, could the value exposed\nbe the sum of accumulated PoW, or in other words the sum of each block's\ndifficulty value in the entire chain? This should be a value that will only\nrise unless a reorg happens after a difficulty drop happens (only likely to\nbe the result of users manually blacklisting an otherwise valid block that\nis several blocks back in the chain).\n\nThis mimics the effect of the block number which only grows. So if you're\nstarting at time A with difficulty X, then you'd estimate what you think\nthe accumulated PoW ought to be at time B with expected difficulty Y (as\ncompared to the current value at time A), and put that value into the\nscript.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/2cdfd6bc/attachment.html>"
            },
            {
                "author": "Tamas Blummer",
                "date": "2019-05-24T16:23:38",
                "message_text_only": "yes, log2work is already computed and would be a strictly increasing value, like time. Thank you for this suggestion. I think attempting an implementation will give further clues it this more suitable to express the same.\n\nTamas Blummer\n\n> On May 24, 2019, at 10:36, Natanael <natanael.l at gmail.com> wrote:\n> \n> On Thu, May 23, 2019 at 9:58 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n> If the difficulty can be directly observed by the script language, you\n> would need to re-evaluate all scripts in unconfirmed transactions\n> whenever the difficulty changes. This complicates implementation of\n> mempools, but it also makes reasoning about validity of (chains of)\n> unconfirmed transactions harder, as an unconfirmed predecessor may\n> have conditions that change over time.\n> \n> To deal with potentially wildly varying difficulty, could the value exposed be the sum of accumulated PoW, or in other words the sum of each block's difficulty value in the entire chain? This should be a value that will only rise unless a reorg happens after a difficulty drop happens (only likely to be the result of users manually blacklisting an otherwise valid block that is several blocks back in the chain).\n> \n> This mimics the effect of the block number which only grows. So if you're starting at time A with difficulty X, then you'd estimate what you think the accumulated PoW ought to be at time B with expected difficulty Y (as compared to the current value at time A), and put that value into the script.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/5d92fa56/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/5d92fa56/attachment.sig>"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-24T08:15:45",
                "message_text_only": "A gamble like this, decentralised or not, is easy to manipulate since difficulty is determined entirely by the last block in a cycle\n\n> On 24 May 2019, at 1:42 AM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> Difficulty change has profound impact on miner\u2019s production thereby introduce the biggest risk while considering an investment.\n> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.\n> \n> I think we could do much better than them natively within Bitcoin.\n> \n> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.\n> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into. \n> The output script may then decide comparing that value with a strike which key can spend it. \n> The input of the transaction would be a multi-sig escrow of those who entered the bet. \n> The winner would broadcast. \n> \n> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.\n> \n> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin\u2019s aim not to introduce 3rd party to do so.\n> \n> Do you see a fault in this proposal or want to contribute?\n> \n> Tamas Blummer \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "OP_DIFFICULTY to enable difficulty hedges (bets) without an oracle and 3rd party.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tamas Blummer",
                "Natanael",
                "Nathan Cook",
                "Johnson Lau",
                "Jorge Tim\u00f3n",
                "Pieter Wuille"
            ],
            "messages_count": 14,
            "total_messages_chars_count": 35807
        }
    },
    {
        "title": "[bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2019-05-22T21:01:21",
                "message_text_only": "Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and\nOP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for\nBitcoin via new Script operations.  However, I think that these proposals\nmiss the mark when it comes to how they approach Bitcoin Script and\nlanguage features.\n\nBitcoin Script appears designed to be a flexible programmable system that\nprovides generic features to be composed to achieve various purposes.\nThus, when we design new language features for Script, we should be\nstriving, as much as possible, to similarly build general purpose tools\nwhich can in turn be used for a variety of purposes.\n\nI feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail\nto achieve these design goals.  They are both are designed with very narrow\napplications in mind, while also going out of their way to extend the\nsemantic domain of the interpretation of Bitcoin operations in new ways\nthat complicate their specification.  In the case of SIGHASH_ANYPREVOUT,\nthe semantic domain is extended by adding new counters to track the use of\nvarious v0 and v2 signature types.  In the case of\nOP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that\npeeks at the value of surrounding opcodes.\n\nInstead, I propose that, for the time being, we simply implement OP_CAT and\nOP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack and\npushes their concatenation back onto the stack.  OP_CHECKSIGFROMSTACKVERIFY\npops a signature, message, and pubkey off the stack and performs a\nbip-schnorr verification on the SHA256 hash of the message.\n\nIn concert, these two operations enable:\n\n* Oracle signature verification, including discrete log contracts.\n* Amortized secure multiparty computations (see \"Amortizing Secure\nComputation with Penalties\" by Kumaresan and Bentov).\n* Transaction introspection including:\n+ Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by\nthe nature of the construction.\n+ Decide if a transaction has exactly one input or not. (etc.)\n+ Weak covenants, which can verify output scripts to see if they are among\na set of predefined values or verify the output hash.\n\nand presumably more applications as well.\n\nFor better or for worse, without an OP_PUBKEYTWEEK operation available, the\nmore interesting recursive-covenants remain largely out of reach, with the\nexception of a recursive covenant that is only able to send back to its own\naddress, possibly abusing its own TXO value as a state variable.\n\nAll this is accomplished by two straightforward opcodes whose semantics are\npure computational operations on stack values.  The only semantic\nside-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the\nexisting 'sigops_passed' count.  Moreover, I feel that adding these\noperations does not preclude adding more specialized opcodes in the future\nas an optimization for whatever popular constructions come up, once we know\nwhat those are.\n\nI feel that this style of generic building blocks truly embodies what is\nmeant by \"programmable money\".\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/4a09c076/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-23T16:59:15",
                "message_text_only": "Good morning Russell,\n\nWhile I am sympathetic to this argument from first principles, as I understand it, it requires that provided witness inputs will become larger, compared to \"shortcuts\" like `SIGHASH_ANYPREVOUT` and `OP_CHECKOUTPUTSHASHVERIFY`.\n\nFor instance, to simulate `SIGHASH_ANYPREVOUT` with `OP_CAT` and `OP_CHECKSIGFROMSTACK`, I would effectively split the unsigned transaction into its \"inputs\" and \"outputs\" part, concat them and use `OP_CHECKSIGFROMSTACK` on the chaperone signature, and also use a normal `OP_CHECKSIGVERIFY` on that same chaperone signature, then dup the \"outputs\" part and use `OP_CHECKSIGFROMSTACK` on the \"any prevout\"/\"noinput\" signature.\nI would effectively give the transaction to itself as part of the witness, and further, I would also have to very carefully write the script (admittedly the writing of the template could be done once, but it would require far more review than simple usages of the \"limited\" operations like `SIGHASH_ANYPREVOUT`).\nSo my witness stack would contain two signatures, and a duplicate of the transaction itself, plus a very much complicated script, whereas use of `SIGHASH_ANYPREVOUT` just requires two signatures and a script not much longer than pre-Schnorr multisig scripts.\n\n\nIt seems to me desirable, to try to reduce bandwidth consumption on the Bitcoin blockchain, including witness data.\nIndeed, I had thought the whole exercise of putting `OP_CHECKSIGFROMSTACK` in a federated sidechain (Elements/Liquid) was to try to identify common patterns of usage for that opcode, and *then* to propose those common patterns as specific \"optimized\" opcodes as a sort of \"jet\" for Bitcoin itself (but not `OP_CHECKSIGFROMSTACK` itself).\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, May 23, 2019 5:01 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.\u00a0 However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.\n>\n> Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.\u00a0 Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.\n>\n> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.\u00a0 They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.\u00a0 In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.\u00a0 In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.\n>\n> Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.\u00a0 OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.\u00a0 OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.\n>\n> In concert, these two operations enable:\n>\n> * Oracle signature verification, including discrete log contracts.\n> * Amortized secure multiparty computations (see \"Amortizing Secure Computation with Penalties\" by Kumaresan and Bentov).\n> * Transaction introspection including:\n> +\u00a0Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.\n> + Decide if a transaction has exactly one input or not. (etc.)\n> + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.\n>\n> and presumably more applications as well.\n>\n> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.\n>\n> All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.\u00a0 The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.\u00a0 Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.\n>\n> I feel that this style of generic building blocks truly embodies what is meant by \"programmable money\"."
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-23T22:06:45",
                "message_text_only": "Hello ZmnSCPxj,\n\nI agree that adding OP_CHECKSIGFROMSTACK doesn't preclude adding shortcuts\nsuch as `SIGHASH_ANYPREVOUT` and `OP_CHECKOUTPUTSHASHVERIFY`, and I agree\nwe ought to support such operations directly, especially if we see\nwidespread use of these constructions in practice.\n\nI think it is desirable to add OP_CHECKSIGFROMSTACK for its direct purposes\nof enabling oracle verification and discreet log contracts.  Moreover, it\nwould be better decide if we do or do not want to do this first, because\nwhether or not we chose to implement a general OP_CHECKSIGFROMSTACK will\ninfluence the design of these other proposals.\n\nFor example, if we choose to deploy OP_CHECKSIGFROMSTACK, then the design\nof OP_CHECKOUTPUTSHASHVERIFY ought to be simplified to OP_PUSHOUTPUTHASH\nand OP_PUSHNUMINPUTS (etc.) because the proposal would no longer be\nextending the expressiveness of Bitcoin Script.  And while\nOP_CHECKSIGFROMSTACK doesn't directly address whether SIGHASH_ANYPREVOUT\nshould be with or without a chaperone (as the simulated version with\nOP_CHECKSIGFROMSTACK is necessarily chaperoned), we might get an\nopportunity to learn if users are willing to take advantage of the\nchaperone, or whether they rather bypass it by using a short well-known\npubkey: (e.g.\n0x0200000000000000000000003b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63)\nand/or similar short signatures if we deploy OP_CHECKSIGFROMSTACK first.\n\nSince most of the \"scary\" recursive convents are not available with\nOP_CHECKSIGFROMSTACK within taproot (without further extensions), the\nOP_CHECKSIGFROMSTACK proposal now has quite different consequences than\nbefore.\n\nOn Thu, May 23, 2019 at 12:59 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Russell,\n>\n> While I am sympathetic to this argument from first principles, as I\n> understand it, it requires that provided witness inputs will become larger,\n> compared to \"shortcuts\" like `SIGHASH_ANYPREVOUT` and\n> `OP_CHECKOUTPUTSHASHVERIFY`.\n>\n> For instance, to simulate `SIGHASH_ANYPREVOUT` with `OP_CAT` and\n> `OP_CHECKSIGFROMSTACK`, I would effectively split the unsigned transaction\n> into its \"inputs\" and \"outputs\" part, concat them and use\n> `OP_CHECKSIGFROMSTACK` on the chaperone signature, and also use a normal\n> `OP_CHECKSIGVERIFY` on that same chaperone signature, then dup the\n> \"outputs\" part and use `OP_CHECKSIGFROMSTACK` on the \"any\n> prevout\"/\"noinput\" signature.\n> I would effectively give the transaction to itself as part of the witness,\n> and further, I would also have to very carefully write the script\n> (admittedly the writing of the template could be done once, but it would\n> require far more review than simple usages of the \"limited\" operations like\n> `SIGHASH_ANYPREVOUT`).\n> So my witness stack would contain two signatures, and a duplicate of the\n> transaction itself, plus a very much complicated script, whereas use of\n> `SIGHASH_ANYPREVOUT` just requires two signatures and a script not much\n> longer than pre-Schnorr multisig scripts.\n>\n>\n> It seems to me desirable, to try to reduce bandwidth consumption on the\n> Bitcoin blockchain, including witness data.\n> Indeed, I had thought the whole exercise of putting `OP_CHECKSIGFROMSTACK`\n> in a federated sidechain (Elements/Liquid) was to try to identify common\n> patterns of usage for that opcode, and *then* to propose those common\n> patterns as specific \"optimized\" opcodes as a sort of \"jet\" for Bitcoin\n> itself (but not `OP_CHECKSIGFROMSTACK` itself).\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/1d4853e6/attachment-0001.html>"
            },
            {
                "author": "Jimmy Song",
                "date": "2019-05-23T17:36:19",
                "message_text_only": "Hi Russell,\n\nThis is probably a dumb question, but I'd like to get some clarity on your\nproposal.\n\nOP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey.\nPresumably, the message would then have to get constructed as part of the\nScript execution. What would such a message look like? What, in other\nwords, would you be signing and would that be similar to what signatures\nsign now? Would it be a single blob that incorporates all the input/output\ninformation in some hashed manner (like BIP143)? Or would you need separate\nsignatures for different parts of the transaction? Or is it something more\ncomplicated like aggregating multiple signatures over different parts of\nthe transaction?\n\nBest,\n\nJimmy\n\nOn Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and\n> OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for\n> Bitcoin via new Script operations.  However, I think that these proposals\n> miss the mark when it comes to how they approach Bitcoin Script and\n> language features.\n>\n> Bitcoin Script appears designed to be a flexible programmable system that\n> provides generic features to be composed to achieve various purposes.\n> Thus, when we design new language features for Script, we should be\n> striving, as much as possible, to similarly build general purpose tools\n> which can in turn be used for a variety of purposes.\n>\n> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail\n> to achieve these design goals.  They are both are designed with very narrow\n> applications in mind, while also going out of their way to extend the\n> semantic domain of the interpretation of Bitcoin operations in new ways\n> that complicate their specification.  In the case of SIGHASH_ANYPREVOUT,\n> the semantic domain is extended by adding new counters to track the use of\n> various v0 and v2 signature types.  In the case of\n> OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that\n> peeks at the value of surrounding opcodes.\n>\n> Instead, I propose that, for the time being, we simply implement OP_CAT\n> and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack\n> and pushes their concatenation back onto the stack.\n> OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the\n> stack and performs a bip-schnorr verification on the SHA256 hash of the\n> message.\n>\n> In concert, these two operations enable:\n>\n> * Oracle signature verification, including discrete log contracts.\n> * Amortized secure multiparty computations (see \"Amortizing Secure\n> Computation with Penalties\" by Kumaresan and Bentov).\n> * Transaction introspection including:\n> + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply\n> by the nature of the construction.\n> + Decide if a transaction has exactly one input or not. (etc.)\n> + Weak covenants, which can verify output scripts to see if they are among\n> a set of predefined values or verify the output hash.\n>\n> and presumably more applications as well.\n>\n> For better or for worse, without an OP_PUBKEYTWEEK operation available,\n> the more interesting recursive-covenants remain largely out of reach, with\n> the exception of a recursive covenant that is only able to send back to its\n> own address, possibly abusing its own TXO value as a state variable.\n>\n> All this is accomplished by two straightforward opcodes whose semantics\n> are pure computational operations on stack values.  The only semantic\n> side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the\n> existing 'sigops_passed' count.  Moreover, I feel that adding these\n> operations does not preclude adding more specialized opcodes in the future\n> as an optimization for whatever popular constructions come up, once we know\n> what those are.\n>\n> I feel that this style of generic building blocks truly embodies what is\n> meant by \"programmable money\".\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/28a9b6e8/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-23T22:00:59",
                "message_text_only": "Hi Jimmy,\n\nThe message could really be anything.  For example, in discreet log\ncontracts, AFAIU, you might have a specific public key from a trusted third\nparty (the Oracle) that is signs the closing price of corn in BTC on\n2019-05-23 with a particular nonce dedicated to that product-date pair, in\nwhich case the message would be the price expressed in binary.  In the case\nof amortized secure multiparty computations, the message is protocol\nspecific binary data that consists of a counter (or counters), concatenated\nwith shares of secret data that is used to construct the result of the\nmultiparty computation.  In the case of transaction reflection, the message\nwould be a duplicate copy of the tapscript signed transaction data (about\n244 bytes of data plus a 64 byte prefix).\n\nAs you note, the message is likely to constructed from a value computed\nfrom a mix of witness and committed data, though the message might be pure\nwitness data, as in the discreet log contract example.  In that the\ndiscreet log contract example, you'd probably duplicate the integer value\nand do further processing (e.g. compare it to some other committed value).\n\nOn Thu, May 23, 2019 at 1:36 PM Jimmy Song <jaejoon at gmail.com> wrote:\n\n> Hi Russell,\n>\n> This is probably a dumb question, but I'd like to get some clarity on your\n> proposal.\n>\n> OP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey.\n> Presumably, the message would then have to get constructed as part of the\n> Script execution. What would such a message look like? What, in other\n> words, would you be signing and would that be similar to what signatures\n> sign now? Would it be a single blob that incorporates all the input/output\n> information in some hashed manner (like BIP143)? Or would you need separate\n> signatures for different parts of the transaction? Or is it something more\n> complicated like aggregating multiple signatures over different parts of\n> the transaction?\n>\n> Best,\n>\n> Jimmy\n>\n> On Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and\n>> OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for\n>> Bitcoin via new Script operations.  However, I think that these proposals\n>> miss the mark when it comes to how they approach Bitcoin Script and\n>> language features.\n>>\n>> Bitcoin Script appears designed to be a flexible programmable system that\n>> provides generic features to be composed to achieve various purposes.\n>> Thus, when we design new language features for Script, we should be\n>> striving, as much as possible, to similarly build general purpose tools\n>> which can in turn be used for a variety of purposes.\n>>\n>> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail\n>> to achieve these design goals.  They are both are designed with very narrow\n>> applications in mind, while also going out of their way to extend the\n>> semantic domain of the interpretation of Bitcoin operations in new ways\n>> that complicate their specification.  In the case of SIGHASH_ANYPREVOUT,\n>> the semantic domain is extended by adding new counters to track the use of\n>> various v0 and v2 signature types.  In the case of\n>> OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that\n>> peeks at the value of surrounding opcodes.\n>>\n>> Instead, I propose that, for the time being, we simply implement OP_CAT\n>> and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack\n>> and pushes their concatenation back onto the stack.\n>> OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the\n>> stack and performs a bip-schnorr verification on the SHA256 hash of the\n>> message.\n>>\n>> In concert, these two operations enable:\n>>\n>> * Oracle signature verification, including discrete log contracts.\n>> * Amortized secure multiparty computations (see \"Amortizing Secure\n>> Computation with Penalties\" by Kumaresan and Bentov).\n>> * Transaction introspection including:\n>> + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply\n>> by the nature of the construction.\n>> + Decide if a transaction has exactly one input or not. (etc.)\n>> + Weak covenants, which can verify output scripts to see if they are\n>> among a set of predefined values or verify the output hash.\n>>\n>> and presumably more applications as well.\n>>\n>> For better or for worse, without an OP_PUBKEYTWEEK operation available,\n>> the more interesting recursive-covenants remain largely out of reach, with\n>> the exception of a recursive covenant that is only able to send back to its\n>> own address, possibly abusing its own TXO value as a state variable.\n>>\n>> All this is accomplished by two straightforward opcodes whose semantics\n>> are pure computational operations on stack values.  The only semantic\n>> side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the\n>> existing 'sigops_passed' count.  Moreover, I feel that adding these\n>> operations does not preclude adding more specialized opcodes in the future\n>> as an optimization for whatever popular constructions come up, once we know\n>> what those are.\n>>\n>> I feel that this style of generic building blocks truly embodies what is\n>> meant by \"programmable money\".\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/c505017a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-24T03:51:13",
                "message_text_only": "Good morning Jimmy,\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, May 24, 2019 1:36 AM, Jimmy Song via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Russell,\n>\n> This is probably a dumb question, but I'd like to get some clarity on your proposal.\n>\n> OP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey. Presumably, the message would then have to get constructed as part of the Script execution. What would such a message look like? What, in other words, would you be signing and would that be similar to what signatures sign now? Would it be a single blob that incorporates all the input/output information in some hashed manner (like BIP143)? Or would you need separate signatures for different parts of the transaction? Or is it something more complicated like aggregating multiple signatures over different parts of the transaction?\n\nIn order to use `OP_CHECKSIGFROMSTACK` work to allow transaction introspection, the message to be signed would be the equivalent of the sighash digest using `SIGHASH_ALL`.\n\nAs a general pattern, if you want a SCRIPT that imposes some rule on some field in the sighash digest of the transaction:\n\n1.  You would require that the transaction be split into three parts, with those parts provided in the witness stack.\n    One would be \"data before the field\", then \"the field\", then \"data after the field\".\n2.  In addition, you would require a signature for the transaction in addition to the transaction parts above.\n3.  You would ensure that \"data before the field\" is the correct size, so that you know \"the field\" is at the correct location in the transaction.\n    Alternately you might need to also introspect some other fields in order to ensure other details like number of inputs, number of outputs, value of inputs etc. etc. are what you expect.\n4.  You would check that the given signature is `SIGHASH_ALL` (most easily by checking its size --- proposed Schnorr signatures have a fixed size, and the lack of an extra sighash flags byte means `SIGHASH_ALL` by default, so if the signature is exactly the fixed Schnorr signature size, it is `SIGHASH_ALL`).\n5.  You would use normal `OP_CHECKSIGVERIFY` to ensure that the signature signs the actual transaction.\n6.  You would concatenate the supposed parts of the transaction together and use `OP_CHECKSIGFROMSTACKVERIFY` to ensure that the signature *also* is valid for that.\n    Since you know the signature is valid for the transaction itself, if it *also* is valid for this, then the concatenation of the input \"data before the field\", \"the field\", and \"data after the field\" is exactly the same sighash digest as the actual transaction, and thus is accurate to the transaction.\n7.  Finally, you would actually validate the field you want to impose some rule on.\n\n`SIGHASH_ALL` is suggested since it allows you to introspect all fields, but also because ensuring that the signature is indeed a `SIGHASH_ALL` signature is easier (just do the size check).\nAlternately you can use some other flag, but you would require the signature on the stack to be flagless and concat the flag yourself before using `OP_CHECKSIGVERIFY`.\n\nThis mechanism is very general and allows SCRIPT to introspect *any* field of the transactions.\nIndeed, one can argue that `OP_CHECKLOCKTIMEVERIFY` and `OP_CHECKSEQUENCEVERIFY` are both superfluous in a system with `OP_CAT` and `OP_CHECKSIGFROMSTACK`.\nOF course, these operations are significantly more optimized since they do not require that you quine the transaction.\n\nRegards,\nZmnSCPxj\n\n\n>\n> Best,\n>\n> Jimmy\n>\n> On Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.\u00a0 However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.\n> >\n> > Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.\u00a0 Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.\n> >\n> > I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.\u00a0 They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.\u00a0 In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.\u00a0 In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.\n> >\n> > Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.\u00a0 OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.\u00a0 OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.\n> >\n> > In concert, these two operations enable:\n> >\n> > * Oracle signature verification, including discrete log contracts.\n> > * Amortized secure multiparty computations (see \"Amortizing Secure Computation with Penalties\" by Kumaresan and Bentov).\n> > * Transaction introspection including:\n> > +\u00a0Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.\n> > + Decide if a transaction has exactly one input or not. (etc.)\n> > + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.\n> >\n> > and presumably more applications as well.\n> >\n> > For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.\n> >\n> > All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.\u00a0 The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.\u00a0 Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.\n> >\n> > I feel that this style of generic building blocks truly embodies what is meant by \"programmable money\".\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-24T04:15:45",
                "message_text_only": "> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.\n\nAfter some thinking, I may have devised a way to achieve the more interesting Turing-complete system (where each \"loop through\" requires paying a fee to miners, akin to Ethereum Gas, and thus a good way to build new footguns) even without `OP_PUBKEYTWEAK`.\n\nI observe the following:\n\n1.  `OP_CHECKSIGFROMSTACK` can introspect into the transaction *doing the spend* by giving the transaction (minus witness) as part of the witness (i.e. quining).\n2.  The above can be leveraged to introspect into the transaction *being spent* by giving that transaction *being spent* (minus witness) as part of the witness stack.\n    This is because the transaction *doing the spend* commits to the transaction *being spent* by referring to its txid.\n    We can concatenate the bits of the previous transaction and confirm that it is indeed the transaction *being spent* by hashing and comparing that to the txid in the input of the transaction *doing the spend*.\n3.  The transaction *being spent* can contain an `OP_RETURN` output that contains the previous state (or a commitment to the previous state if it is too large to fit in an `OP_RETURN`, again requiring that the previous state be given as part of the witness).\n    Since it can be introspected, a script can acquire a \"previous state\" data.\n4.  The transaction *doing the spend* can also contain an `OP_RETURN` with the next state (or commitment to next state).\n5.  The rest of the script can then determine if the transition from \"previous state\" to \"next state\" is valid.\n6.  The script can impose that the same script is paid to by introspecting the transaction *being spent* to get at a commitment to itself.\n\nThe above seems enough to create a potentially unbound loop, bound only by the amount of money you are willing to spend on fees operating that loop.\nThe \"state\" would be the memory of your virtual machine, and the SCRIPT validates the execution of one iteration of the interpreter loop, and that would be enough to create a Turing-complete system within Bitcoin.\nWith MAST, you can compress branches not taken, reducing the number of operations you have to expose at each iteration.\n\nI admit *creating* this by hand will probably be very difficult, but that should be doable with an army of lower-level cognition agents.\n(disclaimer: I am not an AI with an army of lower-level cognition agents and I can completely and totally pass the Turing test)\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-24T15:10:21",
                "message_text_only": "On Wed, May 22, 2019 at 5:01 PM Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> In concert, these two operations enable:\n>\n> * Oracle signature verification, including discrete log contracts.\n>\n\nJonas informs me that I've misunderstood how discreet log contracts work.\nThe DLC signatures are not directly checked by Script and do not rely on\nCHECKSIGFROMSTACK.  I apologize for my hasty literature review.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/ced6f553/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-24T20:51:21",
                "message_text_only": "Hi Russell,\n\nThanks for this detailed comparison. The COSHV BIP does include a brief\ncomparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more\ndetailed.\n\n\nI think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's\nclearly one of the more flexible options available and would enable a\nmultitude of new use cases.\n\nWhen I originally presented my work on congestion control at Jan 2017\nBPASE, I also discussed it as an option for covenants. Unfortunately I\nthink it may be on the edge of too powerful -- there are a lot of use cases\nand implications from having a potentially recursive covenant. If you see\nmy response to Matt in the OP_COSHV BIP thread I classify it as enabling a\nnon-computationally enumerable set of restrictions.\n\nI think also from a developer point of view working with OP_COSHV is much\nmuch simpler (maybe this can be abstracted) which will lead to increased\nadoption. OP_COSHV also uses less per-block bandwidth which also makes it\npreferable for a measure intended to decongest blocks. Do you know the\nexact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating\nchanges to taproot, can be a single byte. OP_COSHV also has less potential\nto have a negative interaction with future opcodes we may want like\nOP_PUBKEYTWEAK. While we're getting to an exact spec for the features we\nwant in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK\nunless there's an exact specification which makes us confident we're\nhitting all the points.\n\nIf the main complaint about OP_COSHV is that it peeks at surrounding data,\nit's also possible to implement it more closely to a multi-byte pushdata\nopcode or do the template optimization.\n\nLastly, as I have previously noted, OP_LEFT is probably safer to implement\nthan OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK scripts.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/77a5aad9/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2019-05-27T07:21:28",
                "message_text_only": "On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev wrote:\n> Bitcoin Script appears designed to be a flexible programmable system that\n> provides generic features to be composed to achieve various purposes.\n\nCounterpoint: haven't the flexibly designed parts of script mostly been\na failure -- requiring opcodes to be disabled due to DoS vectors or\nconsensus bugs, and mostly not being useful in practice where they're\nstill enabled in BTC or on other chains where they have been re-enabled\n(eg, Liquid and BCH)?\n\n> Instead, I propose that, for the time being, we simply implement OP_CAT and\n> OP_CHECKSIGFROMSTACKVERIFY.\n\nFWIW, I'd like to see CAT enabled, though I'm less convinced about a\nCHECKSIG that takes the message from the stack. I think CAT's plausibly\nuseful in practice, but a sig against data from the stack seems more\nuseful in theory than in practice. Has it actually seen use on BCH or\nLiquid, eg?  (Also, I think BCH's name for that opcode makes more sense\nthan Elements' -- all the CHECKSIG opcodes pull a sig from the stack,\nafter all)\n\n> * Transaction introspection including:\n> +\u00a0Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the\n> nature of the construction.\n\nI think simulating an ANYPREVOUT sig with a data signature means checking:\n\n    S1 P CHECKSIG -- to check S1 is a signature for the tx\n\n    S1 H_TapSighash(XAB) P CHECKDATASIG\n         -- to pull out the tx data \"X\", \"A\", \"B\")\n\n    S2 H_TapSighash(XCB) Q CHECKDATASIG\n         -- for the ANYPREVOUT sig, with A changed to C to\n\t    avoid committing to prevout info\n\n    X SIZE 42 EQUALVERIFY\n    B SIZE 47 EQUALVERIFY\n         -- to make sure only C is replaced from \"XCB\"\n\nSo to get all those conditions checked, I think you could do:\n\n   P 2DUP TOALT TOALT CHECKSIGVERIFY\n   SIZE 42 EQUALVERIFY\n   \"TapSighash\" SHA256 DUP CAT SWAP CAT TOALT\n   SIZE 47 EQUALVERIFY TUCK\n   CAT FROMALT TUCK SWAP CAT SHA256 FROMALT SWAP FROMALT\n   CHECKDATASIGVERIFY\n   SWAP TOALT SWAP CAT FROMALT CAT SHA256 Q CHECKDATASIG\n   \nWhere the stack elements are, from top to bottom:\n\n   S1: (65B) signature by P of tx\n   X:  (42B) start of TapSighash spec\n   B:  (47B) end of TapSighash spec (amount, nSequence, tapleaf_hash,\n             key_version, codesep_pos)\n   A:  (73B) middle of TapSighash spec dropped for ANYPREVOUT (spend_type,\n             scriptPubKey and outpoint)\n   C:   (1B) alternate middle (different spend_type)\n   S2: (64B) signature of \"XCB\" by key Q\n\nSo 298B for the witness data, and 119B or so for the script (if I've not\nmade mistakes), versus \"P CHECKSIGVERIFY Q CHECKSIG\" and S2 and S1 on\nthe stack, for 132B of witness data and 70B of script, or half that if\nthe chaperone requirement is removed.\n\nI think you'd need to complicate it a bit further to do the\nANYPREVOUTANYSCRIPT variant, where you retain the commitment to\namount/nseq but drop the commitment to tapleaf_hash.\n\n> I feel that this style of generic building blocks truly embodies what is meant\n> by \"programmable money\".\n\nFor practical purposes, this doesn't seem like a great level of\nabstraction to me. It's certainly better at \"permissionless innovation\"\nthough.\n\nYou could make these constructions a little bit simpler by having a\n\"CHECK_SIG_MSG_VERIFY\" opcode that accepts [sig msg key], and does \"sig\nkey CHECKSIGVERIFY\" but also checks the the provided msg was what was\npassed into bip-schnorr.\n\nCheers,\naj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-05-28T03:41:58",
                "message_text_only": "Sent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Monday, May 27, 2019 3:21 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev wrote:\n>\n> > Bitcoin Script appears designed to be a flexible programmable system that\n> > provides generic features to be composed to achieve various purposes.\n>\n> Counterpoint: haven't the flexibly designed parts of script mostly been\n> a failure -- requiring opcodes to be disabled due to DoS vectors or\n> consensus bugs, and mostly not being useful in practice where they're\n> still enabled in BTC or on other chains where they have been re-enabled\n> (eg, Liquid and BCH)?\n\nOne could argue that manually programming directly with `OP_CHECKSIGFROMSTACK` is difficult enough that we should really be using some compiler that (say) translates Simplicity to SCRIPT that uses `OP_CHECKSIGFROMSTACK` to implement transaction introspection.\nSo the lack of such use may point more to a lack of tools than a lack of actual use.\n\nThis extends in particular to \"lack of abstraction\"; the abstraction might be better served by implementing a pure functional language that is compiled down to `OP_CHECKSIGFROMSTACK` somehow, with the pure functional language implementing loops using the technique I described (keep current state in a separate `OP_RETURN` output, reuse the same `scriptPubKey` but modify the `OP_RETURN` output (i.e. code is `const`, data is `mutable`)).\n\nBut that still requires that we have at least a proof-of-existence in the form of some compiler that targets (say) Liquid/Elements SCRIPT and leverages `OP_CHECKSIGFROMSTACK` appropriately.\n\nI believe Russell has expressed some interest in my Smart Contracts Unchained technique to implement Simplicity on top of Bitcoin by using a semi-trusted user-selected federation to enforce Simplicity execution.\nIf implemented as such, it may be possible to then show that actual use would be enabled if it is possible to run this on Bitcoin.\n(I respect that Blockstream employees have to eat and thus made Liquid, but for example I myself would not be interested in putting any coins in Liquid, as its federation is not selected by me; I would be more willing to use a Simplicity or `OP_CHECKSIGFROMSTACK` implementation on top of Smart Contracts Unchained as at least I can select the federation to include my own hardware, and allow anyone I might want to form such contracts with to also select federation members to include my own hardware.)\n(Of course Liquid is built on Elements and Elements is open-source and in theory I could just replace its federation with my own, but having to start a new blockchain for every federation-set seems wasteful compared to Smart Contracts Unchained; Elements does have the advantage of already actually existing whereas no Smart Contracts Unchained exists at all.)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-29T06:49:29",
                "message_text_only": "On Mon, May 27, 2019 at 3:21 AM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev\n> wrote:\n> > Bitcoin Script appears designed to be a flexible programmable system that\n> > provides generic features to be composed to achieve various purposes.\n>\n> Counterpoint: haven't the flexibly designed parts of script mostly been\n> a failure -- requiring opcodes to be disabled due to DoS vectors or\n> consensus bugs, and mostly not being useful in practice where they're\n> still enabled in BTC or on other chains where they have been re-enabled\n> (eg, Liquid and BCH)?\n>\n\nYou may have a point.  However, I'm still inclined to think that problem is\nthat you want some subset of concatenation, arithmetic, CHECKDATASIG,\ntransaction reflection and/or covenants in order to create particularly\nuseful programs.\n\nA while ago, I was designing a moderately sophisticated Script for Elements\nAlpha to see if I could implement a toy game, but ultimately I was thwarted\ndue to the fact that Elements Alpha didn't support multiplication.\nI did briefly consider using repeated additions and nested if statements to\nimplement multiplication since I was expecting my numbers to be 11 or less,\nbut ultimately I decided to just continue my work on an alternative to\nScript rather than trying to work around the missing multiplication.\n\n\n> > Instead, I propose that, for the time being, we simply implement OP_CAT\n> and\n> > OP_CHECKSIGFROMSTACKVERIFY.\n>\n> FWIW, I'd like to see CAT enabled, though I'm less convinced about a\n> CHECKSIG that takes the message from the stack. I think CAT's plausibly\n> useful in practice, but a sig against data from the stack seems more\n> useful in theory than in practice. Has it actually seen use on BCH or\n> Liquid, eg?  (Also, I think BCH's name for that opcode makes more sense\n> than Elements' -- all the CHECKSIG opcodes pull a sig from the stack,\n> after all)\n>\n> > * Transaction introspection including:\n> > + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply\n> by the\n> > nature of the construction.\n>\n> I think simulating an ANYPREVOUT sig with a data signature means checking:\n>\n>     S1 P CHECKSIG -- to check S1 is a signature for the tx\n>\n>     S1 H_TapSighash(XAB) P CHECKDATASIG\n>          -- to pull out the tx data \"X\", \"A\", \"B\")\n>\n>     S2 H_TapSighash(XCB) Q CHECKDATASIG\n>          -- for the ANYPREVOUT sig, with A changed to C to\n>             avoid committing to prevout info\n>\n>     X SIZE 42 EQUALVERIFY\n>     B SIZE 47 EQUALVERIFY\n>          -- to make sure only C is replaced from \"XCB\"\n>\n> So to get all those conditions checked, I think you could do:\n>\n>    P 2DUP TOALT TOALT CHECKSIGVERIFY\n>    SIZE 42 EQUALVERIFY\n>    \"TapSighash\" SHA256 DUP CAT SWAP CAT TOALT\n>    SIZE 47 EQUALVERIFY TUCK\n>    CAT FROMALT TUCK SWAP CAT SHA256 FROMALT SWAP FROMALT\n>    CHECKDATASIGVERIFY\n>    SWAP TOALT SWAP CAT FROMALT CAT SHA256 Q CHECKDATASIG\n>\n> Where the stack elements are, from top to bottom:\n>\n>    S1: (65B) signature by P of tx\n>    X:  (42B) start of TapSighash spec\n>    B:  (47B) end of TapSighash spec (amount, nSequence, tapleaf_hash,\n>              key_version, codesep_pos)\n>    A:  (73B) middle of TapSighash spec dropped for ANYPREVOUT (spend_type,\n>              scriptPubKey and outpoint)\n>    C:   (1B) alternate middle (different spend_type)\n>    S2: (64B) signature of \"XCB\" by key Q\n>\n> So 298B for the witness data, and 119B or so for the script (if I've not\n> made mistakes), versus \"P CHECKSIGVERIFY Q CHECKSIG\" and S2 and S1 on\n> the stack, for 132B of witness data and 70B of script, or half that if\n> the chaperone requirement is removed.\n>\n\nI haven't checked your details but the above looks about correct to me.\n\nSo what I was thinking is that we could add CHECKDATASIG first, and then\npeople could get started on actually using ANYPREVOUT in practice and we\ncan take our time to debate the merits of the chaperone vs non-chaperone,\nand possibly learn something about actual use before making a decision.\nThere is no doubt that using ANYPREVOUT directly uses less weight, but they\nseem close enough to that it the simulation is usable, though perhaps far\nenough apart that we would want to eventually add ANYPREVOUT.  However, do\nkeep in mind that our goal is not to minimize the weight of specific\nredemption policies.  The weight of implementing any particular redemption\npolicy in Script is somewhat arbitrary to begin with anyways, being\ndependent on the choices made for the Script language operations and its\nencoding.  Again, if our goal were to minimize weight for specific\nredemption policies we should abandon SCRIPT and directly use a language\nsimilar to Miniscript, and/or just directly implement an enumeration of\npolicies.\n\nHowever, my proposal CHECKSIGFROMSTACK (aka CHECKDATASIG) proposal was\nbased on my argument that CHECKDATASIG covenant abilities wouldn't be\ncontroversial since it was limited to self-recursion and had less than\n64-bits of state space.  But ZmnSCPxj has shown that my conclusions were\nhasty and that self-recursion has access to arbitrarily large amounts of\nstate space.  In light of this, it would appear that self-recursive\ncovenants is nearly as powerful as arbitrary recursive covenants, and\ntherefore is nearly as controversial.\n\nSo, while I do think that we should add support for recursive covenants to\nBitcoin, we probably not ready to add it yet given the controversy around\nthe far more innocent ANYPREVOUT.  I do think it would be useful to add\nsupport for CAT and CHECKDATASIG in order to implement MPC with penalties,\nbut perhaps we should support that via a HASH_tapdata digest function\nrather than SHA256, in order to avoid any accidental covenants.  Of course\ndoing so would no longer count as \"an alternative\" proposal to ANYPREVOUT\nor COSHV, and simply \"an additional\" proposal.\n\n\n> I think you'd need to complicate it a bit further to do the\n> ANYPREVOUTANYSCRIPT variant, where you retain the commitment to\n> amount/nseq but drop the commitment to tapleaf_hash.\n>\n> > I feel that this style of generic building blocks truly embodies what is\n> meant\n> > by \"programmable money\".\n>\n> For practical purposes, this doesn't seem like a great level of\n> abstraction to me. It's certainly better at \"permissionless innovation\"\n> though.\n>\n> You could make these constructions a little bit simpler by having a\n> \"CHECK_SIG_MSG_VERIFY\" opcode that accepts [sig msg key], and does \"sig\n> key CHECKSIGVERIFY\" but also checks the the provided msg was what was\n> passed into bip-schnorr.\n>\n\nThe whole point is to keep the functionality simple and let users program\nwhat they want.  What we don't want to do is tailor an opcode for the\nspecific use case we have in mind, because that just comes at the expense\nof all the use cases we don't have in mind.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190529/ac866e25/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-24T23:07:28",
                "message_text_only": "In order of escalating scope of amendments to OP_COSHV, I suggest\n\n1) Peeking at surrounding data surrounding data should definitely be\nreplaced by a pushdata-like op-code that uses the subsequent 32-bytes\ndirectly.  The OP_SUCCESSx upgrade path specifically allows for this, and\navoids complicating the semantics Bitcoin Script.\n2) Furthermore, the number-of-input-verification and the\noutputhash-verification operations ought to be split into different opcodes\nas they are logically unrelated.\n3) Better still, we should instead implement the transaction reflection\noperations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash\nand number of inputs respectively onto the stack.  Recursive covenants\nappear to be effectively impossible without either an OP_TWEEKPUBKEY or an\nOP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard\nagainst placing an arbitrary outputhash onto the stack appears to be wasted\neffort to me.\n4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should most\ndefinitely prefer (3) instead of OP_COSHV, if we still feel the need to do\nanything at all.  It is probably best to have both\nOP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of\nOP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just\nOP_CHECKSIGFROMSTACKVERIFY as well.\n\nOn the other hand, if we are serious about preferring less per-block\nbandwidth over reusable primitive opcodes for programming, then we should\ninstead abandon the RISC-style Bitcoin Script and instead add an\nalternative CISC-style taproot leaf type that directly provides (a\nconjunction of) the various popular common policies: channel opening,\nchannel factories, coinjoins, hashlocks, timelocks, congestion control\netc.  Segwit v0 already implements this CISC-style for the single most\npopular policy: single signature verification.\n\nOn Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Hi Russell,\n>\n> Thanks for this detailed comparison. The COSHV BIP does include a brief\n> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more\n> detailed.\n>\n>\n> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's\n> clearly one of the more flexible options available and would enable a\n> multitude of new use cases.\n>\n> When I originally presented my work on congestion control at Jan 2017\n> BPASE, I also discussed it as an option for covenants. Unfortunately I\n> think it may be on the edge of too powerful -- there are a lot of use cases\n> and implications from having a potentially recursive covenant. If you see\n> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a\n> non-computationally enumerable set of restrictions.\n>\n> I think also from a developer point of view working with OP_COSHV is much\n> much simpler (maybe this can be abstracted) which will lead to increased\n> adoption. OP_COSHV also uses less per-block bandwidth which also makes it\n> preferable for a measure intended to decongest blocks. Do you know the\n> exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating\n> changes to taproot, can be a single byte. OP_COSHV also has less potential\n> to have a negative interaction with future opcodes we may want like\n> OP_PUBKEYTWEAK. While we're getting to an exact spec for the features we\n> want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK\n> unless there's an exact specification which makes us confident we're\n> hitting all the points.\n>\n> If the main complaint about OP_COSHV is that it peeks at surrounding data,\n> it's also possible to implement it more closely to a multi-byte pushdata\n> opcode or do the template optimization.\n>\n> Lastly, as I have previously noted, OP_LEFT is probably safer to implement\n> than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK scripts.\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/868860a9/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-25T01:08:00",
                "message_text_only": "What do you think about having it be OP_CHECK_TXID_TEMPLATE_DATA where the\nhash checked is the TXID of the transaction with the inputs set to 0000...\n(maybe appended to the fee paid)?\n\nThis allows for a variable number of inputs to be allowed (e.g., one, two,\netc). This also fixes potential bugs around TXID malleability for lightning\nlike setups (Greg and I discussed in wizards about version malleability).\n\nAllowing multiple inputs is great for structuring more complex contracts\nwith multiple nodes paying into the same covenantted transaction.\n\nAlso I personally prefer a RISC+CISC approach -- we should enable the\ncommon paths easily as they are known (didn't you come up with jets?) and\nimprove security for API users, but also piecemeal enable features in\nscript to allow for experimentation or custom contracts.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Fri, May 24, 2019 at 4:15 PM Russell O'Connor <roconnor at blockstream.io>\nwrote:\n\n> In order of escalating scope of amendments to OP_COSHV, I suggest\n>\n> 1) Peeking at surrounding data surrounding data should definitely be\n> replaced by a pushdata-like op-code that uses the subsequent 32-bytes\n> directly.  The OP_SUCCESSx upgrade path specifically allows for this, and\n> avoids complicating the semantics Bitcoin Script.\n> 2) Furthermore, the number-of-input-verification and the\n> outputhash-verification operations ought to be split into different opcodes\n> as they are logically unrelated.\n> 3) Better still, we should instead implement the transaction reflection\n> operations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash\n> and number of inputs respectively onto the stack.  Recursive covenants\n> appear to be effectively impossible without either an OP_TWEEKPUBKEY or an\n> OP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard\n> against placing an arbitrary outputhash onto the stack appears to be wasted\n> effort to me.\n> 4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should most\n> definitely prefer (3) instead of OP_COSHV, if we still feel the need to do\n> anything at all.  It is probably best to have both\n> OP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of\n> OP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just\n> OP_CHECKSIGFROMSTACKVERIFY as well.\n>\n> On the other hand, if we are serious about preferring less per-block\n> bandwidth over reusable primitive opcodes for programming, then we should\n> instead abandon the RISC-style Bitcoin Script and instead add an\n> alternative CISC-style taproot leaf type that directly provides (a\n> conjunction of) the various popular common policies: channel opening,\n> channel factories, coinjoins, hashlocks, timelocks, congestion control\n> etc.  Segwit v0 already implements this CISC-style for the single most\n> popular policy: single signature verification.\n>\n> On Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> Hi Russell,\n>>\n>> Thanks for this detailed comparison. The COSHV BIP does include a brief\n>> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more\n>> detailed.\n>>\n>>\n>> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's\n>> clearly one of the more flexible options available and would enable a\n>> multitude of new use cases.\n>>\n>> When I originally presented my work on congestion control at Jan 2017\n>> BPASE, I also discussed it as an option for covenants. Unfortunately I\n>> think it may be on the edge of too powerful -- there are a lot of use cases\n>> and implications from having a potentially recursive covenant. If you see\n>> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a\n>> non-computationally enumerable set of restrictions.\n>>\n>> I think also from a developer point of view working with OP_COSHV is much\n>> much simpler (maybe this can be abstracted) which will lead to increased\n>> adoption. OP_COSHV also uses less per-block bandwidth which also makes it\n>> preferable for a measure intended to decongest blocks. Do you know the\n>> exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating\n>> changes to taproot, can be a single byte. OP_COSHV also has less potential\n>> to have a negative interaction with future opcodes we may want like\n>> OP_PUBKEYTWEAK. While we're getting to an exact spec for the features we\n>> want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK\n>> unless there's an exact specification which makes us confident we're\n>> hitting all the points.\n>>\n>> If the main complaint about OP_COSHV is that it peeks at surrounding\n>> data, it's also possible to implement it more closely to a multi-byte\n>> pushdata opcode or do the template optimization.\n>>\n>> Lastly, as I have previously noted, OP_LEFT is probably safer to\n>> implement than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK\n>> scripts.\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/e41318e9/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2019-05-25T12:52:44",
                "message_text_only": "Allowing multiple inputs is certainly better than the 1 restriction COSHV.\n\nHowever, I agree on your preference for a RISC+CISC approach.  Which is why\ninstead of COSHV or CHECK_TXID_TEMPLACE_DATA we should do the more RISC-y\nthing and begin adding transaction reflection primitives, starting with\nOP_NUMINPUTS and OP_PUSHOUTPUTSHASH.  Nothing bad will happen by pushing\nthe OUTPUTSHASH onto the stack, and we won't even get recursive covenants\nwith just these transaction reflection primitives in tapscript.\n\nOn Fri, May 24, 2019 at 9:08 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> What do you think about having it be OP_CHECK_TXID_TEMPLATE_DATA where the\n> hash checked is the TXID of the transaction with the inputs set to 0000...\n> (maybe appended to the fee paid)?\n>\n> This allows for a variable number of inputs to be allowed (e.g., one, two,\n> etc). This also fixes potential bugs around TXID malleability for lightning\n> like setups (Greg and I discussed in wizards about version malleability).\n>\n> Allowing multiple inputs is great for structuring more complex contracts\n> with multiple nodes paying into the same covenantted transaction.\n>\n> Also I personally prefer a RISC+CISC approach -- we should enable the\n> common paths easily as they are known (didn't you come up with jets?) and\n> improve security for API users, but also piecemeal enable features in\n> script to allow for experimentation or custom contracts.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Fri, May 24, 2019 at 4:15 PM Russell O'Connor <roconnor at blockstream.io>\n> wrote:\n>\n>> In order of escalating scope of amendments to OP_COSHV, I suggest\n>>\n>> 1) Peeking at surrounding data surrounding data should definitely be\n>> replaced by a pushdata-like op-code that uses the subsequent 32-bytes\n>> directly.  The OP_SUCCESSx upgrade path specifically allows for this, and\n>> avoids complicating the semantics Bitcoin Script.\n>> 2) Furthermore, the number-of-input-verification and the\n>> outputhash-verification operations ought to be split into different opcodes\n>> as they are logically unrelated.\n>> 3) Better still, we should instead implement the transaction reflection\n>> operations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash\n>> and number of inputs respectively onto the stack.  Recursive covenants\n>> appear to be effectively impossible without either an OP_TWEEKPUBKEY or an\n>> OP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard\n>> against placing an arbitrary outputhash onto the stack appears to be wasted\n>> effort to me.\n>> 4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should\n>> most definitely prefer (3) instead of OP_COSHV, if we still feel the need\n>> to do anything at all.  It is probably best to have both\n>> OP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of\n>> OP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just\n>> OP_CHECKSIGFROMSTACKVERIFY as well.\n>>\n>> On the other hand, if we are serious about preferring less per-block\n>> bandwidth over reusable primitive opcodes for programming, then we should\n>> instead abandon the RISC-style Bitcoin Script and instead add an\n>> alternative CISC-style taproot leaf type that directly provides (a\n>> conjunction of) the various popular common policies: channel opening,\n>> channel factories, coinjoins, hashlocks, timelocks, congestion control\n>> etc.  Segwit v0 already implements this CISC-style for the single most\n>> popular policy: single signature verification.\n>>\n>> On Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:\n>>\n>>> Hi Russell,\n>>>\n>>> Thanks for this detailed comparison. The COSHV BIP does include a brief\n>>> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more\n>>> detailed.\n>>>\n>>>\n>>> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's\n>>> clearly one of the more flexible options available and would enable a\n>>> multitude of new use cases.\n>>>\n>>> When I originally presented my work on congestion control at Jan 2017\n>>> BPASE, I also discussed it as an option for covenants. Unfortunately I\n>>> think it may be on the edge of too powerful -- there are a lot of use cases\n>>> and implications from having a potentially recursive covenant. If you see\n>>> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a\n>>> non-computationally enumerable set of restrictions.\n>>>\n>>> I think also from a developer point of view working with OP_COSHV is\n>>> much much simpler (maybe this can be abstracted) which will lead to\n>>> increased adoption. OP_COSHV also uses less per-block bandwidth which also\n>>> makes it preferable for a measure intended to decongest blocks. Do you know\n>>> the exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with\n>>> templating changes to taproot, can be a single byte. OP_COSHV also has less\n>>> potential to have a negative interaction with future opcodes we may want\n>>> like OP_PUBKEYTWEAK. While we're getting to an exact spec for the features\n>>> we want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK\n>>> unless there's an exact specification which makes us confident we're\n>>> hitting all the points.\n>>>\n>>> If the main complaint about OP_COSHV is that it peeks at surrounding\n>>> data, it's also possible to implement it more closely to a multi-byte\n>>> pushdata opcode or do the template optimization.\n>>>\n>>> Lastly, as I have previously noted, OP_LEFT is probably safer to\n>>> implement than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK\n>>> scripts.\n>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/5adfc65a/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "An alternative: OP_CAT & OP_CHECKSIGFROMSTACK",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Anthony Towns",
                "Russell O'Connor",
                "ZmnSCPxj",
                "Jimmy Song"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 62879
        }
    },
    {
        "title": "[bitcoin-dev] Safety of committing only to transaction outputs",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2019-05-23T20:54:01",
                "message_text_only": "This is a meta-discussion for any approach that allows the witness committing to only transaction outputs, but not inputs.\n\nWe can already do the following things with the existing bitcoin script system:\n* commit to both inputs and outputs: SIGHASH_ALL or SIGHASH_SINGLE, with optional SIGHASH_ANYONECANPAY\n* commit to only inputs but not outputs: SIGHASH_NONE with optional SIGHASH_ANYONECANPAY\n* not commit to any input nor output: not using any sigop; using a trivial private key; using the SIGHASH_SINGLE bug in legacy script\n\nThe last one is clearly unsafe as any relay/mining node may redirect the payment to any output it chooses. The witness/scriptSig is also replayable, so any future payment to this script will likely be swept immediately\n\nSIGHASH_NONE with ANYONECANPAY also allows redirection of payment, but the signature is not replayable\n\nBut it\u2019s quite obvious that not committing to outputs are inherently insecure\n\nThe existing system doesn\u2019t allow committing only to outputs, and we now have 3 active proposals for this function:\n\n1. CAT and CHECKSIGFROMSTACK (CSFS): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html>\n2. ANYPREVOUT (aka NOINPUT): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html>\n3. CHECKOUTPUTSHASHVERIFY (COHV): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html>\n\nWith outputs committed, redirecting payment is not possible. On the other hand, not committing to any input means the witness is replayable without the consent of address owner. Whether replayability is acceptable is subject to controversy, but the ANYPREVOUT proposal fixes this by requiring a chaperone signature that commits to input. However, if the rationale for chaperone signature stands, it should be applicable to all proposals listed above.\n\nA more generic approach is to always require a \u201csafe\" signature that commits to at least one input. However, this interacts poorly with the \"unknown public key type\u201d upgrade path described in bip-tapscript (https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki <https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki>), since it\u2019d be a hardfork to turn an \u201cunknown type sig\u201d into a \u201csafe sig\u201d. But we could still use a new \u201cleaf version\u201d every time we introduce new sighash types, so we could have a new definition for \u201csafe sig\u201d. I expect this would be a rare event and it won\u2019t consume more than a couple leaf versions. By the way, customised sighash policies could be done with CAT/CSFS.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/d832f52d/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2019-05-24T20:59:03",
                "message_text_only": "Hi Johnson,\n\nAs noted on the other thread, witness replay-ability can be helped by\nsalting the taproot key or the taproot leaf script at the last stage of a\ncongestion control tree.\n\nI also think that chaperone signatures should be opt-in; there are cases\nwhere we may not want them. OP_COSHV is compatible with an additional\nchecksig operation.\n\nThere are also other mechanisms that can improve the safety. Proposed below:\n\nOP_CHECKINPUTSHASHVERIFY -- allow checking that the hash of the inputs is a\nparticular value. The top-level of a congestion control tree can check that\nthe inputs match the desired inputs for that spend, and default to\nrequiring N of N otherwise. This is replay proof! This is useful for other\napplications too.\n\nOP_CHECKFEEVERIFY -- allowing an explicit commitment to the exact amount of\nfee limits replay to txns which were funded with the exact amount of the\nprior. If there's a mismatch, an alternative branch can be used. This is a\ngenerally useful mechanism, but means that transactions using it must have\nall inputs/outputs set.\n\nBest,\n\nJeremy\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Fri, May 24, 2019 at 7:40 AM Johnson Lau via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> This is a meta-discussion for any approach that allows the witness\n> committing to only transaction outputs, but not inputs.\n>\n> We can already do the following things with the existing bitcoin script\n> system:\n> * commit to both inputs and outputs: SIGHASH_ALL or SIGHASH_SINGLE, with\n> optional SIGHASH_ANYONECANPAY\n> * commit to only inputs but not outputs: SIGHASH_NONE with optional\n> SIGHASH_ANYONECANPAY\n> * not commit to any input nor output: not using any sigop; using a trivial\n> private key; using the SIGHASH_SINGLE bug in legacy script\n>\n> The last one is clearly unsafe as any relay/mining node may redirect the\n> payment to any output it chooses. The witness/scriptSig is also replayable,\n> so any future payment to this script will likely be swept immediately\n>\n> SIGHASH_NONE with ANYONECANPAY also allows redirection of payment, but the\n> signature is not replayable\n>\n> But it\u2019s quite obvious that not committing to outputs are inherently\n> insecure\n>\n> The existing system doesn\u2019t allow committing only to outputs, and we now\n> have 3 active proposals for this function:\n>\n> 1. CAT and CHECKSIGFROMSTACK (CSFS):\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html\n> 2. ANYPREVOUT (aka NOINPUT):\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html\n> 3. CHECKOUTPUTSHASHVERIFY (COHV):\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html\n>\n> With outputs committed, redirecting payment is not possible. On the other\n> hand, not committing to any input means the witness is replayable without\n> the consent of address owner. Whether replayability is acceptable is\n> subject to controversy, but the ANYPREVOUT proposal fixes this by requiring\n> a chaperone signature that commits to input. However, if the rationale for\n> chaperone signature stands, it should be applicable to all proposals listed\n> above.\n>\n> A more generic approach is to always require a \u201csafe\" signature that\n> commits to at least one input. However, this interacts poorly with the\n> \"unknown public key type\u201d upgrade path described in bip-tapscript (\n> https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki),\n> since it\u2019d be a hardfork to turn an \u201cunknown type sig\u201d into a \u201csafe sig\u201d.\n> But we could still use a new \u201cleaf version\u201d every time we introduce new\n> sighash types, so we could have a new definition for \u201csafe sig\u201d. I expect\n> this would be a rare event and it won\u2019t consume more than a couple leaf\n> versions. By the way, customised sighash policies could be done with\n> CAT/CSFS.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/9e31d870/attachment-0001.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-25T07:53:34",
                "message_text_only": "> On 25 May 2019, at 4:59 AM, Jeremy <jlrubin at mit.edu> wrote:\n> \n> Hi Johnson,\n> \n> As noted on the other thread, witness replay-ability can be helped by salting the taproot key or the taproot leaf script at the last stage of a congestion control tree.\n> \n\nThe salt will be published when it is first spent. Salting won\u2019t help if the address is reused.\n\n> I also think that chaperone signatures should be opt-in; there are cases where we may not want them. OP_COSHV is compatible with an additional checksig operation.\n> \n> There are also other mechanisms that can improve the safety. Proposed below:\n> \n> OP_CHECKINPUTSHASHVERIFY -- allow checking that the hash of the inputs is a particular value. The top-level of a congestion control tree can check that the inputs match the desired inputs for that spend, and default to requiring N of N otherwise. This is replay proof! This is useful for other applications too.\n\nIt is circular dependent: the script has to commit to the txid, and the txid is a function of script\n\n\n> \n> OP_CHECKFEEVERIFY -- allowing an explicit commitment to the exact amount of fee limits replay to txns which were funded with the exact amount of the prior. If there's a mismatch, an alternative branch can be used. This is a generally useful mechanism, but means that transactions using it must have all inputs/outputs set.\n> \n\nThis restricts replayability to input with same value, but is still replay-able, just like ANYPREVOUT committing to the input value\n\n\n> Best,\n> \n> Jeremy\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin> <https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/cebe50ff/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Safety of committing only to transaction outputs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jeremy",
                "Johnson Lau"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8988
        }
    },
    {
        "title": "[bitcoin-dev] Two questions about segwit implementation",
        "thread_messages": [
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-25T23:56:48",
                "message_text_only": "I realized recently that my segwit implementation was not correct,\nbasically some time ago, wrongly reading the specs (and misleaded by\nwhat follows), I thought that scriptsig would go into witness data as it\nwas, but that's not the case, op_pushdata is replaced by varlen\n\nNow reading correctly the specs, they seem to be not totally correct,\nthen the first question is: why OP_0 is 00 in witness data and not 0100?\nDoes this apply to other op_codes? This does not look logical at all\n\nThe second question is: why for non segwit inputs there is a 00 length\nin segwit data, what is the rational for that? It should just be nothing\nsince you don't need this to reconciliate things"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-26T14:33:06",
                "message_text_only": "> On 26 May 2019, at 7:56 AM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I realized recently that my segwit implementation was not correct,\n> basically some time ago, wrongly reading the specs (and misleaded by\n> what follows), I thought that scriptsig would go into witness data as it\n> was, but that's not the case, op_pushdata is replaced by varlen\n> \n\nWitness is not script. There is no op_pushdata or any other opcodes.\n\nWitness is a stack. For each input, the witness starts with a CCompactSize for the number of stack elements for this input. Each stack element in turns starts with a CCompactSize for the size of this element, followed by the actual data\n\n\n> Now reading correctly the specs, they seem to be not totally correct,\n> then the first question is: why OP_0 is 00 in witness data and not 0100?\n> Does this apply to other op_codes? This does not look logical at all\n> \n\nA \u201c00\u201d element means the size of this element is zero. Since it\u2019s zero size, no data is followed. This will create an empty element on the stack. It\u2019s effectively same as OP_0 (Again, witness is not script)\n\nA \u201c0100\u201d element means the element size is one, and the data for this element is \u201c00\u201d. So it will leave an 1-byte element on the stack.\n\n\n> The second question is: why for non segwit inputs there is a 00 length\n> in segwit data, what is the rational for that? It should just be nothing\n> since you don't need this to reconciliate things\n\nThe \u201c00\u201d here means \"this input has no witness stack element\u201d. You need this even for non segwit inputs, because there is no way to tell whether an input is segwit-enabled or not, until you look up the UTXO, which might not be always available. Transaction serialization couldn\u2019t rely on contextual information.\n\nHowever, if all inputs have no stack element, the spec requires you to always use the non-segwit serialization.\n\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-26T16:18:46",
                "message_text_only": "OK, thanks, understood for OP_0 but still for the 00 number of witness\ndata for non segwit inputs the one that is doing the transaction knows\nwhich inputs are segwit or not, then parsing the transaction you can\nassociate the correct input to the correct witness data, without the\nneed of 00, so I must be missing the use case\n\nLe 26/05/2019 \u00e0 16:33, Johnson Lau a \u00e9crit\u00a0:\n>> On 26 May 2019, at 7:56 AM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> I realized recently that my segwit implementation was not correct,\n>> basically some time ago, wrongly reading the specs (and misleaded by\n>> what follows), I thought that scriptsig would go into witness data as it\n>> was, but that's not the case, op_pushdata is replaced by varlen\n>>\n> Witness is not script. There is no op_pushdata or any other opcodes.\n>\n> Witness is a stack. For each input, the witness starts with a CCompactSize for the number of stack elements for this input. Each stack element in turns starts with a CCompactSize for the size of this element, followed by the actual data\n>\n>\n>> Now reading correctly the specs, they seem to be not totally correct,\n>> then the first question is: why OP_0 is 00 in witness data and not 0100?\n>> Does this apply to other op_codes? This does not look logical at all\n>>\n> A \u201c00\u201d element means the size of this element is zero. Since it\u2019s zero size, no data is followed. This will create an empty element on the stack. It\u2019s effectively same as OP_0 (Again, witness is not script)\n>\n> A \u201c0100\u201d element means the element size is one, and the data for this element is \u201c00\u201d. So it will leave an 1-byte element on the stack.\n>\n>\n>> The second question is: why for non segwit inputs there is a 00 length\n>> in segwit data, what is the rational for that? It should just be nothing\n>> since you don't need this to reconciliate things\n> The \u201c00\u201d here means \"this input has no witness stack element\u201d. You need this even for non segwit inputs, because there is no way to tell whether an input is segwit-enabled or not, until you look up the UTXO, which might not be always available. Transaction serialization couldn\u2019t rely on contextual information.\n>\n> However, if all inputs have no stack element, the spec requires you to always use the non-segwit serialization.\n>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-- \nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Pieter Wuille",
                "date": "2019-05-26T17:54:08",
                "message_text_only": "On Sun, May 26, 2019, 07:07 Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I realized recently that my segwit implementation was not correct,\n> basically some time ago, wrongly reading the specs (and misleaded by\n> what follows), I thought that scriptsig would go into witness data as it\n> was, but that's not the case, op_pushdata is replaced by varlen\n>\n> Now reading correctly the specs, they seem to be not totally correct,\n> then the first question is: why OP_0 is 00 in witness data and not 0100?\n> Does this apply to other op_codes? This does not look logical at all\n>\n> The second question is: why for non segwit inputs there is a 00 length\n> in segwit data, what is the rational for that? It should just be nothing\n> since you don't need this to reconciliate things\n>\n\nThis is a question that belongs on https://bitcoin.stackexchange.com, not\nthis list.\n\nCheers,\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190526/7df58353/attachment.html>"
            },
            {
                "author": "Thomas Kerin",
                "date": "2019-05-26T19:34:55",
                "message_text_only": "The scriptSig when evaluated populates the stack so opcodes can operate\non them. A witness is essentially a list of data elements, quite similar\nto the script stack (the witness is passed in as the script stack in fact)\n\nOP_0 when evaluated pushes a _zero length_ value onto the stack, hence\nthe 00 (the varlen) in the witness serialization. OP_1 (51 in decimal)\npushes 0x01 to the stack, so when serialized would be 0101.\n\nIt may help to consider the entire witness structure as\nvector<vector<data element>> and it's length must equal the number of\ninputs - so a non-segwit input must have a zero sized witness.\n\nOn 5/26/19 12:56 AM, Aymeric Vitte via bitcoin-dev wrote:\n> I realized recently that my segwit implementation was not correct,\n> basically some time ago, wrongly reading the specs (and misleaded by\n> what follows), I thought that scriptsig would go into witness data as it\n> was, but that's not the case, op_pushdata is replaced by varlen\n>\n> Now reading correctly the specs, they seem to be not totally correct,\n> then the first question is: why OP_0 is 00 in witness data and not 0100?\n> Does this apply to other op_codes? This does not look logical at all\n>\n> The second question is: why for non segwit inputs there is a 00 length\n> in segwit data, what is the rational for that? It should just be nothing\n> since you don't need this to reconciliate things\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Kostas Karasavvas",
                "date": "2019-05-27T07:26:21",
                "message_text_only": "On Sun, May 26, 2019 at 5:07 PM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I realized recently that my segwit implementation was not correct,\n> basically some time ago, wrongly reading the specs (and misleaded by\n> what follows), I thought that scriptsig would go into witness data as it\n> was, but that's not the case, op_pushdata is replaced by varlen\n>\n> Now reading correctly the specs, they seem to be not totally correct,\n> then the first question is: why OP_0 is 00 in witness data and not 0100?\n> Does this apply to other op_codes? This does not look logical at all\n>\n>\nop_pushdata allows for unsigned integers and thus it uses the extra byte to\nspecify that.\n\nA varint (varlen) is unsigned.  0 and anything <= 252 is one byte length,\nso 00.\n\n\n> The second question is: why for non segwit inputs there is a 00 length\n> in segwit data, what is the rational for that? It should just be nothing\n> since you don't need this to reconciliate things\n>\n>\nBecause you don't have the number of witnesses as you have for\ninputs/outputs. The witness data length is assumed to be the same as the\ninputs length. And then for non-segwit inputs you need the 00 to specify\nthat it is empty.\n\nHope that helps.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190527/b1ee6569/attachment.html>"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-26T16:28:57",
                "message_text_only": "This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.\n\nIn a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that \u201cthe witness for this input is empty\u201d, and it is the \u201c00\u201d.\n\n> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n> \n> \u2026\u2026. for the 00 number of witness\n> data for non segwit inputs the one that is doing the transaction knows\n> which inputs are segwit or not, then parsing the transaction you can\n> associate the correct input to the correct witness data, without the\n> need of 00, so I must be missing the use case"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-26T17:09:31",
                "message_text_only": "I did not phrase correctly in fact, what I meant is: if the validator\nsees empty or witness script in scriptSig, then this is a segwit input,\nand doing this one by one the validator can associate the correct segwit\ndata to the correct segwit input, so 00 does not look to be needed\n\nLe 26/05/2019 \u00e0 18:28, Johnson Lau a \u00e9crit\u00a0:\n> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.\n>\n> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that \u201cthe witness for this input is empty\u201d, and it is the \u201c00\u201d.\n>\n>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>>\n>> \u2026\u2026. for the 00 number of witness\n>> data for non segwit inputs the one that is doing the transaction knows\n>> which inputs are segwit or not, then parsing the transaction you can\n>> associate the correct input to the correct witness data, without the\n>> need of 00, so I must be missing the use case\n>"
            },
            {
                "author": "Johnson Lau",
                "date": "2019-05-26T17:24:13",
                "message_text_only": "Empty scriptSig doesn\u2019t imply segwit input: if the previous scriptPubKey is OP_1 (which does not allow witness), it could still be spent with an empty scriptSig\n\nSimilarly, a scriptSig looking like a spend of P2SH-segwit doesn\u2019t imply segwit input: if the previous scriptPubKey is empty, it could be spent with a push of any non-zero value.\n\n> On 27 May 2019, at 1:09 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n> \n> I did not phrase correctly in fact, what I meant is: if the validator\n> sees empty or witness script in scriptSig, then this is a segwit input,\n> and doing this one by one the validator can associate the correct segwit\n> data to the correct segwit input, so 00 does not look to be needed\n> \n> Le 26/05/2019 \u00e0 18:28, Johnson Lau a \u00e9crit :\n>> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.\n>> \n>> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that \u201cthe witness for this input is empty\u201d, and it is the \u201c00\u201d.\n>> \n>>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>>> \n>>> \u2026\u2026. for the 00 number of witness\n>>> data for non segwit inputs the one that is doing the transaction knows\n>>> which inputs are segwit or not, then parsing the transaction you can\n>>> associate the correct input to the correct witness data, without the\n>>> need of 00, so I must be missing the use case\n>>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2019-05-26T21:17:30",
                "message_text_only": "Well, OK, then back to non standard stuff and bitcoin considers that an\nOP_1 or empty scriptpubkey is something that can exist, sipa does not\nlike my questions on this list but this is a bit frightening in fact to\nsee that after 10 years an OP_1 scriptpubkey or empty one can be a use\ncase, thanks Thomas also, where all of this is clearly documented so\npeople don't bother the list not to produce approximative stuff remains\nmysterious\n\nLe 26/05/2019 \u00e0 19:24, Johnson Lau a \u00e9crit\u00a0:\n> Empty scriptSig doesn\u2019t imply segwit input: if the previous scriptPubKey is OP_1 (which does not allow witness), it could still be spent with an empty scriptSig\n>\n> Similarly, a scriptSig looking like a spend of P2SH-segwit doesn\u2019t imply segwit input: if the previous scriptPubKey is empty, it could be spent with a push of any non-zero value.\n>\n>> On 27 May 2019, at 1:09 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>>\n>> I did not phrase correctly in fact, what I meant is: if the validator\n>> sees empty or witness script in scriptSig, then this is a segwit input,\n>> and doing this one by one the validator can associate the correct segwit\n>> data to the correct segwit input, so 00 does not look to be needed\n>>\n>> Le 26/05/2019 \u00e0 18:28, Johnson Lau a \u00e9crit :\n>>> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.\n>>>\n>>> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that \u201cthe witness for this input is empty\u201d, and it is the \u201c00\u201d.\n>>>\n>>>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:\n>>>>\n>>>> \u2026\u2026. for the 00 number of witness\n>>>> data for non segwit inputs the one that is doing the transaction knows\n>>>> which inputs are segwit or not, then parsing the transaction you can\n>>>> associate the correct input to the correct witness data, without the\n>>>> need of 00, so I must be missing the use case\n>"
            }
        ],
        "thread_summary": {
            "title": "Two questions about segwit implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Thomas Kerin",
                "Kostas Karasavvas",
                "Johnson Lau",
                "Aymeric Vitte",
                "Pieter Wuille"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 15856
        }
    },
    {
        "title": "[bitcoin-dev] Bandwidth-Efficient Transaction Relay for Bitcoin",
        "thread_messages": [
            {
                "author": "Gleb Naumenko",
                "date": "2019-05-28T00:11:50",
                "message_text_only": "Hi all,\n\nWe are making public our latest work on Erlay, an efficient transaction relay protocol for Bitcoin.\nIt is available here:\u00a0https://arxiv.org/abs/1905.10518\n\nThe main idea is that instead of announcing every transaction to every peer, announcements are only sent directly over a small number of connections (only 8 outgoing ones). Further relay is achieved by periodically running a set reconciliation protocol over every connection between the sets of withheld announcements in both directions.\n\nThe set reconciliation protocol uses error correcting codes to communicate a set of transactions to a peer with an unknown but similar set using bandwidth only equal to the size of the difference and not the size of the sets themselves.\n\nResults: we save half of the bandwidth a node consumes, allow increasing connectivity almost for free, and, as a side effect, better withstand timing attacks.\nIf outbound peer count were increased to 32, Erlay saves around 75% overall bandwidth compared to the current protocol.\n\nThis work uses Minisketch, an efficient library for set reconciliation, which we made public before:\u00a0github.com/sipa/minisketch.\n\nSome of you may already know about it from discussions with me, Scaling Bitcoin 18, or CoreDev in Tokyo. Our proposal has become more precise since then.\n\nThe next step here is to receive more feedback, have a broader discussion, and then write a BIP along with improving reference implementation. We are looking forward to hearing your suggestions or concerns regarding this work.\n\nThis protocol is a result of work by myself, Gregory Maxwell, Pieter Wuille, and my supervisors at UBC: Ivan Beschastnikh and Sasha Fedorova.\nI would like to thank Tim Ruffing and Ben Woosley for contributions to the write-up, and Blockstream for supporting my work on this protocol.\n\n\u2013 gleb\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190527/b84a5c9f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bandwidth-Efficient Transaction Relay for Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gleb Naumenko"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2009
        }
    }
]