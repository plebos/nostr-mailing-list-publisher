[
    {
        "title": "[bitcoin-dev] New Bitcoin Core macOS signing key",
        "thread_messages": [
            {
                "author": "Cory Fields",
                "date": "2018-02-01T01:14:45",
                "message_text_only": "A public key was published recently for future macOS releases. Sadly,\nthat key was created the wrong way (iPhone OS instead of macOS), so\nanother had to be generated.\n\nThe new, working pubkey for Bitcoin Core releases starting with\n0.16.0rc1 is included in the message below. That message is signed\nwith the key mentioned in the previous mail.\nIt can be verified with: openssl smime -verify -noverify -in msg.pem\n\nSorry for the noise.\n\n-----BEGIN PKCS7-----\nMIIPbQYJKoZIhvcNAQcCoIIPXjCCD1oCAQExCzAJBgUrDgMCGgUAMIIC5gYJKoZI\nhvcNAQcBoIIC1wSCAtNBIHB1YmxpYyBrZXkgd2FzIHB1Ymxpc2hlZCByZWNlbnRs\neSBmb3IgZnV0dXJlIG1hY09TIHJlbGVhc2VzLg0KDQpTYWRseSwgdGhlIHB1Ymxp\nc2hlZCBrZXkgd2FzIGNyZWF0ZWQgdGhlIHdyb25nIHdheSAoaVBob25lIE9TIGlu\nc3RlYWQgb2YgbWFjT1MpLCBzbyBhbm90aGVyIGhhZCB0byBiZSByZXF1ZXN0ZWQu\nDQoNClRoZSBuZXcsIHdvcmtpbmcgcHVia2V5IGZvciBCaXRjb2luIENvcmUgcmVs\nZWFzZXMgc3RhcnRpbmcgd2l0aCAwLjE2LjByYzEgaXM6DQoNCi0tLS0tQkVHSU4g\nUFVCTElDIEtFWS0tLS0tDQpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4\nQU1JSUJDZ0tDQVFFQXF4aWJEZ2pBT09WVXBTY3pVMnBqDQp0UEVpQ0lZeXl2V21E\nN2VidGhQbzI5WG9xMUJqYWJGNDlCZ3diNkZFaU1haFN5UTY4ZklMSUhDanJ5SUo4\nRUN1DQpROFJWbVF3cGdhKzV0OTZiMEM5emN5WTFhcSsrRzIyMVNqNmFpUmVveXZw\ncHIrZ2poNmNPbktEc1B0Z2pUcGdiDQovOUhuMmtwYzFmZ000ZkRFMlQ2VXZHVHMw\nd3d5dWNvL21ya0s1LzEySCtqZUE3QXVNcjBLQTBVSktSS1VOenFhDQo4QjlLalFF\nektaRGVVVHRYak9vSmIyNkRQU3hCbXBGd25zWSs2aHBjeFZSSmphNG1FYzRFYnIy\nb2gxSmVORU5uDQp4WXR3MHRWVWczTUwvWlI2WU9qQVpMY0V0cW5IR2ZOZXVRazJX\nVm1pYy9JY3d4VEM0cUk4MnFROGgxQnFpY3pRDQo4UUlEQVFBQg0KLS0tLS1FTkQg\nUFVCTElDIEtFWS0tLS0tDQqgggnZMIIFzTCCBLWgAwIBAgIId5kUM+xSbWMwDQYJ\nKoZIhvcNAQELBQAwgZYxCzAJBgNVBAYTAlVTMRMwEQYDVQQKDApBcHBsZSBJbmMu\nMSwwKgYDVQQLDCNBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9uczFE\nMEIGA1UEAww7QXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ2Vy\ndGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTgwMTEwMjAyNTA1WhcNMTkwMTEwMjAy\nNTA1WjCBwDEaMBgGCgmSJomT8ixkAQEMCllaQzdXSDNNUlUxUDBOBgNVBAMMR2lQ\naG9uZSBEaXN0cmlidXRpb246IEJpdGNvaW4gQ29yZSBDb2RlIFNpZ25pbmcgQXNz\nb2NpYXRpb24gKFlaQzdXSDNNUlUpMRMwEQYDVQQLDApZWkM3V0gzTVJVMS4wLAYD\nVQQKDCVCaXRjb2luIENvcmUgQ29kZSBTaWduaW5nIEFzc29jaWF0aW9uMQswCQYD\nVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKsYmw4IwDjl\nVKUnM1NqY7TxIgiGMsr1pg+3m7YT6NvV6KtQY2mxePQYMG+hRIjGoUskOvHyCyBw\no68iCfBArkPEVZkMKYGvubfem9Avc3MmNWqvvhtttUo+mokXqMr6aa/oI4enDpyg\n7D7YI06YG//R59pKXNX4DOHwxNk+lLxk7NMMMrnKP5q5Cuf9dh/o3gOwLjK9CgNF\nCSkSlDc6mvAfSo0BMymQ3lE7V4zqCW9ugz0sQZqRcJ7GPuoaXMVUSY2uJhHOBG69\nqIdSXjRDZ8WLcNLVVINzC/2UemDowGS3BLapxxnzXrkJNllZonPyHMMUwuKiPNqk\nPIdQaonM0PECAwEAAaOCAfEwggHtMD8GCCsGAQUFBwEBBDMwMTAvBggrBgEFBQcw\nAYYjaHR0cDovL29jc3AuYXBwbGUuY29tL29jc3AwMy13d2RyMTEwHQYDVR0OBBYE\nFNOBKRRpuWarZwT6owhUtiOP6lbSMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAU\niCcXCam2GGCL7Ou69kdZxVJUo7cwggEdBgNVHSAEggEUMIIBEDCCAQwGCSqGSIb3\nY2QFATCB/jCBwwYIKwYBBQUHAgIwgbYMgbNSZWxpYW5jZSBvbiB0aGlzIGNlcnRp\nZmljYXRlIGJ5IGFueSBwYXJ0eSBhc3N1bWVzIGFjY2VwdGFuY2Ugb2YgdGhlIHRo\nZW4gYXBwbGljYWJsZSBzdGFuZGFyZCB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB1\nc2UsIGNlcnRpZmljYXRlIHBvbGljeSBhbmQgY2VydGlmaWNhdGlvbiBwcmFjdGlj\nZSBzdGF0ZW1lbnRzLjA2BggrBgEFBQcCARYqaHR0cDovL3d3dy5hcHBsZS5jb20v\nY2VydGlmaWNhdGVhdXRob3JpdHkvMA4GA1UdDwEB/wQEAwIHgDAWBgNVHSUBAf8E\nDDAKBggrBgEFBQcDAzATBgoqhkiG92NkBgEEAQH/BAIFADANBgkqhkiG9w0BAQsF\nAAOCAQEARvNgy5mhFqZsI5JGgn6HSR/eQIXjuoGyOivOa6+uCb5qcrSjSR+PSj7D\nK/SBxrz+sVgKvwQ3buhv3BJnURmbYtEmqRr60G+yZE6xNpDMEyZyEM7aT6R9zBMX\n++5mwqq5Ip57Mq8yB+pGTzSCBUAat6qiMBUkJBa+F/fk+vXZxgKAfKGMEfALLR5j\nRnwadg2CoTng47Mt4gzuGqjRSJH2vlB44GzRiFoJjXJOJGZ0hdagXl1ARTKul1NF\nQukGMeJa1xlXzEk2K1sT7inGHEHTO5KD4RyyVFaDTnhWtvDfmDZt5R/Ipfc7KMmc\ndObDKqWe/TGoKM5noj3dvafhNFZ9mDCCBAQwggLsoAMCAQICCBh6qajCliEMMA0G\nCSqGSIb3DQEBCwUAMGIxCzAJBgNVBAYTAlVTMRMwEQYDVQQKEwpBcHBsZSBJbmMu\nMSYwJAYDVQQLEx1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEWMBQGA1UE\nAxMNQXBwbGUgUm9vdCBDQTAeFw0xMjAyMDEyMjEyMTVaFw0yNzAyMDEyMjEyMTVa\nMHkxLTArBgNVBAMMJERldmVsb3BlciBJRCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\neTEmMCQGA1UECwwdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxEzARBgNV\nBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVTMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAiXZPBluaQe6lIysCo1/Xcz/ANbCLhAo/BiR/p5U/608Ok6+0\nDtDIPuVtGLMf6IlHv9cJCOT/VpgpFeeUnbk1owrNtMDh4mD0yuwpeEVpaWBrX4qS\n/J4j5jrCIrMxTxy68rY0WULusKkCAxiRBLazeC4zH4BFDUVvuw5aW38659gI1wsO\nMm37hjbkbKvEEYpwhCaqn0TR8bjGe5QXm0j3C1gWuiPFnxU5fspdwzJfD+BSf0Dq\nvqwIZJVbyRqc5YDKH2pEHGw+xLAmHx3se69eoGo9R6lYEjE/IHYobR0csMJOEWkm\ni8vW0BGCyU4P8VZ00NkIS2Z4oqusp+LSTIdZyQIDAQABo4GmMIGjMB0GA1UdDgQW\nBBRXF+2iz9x8mKEQ4Py+hy0s8uMXVDAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQY\nMBaAFCvQaUeUdgn+9GuNLkCm90dNfwheMC4GA1UdHwQnMCUwI6AhoB+GHWh0dHA6\nLy9jcmwuYXBwbGUuY29tL3Jvb3QuY3JsMA4GA1UdDwEB/wQEAwIBhjAQBgoqhkiG\n92NkBgIGBAIFADANBgkqhkiG9w0BAQsFAAOCAQEAQjl0a6HcxqSPNyqMsx0KRLyV\nLH+8WbisYfsHkJIyudS/O8FQOWpEdKLsWx9w5ardS2wcI3EtX9HFk77um4pwZYKd\nFuMaEBeJLajN/Qx4WEkMKH8z7gB6G7R2rLa1u0/fqBudyBmXSgtWZy/CPrazxIM6\n8HdtdMQuI1HumqUDb2D0pUinBsK7WuIfH0ZFfuSX9ScQtyAicm9y2sZQdcU9JY9d\nowDpnzaMSDmPszvqkIAulZpg9HjO9A4KUz6i+k/YHq6ElY0yvFZNiel4GOCsmkK6\nekYbhKKJzhToiNFYi/auVsQsBSpFrwvZS6kCDzSsiMdhVYlEySdzB+6C5U71cDGC\nAn8wggJ7AgEBMIGjMIGWMQswCQYDVQQGEwJVUzETMBEGA1UECgwKQXBwbGUgSW5j\nLjEsMCoGA1UECwwjQXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMx\nRDBCBgNVBAMMO0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zIENl\ncnRpZmljYXRpb24gQXV0aG9yaXR5Agh3mRQz7FJtYzAJBgUrDgMCGgUAoIGxMBgG\nCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTE4MDIwMTAx\nMTExNFowIwYJKoZIhvcNAQkEMRYEFNKi/xYPqnN6zp/RogVZBZ3ICGOBMFIGCSqG\nSIb3DQEJDzFFMEMwCgYIKoZIhvcNAwcwDgYIKoZIhvcNAwICAgCAMA0GCCqGSIb3\nDQMCAgFAMAcGBSsOAwIHMA0GCCqGSIb3DQMCAgEoMA0GCSqGSIb3DQEBAQUABIIB\nAJQtrcrRd/3PLS9rhey0RyU1ZRnuB4Ib+y/wAan3k+fRNpA70F9kaxxcme78eqho\nHH5rvizY4InvrG1wjtpYeickMHp+s0E51j1AbVxOgZ/UiEgjLRq9Dv5OCPgKoLaB\nlsyCj41baXvlqzXZ8RaP7Li2SPLpdksqLE5yegiN+yMIiEPfNAtmaRLN3CNnbbMf\nX1bF4ifgyhy3P1VGPPk+WTiQyu0VqySrlhz0Ux9+acB/TFUrymFEKxJ/7bM//4nL\nUpEQVlnj9rl3OYzhYgDsQgz0kGU+6UG7Iw6gB9xFAMeE/1Y5Xrs2UdjBVC9hkSy8\nr1+2rPF1yixiWjiORNk4kyU=\n-----END PKCS7-----\n\nRegards,\nCory\n\nOn Fri, Jan 12, 2018 at 5:14 AM, nullius via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On 2018-01-12 at 08:54:12 +0000, Peter Todd <pete at petertodd.org> wrote:\n>>\n>> While a clunky way to do it, you can use the `-signer` option to tell\n>> OpenSSL to write the signer's certificate to a file. That certificate can\n>> then be compared to the one from the repo, which was still in the repo as of\n>> the (signed!) v0.15.1 tag.\n>>\n>>\n>> Fun fact: OpenTimestamps has git integration, which means you can extract\n>> a OTS proof from 2016 for that certificate from the repo:\n>>\n>>    $ git checkout v0.15.1\n>>    $ ots git-extract share/certs/BitcoinFoundation_Apple_Cert.pem\n>> share/certs/BitcoinFoundation_Apple_Cert.pem.ots\n>> 36f60a5d5b1bc9a12b87d6475e3245b8236775e4\n>>    $ ots verify share/certs/BitcoinFoundation_Apple_Cert.pem.ots\n>>    Assuming target filename is\n>> 'share/certs/BitcoinFoundation_Apple_Cert.pem'\n>>    Success! Bitcoin attests data existed as of Thu Oct 13 14:08:59 2016\n>> EDT\n>>\n>> Homework problem: write a paragraph explaining how the proof generated by\n>> the above three commands are crypto snakeoil that proved little. :)\n>\n>\n> It says, \u201cBitcoin attests data existed\u201d.  Within the scope of those three\n> commands, I don\u2019t see any proof of who put it there.  Does OTS check the PGP\n> signatures on *commits* when it does that `git-extract`?  The signature on\n> the v0.15.1 tag is irrelevant to that question; and FWIW, I don\u2019t see *that*\n> signature being verified here, either.\n> Second paragraph:  Moreover, with the breaking of SHA-1, it *may* be\n> feasible for some scenario to play out involving two different PEMs with the\n> same hash, but different public keys (and thus different corresponding\n> private keys).  I don\u2019t know off the top of my head if somewhere could be\n> found to stash the magic bits; and the overall scenario would need to be a\n> bit convoluted.  I think a malicious committer who lacked access to the\n> signing key *may* be able to create a collision between the real\n> certificate, and a certificate as for which he has the private key\u2014then\n> switch them, later.  Maybe.  I would not discount the possibility off-hand.\n> OTS would prove nothing, if he had the foresight to obtain timestamps\n> proving that both certificates existed at the appropriate time (which they\n> would need to anyway; it is not a post facto preimage attack).\n>\n>> [...]\n>>\n>> What's nice about OpenPGP's \"clearsigned\" format is how it ignores\n>> whitespace; a replica of that might be a nice thing for OTS to be able to do\n>> too. Though that's on low priority, as there's some tricky design choices(1)\n>> to be made about how to nicely nest clearsigned PGP within OTS.\n>>\n>>\n>> 1) For example, I recently found a security hole related to clearsigned\n>> PGP recently. Basically the issue was that gpg --verify will return true on\n>> a file that looks like the following:\n>>\n>>    1d7a363ce12430881ec56c9cf1409c49c491043618e598c356e2959040872f5a\n>> foo-v2.0.tar.gz\n>>    -----BEGIN PGP SIGNED MESSAGE-----\n>>    Hash: SHA256\n>>\n>>    e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n>> foo-v1.0.tar.gz\n>>    -----BEGIN PGP SIGNATURE-----\n>>\n>>    <snip pgp stuff>\n>>    -----END PGP SIGNATURE-----\n>>\n>> The system I was auditing then did something like this to verify that the\n>> file was signed:\n>>\n>>    set -e # exit immediately on error\n>>    gpg --verify SHA256SUMS.asc\n>>    cat SHA256SUMS.asc | grep foo-v2.0.tar.gz\n>>    <do installation>\n>>\n>> While it makes it a bit less user friendly, the fact that PKCS7's encoding\n>> made it impossible to see the message you signed until it's been properly\n>> verified is a good thing re: security.\n>\n>\n> Potential solutions using PGP:\n>\n> 0. Don\u2019t use clearsigning.\n>\n> 1. Use a detached signature.\n>\n> 2. Use `gpg --verify -o -` and pipe that to `grep`, rather than illogically\n> separating verification from use of data.  (By the way, where is the *hash*\n> verified?  Was `grep` piped to `sha256sum -c`?)\n>\n> 3. Have shell scripts written by somebody who knows how to think about\n> security, and/or who knows how to RTFM; quoting gpg(1):\n>\n>> Note: When verifying a cleartext signature, gpg verifies only what  makes\n>> up the cleartext signed data and not any extra data outside of the cleartext\n>> signature or the header lines directly following the dash marker line.  The\n>> option --output may be used to write out the actual signed data, but there\n>> are other pitfalls with this format as well.  It is suggested to avoid\n>> cleartext signatures in favor of detached signatures.\n>\n>\n> 4. Obtain an audit from Peter Todd.\n>\n>> And yes, I checked: Bitcoin Core's contrib/verifybinaries/verify.sh isn't\n>> vulnerable to this mistake. :)\n>\n>\n> P.S., oh my!  *Unsigned data:*\n>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> --\n> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C\n> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:\n> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)\n> \u201c\u2018If you\u2019re not doing anything wrong, you have nothing to hide.\u2019\n> No!  Because I do nothing wrong, I have nothing to show.\u201d \u2014 nullius\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "New Bitcoin Core macOS signing key",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Cory Fields"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 11388
        }
    },
    {
        "title": "[bitcoin-dev] RBF Wallet Algorithms (Was: Transaction Merging (bip125 relaxation))",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-02-04T22:24:36",
                "message_text_only": "Good Morning Rhavar,\n\nI have been trying to conceptualize an algorithm precisely for RBF, and I agree that \"tracking the mess\" is a significant issue...\n\n> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do \"transaction merging\" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.\n>\n> From a \"coin selection\" point of view, this was significantly easier than\n> I had anticipated. I was able to encode the rules in my linear model and\n> feed in all my unspent and in-flight transactions and it can solve it without difficulty.\n>\n> However, the real problem is tracking the mess. Consider this sequence of events:\n> 1) I have unconfirmed transaction A\n> 2) I replace it with B, which pays John 1 BTC\n> 3) Transaction A gets confirmed\n>\n> So now I still owe John 1 BTC, however it's not immediately clear if\n> it's safe to send to him without waiting $n transactions. However even\n> for a small $n, this breaks my promise to pay him immediately.\n>\n> One possible solution is to only consider a transaction \"replaceable\" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.\n>\n> However, this will only work <50% of the time for me (most transactions\n> don't have change) and opens a pandora's box of complexity.\n\nFor this example, I believe it is possible to assure correct operation without changes to the current RBF policy.\n\nPresumably, the problematic sequence of events is this:\n\n1.  You need to pay Paul.\n2.  You make transaction A that pays to Paul.  It has no change output.\n3.  You need to pay John.\n4.  You see transaction A is unconfirmed.  Using A as basis, you make transaction B that pays to Paul, John.  It replaces A.\n5.  Transaction A confirms once (because the B transaction did not propagate to the lucky miner quickly enough)\n6.  You still have a pending commitment to pay John, so you make a transaction C that pays to John.\n7.  A reorg occurs, transaction A is removed from history.\n8.  Transaction B and transaction C confirm, double-paying John.\n\nThis can be fixed by ensuring that transaction C is incompatible with B, but compatible with A.\n\nBy \"compatibility\", we mean, \"A transaction T is incompatible with U if T cannot confirm if U confirms, and U cannot confirm if T confirms.\"\n\nIf transaction A has no change output, then in order for A to be incompatible with B, with B paying both Paul and John, means that B has more spent inputs than A.  Else where would the extra funds to pay John come from? (assuming you are not taking from Paul to pay John)\n\nIf so, it means that there is some input that B spends, which A does not spend.\n\nSo we can make a transaction C that spends this input (the one which B spends that A does not spend).  This makes C compatible with A, but incompatible with B.\n\nSo you can still work, even without a change output on A, to ensure that your transaction C cannot be confirmed if B confirms.\n\nThus:\n\n1.  If A has some change output, ensure C spends that output.  Presumably if B is incompatible with A (after all, you tried to replace A with B), then C is incompatible with B as C is dependent on A confirming.\n2.  If A has no change output, then if you increased your spending to make transaction B, then logically B has some input that is not in A (otherwise where would the extra funds have come from...).  Then ensure C spends that input of B that is not in A, making it directly incompatible with B.\n\nThis ensures that either A+C confirm, or B confirms.\n\n(Again, the complications are considerable! We can only show that it is possible in theory, but whether it is feasible in practice to implement in some program that can be debugged and maintained  is another issue)\n\nA vague idea I have formed is to use some sort of vector of candidate TXOs you control.  Items are appended to this vector lazily as per your coin policy.  Transactions mark how far in this vector they spend (i.e. a high-water mark for that transaction).  If a previous confirmed transaction you wrote has a change output, you always use that change output and try to get more coins from this vector (starting after the previous confirmed transaction high-water mark) if the change output is not enough.  If a previous confirmed transaction you wrote has no change output, then you get more coins from this vector (again starting from the previous confirmed transaction high-water mark).  The vector is extended lazily from your set of controlled coins.  Older entries in this vector may be dropped once transactions confirm deeply enough that it is unlikely to be reorged (say 144 blocks); the exact policy is that if a transaction confirms deeply enough, then everything from its high-waiter mark to below can be pruned from this vector.\n\nThe above vague idea precludes you from reoptimizing transactions, however; your replacements either have the same set of inputs, or a strict superset of inputs, as the previous transaction.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180204/fbc371ac/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "RBF Wallet Algorithms (Was: Transaction Merging (bip125 relaxation))",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5418
        }
    },
    {
        "title": "[bitcoin-dev] Graftroot: Private and efficient surrogate scripts under the taproot assumption",
        "thread_messages": [
            {
                "author": "Gregory Maxwell",
                "date": "2018-02-05T05:58:43",
                "message_text_only": "In my post on taproot I showed a simple commitment scheme for scripts\nthat is very efficient that there exists some collection of pubkeys\n(like an M-of-N or even N-of-N) whos authorization is an acceptable\nalternative to whatever other conditions we might want to impose on a\ncoin.  If this holds then when spends happen via the plain signature\npath the existence of the alternative is never revealed, providing\nprivacy with improved efficiency compared to not being private at all.\n\nTaproot suffers from a limitation that it only natively provides for\none alternative.  Trees or cascades of taproots can be done, but they\nhave less privacy and efficiency than just a single level. E.g. a tree\ncommitment has overhead that grows with the log of the number of\nalternatives.\n\nHowever, under the taproot assumption-- that there exists some\nmonotone function on plain public keys and nothing else that is\nsufficient to authorize a transaction-- we can do even better.\n\nWith graftroot, the participants establish a threshold key, optionally\nwith a taproot alternative, just as they do with taproot.  At any\ntime, they can delegate their ability to sign to a surrogate script by\nsigning that script (and just the script) with their taproot key, and\nsharing that delegation with whomever they choose.   Later, when it\ncomes time to spend the coin, if the signers aren't available and the\nscript must be used,  the redeeming party does whatever is required to\nsatisfy the script (e.g. provides their own signature and a timelock,\nor whatnot)  and presents that information along with the signer's\nsignature of the script.\n\nThe result is that instead of allowing only one alternative an\nunlimited number of alternatives can be provided. All are executed\nwith equal efficiency to a single alternative, and the number of them\nis hidden without overhead.  Alternatives can be provided for existing\ncoins too, without requiring they get moved-- movement is only\nrequired to destroy the ability to use alternatives by changing keys.\n\nAllowing this kind of delegation makes sense because the same signers\ncould have just signed the transaction outright. The new script simply\nstands in for them, if they're not available or cooperating. No\nspecial conditions are needed outside of the surrogate script on when\nthe surrogate is allowed, because they can be written inside the\nsurrogate.\n\nWe've discussed delegation in script back to at least 2012-- with\nspeculation that enabling it may have been an original motivation\nbehind codeseperator. ... but these design discussions have gotten\nmired in how to express and connect the levels of delegation.  But the\ncase where delegation is accomplished with a simple unconditional\nsignature is an especially simple case, and under the taproot\nassumption the only case that is ever needed.\n\nA naive implementation of this idea requires a complete signature\nevery time a surrogate is used, which means 64 bytes of data (assuming\n128 bit ECC). This is higher overhead than taproot.\n\nHowever,  the non-interactive schnorr aggregation trick[1] can be\napplied to merge the S values of all graftroots and signatures in a\ntransaction into a single aggregate.  With this approach only a single\nR value for each graftroot need be published, lowering the overhead to\n~32 bytes-- the same as taproot. This has a side benefit of binding\nthe published grafts to a particular transaction, which might help\navoid some screwups.\n\nIn cases where the taproot assumption doesn't hold, taproot can still\nbe used by setting the public key to a NUMS point, which preserves\nprivacy (e.g. you can't distinguish txn where the key could never have\nbeen used.)  A similar thing can be done for graftroot if the\nsignature is not a proof of knowledge (commits to the public key): you\nselect the signature in a NUMS manner, and then recover the applicable\npublic key.  Though this can't be done if the signature is a PoK, and\nit's probably a pretty good idea to make it a PoK.\n\nThe primary limitation of this approach compared to taproot\nalternatives and trees is that it requires that anyone who wants to\nmake use of a particular surrogate to interact with the participants\nand store the resulting signature because a single party couldn't\ncompute it again on their own from public data. For trees and taproot\nalternatives, the alternatives can be setup without any interaction\nwith the participants. The primary advantage is that it scales to any\nnumber of alternatives with small constant overhead, can be delegated\nafter the fact, and can still be spent by the participants without\noverhead.\n\nSummarizing:   A coin's authorizing contract is decomposed into a top\nlevel OR between a monotone function of pubkeys (such as N of N) and\nany number of arbitrary surrogate scripts which are acceptable\nauthorizations.  A key aggregate (see [2]) is formed, and is used to\nsign each of the the surrogates.  Participants save these signatures.\nLater, when it comes time to spend the coin, if the pubkey holders are\nunwilling or unavailable, the spender presents and satisfies the\nrelevant surrogate along with it's signature R-value and\nnon-interactively aggregates the S-value into the transaction's\noverall aggregate signature.  The result is 0-overhead if the signers\ncooperate, or ~32-byte overhead (plus the script) if they don't.  This\navoids the log() overhead of tree based schemes, and allows delegation\nto take place before or after the fact but requires storage.  The\npotential for unexpected surrogate replay if keys are reused in\nfoolish ways also needs to be kept in mind, though it may be somewhat\nmitigated by aggregation. The existence of unused surrogates is\ncompletely hidden.\n\nI believe this general design is simple and powerful enough that it\navoids the rathole that earlier delegation discussions have suffered.\n\n\n\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014272.html\nAnd the secure construction at:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014308.html\n\n[2] https://eprint.iacr.org/2018/068"
            },
            {
                "author": "Ryan Grant",
                "date": "2018-02-05T15:56:23",
                "message_text_only": "Am I reading correctly that this allows unilateral key rotation (to a\npreviously unknown key), without invalidating the interests of other\nparties in the existing multisig (or even requiring any on-chain\ntransaction), at the cost of storing the signed delegation?"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-02-05T19:58:24",
                "message_text_only": "On Mon, Feb 5, 2018 at 3:56 PM, Ryan Grant <bitcoin-dev at rgrant.org> wrote:\n> Am I reading correctly that this allows unilateral key rotation (to a\n> previously unknown key), without invalidating the interests of other\n> parties in the existing multisig (or even requiring any on-chain\n> transaction), at the cost of storing the signed delegation?\n\nYes, though I'd avoid the word rotation because as you note it doesn't\ninvalidate the interests of any key, the original setup remains able\nto sign.  You could allow a new key of yours (plus everyone else) to\nsign, assuming the other parties agree... but the old one could also\nstill sign."
            },
            {
                "author": "Jeremy",
                "date": "2018-02-09T07:29:58",
                "message_text_only": "This might be unpopular because of bad re-org behavior, but I believe the\nutility of this construction can be improved if we introduce functionality\nthat makes a script invalid after a certain time (correct me if I'm wrong,\nI believe all current timelocks are valid after a certain time and invalid\nbefore, this is the inverse).\n\nThen you can exclude old delegates by timing/block height arguments, or\neven pre-sign delegates for different periods of time (e.g., if this\nhappens in the next 100 blocks require y, before the next 1000 blocks but\nafter the first 100 require z, etc).\n\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\nOn Mon, Feb 5, 2018 at 11:58 AM, Gregory Maxwell via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Feb 5, 2018 at 3:56 PM, Ryan Grant <bitcoin-dev at rgrant.org> wrote:\n> > Am I reading correctly that this allows unilateral key rotation (to a\n> > previously unknown key), without invalidating the interests of other\n> > parties in the existing multisig (or even requiring any on-chain\n> > transaction), at the cost of storing the signed delegation?\n>\n> Yes, though I'd avoid the word rotation because as you note it doesn't\n> invalidate the interests of any key, the original setup remains able\n> to sign.  You could allow a new key of yours (plus everyone else) to\n> sign, assuming the other parties agree... but the old one could also\n> still sign.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180208/916acbdb/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2018-02-09T07:42:52",
                "message_text_only": "I'm also highly interested in the case where you sign a delegate\nconditional on another delegate being signed, e.g. a bilateral agreement.\n\nIn order for this to work nicely you also need internally something like\nsegwit so that you can refer to one side's delegation by a signature-stable\nidentity.\n\nI don't have a suggestion of a nice way to do this at this time, but will\nstew on it.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\nOn Thu, Feb 8, 2018 at 11:29 PM, Jeremy <jlrubin at mit.edu> wrote:\n\n> This might be unpopular because of bad re-org behavior, but I believe the\n> utility of this construction can be improved if we introduce functionality\n> that makes a script invalid after a certain time (correct me if I'm\n> wrong, I believe all current timelocks are valid after a certain time and\n> invalid before, this is the inverse).\n>\n> Then you can exclude old delegates by timing/block height arguments, or\n> even pre-sign delegates for different periods of time (e.g., if this\n> happens in the next 100 blocks require y, before the next 1000 blocks but\n> after the first 100 require z, etc).\n>\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n> On Mon, Feb 5, 2018 at 11:58 AM, Gregory Maxwell via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Mon, Feb 5, 2018 at 3:56 PM, Ryan Grant <bitcoin-dev at rgrant.org>\n>> wrote:\n>> > Am I reading correctly that this allows unilateral key rotation (to a\n>> > previously unknown key), without invalidating the interests of other\n>> > parties in the existing multisig (or even requiring any on-chain\n>> > transaction), at the cost of storing the signed delegation?\n>>\n>> Yes, though I'd avoid the word rotation because as you note it doesn't\n>> invalidate the interests of any key, the original setup remains able\n>> to sign.  You could allow a new key of yours (plus everyone else) to\n>> sign, assuming the other parties agree... but the old one could also\n>> still sign.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180208/75f279de/attachment-0001.html>"
            },
            {
                "author": "Ryan Grant",
                "date": "2018-02-22T12:19:36",
                "message_text_only": "On Fri, Feb 9, 2018 at 7:29 AM, Jeremy <jlrubin at mit.edu> wrote:\n> utility of this construction can be improved if we introduce functionality\n> that makes a script invalid after a certain time\n\nTagging this thread with \"nExpiryTime\".  Search archives for more."
            },
            {
                "author": "Daniel Edgecumbe",
                "date": "2018-02-22T19:44:21",
                "message_text_only": "> However,  the non-interactive schnorr aggregation trick[1] can be\napplied to merge the S values of all graftroots and signatures in a\ntransaction into a single aggregate.  With this approach only a single\nR value for each graftroot need be published, lowering the overhead to\n~32 bytes-- the same as taproot. This has a side benefit of binding\nthe published grafts to a particular transaction, which might help\navoid some screwups.\n\nI don't think that binding grafts to a particular transaction requires this aggregation.\nIt seems to me that you could just sign H(txid, script) rather than H(script).\nI'm not aware of whether this would break aggregation.\n\n---\nDaniel Edgecumbe / esotericnonsense\nesotericnonsense at esotericnonsense.com\nhttps://esotericnonsense.com\nhttps://danedgecumbe.com"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-02-24T18:58:59",
                "message_text_only": "On Thu, Feb 22, 2018 at 7:44 PM, Daniel Edgecumbe via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I don't think that binding grafts to a particular transaction requires this aggregation.\n> It seems to me that you could just sign H(txid, script) rather than H(script).\n> I'm not aware of whether this would break aggregation.\n\n\nThat would require that you know the txid in advance. Sometimes you\ndo-- and a graftroot sighash flag could handle that... but usually you\nwouldn't.  The case where you already do know it can sort of be\ncovered today without using the graftroot:  Sign a transaction\nspending the multisig coin to the graft.  This isn't a strict\nalternative however, because it's not atomic: you could imagine that\ntxn being announced and then the graft not being spent, while someone\nwould like to spend a different graft.  That non-atomiticity could be\naddressed by making the graft spends an OR of all the other graft\nspends but that isn't scalable or private.  Regardless, still doesn't\nwork if the graft isn't created after the fact.\n\nThe aggregation bit has the property of working just in time, even on\ngrafts created in advance."
            }
        ],
        "thread_summary": {
            "title": "Graftroot: Private and efficient surrogate scripts under the taproot assumption",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "Jeremy",
                "Gregory Maxwell",
                "Daniel Edgecumbe"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 13418
        }
    },
    {
        "title": "[bitcoin-dev] Taproot: Privacy preserving switchable scripting",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-02-05T09:27:07",
                "message_text_only": "Good morning Greg,\n\nI am probably being exceedingly naive, but I would like to compare Taproot to a generalization of funding transactions.\n\nFor instance, CoinSwapCS:\n\n1.  It uses an HTLC in an off-chain transaction, and a funding transaction TX0 whose output is a \"simple\" 2-of-2.\n2.  The HTLC tx spends this 2-of-2.\n3.  If a branch of the HTLC succeeds, the parties contact each other and create a replacement of the (unconfirmed and unbroadcasted but signed) HTLC tx that assigns the funds to the correct owners.\n4.  If the above step fails, individual parties can in isolation publish the HTLC tx and provide its requirements.\n\nBoth of #3 and #4 above, appear to me naively as similar to the two \"top\" cases of Taproot, i.e. either C is signed by all parties, or S is revealed and fulfilled.\n\nThe important bits of this \"generalized funding transaction\" pattern is:\n\n1. The contract that enforces correct behavior spends an unsigned and unbroadcasted funding transaction output (which requires N-of-N).\n2. The enforcement contract is signed first by all parties before the funding transaction is signed by anybody.  This is possible due to SegWit.\n3.  Then, when all parties are sure they have the fully-signed smart contract, the initial funding transaction is signed and broadcast and confirmed.\n4.  When the condition that the contract requires is achieved, then the parties contact each other and try to jointly create a simpler transaction that spends the funding transaction directly to whoever gets the money in the correct proportion.  This avoids publishing the smart contract onchain, and looks like an ordinary N-of-N spend.\n5.  If they fail to get all required signatures for any reason, any party can publish the enforcement contract transaction and subsequently fulfill its conditions in another transaction.\n\nAdmittedly, Taproot if added to the consensus would reduce the number of transactions by 1 in the \"S is revealed\" case.\nBut the \"generalized funding transaction\" pattern is already possible today, and MuSig (to my limited understanding) can be used to make it indistinguishable from 1-of-1 (so, possibly, make it P2WPKH?).\n\n\n(I am probably neglecting something very simple and direct, however...)\n\nRegards,\nZmnSCPxj\n\n-------- Original Message --------\n On January 23, 2018 8:30 AM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main\n> areas: efficiency and privacy. Efficiency because unexecuted forks of\n> a script can avoid ever hitting the chain, and privacy because hiding\n> unexecuted code leaves scripts indistinguishable to the extent that\n> their only differences are in the unexecuted parts.\n>\n> As Mark Friedenbach and others have pointed out before it is almost\n> always the case that interesting scripts have a logical top level\n> branch which allows satisfaction of the contract with nothing other\n> than a signature by all parties.  Other branches would only be used\n> where some participant is failing to cooperate. More strongly stated,\n> I believe that any contract with a fixed finite participant set\n> upfront can be and should be represented as an OR between an N-of-N\n> and whatever more complex contract you might want to represent.\n>\n> One point that comes up while talking about merkelized scripts is can\n> we go about making fancier contract use cases as indistinguishable as\n> possible from the most common and boring payments. Otherwise, if the\n> anonymity set of fancy usage is only other fancy usage it may not be\n> very large in practice. One suggestion has been that ordinary\n> checksig-only scripts should include a dummy branch for the rest of\n> the tree (e.g. a random value hash), making it look like there are\n> potentially alternative rules when there aren't really.  The negative\n> side of this is an additional 32-byte overhead for the overwhelmingly\n> common case which doesn't need it.  I think the privacy gains are\n> worth doing such a thing, but different people reason differently\n> about these trade-offs.\n>\n> It turns out, however, that there is no need to make a trade-off.  The\n> special case of a top level \"threshold-signature OR\n> arbitrary-conditions\" can be made indistinguishable from a normal\n> one-party signature, with no overhead at all, with a special\n> delegating CHECKSIG which I call Taproot.\n>\n> Let's say we want to create a coin that can be redeemed by either\n> Alice && Bob   or by CSV-timelock && Bob.\n>\n> Alice has public A, Bob has pubkey B.\n>\n> We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to\n> protect against rogue key attacks you may want to use the MuSig key\n> aggregation function [1])\n>\n> We form our timelock script S =  \"<timeout> OP_CSV OP_DROP B OP_CHECKSIGVERIFY\"\n>\n> Now we tweak C to produce P which is the key we'll publish: P = C + H(C||S)G.\n>\n> (This is the attack hardened pay-to-contract construction described in [2])\n>\n> Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].\n>\n> Now Alice and Bob-- assuming they are both online and agree about the\n> resolution of their contract-- can jointly form a 2 of 2 signature for\n> P, and spend as if it were a payment to a single party (one of them\n> just needs to add H(C||S) to their private key).\n>\n> Alternatively, the Taproot consensus rules would allow this script to\n> be satisfied by someone who provides the network with C (the original\n> combined pubkey), S, and does whatever S requires-- e.g. passes the\n> CSV check and provides Bob's signature. With this information the\n> network can verify that C + H(C||S) == P.\n>\n> So in the all-sign case there is zero overhead; and no one can tell\n> that the contract alternative exists. In the alternative redemption\n> branch the only overhead is revealing the original combined pubkey\n> and, of course, the existence of the contract is made public.\n>\n> This composes just fine with whatever other merkelized script system\n> we might care to use, as the S can be whatever kind of data we want,\n> including the root of some tree.\n>\n> My example shows 2-of-2 but it works the same for any number of\n> participants (and with setup interaction any threshold of\n> participants, so long as you don't mind an inability to tell which\n> members signed off).\n>\n> The verification computational complexity of signature path is\n> obviously the same as any other plain signature (since its\n> indistinguishable). Verification of the branch redemption requires a\n> hash and a multiplication with a constant point which is strictly more\n> efficient than a signature verification and could be efficiently fused\n> into batch signature validation.\n>\n> The nearest competitor to this idea that I can come up with would\n> supporting a simple delegation where the output can be spent by the\n> named key, or a spending transaction could provide a script along with\n> a signature of that script by the named key, delegating control to the\n> signed script. Before paying into that escrow Alice/Bob would\n> construct this signature. This idea is equally efficient in the common\n> case, but larger and slower to verify in the alternative spend case.\n> Setting up the signature requires additional interaction between\n> participants and the resulting signature must be durably stored and\n> couldn't just be recomputed using single-party information.\n>\n> I believe this construction will allow the largest possible anonymity\n> set for fixed party smart contracts by making them look like the\n> simplest possible payments. It accomplishes this without any overhead\n> in the common case, invoking any sketchy or impractical techniques,\n> requiring extra rounds of interaction between contract participants,\n> and without requiring the durable storage of other data.\n>\n>\n> [1] https://eprint.iacr.org/2018/068\n> [2] https://blockstream.com/sidechains.pdf Appendix A\n>\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            }
        ],
        "thread_summary": {
            "title": "Taproot: Privacy preserving switchable scripting",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8026
        }
    },
    {
        "title": "[bitcoin-dev] NIST 8202 Blockchain Technology Overview",
        "thread_messages": [
            {
                "author": "CANNON",
                "date": "2018-02-06T02:08:24",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 01/31/2018 11:16 AM, Damian Williamson wrote:\n> I disagree with the correctness of the following statement:\n> \n> \n>> Rather than implementing the SegWit changes, the developers of Bitcoin Cash decided to simply increase the blocksize.\n> \n> \n> I would suggest \"Rather than being satisfied with the implementation of SegWit changes alone, the developers of\n> Bitcoin Cash decided to also increase the blocksize.\n> \n> \n> Regards,\n> \n> Damian Williamson\n\nYou do realize that segwit includes many improvements of which are unrelated to scaling? These same improvements of which\nsimply increasing the blocksize alone would not fix or enable. Segwit is not just a blocksize increase.\nBitcoin Cash, while increasing the blocksize directly, from my understanding has yet to implement the\nimprovements and capabilities that segwit enables.\n\nOne example being, with transactions hashes being able to be calculated in advanced prior to signing\n(due to the signature being in different section than that used\nto calculate the transaction ID) it is possible to create transaction trees, enhanced smart contracts, trustless mixing protocols,\nmicropayment networks, etc...\n\nSegwit also increases the security of signatures.\n\nThere are lots of other things segregated witness enables as well.\n\nBy saying \"..segwit changes alone.... decided to also...\" Bitcoin Cash has not implemented segwit. Bitcoin Cash only\nincreased the blocksize.\n\nthat wording above at least from the way I read it, seems to imply that Bitcoin Cash has segwit.\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBCgAGBQJaeQ3IAAoJEAYDai9lH2mwKkQP/3dgYApq1qv2lGIyZIdeN9SE\nD5AuXPqFQYAoMwhC0RPNQU/jUisKIyd6zm4XCIm6KPufCtXkjfH9FLhd0ThbCTcy\nGk+pYYRBzSuBZdPBKg0DHu7alRETtxbdtUI0zDfERt1FFZb+HmcDcGTfwdVci3fa\njBiFXq1R+myMW5xdB44dipSk5kBhcpx2zitr1bIA4rF11QbxKAmzU7iPdRpA+PXz\ngB9NImc1Dbz+TEA50tdq3v9Ov3x7m7F+QtBnqyLAigJh6XKa6guCfwKIGoawRGwZ\nv2ur7T+Qh3KGRXCBlHnxgtFte16wHagwvsVgE5EEmJR0yJUc/4XU2kCGANVNDZ/P\npphqk8pruQ5rjQ8S+s6i5XG8oHVSB2fDh56NvPY7msA72j+Gk+XneV2eJbEAdjhb\n9Ci7u1uPJL3pb3c/ZOwQvpIRV3tRjlh0DertWkd3Li5RZLO3uFvBTxNxrni6+9bf\n/cmAOwfHjoUp8BX/nvgMjpIDCoEu+Rv9IO/ok3s3mX300JbczAdGbXbsPTE5G+DI\nRB1kSmszwst8wOlOAsdVqk/iKRJdN9daTGGN6aE/wjkpSg8rW9BOaoI2X9t4oXCU\n+oe/WlgkxhxPcNyhKpLeeYVe6nFX2fjU+THyyiAq/LJ/qHU/brKpXc4NesCVHhQP\nBBlxiN0E4gndMGs/Lx89\n=+UCK\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Damian Williamson",
                "date": "2018-02-06T07:07:26",
                "message_text_only": "Then you have my apology, I will not claim to be any kind of advocate or user of Bitcoin Cash but *had* understood that segwith had been enabled. Clearly my mistake.\n\n\nRegards,\n\nDamian Williamson\n\n________________________________\nFrom: CANNON <cannon at cannon-ciota.info>\nSent: Tuesday, 6 February 2018 1:08:24 PM\nTo: Damian Williamson; Bitcoin Protocol Discussion\nSubject: Re: [bitcoin-dev] NIST 8202 Blockchain Technology Overview\n\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nOn 01/31/2018 11:16 AM, Damian Williamson wrote:\n> I disagree with the correctness of the following statement:\n>\n>\n>> Rather than implementing the SegWit changes, the developers of Bitcoin Cash decided to simply increase the blocksize.\n>\n>\n> I would suggest \"Rather than being satisfied with the implementation of SegWit changes alone, the developers of\n> Bitcoin Cash decided to also increase the blocksize.\n>\n>\n> Regards,\n>\n> Damian Williamson\n\nYou do realize that segwit includes many improvements of which are unrelated to scaling? These same improvements of which\nsimply increasing the blocksize alone would not fix or enable. Segwit is not just a blocksize increase.\nBitcoin Cash, while increasing the blocksize directly, from my understanding has yet to implement the\nimprovements and capabilities that segwit enables.\n\nOne example being, with transactions hashes being able to be calculated in advanced prior to signing\n(due to the signature being in different section than that used\nto calculate the transaction ID) it is possible to create transaction trees, enhanced smart contracts, trustless mixing protocols,\nmicropayment networks, etc...\n\nSegwit also increases the security of signatures.\n\nThere are lots of other things segregated witness enables as well.\n\nBy saying \"..segwit changes alone.... decided to also...\" Bitcoin Cash has not implemented segwit. Bitcoin Cash only\nincreased the blocksize.\n\nthat wording above at least from the way I read it, seems to imply that Bitcoin Cash has segwit.\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBCgAGBQJaeQ3IAAoJEAYDai9lH2mwKkQP/3dgYApq1qv2lGIyZIdeN9SE\nD5AuXPqFQYAoMwhC0RPNQU/jUisKIyd6zm4XCIm6KPufCtXkjfH9FLhd0ThbCTcy\nGk+pYYRBzSuBZdPBKg0DHu7alRETtxbdtUI0zDfERt1FFZb+HmcDcGTfwdVci3fa\njBiFXq1R+myMW5xdB44dipSk5kBhcpx2zitr1bIA4rF11QbxKAmzU7iPdRpA+PXz\ngB9NImc1Dbz+TEA50tdq3v9Ov3x7m7F+QtBnqyLAigJh6XKa6guCfwKIGoawRGwZ\nv2ur7T+Qh3KGRXCBlHnxgtFte16wHagwvsVgE5EEmJR0yJUc/4XU2kCGANVNDZ/P\npphqk8pruQ5rjQ8S+s6i5XG8oHVSB2fDh56NvPY7msA72j+Gk+XneV2eJbEAdjhb\n9Ci7u1uPJL3pb3c/ZOwQvpIRV3tRjlh0DertWkd3Li5RZLO3uFvBTxNxrni6+9bf\n/cmAOwfHjoUp8BX/nvgMjpIDCoEu+Rv9IO/ok3s3mX300JbczAdGbXbsPTE5G+DI\nRB1kSmszwst8wOlOAsdVqk/iKRJdN9daTGGN6aE/wjkpSg8rW9BOaoI2X9t4oXCU\n+oe/WlgkxhxPcNyhKpLeeYVe6nFX2fjU+THyyiAq/LJ/qHU/brKpXc4NesCVHhQP\nBBlxiN0E4gndMGs/Lx89\n=+UCK\n-----END PGP SIGNATURE-----\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180206/752a41c7/attachment.html>"
            },
            {
                "author": "CANNON",
                "date": "2018-02-18T16:20:13",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nPardon my unproffesional tone in my original comment.\nBut thank you for passing on these corrections. This looks much better.\nI have a few comments that might lend to making this even more accurate or complete.\nIt is nice to see Bitcoin Cash use the proper ticket \"BCH\" and with\nclarrification that segregated witness  was a softfork (backwards compatible\nand optional to unupgraded nodes) instead of a hardfork. While segwit might\nseem to compact more transactions to unupgraded nodes still using the 1 MB\nblocksize limit (because signature data is stored outside of this legacy 1MB\nlimit), segwit is not actually more compact, but rather is a conservative blocksize\nincrease as a result of the new block space made available through segwit upgrade.\n\n(One question I do have, which I am going to ask on the bitcoin-dev mailing list, is\n\"Is the increased blockspace made available through SegWit limited to just witness data?\")\n\nSegwit is not just about increased blockspace or transaction capactity though, but\nalso has more advantages as a result of seperating the signature into a different\nsegment. More information can be found here https://bitcoincore.org/en/2016/01/26/segwit-benefits/\n\nOne advantage is with segwit seperating the signature data, advanced smart contracts and functions\non top of bitcoin can be used. This is due to transaction IDs being able to be calculated without\nsignatures, or before being signed.\n\nSegwit also increases signature security, and if I am correct enables signatures algorithms to be\nable to be upgraded via a softfork.\n\nSegwit also enables Lightning Network. Lightning Network upgrade to Bitcoin enables instant and really\ncheap transactions which can handle micropayments and massive scaling of throughput of transactions per second.\n\nWith micropayment networks such as Lightning Network, payments can be made off-chain, while still being enforced\nby and settled on the Bitcoin blockchain. The Bitcoin blockchain would act as a settlement or dispute layer. As\na result this would also result in freed up space on the bitcoin blockchain as well.\n\nThe political reasons which differ from the \"bitcoin cash\" crowd, and the \"bitcoin\" crowd is the long term vision\nof how to scale Bitcoin. The majority of the \"bitcoin cash\" crowd believes that scaling should be done by\nsimply raising the blocksize.\n\nThe majority of the \"bitcoin\" crowd, believes that increasing the blocksize to accomodate for all transactions like\nwhat \"bitcoin cash\" is doing, would lead to dangerous centralization of whom would able to operate a Bitcoin node.\nThis is due to the factors of both storage, and bandwidth which are needed to sync and store the blockchain by nodes.\n\nhttps://lightning.network/lightning-network-paper.pdf\nPaper:\nThe Bitcoin Lightning Network:\nScalable Off-Chain Instant Payments\nDRAFT Version 0.5.9.2\npage 2-3 outlines a good description of why increasing the blocksize to accomodate every global transaction as a scaling\nsolution is not feasible.\n\nIn summary,\nSo while the majority of the bitcoin crowd see micropayment channels and micropayment networks on higher layers as the\nnext step in scaling for handling majority of transactions, the \"bitcoin cash\" supporters prefer to simply increase the\nblocksize to handle all these transactions.\n\nI plan on reading the rest of this paper to see if I have any other things to add.\n\nCannon\nPGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\nEmail: cannon at cannon-ciota.info\nNOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n\nOn 01/29/2018 12:25 PM, XXXXXName removed for privacyXXXXXX  wrote:\n> Thank you for your comments. You, along with many others, expressed\n> concern on section 8.1.2. To help foster a full transparency approach\n> on the editing of this section, I am sending the revised section to\n> you for further comment.\n>\n> 8.1.2 Bitcoin Cash (BCH)\n> In 2017, Bitcoin users adopted an improvement proposal for Segregated Witness\n> (known as SegWit, where transactions are split into two segments:\n> transactional data, and signature data) through a soft fork. SegWit\n> made it possible to store transactional data in a more compact\n> form while maintaining backwards compatibility.  However, a group\n> of users had different opinions on how Bitcoin should evolve  and\n> developed a hard fork of the Bitcoin blockchain titled Bitcoin\n> Cash. Rather than implementing the SegWit changes, the developers\n> of Bitcoin Cash decided to simply increase the blocksize. When the\n> hard fork occurred, people had access to the same amount of coins\n> on Bitcoin and Bitcoin Cash.\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBCgAGBQJaiabpAAoJEAYDai9lH2mwOVMP/id1xlK7Z7Sx0YpRD0SOHPw2\nLy/C42TQKH/w5zW5NnzndFJhgrLw68FDHcNRXF7NkryJBH9uZC0PuK/F7p2fGfdc\nOAGAnz6dGJKi3aIXS9wyuLXCOBRuBN/PEOTiYk8t7HZ8n60Lsdo5zMxZhuS7QNdu\ng1w3UtosNNXU5+9l4LpcRfynXSCCnh1EnNHa9qTIjmCJIjphnpu/hGVAIYWrYwof\nAgcEMnv+KseYl6zWs7l5+nevAiDjxrUGEuHDUD9N0+kSLYv3Jsp8t++6q5gdtAI4\nxfbyZaIOrSidSe3iSNCnHYuf6TQ/+RstvgPd4VfPJsCK+jVxuJ5R3MC0b5+3cWGU\niUnYsPuX7lKE00B/tW8gVoyVtzYc4eiv8Tp50GeI4Gv6n4K+QuKM82S9DPfn1Ku8\n1vJpyL4LrZLkhmYGdTt2ajmg88wXpcySfaPa+xEY0bFziqEqnKgQgwAv1p3a5PbM\nWCU2x8Hrv8mMR/RCpo4I0QmkdZfM6ITHGRX/WZa3MVdHB8C1hqT574AKyWvzse4K\nYxIdbDZU0cjE5o7oOqTRAF1uR7XD2v8XAbyqQJaHi9z9n8l+CbyEXwNIHAWTkPPb\nOVGmnECTCxE0ZZAyaYWaAEnK3FnYEWlF92LKUmjQxD6+1YkCiEe0X2AwFibXw3at\nFPcZUkjeX+c7YDArq20l\n=Ryov\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "NIST 8202 Blockchain Technology Overview",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson",
                "CANNON"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 10855
        }
    },
    {
        "title": "[bitcoin-dev] BIP0008 clarification",
        "thread_messages": [
            {
                "author": "Helder Garcia",
                "date": "2018-02-08T02:49:45",
                "message_text_only": "Hi,\n\nI\u2019m trying to understand the process of signalling and activation of updates in bitcoin. Following BIP34, BIP9, I got into BIP8.\nIn my understanding of what I read there, an update will be activated even if the threshold of 95% signalling is not reached in STARTED state, as soon as blockchain height is equal or higher than timeout_height.\nIs my understanding correct? If so, isn\u2019t it a risk to activate a change even if you don\u2019t have the majority of hash power accepting it?\n\nThanks for your time,\n\u2014\nHelder Garcia"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-02-13T03:26:47",
                "message_text_only": "Good morning Helder,\n\n>Hi,\n>\n> I\u2019m trying to understand the process of signalling and activation of updates in bitcoin. Following BIP34, BIP9, I got into BIP8.\n> In my understanding of what I read there, an update will be activated even if the threshold of 95% signalling is not reached in STARTED state, as soon as blockchain height is equal or higher than timeout_height.\n> Is my understanding correct? If so, isn\u2019t it a risk to activate a change even if you don\u2019t have the majority of hash power accepting it?\n\nAssuming the update is widespread among economic actors, only miners who do not follow the more stringent rules of the update will suffer, as their blocks will have a high probability of not following those rules and thus will be implicitly rejected by economic actors.  Rational miners who follow the update, no matter how small their hash power share, would prefer the chain that economic actors will accept as real and would build only on blocks that follow updated rules strictly.\n\nIndeed, the time from STARTED to ACTIVE simply serves to let miners upgrade their software, as a concession that in the real world we cannot safely deploy new software in a single day.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "BIP0008 clarification",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Helder Garcia"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1724
        }
    },
    {
        "title": "[bitcoin-dev] Electrum Personal Server alpha release",
        "thread_messages": [
            {
                "author": "Chris Belcher",
                "date": "2018-02-08T16:51:59",
                "message_text_only": "Electrum is a popular bitcoin wallet, but it is not a full node wallet\nas it synchronizes itself using third-party Electrum servers. The\nservers must be trusted to verify the rules of bitcoin, they can trick\nElectrum wallets into accepting fake bitcoin transactions which, for\nexample, print infinite money. Bitcoin's security model requires that\nmost economic activity is backed by full nodes. The Electrum servers\nmust also be trusted with the user's privacy, as wallets send all their\nbitcoin addresses to the server. Spying on wallets is not much more\ncomplicated than simply grepping the server logs. Electrum wallets by\ndefault also connect to servers using their own IP address, linking it\nfurther to their revealed bitcoin addresses.\n\nA way to avoid these problems is for users to run their own Electrum\nserver and connect their wallets only to it. But this requires\nsignificant resource usage: the full unpruned blockchain, transaction\nindex and an extra address index, as well as more RAM and CPU usage\ncompared to just a full node. Servers are not well suited to being shut\ndown and started up again, they are typically always online.\n\nElectrum servers store a database of every bitcoin address ever used,\nwhich is inherently not scalable. This is resource-intensive and\ntherefore pushes users towards centralized solutions. An alternative way\nwould be to store only your own addresses and transactions.\n\nIntroducing Electrum Personal Server; an implementation of the Electrum\nserver protocol which fulfills the specific need of using the Electrum\nUI with full node verification and privacy, but without the heavyweight\nserver backend, for a single user. It allows the user to benefit from\nall of Bitcoin Core's resource-saving features like pruning, blocksonly\nand disabled txindex. All of Electrum's feature-richness like hardware\nwallet integration, multisignature wallets, offline signing, mnemonic\nrecovery phrases and so on can still be used, but backed by the user's\nown full node.\n\nAn alpha version of Electrum Personal Server can be found on the\nrepository: https://github.com/chris-belcher/electrum-personal-server\n\nBefore using, the wallet user must configure Electrum Personal Server\nwith their master public key and those addresses are imported into\nBitcoin Core as watch-only. If the wallet contains historical\ntransactions then it must be rescanned. One of Electrum's motivating\nfeatures is \"instant on\", which is therefore traded away when using\nElectrum Personal Server in return for full node verification and\nprivacy. Although if a brand new empty wallet is created there is no\nneed to rescan. A script like Electrum Personal Server is also well\nsuited to use private transaction broadcasting tech like dandelion or\nbroadcasting through tor.\n\nUsing Electrum with Electrum Personal Server is probably the most\nresource-efficient way right now to use a hardware wallet connected to\nyour own full node. People who make use of Blockstream Satellite could\nuse it to have an off-the-grid node connected to Electrum if that is\ntheir preferred wallet. In the situation of a traveller staying a cheap\nhostels, they could sync their node every couple of days to download\nrecent blocks and use Electrum. Hopefully this software can be part of\nthe plan to get full node wallets into the hands of as many people as\npossible.\n\nThe same kind of ideas could be applied to other lightweight wallets.\nFor example a full nodes can run on smartphones with pruning and\nblocksonly, then a similar script would allow the user to connect their\nSamourai Wallet, Breadwallet or GreenAddress app to their own full node.\n\n\nFurther Reading:\n\n* https://bitcointalk.org/index.php?topic=2664747.msg27179198\n*\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015030.html\n* https://bitcointalk.org/index.php?topic=1634967.0;all"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2018-02-08T20:22:38",
                "message_text_only": "Thanks Chris for sharing!\n\nI\u2019m following a similar approach where I\u2019d like to share a more detailed specification soon.\nSince Chris brought this up here, I\u2019d like to shed some lights on that, very similar approach.\n\nThe idea is to have a Bitcoin Core instance running either with internal (Core) support for the proposed interface or via an external script (python bridge) while the later is probably preferable (hardened HTTPd, less impact on Core).\n\nThe idea is, that the interface can create new wallets (needs dynamic loading/unloading of wallets in Core), add addresses to a wallet (== add watch-only addresses).\n\nAddresses on the client are only visible once they could be added via the interface to the Core wallet as watch only (avoid missing transactions, addresses can be pre-added by the client and used later)\n\nNew transactions can be created through the interface (which will use fundrawtransaction with watch-only-addresses in the background).\nCoin selection, fee calculation, etc. would happened on the Core node.\n\nSigning of transactions happens on the client (maybe BIP174).\nOptionally, a 2of2 (or 2of3 with a backup key) could be achieved where the node would also hold a key to have some sort of \u201e2FA\u201c if the node and the client environment are owned by the same person.\n\nThis would work with pruned nodes and can serve \u2013 depending on the used hardware \u2013 up to a couple of hundred wallets.\n\nBackup restores (xpriv sweeps) are also possible via the UTXO set and take less then a minute and don\u2019t require the full transaction history (or any kind of index).\n\nAdditional, the interface could also act as central, personal multisig bridge where n clients could use the same endpoint to participate in multisig wallets.\n\nOverall, this wold allow a slick and secure (personal or group) (multi-)wallet service that works perfectly fine on pruned nodes by simply adding a bridge-script.\n\n\nThanks\n\u2014\nJonas\n\n\n> Am 09.02.2018 um 03:51 schrieb Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:\n> \n> Electrum is a popular bitcoin wallet, but it is not a full node wallet\n> as it synchronizes itself using third-party Electrum servers. The\n> servers must be trusted to verify the rules of bitcoin, they can trick\n> Electrum wallets into accepting fake bitcoin transactions which, for\n> example, print infinite money. Bitcoin's security model requires that\n> most economic activity is backed by full nodes. The Electrum servers\n> must also be trusted with the user's privacy, as wallets send all their\n> bitcoin addresses to the server. Spying on wallets is not much more\n> complicated than simply grepping the server logs. Electrum wallets by\n> default also connect to servers using their own IP address, linking it\n> further to their revealed bitcoin addresses.\n> \n> A way to avoid these problems is for users to run their own Electrum\n> server and connect their wallets only to it. But this requires\n> significant resource usage: the full unpruned blockchain, transaction\n> index and an extra address index, as well as more RAM and CPU usage\n> compared to just a full node. Servers are not well suited to being shut\n> down and started up again, they are typically always online.\n> \n> Electrum servers store a database of every bitcoin address ever used,\n> which is inherently not scalable. This is resource-intensive and\n> therefore pushes users towards centralized solutions. An alternative way\n> would be to store only your own addresses and transactions.\n> \n> Introducing Electrum Personal Server; an implementation of the Electrum\n> server protocol which fulfills the specific need of using the Electrum\n> UI with full node verification and privacy, but without the heavyweight\n> server backend, for a single user. It allows the user to benefit from\n> all of Bitcoin Core's resource-saving features like pruning, blocksonly\n> and disabled txindex. All of Electrum's feature-richness like hardware\n> wallet integration, multisignature wallets, offline signing, mnemonic\n> recovery phrases and so on can still be used, but backed by the user's\n> own full node.\n> \n> An alpha version of Electrum Personal Server can be found on the\n> repository: https://github.com/chris-belcher/electrum-personal-server\n> \n> Before using, the wallet user must configure Electrum Personal Server\n> with their master public key and those addresses are imported into\n> Bitcoin Core as watch-only. If the wallet contains historical\n> transactions then it must be rescanned. One of Electrum's motivating\n> features is \"instant on\", which is therefore traded away when using\n> Electrum Personal Server in return for full node verification and\n> privacy. Although if a brand new empty wallet is created there is no\n> need to rescan. A script like Electrum Personal Server is also well\n> suited to use private transaction broadcasting tech like dandelion or\n> broadcasting through tor.\n> \n> Using Electrum with Electrum Personal Server is probably the most\n> resource-efficient way right now to use a hardware wallet connected to\n> your own full node. People who make use of Blockstream Satellite could\n> use it to have an off-the-grid node connected to Electrum if that is\n> their preferred wallet. In the situation of a traveller staying a cheap\n> hostels, they could sync their node every couple of days to download\n> recent blocks and use Electrum. Hopefully this software can be part of\n> the plan to get full node wallets into the hands of as many people as\n> possible.\n> \n> The same kind of ideas could be applied to other lightweight wallets.\n> For example a full nodes can run on smartphones with pruning and\n> blocksonly, then a similar script would allow the user to connect their\n> Samourai Wallet, Breadwallet or GreenAddress app to their own full node.\n> \n> \n> Further Reading:\n> \n> * https://bitcointalk.org/index.php?topic=2664747.msg27179198\n> *\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015030.html\n> * https://bitcointalk.org/index.php?topic=1634967.0;all\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180209/c4c58f3c/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Electrum Personal Server alpha release",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Belcher",
                "Jonas Schnelli"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 10330
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: [Lightning-dev] AMP: Atomic Multi-Path Payments over Lightning",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2018-02-08T17:49:23",
                "message_text_only": "---------- Forwarded message ----------\nFrom: Olaoluwa Osuntokun <laolu32 at gmail.com>\nDate: Mon, Feb 5, 2018 at 11:26 PM\nSubject: [Lightning-dev] AMP: Atomic Multi-Path Payments over Lightning\nTo: lightning-dev <lightning-dev at lists.linuxfoundation.org>\n\n\nHi Y'all,\n\nA common question I've seen concerning Lightning is: \"I have five $2\nchannels, is it possible for me to *atomically* send $6 to fulfill a\npayment?\". The answer to this question is \"yes\", provided that the receiver\nwaits to pull all HTLC's until the sum matches their invoice. Typically, one\nassumes that the receiver will supply a payment hash, and the sender will\nre-use the payment hash for all streams. This has the downside of payment\nhash re-use across *multiple* payments (which can already easily be\ncorrelated), and also has a failure mode where if the sender fails to\nactually satisfy all the payment flows, then the receiver can still just\npull the monies (and possibly not disperse a service, or w/e).\n\nConner Fromknecht and I have come up with a way to achieve this over\nLightning while (1) not re-using any payment hashes across all payment\nflows, and (2) adding a *strong* guarantee that the receiver won't be paid\nuntil *all* partial payment flows are extended. We call this scheme AMP\n(Atomic Multi-path Payments). It can be experimented with on Lightning\n*today* with the addition of a new feature bit to gate this new\nfeature. The beauty of the scheme is that it requires no fundamental changes\nto the protocol as is now, as the negotiation is strictly *end-to-end*\nbetween sender and receiver.\n\nTL;DR: we repurpose some unused space in the onion per-hop payload of the\nonion blob to signal our protocol (and deliver some protocol-specific data),\nthen use additive secret sharing to ensure that the receiver can't pull the\npayment until they have enough shares to reconstruct the original pre-image.\n\n\nProtocol Goals\n==============\n1. Atomicity: The logical transaction should either succeed or fail in\nentirety. Naturally, this implies that the receiver should not be unable to\nsettle *any* of the partial payments, until all of them have arrived.\n\n2. Avoid Payment Hash Reuse: The payment preimages validated by the\nconsensus layer should be distinct for each partial payment.  Primarily,\nthis helps avoid correlation of the partial payments, and ensures that\nmalicious intermediaries straddling partial payments cannot steal funds.\n\n3. Order Invariance: The protocol should be forgiving to the order in which\npartial payments arrive at the destination, adding robustness in the face of\ndelays or routing failures.\n\n4. Non-interactive Setup: It should be possible for the sender to perform an\nAMP without directly coordinating with the receiving node. Predominantly,\nthis means that the *sender* is able to determine the number of partial\npayments to use for a particular AMP, which makes sense since they will be\nthe one fronting the fees for the cost of this parameter. Plus, we can\nalways turn a non-interactive protocol into an interactive one for the\npurposes of invoicing.\n\n\nProtocol Benefits\n=================\n\nSending pay payments predominantly over an AMP-like protocol has several\nclear benefits:\n\n  - Eliminates the constraint that a single path from sender to receiver\n    with sufficient directional capacity. This reduces the pressure to have\n    larger channels in order to support larger payment flows. As a result,\n    the payment graph be very diffused, without sacrificing payment\n    utility\n\n  - Reduces strain from larger payments on individual paths, and allows the\n    liquidity imbalances to be more diffuse. We expect this to have a\n    non-negligible impact on channel longevity. This is due to the fact that\n    with usage of AMP, payment flows are typically *smaller* meaning that\n    each payment will unbalance a channel to a lesser degree that\n    with one giant flow.\n\n  - Potential fee savings for larger payments, contingent on there being a\n    super-linear component to routed fees. It's possible that with\n    modifications to the fee schedule, it's actually *cheaper* to send\n    payments over multiple flows rather than one giant flow.\n\n  - Allows for logical payments larger than the current maximum value of an\n    individual payment. Atm we have a (temporarily) limit on the max payment\n    size. With AMP, this can be side stepped as each flow can be up the max\n    size, with the sum of all flows exceeding the max.\n\n  - Given sufficient path diversity, AMPs may improve the privacy of LN\n    Intermediaries are now unaware to how much of the total payment they are\n    forwarding, or even if they are forwarding a partial payment at all.\n\n  - Using smaller payments increases the set of possible paths a partial\n    payment could have taken, which reduces the effectiveness of static\n    analysis techniques involving channel capacities and the plaintext\n    values being forwarded.\n\n\nProtocol Overview\n==================\nThis design can be seen as a generalization of the single, non-interactive\npayment scheme, that uses decoding of extra onion blobs (EOBs?) to encode\nextra data for the receiver. In that design, the extra data includes a\npayment preimage that the receiver can use to settle back the payment. EOBs\nand some method of parsing them are really the only requirement for this\nprotocol to work. Thus, only the sender and receiver need to implement this\nfeature in order for it to function, which can be announced using a feature\nbit.\n\nFirst, let's review the current format of the per-hop payload for each node\ndescribed in BOLT-0004.\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Realm (1 byte) \u2502Next Addr (8 bytes)\u2502Amount (8 bytes)\u2502Outgoing CLTV (4\nbytes)\u2502Unused (12 bytes)\u2502 HMAC (32 bytes) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\n                                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                              \u250265 Bytes Per Hop \u2502\n                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCurrently, *each* node gets a 65-byte payload. We use this payload to give\neach node instructions on *how* to forward a payment. We tell each node: the\nrealm (or chain to forward on), then next node to forward to, the amount to\nforward (this is where fees are extracted by forwarding out less than in),\nthe outgoing CLTV (allows verification that the prior node didn't modify any\nvalues), and finally an HMAC over the entire thing.\n\nTwo important points:\n  1. We have 12 bytes for each hop that are currently unpurposed and can be\n  used by application protocols to signal new interpretation of bytes and\n  also deliver additional encrypted+authenticated data to *each* hop.\n\n  2. The protocol currently has a hard limit of 20-hops. With this feature\n  we ensure that the packet stays fixed sized during processing in order to\n  avoid leaking positional information. Typically most payments won't use\n  all 20 hops, as a result, we can use the remaining hops to stuff in *even\n  more* data.\n\n\nProtocol Description\n====================\nThe solution we propose is Atomic Multi-path Payments (AMPs). At a high\nlevel, this leverages EOBs to deliver additive shares of a base preimage,\nfrom which the payment preimages of partial payments can be derived. The\nreceiver can only construct this value after having received all of the\npartial payments, satisfying the atomicity constraint.\n\nThe basic protocol:\n\nPrimitives\n==========\nLet H be a CRH function.\nLet || denote concatenation.\nLet ^ denote xor.\n\n\nSender Requirements\n===================\nThe parameters to the sending procedure are a random identifier ID, the\nnumber of partial payments n, and the total payment value V. Assume the\nsender has some way of dividing V such that V = v_1 + \u2026 + v_n.\n\nTo begin, the sender builds the base preimage BP, from which n partial\npreimages will be derived. Next, the sender samples n additive shares s_1,\n\u2026, s_n, and takes the sum to compute BP = s_1 ^ \u2026 ^ s_n.\n\nWith the base preimage created, the sender now moves on to constructing the\nn partial payments. For each i in [1,n], the sender deterministically\ncomputes the partial preimage r_i = H(BP ||  i), by concatenating the\nsequence number i to the base preimage and hashing the result. Afterwards,\nit applies H to determine the payment hash to use in the i\u2019th partial\npayment as h_i = H(r_i). Note that that with this preimage derivation\nscheme, once the payments are pulled each pre-image is distinct and\nindistinguishable from any other.\n\nWith all of the pieces in place, the sender initiates the i\u2019th payment by\nconstructing a route to the destination with value v_i and payment hash h_i.\nThe tuple (ID, n, s_i) is included in the EOB to be opened by the receiver.\n\nIn order to include the three tuple within the per-hop payload for the final\ndestination, we repurpose the _first_ byte of the un-used padding bytes in\nthe payload to signal version 0x01 of the AMP protocol (note this is a PoC\noutline, we would need to standardize signalling of these 12 bytes to\nsupport other protocols). Typically this byte isn't set, so the existence of\nthis means that we're (1) using AMP, and (2) the receiver should consume the\n_next_ hop as well. So if the payment length is actually 5, the sender tacks\non an additional dummy 6th hop, encrypted with the _same_ shared secret for\nthat hop to deliver the e2e encrypted data.\n\nNote, the sender can retry partial payments just as they would normal\npayments, since they are order invariant, and would be indistinguishable\nfrom regular payments to intermediaries in the network.\n\n\nReceiver Requirements\n=====================\n\nUpon the arrival of each partial payment, the receiver will iteratively\nreconstruct BP, and do some bookkeeping to figure out when to settle the\npartial payments. During this reconstruction process, the receiver does not\nneed to be aware of the order in which the payments were sent, and in fact\nnothing about the incoming partial payments reveals this information to the\nreceiver, though this can be learned after reconstructing BP.\n\nEach EOB is decoded to retrieve (ID, n, s_i), where i is the unique but\nunknown index of the incoming partial payment. The receiver has access to\npersistent key-value store DB that maps ID to (n, c*, BP*), where c*\nrepresents the number of partial payments received, BP* is the sum of the\nreceived additive shares, and the superscript * denotes that the value is\nbeing updated iteratively. c* and BP* both have initial values of 0.\n\nIn the basic protocol, the receiver cache\u2019s the first n it sees, and\nverifies that all incoming partial payments have the same n. The receiver\nshould reject all partial payments if any EOB deviates.  Next, the we update\nour persistent store with DB[ID] = (n, c* + 1, BP* ^ s_i), advancing the\nreconstruction by one step.\n\nIf c* + 1 < n, there are still more packets in flight, so we sit tight.\nOtherwise, the receiver assumes all partial payments have arrived, and can\nbeing settling them back. Using the base preimage BP = BP* ^ s_i from our\nfinal iteration, the receiver can re-derive all n partial preimages and\npayment hashes, using r_i = H(BP || i) and h_i = H(r_i) simply through\nknowledge of n and BP.\n\nFinally, the receiver settles back any outstanding payments that include\npayment hash h_i using the partial preimage r_i. Each r_i will appear random\ndue to the nature of H, as will it\u2019s corresponding h_i. Thus, each partial\npayment should appear uncorrelated, and does not reveal that it is part of\nan AMP nor the number of partial payments used.\n\nNon-interactive to Interactive AMPs\n===================================\n\nSender simply receives an ID and amount from the receiver in an invoice\nbefore initiating the protocol. The receiver should only consider the\ninvoice settled if the total amount received in partial payments containing\nID matches or exceeds the amount specified in the invoice. With this\nvariant, the receiver is able to map all partial payments to a pre-generated\ninvoice statement.\n\n\nAdditive Shares vs Threshold-Shares\n===================================\n\nThe biggest reason to use additive shares seems to be atomicity. Threshold\nshares open the door to some partial payments being settled, even if others\nare left in flight. Haven\u2019t yet come up with a good reason for using\nthreshold schemes, but there seem to be plenty against it.\n\nReconstruction of additive shares can be done iteratively, and is win for\nthe storage and computation requirements on the receiving end. If the sender\ndecides to use fewer than n partial payments, the remaining shares could be\nincluded in the EOB of the final partial payment to allow the sender to\nreconstruct sooner. Sender could also optimistically do partial\nreconstruction on this last aggregate value.\n\n\nAdaptive AMPs\n=============\n\nThe sender may not always be aware of how many partial payments they wish to\nsend at the time of the first partial payment, at which point the simplified\nprotocol would require n to be chosen. To accommodate, the above scheme can\nbe adapted to handle a dynamically chosen n by iteratively constructing the\nshared secrets as follows.\n\nStarting with a base preimage BP, the key trick is that the sender remember\nthe difference between the base preimage and the sum of all partial\npreimages used so far. The relation is described using the following\nequations:\n\n    X_0 = 0\n    X_i = X_{i-1} ^ s_i\n    X_n = BP ^ X_{n-1}\n\nwhere if n=1, X_1 = BP, implying that this is in fact a generalization of\nthe single, non-interactive payment scheme mentioned above. For i=1, ...,\nn-1, the sender sends s_i in the EOB, and  X_n for the n-th share.\n\nIteratively reconstructing s_1 ^ \u2026. ^ s_{n-1} ^ X_n = BP, allows the\nreceiver to compute all relevant r_i = H(BP || i) and h_i = H(r_i). Lastly,\nthe final number of partial payments n could be signaled in the final EOB,\nwhich would also serve as a sentinel value for signaling completion. In\nresponse to DOS vectors stemming from unknown values of n, implementations\ncould consider advertising a maximum value for n, or adopting some sort of\nframing pattern for conveying that more partial payments are on the way.\n\nWe can further modify our usage of the per-hop payloads to send (H(BP),\ns_i) to\nconsume most of the EOB sent from sender to receiver. In this scenario, we'd\nrepurpose the 11-bytes *after* our signalling byte in the unused byte\nsection\nto store the payment ID (which should be unique for each payment). In the\ncase\nof a non-interactive payment, this will be unused. While for interactive\npayments, this will be the ID within the invoice. To deliver this slimmer\n2-tuple, we'll use 32-bytes for the hash of the BP, and 32-bytes for the\npartial pre-image share, leaving an un-used byte in the payload.\n\n\nCross-Chain AMPs\n================\n\nAMPs can be used to pay a receiver in multiple currencies atomically...which\nis pretty cool :D\n\n\nOpen Research Questions\n=======================\n\nThe above is a protocol sketch to achieve atomic multi-path payments over\nLightning. The details concerning onion blob usage serves as a template that\nfuture protocols can draw upon in order to deliver additional data to *any*\nhop in the route. However, there are still a few open questions before\nsomething like this can be feasibly deployed.\n\n1. How does the sender decide how many chunked payments to send, and the\nsize of each payment?\n\n  - Upon a closer examination, this seems to overlap with the task of\n    congestion control within TCP. The sender may be able to utilize\n    inspired heuristics to gauge: (1) how large the initial payment should\nbe\n    and (2) how many subsequent payments may be required. Note that if the\n    first payment succeeds, then the exchange is over in a signal round.\n\n2. How can AMP and HORNET be composed?\n\n  - If we eventually integrate HORNET, then a distinct communications\n    sessions can be established to allow the sender+receiver to exchange\n    up-to-date partial payment information. This may allow the sender to\nmore\n    accurately size each partial payment.\n\n3. Can the sender's initial strategy be governed by an instance of the\nPush-relabel max flow algo?\n\n4. How does this mesh with the current max HTLC limit on a commitment?\n\n   - ATM, we have a max limit on the number of active HTLC's on a particular\n     commitment transaction. We do this, as otherwise it's possible that the\n     transaction is too large, and exceeds standardness w.r.t transaction\n     size. In a world where most payments use an AMP-like protocol, then\n     overall ant any given instance there will be several pending HTLC's on\n     commitments network wise.\n\n     This may incentivize nodes to open more channels in order to support\n     the increased commitment space utilization.\n\n\nConclusion\n==========\n\nWe've presented a design outline of how to integrate atomic multi-path\npayments (AMP) into Lightning. The existence of such a construct allows a\nsender to atomically split a payment flow amongst several individual payment\nflows. As a result, larger channels aren't as important as it's possible to\nutilize one total outbound payment bandwidth to send several channels.\nAdditionally, in order to support the increased load, internal routing nodes\nare incensed have more active channels. The existence of AMP-like payments\nmay also increase the longevity of channels as there'll be smaller, more\nnumerous payment flows, making it unlikely that a single payment comes\nacross unbalances a channel entirely. We've also showed how one can utilize\nthe current onion packet format to deliver additional data from a sender to\nreceiver, that's still e2e authenticated.\n\n\n-- Conner && Laolu\n\n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180208/be98f021/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: AMP: Atomic Multi-Path Payments over Lightning",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 18311
        }
    },
    {
        "title": "[bitcoin-dev] Setting up bitcoin dev environment ( bitcoind, bitcoin-cli )",
        "thread_messages": [
            {
                "author": "Maksim Solovjov",
                "date": "2018-02-09T10:55:44",
                "message_text_only": "Hi guys,\n\nI am trying to set up the bitcoin development environment on my Mac.\n\nI installed the Bitcoin Core client ( bitcoin-qt ) and also downloaded the\nbinaries.\n\nI face the following issues and hope you can help me to resolve these:\n\n1) Can't open the configuration file from bitcoin-qt.\nI have a configuration file $HOME/Library/Application\nSupport/Bitcoin/bitcoin.conf\nbut it's empty.\nWhen I try to open it via bitcoin-qt ( Preferences -> Show configuration\nfile ) it shows me a popup with an error \"Configuration file could not be\nopened\".\nI tried to change the permissions: \"chmod 600\"...no luck...\n\n2) I can launch bitcoind in -regtest regime.\nBut when I launch *bitcoin-cli -regtest setgenerate true 101*\nI get an error:\n\n> error code: -32601\n> error message:\n> Method not found\n\n\n3) If I try *bitcoin-cli getinfo*\nI get an error:\n\n> error: Could not locate RPC credentials. No authentication cookie could be\n> found, and no rpcpassword is set in the configuration file\n> (/Users/..../Library/Application Support/Bitcoin/bitcoin.conf)\n\n\nHope you can help me!\nThanks\n\nBest,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180209/17ad9743/attachment.html>"
            },
            {
                "author": "Bernd Jendrissek",
                "date": "2018-02-09T20:10:25",
                "message_text_only": "On 9 February 2018 at 12:55, Maksim Solovjov via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> 2) I can launch bitcoind in -regtest regime.\n> But when I launch bitcoin-cli -regtest setgenerate true 101\n> I get an error:\n>>\n>> error code: -32601\n>> error message:\n>> Method not found\n\nsetgenerate was removed in 0.13.0. See doc/release-notes/release-notes-0.13.0.md\n\n> 3) If I try bitcoin-cli getinfo\n> I get an error:\n>>\n>> error: Could not locate RPC credentials. No authentication cookie could be\n>> found, and no rpcpassword is set in the configuration file\n>> (/Users/..../Library/Application Support/Bitcoin/bitcoin.conf)\n\ngetinfo is also deprecated or already removed. (Which version did you\ninstall?) But even before that, you should probably heed the warning\nand note that you don't seem to have a bitcoin.conf in a place where\nbitcoin-cli can find it."
            }
        ],
        "thread_summary": {
            "title": "Setting up bitcoin dev environment ( bitcoind, bitcoin-cli )",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bernd Jendrissek",
                "Maksim Solovjov"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2143
        }
    },
    {
        "title": "[bitcoin-dev] [BIP] Stratum protocol specification",
        "thread_messages": [
            {
                "author": "Jules Lamur",
                "date": "2018-02-09T13:48:39",
                "message_text_only": "Hello,\n\nWith two student colleagues of mine (Denis HODZHADZHIKOV,\nKim-Son PHAM), we are developping a mining pool as an\nacademic work.\n\nCurrently, most of our work is reverse engineering on existing\nimplementations of the protocol because of the lack of\ndocumentation, especially on edge cases.\n\nOur referent professor suggested us to publish a IETF RFC draft\nof the protocol's specification. However, I think a BIP would be\nmore appropriate for this.\n\nI've found that the BIP 40 and the BIP 41 were allocated for\nrespectively the wire protocol and the mining protocol since\nat least August 2013 (cf.\nhttps://github.com/bitcoin/bips/commit/e12d37e6639a4acffa2710ddb6cf81e74403b2a1).\n\nIt seems that nothing has been done since.\n\nCould we (me and my colleagues) start writing a draft for the\nBIP 41 (mining protocol)?\n\nRegards,\nJules LAMUR."
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2018-02-13T00:54:00",
                "message_text_only": "When we worked on the extensions for RSK merge mining, I prepared an\ninternal document with the most up to date Straum protocol description I\ncould get.\n\nThis is the document:\n\nhttps://docs.google.com/document/d/1ocEC8OdFYrvglyXbag1yi8WoskaZoYuR5HGhwf0hWAY/edit?usp=sharing\n\nRegards\n\nOn Fri, Feb 9, 2018 at 10:48 AM, Jules Lamur via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> With two student colleagues of mine (Denis HODZHADZHIKOV,\n> Kim-Son PHAM), we are developping a mining pool as an\n> academic work.\n>\n> Currently, most of our work is reverse engineering on existing\n> implementations of the protocol because of the lack of\n> documentation, especially on edge cases.\n>\n> Our referent professor suggested us to publish a IETF RFC draft\n> of the protocol's specification. However, I think a BIP would be\n> more appropriate for this.\n>\n> I've found that the BIP 40 and the BIP 41 were allocated for\n> respectively the wire protocol and the mining protocol since\n> at least August 2013 (cf.\n> https://github.com/bitcoin/bips/commit/e12d37e6639a4acffa2710ddb6cf81\n> e74403b2a1).\n>\n> It seems that nothing has been done since.\n>\n> Could we (me and my colleagues) start writing a draft for the\n> BIP 41 (mining protocol)?\n>\n> Regards,\n> Jules LAMUR.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/f731f573/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Stratum protocol specification",
            "categories": [
                "bitcoin-dev",
                "BIP"
            ],
            "authors": [
                "Sergio Demian Lerner",
                "Jules Lamur"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2491
        }
    },
    {
        "title": "[bitcoin-dev] Transition to post-quantum",
        "thread_messages": [
            {
                "author": "Tristan Hoy",
                "date": "2018-02-12T14:13:11",
                "message_text_only": "Hi all,\n\nRecently I've been exploring what a post-quantum attack on Bitcoin would\nactually look like, and what options exist for mitigating it.\n\nI've put up a draft of my research here:\nhttps://medium.com/@tristanhoy/11271f430c41\n\nIn summary:\n1) None of the recommended post-quantum DSAs (XMSS, SPHINCS) are scalable\n2) This is a rapidly advancing space and committment to a specific\npost-quantum DSA now would be premature\n3) I've identified a strategy (solution 3 in the draft) that mitigates\nagainst the worst case scenario (unexpectedly early attack on ECDSA)\nwithout requiring any changes to the Bitcoin protocol or total committment\nto a specific post-quantum DSA that will likely be superseded in the next\n3-5 years\n4) This strategy also serves as a secure means of transferring balances\ninto a post-quantum DSA address space, even in the event that ECDSA is\nfully compromised and the transition is reactionary\n\nThe proposal is a change to key generation only and will be implemented by\nwallet providers.\n\nFeedback would be most appreciated.\n\nRegards,\n\nTristan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/a2ca6c0e/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-02-12T15:50:50",
                "message_text_only": "Hi Tristan,\n\nRegarding the \"Post-Quantum Address Recovery\" part (I haven't read the\nother parts), you may be interested in my message to the list from last\nmonth and the rest of the thread:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015659.html\n\nThis is an approach which aims to avoid the issues that you've\nmentioned in your blog post.\n\nBest,\nTim\n\nOn Tue, 2018-02-13 at 01:13 +1100, Tristan Hoy via bitcoin-dev wrote:\n> Hi all,\n> \n> Recently I've been exploring what a post-quantum attack on Bitcoin\n> would actually look like, and what options exist for mitigating it.\n> \n> I've put up a draft of my research here: https://medium.com/@tristanh\n> oy/11271f430c41 \n> \n> In summary:\n> 1) None of the recommended post-quantum DSAs (XMSS, SPHINCS) are\n> scalable\n> 2) This is a rapidly advancing space and committment to a specific\n> post-quantum DSA now would be premature\n> 3) I've identified a strategy (solution 3 in the draft) that\n> mitigates against the worst case scenario (unexpectedly early attack\n> on ECDSA) without requiring any changes to the Bitcoin protocol or\n> total committment to a specific post-quantum DSA that will likely be\n> superseded in the next 3-5 years\n> 4) This strategy also serves as a secure means of transferring\n> balances into a post-quantum DSA address space, even in the event\n> that ECDSA is fully compromised and the transition is reactionary\n> \n> The proposal is a change to key generation only and will be\n> implemented by wallet providers.\n> \n> Feedback would be most appreciated.\n> \n> Regards,\n> \n> Tristan\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tristan Hoy",
                "date": "2018-02-12T21:32:35",
                "message_text_only": "Hi Tim,\n\nJust read through your post, thanks for the heads up - I only just joined\nthis mailing list.\n\nIn a post-quantum world, your second \"d\" type transaction is completely\nforgeable, which means it is vulnerable to front-running. An adversary\ncapable of breaking ECDSA needs only listen for these transactions, obtain\n\"classic_sk\" and then use a higher fee (or relationship with a miner) to\neffectively turn your original \"d\" transaction into a double-spend, with\nthe forged transaction sending all your funds to the adversary.\n\nI'm pretty confident that a PQ DSA is required to prevent front-running,\nand that no \"commit-reveal\" scheme will be secure without one.\n\nThe other issue with your approach is that if it is rolled out today, it\nwill effectively double transaction volumes - this is what I tried to solve\nin solutions 2 and 3 in my article by instead modifying the address\ngeneration process.\n\nRegards,\n\nTristan\n\nOn Tue, Feb 13, 2018 at 2:50 AM, Tim Ruffing via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Tristan,\n>\n> Regarding the \"Post-Quantum Address Recovery\" part (I haven't read the\n> other parts), you may be interested in my message to the list from last\n> month and the rest of the thread:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/\n> 2018-January/015659.html\n>\n> This is an approach which aims to avoid the issues that you've\n> mentioned in your blog post.\n>\n> Best,\n> Tim\n>\n> On Tue, 2018-02-13 at 01:13 +1100, Tristan Hoy via bitcoin-dev wrote:\n> > Hi all,\n> >\n> > Recently I've been exploring what a post-quantum attack on Bitcoin\n> > would actually look like, and what options exist for mitigating it.\n> >\n> > I've put up a draft of my research here: https://medium.com/@tristanh\n> > oy/11271f430c41\n> >\n> > In summary:\n> > 1) None of the recommended post-quantum DSAs (XMSS, SPHINCS) are\n> > scalable\n> > 2) This is a rapidly advancing space and committment to a specific\n> > post-quantum DSA now would be premature\n> > 3) I've identified a strategy (solution 3 in the draft) that\n> > mitigates against the worst case scenario (unexpectedly early attack\n> > on ECDSA) without requiring any changes to the Bitcoin protocol or\n> > total committment to a specific post-quantum DSA that will likely be\n> > superseded in the next 3-5 years\n> > 4) This strategy also serves as a secure means of transferring\n> > balances into a post-quantum DSA address space, even in the event\n> > that ECDSA is fully compromised and the transition is reactionary\n> >\n> > The proposal is a change to key generation only and will be\n> > implemented by wallet providers.\n> >\n> > Feedback would be most appreciated.\n> >\n> > Regards,\n> >\n> > Tristan\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/876e923d/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-02-13T06:46:14",
                "message_text_only": "On Tue, 2018-02-13 at 08:32 +1100, Tristan Hoy wrote:\n> In a post-quantum world, your second \"d\" type transaction is\n> completely forgeable, which means it is vulnerable to front-running.\n> An adversary capable of breaking ECDSA needs only listen for these\n> transactions, obtain \"classic_sk\" and then use a higher fee (or\n> relationship with a miner) to effectively turn your original \"d\"\n> transaction into a double-spend, with the forged transaction sending\n> all your funds to the adversary.\n\nThat's not true. The d(ecommit) transaction, or better let's call it\n\"decommit step\" of a two-step transaction does not specify the effects\n(output script). This is what I denote by \"tx\" in the writeup, and it's\nalready fixed by the c(ommit) step.\n\nSo yes, if the user finally reveals\n  d  = classic_pk||Sign(classic_sk, tx)\na quantum attacker can indeed forge\n  d' = classic_pk||Sign(classic_sk, tx') \nfor tx' != tx of his choice. But that won't help him, because the first\nvalid c step in the chain is for tx and not for tx'.\n\n> The other issue with your approach is that if it is rolled out today,\n> it will effectively double transaction volumes - this is what I tried\n> to solve in solutions 2 and 3 in my article by instead modifying the\n> address generation process.\n\nYep, it needs two entries in the blockchain, and that does not mean\nthat it doubles the data. It will need some more bytes in the\nblockchain but also proper PQ-transactions could need more bytes in the\nblockchain, so I don't think that's the major issue.\n\n\n> \n> Regards,\n> \n> Tristan\n> \n> On Tue, Feb 13, 2018 at 2:50 AM, Tim Ruffing via bitcoin-dev <bitcoin\n> -dev at lists.linuxfoundation.org> wrote:\n> > Hi Tristan,\n> > \n> > Regarding the \"Post-Quantum Address Recovery\" part (I haven't read\n> > the\n> > other parts), you may be interested in my message to the list from\n> > last\n> > month and the rest of the thread:\n> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-Januar\n> > y/015659.html\n> > \n> > This is an approach which aims to avoid the issues that you've\n> > mentioned in your blog post.\n> > \n> > Best,\n> > Tim\n> > \n> > On Tue, 2018-02-13 at 01:13 +1100, Tristan Hoy via bitcoin-dev\n> > wrote:\n> > > Hi all,\n> > >\n> > > Recently I've been exploring what a post-quantum attack on\n> > Bitcoin\n> > > would actually look like, and what options exist for mitigating\n> > it.\n> > >\n> > > I've put up a draft of my research here: https://medium.com/@tris\n> > tanh\n> > > oy/11271f430c41\n> > >\n> > > In summary:\n> > > 1) None of the recommended post-quantum DSAs (XMSS, SPHINCS) are\n> > > scalable\n> > > 2) This is a rapidly advancing space and committment to a\n> > specific\n> > > post-quantum DSA now would be premature\n> > > 3) I've identified a strategy (solution 3 in the draft) that\n> > > mitigates against the worst case scenario (unexpectedly early\n> > attack\n> > > on ECDSA) without requiring any changes to the Bitcoin protocol\n> > or\n> > > total committment to a specific post-quantum DSA that will likely\n> > be\n> > > superseded in the next 3-5 years\n> > > 4) This strategy also serves as a secure means of transferring\n> > > balances into a post-quantum DSA address space, even in the event\n> > > that ECDSA is fully compromised and the transition is reactionary\n> > >\n> > > The proposal is a change to key generation only and will be\n> > > implemented by wallet providers.\n> > >\n> > > Feedback would be most appreciated.\n> > >\n> > > Regards,\n> > >\n> > > Tristan\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n>"
            },
            {
                "author": "Tristan Hoy",
                "date": "2018-02-13T10:06:31",
                "message_text_only": "On 13/02/2018 5:46 PM, Tim Ruffing via bitcoin-dev wrote:\n> On Tue, 2018-02-13 at 08:32 +1100, Tristan Hoy wrote:\n>> In a post-quantum world, your second \"d\" type transaction is\n>> completely forgeable, which means it is vulnerable to front-running.\n>> An adversary capable of breaking ECDSA needs only listen for these\n>> transactions, obtain \"classic_sk\" and then use a higher fee (or\n>> relationship with a miner) to effectively turn your original \"d\"\n>> transaction into a double-spend, with the forged transaction sending\n>> all your funds to the adversary.\n> That's not true. The d(ecommit) transaction, or better let's call it\n> \"decommit step\" of a two-step transaction does not specify the effects\n> (output script). This is what I denote by \"tx\" in the writeup, and it's\n> already fixed by the c(ommit) step.\n>\n> So yes, if the user finally reveals\n>    d  = classic_pk||Sign(classic_sk, tx)\n> a quantum attacker can indeed forge\n>    d' = classic_pk||Sign(classic_sk, tx')\n> for tx' != tx of his choice. But that won't help him, because the first\n> valid c step in the chain is for tx and not for tx'.\nThank you for clarifying, I should have caught that.\n\n>> The other issue with your approach is that if it is rolled out today,\n>> it will effectively double transaction volumes - this is what I tried\n>> to solve in solutions 2 and 3 in my article by instead modifying the\n>> address generation process.\n> Yep, it needs two entries in the blockchain, and that does not mean\n> that it doubles the data. It will need some more bytes in the\n> blockchain but also proper PQ-transactions could need more bytes in the\n> blockchain, so I don't think that's the major issue.\n>\nThe worst-case outcome is that ECDSA is broken before PQ addresses are \nrolled out. There is no reactive response to this - all the existing \nECDSA addresses will be compromised. A proactive measure is required, \nand it should be deployed sooner rather than later.\n\nAny two-step approach adopted now as a proactive measure will not only \nbloat the blockchain, it will also double the effective confirmation \ntime - for all transactions between now and when PQ addresses are rolled \nout, which seems unlikely to happen in the next 5 years. The bloat will \nbe permanent.\n\nEither way, would you mind if I included your approach in the article, \nwith credit? I will seek your review before publishing.\n\n>> Regards,\n>>\n>> Tristan\n>>\n>> On Tue, Feb 13, 2018 at 2:50 AM, Tim Ruffing via bitcoin-dev <bitcoin\n>> -dev at lists.linuxfoundation.org> wrote:\n>>> Hi Tristan,\n>>>\n>>> Regarding the \"Post-Quantum Address Recovery\" part (I haven't read\n>>> the\n>>> other parts), you may be interested in my message to the list from\n>>> last\n>>> month and the rest of the thread:\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-Januar\n>>> y/015659.html\n>>>\n>>> This is an approach which aims to avoid the issues that you've\n>>> mentioned in your blog post.\n>>>\n>>> Best,\n>>> Tim\n>>>\n>>> On Tue, 2018-02-13 at 01:13 +1100, Tristan Hoy via bitcoin-dev\n>>> wrote:\n>>>> Hi all,\n>>>>\n>>>> Recently I've been exploring what a post-quantum attack on\n>>> Bitcoin\n>>>> would actually look like, and what options exist for mitigating\n>>> it.\n>>>> I've put up a draft of my research here: https://medium.com/@tris\n>>> tanh\n>>>> oy/11271f430c41\n>>>>\n>>>> In summary:\n>>>> 1) None of the recommended post-quantum DSAs (XMSS, SPHINCS) are\n>>>> scalable\n>>>> 2) This is a rapidly advancing space and committment to a\n>>> specific\n>>>> post-quantum DSA now would be premature\n>>>> 3) I've identified a strategy (solution 3 in the draft) that\n>>>> mitigates against the worst case scenario (unexpectedly early\n>>> attack\n>>>> on ECDSA) without requiring any changes to the Bitcoin protocol\n>>> or\n>>>> total committment to a specific post-quantum DSA that will likely\n>>> be\n>>>> superseded in the next 3-5 years\n>>>> 4) This strategy also serves as a secure means of transferring\n>>>> balances into a post-quantum DSA address space, even in the event\n>>>> that ECDSA is fully compromised and the transition is reactionary\n>>>>\n>>>> The proposal is a change to key generation only and will be\n>>>> implemented by wallet providers.\n>>>>\n>>>> Feedback would be most appreciated.\n>>>>\n>>>> Regards,\n>>>>\n>>>> Tristan\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-02-15T15:59:27",
                "message_text_only": "First of all, there is indeed an issue in my proposal:\n\nThe idea was to include a classic signature to make sure that, if (for\nwhatever reason) you have revealed classic_pk already.\n\nHowever, the problem is that if you have revealed classic_pk, then\neverybody can effectively prevent you from spending the funds as you\nwish by just including the first commit entry with an arbitrary tx in\nthe blockchain. That's bad obviously.\n\nHere is a fixed variant, which does not only work with normal P2PKH but\n1) supports basically with any (hash-based) addresses, for which the\npreimage has not been revealed and 2) does not change the conditions\nunder which a UTXO can be spent.\n\nSetup\n=====\nWe will need multiple hash functions KDF, H, and authenticated\nsymmetric encryption Enc/Dec.\n\nLet's assume we have an UTXO with address addr = H_addr(chal), where\nchal is a challenge, i.e., typically a scriptPubKey (what I called\nclassic_pk initially) and H_addr is the hash function used to form\naddresses. (If there are multiple UTXO sharing the same address, they\ncan be spent simultaneously with this approach.) To spend this UTXO\nwith a transaction tx, the user performs the following two steps.\n\nNote that -- in contrast to my earlier emails -- tx is assumed to\ninclude a solution to the challenge in its input, i.e., a string which\nproves that you are allowed to spend the UTXO (typically a scriptSig). \n\nCommit step\n===========\nDerive a symmetric key k = KDF(chal).\n\nCreate and publish a commitment in the blockchain that references the\nUTXO as inputs and contains the following data: \n      c = Enc(k, tx)\n\nWait until c is confirmed. (If it does not confirm, send it again as\nusual.)\n\nDecommit step\n=============\nCreate and publish a decommitment with the following data:\n      d = chal\n\nConsensus rules\n===============\nA decommitment d = chal spends a UTXO with address H_addr(chal), if\nthere exists a commitment c in the blockchain which references the UTXO\nand which is the first commitment (among all referencing the UTXO) in\nthe blockchain such that\n1. k = KDF(chal) correctly decrypts Dec(k, c)\n    and\n2. tx = Dec(k, c) is a valid transaction to spend UTXO \n\nThe UTXO is spent as described by tx.\nCommitments never expire.\n\nThe second condition covers that tx contains a classic signature under\nthe public key specified in chal in normal P2PKH addresses.\n\nThe trick here is that the encryption ensures that the user commits to\ntx (including the classic signature) already in the commit step, while\nstill keeping the decommitment unique. If I'm not mistaken, this scheme\nis a variant of Adam Back's proposal for committed transactions from\n2013, which he invented for an entirely different goal, namely\ncensorship resistance:\nhttps://bitcointalk.org/index.php?topic=206303.msg2162962#msg2162962\n\n(Adam noted the similarity of the problems on Twitter recently:\nhttps://twitter.com/adam3us/status/948219461345075201)\n\nThe above variant is pretty simple. If it really works and is secure,\nit has the advantage over Adam's proposal that it does not rely on\nECDSA specifically and can be used for any address type. \n\nThe aforementioned thread in the Bitcoin forum discusses the main\nproblem of an approach like that: Everybody can flood the blockchain\nwith commitments. Of course, one can require fees to create\ncommitments, but that's pretty ugly: If this UTXO is the only money you\nhave, then you need to borrow some to pay the transaction fees upfront.\nBut this may be the price you need to pay for recovery. This can be\nacceptable, because recovery should be the exception (see below).\n\nOn Tue, 2018-02-13 at 21:06 +1100, Tristan Hoy via bitcoin-dev wrote:\n> The worst-case outcome is that ECDSA is broken before PQ addresses\n> are \n> rolled out. There is no reactive response to this - all the existing \n> ECDSA addresses will be compromised. A proactive measure is\n> required, \n> and it should be deployed sooner rather than later.\n\nThe proposal above does not require any changes to existing ECDSA\naddresses, so there is no need to change something now already. \n\nAt some point in the future, PQ addresses will be deployed. And at some\n(potentially different) point in the future, we should deploy a\nsolution to recover UTXOs. But there's no need to do this today. A\nrecovery solution can be deployed even when DLOG has been broken\nalready -- not optimal but possible.\n\n> \n> Any two-step approach adopted now as a proactive measure will not\n> only \n> bloat the blockchain, it will also double the effective confirmation \n> time - for all transactions between now and when PQ addresses are\n> rolled \n> out, which seems unlikely to happen in the next 5 years. The bloat\n> will \n> be permanent.\n> \n\nI don't think that's true due to the situation I describe above. We\ndon't need to act now.\n\nAnd even if we act now, i.e., even if we enable the above proposal (or\nany other protocol that enables recovery of UTXOs with addresses)\ntoday, people are not forced to use it. As long as ECDSA and the other\nschemes we use today remain secure, people can and will continue to\nperform conventional transactions. Ideally, people will need a recovery\nprotocol only for those UTXOs which they haven't touched for years and\nhave forgotten to convert to PQ in time.\n\nYou mentioned confirmation time. A nice thing is that the above\nprotocol does not double confirmation times. The sender needs to wait\nfor confirmation of the commitment. But as soon as the commitment is\nconfirmed, double-spending is excluded already, because the sender is\ncommitted to the transaction. So the recipient does not need to wait\nfor confirmation of the decommitment. As soon as the recipient sees the\ndecommitment, everything is good. (If the decommitment is not\nconfirmed, the recipient can just re-broadcast it.)\n\nIn practice, we could even go further and call the transaction done\nafter the commitment is confirmed and the sender sends the data for the\nsecond step to the recipient off-chain. Only when the recipient wants\nto spend the funds again, the recipient will reveal this data.\n\nThe fact that double-spending is excluded after the first step is\nconfirmed, is exactly what makes the protocol secure against quantum\nattackers who want to steal the money. As soon as the user reveals the\nECDSA public key, a quantum attacker has access to all secrets: The\nattacker knows the preimage of the hash can compute the secret key.\nSo from this point on, there is no hope that we can distinguish the\nhonest user from the attacker. But since the correct transaction has\nbeen committed to the blockchain, and cannot be changed anymore, we\ndon't need to distinguish the honest user from the attacker.\n\n> Either way, would you mind if I included your approach in the\n> article, \n> with credit? I will seek your review before publishing.\n\nSure, feel free to include. You don't need to seek my review but I can\ncertainly have a look if desired.\n\nTim"
            },
            {
                "author": "Natanael",
                "date": "2018-02-15T20:27:27",
                "message_text_only": "Den 15 feb. 2018 17:00 skrev \"Tim Ruffing via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n\nConsensus rules\n===============\nA decommitment d = chal spends a UTXO with address H_addr(chal), if\nthere exists a commitment c in the blockchain which references the UTXO\nand which is the first commitment (among all referencing the UTXO) in\nthe blockchain such that\n1. k = KDF(chal) correctly decrypts Dec(k, c)\n    and\n2. tx = Dec(k, c) is a valid transaction to spend UTXO\n\nThe UTXO is spent as described by tx.\nCommitments never expire.\n\n\nI addressed this partially before, and this is unfortunately incomplete.\n\nSituation A: Regardless of expiration of commitments, we allow doubles. (Or\nno doubles allowed, but commitments expire.)\n\nIf I can block your transaction from confirming (censorship), then I can\nmake my own commitment + transaction. The miners will see two commitments\nreferencing the same UTXO - but can see only one transaction which match a\nvalid challenge and spends them, which is mine. You gained nothing from the\ncommitment.\n\nSituation B: We don't allow conflicting commitments, and they never expire.\nI can now freeze everybody's funds trivially with invalid commitments,\nbecause you can't validate a commitment without seeing a valid transaction\nmatching it - and exposing an uncommitted transaction breaks the security\npromise of commitments.\n\nAny additional data in the commitment but hash it the transaction is\npointless, because the security properties are the same. You can't freeze\nan UTXO after only seeing a commitment, and for any two conflicting\ntransactions you may observe it does not matter at all if one references\nUTXO:s or not since you already know both transactions' commitment ages\nanyway. Oldest would win no matter the additional data.\n\nCommitments work when the network can't easily be censored for long enough\nto deploy the attack (at least for 2-3 blocks worth of time). They fail\nwhen the attacker is capable of performing such an attack.\n\nAs I said previously, the only completely solid solution in all\ncircumstances is a quantum resistant Zero-knowledge proof algorithm, or\nsome equivalent method of proving knowledge of the key without revealing\nany data that enables a quantum attack.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180215/7b046cd7/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-02-15T21:57:41",
                "message_text_only": "On Thu, 2018-02-15 at 21:27 +0100, Natanael wrote:\n> I addressed this partially before, and this is unfortunately\n> incomplete.\n> \n> Situation A: Regardless of expiration of commitments, we allow\n> doubles. (Or no doubles allowed, but commitments expire.) \n> \n> If I can block your transaction from confirming (censorship), then I\n> can make my own commitment + transaction. The miners will see two\n> commitments referencing the same UTXO - but can see only one\n> transaction which match a valid challenge and spends them, which is\n> mine. You gained nothing from the commitment.\n\nYes, I assume situation A: \n  * commitments never expire\n  * and there is no limit on the number of commitment for the same UTXO\n\nAs I understand, you mean \"decommitment\" when you say \"transaction\".\nPlease correct me if I'm wrong. I'll stick with \"decommitment\".\n\nLet's assume the attacker blocks the decommitment by the honest user,\ninserts his own malicious commitment and his own decommitment, which\nshould be valid for the malicious commitment. Then the miners will see\ntwo commitments (the earlier commitment by the honest user and the\nlater one by the attacker).\n\nAlso, the miners will indeed see one valid decommitment. This\ndecommitment may have been sent by the attacker but it's the preimage\nchal of the address, because otherwise it's not valid for the malicious\ncommitment. But if the decommitment is chal, then this decommitment is\nalso valid for the commitment of the honest user, which is earliest\nadditionally. So the honest commitment wins. The attacker does not\nsucceed and everything is fine.\n\nThe reason why this works:\nThere is only one unique decommitment for the UTXO (assuming H_addr is\ncollision-resistant). The decommitment does not depend on the\ncommitment. The attacker cannot send a different decommitment, just\nbecause there is none.\n\nMaybe I'm wrong and I just don't understand your attack. In this case,\nplease explain it more detail.\n\nRegards,\nTim"
            },
            {
                "author": "Natanael",
                "date": "2018-02-15T22:44:05",
                "message_text_only": "Den 15 feb. 2018 22:58 skrev \"Tim Ruffing via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n\nAlso, the miners will indeed see one valid decommitment. This\ndecommitment may have been sent by the attacker but it's the preimage\nchal of the address, because otherwise it's not valid for the malicious\ncommitment. But if the decommitment is chal, then this decommitment is\nalso valid for the commitment of the honest user, which is earliest\nadditionally. So the honest commitment wins. The attacker does not\nsucceed and everything is fine.\n\nThe reason why this works:\nThere is only one unique decommitment for the UTXO (assuming H_addr is\ncollision-resistant). The decommitment does not depend on the\ncommitment. The attacker cannot send a different decommitment, just\nbecause there is none.\n\n\nIf your argument is that we publish the full transaction minus the public\nkey and signatures, just committing to it, and then revealing that later\n(which means an attacker can't modify the transaction in advance in a way\nthat produces a valid transaction);\n\nAllowing expiration retains insecurity, while allowing expiration makes it\na trivial DoS target.\n\nAnybody can flood the miners with invalid transaction commitments. No miner\ncan ever prune invalid commitments until a valid transaction is finalized\nwhich conflicts with the invalid commitments. You can't even rate limit it\nsafely.\n\nLike I said in the other thread, this is unreasonable. It's much more\npractical with  simple hash commitment that you can \"fold away\" in a Merkle\ntree hash and which you don't need to validate until the full transaction\nis published.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180215/c5df0634/attachment-0001.html>"
            },
            {
                "author": "Natanael",
                "date": "2018-02-15T22:45:09",
                "message_text_only": "Small correction, see edited quote\n\nDen 15 feb. 2018 23:44 skrev \"Natanael\" <natanael.l at gmail.com>:\n\nAllowing expiration retains insecurity, while *NOT* allowing expiration\nmakes it a trivial DoS target.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180215/f3aca9fc/attachment.html>"
            },
            {
                "author": "Tim Ruffing",
                "date": "2018-02-15T23:44:19",
                "message_text_only": "On Thu, 2018-02-15 at 23:44 +0100, Natanael wrote:\n> If your argument is that we publish the full transaction minus the\n> public key and signatures, just committing to it, and then revealing\n> that later (which means an attacker can't modify the transaction in\n> advance in a way that produces a valid transaction);\n\nAlmost. Actually we reveal the entire transaction later. \n\n> \n> [...] while *NOT* allowing expiration makes it a trivial DoS target. \n> \n> Anybody can flood the miners with invalid transaction commitments. No\n> miner can ever prune invalid commitments until a valid transaction is\n> finalized which conflicts with the invalid commitments. You can't\n> even rate limit it safely. \n\nYes, that's certainly true. I mentioned that issue already. \n\nYou can rate limit this: The only thing I see is that one can require\ntransaction fees even for commitments. That's super annoying, because\nyou need a second (PQ-)UTXO just to commit. But it's not impossible.\n\nYou can call this impractical and this may well be true. But what will\nbe most practical in the future depends on many parameters that are\ntotally unclear at the moment, e.g., the efficiency of zero-knowledge\nproof systems. Who knows?\n\nIf you would like to use zero-knowledge proofs to recover an UTXO with\nan P2PKH address, you need to prove in zero-knowledge that you know\nsome secret key x such that H(g^x)=addr. That seems plausible. But\nP2PKH is by far the simplest example. For arbitrary scripts, this can \nbecome pretty complex and nasty, even if our proof systems and machines\nare fast enough."
            }
        ],
        "thread_summary": {
            "title": "Transition to post-quantum",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tim Ruffing",
                "Natanael",
                "Tristan Hoy"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 30051
        }
    },
    {
        "title": "[bitcoin-dev] Revisiting BIP 125 RBF policy.",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2018-02-12T15:52:30",
                "message_text_only": "I think it is worth revisiting BIP 125's replace-by-fee policy for when to\nreplace transactions.\n\nThe current policy can be problematic. As noted earlier by Rhavar,\nsometimes one's transaction becomes pinned making it infeasible to fee bump\nwith RBF.  This happens when one makes a normal payment to a large\ncommercial service, and, while the transaction remains unconfirmed, the\ncommercial service creates a low-fee-rate sweep of one's payment, among a\ncollection of others.  If one wants to RBF this original payment, for\nexample to get confirmation of the change output for use in further\ntransactions, the current BIP 125 rules require that you make a fee bump\nthat exceeds the combined total fees of the original transaction and the\nlow-fee-rate sweep of the commercial service.\n\nThe problem is that, while the fee rate of the sweep is low, the absolute\nsize of the fee can still be large, making it infeasible to RBF the\noriginal transaction.  BIP 125 was defined back in 2015, when perhaps\nrational miners did care about absolute fee amounts. However, today we are\nin an era where rational miners care about fee-rates more than absolute\nfees.  The fee-rate of the large sweep transaction is low enough that we do\nnot expect that miners will be mining it in the same block as the original\ntransaction.  Today, a rational miner will prefer a fee-bumped version of\noriginal transaction without consideration of the low-fee sweep transaction\n(or at least discounting the low-fee sweep in proportion to the miner's\nhash-rate fraction).\n\nLet me quote the five rules that define the current BIP 125 policy:\n\nOne or more transactions currently in the mempool (original transactions)\n> will be replaced by a new transaction (replacement transaction) that spends\n> one or more of the same inputs if,\n>\n>    1. The original transactions signal replaceability explicitly or\n>    through inheritance as described in the above Summary section.\n>    2. The replacement transaction does not contain any new unconfirmed\n>    inputs that did not previously appear in the mempool. (Unconfirmed inputs\n>    are inputs spending outputs from currently unconfirmed transactions.)\n>    3. The replacement transaction pays an absolute fee of at least the\n>    sum paid by the original transactions.\n>    4. The replacement transaction must also pay for its own bandwidth at\n>    or above the rate set by the node's minimum relay fee setting. For example,\n>    if the minimum relay fee is 1 satoshi/byte and the replacement transaction\n>    is 500 bytes total, then the replacement must pay a fee at least 500\n>    satoshis higher than the sum of the originals.\n>    5. The number of original transactions to be replaced and their\n>    descendant transactions which will be evicted from the mempool must not\n>    exceed a total of 100 transactions.\n>\n> To address the new reality of rational miners' consideration, I propose\nchanging rules 3 and 4 to something like the following.\n\n3'. The replacement transaction pays a fee rate of at least the effective\nfee rate of any chain of transactions from the set of original transactions\nthat begins with the root of the original transaction set.\n\n4'. The replacement transaction must also pay for replacing the original\ntransactions at or above the rate set by the node's minimum relay fee\nsetting. For example, if the minimum relay fee is 1 satoshi/byte and the\nreplacement transaction and the original transactions are 1000 bytes total,\nthen the replacement must pay a fee at least 1000 satoshis higher than the\nfee of the root transaction of the original transactions.\n\nRule 3' is a fancy way of saying that the replacement transaction must have\na fee rate that is larger than the package fee rate of the root of the set\nof transactions it replaces, where the package fee rate is the fee rate\nimplied by considering CPFP.\n\nRule 4' is an amended anti-spam rule that is intended to avoid DOS attacks\nfrom churning the mempool. I don't know if it is really necessary to pay\nfor the size of the original transactions being evicted, but some people I\nchatted with thought it could be important.\n\nOther people on the mailing list have been thinking about RBF policy for\nfar longer than I have, so I wouldn't be surprised if my proposal above is\nnaive.  However, I think it can start a conversation about addressing the\nproblems with the current RBF policy.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/fa293ce5/attachment-0001.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-12T17:30:04",
                "message_text_only": "Thank you very much for writing this up.\u00a0 It's worth noting that there can be multiple roots for the transactions that are getting replaced.\n\nSo for rule 3, you probably want a feeRate >= the max \"package fee rate\" of all replaced roots.\n\n\nI am very happy with this proposal in general, as it's clearly a step in the right direction for making transaction replacement practically usable for todays services.\n\n\nHowever, I think your new rule 4 is a bit weak. The logical extension of your proposal would be to allow a transaction (say B) be able to replace transactions (say A) by purely paying a higher fee rate, /even if it's less absolute fee/. In this simple example of B replacing A -- B should pay at least:   (a.FeeRate * b.size) + relayFeeRate*(a.size + b.size)\n\n\n\n\u200b-Ryan\n\n\u200b\n\n-------- Original Message --------\n On February 12, 2018 10:52 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>I think it is worth revisiting BIP 125's replace-by-fee policy for when to replace transactions.\n>The current policy can be problematic. As noted earlier by Rhavar, sometimes one's transaction becomes pinned making it infeasible to fee bump with RBF.\u00a0 This happens when one makes a normal payment to a large commercial service, and, while the transaction remains unconfirmed, the commercial service creates a low-fee-rate sweep of one's payment, among a collection of others.\u00a0 If one wants to RBF this original payment, for example to get confirmation of the change output for use in further transactions, the current BIP 125 rules require that you make a fee bump that exceeds the combined total fees of the original transaction and the low-fee-rate sweep of the commercial service.\n>\n>The problem is that, while the fee rate of the sweep is low, the absolute size of the fee can still be large, making it infeasible to RBF the original transaction.\u00a0 BIP 125 was defined back in 2015, when perhaps rational miners did care about absolute fee amounts. However, today we are in an era where rational miners care about fee-rates more than absolute fees.\u00a0 The fee-rate of the large sweep transaction is low enough that we do not expect that miners will be mining it in the same block as the original transaction.\u00a0 Today, a rational miner will prefer a fee-bumped version of original transaction without consideration of the low-fee sweep transaction (or at least discounting the low-fee sweep in proportion to the miner's hash-rate fraction).\n>\n>Let me quote the five rules that define the current BIP 125 policy:\n>\n>>\n>>One or more transactions currently in the mempool (original\n>>transactions) will be replaced by a new transaction (replacement\n>>transaction) that spends one or more of the same inputs if,\n>>\n>>\n>>1. The original transactions signal replaceability explicitly or through inheritance as described in the above Summary section.\n>>\n>>2. The\n>> replacement transaction does not contain any new unconfirmed inputs \n>>that did not previously appear in the mempool. (Unconfirmed inputs are \n>>inputs spending outputs from currently unconfirmed transactions.)\n>>\n>>3. The replacement transaction pays an absolute fee of at least the sum paid by the original transactions.\n>>\n>>4. The\n>> replacement transaction must also pay for its own bandwidth at or above\n>> the rate set by the node's minimum relay fee setting.  For example, if \n>>the minimum relay fee is 1 satoshi/byte and the replacement transaction \n>>is 500 bytes total, then the replacement must pay a fee at least 500 \n>>satoshis higher than the sum of the originals.\n>>\n>>5. The number of \n>>original transactions to be replaced and their descendant transactions \n>>which will be evicted from the mempool must not exceed a total of 100 \n>>transactions.\n>>\n>>To address the new reality of rational miners' consideration, I propose changing rules 3 and 4 to something like the following.\n>3'. The replacement transaction pays a fee rate of at least the effective fee rate of any chain of transactions from the set of original transactions that begins with the root of the original transaction set.\n>\n>4'. The\n> replacement transaction must also pay for replacing the original transactions at or above\n> the rate set by the node's minimum relay fee setting.  For example, if \n>the minimum relay fee is 1 satoshi/byte and the replacement transaction and the original transactions are 1000 bytes total, then the replacement must pay a fee at least 1000 \n>satoshis higher than the fee of the root transaction of the original transactions.\n>Rule 3' is a fancy way of saying that the replacement transaction must have a fee rate that is larger than the package fee rate of the root of the set of transactions it replaces, where the package fee rate is the fee rate implied by considering CPFP.\n>Rule 4' is an amended anti-spam rule that is intended to avoid DOS attacks from churning the mempool. I don't know if it is really necessary to pay for the size of the original transactions being evicted, but some people I chatted with thought it could be important.\n>\n>Other people on the mailing list have been thinking about RBF policy for far longer than I have, so I wouldn't be surprised if my proposal above is naive.\u00a0 However, I think it can start a conversation about addressing the problems with the current RBF policy.\n>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-02-12T22:58:28",
                "message_text_only": "On Mon, Feb 12, 2018 at 10:52:30AM -0500, Russell O'Connor via bitcoin-dev wrote:\n> I think it is worth revisiting BIP 125's replace-by-fee policy for when to\n> replace transactions.\n> \n> The current policy can be problematic. As noted earlier by Rhavar,\n> sometimes one's transaction becomes pinned making it infeasible to fee bump\n> with RBF.  This happens when one makes a normal payment to a large\n> commercial service, and, while the transaction remains unconfirmed, the\n> commercial service creates a low-fee-rate sweep of one's payment, among a\n> collection of others.  If one wants to RBF this original payment, for\n> example to get confirmation of the change output for use in further\n> transactions, the current BIP 125 rules require that you make a fee bump\n> that exceeds the combined total fees of the original transaction and the\n> low-fee-rate sweep of the commercial service.\n> \n> The problem is that, while the fee rate of the sweep is low, the absolute\n> size of the fee can still be large, making it infeasible to RBF the\n> original transaction.  BIP 125 was defined back in 2015, when perhaps\n> rational miners did care about absolute fee amounts. However, today we are\n> in an era where rational miners care about fee-rates more than absolute\n> fees.  The fee-rate of the large sweep transaction is low enough that we do\n> not expect that miners will be mining it in the same block as the original\n> transaction.  Today, a rational miner will prefer a fee-bumped version of\n> original transaction without consideration of the low-fee sweep transaction\n> (or at least discounting the low-fee sweep in proportion to the miner's\n> hash-rate fraction).\n\nI don't actually see where the problem is here. First of all, suppose we have a\ntransaction T_a that already pays Alice with a feerate sufficiently high that\nwe expect it to get mined in the near future. If we want to pay Bob, we can do\nthat by simply creating a double-spend of T_a that pays both Bob and Alice,\nT_{ab}. BIP125 only requires that double-spend to have an absolute fee higher\nthan the minimum relay feerate * size of the transaction.\n\nI just checked one of my nodes, and the absolute minimum relay fee is about\n1/5th that of what estimatefee returns for the longest possible estimate, 48\nblocks. Depends on the exact circumstances, but it'll likely be worth it to pay\nBob with a replacement of T_a rather than create a second transaction due to\nthat difference.\n\nSecondly, if for some reason you need to broadcast a separate transaction\npaying Bob before you do the replacement, again I don't see an issue: just make\na minimum fee T_b that pays Bob, and replace both with T_{ab}. Again, the big\ndifference between minimum fee and what you might actually pay in fees means\nthat you'll still save money in most cases, so long as your wallet is\nintelligent enough to pick a low feerate for T_b.\n\n> Let me quote the five rules that define the current BIP 125 policy:\n> \n> One or more transactions currently in the mempool (original transactions)\n> > will be replaced by a new transaction (replacement transaction) that spends\n> > one or more of the same inputs if,\n> >\n> >    1. The original transactions signal replaceability explicitly or\n> >    through inheritance as described in the above Summary section.\n> >    2. The replacement transaction does not contain any new unconfirmed\n> >    inputs that did not previously appear in the mempool. (Unconfirmed inputs\n> >    are inputs spending outputs from currently unconfirmed transactions.)\n> >    3. The replacement transaction pays an absolute fee of at least the\n> >    sum paid by the original transactions.\n> >    4. The replacement transaction must also pay for its own bandwidth at\n> >    or above the rate set by the node's minimum relay fee setting. For example,\n> >    if the minimum relay fee is 1 satoshi/byte and the replacement transaction\n> >    is 500 bytes total, then the replacement must pay a fee at least 500\n> >    satoshis higher than the sum of the originals.\n> >    5. The number of original transactions to be replaced and their\n> >    descendant transactions which will be evicted from the mempool must not\n> >    exceed a total of 100 transactions.\n> >\n> > To address the new reality of rational miners' consideration, I propose\n> changing rules 3 and 4 to something like the following.\n> \n> 3'. The replacement transaction pays a fee rate of at least the effective\n> fee rate of any chain of transactions from the set of original transactions\n> that begins with the root of the original transaction set.\n\nI think what you mean here should be the effective fee rate of the maximum\nfeerate package that can be built from the set of transactions that begins with\nthe candidate replacement. But actually calculating this is I believe\nnon-trivial, which is why I didn't implement it this way when RBF was first\nimplemented.\n\n> 4'. The replacement transaction must also pay for replacing the original\n> transactions at or above the rate set by the node's minimum relay fee\n> setting. For example, if the minimum relay fee is 1 satoshi/byte and the\n> replacement transaction and the original transactions are 1000 bytes total,\n> then the replacement must pay a fee at least 1000 satoshis higher than the\n> fee of the root transaction of the original transactions.\n\nSo the previous version of condition #4 does this implicitly because the\nabsolute fee isn't allowed to go down; you're effectively re-adding this\ncondition. But as I've shown above, you can get the same *behavior* by simply\nensuring that the transactions you broadcast that you'll want to double-spend\nhave a minimum feerate in the first place.\n\n> Rule 3' is a fancy way of saying that the replacement transaction must have\n> a fee rate that is larger than the package fee rate of the root of the set\n> of transactions it replaces, where the package fee rate is the fee rate\n> implied by considering CPFP.\n> \n> Rule 4' is an amended anti-spam rule that is intended to avoid DOS attacks\n> from churning the mempool. I don't know if it is really necessary to pay\n> for the size of the original transactions being evicted, but some people I\n> chatted with thought it could be important.\n\nI think this is very important. For example, without this condition I could do\na DoS attack by repeatedly broadcasting a transaction, then spending the\noutputs of that transaction with a very large number of child transactions, all\nof minimum fee. With up to 100 transactions allowed for consideration, and a\n100KB max transaction size, that could be up to ~10MB of transactions.\n\nNext I double spend the root, increasing it's feerate but *not* paying for the\nchild transactions. Those ~10MB are now evicted from the mempool, and I can\nrepeat the cycle again. The cost is whatever the root tx replacement cost,\nwhich will be much less than the cost of broadcasting 10MB should have been.\n\n> Other people on the mailing list have been thinking about RBF policy for\n> far longer than I have, so I wouldn't be surprised if my proposal above is\n> naive.  However, I think it can start a conversation about addressing the\n> problems with the current RBF policy.\n\nA better way to solve this class of problems may be diffed tx replacement\npropagation: basically broadcast a diff between the original tx and the\nproposed replacement, allowing you to do the minimum bandwidth accounting based\non the size of the diff instead.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/7c69245e/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-02-12T23:19:40",
                "message_text_only": "On Mon, Feb 12, 2018 at 5:58 PM, Peter Todd <pete at petertodd.org> wrote:\n\n>\n> I don't actually see where the problem is here. First of all, suppose we\n> have a\n> transaction T_a that already pays Alice with a feerate sufficiently high\n> that\n> we expect it to get mined in the near future. If we want to pay Bob, we\n> can do\n> that by simply creating a double-spend of T_a that pays both Bob and Alice,\n> T_{ab}. BIP125 only requires that double-spend to have an absolute fee\n> higher\n> than the minimum relay feerate * size of the transaction.\n>\n\nThe problem is that rule 3 of BIP 125 requires you pay a fee that is higher\nthan the the fee of T_a *plus* the fee of the sweep-transaction that the\nAlice has added as a unconfirmed child transaction to T_a because\ndouble-spending to pay Alice and Bob invalidates Alice's\nsweep-transaction.  Alice's sweep-transaction is very large, and hence pays\na large absolute fee even though her fee-rate is very low.  We do not have\nany control over its value, hence Alice has \"pinned\" our RBF transaction.\n\n> 3'. The replacement transaction pays a fee rate of at least the effective\n> > fee rate of any chain of transactions from the set of original\n> transactions\n> > that begins with the root of the original transaction set.\n>\n> I think what you mean here should be the effective fee rate of the maximum\n> feerate package that can be built from the set of transactions that begins\n> with\n> the candidate replacement. But actually calculating this is I believe\n> non-trivial, which is why I didn't implement it this way when RBF was first\n> implemented.\n>\n\nYes, that is what I mean.  My proposal was off-the-mark.\n\nSurely CPFP is already computing the package-fee rates of mempool\ntransactions.  That is the value we need to compute.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/c1b15de0/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-02-12T23:42:25",
                "message_text_only": "On Mon, Feb 12, 2018 at 06:19:40PM -0500, Russell O'Connor wrote:\n> On Mon, Feb 12, 2018 at 5:58 PM, Peter Todd <pete at petertodd.org> wrote:\n> \n> >\n> > I don't actually see where the problem is here. First of all, suppose we\n> > have a\n> > transaction T_a that already pays Alice with a feerate sufficiently high\n> > that\n> > we expect it to get mined in the near future. If we want to pay Bob, we\n> > can do\n> > that by simply creating a double-spend of T_a that pays both Bob and Alice,\n> > T_{ab}. BIP125 only requires that double-spend to have an absolute fee\n> > higher\n> > than the minimum relay feerate * size of the transaction.\n> >\n> \n> The problem is that rule 3 of BIP 125 requires you pay a fee that is higher\n> than the the fee of T_a *plus* the fee of the sweep-transaction that the\n> Alice has added as a unconfirmed child transaction to T_a because\n> double-spending to pay Alice and Bob invalidates Alice's\n> sweep-transaction.  Alice's sweep-transaction is very large, and hence pays\n> a large absolute fee even though her fee-rate is very low.  We do not have\n> any control over its value, hence Alice has \"pinned\" our RBF transaction.\n\nAh ok, I misunderstood and didn't realise you were talking about the case where\nAlice re-spends her unconfirmed payment. Unfortunately I don't think that case\nis possible to solve without putting some kind of restriction on spending\nunconfirmed outputs; with a restriction it's fairly simple to solve.\n\n> > I think what you mean here should be the effective fee rate of the maximum\n> > feerate package that can be built from the set of transactions that begins\n> > with\n> > the candidate replacement. But actually calculating this is I believe\n> > non-trivial, which is why I didn't implement it this way when RBF was first\n> > implemented.\n> >\n> \n> Yes, that is what I mean.  My proposal was off-the-mark.\n> \n> Surely CPFP is already computing the package-fee rates of mempool\n> transactions.  That is the value we need to compute.\n\nTrue, maybe we can just reuse the CPFP calculation now. That said, AFAIK that's\nonly done in the miner code, not the mempool, so that may not be trivial to\nactually do.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/416aec03/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-02-12T23:46:43",
                "message_text_only": "On Mon, Feb 12, 2018 at 6:42 PM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Feb 12, 2018 at 06:19:40PM -0500, Russell O'Connor wrote:\n> > On Mon, Feb 12, 2018 at 5:58 PM, Peter Todd <pete at petertodd.org> wrote:\n> >\n> > >\n> > > I don't actually see where the problem is here. First of all, suppose\n> we\n> > > have a\n> > > transaction T_a that already pays Alice with a feerate sufficiently\n> high\n> > > that\n> > > we expect it to get mined in the near future. If we want to pay Bob, we\n> > > can do\n> > > that by simply creating a double-spend of T_a that pays both Bob and\n> Alice,\n> > > T_{ab}. BIP125 only requires that double-spend to have an absolute fee\n> > > higher\n> > > than the minimum relay feerate * size of the transaction.\n> > >\n> >\n> > The problem is that rule 3 of BIP 125 requires you pay a fee that is\n> higher\n> > than the the fee of T_a *plus* the fee of the sweep-transaction that the\n> > Alice has added as a unconfirmed child transaction to T_a because\n> > double-spending to pay Alice and Bob invalidates Alice's\n> > sweep-transaction.  Alice's sweep-transaction is very large, and hence\n> pays\n> > a large absolute fee even though her fee-rate is very low.  We do not\n> have\n> > any control over its value, hence Alice has \"pinned\" our RBF transaction.\n>\n> Ah ok, I misunderstood and didn't realise you were talking about the case\n> where\n> Alice re-spends her unconfirmed payment. Unfortunately I don't think that\n> case\n> is possible to solve without putting some kind of restriction on spending\n> unconfirmed outputs; with a restriction it's fairly simple to solve.\n>\n\nAdding such a restriction was Rhavar's original suggestion in\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014688.html,\nbut it seems the proposal wasn't well received because it kinda destroys\nCPFP.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/c7158cb4/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-02-14T14:08:01",
                "message_text_only": "On Mon, Feb 12, 2018 at 6:42 PM, Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Feb 12, 2018 at 06:19:40PM -0500, Russell O'Connor wrote:\n> > Surely CPFP is already computing the package-fee rates of mempool\n> > transactions.  That is the value we need to compute.\n>\n> True, maybe we can just reuse the CPFP calculation now. That said, AFAIK\n> that's\n> only done in the miner code, not the mempool, so that may not be trivial to\n> actually do.\n>\n\nDo you (or anyone else) know if the package fee rate is considered when\nejecting transactions from the bottom of the mempool when the mempool gets\ntoo large?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180214/18428424/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2018-02-14T14:16:29",
                "message_text_only": "Yes.\n\nOn Wed, Feb 14, 2018 at 9:08 AM, Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Feb 12, 2018 at 6:42 PM, Peter Todd <pete at petertodd.org> wrote:\n>\n>> On Mon, Feb 12, 2018 at 06:19:40PM -0500, Russell O'Connor wrote:\n>> > Surely CPFP is already computing the package-fee rates of mempool\n>> > transactions.  That is the value we need to compute.\n>>\n>> True, maybe we can just reuse the CPFP calculation now. That said, AFAIK\n>> that's\n>> only done in the miner code, not the mempool, so that may not be trivial\n>> to\n>> actually do.\n>>\n>\n> Do you (or anyone else) know if the package fee rate is considered when\n> ejecting transactions from the bottom of the mempool when the mempool gets\n> too large?\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180214/345c3933/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2018-02-27T16:25:59",
                "message_text_only": "On Mon, Feb 12, 2018 at 6:42 PM, Peter Todd <pete at petertodd.org> wrote:\n\n>\n> Ah ok, I misunderstood and didn't realise you were talking about the case\n> where\n> Alice re-spends her unconfirmed payment. Unfortunately I don't think that\n> case\n> is possible to solve without putting some kind of restriction on spending\n> unconfirmed outputs; with a restriction it's fairly simple to solve.\n\n\nWhen you say that you don't think it is possible to solve, do you mean that\nthere is a specific problem with this proposal of replacing transactions\nwhen offered a new transaction whose fee rate exceeds the package fee rate\nof the original transaction (and ensuring that the fee increase covers the\nsize of the transactions being ejected)?  Is your concern only about the\nability to computing and track the package fee rate for transactions within\nthe mempool or is there some other issue you foresee?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180227/33ef4b98/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-12T23:23:12",
                "message_text_only": "On February 12, 2018 5:58 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I don't actually see where the problem is here. First of all, suppose we have a\n> transaction T_a that already pays Alice with a feerate sufficiently high that\n> we expect it to get mined in the near future. If we want to pay Bob, we can do\n> that by simply creating a double-spend of T_a that pays both Bob and Alice,\n> T_{ab}. BIP125 only requires that double-spend to have an absolute fee higher\n> than the minimum relay feerate * size of the transaction.\n\nIt's a bit of a made up term, but when Russel said \"pinned\" it refers to a child transaction that was made  (i.e. in this case by Alice) and for us to replace our transaction we need to \"unpin\" it.\n\nHowever to unpin it, the current bip125 rules require you pay not only the relay of the transactions you're throwing away, but the absolute fee. This is general is cost prohibitive, as even a normalish transaction can be spending $20 in fees. \n\nAlso FWIW this whole idea of T_a and T_ab  is good, but it's also pretty impractical at the moment due to the sheer amount complexity it introduces (i.e. monitoring, seeing which confirms, trying to rebroadcast the missing one in a way that is safe against reorgs, blah blah).\n\n\n\n>\n> I just checked one of my nodes, and the absolute minimum relay fee is about\n> 1/5th that of what estimatefee returns for the longest possible estimate, 48\n> blocks.\n\nIf you use estimatesmartfee you should be able to get estimates all the way to 1008 or something btw\n\n> [...]\n> I think this is very important. For example, without this condition I could do\n> a DoS attack by repeatedly broadcasting a transaction, then spending the\n> outputs of that transaction with a very large number of child transactions, all\n> of minimum fee. \n\nI agree.\n\n>\n> A better way to solve this class of problems may be diffed tx replacement\n> propagation: basically broadcast a diff between the original tx and the\n> proposed replacement, allowing you to do the minimum bandwidth accounting based\n> on the size of the diff instead.\n\nThis would definitely work for some specific use-case. For instance currently if you do n replacements of a transaction, each time adding an additional output .. you need to pay something like O(n^2) relay fee. If you used a diff instead, you could probably get it to O(n)ish. \n\nBut relay fee (and n) at the moment, mean it's not a big deal at all. The big flaw (imo) in bip125 is that you need to pay the absolute fee from the transactions you are evicting. And that can be from transactions you didn't even generate yourself.  We can already compactly represent the diff  (the new transaction invalidates it)  the debate is more \"Should you have to pay the absolute fee or just relay fee for the stuff you invalidate\""
            },
            {
                "author": "Peter Todd",
                "date": "2018-02-13T18:40:34",
                "message_text_only": "On Mon, Feb 12, 2018 at 06:23:12PM -0500, rhavar at protonmail.com wrote:\n> \n>  On February 12, 2018 5:58 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> > I don't actually see where the problem is here. First of all, suppose we have a\n> > transaction T_a that already pays Alice with a feerate sufficiently high that\n> > we expect it to get mined in the near future. If we want to pay Bob, we can do\n> > that by simply creating a double-spend of T_a that pays both Bob and Alice,\n> > T_{ab}. BIP125 only requires that double-spend to have an absolute fee higher\n> > than the minimum relay feerate * size of the transaction.\n> \n> It's a bit of a made up term, but when Russel said \"pinned\" it refers to a child transaction that was made  (i.e. in this case by Alice) and for us to replace our transaction we need to \"unpin\" it.\n\nYeah, sorry, I just misread what scenario you guys were talking about. IIRC the\nterm \"pinned\" may have even been invented by myself, as IIRC I noticed the\nissue when the RBF patch was being developed years ago. I don't think I had a\nsolution at the time so I just punted on it.\n\n> However to unpin it, the current bip125 rules require you pay not only the relay of the transactions you're throwing away, but the absolute fee. This is general is cost prohibitive, as even a normalish transaction can be spending $20 in fees. \n> \n> Also FWIW this whole idea of T_a and T_ab  is good, but it's also pretty impractical at the moment due to the sheer amount complexity it introduces (i.e. monitoring, seeing which confirms, trying to rebroadcast the missing one in a way that is safe against reorgs, blah blah).\n\nI'm not sure that's actually true, as you're only creating transactions sets\nthat are reorg safe. Though I don't have a detailed design in mind so I may be\nmissing something.\n\n> > A better way to solve this class of problems may be diffed tx replacement\n> > propagation: basically broadcast a diff between the original tx and the\n> > proposed replacement, allowing you to do the minimum bandwidth accounting based\n> > on the size of the diff instead.\n> \n> This would definitely work for some specific use-case. For instance currently if you do n replacements of a transaction, each time adding an additional output .. you need to pay something like O(n^2) relay fee. If you used a diff instead, you could probably get it to O(n)ish. \n> \n> But relay fee (and n) at the moment, mean it's not a big deal at all. The big flaw (imo) in bip125 is that you need to pay the absolute fee from the transactions you are evicting. And that can be from transactions you didn't even generate yourself.  We can already compactly represent the diff  (the new transaction invalidates it)  the debate is more \"Should you have to pay the absolute fee or just relay fee for the stuff you invalidate\"\n\nYes, the diff approach doesn't help for the pinned case.\n\nUnfortunately the only solution I have is basically the same as what you\nproposed(1) months ago: limit spends of unconfirmed outputs in some way.\n\nSo here's a question: how many wallets have actually implemented CPFP fee bumps\nfor incoming transactions?\n\n1) https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014688.html\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/a96b97d8/attachment-0001.sig>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-14T02:07:25",
                "message_text_only": "On February 13, 2018 1:40 PM, Peter Todd <pete at petertodd.org> wrote:\n\n> Yeah, sorry, I just misread what scenario you guys were talking about. IIRC the\n> term \"pinned\" may have even been invented by myself, as IIRC I noticed the\n> issue when the RBF patch was being developed years ago. I don't think I had a\n> solution at the time so I just punted on it.\n\nYeah. I posted that before it was clarified, it's just my message got held up in the moderation queue so it came out of order at an inconvenient time ><\n\n\n\n> I'm not sure that's actually true, as you're only creating transactions sets\n> that are reorg safe. Though I don't have a detailed design in mind so I may be\n> missing something.\n\nIt is. T_a and T_ab are \"reorg\" safe, but if T_a confirms you will still need to pay Bob in way. But you need to pay him such that in a reorg occurs and suddenly T_ab is mined, you haven't doubled paid him. \n\nI've been working on it's implementation, but it's honestly really complex and hard to test. I outlined the procedure here: https://gist.github.com/RHavar/cff76a026ece8446c898470db4f35682  which I call \"Super Withdrawals\".\n\n\nMy point though isn't that it's impossible, it's that it's sufficiently complex that it's unreasonable to expect anyone to be doing it any time soon. By relaxing any unnecessary restrictions on bip125, just makes it _drastically_ easier to do certain things.\n\n> So here's a question: how many wallets have actually implemented CPFP fee bumps\n> for incoming transactions?\n\nNever tried it, but I recall seeing it in the electrum gui. I originally tried supporting this myself, but it's kind of annoying. It's  generally a bit cost-prohibitive to create a transaction specifically for the purpose of a CPFP fee bump, but since I made transactions pretty frequently (averaged say every 8 minutes) it doesn't add an additional input for the purpose of bumping selected incoming transactions.\n\nThe work flow is reasonably smooth: Alice has sent me 1 BTC with low fees, I owe Bob some money. I source Alice's output in the payment to Bob, giving her transaction a fee bump. Both transactions confirm, everyone is happy.\n\nHowever during the whole time I need to watch Alice's transaction because if it ever is replaced/conflicted, I need to immediately pay Bob (in a reorg safe way, so I don't double-pay). It's not terribly hard to do, by making sure when I pay Bob I use an additional input that I also use for any \"repayment\" but it's enough complexity and hard enough to test that I gave up.\n\nThe really nice thing of most current send systems (and now especially so with segwit) is everything is pretty much fire and forget.  (although I just schedule in 0.5, 1, 2, 4, .... 32 hours fee bump attempts. But that's just background that can fail/succeed blindly)\n\n\n\n\n\n\n>\n>1. https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-July/014688.html\n>\n> --\n>https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n>"
            }
        ],
        "thread_summary": {
            "title": "Revisiting BIP 125 RBF policy.",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Russell O'Connor",
                "rhavar at protonmail.com",
                "Peter Todd",
                "Greg Sanders"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 36472
        }
    },
    {
        "title": "[bitcoin-dev] Total fees have almost crossed the block reward",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2018-02-12T17:23:35",
                "message_text_only": "On 21 December 2017 at 22:30, Melvin Carvalho <melvincarvalho at gmail.com>\nwrote:\n\n> I asked adam back at hcpp how the block chain would be secured in the long\n> term, once the reward goes away.  The base idea has always been that fees\n> would replace the block reward.\n>\n> At that time fees were approximately 10% of the block reward, but have now\n> reached 45%, with 50% potentially being crossed soon\n>\n> https://fork.lol/reward/feepct\n>\n> While this bodes well for the long term security of the coin, I think\n> there is some legitimate concern that the fee per tx is prohibitive for\n> some use cases, at this point in the adoption curve.\n>\n> Observations of segwit adoption show around 10% at this point\n>\n> http://segwit.party/charts/\n>\n> Watching the mempool shows that the congestion is at a peak, though it's\n> quite possible this will come down over the long weekend.  I wonder if this\n> is of concern to some.\n>\n> https://dedi.jochen-hoenicke.de/queue/more/#24h\n>\n> I thought these data points may be of interest and are mainly FYI.  Though\n> if further discussion is deemed appropriate, it would be interesting to\n> hear thoughts.\n>\n\nJust following up on this, for no other reason than I've had my eyes glued\nto these stats the last few weeks.  I'll share a few more stats links.\n\nMempool has come down significantly, as have fees.  Tho, of course, this\ncould spike any time.\n\nhttps://bitinfocharts.com/bitcoin/\n\nTypically fees are :\n\n $2.06 on tx $543 (median) # 0.38%\n $3.47 on tx $75,000 (mean) # 0.005%\n\nAside: An observation on this.  High value transactors seems to be getting\na much better deal, than the mean.  This lead me to ponder whether the\nintuitive metric of satoshi/byte is, in fact, game theory optimal.\nPossibly over the short term it is, but over a longer period, those wishing\nto increase the longevity of proof of work in general might wish to\nconsider more progressive fee approaches.  Naively, it might be possible to\nimagine some kind of gaussian distribution that picks tx according to a\nblended combination of sats/byte and %transacted.  Perhaps something for\nminers and fee estimation algorithms to develop over time.\n\nSegwit adoption has increased, and anecdotal evidence shows that trend to\ncontinue.  The release of 0.16 will I think also have a positive effect.\n\nFinally, I came across this wonderful site that shows lightning network\nadoption on mainnet\n\nhttp://shabang.io/\n\nLN is increasing well.  Some blocks are not far off 1% lightning funding,\nwhich I think bodes well.  I'll go out on a limb and predict that over 1%\nof btc tx will be lightning based by year end.\n\nSince such posts are not strictly development, I'll keep them to a\nminimum.  However, I hope these stats provide useful data points for\nproject evolution.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/e65cbca0/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-12T17:47:50",
                "message_text_only": "> This lead me to ponder whether the intuitive metric of satoshi/byte is, in fact, game\n>theory optimal.\u00a0 Possibly over the short term it is, but over a longer period, those\n> wishing to increase the longevity of proof of work in general might wish to consider\n> more progressive fee approaches.\u00a0\n\nThe constraining factor for blocks is the max-block weight. So miners are already optimizing for the right thing (creating a block that gives the most immediate reward). If miners want to start a cartel-like behavior of charging more for more value-transfer it would be incredibly harmful and even likely promote centralization (the cartel would likely not look kindly on any miner who doesn't follow their rules, and perhaps start orphaning their blocks).\n\nNow I guess in theory you could add consensus rules that apply restrictions on the amount of \"value transfer\" in a block, such that miners are motivated to charge more for high-value transactions. However there's going to be almost 0 appetite from anyone to want to do anything like this, and the amount of unintended and harmful side effects would be profound.  (Personally, I'd lose any interest in bitcoin if such a change was ever instated)\n\n\n\u200b-Ryan\n\n\u200b\n\n-------- Original Message --------\n On February 12, 2018 12:23 PM, Melvin Carvalho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n>On 21 December 2017 at 22:30, Melvin Carvalho <melvincarvalho at gmail.com> wrote:\n>>I asked adam back at hcpp how the block chain would be secured in the long term, once the reward goes away.\u00a0 The base idea has always been that fees would replace the block reward.\n>>At that time fees were approximately 10% of the block reward, but have now reached 45%, with 50% potentially being crossed soon\n>>\n>>https://fork.lol/reward/feepct\n>>\n>>While this bodes well for the long term security of the coin, I think there is some legitimate concern that the fee per tx is prohibitive for some use cases, at this point in the adoption curve.\n>>\n>>Observations of segwit adoption show around 10% at this point\n>>\n>>http://segwit.party/charts/\n>>\n>>Watching the mempool shows that the congestion is at a peak, though it's quite possible this will come down over the long weekend.\u00a0 I wonder if this is of concern to some.\n>>\n>>https://dedi.jochen-hoenicke.de/queue/more/#24h\n>>\n>>I thought these data points may be of interest and are mainly FYI.\u00a0 Though if further discussion is deemed appropriate, it would be interesting to hear thoughts.\n>>\n>Just following up on this, for no other reason than I've had my eyes glued to these stats the last few weeks.\u00a0 I'll share a few more stats links.\n>Mempool has come down significantly, as have fees.\u00a0 Tho, of course, this could spike any time.\u00a0 \n>\n>https://bitinfocharts.com/bitcoin/\n>Typically fees are :\n>\n>\u00a0$2.06 on tx $543 (median) # 0.38%\n>\u00a0$3.47 on tx $75,000 (mean) # 0.005%\n>Aside: An observation on this.\u00a0 High value transactors seems to be getting a much better deal, than the mean.\u00a0 This lead me to ponder whether the intuitive metric of satoshi/byte is, in fact, game theory optimal.\u00a0 Possibly over the short term it is, but over a longer period, those wishing to increase the longevity of proof of work in general might wish to consider more progressive fee approaches.\u00a0 Naively, it might be possible to imagine some kind of gaussian distribution that picks tx according to a blended combination of sats/byte and %transacted.\u00a0 Perhaps something for miners and fee estimation algorithms to develop over time.\n>Segwit adoption has increased, and anecdotal evidence shows that trend to continue.\u00a0 The release of 0.16 will I think also have a positive effect.\n>Finally, I came across this wonderful site that shows lightning network adoption on mainnet\n>\n>http://shabang.io/\n>LN is increasing well.\u00a0 Some blocks are not far off 1% lightning funding, which I think bodes well.\u00a0 I'll go out on a limb and predict that over 1% of btc tx will be lightning based by year end.\n>Since such posts are not strictly development, I'll keep them to a minimum.\u00a0 However, I hope these stats provide useful data points for project evolution.\n>\n>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-02-12T18:12:32",
                "message_text_only": "On Mon, Feb 12, 2018 at 06:23:35PM +0100, Melvin Carvalho via bitcoin-dev wrote:\n> Finally, I came across this wonderful site that shows lightning network\n> adoption on mainnet\n> \n> http://shabang.io/\n> \n> LN is increasing well.  Some blocks are not far off 1% lightning funding,\n> which I think bodes well.  I'll go out on a limb and predict that over 1%\n> of btc tx will be lightning based by year end.\n\nDoes shabang.io say anywhere how it determines whether or not a transaction\nfunded a Lightning channel?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180212/9c2d6824/attachment-0001.sig>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-02-12T19:41:39",
                "message_text_only": "Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nwrites:\n> Does shabang.io say anywhere how it determines whether or not a transaction\n> funded a Lightning channel?\n\nMy guess they simply collect the short_channel_ids which point to\non-chain outputs that funded a channel. This relies on the channels\nbeing public, non-public channels can still be identified on settlement."
            },
            {
                "author": "Peter Todd",
                "date": "2018-02-13T19:03:17",
                "message_text_only": "On Mon, Feb 12, 2018 at 08:41:39PM +0100, Christian Decker wrote:\n> Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> writes:\n> > Does shabang.io say anywhere how it determines whether or not a transaction\n> > funded a Lightning channel?\n> \n> My guess they simply collect the short_channel_ids which point to\n> on-chain outputs that funded a channel. This relies on the channels\n> being public, non-public channels can still be identified on settlement.\n\nSounds plausible; it'd be good if they documented that on the site!\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/1d252f34/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Total fees have almost crossed the block reward",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Melvin Carvalho",
                "rhavar at protonmail.com",
                "Peter Todd",
                "Christian Decker"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 9204
        }
    },
    {
        "title": "[bitcoin-dev] Possible change to the MIT license",
        "thread_messages": [
            {
                "author": "JOSE FEMENIAS CA\u00d1UELO",
                "date": "2018-02-13T12:25:53",
                "message_text_only": "Hi,\n\nBitcoin is licensed under the MIT license (https://github.com/bitcoin/bitcoin/blob/master/COPYING <https://github.com/bitcoin/bitcoin/blob/master/COPYING>) which is one of the most permissive licenses widely in use.\nWhile this almost restriction-less license has proved useful to many software projects, I think it could be wise to question its current suitability for this project, given the recent history.\n\nThe difficulty among the general population to distinguish between Bitcoin (the protocol and software) and bitcoin (the currency) arises spontaneously from the intimate entanglement of both. \nThe current list of Bitcoin lookalikes includes: Bitcoin Cash, Bitcoin Gold, Bitcoin Diamond, Bitcoin God, Bitcoin Clashic, Super Bitcoin, Bitcoin Hot, Bitcoin X, Oil Bitcoin, Bitcoin World, Lightning Bitcoin...\n\nThis recent flurry of hard forks is, IMHO, exacerbating the confusion about the very nature of the project, and harming it in many ways.\n\nAlthough the liberal MIT license is (rightfully) beneficial to many other projects, companies and individuals, it is my belief that several projects are unfairly taking advantage of this generous license to attack Bitcoin (both the software and the currency), confuse the public, and gain personal profit in a way that is severely harming the Bitcoin ecosystem.\n\nTherefore, I\u2019d like to raise the possibility of amending the MIT license in a simple way, by adding a line such as:\n\n\n***\nNO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN (CORE) BLOCKCHAIN\n***\n\n(This is just an approximation. A final version would probably have to include a restriction to some soundalikes like BITKOIN, BIITCOIN,\u2026)\n\nThis way, I could legitimate use this software to create my own crypto coin, or use it in Ethereum, Litecoin or any of the other legitimate cryptos, but I could not make my \u201cBitcoin Whatever\u201d fork and keep using this software as the basis for it. I could also fork the bitcoin blockchain to create \u201cBcoin lightspeed\u201d but not \u201cBitcoin lightspeed\u201d for instance.\n\nI know this would probably not prevent the explosion of forks in the future, but maybe it could help mitigate the confusion among the users and the harm to this community. Even if its enforceability is dubious, at least any infringing project would be exposed to some liability. I see myself some possible loopholes the way the license addendum is written. My intention is not to arrive immediately to a final wording but to know if there is some value to the idea of changing the license with this purpose.\n\n\nJose Femenias"
            },
            {
                "author": "Natanael",
                "date": "2018-02-13T14:25:10",
                "message_text_only": "Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org>:\n\n***\nNO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES THE\nNAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS THE\nSOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n(CORE) BLOCKCHAIN\n***\n\n\nThat's better solved with trademarks. (whoever would be the trademark\nholder - Satoshi?)\n\nThis would also prohibit any reimplementation that's not formally verified\nto be perfectly compatible from using the name.\n\nIt also adds legal uncertainty.\n\nAnother major problem is that it neither affects anybody forking older\nversions of Bitcoin, not people using existing independent blockchain\nimplementations and renaming them Bitcoin-Whatsoever.\n\nAnd what happens when an old version is technically incompatible with a\nfuture version by the Core team due to not understanding various new\nsoftforks? Which version wins the right to the name?\n\nAlso, being unable to even mention Bitcoin is overkill.\n\nThe software license also don't affect the blockchain data.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/5c9fcd62/attachment-0001.html>"
            },
            {
                "author": "Jameson Lopp",
                "date": "2018-02-13T15:24:55",
                "message_text_only": "If I'm understanding the problem being stated correctly:\n\n\"Bitcoin is under a branding attack by fork coins.\"\n\nThe proposed solution is to disincentivize fork coins from using the word\nBitcoin by altering the license terms. I'm not a lawyer, but it seems to me\nthat the words of the license are basically useless unless there is an\nentity that intends to make use of court systems to threaten noncompliant\nprojects into submission.\n\nIn my opinion, the perceived attack on Bitcoin here is social /\nmarketing-based, thus it makes sense that any defense against said attack\nshould also be social / marketing-based. I don't think that Bitcoin should\nbe reliant upon courts or governments to defend itself against attacks of\nany form.\n\nOn Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n> ***\n> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n> (CORE) BLOCKCHAIN\n> ***\n>\n>\n> That's better solved with trademarks. (whoever would be the trademark\n> holder - Satoshi?)\n>\n> This would also prohibit any reimplementation that's not formally verified\n> to be perfectly compatible from using the name.\n>\n> It also adds legal uncertainty.\n>\n> Another major problem is that it neither affects anybody forking older\n> versions of Bitcoin, not people using existing independent blockchain\n> implementations and renaming them Bitcoin-Whatsoever.\n>\n> And what happens when an old version is technically incompatible with a\n> future version by the Core team due to not understanding various new\n> softforks? Which version wins the right to the name?\n>\n> Also, being unable to even mention Bitcoin is overkill.\n>\n> The software license also don't affect the blockchain data.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/6b606fdf/attachment.html>"
            },
            {
                "author": "Brian Lockhart",
                "date": "2018-02-13T15:37:09",
                "message_text_only": "> I don't think that Bitcoin should be reliant upon courts or governments\nto defend itself against attacks of any form.\n\nAgree 100%. Plus yeah, lotsa luck getting any success via those channels...\n\nBut assuming the answer to the perceived problem is to \u201cfight fire with\nfire\u201d (using social / marketing based efforts) who \u201cshould\u201d pick up the\nmantle here? Without inciting riots by asking the question, wouldn\u2019t that\nostensibly be something the Bitcoin Foundation would lead on here? <ducks\nand runs for cover>\n\nIn any case, it\u2019s frustrating to watch the ongoing FUD and scammery going\nunanswered in any \u201cofficial\u201d capacity.\n\n\nOn February 13, 2018 at 7:25:35 AM, Jameson Lopp via bitcoin-dev (\nbitcoin-dev at lists.linuxfoundation.org) wrote:\n\nIf I'm understanding the problem being stated correctly:\n\n\"Bitcoin is under a branding attack by fork coins.\"\n\nThe proposed solution is to disincentivize fork coins from using the word\nBitcoin by altering the license terms. I'm not a lawyer, but it seems to me\nthat the words of the license are basically useless unless there is an\nentity that intends to make use of court systems to threaten noncompliant\nprojects into submission.\n\nIn my opinion, the perceived attack on Bitcoin here is social /\nmarketing-based, thus it makes sense that any defense against said attack\nshould also be social / marketing-based. I don't think that Bitcoin should\nbe reliant upon courts or governments to defend itself against attacks of\nany form.\n\nOn Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n> ***\n> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n> (CORE) BLOCKCHAIN\n> ***\n>\n>\n> That's better solved with trademarks. (whoever would be the trademark\n> holder - Satoshi?)\n>\n> This would also prohibit any reimplementation that's not formally verified\n> to be perfectly compatible from using the name.\n>\n> It also adds legal uncertainty.\n>\n> Another major problem is that it neither affects anybody forking older\n> versions of Bitcoin, not people using existing independent blockchain\n> implementations and renaming them Bitcoin-Whatsoever.\n>\n> And what happens when an old version is technically incompatible with a\n> future version by the Core team due to not understanding various new\n> softforks? Which version wins the right to the name?\n>\n> Also, being unable to even mention Bitcoin is overkill.\n>\n> The software license also don't affect the blockchain data.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/645a487a/attachment.html>"
            },
            {
                "author": "Patrick Murck",
                "date": "2018-02-13T17:04:48",
                "message_text_only": "This is a poor idea, and agree that it\u2019s largely off-topic. So without\nwasting too much of anyone\u2019s time here, I\u2019d point out the following.\n\nIt is pretty clear that any developer who is subject to a lawsuit from\nsomeone using Bitcoin Core software could point to the license (among other\nthings) *defensively* to limit their liability.\n\nBut who would be in a position to assert an *offensive* claim that their\nlicense terms have been breached? Who would have a right in the software\nthat they are granting via the license? Definitely not the Bitcoin\nFoundation\u2026\n\nThis software is meant to be free and open for anyone to use, unfortunately\nthat means some people will sometimes do things you disagree with.\n\n-pm\n\nOn February 13, 2018 at 11:24:37 AM, Brian Lockhart via bitcoin-dev (\nbitcoin-dev at lists.linuxfoundation.org) wrote:\n\n> I don't think that Bitcoin should be reliant upon courts or governments\nto defend itself against attacks of any form.\n\nAgree 100%. Plus yeah, lotsa luck getting any success via those channels...\n\nBut assuming the answer to the perceived problem is to \u201cfight fire with\nfire\u201d (using social / marketing based efforts) who \u201cshould\u201d pick up the\nmantle here? Without inciting riots by asking the question, wouldn\u2019t that\nostensibly be something the Bitcoin Foundation would lead on here? <ducks\nand runs for cover>\n\nIn any case, it\u2019s frustrating to watch the ongoing FUD and scammery going\nunanswered in any \u201cofficial\u201d capacity.\n\n\nOn February 13, 2018 at 7:25:35 AM, Jameson Lopp via bitcoin-dev (\nbitcoin-dev at lists.linuxfoundation.org) wrote:\n\nIf I'm understanding the problem being stated correctly:\n\n\"Bitcoin is under a branding attack by fork coins.\"\n\nThe proposed solution is to disincentivize fork coins from using the word\nBitcoin by altering the license terms. I'm not a lawyer, but it seems to me\nthat the words of the license are basically useless unless there is an\nentity that intends to make use of court systems to threaten noncompliant\nprojects into submission.\n\nIn my opinion, the perceived attack on Bitcoin here is social /\nmarketing-based, thus it makes sense that any defense against said attack\nshould also be social / marketing-based. I don't think that Bitcoin should\nbe reliant upon courts or governments to defend itself against attacks of\nany form.\n\nOn Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n> bitcoin-dev at lists.linuxfoundation.org>:\n>\n> ***\n> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n> (CORE) BLOCKCHAIN\n> ***\n>\n>\n> That's better solved with trademarks. (whoever would be the trademark\n> holder - Satoshi?)\n>\n> This would also prohibit any reimplementation that's not formally verified\n> to be perfectly compatible from using the name.\n>\n> It also adds legal uncertainty.\n>\n> Another major problem is that it neither affects anybody forking older\n> versions of Bitcoin, not people using existing independent blockchain\n> implementations and renaming them Bitcoin-Whatsoever.\n>\n> And what happens when an old version is technically incompatible with a\n> future version by the Core team due to not understanding various new\n> softforks? Which version wins the right to the name?\n>\n> Also, being unable to even mention Bitcoin is overkill.\n>\n> The software license also don't affect the blockchain data.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/1a77d522/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-02-13T15:45:17",
                "message_text_only": "No, the problem is not bitcoin being under any kind of attack by the\nforks for me, but the forks fooling people because, again, reusing the\nbitcoin core code is too easy\n\nI don't know if there can be a legal solution to this which would keep\nsome open source aspect of the code, but at least it deserves to be studied\n\n\nLe 13/02/2018 \u00e0 16:24, Jameson Lopp via bitcoin-dev a \u00e9crit\u00a0:\n> If I'm understanding the problem being stated correctly:\n>\n> \"Bitcoin is under a branding attack by fork coins.\"\n>\n> The proposed solution is to disincentivize fork coins from using the\n> word Bitcoin by altering the license terms. I'm not a lawyer, but it\n> seems to me that the words of the license are basically useless unless\n> there is an entity that intends to make use of court systems to\n> threaten noncompliant projects into submission.\n>\n> In my opinion, the perceived attack on Bitcoin here is social /\n> marketing-based, thus it makes sense that any defense against said\n> attack should also be social / marketing-based. I don't think that\n> Bitcoin should be reliant upon courts or governments to defend itself\n> against attacks of any form.\n>\n> On Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>\n>\n>     Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via\n>     bitcoin-dev\" <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>>:\n>\n>         ***\n>         NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT\n>         THAT USES THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS\n>         MARKETING MATERIAL UNLESS THE SOFTWARE PRODUCED BY THAT\n>         PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN (CORE) BLOCKCHAIN\n>         ***\n>\n>\n>     That's better solved with trademarks. (whoever would be the\n>     trademark holder - Satoshi?)\u00a0\u00a0\n>\n>     This would also prohibit any reimplementation that's not formally\n>     verified to be perfectly compatible from using the name.\u00a0\n>\n>     It also adds legal uncertainty.\u00a0\n>\n>     Another major problem is that it neither affects anybody forking\n>     older versions of Bitcoin, not people using existing independent\n>     blockchain implementations and renaming them Bitcoin-Whatsoever.\u00a0\n>\n>     And what happens when an old version is technically incompatible\n>     with a future version by the Core team due to not understanding\n>     various new softforks? Which version wins the right to the name?\u00a0\n>\n>     Also, being unable to even mention Bitcoin is overkill.\u00a0\n>\n>     The software license also don't affect the blockchain data.\u00a0\n>\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n>\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/3121c4e7/attachment-0001.html>"
            },
            {
                "author": "Bedri Ozgur Guler",
                "date": "2018-02-13T15:47:09",
                "message_text_only": "Hello,\nThe use of name Bitcoin cannot be avoided due to it's nature of being a\nProtocol. Prohibition of usage of it as a \"brand name\" is just like\nprohibiting the word \"Linux\", which is the name of the kernel, being used\nas a brand name or part of a brand name. If that had happened, systems\nbased on Linux kernel couldn't have used Linux word in their brands. The\nlicence in the Linux example is GPL but it does not really differ so much.\nMaking a protocol name a Trademark(TM) name and prohibiting it's use may\nsolve some confusions and bad reputation causing actions but it also\nprohibits the protocol to be used widely so damages the credibility of the\nprotocol itself which was born to be an independent, freedom-based,\ngovernment-free, boundaries-free etc. approach to the current corrupted\nmonetary system.\n\nIf precautions should be taken to control the usage of Bitcoin word in\nvarious positions and cases, it should be done in such a way that it should\nnot contradict with the philosophy of the Bitcoin itself. Social\n/marketing-based approaches proposed by Jameson Lopp will be more logical\nand freedom based. Trademarking and in some sense Cartel-ing the Bitcoin\nProtocol who arose against trademarks and cartels on \"money\" will destroy\nit's own roots and birth-right of existence in my opinion.\n\nBedri \u00d6zg\u00fcr G\u00fcler\n\nOn Tue, Feb 13, 2018 at 6:24 PM, Jameson Lopp via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If I'm understanding the problem being stated correctly:\n>\n> \"Bitcoin is under a branding attack by fork coins.\"\n>\n> The proposed solution is to disincentivize fork coins from using the word\n> Bitcoin by altering the license terms. I'm not a lawyer, but it seems to me\n> that the words of the license are basically useless unless there is an\n> entity that intends to make use of court systems to threaten noncompliant\n> projects into submission.\n>\n> In my opinion, the perceived attack on Bitcoin here is social /\n> marketing-based, thus it makes sense that any defense against said attack\n> should also be social / marketing-based. I don't think that Bitcoin should\n> be reliant upon courts or governments to defend itself against attacks of\n> any form.\n>\n> On Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>>\n>> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n>> bitcoin-dev at lists.linuxfoundation.org>:\n>>\n>> ***\n>> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n>> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n>> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n>> (CORE) BLOCKCHAIN\n>> ***\n>>\n>>\n>> That's better solved with trademarks. (whoever would be the trademark\n>> holder - Satoshi?)\n>>\n>> This would also prohibit any reimplementation that's not formally\n>> verified to be perfectly compatible from using the name.\n>>\n>> It also adds legal uncertainty.\n>>\n>> Another major problem is that it neither affects anybody forking older\n>> versions of Bitcoin, not people using existing independent blockchain\n>> implementations and renaming them Bitcoin-Whatsoever.\n>>\n>> And what happens when an old version is technically incompatible with a\n>> future version by the Core team due to not understanding various new\n>> softforks? Which version wins the right to the name?\n>>\n>> Also, being unable to even mention Bitcoin is overkill.\n>>\n>> The software license also don't affect the blockchain data.\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/1e805287/attachment-0001.html>"
            },
            {
                "author": "Felix Wolfsteller",
                "date": "2018-02-13T17:28:58",
                "message_text_only": "I'd call the license change an attack on bitcoin if its code license\nprohibited me to play around with it and call it whatever I the fud I want.\nOther entities like companies, goverments and whoknowswhat might\nprohibit that (in some countries of the world), but the nature of the\nsource and protocoll shall be Free (as in free speech).\n\nEven if my code changes are compatible with the current blockchain as\nper bitcoin core I would have the lifetime \"threat\" that one day my code\nwouldnt anymore because of changes in bitcoin core, and I wouldnt like\nto get letters from lawyers earning their money by sending out letters.\n\nBesides I am not fully sure if I could sign the main assumption that the\nforks \"... [are] exacerbating the confusion about the very nature of the\nproject, and harming it in many ways.\"\nOr at least I am not sure that the \"harm done\" __in the end__ is bigger\nthan the gains and the proof-of-spirit as well as all the insights\ngained through what happens here, regarding Free (well, MIT) Software\nout in the world. Yes, its not always pleasant but I think its worth it.\n\n-f\n\n\nOn 13.02.2018 16:47, Bedri Ozgur Guler via bitcoin-dev wrote:\n> Hello,\n> The use of name Bitcoin cannot be avoided due to it's nature of being a\n> Protocol. Prohibition of usage of it as a \"brand name\" is just like\n> prohibiting the word \"Linux\", which is the name of the kernel, being used\n> as a brand name or part of a brand name. If that had happened, systems\n> based on Linux kernel couldn't have used Linux word in their brands. The\n> licence in the Linux example is GPL but it does not really differ so much.\n> Making a protocol name a Trademark(TM) name and prohibiting it's use may\n> solve some confusions and bad reputation causing actions but it also\n> prohibits the protocol to be used widely so damages the credibility of the\n> protocol itself which was born to be an independent, freedom-based,\n> government-free, boundaries-free etc. approach to the current corrupted\n> monetary system.\n> \n> If precautions should be taken to control the usage of Bitcoin word in\n> various positions and cases, it should be done in such a way that it should\n> not contradict with the philosophy of the Bitcoin itself. Social\n> /marketing-based approaches proposed by Jameson Lopp will be more logical\n> and freedom based. Trademarking and in some sense Cartel-ing the Bitcoin\n> Protocol who arose against trademarks and cartels on \"money\" will destroy\n> it's own roots and birth-right of existence in my opinion.\n> \n> Bedri \u00d6zg\u00fcr G\u00fcler\n> \n> On Tue, Feb 13, 2018 at 6:24 PM, Jameson Lopp via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> If I'm understanding the problem being stated correctly:\n>>\n>> \"Bitcoin is under a branding attack by fork coins.\"\n>>\n>> The proposed solution is to disincentivize fork coins from using the word\n>> Bitcoin by altering the license terms. I'm not a lawyer, but it seems to me\n>> that the words of the license are basically useless unless there is an\n>> entity that intends to make use of court systems to threaten noncompliant\n>> projects into submission.\n>>\n>> In my opinion, the perceived attack on Bitcoin here is social /\n>> marketing-based, thus it makes sense that any defense against said attack\n>> should also be social / marketing-based. I don't think that Bitcoin should\n>> be reliant upon courts or governments to defend itself against attacks of\n>> any form.\n>>\n>> On Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>>\n>>>\n>>> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n>>> bitcoin-dev at lists.linuxfoundation.org>:\n>>>\n>>> ***\n>>> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n>>> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n>>> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n>>> (CORE) BLOCKCHAIN\n>>> ***\n>>>\n>>>\n>>> That's better solved with trademarks. (whoever would be the trademark\n>>> holder - Satoshi?)\n>>>\n>>> This would also prohibit any reimplementation that's not formally\n>>> verified to be perfectly compatible from using the name.\n>>>\n>>> It also adds legal uncertainty.\n>>>\n>>> Another major problem is that it neither affects anybody forking older\n>>> versions of Bitcoin, not people using existing independent blockchain\n>>> implementations and renaming them Bitcoin-Whatsoever.\n>>>\n>>> And what happens when an old version is technically incompatible with a\n>>> future version by the Core team due to not understanding various new\n>>> softforks? Which version wins the right to the name?\n>>>\n>>> Also, being unable to even mention Bitcoin is overkill.\n>>>\n>>> The software license also don't affect the blockchain data.\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> \n> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Cory Fields",
                "date": "2018-02-13T19:08:02",
                "message_text_only": "I agree that this is a bad idea. When trying to work around a social\nissue for a highly technical project, a legal hack is certainly not\nthe answer. As Daniel pointed out, the result of such a change would\nsimply be that 100% of all Bitcoin companies would be told by their\nlegal teams to use the last MIT-licensed version of Bitcoin Core as\nthey would have no idea how to prove that they're not in violation. So\nI think it would succeed in exactly the _opposite_ of its intended\npurpose.\n\nAs Patrick said:\n> This software is meant to be free and open for anyone to use, unfortunately that means some people will sometimes do things you disagree with.\n\nBitcoin is a Kleenex, a Q-Tip, a Xerox in the crypto world. I think we\nshould just accept that as a feature at this point. Let other projects\nfaff about with copyright litigation and trademark dilution concerns\n:)\n\nBesides, I assume many/most developers would be unwilling to accept\nsuch a change. Speaking for only myself at least, I would not\ncontribute under that license.\n\nI must admit, though, that it would be fun to read codified\nNo-True-Scotsman appeals in a software license :p.\n\nCory\n\nOn Tue, Feb 13, 2018 at 12:28 PM, Felix Wolfsteller via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I'd call the license change an attack on bitcoin if its code license\n> prohibited me to play around with it and call it whatever I the fud I want.\n> Other entities like companies, goverments and whoknowswhat might\n> prohibit that (in some countries of the world), but the nature of the\n> source and protocoll shall be Free (as in free speech).\n>\n> Even if my code changes are compatible with the current blockchain as\n> per bitcoin core I would have the lifetime \"threat\" that one day my code\n> wouldnt anymore because of changes in bitcoin core, and I wouldnt like\n> to get letters from lawyers earning their money by sending out letters.\n>\n> Besides I am not fully sure if I could sign the main assumption that the\n> forks \"... [are] exacerbating the confusion about the very nature of the\n> project, and harming it in many ways.\"\n> Or at least I am not sure that the \"harm done\" __in the end__ is bigger\n> than the gains and the proof-of-spirit as well as all the insights\n> gained through what happens here, regarding Free (well, MIT) Software\n> out in the world. Yes, its not always pleasant but I think its worth it.\n>\n> -f\n>\n>\n> On 13.02.2018 16:47, Bedri Ozgur Guler via bitcoin-dev wrote:\n>> Hello,\n>> The use of name Bitcoin cannot be avoided due to it's nature of being a\n>> Protocol. Prohibition of usage of it as a \"brand name\" is just like\n>> prohibiting the word \"Linux\", which is the name of the kernel, being used\n>> as a brand name or part of a brand name. If that had happened, systems\n>> based on Linux kernel couldn't have used Linux word in their brands. The\n>> licence in the Linux example is GPL but it does not really differ so much.\n>> Making a protocol name a Trademark(TM) name and prohibiting it's use may\n>> solve some confusions and bad reputation causing actions but it also\n>> prohibits the protocol to be used widely so damages the credibility of the\n>> protocol itself which was born to be an independent, freedom-based,\n>> government-free, boundaries-free etc. approach to the current corrupted\n>> monetary system.\n>>\n>> If precautions should be taken to control the usage of Bitcoin word in\n>> various positions and cases, it should be done in such a way that it should\n>> not contradict with the philosophy of the Bitcoin itself. Social\n>> /marketing-based approaches proposed by Jameson Lopp will be more logical\n>> and freedom based. Trademarking and in some sense Cartel-ing the Bitcoin\n>> Protocol who arose against trademarks and cartels on \"money\" will destroy\n>> it's own roots and birth-right of existence in my opinion.\n>>\n>> Bedri \u00d6zg\u00fcr G\u00fcler\n>>\n>> On Tue, Feb 13, 2018 at 6:24 PM, Jameson Lopp via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> If I'm understanding the problem being stated correctly:\n>>>\n>>> \"Bitcoin is under a branding attack by fork coins.\"\n>>>\n>>> The proposed solution is to disincentivize fork coins from using the word\n>>> Bitcoin by altering the license terms. I'm not a lawyer, but it seems to me\n>>> that the words of the license are basically useless unless there is an\n>>> entity that intends to make use of court systems to threaten noncompliant\n>>> projects into submission.\n>>>\n>>> In my opinion, the perceived attack on Bitcoin here is social /\n>>> marketing-based, thus it makes sense that any defense against said attack\n>>> should also be social / marketing-based. I don't think that Bitcoin should\n>>> be reliant upon courts or governments to defend itself against attacks of\n>>> any form.\n>>>\n>>> On Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>>\n>>>>\n>>>> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n>>>> bitcoin-dev at lists.linuxfoundation.org>:\n>>>>\n>>>> ***\n>>>> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n>>>> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n>>>> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n>>>> (CORE) BLOCKCHAIN\n>>>> ***\n>>>>\n>>>>\n>>>> That's better solved with trademarks. (whoever would be the trademark\n>>>> holder - Satoshi?)\n>>>>\n>>>> This would also prohibit any reimplementation that's not formally\n>>>> verified to be perfectly compatible from using the name.\n>>>>\n>>>> It also adds legal uncertainty.\n>>>>\n>>>> Another major problem is that it neither affects anybody forking older\n>>>> versions of Bitcoin, not people using existing independent blockchain\n>>>> implementations and renaming them Bitcoin-Whatsoever.\n>>>>\n>>>> And what happens when an old version is technically incompatible with a\n>>>> future version by the Core team due to not understanding various new\n>>>> softforks? Which version wins the right to the name?\n>>>>\n>>>> Also, being unable to even mention Bitcoin is overkill.\n>>>>\n>>>> The software license also don't affect the blockchain data.\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "CryptAxe",
                "date": "2018-02-13T19:08:36",
                "message_text_only": "This is ridiculous. We shouldn't bastardize open source principals because\nsomeone hurt your feelings.\n\nThis is how open source works, stop using it if you don't like it.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/eb94265d/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2018-02-13T15:22:43",
                "message_text_only": "I was thinking to post something very similar on this list but not sure\nthat it would get some kind of interest\n\nNot sure how and if it can be done (ie license modification) but the\nreuse of the bitcoin core code can allow even a child to launch a fork\nand this mess should stop, maybe people like to get \"free\" coins but\nthey are misleaded, they can lose everything and there are some more\nvicious side effects like replay protection collisions between forks,\nthis is already happening, nobody seems to care but I wrote:\n\nBitcoin Tartuffe, the ultimate fork - User guide: How to create your\nbitcoin fork in 5mn, fool everybody and become rich\nhttps://www.linkedin.com/pulse/user-guide-how-create-your-bitcoin-fork-5mn-fool-everybody-vitte\n\n--> this is a parody of course but very close to the reality, some info\nare intentionally wrong\n\nThe madness of bitcoin forks: risk, reward and ruin\nhttps://www.linkedin.com/pulse/madness-bitcoin-forks-risk-reward-ruin-aymeric-vitte/\n\nI don't think that it really impacts bitcoin itself but this is\ndefinitely too easy for people to fork the bitcoin core code and launch\nsome shxtty fork\n\nProbably nobody here follow this, as an example (among plenty) see this\nhttps://bitcointalk.org/index.php?topic=2515675.msg30173307#msg30173307\ncompletely absurd mess\n\nLe 13/02/2018 \u00e0 13:25, JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev a \u00e9crit\u00a0:\n> Hi,\n>\n> Bitcoin is licensed under the MIT license (https://github.com/bitcoin/bitcoin/blob/master/COPYING <https://github.com/bitcoin/bitcoin/blob/master/COPYING>) which is one of the most permissive licenses widely in use.\n> While this almost restriction-less license has proved useful to many software projects, I think it could be wise to question its current suitability for this project, given the recent history.\n>\n> The difficulty among the general population to distinguish between Bitcoin (the protocol and software) and bitcoin (the currency) arises spontaneously from the intimate entanglement of both. \n> The current list of Bitcoin lookalikes includes: Bitcoin Cash, Bitcoin Gold, Bitcoin Diamond, Bitcoin God, Bitcoin Clashic, Super Bitcoin, Bitcoin Hot, Bitcoin X, Oil Bitcoin, Bitcoin World, Lightning Bitcoin...\n>\n> This recent flurry of hard forks is, IMHO, exacerbating the confusion about the very nature of the project, and harming it in many ways.\n>\n> Although the liberal MIT license is (rightfully) beneficial to many other projects, companies and individuals, it is my belief that several projects are unfairly taking advantage of this generous license to attack Bitcoin (both the software and the currency), confuse the public, and gain personal profit in a way that is severely harming the Bitcoin ecosystem.\n>\n> Therefore, I\u2019d like to raise the possibility of amending the MIT license in a simple way, by adding a line such as:\n>\n>\n> ***\n> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN (CORE) BLOCKCHAIN\n> ***\n>\n> (This is just an approximation. A final version would probably have to include a restriction to some soundalikes like BITKOIN, BIITCOIN,\u2026)\n>\n> This way, I could legitimate use this software to create my own crypto coin, or use it in Ethereum, Litecoin or any of the other legitimate cryptos, but I could not make my \u201cBitcoin Whatever\u201d fork and keep using this software as the basis for it. I could also fork the bitcoin blockchain to create \u201cBcoin lightspeed\u201d but not \u201cBitcoin lightspeed\u201d for instance.\n>\n> I know this would probably not prevent the explosion of forks in the future, but maybe it could help mitigate the confusion among the users and the harm to this community. Even if its enforceability is dubious, at least any infringing project would be exposed to some liability. I see myself some possible loopholes the way the license addendum is written. My intention is not to arrive immediately to a final wording but to know if there is some value to the idea of changing the license with this purpose.\n>\n>\n> Jose Femenias\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms"
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-02-13T17:53:40",
                "message_text_only": "This would give too much power to Bitcoin Core, and implies falsely that \nBitcoin and Bitcoin Core are the same thing.\n\nOn Tuesday 13 February 2018 12:25:53 PM JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev \nwrote:\n> Hi,\n> \n> Bitcoin is licensed under the MIT license\n> (https://github.com/bitcoin/bitcoin/blob/master/COPYING\n> <https://github.com/bitcoin/bitcoin/blob/master/COPYING>) which is one of\n> the most permissive licenses widely in use. While this almost\n> restriction-less license has proved useful to many software projects, I\n> think it could be wise to question its current suitability for this\n> project, given the recent history.\n> \n> The difficulty among the general population to distinguish between Bitcoin\n> (the protocol and software) and bitcoin (the currency) arises\n> spontaneously from the intimate entanglement of both. The current list of\n> Bitcoin lookalikes includes: Bitcoin Cash, Bitcoin Gold, Bitcoin Diamond,\n> Bitcoin God, Bitcoin Clashic, Super Bitcoin, Bitcoin Hot, Bitcoin X, Oil\n> Bitcoin, Bitcoin World, Lightning Bitcoin...\n> \n> This recent flurry of hard forks is, IMHO, exacerbating the confusion about\n> the very nature of the project, and harming it in many ways.\n> \n> Although the liberal MIT license is (rightfully) beneficial to many other\n> projects, companies and individuals, it is my belief that several projects\n> are unfairly taking advantage of this generous license to attack Bitcoin\n> (both the software and the currency), confuse the public, and gain\n> personal profit in a way that is severely harming the Bitcoin ecosystem.\n> \n> Therefore, I\u2019d like to raise the possibility of amending the MIT license in\n> a simple way, by adding a line such as:\n> \n> \n> ***\n> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES THE\n> NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS THE\n> SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n> (CORE) BLOCKCHAIN ***\n> \n> (This is just an approximation. A final version would probably have to\n> include a restriction to some soundalikes like BITKOIN, BIITCOIN,\u2026)\n> \n> This way, I could legitimate use this software to create my own crypto\n> coin, or use it in Ethereum, Litecoin or any of the other legitimate\n> cryptos, but I could not make my \u201cBitcoin Whatever\u201d fork and keep using\n> this software as the basis for it. I could also fork the bitcoin\n> blockchain to create \u201cBcoin lightspeed\u201d but not \u201cBitcoin lightspeed\u201d for\n> instance.\n> \n> I know this would probably not prevent the explosion of forks in the\n> future, but maybe it could help mitigate the confusion among the users and\n> the harm to this community. Even if its enforceability is dubious, at\n> least any infringing project would be exposed to some liability. I see\n> myself some possible loopholes the way the license addendum is written. My\n> intention is not to arrive immediately to a final wording but to know if\n> there is some value to the idea of changing the license with this purpose.\n> \n> \n> Jose Femenias\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jameson Lopp",
                "date": "2018-02-13T15:45:55",
                "message_text_only": "Anyone who feels so inclined is free to \"pick up the mantle\" and defend\nBitcoin against perceived social attacks. I don't think that Bitcoin\nprotocol developers have any particular responsibility to do so, and as\nsuch this particular discussion is likely going to quickly veer off-topic\nfor this mailing list.\n\nOn Tue, Feb 13, 2018 at 10:37 AM, Brian Lockhart <brianlockhart at gmail.com>\nwrote:\n\n> > I don't think that Bitcoin should be reliant upon courts or governments\n> to defend itself against attacks of any form.\n>\n> Agree 100%. Plus yeah, lotsa luck getting any success via those channels...\n>\n> But assuming the answer to the perceived problem is to \u201cfight fire with\n> fire\u201d (using social / marketing based efforts) who \u201cshould\u201d pick up the\n> mantle here? Without inciting riots by asking the question, wouldn\u2019t that\n> ostensibly be something the Bitcoin Foundation would lead on here? <ducks\n> and runs for cover>\n>\n> In any case, it\u2019s frustrating to watch the ongoing FUD and scammery going\n> unanswered in any \u201cofficial\u201d capacity.\n>\n>\n> On February 13, 2018 at 7:25:35 AM, Jameson Lopp via bitcoin-dev (\n> bitcoin-dev at lists.linuxfoundation.org) wrote:\n>\n> If I'm understanding the problem being stated correctly:\n>\n> \"Bitcoin is under a branding attack by fork coins.\"\n>\n> The proposed solution is to disincentivize fork coins from using the word\n> Bitcoin by altering the license terms. I'm not a lawyer, but it seems to me\n> that the words of the license are basically useless unless there is an\n> entity that intends to make use of court systems to threaten noncompliant\n> projects into submission.\n>\n> In my opinion, the perceived attack on Bitcoin here is social /\n> marketing-based, thus it makes sense that any defense against said attack\n> should also be social / marketing-based. I don't think that Bitcoin should\n> be reliant upon courts or governments to defend itself against attacks of\n> any form.\n>\n> On Tue, Feb 13, 2018 at 9:25 AM, Natanael via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>>\n>> Den 13 feb. 2018 15:07 skrev \"JOSE FEMENIAS CA\u00d1UELO via bitcoin-dev\" <\n>> bitcoin-dev at lists.linuxfoundation.org>:\n>>\n>> ***\n>> NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES\n>> THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS\n>> THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN\n>> (CORE) BLOCKCHAIN\n>> ***\n>>\n>>\n>> That's better solved with trademarks. (whoever would be the trademark\n>> holder - Satoshi?)\n>>\n>> This would also prohibit any reimplementation that's not formally\n>> verified to be perfectly compatible from using the name.\n>>\n>> It also adds legal uncertainty.\n>>\n>> Another major problem is that it neither affects anybody forking older\n>> versions of Bitcoin, not people using existing independent blockchain\n>> implementations and renaming them Bitcoin-Whatsoever.\n>>\n>> And what happens when an old version is technically incompatible with a\n>> future version by the Core team due to not understanding various new\n>> softforks? Which version wins the right to the name?\n>>\n>> Also, being unable to even mention Bitcoin is overkill.\n>>\n>> The software license also don't affect the blockchain data.\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/f4d389bf/attachment.html>"
            },
            {
                "author": "Adam Ficsor",
                "date": "2018-02-13T17:25:50",
                "message_text_only": "I agree with the opposition on changing the license, because of the\nbranding attacks.\n\nHowever having two coins with the same Proof Of Work is a zero sum game\nfrom a security point of view. It may not be a bad idea to consider\nchanging the license in a way that only limits cryptocurrencies with the\nsame Proof Of Work, since they directly affect the stability and security\nof Bitcoin.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/df2de265/attachment.html>"
            },
            {
                "author": "Daniel Robinson",
                "date": "2018-02-13T17:46:18",
                "message_text_only": "Custom open-source licenses are basically never a good idea. Every\ndeviation in wording from universally-accepted open-source licensing terms\nis a major compliance headache from the perspective of any organization\ntrying to use the software. You don\u2019t want users having to clear their use\nof Bitcoin Core through their employers\u2019 legal departments, whether or not\nthey would ultimately approve that use. For that reason alone I think such\na change is not viable, no matter how you phrased it.\nOn Tue, Feb 13, 2018 at 9:27 AM Adam Ficsor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I agree with the opposition on changing the license, because of the\n> branding attacks.\n>\n> However having two coins with the same Proof Of Work is a zero sum game\n> from a security point of view. It may not be a bad idea to consider\n> changing the license in a way that only limits cryptocurrencies with the\n> same Proof Of Work, since they directly affect the stability and security\n> of Bitcoin.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180213/3c912384/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Possible change to the MIT license",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Natanael",
                "Patrick Murck",
                "Felix Wolfsteller",
                "JOSE FEMENIAS CA\u00d1UELO",
                "CryptAxe",
                "Bedri Ozgur Guler",
                "Brian Lockhart",
                "Adam Ficsor",
                "Aymeric Vitte",
                "Daniel Robinson",
                "Luke Dashjr",
                "Jameson Lopp",
                "Cory Fields"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 48677
        }
    },
    {
        "title": "[bitcoin-dev]  Possible change to the MIT license",
        "thread_messages": [
            {
                "author": "Damian Williamson",
                "date": "2018-02-14T10:09:25",
                "message_text_only": "I do not know that Bitcoin's position is any weaker because of the terms that the software is licenced under.\n\n\nCory Fields said:\n\n>Let other projects faff about with copyright litigation and trademark dilution concerns\n\n\nI disagree completely with any licence change. As well as allowing for the use of a software, a licence is also a disclaimer for those responsible for the release. Changing a single word can have drastic implications should there ever be any action considered against any involved party or group. The current MIT licence is IMHO the right fit.\n\n\nRegards,\n\nDamian Williamson\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180214/014fb010/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Possible change to the MIT license",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 778
        }
    },
    {
        "title": "[bitcoin-dev] Amend the BIP 123 process to include buried deployments",
        "thread_messages": [
            {
                "author": "Marco Falke",
                "date": "2018-02-14T22:01:46",
                "message_text_only": "I define a buried deployment as a consensus rule change that affects\nvalidity of blocks that are buried by a sufficiently large number of\nblocks in the current valid most-work chain, but the current block\n(and all its parents) remain valid.\n\nBIP 123 suggests that BIPs in the consensus layer should be assigned a\nlabel \"soft fork\" or \"hard fork\". However, I think the differentiation\ninto soft fork or hard fork should not be made for BIPs that document\nburied deployments. In contrast to soft forks and hard forks, buried\ndeployments do not require community and miner coordination for a safe\ndeployment.\n\nFor a chain fork to happen due to a buried deployment, a massive chain\nreorganization must be produced off of a block in the very past. In\nthe extremely unlikely event of such a large chain reorganization,\nBitcoin's general security assumptions would be violated regardless of\nthe presence of a buried deployment."
            },
            {
                "author": "Luke Dashjr",
                "date": "2018-02-14T22:11:42",
                "message_text_only": "On Wednesday 14 February 2018 10:01:46 PM Marco Falke via bitcoin-dev wrote:\n> BIP 123 suggests that BIPs in the consensus layer should be assigned a\n> label \"soft fork\" or \"hard fork\". However, I think the differentiation\n> into soft fork or hard fork should not be made for BIPs that document\n> buried deployments. In contrast to soft forks and hard forks, buried\n> deployments do not require community and miner coordination for a safe\n> deployment.\n\nThey also do not require software coordination. Therefore, why should there be \nBIPs at all? Seems to me that we should instead add these documents to \nhttps://github.com/bitcoin-core/docs\n\nThat being said, I'm also okay with just adding an Annex to the original \nsoftfork/hardfork BIP describing each shortcut. It just seems annoying to have \ntwo BIPs for every protocol change: one for the change itself, and then \nanother for implementation-specific shortcuts taken.\n\nLuke"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-02-14T22:20:31",
                "message_text_only": "On Wed, Feb 14, 2018 at 10:11 PM, Luke Dashjr via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On Wednesday 14 February 2018 10:01:46 PM Marco Falke via bitcoin-dev wrote:\n>> BIP 123 suggests that BIPs in the consensus layer should be assigned a\n>> label \"soft fork\" or \"hard fork\". However, I think the differentiation\n>> into soft fork or hard fork should not be made for BIPs that document\n>> buried deployments. In contrast to soft forks and hard forks, buried\n>> deployments do not require community and miner coordination for a safe\n>> deployment.\n>\n> They also do not require software coordination. Therefore, why should there be\n> BIPs at all? Seems to me that we should instead add these documents to\n> https://github.com/bitcoin-core/docs\n\nIn that sense, no but they help people understand the system (e.g. so\nthey don't go look at implementations and confuse that the activations\nthey expect are simply not there); and they aid other implementations\nin understanding what other people have already analyzed and concluded\nwas safe. You could certainly get an analysis wrong for one of these\nthings."
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-02-14T23:57:10",
                "message_text_only": "On 02/14/2018 02:01 PM, Marco Falke via bitcoin-dev wrote:\n> I define a buried deployment as a consensus rule change that affects\n> validity of blocks that are buried by a sufficiently large number of\n> blocks in the current valid most-work chain,\n\nSufficient for what, specifically?\n\n> but the current block (and all its parents) remain valid.\n\nRemain valid in the case where the depth assumption is \"sufficient\" to\nensure that a chain split is not possible?\n\nIf this was true (which it is not), it would imply that there is no\nreason to validate any block deeper than the most recent 25,000.\nPresumably this means that people may continuously rely on some\nauthority (like Bitcoin Core?) to determine the checkpoint for tip-25,000.\n\n> BIP 123 suggests that BIPs in the consensus layer should be assigned a\n> label \"soft fork\" or \"hard fork\". However, I think the differentiation\n> into soft fork or hard fork should not be made for BIPs that document\n> buried deployments. In contrast to soft forks and hard forks, buried\n> deployments do not require community and miner coordination for a safe\n> deployment.\n\nThey can only avoid this requirement based on the assumption that the\nhard fork cannot result in a chain split. This is not the case.\n\n> For a chain fork to happen due to a buried deployment, a massive chain\n> reorganization must be produced off of a block in the very past.\n\nIn other words a \"buried deployment\" is a hard fork that is not likely\nto cause a chain split. This is a subjective subcategory of hard fork,\nnot an independent category - unless maybe you can show that there is\nthe 25,000 blocks number is an objective threshold.\n\n> In the extremely unlikely event of such a large chain reorganization,\n> Bitcoin's general security assumptions would be violated regardless of\n> the presence of a buried deployment.\n\nThis is untrue. The \"security assumptions\" of Bitcoin do not preclude\ndeep reorganizations.\n\ne\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180214/6adfbbf6/attachment-0001.sig>"
            },
            {
                "author": "Marco Falke",
                "date": "2018-02-18T18:57:03",
                "message_text_only": "> They also do not require software coordination. Therefore, why should there be\n> BIPs at all? Seems to me that we should instead add these documents to\n> https://github.com/bitcoin-core/docs\n\n\nConsensus is not trivial. I think documentation is important, even if\nit seems simple to some.\nPersonally, I don't care too much where to place the documentation,\nbut the BIPs repo seems a good place, since it also hosts other\ninformational documents.\n\nTo prevent \"two BIPs for every protocol change\", related buried\ndeployments could be bundled. E.g. the ISM BIP 90 change.\n\n\n\nOn Wed, Feb 14, 2018 at 6:57 PM, Eric Voskuil <eric at voskuil.org> wrote:\n> On 02/14/2018 02:01 PM, Marco Falke via bitcoin-dev wrote:\n>> I define a buried deployment as a consensus rule change that affects\n>> validity of blocks that are buried by a sufficiently large number of\n>> blocks in the current valid most-work chain,\n>\n> Sufficient for what, specifically?\n\n\nSufficiently large to prevent potential bike-shedding. The expected\nnumber of blocks in two weeks could be considered a lower bound. Then\nmultiply that by 10 or 20.\n\n>\n>> but the current block (and all its parents) remain valid.\n>\n> Remain valid in the case where the depth assumption is \"sufficient\" to\n> ensure that a chain split is not possible?\n>\n> If this was true (which it is not), it would imply that there is no\n> reason to validate any block deeper than the most recent 25,000.\n> Presumably this means that people may continuously rely on some\n> authority (like Bitcoin Core?) to determine the checkpoint for tip-25,000.\n>\n\n\nNote that a checkpoint *freezes* the chain completely at a given\nheight. Buried deployments are *not* checkpoints.\n\nAlso note that buried deployments only make sense after a protocol\nupgrade has happened (i.e. a soft fork or hard fork). If a miner has\nthe resources to cause a chain split, they could trivially do that\neven in the complete absence of buried deployments. Buried deployments\nare *not* a solution to 50% attacks.\n\n\n>> BIP 123 suggests that BIPs in the consensus layer should be assigned a\n>> label \"soft fork\" or \"hard fork\". However, I think the differentiation\n>> into soft fork or hard fork should not be made for BIPs that document\n>> buried deployments. In contrast to soft forks and hard forks, buried\n>> deployments do not require community and miner coordination for a safe\n>> deployment.\n>\n> They can only avoid this requirement based on the assumption that the\n> hard fork cannot result in a chain split. This is not the case.\n>\n>> For a chain fork to happen due to a buried deployment, a massive chain\n>> reorganization must be produced off of a block in the very past.\n>\n> In other words a \"buried deployment\" is a hard fork that is not likely\n> to cause a chain split. This is a subjective subcategory of hard fork,\n> not an independent category - unless maybe you can show that there is\n> the 25,000 blocks number is an objective threshold.\n\n\nPlease note that a buried deployment can very well be a soft fork. I\nthink this makes it even clearer, that such a label makes no sense for\nburied deployments.\n\n\n>> In the extremely unlikely event of such a large chain reorganization,\n>> Bitcoin's general security assumptions would be violated regardless of\n>> the presence of a buried deployment.\n>\n> This is untrue. The \"security assumptions\" of Bitcoin do not preclude\n> deep reorganizations.\n> e\n>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-02-21T17:27:53",
                "message_text_only": "On 02/18/2018 10:57 AM, Marco Falke via bitcoin-dev wrote:\n>> They also do not require software coordination. Therefore, why should there be\n>> BIPs at all? Seems to me that we should instead add these documents to\n>> https://github.com/bitcoin-core/docs\n> \n> Consensus is not trivial. I think documentation is important, even if\n> it seems simple to some.\n> Personally, I don't care too much where to place the documentation,\n> but the BIPs repo seems a good place, since it also hosts other\n> informational documents.\n> \n> To prevent \"two BIPs for every protocol change\", related buried\n> deployments could be bundled. E.g. the ISM BIP 90 change.\n\nYou seem to have missed the point. Either the \"buried deployment\" is a\nconsensus rule, and requires a BIP, or it is not a consensus rule, and\ndoes not warrant a BIP.\n\nYou are arguing that it is not a consensus rule, yet requires a BIP. You\nalso strongly imply that it is a consensus rule (\"consensus is important\").\n\nIf it is a consensus rule it is either a hard fork (valid tx set\nexpansion) or a soft fork (valid tx set contraction). You are attempting\nto create an independent category that violates this clear engineering\ndefinition. The category you desire is actually a subcategory of hard\nfork (employing an arbitrary threshold for likelihood of causing a chain\nsplit).\n\n> On Wed, Feb 14, 2018 at 6:57 PM, Eric Voskuil <eric at voskuil.org> wrote:\n>> On 02/14/2018 02:01 PM, Marco Falke via bitcoin-dev wrote:\n>>> I define a buried deployment as a consensus rule change that affects\n>>> validity of blocks that are buried by a sufficiently large number of\n>>> blocks in the current valid most-work chain,\n>>\n>> Sufficient for what, specifically?\n> \n> Sufficiently large to prevent potential bike-shedding. The expected\n> number of blocks in two weeks could be considered a lower bound. Then\n> multiply that by 10 or 20.\n\nThe arbitrary threshold. It seems it could be anything. Such a\ndefinition has no clear *engineering* usefulness.\n\n>>> but the current block (and all its parents) remain valid.\n>>\n>> Remain valid in the case where the depth assumption is \"sufficient\" to\n>> ensure that a chain split is not possible?\n>>\n>> If this was true (which it is not), it would imply that there is no\n>> reason to validate any block deeper than the most recent 25,000.\n>> Presumably this means that people may continuously rely on some\n>> authority (like Bitcoin Core?) to determine the checkpoint for tip-25,000.\n>>\n> Note that a checkpoint *freezes* the chain completely at a given\n> height. Buried deployments are *not* checkpoints.\n\nYou are arguing a point that I did not make. The issue is that you argue\na \"buried deployment\" hard fork cannot create a chain split. This itself\nimplies that the chain is \"frozen\" at the depth below which the chain\ncannot be split. In other words, by accepting your logic, we must\nconclude there is no reason whatsoever to validate the chain prior to\nthat depth. This would lead to the conclusion that check-pointing the\nchain to that depth is always sufficient validation.\n\n> Also note that buried deployments only make sense after a protocol\n> upgrade has happened (i.e. a soft fork or hard fork). If a miner has\n> the resources to cause a chain split, they could trivially do that\n> even in the complete absence of buried deployments. Buried deployments\n> are *not* a solution to 50% attacks.\n\nNot sure why you are making this obvious but seemingly-irrelevant point.\n>>> BIP 123 suggests that BIPs in the consensus layer should be assigned a\n>>> label \"soft fork\" or \"hard fork\". However, I think the differentiation\n>>> into soft fork or hard fork should not be made for BIPs that document\n>>> buried deployments. In contrast to soft forks and hard forks, buried\n>>> deployments do not require community and miner coordination for a safe\n>>> deployment.\n>>\n>> They can only avoid this requirement based on the assumption that the\n>> hard fork cannot result in a chain split. This is not the case.\n>>\n>>> For a chain fork to happen due to a buried deployment, a massive chain\n>>> reorganization must be produced off of a block in the very past.\n>>\n>> In other words a \"buried deployment\" is a hard fork that is not likely\n>> to cause a chain split. This is a subjective subcategory of hard fork,\n>> not an independent category - unless maybe you can show that there is\n>> the 25,000 blocks number is an objective threshold.\n> \n> Please note that a buried deployment can very well be a soft fork. I\n> think this makes it even clearer, that such a label makes no sense for\n> buried deployments.\n\nNo, it cannot. Removal of an activated soft fork (valid tx set\ncontraction) is a hard fork (valid tx set expansion), and a new\nactivation rule for an active soft fork creates a path to that removal.\nGiven this error you may want to reconsider your proposal.\n\n>>> In the extremely unlikely event of such a large chain reorganization,\n>>> Bitcoin's general security assumptions would be violated regardless of\n>>> the presence of a buried deployment.\n>>\n>> This is untrue. The \"security assumptions\" of Bitcoin do not preclude\n>> deep reorganizations.\n>>\n>> e\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 490 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/36addda8/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Amend the BIP 123 process to include buried deployments",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Eric Voskuil",
                "Luke Dashjr",
                "Gregory Maxwell",
                "Marco Falke"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 14026
        }
    },
    {
        "title": "[bitcoin-dev] Alternative way to count sigops",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2018-02-16T22:49:17",
                "message_text_only": "Short history\n----------------\n\nSatoshi introduced sigops counting as a softfork to limit the number of signature operation in a block. He statically counted all OP_CHECK(MULTI)SIG(VERIFY) in both scriptSig and scriptPubKey, assumed a OP_CHECKMULTISIG is equivalent to 20 OP_CHECKSIG, and enforced a block limit of 20000 sigop. The counting is not contextual, i.e. one doesn\u2019t need the UTXO set to determine the number of sigop. The counting was also static so one doesn\u2019t need to execute a script in order to count sigop. However, this is completely wrong for few reasons: a) opcodes in scriptPubKey are not executed; b) scriptPubKey of spent UTXO, which are actually executed, are not counted at all; c) it greatly overestimate the cost of multi-sig; d) it counts sigop in unexecuted branch.\n\nAs P2SH was introduced, sigop counting also covered the sigop redeemScript. This is good because redeemScript is what being executed. It also improved the counting of OP_CHECKMULTISIG. If it is in certain canonical form, it would count the number of public keys instead of assuming it as 20. On the other hand, counting sigop becomes not possible without the UTXO set, since one needs UTXO to identify P2SH inputs. Also, the canonical OP_CHECKMULTISIG counting is not quite elegant and created more special cases in the code.\n\nSegwit (BIP141) scaled the legacy sigop limit by 4x. So every legacy sigop becomes 4 new sigop, with a block limit of 80000 new sigop. P2WPKH is counted as 1 new sigop, and P2WSH is counted in the same way as P2SH.\n\n\n\nProblem\n------------\n\nWe now have multiple 2nd generation script proposals, such as BIP114, BIP117, taproot, etc. BIP114 and taproot allows static sigop counting, but not BIP117 as it requires execution to determine what would be run as script (like OP_EVAL). As we want to allow more complicated script functions, static sigop counting might not be easy. However, we still want to have a limit to avoid unexpected DoS attack.\n\n\n\n\nProposal\n------------\n\nSince we have a block weight limit of 4,000,000 and sigop limit of 80,000, each sigop could not use more than 50 weight unit on average. For new script proposals we could count the actual number of sigop at execution (i.e. skip unexecuted sigop, skip 0-size signature, count the actual checksig operations in multi-sig), and make sure the number of executed sigop * 50 is not greater than the size of the input.\n\nThe minimal size of each input is 32 (prevout.hash) + 4 (prevout.n) + 4 (nSequence) + 1 (empty scriptSig) = 41 bytes or 164 weight unit. So the new rule would require that (164 + input witness size) >= (actual_sigop * 50). This is a per-input limit, as script validation is parallel.\n\nSince a compressed key is 33 bytes and a normal compact signature is 64 bytes, the 1:50 ratio should be more than enough to allow any normal use of CHECKSIG, unless people are doing weird things like 2DUP 2DUP 2DUP\u2026\u2026..CHECKSIG CHECKSIG CHECKSIG CHECKSIG , which would have many sigop with a relatively small witness. Interactive per-tx signature aggregation allows 64bytes/tx signature, and per-block non-interatcitve signature aggregation allows 32bytes/signature (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014272.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014272.html>). In such cases, the 1:50 ratio might not be enough if many signatures are aggregated. Depends on the number of sigop we could tolerate, the 1:50 ratio might be reduced to 1:32 or lower to make sure legitimate use would never hit the limit. I think 32 is reasonable as it is about the size of a public key, which would guarantee each pubkey must get a sigop slot.\n\nSo a relay node could be certain that a tx won\u2019t spend excessive CPU power by just looking at its size. If it spends too much, it is invalid and script execution could be terminated early.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180216/296ee3ec/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 659 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180216/296ee3ec/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2018-02-17T02:33:32",
                "message_text_only": "On Fri, Feb 16, 2018 at 10:49 PM, Johnson Lau via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Since we have a block weight limit of 4,000,000 and sigop limit of 80,000,\n> each sigop could not use more than 50 weight unit on average. For new script\n> proposals we could count the actual number of sigop at execution (i.e. skip\n> unexecuted sigop, skip 0-size signature, count the actual checksig\n> operations in multi-sig), and make sure the number of executed sigop * 50 is\n> not greater than the size of the input.\n\nWe have a related policy rule in Bitcoin Core for some time now, the\nweight of the transaction for the purpose of mining is\nmax(weight,lambda*sigops), though we set lambda a bit lower than makes\nsense due to how checkmultisig.  This policy rule replaced an earlier\none which was almost equivalent to your proposal: it rejected\ntransactions with too many sigops per the byte count, but we found it\nblock actual more or less sensible transactions.\n\nGoing forward I don't think this is a great framework.  It works if\nthe only expensive operations all involve large input data, but I\nthink many proposals people have made for new operations would have\ncomputational cost which requires relatively small amounts of\nadditional input-- aggregation is just one fairly minor example."
            }
        ],
        "thread_summary": {
            "title": "Alternative way to count sigops",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gregory Maxwell",
                "Johnson Lau"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5649
        }
    },
    {
        "title": "[bitcoin-dev] Increased blockspace enabled by SegWit limited to just witness data?",
        "thread_messages": [
            {
                "author": "CANNON",
                "date": "2018-02-18T16:26:14",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nI have a question in reference to the increased blockspace enabled\nby the segregated witness upgrade. Is this extra blockspace beyond\nthe legacy 1 MB limit limited to just witness data?\n\n\n- -- \nCannon\nPGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832 \nEmail: cannon at cannon-ciota.info\n\nNOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD \nBE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n-----BEGIN PGP SIGNATURE-----\n\niQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\njLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\nfRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\npe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n+rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\nSW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\nbIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\nn8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\nLVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\nqZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\nI+W6ny7qXt+pegLF4cYL\n=YqEM\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Austin Maier",
                "date": "2018-02-18T16:57:49",
                "message_text_only": "Effectively yes. The discount on weight applies to the witness data.\n\nOn Feb 18, 2018 11:42 AM, \"CANNON via bitcoin-dev\" <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> -----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA512\n>\n> I have a question in reference to the increased blockspace enabled\n> by the segregated witness upgrade. Is this extra blockspace beyond\n> the legacy 1 MB limit limited to just witness data?\n>\n>\n> - --\n> Cannon\n> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n> Email: cannon at cannon-ciota.info\n>\n> NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD\n> BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n> -----BEGIN PGP SIGNATURE-----\n>\n> iQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\n> jLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\n> fRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\n> pe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n> +rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\n> SW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\n> bIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\n> n8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n> 5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\n> LVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\n> qZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\n> I+W6ny7qXt+pegLF4cYL\n> =YqEM\n> -----END PGP SIGNATURE-----\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180218/7e1b32cf/attachment.html>"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-18T17:04:17",
                "message_text_only": "No, you are misunderstanding. The block size limit (1MB) has been replaced in favor of a block weight limit (4M weight). Bytes which must be sent to old clients are weighted at 4 units each which is what allows it to be a soft fork.\n\nSo as such, there's not two separate limits or anything. \n\nP.S. what's up with your signature lol\n\n\n\u200b-Ryan\n\n\u200b\n\n-------- Original Message --------\n On February 18, 2018 11:26 AM, CANNON via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>-----BEGIN PGP SIGNED MESSAGE-----\n> Hash: SHA512\n>\n> I have a question in reference to the increased blockspace enabled\n> by the segregated witness upgrade. Is this extra blockspace beyond\n> the legacy 1 MB limit limited to just witness data?\n>\n>\n>\n>Cannon\n> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n> Email: cannon at cannon-ciota.info\n>\n> NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD\n> BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n> -----BEGIN PGP SIGNATURE-----\n>\n> iQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\n> jLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\n> fRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\n> pe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n> +rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\n> SW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\n> bIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\n> n8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n> 5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\n> LVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\n> qZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\n> I+W6ny7qXt+pegLF4cYL\n> =YqEM\n> -----END PGP SIGNATURE-----\n>\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-02-18T18:39:09",
                "message_text_only": "As a soft fork, all preceding rules remain in effect. No rule has been \u201creplaced\u201d. Blocks must validate against pre-segwit rules or are invalid. Additional rules are applied that further restrict validity, and consider additional (witness) data in the context of the block.\n\ne\n\n> On Feb 18, 2018, at 09:04, Ryan Havar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> No, you are misunderstanding. The block size limit (1MB) has been replaced in favor of a block weight limit (4M weight). Bytes which must be sent to old clients are weighted at 4 units each which is what allows it to be a soft fork.\n> \n> So as such, there's not two separate limits or anything. \n> \n> P.S. what's up with your signature lol\n> \n> \n> \u200b-Ryan\n> \n> \u200b\n> \n> -------- Original Message --------\n>> On February 18, 2018 11:26 AM, CANNON via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> -----BEGIN PGP SIGNED MESSAGE-----\n>> Hash: SHA512\n>> \n>> I have a question in reference to the increased blockspace enabled\n>> by the segregated witness upgrade. Is this extra blockspace beyond\n>> the legacy 1 MB limit limited to just witness data?\n>> \n>> \n>> \n>> Cannon\n>> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n>> Email: cannon at cannon-ciota.info\n>> \n>> NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD\n>> BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n>> -----BEGIN PGP SIGNATURE-----\n>> \n>> iQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\n>> jLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\n>> fRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\n>> pe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n>> +rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\n>> SW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\n>> bIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\n>> n8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n>> 5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\n>> LVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\n>> qZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\n>> I+W6ny7qXt+pegLF4cYL\n>> =YqEM\n>> -----END PGP SIGNATURE-----\n>> \n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> \n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "rhavar at protonmail.com",
                "date": "2018-02-18T19:04:57",
                "message_text_only": "> No rule has been \u201creplaced\u201d.\n\nIt really has been. The code is no longer checks the size of a block, but the weight of it. For all intents and purposes the block size limits has been replaced in favor of a block weight limit. It's just been designed such that the new rule is more restrictive than the one it replaces.\n\nNow, I'm not doubting you can argue the semantics on the difference between \"replacing with a more restrictive rule\" and \"leaving the existing rules, but adding a new one\" -- but it's uninteresting and only serves to confuse novice's like CANNON into thinking that there are two rules/spaces/limits for transactions.\n\n\n\n\u200b-Ryan\n\n\u200b\n\n-------- Original Message --------\n On February 18, 2018 1:39 PM, Eric Voskuil <eric at voskuil.org> wrote:\n\n>As a soft fork, all preceding rules remain in effect. No rule has been \u201creplaced\u201d. Blocks must validate against pre-segwit rules or are invalid. Additional rules are applied that further restrict validity, and consider additional (witness) data in the context of the block.\n>\n> e\n>\n>>On Feb 18, 2018, at 09:04, Ryan Havar via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>>No, you are misunderstanding. The block size limit (1MB) has been replaced in favor of a block weight limit (4M weight). Bytes which must be sent to old clients are weighted at 4 units each which is what allows it to be a soft fork.\n>>So as such, there's not two separate limits or anything.\n>>P.S. what's up with your signature lol\n>>\u200b-Ryan\n>>\u200b\n>>-------- Original Message --------\n>>>On February 18, 2018 11:26 AM, CANNON via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>>>-----BEGIN PGP SIGNED MESSAGE-----\n>>> Hash: SHA512\n>>>I have a question in reference to the increased blockspace enabled\n>>> by the segregated witness upgrade. Is this extra blockspace beyond\n>>> the legacy 1 MB limit limited to just witness data?\n>>>Cannon\n>>> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n>>> Email: cannon at cannon-ciota.info\n>>>NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD\n>>> BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n>>> -----BEGIN PGP SIGNATURE-----\n>>>iQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\n>>> jLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\n>>> fRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\n>>> pe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n>>> +rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\n>>> SW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\n>>> bIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\n>>> n8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n>>> 5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\n>>> LVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\n>>> qZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\n>>> I+W6ny7qXt+pegLF4cYL\n>>> =YqEM\n>>> -----END PGP SIGNATURE-----\n>>>bitcoin-dev mailing list\n>>>bitcoin-dev at lists.linuxfoundation.org\n>>>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>bitcoin-dev mailing list\n>>bitcoin-dev at lists.linuxfoundation.org\n>>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>"
            },
            {
                "author": "Eric Voskuil",
                "date": "2018-02-18T19:14:22",
                "message_text_only": "If the new rule is more restrictive the original limit remains.\n\ne\n\nOn Feb 18, 2018, at 11:04, rhavar at protonmail.com wrote:\n\n>> No rule has been \u201creplaced\u201d.\n> \n> It really has been. The code is no longer checks the size of a block, but the weight of it. For all intents and purposes the block size limits has been replaced in favor of a block weight limit. It's just been designed such that the new rule is more restrictive than the one it replaces.\n> \n> Now, I'm not doubting you can argue the semantics on the difference between \"replacing with a more restrictive rule\" and \"leaving the existing rules, but adding a new one\" -- but it's uninteresting and only serves to confuse novice's like CANNON into thinking that there are two rules/spaces/limits for transactions.\n> \n> \n> \n> \u200b-Ryan\n> \n> \u200b\n> \n> -------- Original Message --------\n>> On February 18, 2018 1:39 PM, Eric Voskuil <eric at voskuil.org> wrote:\n>> \n>> As a soft fork, all preceding rules remain in effect. No rule has been \u201creplaced\u201d. Blocks must validate against pre-segwit rules or are invalid. Additional rules are applied that further restrict validity, and consider additional (witness) data in the context of the block.\n>> \n>> e\n>> \n>>> On Feb 18, 2018, at 09:04, Ryan Havar via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>>> No, you are misunderstanding. The block size limit (1MB) has been replaced in favor of a block weight limit (4M weight). Bytes which must be sent to old clients are weighted at 4 units each which is what allows it to be a soft fork.\n>>> So as such, there's not two separate limits or anything.\n>>> P.S. what's up with your signature lol\n>>> \u200b-Ryan\n>>> \u200b\n>>> -------- Original Message --------\n>>>> On February 18, 2018 11:26 AM, CANNON via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>>>> -----BEGIN PGP SIGNED MESSAGE-----\n>>>> Hash: SHA512\n>>>> I have a question in reference to the increased blockspace enabled\n>>>> by the segregated witness upgrade. Is this extra blockspace beyond\n>>>> the legacy 1 MB limit limited to just witness data?\n>>>> Cannon\n>>>> PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832\n>>>> Email: cannon at cannon-ciota.info\n>>>> NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD\n>>>> BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.\n>>>> -----BEGIN PGP SIGNATURE-----\n>>>> iQIcBAEBCgAGBQJaiajLAAoJEAYDai9lH2mwDbMQAKgJseZG9oOoP9WJlESFdAzm\n>>>> jLM69KLF4RVWDQjMWCtyVayyolXMLavW6fL4GL7/ztLYSl9Pz+FDlH3Qgo1GLDx4\n>>>> fRUkmb0ApLBSAjmdqM+kWjgq3s6/oZaIkNxGeyK5SYY4QhF80Z42PWLBPKjAc7vn\n>>>> pe7Im13NwtyJiRuCmq4e1z6GmW86fFOKOsR4rlWcftHOFmH8Gz5d9KK9LbPqU6Ca\n>>>> +rde8yb+A9uXEv3O9MqeLId7FYSJixgzFGJosidVkAVQI7YZ0TAfG4HSwKjtqDz7\n>>>> SW2Bs3nDeiCr2QN7Su9TUaoSN/yKTBOw5jnql9cNOYuf4GAG0MXWinmYP8MWCiqh\n>>>> bIrzvOnlZGapX/36Fpab67VDcFnXJJc8ofqYmn+oUoW/q7geQpu/V1oz+AR9nD/d\n>>>> n8wFxvZdRlTbq2XDXySaontxNH0rd80fSG5SJtO5Js9hK/vNG+Xa7Zc+76gEtvlF\n>>>> 5G1F6MOcsoXUDCnMteuNxaZx6TPML6RuWVmbR1wXOaX4qZ01p7AsjQlTIcrlVDsB\n>>>> LVGW70wjfETBCffn1JQvFmIK7NzggIUuYfLF0IrfM4BrTa/01RnmfBOpWGiIvyIG\n>>>> qZqKLYDbW7BDkc/HMtAonR/0t6bTUv/388USSnbMakO9bvih0xxIw4NWTyoSoef/\n>>>> I+W6ny7qXt+pegLF4cYL\n>>>> =YqEM\n>>>> -----END PGP SIGNATURE-----\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>> \n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> \n>> \n>"
            }
        ],
        "thread_summary": {
            "title": "Increased blockspace enabled by SegWit limited to just witness data?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Austin Maier",
                "rhavar at protonmail.com",
                "Eric Voskuil",
                "CANNON"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 14479
        }
    },
    {
        "title": "[bitcoin-dev] Some thoughts on removing timestamps in PoW",
        "thread_messages": [
            {
                "author": "Tao Effect",
                "date": "2018-02-19T01:29:50",
                "message_text_only": "Copied from: https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-spring2018/pull/13 <https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-spring2018/pull/13>\n\n\n# Blockchain Timestamps Unnecessary In Proof-of-Work?\n\n*Author: Greg Slepak ([@taoeffect at mastodon.social <mailto:taoeffect at mastodon.social>](https://mastodon.social/@taoeffect <https://mastodon.social/@taoeffect>))*\n\n----\n\nThe Bitcoin blockchain has a 10-minute target blocktime that is achieved by a difficulty adjustment algorithm.\n\nI assert, or rather, pose the hypothesis, that the use of timestamps in Bitcoin's blockchain may be unnecessary, and that Bitcoin can operate with the same security guarantees without it (except as noted in [Risks and Mitigations](#risks-and-mitigations)), and therefore does not need miners to maintain global clock synchronization.\n\nThe alternative difficulty adjustment algorithm would work according to the following principles:\n\n- The incentive for miners is and always has been to maximize profit.\n- The block reward algorithm is now modified to issue coins into perpetuity (no maximum). Any given block can issue _up to_ `X` number of coins per block.\n- The number of coins issued per block is now tied directly to the difficulty of the block, and the concept of \"epocs\" or \"block reward halving\" is removed.\n- The chain selection rule remains \"chain with most proof of work\"\n- The difficulty can be modified by miners in an arbitrary direction (up or down), but is limited in magnitude by some maximum percentage (e.g. no more than 20% deviation from the previous block), we call this `Y%`.\n\n### Observations\n\n- Miners are free to mine blocks of whatever difficulty they choose, up to a maximum deviation\n- The blockchain may at times produce blocks very quickly, and at other times produce blocks more slowly\n- Powerful miners are incentivized to raise the difficulty to remove competitors (as is true today)\n- Whether miners choose to produce blocks quickly or slowly is entirely up to them. If they produce blocks quickly, each block has a lower reward, but there are more of them. If they produce blocks slowly, each block has a higher reward, but there are fewer of them. So an equilibrium will be naturally reached to produce blocks at a rate that should minimize orphans.\n\nA timestamp may still be included in blocks, but it no longer needs to be used for anything, or represent anything significant other than metadata about when the miner claims to have produced the block.\n\n### Risks and Mitigations\n\nSuch a system may introduce risks that require further modification of the protocol to mitigate.\n\nThe most straightforward risk comes from the potential increase in total transaction throughput that such a change would introduce (these are the same concerns that exist with respect to raising the blocksize). The removal of timestamps would allow a cartel of miners to produce high-difficulty blocks at a fast rate, potentially resulting in additional centralization pressures not only on miners but also on full nodes who then would have greater difficulty keeping up with the additional bandwidth and storage demands.\n\nTwo equally straightforward mitigations exist to address this if we are given the liberty of modifying the protocol as we wish:\n\n1. Introducing state checkpoints into the chain itself could make it possible for full nodes to skip verification of large sections of historical data when booting up.\n2. A sharded protocol, where each shard uses a \"sufficiently different\" PoW algorithm, would create an exit for users should the primary blockchain become captured by a cartel providing poor quality-of-service.\n\n\n--\nPlease do not email me anything that you are not comfortable also sharing with the NSA.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180218/89e66ce8/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180218/89e66ce8/attachment-0001.sig>"
            },
            {
                "author": "Damian Williamson",
                "date": "2018-02-19T09:04:02",
                "message_text_only": ">1. Introducing state checkpoints into the chain itself could make it possible for full nodes to skip verification of large sections of historical data when booting up.\n\n\nWhat you are suggesting, unless I am mistaken, is that new full nodes should have no way of knowing if an output is spent or even if it exists. Since large sections of the blockchain will potentially be skipped, the full node will not have complete knowledge of utxo's just for starters.\n\n\nRegards,\n\nDamian Williamson\n\n________________________________\nFrom: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Tao Effect via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Monday, 19 February 2018 12:29:50 PM\nTo: Bitcoin Protocol Discussion\nSubject: [bitcoin-dev] Some thoughts on removing timestamps in PoW\n\nCopied from: https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-spring2018/pull/13\n\n\n# Blockchain Timestamps Unnecessary In Proof-of-Work?\n\n*Author: Greg Slepak ([@taoeffect at mastodon.social<mailto:taoeffect at mastodon.social>](https://mastodon.social/@taoeffect))*\n\n----\n\nThe Bitcoin blockchain has a 10-minute target blocktime that is achieved by a difficulty adjustment algorithm.\n\nI assert, or rather, pose the hypothesis, that the use of timestamps in Bitcoin's blockchain may be unnecessary, and that Bitcoin can operate with the same security guarantees without it (except as noted in [Risks and Mitigations](#risks-and-mitigations)), and therefore does not need miners to maintain global clock synchronization.\n\nThe alternative difficulty adjustment algorithm would work according to the following principles:\n\n- The incentive for miners is and always has been to maximize profit.\n- The block reward algorithm is now modified to issue coins into perpetuity (no maximum). Any given block can issue _up to_ `X` number of coins per block.\n- The number of coins issued per block is now tied directly to the difficulty of the block, and the concept of \"epocs\" or \"block reward halving\" is removed.\n- The chain selection rule remains \"chain with most proof of work\"\n- The difficulty can be modified by miners in an arbitrary direction (up or down), but is limited in magnitude by some maximum percentage (e.g. no more than 20% deviation from the previous block), we call this `Y%`.\n\n### Observations\n\n- Miners are free to mine blocks of whatever difficulty they choose, up to a maximum deviation\n- The blockchain may at times produce blocks very quickly, and at other times produce blocks more slowly\n- Powerful miners are incentivized to raise the difficulty to remove competitors (as is true today)\n- Whether miners choose to produce blocks quickly or slowly is entirely up to them. If they produce blocks quickly, each block has a lower reward, but there are more of them. If they produce blocks slowly, each block has a higher reward, but there are fewer of them. So an equilibrium will be naturally reached to produce blocks at a rate that should minimize orphans.\n\nA timestamp may still be included in blocks, but it no longer needs to be used for anything, or represent anything significant other than metadata about when the miner claims to have produced the block.\n\n### Risks and Mitigations\n\nSuch a system may introduce risks that require further modification of the protocol to mitigate.\n\nThe most straightforward risk comes from the potential increase in total transaction throughput that such a change would introduce (these are the same concerns that exist with respect to raising the blocksize). The removal of timestamps would allow a cartel of miners to produce high-difficulty blocks at a fast rate, potentially resulting in additional centralization pressures not only on miners but also on full nodes who then would have greater difficulty keeping up with the additional bandwidth and storage demands.\n\nTwo equally straightforward mitigations exist to address this if we are given the liberty of modifying the protocol as we wish:\n\n1. Introducing state checkpoints into the chain itself could make it possible for full nodes to skip verification of large sections of historical data when booting up.\n2. A sharded protocol, where each shard uses a \"sufficiently different\" PoW algorithm, would create an exit for users should the primary blockchain become captured by a cartel providing poor quality-of-service.\n\n\n--\nPlease do not email me anything that you are not comfortable also sharing with the NSA.\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/12562bfb/attachment-0001.html>"
            },
            {
                "author": "Tao Effect",
                "date": "2018-02-21T21:58:10",
                "message_text_only": "> What you are suggesting, unless I am mistaken, is that new full nodes should have no way of knowing if an output is spent or even if it exists. Since large sections of the blockchain will potentially be skipped, the full node will not have complete knowledge of utxo's just for starters.\n\nSo, this might not have been clear, but by \"if we are given the liberty of modifying the protocol as we wish\" I meant that I was discussing a protocol where these sorts of concerns are not an issue because we are not limited by the constraints of Bitcoin's current design.\n\nThere have been plenty of proposals across the web for how to design a blockchain where what you're referring to is not an issue because of merkle commitments, etc., and some blockchains already do this (e.g. I believe Ethereum does this via parity).\n\nCheers,\nGreg\n\n--\nPlease do not email me anything that you are not comfortable also sharing with the NSA.\n\n> On Feb 19, 2018, at 4:04 AM, Damian Williamson <willtech at live.com.au> wrote:\n> \n> >1. Introducing state checkpoints into the chain itself could make it possible for full nodes to skip verification of large sections of historical data when booting up.\n> \n> What you are suggesting, unless I am mistaken, is that new full nodes should have no way of knowing if an output is spent or even if it exists. Since large sections of the blockchain will potentially be skipped, the full node will not have complete knowledge of utxo's just for starters.\n> \n> Regards,\n> Damian Williamson\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/1f9f0f49/attachment.sig>"
            },
            {
                "author": "Ryan J Martin",
                "date": "2018-02-19T05:10:31",
                "message_text_only": "To be frank, this kind of thing would be better off attempted as a fork to a new coin. Changing the max number of coins, the block reward, the difficulty algo, mining policy and protocol is going to be a non-starter. Also, what are the proposed quantifiavle benefits from removing timestamps? How would this be done at the protocol level? Are these other changes related to removing timestamps/rationale for other supply changes?\n\nRegards,\nRyan J. Martin\n\n\nOn Feb 18, 2018 10:01 PM, Tao Effect via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\nCopied from: https://github.com/WebOfTrustInfo/rebooting-the-web-of-trust-spring2018/pull/13\n\n\n# Blockchain Timestamps Unnecessary In Proof-of-Work?\n\n*Author: Greg Slepak ([@taoeffect at mastodon.social<mailto:taoeffect at mastodon.social>](https://mastodon.social/@taoeffect))*\n\n----\n\nThe Bitcoin blockchain has a 10-minute target blocktime that is achieved by a difficulty adjustment algorithm.\n\nI assert, or rather, pose the hypothesis, that the use of timestamps in Bitcoin's blockchain may be unnecessary, and that Bitcoin can operate with the same security guarantees without it (except as noted in [Risks and Mitigations](#risks-and-mitigations)), and therefore does not need miners to maintain global clock synchronization.\n\nThe alternative difficulty adjustment algorithm would work according to the following principles:\n\n- The incentive for miners is and always has been to maximize profit.\n- The block reward algorithm is now modified to issue coins into perpetuity (no maximum). Any given block can issue _up to_ `X` number of coins per block.\n- The number of coins issued per block is now tied directly to the difficulty of the block, and the concept of \"epocs\" or \"block reward halving\" is removed.\n- The chain selection rule remains \"chain with most proof of work\"\n- The difficulty can be modified by miners in an arbitrary direction (up or down), but is limited in magnitude by some maximum percentage (e.g. no more than 20% deviation from the previous block), we call this `Y%`.\n\n### Observations\n\n- Miners are free to mine blocks of whatever difficulty they choose, up to a maximum deviation\n- The blockchain may at times produce blocks very quickly, and at other times produce blocks more slowly\n- Powerful miners are incentivized to raise the difficulty to remove competitors (as is true today)\n- Whether miners choose to produce blocks quickly or slowly is entirely up to them. If they produce blocks quickly, each block has a lower reward, but there are more of them. If they produce blocks slowly, each block has a higher reward, but there are fewer of them. So an equilibrium will be naturally reached to produce blocks at a rate that should minimize orphans.\n\nA timestamp may still be included in blocks, but it no longer needs to be used for anything, or represent anything significant other than metadata about when the miner claims to have produced the block.\n\n### Risks and Mitigations\n\nSuch a system may introduce risks that require further modification of the protocol to mitigate.\n\nThe most straightforward risk comes from the potential increase in total transaction throughput that such a change would introduce (these are the same concerns that exist with respect to raising the blocksize). The removal of timestamps would allow a cartel of miners to produce high-difficulty blocks at a fast rate, potentially resulting in additional centralization pressures not only on miners but also on full nodes who then would have greater difficulty keeping up with the additional bandwidth and storage demands.\n\nTwo equally straightforward mitigations exist to address this if we are given the liberty of modifying the protocol as we wish:\n\n1. Introducing state checkpoints into the chain itself could make it possible for full nodes to skip verification of large sections of historical data when booting up.\n2. A sharded protocol, where each shard uses a \"sufficiently different\" PoW algorithm, would create an exit for users should the primary blockchain become captured by a cartel providing poor quality-of-service.\n\n\n--\nPlease do not email me anything that you are not comfortable also sharing with the NSA.\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/99c850da/attachment.html>"
            },
            {
                "author": "Tao Effect",
                "date": "2018-02-19T05:15:59",
                "message_text_only": "Real quick (I've received some off-list replies and do plan to respond to those), want to be clear: this thread is not meant to be interpreted as a proposal to modify Bitcoin (it is not a BIP), it is just, exactly as the subject says, some thoughts I had that I hadn't seen expressed elsewhere, that I felt like sharing, in case they are at all useful/interesting to anyone.\n\nCheers,\nGreg\n\n--\nPlease do not email me anything that you are not comfortable also sharing with the NSA.\n\n> On Feb 19, 2018, at 12:10 AM, Ryan J Martin <rjmarti2 at millersville.edu <mailto:rjmarti2 at millersville.edu>> wrote:\n> \n> To be frank, this kind of thing would be better off attempted as a fork to a new coin. Changing the max number of coins, the block reward, the difficulty algo, mining policy and protocol is going to be a non-starter. Also, what are the proposed quantifiavle benefits from removing timestamps? How would this be done at the protocol level? Are these other changes related to removing timestamps/rationale for other supply changes?\n> \n> Regards,\n> Ryan J. Martin\n> \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/e9eb9acd/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: Message signed with OpenPGP\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/e9eb9acd/attachment.sig>"
            },
            {
                "author": "Daniele Pinna",
                "date": "2018-02-19T13:41:21",
                "message_text_only": "Granted that removing the 21M coin cap is basically a non-starter in de\nbitcoin community I'd like to respond to a couple points in your proposal.\n\nThe Y% difficulty adjustment should still be calculated through some\naveraging of a certain number N of past blocks. Otherwise two lucky high\ndifficulty blocks in a row could potentially grind the network to a halt.\nJust imagine what would happen to the bitcoin network if the difficulty\ntarget was magically increased by 40% all of a sudden. This is certainly\nnot likely but must be considered imo.\n\nThe second, and most interesting (to me at least) is how the reward should\nscale with difficulty. By making the reward scale concavely\n(logarithmically for example) with difficulty as well as depend on past\naverage difficulty AND total # of mined coins, it might be possible to\nretain something close to the 21M coin cap while also disincentivizing\nmining blocks with excessively large difficulties.\n\nLet D and D_0 be the difficulty of the mind block and some reference\ninitial difficulty respectively. S and S_0 the total floating coin supply\nand the reference initial supply. Then the reward function could look\nsomething like this:\n\nR(D, S; D_0,S_0) =R_0(S/S_0)*Log[1+D/D_0]/Log[2]\n\nWhere R_0(S/S_0) can be some decaying exponential function of the ratio\nS/S_0 such that initially (when S=S_0) R_0=12.5.\n\nBut... As I said, this is solely for sake of argument.\n\nDaniele\n\n---------- Forwarded message ----------\nFrom: Tao Effect <contact at taoeffect.com>\nTo: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\nCc:\nBcc:\nDate: Sun, 18 Feb 2018 20:29:50 -0500\nSubject: [bitcoin-dev] Some thoughts on removing timestamps in PoW\nCopied from: https://github.com/WebOfTrustInfo/rebooting-the-\nweb-of-trust-spring2018/pull/13\n\n\n# Blockchain Timestamps Unnecessary In Proof-of-Work?\n\n*Author: Greg Slepak ([@taoeffect at mastodon.social](https://mastodon.social/@\ntaoeffect))*\n\n----\n\nThe Bitcoin blockchain has a 10-minute target blocktime that is achieved by\na difficulty adjustment algorithm.\n\nI assert, or rather, pose the hypothesis, that the use of timestamps in\nBitcoin's blockchain may be unnecessary, and that Bitcoin can operate with\nthe same security guarantees without it (except as noted in [Risks and\nMitigations](#risks-and-mitigations)), and therefore does not need miners\nto maintain global clock synchronization.\n\nThe alternative difficulty adjustment algorithm would work according to the\nfollowing principles:\n\n- The incentive for miners is and always has been to maximize profit.\n- The block reward algorithm is now modified to issue coins into perpetuity\n(no maximum). Any given block can issue _up to_ `X` number of coins per\nblock.\n- The number of coins issued per block is now tied directly to the\ndifficulty of the block, and the concept of \"epocs\" or \"block reward\nhalving\" is removed.\n- The chain selection rule remains \"chain with most proof of work\"\n- The difficulty can be modified by miners in an arbitrary direction (up or\ndown), but is limited in magnitude by some maximum percentage (e.g. no more\nthan 20% deviation from the previous block), we call this `Y%`.\n\n### Observations\n\n- Miners are free to mine blocks of whatever difficulty they choose, up to\na maximum deviation\n- The blockchain may at times produce blocks very quickly, and at other\ntimes produce blocks more slowly\n- Powerful miners are incentivized to raise the difficulty to remove\ncompetitors (as is true today)\n- Whether miners choose to produce blocks quickly or slowly is entirely up\nto them. If they produce blocks quickly, each block has a lower reward, but\nthere are more of them. If they produce blocks slowly, each block has a\nhigher reward, but there are fewer of them. So an equilibrium will be\nnaturally reached to produce blocks at a rate that should minimize orphans.\n\nA timestamp may still be included in blocks, but it no longer needs to be\nused for anything, or represent anything significant other than metadata\nabout when the miner claims to have produced the block.\n\n### Risks and Mitigations\n\nSuch a system may introduce risks that require further modification of the\nprotocol to mitigate.\n\nThe most straightforward risk comes from the potential increase in total\ntransaction throughput that such a change would introduce (these are the\nsame concerns that exist with respect to raising the blocksize). The\nremoval of timestamps would allow a cartel of miners to produce\nhigh-difficulty blocks at a fast rate, potentially resulting in additional\ncentralization pressures not only on miners but also on full nodes who then\nwould have greater difficulty keeping up with the additional bandwidth and\nstorage demands.\n\nTwo equally straightforward mitigations exist to address this if we are\ngiven the liberty of modifying the protocol as we wish:\n\n1. Introducing state checkpoints into the chain itself could make it\npossible for full nodes to skip verification of large sections of\nhistorical data when booting up.\n2. A sharded protocol, where each shard uses a \"sufficiently different\" PoW\nalgorithm, would create an exit for users should the primary blockchain\nbecome captured by a cartel providing poor quality-of-service.\n\n\n--\nPlease do not email me anything that you are not comfortable also sharing with\nthe NSA.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/b27ba57b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Some thoughts on removing timestamps in PoW",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson",
                "Ryan J Martin",
                "Tao Effect",
                "Daniele Pinna"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 22120
        }
    },
    {
        "title": "[bitcoin-dev] Built in encryption",
        "thread_messages": [
            {
                "author": "Ilan Oh",
                "date": "2018-02-19T09:21:34",
                "message_text_only": "Hey guys,\n\nFeatures info,\nI know we can add text to a btc transaction and it is pretty easy,\n\nHowever is it possible to encrypt the data in a way that only the receiver\nwould be able to read it in clear.\nAnd of course without having to exchange info off the network.\n\nAnd if not possible on bitcoin would it be possible on a sidechain or on\nrsk or else\n\nI have few ideas of concrete uses of it, I'm sure you guys may also think\nof something interesting,\n\nThanks,\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180219/754837c4/attachment.html>"
            },
            {
                "author": "Lucas Clemente Vella",
                "date": "2018-02-19T20:11:56",
                "message_text_only": "Theoretically, if the recipient address had already disclosed the\npublic key (i.e. already spent from that address), or shared it with\nyou instead of (or alongside with) the address, then you can use\nrecipient's ECDSA key to encrypt the message with ECC, as both ECDSA\nand ECC share the same kind of public/private key pair, according to\nthe this link: https://crypto.stackexchange.com/questions/14662/using-ecdsa-keys-for-encryption\n\nIn practice, I am not sure the nodes would broadcast such non-standard\ntransaction (but it can be mined, nonetheless).\n\n2018-02-19 6:21 GMT-03:00 Ilan Oh via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org>:\n> Hey guys,\n>\n> Features info,\n> I know we can add text to a btc transaction and it is pretty easy,\n>\n> However is it possible to encrypt the data in a way that only the receiver\n> would be able to read it in clear.\n> And of course without having to exchange info off the network.\n>\n> And if not possible on bitcoin would it be possible on a sidechain or on rsk\n> or else\n>\n> I have few ideas of concrete uses of it, I'm sure you guys may also think of\n> something interesting,\n>\n> Thanks,\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \nLucas Clemente Vella\nlvella at gmail.com"
            }
        ],
        "thread_summary": {
            "title": "Built in encryption",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Lucas Clemente Vella",
                "Ilan Oh"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2020
        }
    },
    {
        "title": "[bitcoin-dev] Multi CSV Transaction",
        "thread_messages": [
            {
                "author": "Praveen Baratam",
                "date": "2018-02-20T16:53:25",
                "message_text_only": "Hello Everybody,\n\nI need a little clarity about how OP_CHECKSEQUENCEVERIFY (CSV) works in\ntransactions.\n\nCan I use multiple CSV end points as depicted in the figure below? I\nbasically want to allow different conditions at different delays.\n\n[image: Inline image 3]\n\nI just want to know if OP_CHECKSEQUENCEVERIFY can be used to achieve the\nabove.\n\nThank you.\n\nPraveen\n\u1427\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180220/915127e0/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Multi CSV.png\nType: image/png\nSize: 119739 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180220/915127e0/attachment-0001.png>"
            },
            {
                "author": "Daniel Robinson",
                "date": "2018-02-21T00:59:45",
                "message_text_only": "Yes, although it's a functionality of Bitcoin Script generally, not OP_CSV\nin particular. Bitcoin Script allows you to use nested IF statements, and\nenforce whatever different conditions you want in each branch.\n\nHere's your contract in Ivy <https://ivy-lang.org/bitcoin/>:\n\ncontract MultiCSV(\n  bob: PublicKey,\n  carol: PublicKey,\n  bobDelay: Duration,\n  carolDelay: Duration,\n  val: Value\n) {\n  clause bobSpend(sig: Signature) {\n    verify checkSig(bob, sig)\n    verify older(bobDelay)\n    unlock val\n  }\n  clause carolSpend(sig: Signature) {\n    verify checkSig(carol, sig)\n    verify older(carolDelay)\n    unlock val\n  }\n  clause bothSpend(bobSig: Signature, carolSig: Signature) {\n    verify checkMultiSig([bob, carol], [bobSig, carolSig])\n    unlock val\n  }\n}\n\nIt compiles to the following Bitcoin Script:\n\nPUSH(carolKey) PUSH(bobKey) 2 PICK 2 EQUAL IF ROT DROP 0 4 ROLL 4 ROLL 2\n2ROT 2 CHECKMULTISIG ELSE ROT IF DROP CHECKSIGVERIFY PUSH(carolDelay)\nCHECKSEQUENCEVERIFY DROP 1 ELSE NIP CHECKSIGVERIFY PUSH(bobDelay)\nCHECKSEQUENCEVERIFY DROP 1 ENDIF ENDIF\n\nOn Tue, Feb 20, 2018 at 5:32 PM Praveen Baratam via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Everybody,\n>\n> I need a little clarity about how OP_CHECKSEQUENCEVERIFY (CSV) works in\n> transactions.\n>\n> Can I use multiple CSV end points as depicted in the figure below? I\n> basically want to allow different conditions at different delays.\n>\n> [image: Multi CSV.png]\n>\n> I just want to know if OP_CHECKSEQUENCEVERIFY can be used to achieve the\n> above.\n>\n> Thank you.\n>\n> Praveen\n> \u1427\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/c8f680ea/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Multi CSV.png\nType: image/png\nSize: 119739 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/c8f680ea/attachment-0001.png>"
            },
            {
                "author": "Praveen Baratam",
                "date": "2018-02-21T02:36:31",
                "message_text_only": "Thank you Daniel!\n\nYour detailed explanation did clear things up :-)\n\u1427\n\nOn Wed, Feb 21, 2018 at 6:29 AM, Daniel Robinson <danrobinson010 at gmail.com>\nwrote:\n\n> Yes, although it's a functionality of Bitcoin Script generally, not OP_CSV\n> in particular. Bitcoin Script allows you to use nested IF statements, and\n> enforce whatever different conditions you want in each branch.\n>\n> Here's your contract in Ivy <https://ivy-lang.org/bitcoin/>:\n>\n> contract MultiCSV(\n>   bob: PublicKey,\n>   carol: PublicKey,\n>   bobDelay: Duration,\n>   carolDelay: Duration,\n>   val: Value\n> ) {\n>   clause bobSpend(sig: Signature) {\n>     verify checkSig(bob, sig)\n>     verify older(bobDelay)\n>     unlock val\n>   }\n>   clause carolSpend(sig: Signature) {\n>     verify checkSig(carol, sig)\n>     verify older(carolDelay)\n>     unlock val\n>   }\n>   clause bothSpend(bobSig: Signature, carolSig: Signature) {\n>     verify checkMultiSig([bob, carol], [bobSig, carolSig])\n>     unlock val\n>   }\n> }\n>\n> It compiles to the following Bitcoin Script:\n>\n> PUSH(carolKey) PUSH(bobKey) 2 PICK 2 EQUAL IF ROT DROP 0 4 ROLL 4 ROLL 2\n> 2ROT 2 CHECKMULTISIG ELSE ROT IF DROP CHECKSIGVERIFY PUSH(carolDelay)\n> CHECKSEQUENCEVERIFY DROP 1 ELSE NIP CHECKSIGVERIFY PUSH(bobDelay)\n> CHECKSEQUENCEVERIFY DROP 1 ENDIF ENDIF\n>\n> On Tue, Feb 20, 2018 at 5:32 PM Praveen Baratam via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello Everybody,\n>>\n>> I need a little clarity about how OP_CHECKSEQUENCEVERIFY (CSV) works in\n>> transactions.\n>>\n>> Can I use multiple CSV end points as depicted in the figure below? I\n>> basically want to allow different conditions at different delays.\n>>\n>> [image: Multi CSV.png]\n>>\n>> I just want to know if OP_CHECKSEQUENCEVERIFY can be used to achieve the\n>> above.\n>>\n>> Thank you.\n>>\n>> Praveen\n>> \u1427\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n\n-- \nDr. Praveen Baratam\n\nabout.me <http://about.me/praveen.baratam>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/6c93a074/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: Multi CSV.png\nType: image/png\nSize: 119739 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180221/6c93a074/attachment-0001.png>"
            }
        ],
        "thread_summary": {
            "title": "Multi CSV Transaction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Praveen Baratam",
                "Daniel Robinson"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5572
        }
    },
    {
        "title": "[bitcoin-dev] Fwd: [Lightning-dev] Post-Schnorr lightning txes",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2018-02-20T22:42:19",
                "message_text_only": "---------- Forwarded message ----------\nFrom: Anthony Towns <aj at erisian.com.au>\nDate: Mon, Feb 19, 2018 at 4:59 PM\nSubject: [Lightning-dev] Post-Schnorr lightning txes\nTo: lightning-dev at lists.linuxfoundation.org\n\n\nHi *,\n\nMy understanding of lightning may be out of date, so please forgive\n(or at least correct :) any errors on my behalf.\n\nI was thinking about whether Greg Maxwell's graftroot might solve the\nchannel monitoring problem (spoiler: not really) and ended up with maybe\nan interesting take on Schnorr. I don't think I've seen any specific\nwriteup of what that might look like, so hopefully at least some of this\nis novel!\n\nI'm assuming familiarity with current thinking on Schnorr sigs -- but all\nyou should need to know is the quick summary at footnote [0].\n\nSo I think there's four main scenarios for closing a lightning channel:\n\n - both parties are happy to close, do so cooperatively, and can\n   sign a new unconditional transaction that they agree on. already fine.\n   (should happen almost all of the time, call it 80%)\n\n - communications failure: one side has to close, but the other side\n   is happy to cooperate as far as they're able but can only do so via\n   the blockchain and maybe with some delay (maybe 15% of the time)\n\n - disappearance, uncooperative: one side effectively completely\n   disappears so the other side has to fully close the channel on their\n   own (5% of the time)\n\n - misbehaviour: one side tries publishing an old channel state due to\n   error or maliciousness, and the other collects the entire balance as\n   penalty (0% of the time)\n\nWith \"graftroot\" in mind, I was thinking that optimising for the last\ncase might be interesting -- despite expecting it to be vanishingly\nrare. That would have to look something like:\n\n   (0) funding tx\n   (1) ...which is spent by a misbehaving commitment tx\n   (2) ...which is spent by a penalty tx\n\nYou do need 3 txes for that case, but you really only need 1 output\nfor each: so (0) is 2-in-1-out, (1) is 1-in-1-out, (2) is 1-in-1-out;\nwhich could all be relatively cheap. (And (2) could be batched with other\ntxes making it 1 input in a potentially large tx)\n\nFor concreteness, I'm going to treat A as the one doing the penalising,\nand B (Bad?) as the one that's misbehaving.\n\nIf you treat each of those txes as a muSig Schnorr pay-to-pubkey, the\noutput addresses would be:\n\n   (0) funding tx pays to [A,B]\n   (1) commitment tx pays to [A(i),Revocation(B,i)]\n   (2) pays to A\n\n(where i is a commitment id / counter for the channel state)\n\nIf B misbehaves by posting the commitment tx after revealing the\nrevocation secret, A can calculate A(i) and Revocation(B,i) and claim\nall the funds immediately.\n\nAs far as the other cases go:\n\n  - In a cooperative close, you don't publish any commitment txes, you\n    just spend the funding to each party's preferred destinations\n    directly; so this is already great.\n\n  - Otherwise, you need to be able to actually commit to how the funds\n    get distributed.\n\nBut committing to distributing funds is easy: just jointly sign\na transaction with [A(i),Revocation(B,i)]. Since B is the one we're\nworrying about misbehaving, it needs to hold a transaction with the\nappropriate outputs that is:\n\n  - timelocked to `to_self_delay` blocks/seconds in advance via nSequence\n  - signed by A(i)\n\nThat ensures A has `to_self_delay` blocks/seconds to penalise misehaviour,\nand that when closing properly, B can complete the signature using the\ncurrent revocation secret.\n\nThis means the \"appropriate outputs\" no longer need the OP_CSV step, which\nshould simplify the scripts a bit.\n\nHaving B have a distribution transaction isn't enough -- B could vanish\nbetween publishing the commitment transaction and the distribution\ntransaction, leaving A without access to any funds. So A needs a\ncorresponding distribution transaction. But because that transaction can\nonly be published if B signs and publishes the corresponding commitment\ntransaction, the fact that it's published indicates both A and B are\nhappy with the channel close -- so this is a semi-cooperative close and\nno delay is needed. So A should hold a partially signed transaction with\nthe same outputs:\n\n  - without any timelock\n  - signed by Revocation(B,i), waiting for signature by A(i)\n\nThus, if B does a non-cooperative close, either:\n\n  - A proves misbehaviour and claims all the funds immediately\n  - A agrees that the channel state is correct, signs and publishes\n    the un-timelocked distribution transaction, then claims A's outputs;\n    B can then immediately claim its outputs\n  - A does nothing, and B waits for the `to_self_delay` period, signs\n    and publishes its transaction, then claims B's outputs; A can eventually\n    claim its own outputs\n\nIn that case all of the transactions except the in-flight HTLCs just look\nlike simple pay-to-pubkey transactions.\n\nFurther, other than the historical secrets no old information needs\nto be retained: misbehaviour can be dealt with (and can only be dealt\nwith) by creating a new transaction signed by your own secrets and the\nrevocation information.\n\nNone of that actually relies on Schnorr-multisig, I think -- it could\nbe done today with normal 2-of-2 multisig as far as I can see.\n\n\n\nI'm not 100% sure how this approach works compared to the current one\nfor the CSV/CLTV overlap problem. I think any case you could solve by\nobtaining a HTLC-Timeout or HTLC-Success transaction currently, you could\nsolve in the above scenario by just updating the channel state to remove\nthe HTLC.\n\n\nSo I believe the above lets you completely forget info about old HTLCs,\nwhile still enforcing correct behavior, and also makes enforcing correct\nbehaviour cheaper because it's just two extremely simple transactions\nto post. If I haven't missed any corner cases, it also seems to simplify\nthe scripts a fair bit.\n\nDoes this make sense? It seems to to me...\n\n\nSo for completeness, it would make sense to do HTLCs via Schnorr --\nat least to make them reveal elliptic curve private keys, and ideally\nto make them mostly indistinguishable from regular transactions as a\n\"scriptless script\" [1] or \"discreet log contract\" [2]. (I think, at\nleast for HTLCs, these end up being the same?)\n\nThe idea then is to have the HTLC payment hash be R=r*G, where r is the\nsecret/payment receipt.\n\nSupposing your current commitment has n HTLCs in-flight, some paying A\nif the HTLC succeeds and \"r\" is revealed, others paying B. We'll focus\non one paying A.\n\nSo you succeed by A completing a signature that reveals r to B,\nand which simultaneously allows collection of the funds on chain. A\nneeds to be able to do this knowing nothing other than r (and their own\nprivate keys). So agree to sign to muSig 2-of-2 multisig [A,B]. A and B\ngenerate random values i and j respectively and reveal I=i*G and J=j*G,\nand each calculates Q=I+J+R, and they generate partial signatures of a\ntransaction paying A:\n\n    I, i + H(X,Q,m)*H(L,A)*a\n    J, j + H(X,Q,m)*H(L,B)*b\n\nwhere L = H(A,B) and X = H(L,A)*A + H(L,B)*B as usual. Once A knows r,\nA can construct a full signature by adding R, r to the above values,\nand B can then determine r by subtracting the above values from signature\nA generated.\n\nTo ensure B gets paid if the HTLC timesout, they should also sign a\ntimelocked transaction paying B directly, that B can hold onto until\nthe channel state gets updated.\n\nAnd once you're doing payment hashes via ECC, you can of course change\nthem at each hop to make it harder to correlate steps in a payment route.\n\nI think that when combined with the above method of handling CSV delays\nand revocation, this covers all the needed cases with a straightforward\npay-to-pubkey(hash) output, no script info needed at all. It does mean\neach HTLC needs a signature every time the channel state updates (B needs\nto sign a tx allowing A to claim the output once A knows the secret,\nA needs to sign a tx allowing B to claim the output on timeout).\n\n\nFor channel monitoring this is pretty good, I think. You need to\nkeep track of the revocation info and your secret keys -- but that's\nessentially a constant amount of data.\n\nIf you're happy to have the data grow by 64 bytes every time the channel\nstate updates, you can outsource channel monitoring: arrange a formula\nfor constructing a penalty tx based on the channel commitment tx --\neg, 95% of the balance goes to me, 4% goes to the monitor's address, 1%\ngoes to fees, there's a relative locktime of to_self_delay/3 to allow me\nto directly claim 100% of the funds if I happen to be paying attention;\nthen do a partial signature with A(i), and then allow the monitoring\nservice to catch fraudulent transactions, work out the appropriate\nrevocation secret, and finish the signature.\n\nIf your channel updates 100 times a second for an entire year, that's\n200GB of data, which seems pretty feasible. (You can't just regenerate\nthat data though, unless you keep each commitment tx) And it's pretty\neasy to work out which bit of data you need to access: the funding\ntx that's being spent tells you which channel, and the channel state\nindex is encoded in the locktime and sequence, so you should only need\nsmall/logarithmic overhead even for frequently updated channels rather\nthan any serious indexes.\n\nI don't think you can do better than that without serious changes to\nbitcoin: if you let the monitoring agency sign on its own, you'd need some\nsort of covenant opcode to ensure it sends any money to you; and with\nsegwit outputs, there's no way to provide a signature for a transaction\nwithout committing to exactly which transaction you're signing.\n\nI was hoping covenants and graftroot would be enough, but I don't\nthink they are. The idea would be that since the transaction spends to\nA(i)+Rev(B,i), you'd sign an output script with A that uses covenant\nopcodes to ensure the transaction only pays the appropriate monitoring\nreward, and the monitor could then work out A(i)-A and Rev(B,i) and finish\nthe signature. But the signature by \"A\" would need to know A(i)+Rev(B,i)\nwhen calculating the hash, and that's different for every commitment\ntransaction, so as far as I can see, it just doesn't work. You can't\ndrop the muSig-style construction because you need to be protect yourself\nagainst potential malicious choice of the revocation secret [3].\n\n\nSummary:\n\n - Funding txes as 2-of-2 multisig is still great. Convert to\n   Schnorr/muSig when available of course.\n\n - Generate 6+8*n transactions everytime the channel state is updated,\n   (n = number of HTLCs in-flight)\n\n   1. Channel state commitment tx, held by A, spends funding tx,\n      payable to Schnorr muSig address [A(i),Rev(B,i)], signed by B\n   2. Channel fund distribution tx, held by A (CSV), spends (1),\n      signed by Rev(B,i)\n   3. Channel fund distribution tx, held by B (no CSV), spends (1),\n      signed by A(i)\n   4. Channel state commitment tx, held by B, spends funding tx\n      payable to Schnorr muSig address [B(i),Rev(A,i)], signed by A\n   5. Channel fund distribution tx, held by B (CSV), spends (4),\n      signed by Rev(A,i)\n   6. Channel fund distribution tx, held by A (no CSV), spends (4),\n      signed by B(i)\n\n   The fund distribution txs all pay the same collection of addresses:\n     - channel balance for A directly to A's preferred address\n     - channel balance for B directly to B's preferred address\n     - HTLC balance to muSig address for [A,B] for each in-flight HTLC\n       paying A on success\n     - HTLC balance to muSig address for [B,A] for each in-flight HTLC\n       paying B on success\n     - (probably makes sense to bump the HTLC addresses by some random\n       value to make it harder for third parties to tell which addresses\n       were balances versus HTLCs)\n\n   Both (1) and (4) include obscured channel state ids as per current\n   standard.\n\n   For each HTLC that pays X on timeout and Y on success:\n     a. Timeout tx, held by X, signed by Y, spends from (2)\n     b. Timeout tx, held by X, signed by Y, spends from (3)\n     c. Timeout tx, held by X, signed by Y, spends from (5)\n     d. Timeout tx, held by X, signed by Y, spends from (6)\n\n     e. Success tx, held by Y, signed by X, spends from (2)\n     f. Success tx, held by Y, signed by X, spends from (3)\n     g. Success tx, held by Y, signed by X, spends from (5)\n     h. Success tx, held by Y, signed by X, spends from (6)\n\n     (these should all be able to be SIGHASH_SINGLE, ANYONECANPAY\n      to allow some level of aggregation)\n\n - Fund distribution tx outputs can all be pay2pubkey(hash): HTLCs work\n   by pre-signed timelocked transactions and scriptless\n   scripts/discreet-log contracts to reveal the secret; balances work\n   directly; CSV and revocations are already handled by that point\n\n - You can discard all old transaction info and HTLC parameters once\n   they're not relevant to the current channel state\n\n - Channel monitoring can be outsourced pretty efficiently -- as little as\n   a signature per state could be made to works as far as I can see,\n   which doesn't add up too fast.\n\n - There's still no plausible way of doing constant space outsourced\n   channel monitoring without some sort of SIGHASH_NOINPUT, at least\n   that I can see\n\nThoughts?\n\n[4]\n\nCheers,\naj, very sad that this didn't turn out to be a potential use case for\n    graftroot :(\n\n[0] In particular, I'm assuming that:\n\n    - Schnorr sigs in bitcoin will look something like:\n        R, r + H(X,R,m)*x\n\n      (where m is the message being signed by private key x, r is a\n      random per-sig nonce, R and X are public keys corresponding to r,x;\n      H is the secure hash function)\n\n    - muSig is a secure way for untrusting parties to construct an n-of-n\n      combined signature; for public keys A and B, it produces a combined\n      public key:\n        X = H(L,A)*A + H(L,B)*B\n      with L = H(A,B)\n\n   See https://blockstream.com/2018/01/23/musig-key-aggregation-\nschnorr-signatures.html\n\n[1] https://scalingbitcoin.org/stanford2017/Day2/Using-the-\nChain-for-what-Chains-are-Good-For.pdf\n    http://diyhpl.us/wiki/transcripts/scalingbitcoin/\nstanford-2017/using-the-chain-for-what-chains-are-good-for/\n\n[2] https://adiabat.github.io/dlc.pdf\n    https://diyhpl.us/wiki/transcripts/discreet-log-contracts/\n\n[3] Well, maybe you could request a zero-knowledge proof to ensure a new\n    revocation hash conforms to the standard for generating revocation\n    secrets without revealing the secret, and have the public key be\n    a(i)*G + r(B,i)*G without using the muSig construct, but that would\n    probably be obnoxious to have to generate every time you update\n    the channel state.\n\n[4] As an aside -- this could make it feasible and interesting to penalise\n    disappearance as well as misbehaviour. If you add a transaction\n    the B pre-signs, spending the commitment tx A holds, giving all the\n    channel funds to A but only after a very large CSV timeout, perhaps\n    `to_self_delay`*50, then the scenarios are:\n\n    If A is present:\n\n      - B publishes an old commitment: A immediately steals all the\n        funds if active or outsourced misbehaviour monitoring. Whoops!\n\n      - B publishes the current commitment: A publishes its distribution\n        transaction and collects its funds immediately, allowing B to\n        do likewise\n\n    If A has disappeared:\n\n      - B publises the current commitment and waits a modest amount\n        of time, publishes its distribution transaction claiming its\n        rightful funds, and allowing A to collect its funds if it ever\n        does reappear and still knows its secrets\n\n      - B publishes the current commitment, waits a fair while,\n        A reappears and publishes its distribution transactions, both\n        parties get their rightful funds\n\n      - B publishes the current commitment, waits an extended period\n        of time, and claims the entire channel's funds. If B is\n        particularly reputable, and A can prove its identity (but not\n        recover all its secrets) maybe B even refunds A some/all of its\n        rightful balance\n\n    Perhaps that provides too much of an incentive to try blocking\n    someone from having access to the blockchain though.\n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180220/1540dab1/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Post-Schnorr lightning txes",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 16564
        }
    },
    {
        "title": "[bitcoin-dev] BIP Activation Reference",
        "thread_messages": [
            {
                "author": "Damian Williamson",
                "date": "2018-02-24T06:00:48",
                "message_text_only": "Would it be possible or desirable to add a `nBlockHeight Activated` column to the [README.mediawiki](https://github.com/bitcoin/bips/blob/master/README.mediawiki) to show a specific reference to when a BIP was activated? - And/or include such information in the BIP Header format?\n\n\nRegards,\n\nDamian Williamson\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180224/34196124/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Activation Reference",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Damian Williamson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 498
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.16.0 released",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2018-02-26T07:54:17",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBitcoin Core version 0.16.0 is now available from:\n\n  <https://bitcoincore.org/bin/bitcoin-core-0.16.0/>\n\nor through bittorrent:\n\n  magnet:?xt=urn:btih:6493ae7a15b4d32bb4eca1dfaf6dcc0c143492cb&dn=bitcoin-core-0.16.0&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969\n\nThis is a new major version release, including new features, various bugfixes\nand performance improvements, as well as updated translations.\n\nPlease report bugs using the issue tracker at GitHub:\n\n  <https://github.com/bitcoin/bitcoin/issues>\n\nTo receive security and update notifications, please subscribe to:\n\n  <https://bitcoincore.org/en/list/announcements/join/>\n\nHow to Upgrade\n==============\n\nIf you are running an older version, shut it down. Wait until it has completely\nshut down (which might take a few minutes for older versions), then run the\ninstaller (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\nor `bitcoind`/`bitcoin-qt` (on Linux).\n\nThe first time you run version 0.15.0 or newer, your chainstate database will be converted to a\nnew format, which will take anywhere from a few minutes to half an hour,\ndepending on the speed of your machine.\n\nNote that the block database format also changed in version 0.8.0 and there is no\nautomatic upgrade code from before version 0.8 to version 0.15.0 or higher. Upgrading\ndirectly from 0.7.x and earlier without re-downloading the blockchain is not supported.\nHowever, as usual, old wallet versions are still supported.\n\nDowngrading warning\n- -------------------\n\nWallets created in 0.16 and later are not compatible with versions prior to 0.16\nand will not work if you try to use newly created wallets in older versions. Existing\nwallets that were created with older versions are not affected by this.\n\nCompatibility\n==============\n\nBitcoin Core is extensively tested on multiple operating systems using\nthe Linux kernel, macOS 10.8+, and Windows Vista and later. Windows XP is not supported.\n\nBitcoin Core should also work on most other Unix-like systems but is not\nfrequently tested on them.\n\nNotable changes\n===============\n\nWallet changes\n- ---------------\n\n### Segwit Wallet\n\nBitcoin Core 0.16.0 introduces full support for segwit in the wallet and user interfaces. A new `-addresstype` argument has been added, which supports `legacy`, `p2sh-segwit` (default), and `bech32` addresses. It controls what kind of addresses are produced by `getnewaddress`, `getaccountaddress`, and `createmultisigaddress`. A `-changetype` argument has also been added, with the same options, and by default equal to `-addresstype`, to control which kind of change is used.\n\nA new `address_type` parameter has been added to the `getnewaddress` and `addmultisigaddress` RPCs to specify which type of address to generate.\nA `change_type` argument has been added to the `fundrawtransaction` RPC to override the `-changetype` argument for specific transactions.\n\n- - All segwit addresses created through `getnewaddress` or `*multisig` RPCs explicitly get their redeemscripts added to the wallet file. This means that downgrading after creating a segwit address will work, as long as the wallet file is up to date.\n- - All segwit keys in the wallet get an implicit redeemscript added, without it being written to the file. This means recovery of an old backup will work, as long as you use new software.\n- - All keypool keys that are seen used in transactions explicitly get their redeemscripts added to the wallet files. This means that downgrading after recovering from a backup that includes a segwit address will work\n\nNote that some RPCs do not yet support segwit addresses. Notably, `signmessage`/`verifymessage` doesn't support segwit addresses, nor does `importmulti` at this time. Support for segwit in those RPCs will continue to be added in future versions.\n\nP2WPKH change outputs are now used by default if any destination in the transaction is a P2WPKH or P2WSH output. This is done to ensure the change output is as indistinguishable from the other outputs as possible in either case.\n\n### BIP173 (Bech32) Address support (\"bc1...\" addresses)\n\nFull support for native segwit addresses (BIP173 / Bech32) has now been added.\nThis includes the ability to send to BIP173 addresses (including non-v0 ones), and generating these\naddresses (including as default new addresses, see above).\n\nA checkbox has been added to the GUI to select whether a Bech32 address or P2SH-wrapped address should be generated when using segwit addresses. When launched with `-addresstype=bech32` it is checked by default. When launched with `-addresstype=legacy` it is unchecked and disabled.\n\n### HD-wallets by default\n\nDue to a backward-incompatible change in the wallet database, wallets created\nwith version 0.16.0 will be rejected by previous versions. Also, version 0.16.0\nwill only create hierarchical deterministic (HD) wallets. Note that this only applies\nto new wallets; wallets made with previous versions will not be upgraded to be HD.\n\n### Replace-By-Fee by default in GUI\n\nThe send screen now uses BIP125 RBF by default, regardless of `-walletrbf`.\nThere is a checkbox to mark the transaction as final.\n\nThe RPC default remains unchanged: to use RBF, launch with `-walletrbf=1` or\nuse the `replaceable` argument for individual transactions.\n\n### Wallets directory configuration (`-walletdir`)\n\nBitcoin Core now has more flexibility in where the wallets directory can be\nlocated. Previously wallet database files were stored at the top level of the\nbitcoin data directory. The behavior is now:\n\n- - For new installations (where the data directory doesn't already exist),\n  wallets will now be stored in a new `wallets/` subdirectory inside the data\n  directory by default.\n- - For existing nodes (where the data directory already exists), wallets will be\n  stored in the data directory root by default. If a `wallets/` subdirectory\n  already exists in the data directory root, then wallets will be stored in the\n  `wallets/` subdirectory by default.\n- - The location of the wallets directory can be overridden by specifying a\n  `-walletdir=<path>` option where `<path>` can be an absolute path to a\n  directory or directory symlink.\n\nCare should be taken when choosing the wallets directory location, as if it\nbecomes unavailable during operation, funds may be lost.\n\nBuild: Minimum GCC bumped to 4.8.x\n- ------------------------------------\nThe minimum version of the GCC compiler required to compile Bitcoin Core is now 4.8. No effort will be\nmade to support older versions of GCC. See discussion in issue #11732 for more information.\nThe minimum version for the Clang compiler is still 3.3. Other minimum dependency versions can be found in `doc/dependencies.md` in the repository.\n\nSupport for signalling pruned nodes (BIP159)\n- ---------------------------------------------\nPruned nodes can now signal BIP159's NODE_NETWORK_LIMITED using service bits, in preparation for\nfull BIP159 support in later versions. This would allow pruned nodes to serve the most recent blocks. However, the current change does not yet include support for connecting to these pruned peers.\n\nPerformance: SHA256 assembly enabled by default\n- -------------------------------------------------\nThe SHA256 hashing optimizations for architectures supporting SSE4, which lead to ~50% speedups in SHA256 on supported hardware (~5% faster synchronization and block validation), have now been enabled by default. In previous versions they were enabled using the `--enable-experimental-asm` flag when building, but are now the default and no longer deemed experimental.\n\nGUI changes\n- -----------\n- - Uses of \"\u00b5BTC\" in the GUI now also show the more colloquial term \"bits\", specified in BIP176.\n- - The option to reuse a previous address has now been removed. This was justified by the need to \"resend\" an invoice, but now that we have the request history, that need should be gone.\n- - Support for searching by TXID has been added, rather than just address and label.\n- - A \"Use available balance\" option has been added to the send coins dialog, to add the remaining available wallet balance to a transaction output.\n- - A toggle for unblinding the password fields on the password dialog has been added.\n\nRPC changes\n- ------------\n\n### New `rescanblockchain` RPC\n\nA new RPC `rescanblockchain` has been added to manually invoke a blockchain rescan.\nThe RPC supports start and end-height arguments for the rescan, and can be used in a\nmultiwallet environment to rescan the blockchain at runtime.\n\n### New `savemempool` RPC\nA new `savemempool` RPC has been added which allows the current mempool to be saved to\ndisk at any time to avoid it being lost due to crashes / power loss.\n\n### Safe mode disabled by default\n\nSafe mode is now disabled by default and must be manually enabled (with `-disablesafemode=0`) if you wish to use it. Safe mode is a feature that disables a subset of RPC calls - mostly related to the wallet and sending - automatically in case certain problem conditions with the network are detected. However, developers have come to regard these checks as not reliable enough to act on automatically. Even with safe mode disabled, they will still cause warnings in the `warnings` field of the `getneworkinfo` RPC and launch the `-alertnotify` command.\n\n### Renamed script for creating JSON-RPC credentials\n\nThe `share/rpcuser/rpcuser.py` script was renamed to `share/rpcauth/rpcauth.py`. This script can be\nused to create `rpcauth` credentials for a JSON-RPC user.\n\n### Validateaddress improvements\n\nThe `validateaddress` RPC output has been extended with a few new fields, and support for segwit addresses (both P2SH and Bech32). Specifically:\n* A new field `iswitness` is True for P2WPKH and P2WSH addresses (\"bc1...\" addresses), but not for P2SH-wrapped segwit addresses (see below).\n* The existing field `isscript` will now also report True for P2WSH addresses.\n* A new field `embedded` is present for all script addresses where the script is known and matches something that can be interpreted as a known address. This is particularly true for P2SH-P2WPKH and P2SH-P2WSH addresses. The value for `embedded` includes much of the information `validateaddress` would report if invoked directly on the embedded address.\n* For multisig scripts a new `pubkeys` field was added that reports the full public keys involved in the script (if known). This is a replacement for the existing `addresses` field (which reports the same information but encoded as P2PKH addresses), represented in a more useful and less confusing way. The `addresses` field remains present for non-segwit addresses for backward compatibility.\n* For all single-key addresses with known key (even when wrapped in P2SH or P2WSH), the `pubkey` field will be present. In particular, this means that invoking `validateaddress` on the output of `getnewaddress` will always report the `pubkey`, even when the address type is P2SH-P2WPKH.\n\n### Low-level changes\n\n- - The deprecated RPC `getinfo` was removed. It is recommended that the more specific RPCs are used:\n  * `getblockchaininfo`\n  * `getnetworkinfo`\n  * `getwalletinfo`\n  * `getmininginfo`\n- - The wallet RPC `getreceivedbyaddress` will return an error if called with an address not in the wallet.\n- - The wallet RPC `addwitnessaddress` was deprecated and will be removed in version 0.17,\n  set the `address_type` argument of `getnewaddress`, or option `-addresstype=[bech32|p2sh-segwit]` instead.\n- - `dumpwallet` now includes hex-encoded scripts from the wallet in the dumpfile, and\n  `importwallet` now imports these scripts, but corresponding addresses may not be added\n  correctly or a manual rescan may be required to find relevant transactions.\n- - The RPC `getblockchaininfo` now includes an `errors` field.\n- - A new `blockhash` parameter has been added to the `getrawtransaction` RPC which allows for a raw transaction to be fetched from a specific block if known, even without `-txindex` enabled.\n- - The `decoderawtransaction` and `fundrawtransaction` RPCs now have optional `iswitness` parameters to override the\n  heuristic witness checks if necessary.\n- - The `walletpassphrase` timeout is now clamped to 2^30 seconds.\n- - Using addresses with the `createmultisig` RPC is now deprecated, and will be removed in a later version. Public keys should be used instead.\n- - Blockchain rescans now no longer lock the wallet for the entire rescan process, so other RPCs can now be used at the same time (although results of balances / transactions may be incorrect or incomplete until the rescan is complete).\n- - The `logging` RPC has now been made public rather than hidden.\n- - An `initialblockdownload` boolean has been added to the `getblockchaininfo` RPC to indicate whether the node is currently in IBD or not.\n- - `minrelaytxfee` is now included in the output of `getmempoolinfo`\n\nOther changed command-line options\n- ----------------------------------\n- - `-debuglogfile=<file>` can be used to specify an alternative debug logging file.\n- - bitcoin-cli now has an `-stdinrpcpass` option to allow the RPC password to be read from standard input.\n- - The `-usehd` option has been removed.\n- - bitcoin-cli now supports a new `-getinfo` flag which returns an output like that of the now-removed `getinfo` RPC.\n\nTesting changes\n- ----------------\n- - The default regtest JSON-RPC port has been changed to 18443 to avoid conflict with testnet's default of 18332.\n- - Segwit is now always active in regtest mode by default. Thus, if you upgrade a regtest node you will need to either -reindex or use the old rules by adding `vbparams=segwit:0:999999999999` to your regtest bitcoin.conf. Failure to do this will result in a CheckBlockIndex() assertion failure that will look like: Assertion `(pindexFirstNeverProcessed != nullptr) == (pindex->nChainTx == 0)' failed.\n\n0.16.0 change log\n- ------------------\n\n### Block and transaction handling\n- - #10953 `aeed345` Combine scriptPubKey and amount as CTxOut in CScriptCheck (jl2012)\n- - #11309 `93d20a7` Minor cleanups for AcceptToMemoryPool (morcos)\n- - #11418 `38c201f` Add error string for CLEANSTACK script violation (maaku)\n- - #11411 `339da9c` Change SignatureHash input index check to an assert (jimpo)\n- - #11406 `e12522d` Add state message print to AcceptBlock failure message (TheBlueMatt)\n- - #11062 `26fee4f` Mark mempool import fails that were found in mempool as 'already there' (kallewoof)\n- - #11269 `61fb806` CTxMemPoolEntry::UpdateAncestorState: modifySiagOps param type (donaloconnor)\n- - #11747 `e970396` Fix: Open files read only if requested (Elbandi)\n- - #11737 `46d1ebf` Document partial validation in ConnectBlock() (sdaftuar)\n- - #10699 `c090262` Make all script validation flags backward compatible (sipa)\n- - #10279 `214046f` Add a CChainState class to validation.cpp to take another step towards clarifying internal interfaces (TheBlueMatt)\n- - #11824 `d9fdac1` Block ActivateBestChain to empty validationinterface queue (TheBlueMatt)\n- - #12127 `9501dc2` Remove unused mempool index (sdaftuar)\n- - #12118 `44080a9` Sort mempool by min(feerate, ancestor_feerate) (sdaftuar)\n- - #8498 `0e3a411` Minimize the number of times it is checked that no money... (jtimon)\n- - #12368 `3f5012b` Hold mempool.cs for the duration of ATMP (TheBlueMatt)\n- - #12401 `d44cd7e` Reset pblocktree before deleting LevelDB file (Sjors)\n- - #12415 `f893824` Interrupt loading thread after shutdown request (promag)\n\n### P2P protocol and network code\n- - #10596 `6866b49` Add vConnect to CConnman::Options (benma)\n- - #10663 `9d31ed2` Split resolve out of connect (theuni)\n- - #11113 `fef65c4` Ignore getheaders requests for very old side blocks (jimpo)\n- - #11585 `5aeaa9c` addrman: Add missing lock in Clear() (CAddrMan) (practicalswift)\n- - #11524 `5ef3b69` De-duplicate connection eviction logic (tjps)\n- - #11580 `1f4375f` Do not send (potentially) invalid headers in response to getheaders (TheBlueMatt)\n- - #11655 `aca77a4` Assert state.m_chain_sync.m_work_header in ConsiderEviction (practicalswift)\n- - #11744 `3ff6ff5` Add missing locks in net.{cpp,h} (practicalswift)\n- - #11740 `59d3dc8` Implement BIP159 NODE_NETWORK_LIMITED (pruned peers) *signaling only* (jonasschnelli)\n- - #11583 `37ffa16` Do not make it trivial for inbound peers to generate log entries (TheBlueMatt)\n- - #11363 `ba2f195` Split socket create/connect (theuni)\n- - #11917 `bc66765` Add testnet DNS seed:  seed.testnet.bitcoin.sprovoost.nl (Sjors)\n- - #11512 `6e89de5` Use GetDesireableServiceFlags in seeds, dnsseeds, fixing static seed adding (TheBlueMatt)\n- - #12262 `16bac24` Hardcoded seed update (laanwj)\n- - #12270 `9cf6393` Update chainTxData for 0.16 (laanwj)\n- - #12392 `0f61651` Fix ignoring tx data requests when fPauseSend is set on a peer (TheBlueMatt)\n\n### Wallet\n- - #11039 `fc51565` Avoid second mapWallet lookup (promag)\n- - #10952 `2621673` Remove vchDefaultKey and have better first run detection (achow101)\n- - #11007 `fc5c237` Fix potential memory leak when loading a corrupted wallet file (practicalswift)\n- - #10976 `07c92b9` Move some static functions out of wallet.h/cpp (ryanofsky)\n- - #11117 `961901f` Prepare for non-Base58 addresses (sipa)\n- - #10916 `e6ab88a` add missing lock to crypter GetKeys() (benma)\n- - #10767 `791a0e6` Clarify wallet initialization / destruction interface (jnewbery)\n- - #11250 `c22a53c` Bump wallet version to 159900 and remove the `usehd` option (achow101)\n- - #11307 `4f7e37e` Display non-HD error on first run (MarcoFalke)\n- - #11408 `69c7ece` Fix parameter name typo in ErasePurpose walletdb method (PierreRochard)\n- - #11167 `aa624b6` Full BIP173 (Bech32) support (sipa)\n- - #11594 `0ecc630` Improve -disablewallet parameter interaction (promag)\n- - #10368 `77ba4bf` Remove helper conversion operator from wallet (kallewoof)\n- - #11074 `99ec126` Assert that CWallet::SyncMetaData finds oldest transaction (BitonicEelis)\n- - #11272 `e6e3fc3` CKeystore/CCrypter: move relevant implementation out of the header (jonasschnelli)\n- - #10286 `927a1d7` Call wallet notify callbacks in scheduler thread (without cs_main) (TheBlueMatt)\n- - #10600 `4ed8180` Make feebumper class stateless (ryanofsky)\n- - #11466 `d080a7d` Specify custom wallet directory with -walletdir param (MeshCollider)\n- - #11839 `8ab6c0b` Don't attempt mempool entry for wallet transactions on startup (instagibbs)\n- - #11854 `2214954` Split up key and script metadata for better type safety (ryanofsky)\n- - #11870 `ef8ba7d` Remove unnecessary mempool lock in ReacceptWalletTransactions (promag)\n- - #11864 `2ae58d5` Make CWallet::FundTransaction atomic (promag)\n- - #11886 `df71819` Clarify getbalance meaning a tiny bit in response to questions (TheBlueMatt)\n- - #11923 `81c89e9` Remove unused fNoncriticalErrors variable from CWalletDB::FindWalletTx (PierreRochard)\n- - #11726 `604e08c` Cleanups + nit fixes for walletdir PR (MeshCollider)\n- - #11403 `d889c03` Segwit wallet support (sipa)\n- - #11970 `b7450cd` Add test coverage for bitcoin-cli multiwallet calls (ryanofsky)\n- - #11904 `66e3af7` Add a lock to the wallet directory (MeshCollider)\n- - #12101 `c7978be` Clamp walletpassphrase timeout to 2^30 seconds and check its bounds (achow101)\n- - #12210 `17180fa` Deprecate addwitnessaddress (laanwj)\n- - #12220 `f4c942e` Error if relative -walletdir is specified (ryanofsky)\n- - #11281 `8470e64` Avoid permanent cs_main/cs_wallet lock during RescanFromTime (jonasschnelli)\n- - #12119 `9594139` Use P2WPKH change output if any destination is P2WPKH or P2WSH (Sjors)\n- - #12213 `eadb2da` Add address type option to addmultisigaddress (promag)\n- - #12276 `7936446` Remove duplicate mapWallet lookups (promag)\n\n### RPC and other APIs\n- - #11008 `3841aaf` Enable disablesafemode by default (gmaxwell)\n- - #11050 `7ed57d3` Avoid treating null RPC arguments different from missing arguments (ryanofsky)\n- - #10997 `affe927` Add option -stdinrpcpass to bitcoin-cli to allow RPC password to be read from standard input (jharvell)\n- - #11179 `e0e3cbb` Push down safe mode checks (laanwj)\n- - #11203 `d745b4c` add wtxid to mempool entry output (sdaftuar)\n- - #11099 `bc561b4` Add savemempool RPC (greenaddress)\n- - #10838 `66a5b41` (finally) remove getinfo (TheBlueMatt)\n- - #10753 `7fcd61b` test: Check RPC argument mapping (laanwj)\n- - #11288 `0f8e095` More user-friendly error message when partially signing (MeshCollider)\n- - #11031 `ef8340d` deprecate estimatefee (jnewbery)\n- - #10858 `9a8e916` Add \"errors\" field to getblockchaininfo and unify \"errors\" field in get*info RPCs (achow101)\n- - #11021 `90926db` Fix getchaintxstats() (AkioNak)\n- - #11367 `3a93270` getblockchaininfo: Add disk_size, prune_target_size (esotericnonsense)\n- - #11006 `a1d78b5` Improve shutdown process (promag)\n- - #11529 `ff92fbf` Avoid slow transaction search with txindex enabled (promag)\n- - #11618 `87d90ef` Lock cs_main in blockToJSON/blockheaderToJSON (practicalswift)\n- - #11626 `998c304` Make `logging` RPC public (laanwj)\n- - #11258 `033c786` Add initialblockdownload to getblockchaininfo (jnewbery)\n- - #11087 `99bc0b4` Diagnose unsuitable outputs in lockunspent() (BitonicEelis)\n- - #11710 `9388639` cli: Reject arguments to -getinfo (laanwj)\n- - #11738 `d4267a3` Fix sendrawtransaction hang when sending a tx already in mempool (TheBlueMatt)\n- - #11753 `32c9b57` clarify abortrescan rpc use (instagibbs)\n- - #11191 `ef14f2e` Improve help text and behavior of RPC-logging (AkioNak)\n- - #10874 `9e38d35` getblockchaininfo: Loop through the bip9 soft fork deployments instead of hard coding (achow101)\n- - #10275 `497d0e0` Allow fetching tx directly from specified block in getrawtransaction (kallewoof)\n- - #11178 `fee0370` Add iswitness parameter to decode- and fundrawtransaction RPCs (MeshCollider)\n- - #11667 `711d16c` Add scripts to dumpwallet RPC (MeshCollider)\n- - #11475 `9bad8d6` mempoolinfo should take ::minRelayTxFee into account (mess110)\n- - #12001 `a9a49e6` Adding ::minRelayTxFee amount to getmempoolinfo and updating help (jeffrade)\n- - #12198 `adce1de` Add deprecation error for `getinfo` (laanwj)\n- - #11415 `69ec021` Disallow using addresses in createmultisig (achow101)\n- - #12278 `288deac` Add special error for genesis coinbase to getrawtransaction (MeshCollider)\n- - #11362 `c6223b3` Remove nBlockMaxSize from miner opt struct as it is no longer used (gmaxwell)\n- - #10825 `28485c7` Set regtest JSON-RPC port to 18443 to avoid conflict with testnet 18332 (fametrano)\n- - #11303 `e542728` Fix estimatesmartfee rounding display issue (TheBlueMatt)\n- - #7061 `8c2de82` Add RPC call \"rescanblockchain <startheight> <stopheight>\" (jonasschnelli)\n- - #11055 `95e14dc` RPC getreceivedbyaddress should return error if called with address not owned by the wallet (jnewbery)\n- - #12366 `93de37a` http: Join worker threads before deleting work queue (laanwj)\n- - #12315 `758a41e` Bech32 addresses in dumpwallet (fivepiece)\n- - #12427 `3762ac1` Make signrawtransaction accept P2SH-P2WSH redeemscripts (sipa)\n\n### GUI\n- - #10964 `64e66bb` Pass SendCoinsRecipient (208 bytes) by reference (practicalswift)\n- - #11169 `5b8af7b` Make tabs toolbar no longer have a context menu (achow101)\n- - #10911 `9c8f365` Fix typo and access key in optionsdialog.ui (keystrike)\n- - #10770 `ea729d5` Drop upgrade-cancel callback registration for a generic \"cancelable\" (TheBlueMatt)\n- - #11156 `a3624dd` Fix memory leaks in qt/guiutil.cpp (danra)\n- - #11268 `31e72b2` [macOS] remove Growl support, remove unused code (jonasschnelli)\n- - #11193 `c5c77bd` Terminate string *pszExePath after readlink and without using memset (practicalswift)\n- - #11508 `ffa5159` Fix crash via division by zero assertion (jonasschnelli)\n- - #11499 `6157e8c` Add upload and download info to the peerlist (debug menu) (aarongolliver)\n- - #11480 `ffc0b11` Add toggle for unblinding password fields (tjps)\n- - #11316 `22cdf93` Add use available balance in send coins dialog (CryptAxe, promag)\n- - #3716 `13e352d` Receive: Remove option to reuse a previous address (luke-jr)\n- - #11690 `f0c1f8a` Fix the StartupWMClass for bitoin-qt, so gnome-shell can recognize it (eklitzke)\n- - #10920 `f6f8d54` Fix potential memory leak in newPossibleKey(ChangeCWallet *wallet) (practicalswift)\n- - #11698 `7293d06` RPC-Console nested commands documentation  (lmlsna)\n- - #11395 `38d31f9` Enable searching by transaction id (luke-jr)\n- - #11556 `91eeaa0` Improved copy for RBF checkbox and tooltip (Sjors)\n- - #11809 `80f9dad` Fix proxy setting options dialog crash (laanwj)\n- - #11616 `8585bb8` Update ban-state in case of dirty-state during periodic sweep (jonasschnelli)\n- - #11605 `f19ca12` Enable RBF by default in QT (Sjors)\n- - #12074 `a1136f0` Optimizes boolean expression model && model->haveWatchOnly() (251Labs)\n- - #12035 `eeb6d52` Change \u00b5BTC to bits (jb55)\n- - #12092 `fd4ca17` Replaces numbered place marker %2 with %1 (251Labs)\n- - #12173 `bbc91b7` Use flexible font size for QRCode image address (jonasschnelli)\n- - #12211 `10d10d7` Avoid potential null dereference in ReceiveCoinsDialog constructor (ryanofsky)\n- - #12261 `f359afc` Bump BLOCK_CHAIN_SIZE to 200GB (laanwj)\n- - #11991 `062c8b6` Receive: checkbox for bech32 address (Sjors)\n- - #11644 `045a809` Fix qt build broken by 5a5e4e9 (TheBlueMatt)\n- - #11448 `d473e6d` reset addrProxy/addrSeparateProxyTor if colon char missing (mess110)\n- - #12377 `604f289` qt: Poll ShutdownTimer after init is done (MarcoFalke)\n- - #12374 `daaae36` qt: Make sure splash screen is freed on AppInitMain fail (laanwj)\n- - #12349 `ad10b90` shutdown: fix crash on shutdown with reindex-chainstate (theuni)\n\n### Build system\n- - #10923 `2c9f5ec` travis: Build with --enable-werror under OS X (practicalswift)\n- - #11176 `df8c722` build: Rename --enable-experimental-asm to --enable-asm and enable by default (laanwj)\n- - #11286 `11dacc6` [depends] Don't build libevent sample code (fanquake)\n- - #7142 `801dd40` Travis: Test build against system libs (& Qt4) (luke-jr)\n- - #11380 `390771b` Remove outdated share/certs/ directory (MeshCollider)\n- - #11391 `7632310` Remove lxcbr0 lines from gitian-build.sh (MeshCollider)\n- - #11435 `167cef8` build: Make \"make clean\" remove all files created when running \"make check\" (practicalswift)\n- - #11460 `e022463` [depends] mac_alias 2.0.6, ds_store 1.1.2 (fanquake)\n- - #11541 `bb9ab0f` Build: Fix Automake warnings when running autogen.sh (fanquake)\n- - #11611 `0e70791` [build] Don't fail when passed --disable-lcov and lcov isn't available (fanquake)\n- - #11651 `3c098a8` refactor: Make all #includes relative to project root (laanwj, MeshCollider, ryanofsky)\n- - #11621 `1f7695b` [build] Add temp_bitcoin_locale_qrc to CLEAN_QT to fix make distcheck (fanquake)\n- - #11755 `84fa645` [Docs] Bump minimum required version of GCC to 4.8 (fanquake)\n- - #9254 `6d3dc52` [depends] ZeroMQ 4.2.2 (fanquake)\n- - #11842 `3c8f0a3` [build] Add missing stuff to clean-local (kallewoof)\n- - #11936 `483bb67` [build] Warn that only libconsensus can be built without Boost (fanquake)\n- - #11945 `7a11ba7` Improve BSD compatibility of contrib/install_db4.sh (laanwj)\n- - #11981 `180a255` Fix gitian build after libzmq bump (theuni)\n- - #11903 `8f68fd2` [trivial] Add required package dependencies for depends cross compilation (jonasschnelli)\n- - #12168 `45cf8a0`  #include sys/fcntl.h to just fcntl.h (without sys/) (jsarenik)\n- - #12095 `3fa1ab4` Use BDB_LIBS/CFLAGS and pass --disable-replication (fanquake)\n- - #11711 `6378e5c` bitcoin_qt.m4: Minor fixes and clean-ups (fanquake)\n- - #11989 `90d4104` .gitignore: add QT Creator artifacts (Sjors)\n- - #11577 `c0ae864` Fix warnings (-Wsign-compare) when building with DEBUG_ADDRMAN (practicalswift)\n\n### Tests and QA\n- - #11024 `3e55f13` Remove OldSetKeyFromPassphrase/OldEncrypt/OldDecrypt (practicalswift)\n- - #10679 `31b2612` Document the non-DER-conformance of one test in tx_valid.json (schildbach)\n- - #11160 `ede386c` Improve versionbits_computeblockversion test code consistency (danra)\n- - #10303 `f088a1b` Include ms/blk stats in Connect* benchmarks (kallewoof)\n- - #10777 `d81dccf` Avoid redundant assignments. Remove unused variables (practicalswift)\n- - #11260 `52f8877` travis: Assert default datadir isn't created, Run scripted diff only once (MarcoFalke)\n- - #11271 `638e6c5` travis: filter out pyenv (theuni)\n- - #11285 `3255d63` Add -usehd to excluded args in check-doc.py (MeshCollider)\n- - #11297 `16e4184` Make sure ~/.bitcoin doesn't exist before build (MeshCollider)\n- - #11311 `cce94c5` travis: Revert default datadir check (MarcoFalke)\n- - #11300 `f4ed44a` Add a lint check for trailing whitespace (MeshCollider)\n- - #11323 `4ce2f3d` mininode: add an optimistic write and disable nagle (theuni)\n- - #11370 `2d85899` Add getblockchaininfo functional test (promag)\n- - #11365 `f199b8a` Add Qt GUI tests to Overview and ReceiveCoin Page (anditto)\n- - #11293 `dbc4ae0` Deduplicate CMerkleBlock construction code, add test coverage (jamesob)\n- - #10440 `9e8ef9d` Add libFuzzer support (practicalswift)\n- - #10941 `364da2c` Add blocknotify and walletnotify functional tests (promag)\n- - #11420 `8928093` Bump univalue subtree and fix json formatting in tests (MarcoFalke)\n- - #10099 `424be03` Slightly Improve Unit Tests for Checkqueue (JeremyRubin)\n- - #11513 `14b860b` A few Python3 tidy ups (jnewbery)\n- - #11486 `2ca518d` Add uacomment tests (mess110)\n- - #11452 `02ac8c8` Improve ZMQ functional test (promag)\n- - #10409 `b5545d8` Add fuzz testing for BlockTransactions and BlockTransactionsRequest (practicalswift)\n- - #11389 `dd56166` Support having segwit always active in regtest (sipa, ajtowns, jnewbery)\n- - #11562 `5776582` bench: use std::chrono rather than gettimeofday (theuni)\n- - #11182 `f7388e9` Add P2P interface to TestNode (jnewbery)\n- - #11552 `b5f9f02` Improve wallet-accounts test (ryanofsky)\n- - #11638 `5e3f5e4` Dead mininode code (jnewbery)\n- - #11646 `fe503e1` Require a steady clock for bench with at least micro precision (TheBlueMatt)\n- - #11468 `76b3349` Make comp test framework more debuggable (jnewbery)\n- - #11623 `ee92243` Add missing locks to tests (practicalswift)\n- - #11035 `927e528` [contrib] Add Valgrind suppressions file (practicalswift)\n- - #11641 `7adeea3` Only allow disconnecting all NodeConns (MarcoFalke)\n- - #11677 `3bdf242` Remove unused NodeConn members (MarcoFalke)\n- - #11699 `66d46c7` [travis-ci] Only run linters on Pull Requests (jnewbery)\n- - #11654 `084f52f` Initialize recently introduced non-static class member lastCycles to zero in constructor (practicalswift)\n- - #11648 `ccc70a2` Add messages.py (jnewbery)\n- - #11713 `49667a7` Fix for mismatched extern definition in wallet tests (sipsorcery)\n- - #11707 `0d89fa0` Fix sendheaders (jnewbery)\n- - #11718 `9cdd2bc` Move pwalletMain to wallet test fixture (laanwj)\n- - #11714 `901ba3e` Test that mempool rejects coinbase transactions (jamesob)\n- - #11743 `3d6ad40` Add multiwallet prefix test (MarcoFalke)\n- - #11683 `a892218` Remove unused mininode functions {ser,deser}_int_vector(...). Remove unused imports (practicalswift)\n- - #11712 `9f2c2db` Split NodeConn from NodeConnCB (jnewbery)\n- - #11791 `13e31dd` Rename NodeConn and NodeConnCB (jnewbery)\n- - #11835 `f60b4ad` Add Travis check for unused Python imports (practicalswift)\n- - #11849 `ad1820c` Assert that only one NetworkThread exists (jnewbery)\n- - #11877 `d4991c0` Improve createrawtransaction functional tests (promag)\n- - #11220 `2971fd0` Check specific validation error in miner tests (Sjors)\n- - #11947 `797441e` Fix rawtransactions test (laanwj)\n- - #11946 `8049241` Remove unused variable (firstAddrnServices) (practicalswift)\n- - #11867 `18a1bba` Improve node network test (jnewbery)\n- - #11883 `cfd99dd` Add configuration file/argument testing (MeshCollider)\n- - #11879 `d4e404a` Remove redundant univalue_tests.cpp (jnewbery)\n- - #11748 `20166f8` Adding unit tests for GetDifficulty in blockchain.cpp (merehap)\n- - #11517 `5180a86` Improve benchmark precision (martinus)\n- - #11291 `a332a7d` Fix string concatenation to os.path.join and add exception case (dongsam)\n- - #11965 `d38d1a3` Note on test order in test_runner (MarcoFalke)\n- - #11997 `ddff344` util_tests.cpp: actually check ignored args (ajtowns)\n- - #12079 `45173fa` Improve prioritisetransaction test coverage (promag)\n- - #12150 `92a810d` Fix ListCoins test failure due to unset g_address_type, g_change_type (ryanofsky)\n- - #12133 `1d2eaba` Fix rare failure in p2p-segwit.py (sdaftuar)\n- - #12082 `0910cbe` Adding test case for SINGLE|ANYONECANPAY hash type in tx_valid.json (Christewart)\n- - #11796 `4db16ec` Functional test naming convention (ajtowns)\n- - #12227 `b987ca4` test_runner: Readable output if create_cache.py fails (ryanofsky)\n- - #12089 `126000b` Make TestNodeCLI command optional in send_cli (MarcoFalke)\n- - #11774 `6970b30` Rename functional tests (ajtowns)\n- - #12264 `598a9c4` Fix versionbits warning test (jnewbery)\n- - #12217 `1213be6` Add missing syncwithvalidationinterfacequeue to tests (MarcoFalke)\n- - #12292 `eebe458` Fix names of excluded extended tests for travis (ajtowns)\n- - #11789 `60d739e` [travis-ci] Combine logs on failure (jnewbery)\n- - #11838 `3e50024` Add getrawtransaction in_active_chain=False test (MarcoFalke)\n- - #12206 `898f560` Sync with validationinterface queue in sync_mempools (MarcoFalke)\n- - #12424 `ff44101` Fix rescan test failure due to unset g_address_type, g_change_type (ryanofsky)\n- - #12388 `e2431d1` travis: Full clone for git subtree check (MarcoFalke)\n\n### Documentation\n- - #10680 `6366941` Fix inconsistencies and grammar in various files (MeshCollider)\n- - #11011 `7db65c3` Add a comment on the use of prevector in script (gmaxwell)\n- - #10878 `c58128f` Fix Markdown formatting issues in init.md (dongcarl)\n- - #11066 `9e00a62` Document the preference of nullptr over NULL or (void*)0 (practicalswift)\n- - #11094 `271e40a` Hash in ZMQ hash is raw bytes, not hex (runn1ng)\n- - #11026 `ea3ac59` Bugfix: Use testnet RequireStandard for -acceptnonstdtxn default (luke-jr)\n- - #11058 `4b65fa5` Comments: More comments on functions/globals in standard.h (jimpo)\n- - #11112 `3f726c9` [developer-notes] By default, declare single-argument constructors \"explicit\" (practicalswift)\n- - #11155 `a084767` Trivial: Documentation fixes for CVectorWriter ctors (danra)\n- - #11136 `108222b` Docs: Add python3 to list of dependencies on some platforms (danra)\n- - #11216 `81f8c03` Update hmac_sha256.h (utsavgupta)\n- - #11236 `ba05971` Add note on translations to CONTRIBUTING.md (MeshCollider)\n- - #11173 `4eb1f39` RPC: Fix currency unit string in the help text (AkioNak)\n- - #11135 `21e2f2f` Update developer notes with RPC response guidelines (promag)\n- - #11219 `bcc8a62` explain how to recompile a modified unit test (Sjors)\n- - #10779 `f656147` Create dependencies.md (flack)\n- - #10682 `2a56baf` Move the AreInputsStandard documentation next to its implementation (esneider)\n- - #11276 `ee50c9e` Update CONTRIBUTING.md to reduce unnecessary review workload (jonasschnelli)\n- - #11264 `b148803` Fix broken Markdown table in dependencies.md (practicalswift)\n- - #10691 `ce82985` Properly comment about shutdown process in init.cpp file (wraith7)\n- - #11330 `ae233c4` Fix comments for DEFAULT_WHITELIST[FORCE]RELAY (danra)\n- - #11340 `d6d2c85` Fix validation comments (danra)\n- - #11305 `2847480` Update release notes and manpages for 0.16 (MarcoFalke)\n- - #11132 `551d7bf` Document assumptions that are being made to avoid NULL pointer dereferences (practicalswift)\n- - #11390 `12ed800` Document scripted-diff (jnewbery)\n- - #11392 `a3b4c59` Fix stale link in gitian-building.md (shooterman)\n- - #11401 `4202273` Move gitian building to external repo (MarcoFalke)\n- - #11414 `bbc901d` Remove partial gitian build instructions from descriptors dir (fanquake)\n- - #11571 `c95832d` Fixed a couple small grammatical errors (BitsInMyBlood)\n- - #11624 `f9b74ef` Change formatting for sequence of steps (vivganes)\n- - #11597 `6f01dcf` Fix error messages in CFeeBumper (kallewoof)\n- - #11438 `7fbf3c6` Updated Windows build doc for WSL/Xenial workaround (sipsorcery)\n- - #11663 `41aa9c4` Add getreceivedbyaddress release notes (MarcoFalke)\n- - #11533 `cbb54e7` Update WSL installation notes for Fall Creators update (Thoragh)\n- - #11680 `4db82b7` Add instructions for lcov report generation (jamesob)\n- - #11686 `54aedc0` Make ISSUE_TEMPLATE a bit shorter, mention hardware tests (TheBlueMatt)\n- - #11704 `ea68190` Windows build doc update (sipsorcery)\n- - #11706 `5197100` Make default issue text all comments to make issues more readable (TheBlueMatt)\n- - #11140 `1429132` Improve #endif comments (danra)\n- - #11729 `7a43fbb` links to code style guides (Sjors)\n- - #11793 `8879d50` Bump OS X version to 10.13 (Varunram)\n- - #11783 `16fff80` Fix shutdown in case of errors during initialization (laanwj)\n- - #11804 `00d25e9` Fixed outdated link with archive.is (TimothyShimmin)\n- - #11960 `4307062` Fix link to installation script (laudaa)\n- - #12027 `63a4dc1` Remove boost --c++ flag from osx build instructions (fernandezpablo85)\n- - #12062 `5961b23` Increment MIT Licence copyright header year on files modified in 2017 (akx20000a)\n- - #12063 `36a5a44` Update license year range to 2018 (akx20000a)\n- - #12093 `5691028` Fix incorrect Markdown link (practicalswift)\n- - #12143 `b0d626d` Fix link for BIP159 pull request (azuchi)\n- - #12112 `3c62868` Remove the ending slashes from RPC URI format (jackycjh)\n- - #12166 `e839d65` Clarify -walletdir usage (jnewbery)\n- - #12241 `b030133` Fix incorrect link in /test/ README.md (fanquake)\n- - #12187 `b5e4b9b` Updating benchmarkmarking.md with an updated sample output (jeffrade)\n- - #12294 `7cf1aea` Create NetBSD build instructions and fix compilation (fanquake)\n- - #12251 `cc5870a` initwallet: Do not translate highly technical addresstype help (MarcoFalke)\n- - #11984 `efae366` Update OpenBSD build instructions for 6.2 (cont'd) (laanwj)\n- - #12293 `9d9c418` Mention that HD is enabled if hdmasterkeyid is present in getwalletinfo RPC help (fanquake)\n- - #12077 `c04cb48` Correct `sendmany` curl example (251Labs)\n- - #10677 `b3ecb7b` Document that addmultisigaddress is intended for non-watchonly addresses (instagibbs)\n- - #12177 `cad504b` Fix address_type help text of getnewaddress and getrawchangeaddress (mruddy)\n\n### Refactoring\n- - #9964 `b6a4891` Add const to methods that do not modify the object for which it is called (practicalswift)\n- - #10965 `655970d` Replace deprecated throw() with noexcept specifier (C++11) (practicalswift)\n- - #10645 `c484ec6` Use nullptr (C++11) instead of zero (0) as the null pointer constant (practicalswift)\n- - #10901 `22e301a` Fix constness of ArgsManager methods (promag)\n- - #10969 `4afb5aa` Declare single-argument (non-converting) constructors \"explicit\" (practicalswift)\n- - #11071 `dbf6bd6` Use static_assert(\u2026, \u2026) (C++11) instead of assert(\u2026) where appropriate (practicalswift)\n- - #10809 `c559884` optim: mark a few classes final (theuni)\n- - #10843 `2ab7c63` Add attribute [[noreturn]] (C++11) to functions that will not return (practicalswift)\n- - #11151 `7fd49d0` Fix header guards using reserved identifiers (danra)\n- - #11138 `2982511` Compat: Simplify bswap_16 implementation (danra)\n- - #11161 `745bbdc` Remove redundant explicitly defined copy ctors (danra)\n- - #11144 `cee4fe1` Move local include to before system includes (danra)\n- - #10781 `60dd9cc` Python cleanups (practicalswift)\n- - #10701 `50fae68` Remove the virtual specifier for functions with the override specifier (practicalswift)\n- - #11164 `38a54a5` Fix boost headers included as user instead of system headers (danra)\n- - #11143 `3aa60b7` Fix include path for bitcoin-config.h (danra)\n- - #8330 `59e1789` Structure Packing Optimizations in C{,Mutable}Transaction (JeremyRubin)\n- - #10845 `39ae413` Remove unreachable code (practicalswift)\n- - #11238 `6acdb1f` Add assertions before potential null deferences (MeshCollider)\n- - #11259 `089b742` Remove duplicate destination decoding (promag)\n- - #11232 `2f0d3e6` Ensure that data types are consistent (jjz)\n- - #10793 `efb4383` Changing &var[0] to var.data() (MeshCollider)\n- - #11196 `e278f86` Switch memory_cleanse implementation to BoringSSL's to ensure memory clearing even with -lto (maaku)\n- - #10888 `9821274` range-based loops and const qualifications in net.cpp (benma)\n- - #11351 `6c4fecf` Refactor: Modernize disallowed copy constructors/assignment (danra)\n- - #11385 `94c9015` Remove some unused functions and methods (sipa)\n- - #11301 `8776787` add m_added_nodes to connman options (benma)\n- - #11432 `058c0f9` Remove unused fTry from push_lock (promag)\n- - #11107 `e93fff1` Fix races in AppInitMain and others with lock and atomic bools (MeshCollider)\n- - #9572 `17f2ace` Skip witness sighash cache for non-segwit transactions (jl2012)\n- - #10961 `da0478e` Improve readability of DecodeBase58Check(...) (practicalswift)\n- - #11133 `a865b38` Document assumptions that are being made to avoid division by zero (practicalswift)\n- - #11073 `3bb77eb` Remove dead store in ecdsa_signature_parse_der_lax (BitonicEelis)\n- - #10898 `470c730` Fix invalid checks (NULL checks after dereference, redundant checks, etc.) (practicalswift)\n- - #11495 `50d72b3` [trivial] Make namespace explicit for is_regular_file (jnewbery)\n- - #11511 `db2f83e` [Init] Remove redundant exit(EXIT_FAILURE) instances and replace with return false (donaloconnor)\n- - #10866 `ef8a634` Fix -Wthread-safety-analysis warnings. Compile with -Wthread-safety-analysis if available (practicalswift)\n- - #11221 `0dec4cc` Refactor: simpler read (gnuser)\n- - #10696 `ef3758d` Remove redundant nullptr checks before deallocation (practicalswift)\n- - #11043 `5e9be16` Use std::unique_ptr (C++11) where possible (practicalswift)\n- - #11353 `05a7619` Small refactor of CCoinsViewCache::BatchWrite() (danra)\n- - #10749 `2adbddb` Use compile-time constants instead of unnamed enumerations (remove \"enum hack\") (practicalswift)\n- - #11603 `a933cb1` Move RPC registration out of AppInitParameterInteraction (ryanofsky)\n- - #11722 `26efc22` Switched sync.{cpp,h} to std threading primitives (tjps)\n- - #10493 `fbce66a` Use range-based for loops (C++11) when looping over map elements (practicalswift)\n- - #11337 `0d7e0a3` Fix code constness in CBlockIndex::GetAncestor() overloads (danra)\n- - #11516 `0e722e8` crypto: Add test cases covering the relevant HMAC-SHA{256,512} key length boundaries (practicalswift)\n- - #10574 `5d132e8` Remove includes in .cpp files for things the corresponding .h file already included (practicalswift)\n- - #11884 `66479c0` Remove unused include in hash.cpp (kallewoof)\n- - #10839 `c66adb2` Don't use pass by reference to const for cheaply-copied types (bool, char, etc.) (practicalswift)\n- - #10657 `79399c8` Utils: Improvements to ECDSA key-handling code (str4d)\n- - #12250 `e37ca2b` Make CKey::Load references const (ryanofsky)\n- - #12108 `9220426` Remove unused fQuit var from checkqueue.h (donaloconnor)\n- - #12159 `f3c7062` Use the character based overload for std::string::find (kekimusmaximus)\n- - #12266 `3448907` Move scheduler/threadGroup into common-init instead of per-app (TheBlueMatt)\n\n### Miscellaneous\n- - #11246 `777519b` github-merge: Coalesce git fetches (laanwj)\n- - #10871 `c9a4aa8` Handle getinfo in bitcoin-cli w/ -getinfo (revival of #8843) (achow101)\n- - #11419 `093074b` Utils: Fix launchctl not being able to stop bitcoind (OmeGak)\n- - #11394 `6e4e98e` Perform a weaker subtree check in Travis (sipa)\n- - #11702 `4122112` [build] Add a script for installing db4 (jamesob)\n- - #11794 `dd49862` Prefix leveldb debug logging (laanwj)\n- - #11781 `24df9af` Add `-debuglogfile` option (laanwj)\n- - #10773 `c17f11f` Shell script cleanups (practicalswift)\n- - #11829 `7630a1f` Test datadir specified in conf file exists (MeshCollider)\n- - #11836 `d44535d` Rename rpcuser.py to rpcauth.py (hkjn)\n- - #11831 `d48ab83` Always return true if AppInitMain got to the end (TheBlueMatt)\n- - #11943 `1808660` contrib: fix typo in install_db4.sh help message (laanwj)\n- - #12075 `c991b30` [scripts] Add missing univalue file to copyright_header.py (fanquake)\n- - #12197 `000ac4f` Log debug build status and warn when running benchmarks (laanwj)\n- - #10672 `6ab0e4c` Avoid division by zero in the case of a corrupt estimates file (practicalswift)\n- - #11273 `cdd6bbf` Ignore old format estimation file (Xekyo)\n- - #11951 `1fb34e0` Remove dead feeest-file read code for old versions (TheBlueMatt)\n- - #11421 `9ccafb1` Merge current secp256k1 subtree (MarcoFalke)\n- - #11573 `2631d55` [Util] Update tinyformat.h (fanquake)\n- - #10529 `331352f` Improve bitcoind systemd service file (Flowdalic)\n- - #11620 `70fec9e` [build] .gitignore: add background.tiff (Sjors)\n- - #11558 `68e021e` Minimal code changes to allow msvc compilation (sipsorcery)\n- - #11284 `10bee0d` Fix invalid memory access in CScript::operator+= (guidovranken, ajtowns)\n- - #10939 `a1f7f18` [init] Check non-emptiness of -blocknotify command prior to executing (practicalswift)\n- - #11467 `937613d` Fix typos. Use nullptr instead of NULL (practicalswift)\n- - #11834 `5bea05b` [verify-commits] Fix gpg.sh's echoing for commits with '\\n' (TheBlueMatt)\n- - #11830 `a13e443` rpcuser.py: Use 'python' not 'python2' (hkjn)\n- - #12194 `7abb0f0` Add change type option to fundrawtransaction (promag)\n- - #12269 `2ae7cf8` Update defaultAssumeValid to block 506067 (gmaxwell)\n- - #11952 `9ab9963` univalue: Bump subtree (MarcoFalke)\n- - #12367 `09fc859` Fix two fast-shutdown bugs (TheBlueMatt)\n- - #12422 `4d54e7a` util: Make LockDirectory thread-safe, consistent, and fix OpenBSD 6.2 build (laanwj)\n\nCredits\n=======\n\nThanks to everyone who directly contributed to this release:\n\n- - 251\n- - Aaron Clauson\n- - Aaron Golliver\n- - aaron-hanson\n- - Adam Langley\n- - Akio Nakamura\n- - Akira Takizawa\n- - Alejandro Avil\u00e9s\n- - Alex Morcos\n- - Alin Rus\n- - Anditto Heristyo\n- - Andras Elso\n- - Andreas Schildbach\n- - Andrew Chow\n- - Anthony Towns\n- - azuchi\n- - Carl Dong\n- - Chris Moore\n- - Chris Stewart\n- - Christian Gentry\n- - Cory Fields\n- - Cristian Mircea Messel\n- - CryptAxe\n- - Dan Raviv\n- - Daniel Edgecumbe\n- - danra\n- - david60\n- - Donal O'Connor\n- - dongsamb\n- - Dusty Williams\n- - Eelis\n- - esneider\n- - Evan Klitzke\n- - fanquake\n- - Ferdinando M. Ametrano\n- - fivepiece\n- - flack\n- - Florian Schmaus\n- - gnuser\n- - Gregory Maxwell\n- - Gregory Sanders\n- - Henrik Jonsson\n- - Jack Grigg\n- - Jacky C\n- - James Evans\n- - James O'Beirne\n- - Jan Sarenik\n- - Jeff Rade\n- - Jeremiah Buddenhagen\n- - Jeremy Rubin\n- - Jim Posen\n- - jjz\n- - Joe Harvell\n- - Johannes Kanig\n- - John Newbery\n- - Johnson Lau\n- - Jonas Nick\n- - Jonas Schnelli\n- - Jo\u00e3o Barbosa\n- - Jorge Tim\u00f3n\n- - Karel B\u00edlek\n- - Karl-Johan Alm\n- - klemens\n- - Kyuntae Ethan Kim\n- - laudaa\n- - Lawrence Nahum\n- - Lucas Betschart\n- - Luke Dashjr\n- - Luke Mlsna\n- - MarcoFalke\n- - Mark Friedenbach\n- - Marko Bencun\n- - Martin Ankerl\n- - Matt Corallo\n- - mruddy\n- - Murch\n- - NicolasDorier\n- - Pablo Fernandez\n- - Paul Berg\n- - Pedro Branco\n- - Pierre Rochard\n- - Pieter Wuille\n- - practicalswift\n- - Randolf Richardson\n- - Russell Yanofsky\n- - Samuel Dobson\n- - Sean Erle Johnson\n- - Shooter\n- - Sjors Provoost\n- - Suhas Daftuar\n- - Thomas Snider\n- - Thoragh\n- - Tim Shimmin\n- - Tomas van der Wansem\n- - Utsav Gupta\n- - Varunram Ganesh\n- - Vivek Ganesan\n- - Werner Lemberg\n- - William Casarin\n- - Willy Ko\n- - Wladimir J. van der Laan\n\nAs well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQEcBAEBCgAGBQJak7zUAAoJEB5K7WKYbNJdBbgH/3eTGVHCXl+qRKDTz2w5avNJ\noqjCuWZNUmMLeAKUDKy30kYe9ORwuCSkP9pPeqNcq9LsVkaIQ6oGqbNIkJBrDUaz\n0jy69sVHoixm5B6gZzT2ScTLa2mnljuI6lWseXxsww0kMGwG1zIqahF4UEzhG3Gm\nwQxcjzwq+rG/Ph74D0usH0q61FnbtcAo6hJCbUiqVFxFeQDA88yYeQoCoTT9IaHZ\nm2HaDhVLtZUyRdUlYM0U8gPwYsXbQ3e714/xFT8QQQHTkaekwzHaoAAHYyBMzUe4\nn5UyVAZ0u3dX2jhsQlSsPyXofI18Y1c9hTdj27D217FPMUJ3PR+MSqPys9d6JV4=\n=aeRF\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.16.0 released",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 48127
        }
    },
    {
        "title": "[bitcoin-dev] Simple lock/unlock mechanism",
        "thread_messages": [
            {
                "author": "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3",
                "date": "2018-02-28T03:47:29",
                "message_text_only": "With the recent trend of physically robbing people for bitcoin (or\nother cryptocurrencies), I thought it would be beneficial to introduce\na standard for locking up a portion of your bitcoin in a simple\n'gotta-wait-awhile' system.\n\nThe idea is to simply create a transaction spending a set of UTXOs to\na P2SH address with an OP_CSV attached to it, and then throw away the\nprivate keys.\n\nTo spend the bitcoin, you would have to broadcast the transaction and\nwait the given amount of time, then use the new txout.\n\nThere are several ways to shoot yourself in the foot trying to do this\nmanually, but e.g. Bitcoin Core could handle this in a fairly\nstraightforward manner by introducing two new commands, which I call\nfreeze and unfreeze:\n\nbitcoin-cli freeze [amount OR array of txid+vout objects] [days, default 1]\n\nE.g. bitcoin-cli freeze 10 5\nE.g. bitcoin-cli freeze [\"abc123:1\", \"def346:0\"] 3\n\nThe unfreeze command would by default list all freezes:\n\nbitcoin-cli unfreeze\ntxid         days     status\nbcd123   5           frozen\ndca999   3           frozen\n\nincluding the txid would broadcast the unfreeze and status would\nbecome 'thawing' until the amount becomes available:\n\nbitcoin-cli unfreeze bcd123\n\nbitcoin-cli unfreeze\ntxid         days     status\nbcd123   5           thawing\ndca999   3           frozen\n\nThe benefit of this is that it becomes physically impossible for you\nto spend the coins until you thaw them, and if this becomes standard\nenough, it should disincentivize potential robbers as it would be\nexpected that you keep most of your assets locked up. They could of\ncourse hold you hostage until the period is over, which may be worse,\nbut I think that kind of operation would be substantially more\ndifficult than a simply rob-and-run.\n\nThe drawback is that you have to broadcast a transaction in order to\nspend the content, and you cannot bump the fee so the transaction\ncould get stuck in a high-fee situation.\n\n-Kalle."
            },
            {
                "author": "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3",
                "date": "2018-02-28T04:34:18",
                "message_text_only": "A few p.s.'es:\n\n1. Graftroot probably breaks this (someone could just sign the\ntime-locked output with a script that has no time-lock).\n\n2. Address reuse of discarded privkeys would be a problem. A way to\nalleviate might be that freezing includes a send to a new address and\nthe privkeys for that new one are discarded instead. One extra\ntransaction, but reduces the risk of accidentally throwing away\n`donations4mybook` vanity keys.\n\n-Kalle.\n\nOn Wed, Feb 28, 2018 at 3:47 AM, \u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3 <karl at dglab.com> wrote:\n> With the recent trend of physically robbing people for bitcoin (or\n> other cryptocurrencies), I thought it would be beneficial to introduce\n> a standard for locking up a portion of your bitcoin in a simple\n> 'gotta-wait-awhile' system.\n>\n> The idea is to simply create a transaction spending a set of UTXOs to\n> a P2SH address with an OP_CSV attached to it, and then throw away the\n> private keys.\n>\n> To spend the bitcoin, you would have to broadcast the transaction and\n> wait the given amount of time, then use the new txout.\n>\n> There are several ways to shoot yourself in the foot trying to do this\n> manually, but e.g. Bitcoin Core could handle this in a fairly\n> straightforward manner by introducing two new commands, which I call\n> freeze and unfreeze:\n>\n> bitcoin-cli freeze [amount OR array of txid+vout objects] [days, default 1]\n>\n> E.g. bitcoin-cli freeze 10 5\n> E.g. bitcoin-cli freeze [\"abc123:1\", \"def346:0\"] 3\n>\n> The unfreeze command would by default list all freezes:\n>\n> bitcoin-cli unfreeze\n> txid         days     status\n> bcd123   5           frozen\n> dca999   3           frozen\n>\n> including the txid would broadcast the unfreeze and status would\n> become 'thawing' until the amount becomes available:\n>\n> bitcoin-cli unfreeze bcd123\n>\n> bitcoin-cli unfreeze\n> txid         days     status\n> bcd123   5           thawing\n> dca999   3           frozen\n>\n> The benefit of this is that it becomes physically impossible for you\n> to spend the coins until you thaw them, and if this becomes standard\n> enough, it should disincentivize potential robbers as it would be\n> expected that you keep most of your assets locked up. They could of\n> course hold you hostage until the period is over, which may be worse,\n> but I think that kind of operation would be substantially more\n> difficult than a simply rob-and-run.\n>\n> The drawback is that you have to broadcast a transaction in order to\n> spend the content, and you cannot bump the fee so the transaction\n> could get stuck in a high-fee situation.\n>\n> -Kalle."
            },
            {
                "author": "Anthony Towns",
                "date": "2018-02-28T22:30:44",
                "message_text_only": "On Wed, Feb 28, 2018 at 04:34:18AM +0000, \u30a2\u30eb\u30e0 \u30ab\u30fc\u30eb\u30e8\u30cf\u30f3 via bitcoin-dev wrote:\n> 1. Graftroot probably breaks this (someone could just sign the\n> time-locked output with a script that has no time-lock).\n\nMaking the graftroot key be a 2-of-2 muSig with an independent third party\nthat commits to only signing CLTV scripts could avoid this. Making it\n3-of-3 or 5-of-5 could be even better if you can find multiple independent\nservices that will do it.\n\nCheers,\naj"
            },
            {
                "author": "Adam Back",
                "date": "2018-02-28T23:36:05",
                "message_text_only": "Coincidentally I had thought of something similar to what Kalle posted\nabout a kind of software only time-lock vault, and described the idea\nto a few people off-list.  Re. Root incompatibility, if the key is\ndeleted (as it must be) then a delegated signature can not be made\nthat bypasses the CSV timeout restriction, so Root should not be\nincompatible with this.  I think it would be disadvantageous to mark\nkeys as Rootable vs not in a sighash sense, because then that is\nanother privacy/fungibility loss eroding  the uniformity advantage of\nRoot when the delegate is not used.\n\nOne drawback is deleting keys may itself be a bit difficult to assure\nwith HD wallet seeds setup-time backup model.\n\nAs Anthony described I think, a simpler though less robust model would\nbe to have a third party refuse to co-sign until a pre-arranged time,\nand this would have the advantage of not requiring two on-chain\ntransactions.\n\nWith bulletproofs and CT rangeproofs / general ECDL ZKPS there is the\npossibility to prove things about the private key, or hidden\nattributes of a public key in zero-knowledge.  Kind of what we want is\nto place private key covenants, where we have to prove that they are\nmet without disclosing them.  For example there is a hidden CSV and it\nis met OR there is no hidden CSV so it is not applicable.\n\nAdam\n\nOn 28 February 2018 at 23:30, Anthony Towns via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> On Wed, Feb 28, 2018 at 04:34:18AM +0000, \u30a2\u30eb\u30e0 \u30ab\u30fc\u30eb\u30e8\u30cf\u30f3 via bitcoin-dev wrote:\n>> 1. Graftroot probably breaks this (someone could just sign the\n>> time-locked output with a script that has no time-lock).\n>\n> Making the graftroot key be a 2-of-2 muSig with an independent third party\n> that commits to only signing CLTV scripts could avoid this. Making it\n> 3-of-3 or 5-of-5 could be even better if you can find multiple independent\n> services that will do it.\n>\n> Cheers,\n> aj\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Simple lock/unlock mechanism",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Adam Back",
                "Anthony Towns",
                "\u30a2\u30eb\u30e0\u3000\u30ab\u30fc\u30eb\u30e8\u30cf\u30f3"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7044
        }
    }
]