[{"title": "[bitcoin-dev] BIP for OP_VAULT", "thread_messages": [{"author": "Greg Sanders", "date": "2023-03-01T15:05:47", "message_text_only": "Hello James,\n\nFirst off, thank you for crafting an interesting idea like this that is\naimed at solving a serious problem. I see a lot of excitement about the use\ncases, and I think it's worth iterating on.\n\nAttempting to keep the idealized functionality constant, I'd like to\nexplore a design detour. I'm attempting to decouple the 3 functionalities\nof `OP_VAULT` and `OP_UNVAULT` into their constituent functions with names\nI just made up.\n\nThe goals of this e-mail:\n\n1) Removing variable number of arguments based on values of arguments for\nthe opcodes.\nTo me as a spec reader, I find it very difficult to parse what's precisely\nhappening when. I think the only/last opcode to support this behavior was\nOP_CHECKMULTISIG(could be wrong), and now I know another reason why OP_CSA\nconstruct is nicer going forward with taproot.\n\n2) Remove the recursive evaluation functionality used for authentication,\nwithout reducing the efficacy of the targeted solution. Recursive\nevaluation has a fraught history in Bitcoin script, makes composing\nfunctionality with tooling likely more difficult, and has a lot of\ntemplated behavior. If we can rely on regular old tapscript to get us where\nwe need to go, I'd prefer that.\n\n3) Increase legibility of the spec. There's a ton going on, breaking things\nup and naming them based on the method rather than the goal may help here.\n\n4) Not (greatly) increase the expressiveness of the proposal. It's a\ntargeted proposal, and I'd like to respect that. These covenant opcodes are\nintended to be drop-in replacements for the OP_(UN)VAULT opcodes.\n\nTo recap, there are three things happen in idealized OP_VAULT scenario:\n1) Money comes out, then has to wait (trigger transaction)\n2) Money waits long enough, then withdrawals to dynamic set of outputs that\nare declared at trigger time (withdrawal transaction)\n3) Money to single specified output script picked up front, with no wait\n(recovery)\n\nBelow is a sketch of a replacement for the two opcodes. Ignore my\ninconsistency on VERIFY/non-VERIFY behavior, seeing if people agree with\nthis general direction:\n\n`OP_TRIGGER_FORWARD`: Takes exactly three arguments:\n1) output index to match against (provided at spend time normally)\n2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)\n(provided at spend time normally)\n3) spend-delay: value to be forwarded to output given at (1)\n\nFails script immediately if there aren't enough inputs or they're the wrong\nformat.\n\nThese last two arguments are \"forwarded\" to output at index declared in\nfirst argument, resulting in:\n\n`EXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP\n<target-outputs-hash> OP_FORWARD_OUTPUTS`\n\nAs the derived tapscript, embedded in a output scriptpubkey of the form:\n`tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block\nfrom the spending input, swap the inner pubkey for `NUMS`, use\n`EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output\nscriptpubkey doesnt match, fail.\n\nThis TLUV-ish script/inner pubkey replacement is meant to allow arbitrary\nother conditions, which is where the \"recovery\" path comes in for typical\nusage.\n\nIf output at the target output index doesn't match the constructed script,\nthe evaluation fails.\n\n`OP_FORWARD_DESTINATION`: Takes exactly two arguments:\n1) `dest-vout-idx`: index of output that contains the so-called \"recovery\"\npath\n2) <recovery sPK tagged hash (32 bytes)>: the hash of the script destination\n\nFails immediately if the reconstructed output script doesn't match.\n\n`OP_FORWARD_OUTPUTS` takes exactly one argument:\n1) target-outputs-hash: commits to all outputs' scripts and values\n\nFails immediately if transaction's outputs(including value) hash doesn't\nmatch.\n\n**Typical usage**:\n```\nDEPOSITING TO VAULT SCRIPT:\n\nEXPR_RECOVERY:   <recovery> <auth> <stuff> <recovery sPK tagged hash (32\nbytes)> OP_FORWARD_DESTINATION\nEXPR_TRIGGER:     <trigger> <auth> <stuff> <spend-delay> OP_TRIGGER_FORWARD\n\ntr(KEY, {EXPR_RECOVERY, EXPR_TRIGGER})\n```\n\n```\nEXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP\n<target-outputs-hash> OP_FORWARD_OUTPUTS\n```\n\n```\nTRIGGERING WITHDRAWAL TIMER SCRIPT:\n\ntr(NUMS, {EXPR_RECOVERY,EXPR_WITHDRAW}) <--- note EXPR_RECOVERY is forced\nby the OP_TRIGGER_FORWARD TLUV action\n```\n\nCould save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly\nas an argument, or keep it more general as I did.\n\nWould love to know what you and others think about this direction. I\napologies for any misunderstandings I have about the current OP_VAULT BIP!\n\nCheers,\nGreg\n\nOn Mon, Feb 13, 2023 at 4:09\u202fPM James O'Beirne via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Since the last related correspondence on this list [0], a number of\n> improvements have been made to the OP_VAULT draft [1]:\n>\n> * There is no longer a hard dependence on package relay/ephemeral\n>   anchors for fee management. When using \"authorized recovery,\" all\n>   vault-related transactions can be bundled with unrelated inputs and\n>   outputs, facilitating fee management that is self contained to the\n>   transaction. Consequently, the contents of this proposal are in theory\n>   usable today.\n>\n> * Specific output locations are no longer hardcoded in any of the\n>   transaction validation algorithms. This means that the proposal is now\n>   compatible with future changes like SIGHASH_GROUP, and\n>   transaction shapes for vault operations are more flexible.\n>\n> ---\n>\n> I've written a BIP that fully describes the proposal here:\n>\n>\n> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n>\n> The corresponding PR is here:\n>\n>   https://github.com/bitcoin/bips/pull/1421\n>\n> My next steps will be to try for a merge to the inquisition repo.\n>\n> Thanks to everyone who has participated so far, but especially to AJ and\n> Greg for all the advice.\n>\n> James\n>\n> [0]:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n> [1]: https://github.com/bitcoin/bitcoin/pull/26857\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230301/067e5b0d/attachment.html>", "summary": "A proposal to decouple the functionalities of `OP_VAULT` and `OP_UNVAULT` into their constituent functions with names, to improve legibility and remove recursive evaluation functionality. The proposal aims to be a drop-in replacement for the existing opcodes."}, {"author": "Anthony Towns", "date": "2023-03-02T04:46:25", "message_text_only": "On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev wrote:\n> Below is a sketch of a replacement for the two opcodes. \n\nI like this! I tried to come up with something along similar lines for\nsimilar reasons, but I think I tried too hard to reduce it to two opcodes\nor something and got myself confused.\n\n> `OP_TRIGGER_FORWARD`: Takes exactly three arguments:\n> 1) output index to match against (provided at spend time normally)\n> 2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)\n> (provided at spend time normally)\n> 3) spend-delay: value to be forwarded to output given at (1)\n\nI think you could generalise this as follows:\n\n   idx .. npush script OP_FORWARD_LEAF_UPDATE\n\n(OP_FLU :) with the behaviour being:\n\n   pop script from the stack\n   pop npush from the stack (error if non-minimal or <0)\n   pop npush entries from the stack,\n     prefix script with a minimal push of that entry\n   pop idx off the stack (error if idx is not a valid output)\n   calculate the spk corresponding to taking the current\n     input's spk and replacing the current leaf with the\n     given script\n   check the output at idx matches this spk, and the\n     value from this input accumulates to that output\n\nThen instead of `idx hash delay OP_TRIGGER_FORWARD` you\nwrite `idx hash delay 2 \"OP_CSV OP_DROP OP_FORWARD_OUTPUTS\"\nOP_FORWARD_LEAF_UPDATE`\n\nThat's an additional 5 witness bytes, but a much more generic/composable\nopcode.\n\nBeing able to prefix a script with push opcodes avoids the possibility\nof being able to add OP_SUCCESS instructions, so I think this is a fairly\nsafe way of allowing a TLUV-ish script to be modified, especially compared\nto OP_CAT.\n\nI do recognise that it makes it take a variable number of stack elements\nthough :)\n\n> As the derived tapscript, embedded in a output scriptpubkey of the form:\n> `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block\n> from the spending input, swap the inner pubkey for `NUMS`, use\n> `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output\n> scriptpubkey doesnt match, fail.\n\nI don't think replacing the internal-public-key makes sense -- if it\nwas immediately spendable via the keypath before there's no reason for\nit not to be immediately spendable now.\n\n> Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly\n> as an argument, or keep it more general as I did.\n\nHaving OP_FORWARD_OUTPUTS not leave its input on the stack would let\nyou move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.\n\n> Would love to know what you and others think about this direction. I\n> apologies for any misunderstandings I have about the current OP_VAULT BIP!\n\nI think the existing OP_VAULT cleverness would work here, allowing you\nto spend two inputs to the same output, accumulating their values.\n\nI don't think it quite gives you a way to \"refund\" values though -- so\nthat you can take a vault with 3 BTC, start the <delay> wait to spend\n1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on\nsomething else, without the 0.8 BTC effectively having a doubled delay.\n\nI think you could fix that with something as simple as an additional\n\"idx OP_FORWARD_REFUND\" opcode, though -- then the restriction is just\nthat the output at the refund idx has the same sPK as this input, and\nthe total value of this input is accumulated amongst all the outputs\nspecified by OP_FORWARD opcodes. (Maybe you need to specify the refund\namount explicitly as well, to keep verification easy)\n\nThat would make maybe three new opcodes to cover the \"accumulate value\nfrom one or more inputs into specified outputs\":\n\n - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk\n - OP_FORWARD_DESTINATION --> forward input value to given spk\n - OP_FORWARD_REFUND --> forward part of input value to same spk\n\nalong with OP_CTV:\n\n - OP_FORWARD_OUTPUTS --> pay to specific outputs\n\nOP_VAULT's \"accumulate value\" behaviour here makes the OP_IN_OUT_AMOUNT\nthings from TLUV more implicit and automatic, which is nice. I think\ndoing TLUV payment pools wouldn't require much more than the ability to\ncombine OP_FLU and OP_FDEST in a single script, explicitly specifying\nhow much value is extracted via OP_FDEST with the rest assigned to OP_FLU.\n\nCheers,\naj", "summary": "A proposed replacement for two opcodes in Bitcoin involves a new opcode called OP_TRIGGER_FORWARD, which takes three arguments and can be generalized for more flexibility. The proposed opcode can be embedded in a tapscript and used to modify a TLUV-ish script. The existing OP_VAULT cleverness can be used to spend two inputs to the same output, but there is no way to refund values."}, {"author": "Greg Sanders", "date": "2023-03-02T14:54:31", "message_text_only": "Greetings AJ,\n\nGlad I could resurrect the idea!\n\n> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you\nwrite `idx hash delay 2 \"OP_CSV OP_DROP OP_FORWARD_OUTPUTS\"\nOP_FORWARD_LEAF_UPDATE`\n\nInteresting idea! (I'll let you be the one to scope creep the proposal :) )\n\nTo be pedantic, EXPR_TRIGGER would become:\n\n<trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP\nOP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE\n\nand at spend time the idx and hash are put into the witness stack.\n\nTo be clear, <spend-delay> could be embedded in the <script> too, right,\nmaking <2> a <1> in the above? Any reason for one or the other?\n\nAnother bonus from this is that you can introduce withdrawal authorization\nas well as part of the <script>. Current proposal has no withdrawal\nauthorization, from what I understand. So each transition in a vault\nconstruct can have authorization, if it desires it.\n\n> I do recognise that it makes it take a variable number of stack elements\nthough :)\n\nJust when I thought I was out, they pulled me back in.\n\n> I don't think replacing the internal-public-key makes sense -- if it\nwas immediately spendable via the keypath before there's no reason for\nit not to be immediately spendable now.\n\nSlavishly following the current proposal was the idea to make sure all\nfunctionality was captured; I agree with this change.\n\n> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let\nyou move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.\n\nPreviously setting CSV timeout to 0 would result in it not being\nsatisfiable, if I'm understanding the suggestion correctly. I suppose this\nwas a side-effect of having OP_UNVAULT take this value directly. Indeed\nwith `OP_FORWARD_OUTPUTS` being split out there's not really a reason to\nuse a 0 value?\n\n> I think the existing OP_VAULT cleverness would work here, allowing you\nto spend two inputs to the same output, accumulating their values.\n\nYes I think batching story should be same hopefully. I am assuming all the\naccounting OP_VAULT is doing is being done here. We match against the hash\npassed in, and fits into the \"deferred checks\" IIUC.\n\n> OP_FORWARD_REFUND\n\nAgain, to be pedantic EXPR_TRIGGER becomes:\n\n<trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP\nOP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE OP_FORWARD_REFUND\n\nResulting in 2 more WU at spend time(for small idx). So *up front*\ncommitting to a refund path, perhaps with value explicitly passed in.\n\nTotally forgot about the refund path; will need to mull the issue over, see\nhow it interacts with BYOF schemes, etc.\n\nCheers,\nGreg\n\n\nOn Wed, Mar 1, 2023 at 11:46\u202fPM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev\n> wrote:\n> > Below is a sketch of a replacement for the two opcodes.\n>\n> I like this! I tried to come up with something along similar lines for\n> similar reasons, but I think I tried too hard to reduce it to two opcodes\n> or something and got myself confused.\n>\n> > `OP_TRIGGER_FORWARD`: Takes exactly three arguments:\n> > 1) output index to match against (provided at spend time normally)\n> > 2) target-outputs-hash: 32 byte hash to be forwarded to output given at\n> (1)\n> > (provided at spend time normally)\n> > 3) spend-delay: value to be forwarded to output given at (1)\n>\n> I think you could generalise this as follows:\n>\n>    idx .. npush script OP_FORWARD_LEAF_UPDATE\n>\n> (OP_FLU :) with the behaviour being:\n>\n>    pop script from the stack\n>    pop npush from the stack (error if non-minimal or <0)\n>    pop npush entries from the stack,\n>      prefix script with a minimal push of that entry\n>    pop idx off the stack (error if idx is not a valid output)\n>    calculate the spk corresponding to taking the current\n>      input's spk and replacing the current leaf with the\n>      given script\n>    check the output at idx matches this spk, and the\n>      value from this input accumulates to that output\n>\n> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you\n> write `idx hash delay 2 \"OP_CSV OP_DROP OP_FORWARD_OUTPUTS\"\n> OP_FORWARD_LEAF_UPDATE`\n>\n> That's an additional 5 witness bytes, but a much more generic/composable\n> opcode.\n>\n> Being able to prefix a script with push opcodes avoids the possibility\n> of being able to add OP_SUCCESS instructions, so I think this is a fairly\n> safe way of allowing a TLUV-ish script to be modified, especially compared\n> to OP_CAT.\n>\n> I do recognise that it makes it take a variable number of stack elements\n> though :)\n>\n> > As the derived tapscript, embedded in a output scriptpubkey of the form:\n> > `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control\n> block\n> > from the spending input, swap the inner pubkey for `NUMS`, use\n> > `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the\n> output\n> > scriptpubkey doesnt match, fail.\n>\n> I don't think replacing the internal-public-key makes sense -- if it\n> was immediately spendable via the keypath before there's no reason for\n> it not to be immediately spendable now.\n>\n> > Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly\n> > as an argument, or keep it more general as I did.\n>\n> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let\n> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.\n>\n> > Would love to know what you and others think about this direction. I\n> > apologies for any misunderstandings I have about the current OP_VAULT\n> BIP!\n>\n> I think the existing OP_VAULT cleverness would work here, allowing you\n> to spend two inputs to the same output, accumulating their values.\n>\n> I don't think it quite gives you a way to \"refund\" values though -- so\n> that you can take a vault with 3 BTC, start the <delay> wait to spend\n> 1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on\n> something else, without the 0.8 BTC effectively having a doubled delay.\n>\n> I think you could fix that with something as simple as an additional\n> \"idx OP_FORWARD_REFUND\" opcode, though -- then the restriction is just\n> that the output at the refund idx has the same sPK as this input, and\n> the total value of this input is accumulated amongst all the outputs\n> specified by OP_FORWARD opcodes. (Maybe you need to specify the refund\n> amount explicitly as well, to keep verification easy)\n>\n> That would make maybe three new opcodes to cover the \"accumulate value\n> from one or more inputs into specified outputs\":\n>\n>  - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk\n>  - OP_FORWARD_DESTINATION --> forward input value to given spk\n>  - OP_FORWARD_REFUND --> forward part of input value to same spk\n>\n> along with OP_CTV:\n>\n>  - OP_FORWARD_OUTPUTS --> pay to specific outputs\n>\n> OP_VAULT's \"accumulate value\" behaviour here makes the OP_IN_OUT_AMOUNT\n> things from TLUV more implicit and automatic, which is nice. I think\n> doing TLUV payment pools wouldn't require much more than the ability to\n> combine OP_FLU and OP_FDEST in a single script, explicitly specifying\n> how much value is extracted via OP_FDEST with the rest assigned to OP_FLU.\n>\n> Cheers,\n> aj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/59e4f0f8/attachment.html>", "summary": "Greg proposes a new script for the EXPR_TRIGGER opcode, allowing for withdrawal authorization and introducing a refund path."}, {"author": "Andrew Melnychuk Oseen", "date": "2023-03-02T19:51:17", "message_text_only": "I read the draft and this seems to have some functionality that I am looking for. I'm pretty new to bitcoin-dev, but I'm persistent and have a lot of time on my hands.\n\nI would like multiple tapleaves be restricted on the amount that they can spend.\nSay an input of 1 BTC, has a locking script of a tapscript that has 1 of 3 pubkeys of Alice, Bob and Carol(participants). I want to restrict the outputs of their next transactions to .2, .3 and .5 BTC respectively.\n\nIn the event of Bob spending their output, they are restricted to make a transaction that has a change output that has at least Alice and Carol's Amount, and a 1 or 2 tapscript or a 1 of 3 tapscript if Bob didn't spend all of their funds.\n\nIn the event of two of the three participants separately broadcast their transactions, I'm hoping that the second sender, can combine the two transactions into a package where the outputs and witnesses would be adjusted where two participants share an output with their respective amounts, and the remainder participant still has their funds available.\n\nIs this clear? I don't have a lot of experience communicating complex ideas in writing. I've been looking at some BIP's like OP_CHECKTEMPLATEVERIFY as well which had some idea's I really liked like OP_AMOUNTVERIFY. I'm not aware of the risks that the community previously discussed about the topic.\n\nAndrew\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Thursday, March 2nd, 2023 at 6:54 AM, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Greetings AJ,\n>\n> Glad I could resurrect the idea!\n>\n>> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you\n> write `idx hash delay 2 \"OP_CSV OP_DROP OP_FORWARD_OUTPUTS\"\n> OP_FORWARD_LEAF_UPDATE`\n>\n> Interesting idea! (I'll let you be the one to scope creep the proposal :) )\n>\n> To be pedantic, EXPR_TRIGGER would become:\n>\n> <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE\n>\n> and at spend time the idx and hash are put into the witness stack.\n>\n> To be clear, <spend-delay> could be embedded in the <script> too, right, making <2> a <1> in the above? Any reason for one or the other?\n>\n> Another bonus from this is that you can introduce withdrawal authorization as well as part of the <script>. Current proposal has no withdrawal authorization, from what I understand. So each transition in a vault construct can have authorization, if it desires it.\n>\n>> I do recognise that it makes it take a variable number of stack elements\n> though :)\n>\n> Just when I thought I was out, they pulled me back in.\n>\n>> I don't think replacing the internal-public-key makes sense -- if it\n> was immediately spendable via the keypath before there's no reason for\n> it not to be immediately spendable now.\n>\n> Slavishly following the current proposal was the idea to make sure all functionality was captured; I agree with this change.\n>\n>> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let\n> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.\n>\n> Previously setting CSV timeout to 0 would result in it not being satisfiable, if I'm understanding the suggestion correctly. I suppose this was a side-effect of having OP_UNVAULT take this value directly. Indeed with `OP_FORWARD_OUTPUTS` being split out there's not really a reason to use a 0 value?\n>\n>> I think the existing OP_VAULT cleverness would work here, allowing you\n> to spend two inputs to the same output, accumulating their values.\n>\n> Yes I think batching story should be same hopefully. I am assuming all the accounting OP_VAULT is doing is being done here. We match against the hash passed in, and fits into the \"deferred checks\" IIUC.\n>\n>> OP_FORWARD_REFUND\n>\n> Again, to be pedantic EXPR_TRIGGER becomes:\n>\n> <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE OP_FORWARD_REFUND\n>\n> Resulting in 2 more WU at spend time(for small idx). So up front committing to a refund path, perhaps with value explicitly passed in.\n>\n> Totally forgot about the refund path; will need to mull the issue over, see how it interacts with BYOF schemes, etc.\n>\n> Cheers,\n> Greg\n>\n> On Wed, Mar 1, 2023 at 11:46\u202fPM Anthony Towns <aj at erisian.com.au> wrote:\n>\n>> On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev wrote:\n>>> Below is a sketch of a replacement for the two opcodes.\n>>\n>> I like this! I tried to come up with something along similar lines for\n>> similar reasons, but I think I tried too hard to reduce it to two opcodes\n>> or something and got myself confused.\n>>\n>>> `OP_TRIGGER_FORWARD`: Takes exactly three arguments:\n>>> 1) output index to match against (provided at spend time normally)\n>>> 2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)\n>>> (provided at spend time normally)\n>>> 3) spend-delay: value to be forwarded to output given at (1)\n>>\n>> I think you could generalise this as follows:\n>>\n>> idx .. npush script OP_FORWARD_LEAF_UPDATE\n>>\n>> (OP_FLU :) with the behaviour being:\n>>\n>> pop script from the stack\n>> pop npush from the stack (error if non-minimal or <0)\n>> pop npush entries from the stack,\n>> prefix script with a minimal push of that entry\n>> pop idx off the stack (error if idx is not a valid output)\n>> calculate the spk corresponding to taking the current\n>> input's spk and replacing the current leaf with the\n>> given script\n>> check the output at idx matches this spk, and the\n>> value from this input accumulates to that output\n>>\n>> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you\n>> write `idx hash delay 2 \"OP_CSV OP_DROP OP_FORWARD_OUTPUTS\"\n>> OP_FORWARD_LEAF_UPDATE`\n>>\n>> That's an additional 5 witness bytes, but a much more generic/composable\n>> opcode.\n>>\n>> Being able to prefix a script with push opcodes avoids the possibility\n>> of being able to add OP_SUCCESS instructions, so I think this is a fairly\n>> safe way of allowing a TLUV-ish script to be modified, especially compared\n>> to OP_CAT.\n>>\n>> I do recognise that it makes it take a variable number of stack elements\n>> though :)\n>>\n>>> As the derived tapscript, embedded in a output scriptpubkey of the form:\n>>> `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block\n>>> from the spending input, swap the inner pubkey for `NUMS`, use\n>>> `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output\n>>> scriptpubkey doesnt match, fail.\n>>\n>> I don't think replacing the internal-public-key makes sense -- if it\n>> was immediately spendable via the keypath before there's no reason for\n>> it not to be immediately spendable now.\n>>\n>>> Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly\n>>> as an argument, or keep it more general as I did.\n>>\n>> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let\n>> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.\n>>\n>>> Would love to know what you and others think about this direction. I\n>>> apologies for any misunderstandings I have about the current OP_VAULT BIP!\n>>\n>> I think the existing OP_VAULT cleverness would work here, allowing you\n>> to spend two inputs to the same output, accumulating their values.\n>>\n>> I don't think it quite gives you a way to \"refund\" values though -- so\n>> that you can take a vault with 3 BTC, start the <delay> wait to spend\n>> 1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on\n>> something else, without the 0.8 BTC effectively having a doubled delay.\n>>\n>> I think you could fix that with something as simple as an additional\n>> \"idx OP_FORWARD_REFUND\" opcode, though -- then the restriction is just\n>> that the output at the refund idx has the same sPK as this input, and\n>> the total value of this input is accumulated amongst all the outputs\n>> specified by OP_FORWARD opcodes. (Maybe you need to specify the refund\n>> amount explicitly as well, to keep verification easy)\n>>\n>> That would make maybe three new opcodes to cover the \"accumulate value\n>> from one or more inputs into specified outputs\":\n>>\n>> - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk\n>> - OP_FORWARD_DESTINATION --> forward input value to given spk\n>> - OP_FORWARD_REFUND --> forward part of input value to same spk\n>>\n>> along with OP_CTV:\n>>\n>> - OP_FORWARD_OUTPUTS --> pay to specific outputs\n>>\n>> OP_VAULT's \"accumulate value\" behaviour here makes the OP_IN_OUT_AMOUNT\n>> things from TLUV more implicit and automatic, which is nice. I think\n>> doing TLUV payment pools wouldn't require much more than the ability to\n>> combine OP_FLU and OP_FDEST in a single script, explicitly specifying\n>> how much value is extracted via OP_FDEST with the rest assigned to OP_FLU.\n>>\n>> Cheers,\n>> aj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/738f7390/attachment-0001.html>", "summary": "The sender is proposing a tapscript that restricts the amount that multiple tapleaves can spend, with specific rules for each participant. They also suggest combining transactions and mention related BIPs."}, {"author": "James O'Beirne", "date": "2023-03-06T15:25:38", "message_text_only": "I'm glad to see that Greg and AJ are forming a habit of hammering\nthis proposal into shape. Nice work fellas.\n\nTo summarize:\n\nWhat Greg is proposing above is to in essence TLUV-ify this proposal.\n\nI.e. instead of relying on hashed commitments and recursive script\nexecution (e.g. <trigger-sPK-hash> + later presentation of preimage\nscript for execution), OP_VAULT would instead move through its\nwithdrawal process by swapping out tapleaf contents according to\nspecialized rules. If this is opaque (as it was to me), don't fret -\nI'll describe it below in the \"mechanics\" section.\n\n\nThe benefits of this TLUVification are\n\n- we can avoid any nested/recursive script execution. I know the\n  recursive stuff rankles some greybeards even in spite of it being\n  bounded to a single call. I'm not sure I share the concern but\n  maintaining the status quo seems good.\n\n- the spec is easier to reason about, more or less. The opcodes\n  introduced don't have variadic witness requirements, and each opcode\n  is only consumed in a single way.\n\n- there's less general indirection. Instead of saying \"okay, here's the\n  hash of the script I'm going to use to authorize trigger\n  transactions,\" we're just outright including the trigger auth script\n  in the tapleaf at the birth of the vault as regular 'ol script that is\n  evaluated before execution of the OP_VAULT instruction.\n\n  Similarly, instead of relying on an implicit rule that an OP_VAULT can\n  be claimed by a recovery flow, we're relying on a specific tapleaf that\n  facilitates that recovery with OP_VAULT_RECOVER, described below.\n\nBasically, OP_VAULT would just be implemented in a way that feels\nmore native to Taproot primitives.\n\nGreg also introduces different opcodes to facilitate consistent\nwitness structure, rather than the variable ones we have now\nsince OP_VAULT and OP_UNVAULT can each be spent in two different\ncontexts. I've changed those a little here; instead of the three general\nones Greg gave, we whittled it down to two: OP_VAULT and\nOP_VAULT_RECOVER.\n\n\nSo I think that, barring significant implementation complexity - which\nI'll find out about soon and don't expect - this is a good change to the\nproposal. As Greg noted, it doesn't really change anything about the\nusage or expressiveness... other than the fact that, as a bonus, it\nmight allow an optional withdrawal authorization script (i.e. trigger\noutput => final target), which could be useful if e.g. some kind of\nsize-limiting opcode (e.g. OP_TX_MAXSIZE or something) came around in\nthe future as a kind of pinning fix.\n\nIf that last bit lost you, don't worry - that is speculative, but the\npoint is that this rework composes well with other stuff.\n\n\n# CTV use\n\nAnother thing that has dawned on us is that we might as well just reuse\nOP_CHECKTEMPLATEVERIFY for withdrawal target spends. Ben Carmen and\nothers realized early on that you can synthesize CTV-like behavior by\nspending to a 0-delay OP_UNVAULT output, so something CTVish has always\nimplicitly been a part of the proposal. But CTV is better studied and\nbasically as simple as the OP_UNVAULT spend semantics, so the thought is\nthat we might as well reuse all the existing work (and scrutiny) from\nCTV.\n\nAs a concrete example, an issue with the existing proposal is that the\nexisting CTVish OP_UNVAULT behavior has txid malleability, since it\ndoesn't commit to nVersion or nLockTime or the input sequences. Using\nCTV solves this issue. Otherwise we'd basically reinvent it - \"something\nsomething convergent evolution.\"\n\nI think this is a satisfying development, because there's clearly demand\nfor CTV use in other contexts (DLC efficiency, e.g.), and if it's\nrequired behavior for practical vaults, I think pulling in the existing\nBIP-119 that's been worked over for years reduces the conceptual\nsurface area added by OP_VAULT.\n\n\n# New mechanics of the proposal\n\nSo here I'm going to describe my rendering of Greg and AJ's suggestions.\n\n\n## Required opcodes\n\n- OP_VAULT: spent to trigger withdrawal\n- OP_VAULT_RECOVER: spent to recover\n- OP_CHECKTEMPLATEVERIFY: spent into final withdrawal target\n\n\nCreating an initial deposit\n---------------------------\n\nFor each vault, vaulted coins are spent to an output with the taproot\nstructure\n\n  taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})\n\nwhere\n\n  internal_key =\n    unchanged from original proposal (some very safe recovery key)\n\n  $recovery_leaf =\n    [<opt.> <recovery> <auth>] <recovery sPK hash> OP_VAULT_RECOVER\n\n  $trigger_leaf =\n    <trigger> <auth> <script> <spend-delay> OP_VAULT\n\n  ... =\n    other (optional) leaves in the taptree\n\n\nTriggering a withdrawal request\n-------------------------------\n\nTo trigger the start of the withdrawal process, an output of the above\nform is spent with a witness that contains\n\n  - Taproot control block pointing to $trigger_leaf.\n  - <trigger-vout-idx>, indicating the trigger output which must abide\n    by the rules given below.\n\n\n## Output structure\n\n  taproot(internal_key, {$recovery_leaf, $expr_withdraw, ...})\n\nwhere\n\n  $recovery_leaf is preserved exactly\n  $expr_withdraw =\n    <spend-delay> OP_CSV OP_DROP <target-ctv-hash> OP_CTV\n  ... is preserved exactly\n\n\n(Spoiler: note here that the only thing that is changing is\ns/expr_trigger/expr_withdrawl/ from the initial vault ouput.)\n\nOf course $expr_withdraw *could* be prefixed by an optional \"withdrawal\nauthorization\" script, if some sensible use for that is found.\n\nThe validation rules are essentially unchanged from the existing\nproposal:\n\n- The total amount of all OP_VAULT inputs with matching $recovery_leaf\n  values must be reflected in output <trigger-vout-idx>\n\n- <trigger-vout-idx> must correspond to an output that is identical to\n  the input taptree but with the spent tapleaf (OP_VAULT) swapped out\n  for the timelocked CTV constructed using <target-ctv-hash> and\n  <spend-delay> as extracted from the spent tapleaf\n  - internal_key is preserved\n  - the whole rest of the taptree is preserved\n  - (this is what ensures the parameters of the vault are forwarded)\n\nAll batching, fee management characteristics are the same.\n\n\nFinalizing withdrawal\n---------------------\n\nHappens via script-path spend to $expr_withdraw, i.e. a timelocked\nOP_CTV.\n\n\nRecovery\n--------\n\nCan happen from any of the above outputs using the $recovery_leaf\nscript path in a way very similar to the existing OP_VAULT proposal.\n\n\n---\n\nTo reiterate, all aspects of the existing OP_VAULT proposal are either\npreserved or improved upon in terms of malleability reduction,\ncomposability, and flexibility. So big thanks to AJ and Greg.\n\nI'll undertake implementing these changes in the coming days to verify\nthat they are, as expected, workable.\n\nJames\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230306/0762c458/attachment.html>", "summary": "Greg and AJ propose TLUV-ifying the OP_VAULT proposal to avoid recursive script execution and simplify the spec. This change would make OP_VAULT more native to Taproot primitives. The proposal also introduces new opcodes to facilitate consistent witness structure. The change does not affect usage or expressiveness but may allow an optional withdrawal authorization script in the future. Additionally, the proposal suggests reusing OP_CHECKTEMPLATEVERIFY for withdrawal target spends."}, {"author": "Greg Sanders", "date": "2023-03-06T16:07:38", "message_text_only": "Hi James,\n\nI think everything except the hinted \"withdrawal authorization\" is spot on.\n\nFor withdrawal authorization, I think we'll have to go deeper into the TLUV\ndirection\nas AJ suggested for at least a couple reasons:\n\n1) You need the withdrawal authorization committed at deposit time\n2) You need to make sure cheeky opcodes cannot be prepended to the script\nat spend time\n\nOP_FORWARD_LEAF_UPDATE(OP_FLU) seems to fit the bill, at the cost of maybe\nadding another opcode for \"refunds\" as he notes.\n\nCheers,\nGreg\n\nOn Mon, Mar 6, 2023 at 10:25\u202fAM James O'Beirne <james.obeirne at gmail.com>\nwrote:\n\n> I'm glad to see that Greg and AJ are forming a habit of hammering\n> this proposal into shape. Nice work fellas.\n>\n> To summarize:\n>\n> What Greg is proposing above is to in essence TLUV-ify this proposal.\n>\n> I.e. instead of relying on hashed commitments and recursive script\n> execution (e.g. <trigger-sPK-hash> + later presentation of preimage\n> script for execution), OP_VAULT would instead move through its\n> withdrawal process by swapping out tapleaf contents according to\n> specialized rules. If this is opaque (as it was to me), don't fret -\n> I'll describe it below in the \"mechanics\" section.\n>\n>\n> The benefits of this TLUVification are\n>\n> - we can avoid any nested/recursive script execution. I know the\n>   recursive stuff rankles some greybeards even in spite of it being\n>   bounded to a single call. I'm not sure I share the concern but\n>   maintaining the status quo seems good.\n>\n> - the spec is easier to reason about, more or less. The opcodes\n>   introduced don't have variadic witness requirements, and each opcode\n>   is only consumed in a single way.\n>\n> - there's less general indirection. Instead of saying \"okay, here's the\n>   hash of the script I'm going to use to authorize trigger\n>   transactions,\" we're just outright including the trigger auth script\n>   in the tapleaf at the birth of the vault as regular 'ol script that is\n>   evaluated before execution of the OP_VAULT instruction.\n>\n>   Similarly, instead of relying on an implicit rule that an OP_VAULT can\n>   be claimed by a recovery flow, we're relying on a specific tapleaf that\n>   facilitates that recovery with OP_VAULT_RECOVER, described below.\n>\n> Basically, OP_VAULT would just be implemented in a way that feels\n> more native to Taproot primitives.\n>\n> Greg also introduces different opcodes to facilitate consistent\n> witness structure, rather than the variable ones we have now\n> since OP_VAULT and OP_UNVAULT can each be spent in two different\n> contexts. I've changed those a little here; instead of the three general\n> ones Greg gave, we whittled it down to two: OP_VAULT and\n> OP_VAULT_RECOVER.\n>\n>\n> So I think that, barring significant implementation complexity - which\n> I'll find out about soon and don't expect - this is a good change to the\n> proposal. As Greg noted, it doesn't really change anything about the\n> usage or expressiveness... other than the fact that, as a bonus, it\n> might allow an optional withdrawal authorization script (i.e. trigger\n> output => final target), which could be useful if e.g. some kind of\n> size-limiting opcode (e.g. OP_TX_MAXSIZE or something) came around in\n> the future as a kind of pinning fix.\n>\n> If that last bit lost you, don't worry - that is speculative, but the\n> point is that this rework composes well with other stuff.\n>\n>\n> # CTV use\n>\n> Another thing that has dawned on us is that we might as well just reuse\n> OP_CHECKTEMPLATEVERIFY for withdrawal target spends. Ben Carmen and\n> others realized early on that you can synthesize CTV-like behavior by\n> spending to a 0-delay OP_UNVAULT output, so something CTVish has always\n> implicitly been a part of the proposal. But CTV is better studied and\n> basically as simple as the OP_UNVAULT spend semantics, so the thought is\n> that we might as well reuse all the existing work (and scrutiny) from\n> CTV.\n>\n> As a concrete example, an issue with the existing proposal is that the\n> existing CTVish OP_UNVAULT behavior has txid malleability, since it\n> doesn't commit to nVersion or nLockTime or the input sequences. Using\n> CTV solves this issue. Otherwise we'd basically reinvent it - \"something\n> something convergent evolution.\"\n>\n> I think this is a satisfying development, because there's clearly demand\n> for CTV use in other contexts (DLC efficiency, e.g.), and if it's\n> required behavior for practical vaults, I think pulling in the existing\n> BIP-119 that's been worked over for years reduces the conceptual\n> surface area added by OP_VAULT.\n>\n>\n> # New mechanics of the proposal\n>\n> So here I'm going to describe my rendering of Greg and AJ's suggestions.\n>\n>\n> ## Required opcodes\n>\n> - OP_VAULT: spent to trigger withdrawal\n> - OP_VAULT_RECOVER: spent to recover\n> - OP_CHECKTEMPLATEVERIFY: spent into final withdrawal target\n>\n>\n> Creating an initial deposit\n> ---------------------------\n>\n> For each vault, vaulted coins are spent to an output with the taproot\n> structure\n>\n>   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})\n>\n> where\n>\n>   internal_key =\n>     unchanged from original proposal (some very safe recovery key)\n>\n>   $recovery_leaf =\n>     [<opt.> <recovery> <auth>] <recovery sPK hash> OP_VAULT_RECOVER\n>\n>   $trigger_leaf =\n>     <trigger> <auth> <script> <spend-delay> OP_VAULT\n>\n>   ... =\n>     other (optional) leaves in the taptree\n>\n>\n> Triggering a withdrawal request\n> -------------------------------\n>\n> To trigger the start of the withdrawal process, an output of the above\n> form is spent with a witness that contains\n>\n>   - Taproot control block pointing to $trigger_leaf.\n>   - <trigger-vout-idx>, indicating the trigger output which must abide\n>     by the rules given below.\n>\n>\n> ## Output structure\n>\n>   taproot(internal_key, {$recovery_leaf, $expr_withdraw, ...})\n>\n> where\n>\n>   $recovery_leaf is preserved exactly\n>   $expr_withdraw =\n>     <spend-delay> OP_CSV OP_DROP <target-ctv-hash> OP_CTV\n>   ... is preserved exactly\n>\n>\n> (Spoiler: note here that the only thing that is changing is\n> s/expr_trigger/expr_withdrawl/ from the initial vault ouput.)\n>\n> Of course $expr_withdraw *could* be prefixed by an optional \"withdrawal\n> authorization\" script, if some sensible use for that is found.\n>\n> The validation rules are essentially unchanged from the existing\n> proposal:\n>\n> - The total amount of all OP_VAULT inputs with matching $recovery_leaf\n>   values must be reflected in output <trigger-vout-idx>\n>\n> - <trigger-vout-idx> must correspond to an output that is identical to\n>   the input taptree but with the spent tapleaf (OP_VAULT) swapped out\n>   for the timelocked CTV constructed using <target-ctv-hash> and\n>   <spend-delay> as extracted from the spent tapleaf\n>   - internal_key is preserved\n>   - the whole rest of the taptree is preserved\n>   - (this is what ensures the parameters of the vault are forwarded)\n>\n> All batching, fee management characteristics are the same.\n>\n>\n> Finalizing withdrawal\n> ---------------------\n>\n> Happens via script-path spend to $expr_withdraw, i.e. a timelocked\n> OP_CTV.\n>\n>\n> Recovery\n> --------\n>\n> Can happen from any of the above outputs using the $recovery_leaf\n> script path in a way very similar to the existing OP_VAULT proposal.\n>\n>\n> ---\n>\n> To reiterate, all aspects of the existing OP_VAULT proposal are either\n> preserved or improved upon in terms of malleability reduction,\n> composability, and flexibility. So big thanks to AJ and Greg.\n>\n> I'll undertake implementing these changes in the coming days to verify\n> that they are, as expected, workable.\n>\n> James\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230306/3e92a245/attachment-0001.html>", "summary": "Greg proposes to TLUV-ify the proposal for withdrawal authorization, using OP_FORWARD_LEAF_UPDATE to avoid recursive script execution and ensure secure spending."}, {"author": "Anthony Towns", "date": "2023-03-07T12:45:34", "message_text_only": "On Mon, Mar 06, 2023 at 10:25:38AM -0500, James O'Beirne via bitcoin-dev wrote:\n> What Greg is proposing above is to in essence TLUV-ify this proposal.\n\nFWIW, the way I'm thinking about this is that the \"OP_VAULT\" concept is\nintroducing two things:\n\n a) the concept of \"forwarding\" the input amount to specified\n    outputs in a way that elegantly allows merging/splitting\n\n b) various restrictions on the form of the output scripts\n\nThese concepts go together well, because restricting an output script is\nonly an interesting thing to do if you're moving value from this input\ninto it. And then it's just a matter of figuring out a nice way to pick\nopcodes that combine those two concepts in interesting ways.\n\nThis is different from TLUV, in that TLUV only did part (b), and\nassumed you'd do part (a) manually somehow, eg via \"OP_IN_OUT_AMOUNT\"\nand arithmetic opcodes. The advantage of this new approach over that\none is that it makes it really easy to get the logic right (I often\nforgot to include the IN_OUT_AMOUNT checks at all, for instance), and\nalso makes spending multiple inputs to a single output really simple,\nsomething that would otherwise require kind-of gnarly logic.\n\nI think there are perhaps four opcodes that are interesting in this class:\n\n   idx sPK OP_FORWARD_TARGET\n     -- sends the value to a particular output (given by idx), and\n        requires that output have a particular scriptPubKey (given\n        by sPK).\n\n   idx [...] n script OP_FORWARD_LEAF_UPDATE\n     -- sends the value to a particular output (given by idx), and\n\trequires that output to have almost the same scriptPubKey as this\n\tinput, _except_ that the current leaf is replaced by \"script\",\n\twith that script prefixed by \"n\" pushes (of values given by [...])\n\n   idx OP_FORWARD_SELF\n     -- sends the value to a particular output (given by idx), and\n        requires that output to have the same scriptPubKey as this input\n\n   amt OP_FORWARD_PARTIAL\n     -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n        rather than the entire balance. opcodes after that affect the\n\tremaining balance, after \"amt\" has been subtracted. if \"amt\" is\n\t0, the next OP_FORWARD_* becomes a no-op.\n\nThen each time you see OP_FORWARD_TARGET or OP_FORWARD_LEAF_UPDATE, you\naccumulate the value that's expected to be forwarded to the output by\neach input, and verify that the amount for that output is greater-or-equal\nto the accumulated value.\n\n> ## Required opcodes\n> - OP_VAULT: spent to trigger withdrawal\n> - OP_VAULT_RECOVER: spent to recover\n\nNaming here is OP_VAULT ~= OP_FORWARD_LEAF_UPDATE; OP_VAULT_RECOVER ~=\nOP_FORWARD_TARGET.\n\n> For each vault, vaulted coins are spent to an output with the taproot\n> structure\n> \n>   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})\n> \n> where\n> \n>   $trigger_leaf =\n>     <trigger> <auth> <script> <spend-delay> OP_VAULT\n\nWith the opcodes above, the trigger_leaf (for spending some of the\nvaulted funds via your hot wallet) script might look like:\n\n   OP_FORWARD_PARTIAL OP_FORWARD_SELF\n   1 \"288 OP_CSV OP_DROP OP_CTV\" OP_FORWARD_LEAF_UPDATE\n   key CHECKSIG\n\nSo if you have 2.0 BTC in a vault utxo, you might spend 0.4 BTC by\nsupplying the witness data:\n\n  160000000  (1.6BTC in sats)\n  0 (output 0 puts 1.6BTC goes back into the vault)\n  <ctvhash> (the outputs where you want the remaining 0.4 BTC to end up)\n  1 (the output idx that will be spend via the CTV path once the CSV\n     delay is done)\n  <sig> (a signature of this transaction via the hot wallet \"key\")\n\nThat is, the script becomes:\n\n  160000000 FORWARD_PARTIAL\n  0 FORWARD_SELF\n  1 <ctvhash> 1 \"288 CSV DROP CTV\" FORWARD_LEAF_UPDATE\n  sig key CHECKSIG\n\nOutput 1 would then have a tapscript of \"<ctvhash> 288 OP_CSV OP_DROP\nOP_CTV\", satisfied with an empty witness stack (along with the recovery\npath, etc).\n\nOutput 0 is just 1.6BTC back in your vault, and immediately available \nfor use.\n\nOther inputs/outputs (for fees etc) would still be committed to by <sig>,\nso nothing here is malleable. The script here is about 45 bytes (compared\nto 34 for a simple \"key CHECKSIG\") and the witness data is about 105 bytes\n(compared to 65 bytes for just a signature), which seems pretty nice.\n\n>   ... =\n>     other (optional) leaves in the taptree\n\nThis would allow you to have multiple hot wallets (if any of them are\ncompromised you can still use the recovery path to avoid loss of funds;\nbut if some hot wallet becomes temporarily *inaccessible* you can still\neasily spend the funds via one of the alternative hot wallets), or,\nif you have multiple watchtowers validating your spends and recovering\nfunds to your cold wallet on a violation, you could have multiple recovery\npaths to provide some auditability for who triggered the recovery.\n\n> Happens via script-path spend to $expr_withdraw, i.e. a timelocked\n> OP_CTV.\n\nNote that if you calculated the OP_CTV incorrectly (eg, you don't set a\ncorrect nSequence timelock, so that any tx that passes OP_CTV won't pass\nthe OP_CSV check, and vice-versa) then this spend path becomes invalid,\nand the funds can only be reclaimed via some other path (key path spend,\nrecovery tapscript, potentially an alternative hotwallet script path).\n\nOP_FORWARD_LEAF_UPDATE is equivalent to a very specific form of TLUV,\nnamely \"FALSE <h> 2 TLUV\", where \"<h>\" is calculated by building the\nscript, prefixing the pushes, then doing the Hash_TapLeaf calculation.\n\nNot being able to tweak the internal public key (\"FALSE\" rather than\n\"<x>\") means this can't be used to build a coinpool with unilateral\nexit -- you can't remove your key from the key path, which screws over\neveryone who's still in the coinpool.\n\nOn the other hand, not tweaking the internal public key avoids introducing\nall the x-only pubkey complications, and keeps it relatively simple,\nwhich is nice, and keeping things simple and targeted now means there's\nstill plenty of OP_SUCCESS opcodes available later for something more\ngeneral, if that turns out to be desirable.\n\nCheers,\naj", "summary": "A proposal to introduce the concept of \"forwarding\" input amounts to specified outputs with various restrictions on output scripts using new opcodes."}, {"author": "Greg Sanders", "date": "2023-03-09T18:45:15", "message_text_only": "AJ,\n\nInteresting stuff! Just a couple thoughts on these proposed opcodes, at\nleast one we discussed elsewhere:\n\n1) OP_FORWARD_SELF is a JET of OP_FLU in the revaulting common case. Maybe\nobvious but I missed this initially and thought it was useful to be pointed\nout.\n\n2)  Using these extended primitives, you can do rate-limiting of the two\nstep unvaulting, or just a single step vault by committing to the partial\nvalues. For the single stage case it's something like:\n\n$recovery = Same As Before\n\n$withdrawal = <deposit-delay> OP_CSV OP_DROP <pubkey> OP_CHECKSIG OP_DUP\n<V> OP_LESSTHANOREQUAL OP_VERIFY OP_FORWARD_PARTIAL OP_FORWARD_TARGET\nOP_FORWARD_SELF\n\n$withdrawal is spent by:\n\n<self-idx> <target-idx> <spk> <0<=v<=V> <signature>\n\nwhere \"V\"  is the max allowed withdrawal value, and \"deposit-delay\" the\nrequired gap in withdrawals\n\nDue to the OP_LEQ, you are bound to ~21 BTC in value for this operation,\nbut for larger vaults it's pretty trivial to add larder fixed denominations\nto \"peel out\" value until you get to your final ~21 BTC.\n\nThis rate-limiting(in either the two-stage or one-stage scheme) can limit\nthe risk of theft during a watchtower outage to a constant value per utxo\nper time period of watchtower failure. As we've seen in the past with LN\ninfrastructure, software risks are often correlated, so it's a good idea to\nbuild in belt and suspenders where we can or at least have them available\nwhen possible.\n\nCheers,\nGreg\n\n\nOn Tue, Mar 7, 2023 at 7:45\u202fAM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Mon, Mar 06, 2023 at 10:25:38AM -0500, James O'Beirne via bitcoin-dev\n> wrote:\n> > What Greg is proposing above is to in essence TLUV-ify this proposal.\n>\n> FWIW, the way I'm thinking about this is that the \"OP_VAULT\" concept is\n> introducing two things:\n>\n>  a) the concept of \"forwarding\" the input amount to specified\n>     outputs in a way that elegantly allows merging/splitting\n>\n>  b) various restrictions on the form of the output scripts\n>\n> These concepts go together well, because restricting an output script is\n> only an interesting thing to do if you're moving value from this input\n> into it. And then it's just a matter of figuring out a nice way to pick\n> opcodes that combine those two concepts in interesting ways.\n>\n> This is different from TLUV, in that TLUV only did part (b), and\n> assumed you'd do part (a) manually somehow, eg via \"OP_IN_OUT_AMOUNT\"\n> and arithmetic opcodes. The advantage of this new approach over that\n> one is that it makes it really easy to get the logic right (I often\n> forgot to include the IN_OUT_AMOUNT checks at all, for instance), and\n> also makes spending multiple inputs to a single output really simple,\n> something that would otherwise require kind-of gnarly logic.\n>\n> I think there are perhaps four opcodes that are interesting in this class:\n>\n>    idx sPK OP_FORWARD_TARGET\n>      -- sends the value to a particular output (given by idx), and\n>         requires that output have a particular scriptPubKey (given\n>         by sPK).\n>\n>    idx [...] n script OP_FORWARD_LEAF_UPDATE\n>      -- sends the value to a particular output (given by idx), and\n>         requires that output to have almost the same scriptPubKey as this\n>         input, _except_ that the current leaf is replaced by \"script\",\n>         with that script prefixed by \"n\" pushes (of values given by [...])\n>\n>    idx OP_FORWARD_SELF\n>      -- sends the value to a particular output (given by idx), and\n>         requires that output to have the same scriptPubKey as this input\n>\n>    amt OP_FORWARD_PARTIAL\n>      -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n>         rather than the entire balance. opcodes after that affect the\n>         remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n>         0, the next OP_FORWARD_* becomes a no-op.\n>\n> Then each time you see OP_FORWARD_TARGET or OP_FORWARD_LEAF_UPDATE, you\n> accumulate the value that's expected to be forwarded to the output by\n> each input, and verify that the amount for that output is greater-or-equal\n> to the accumulated value.\n>\n> > ## Required opcodes\n> > - OP_VAULT: spent to trigger withdrawal\n> > - OP_VAULT_RECOVER: spent to recover\n>\n> Naming here is OP_VAULT ~= OP_FORWARD_LEAF_UPDATE; OP_VAULT_RECOVER ~=\n> OP_FORWARD_TARGET.\n>\n> > For each vault, vaulted coins are spent to an output with the taproot\n> > structure\n> >\n> >   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})\n> >\n> > where\n> >\n> >   $trigger_leaf =\n> >     <trigger> <auth> <script> <spend-delay> OP_VAULT\n>\n> With the opcodes above, the trigger_leaf (for spending some of the\n> vaulted funds via your hot wallet) script might look like:\n>\n>    OP_FORWARD_PARTIAL OP_FORWARD_SELF\n>    1 \"288 OP_CSV OP_DROP OP_CTV\" OP_FORWARD_LEAF_UPDATE\n>    key CHECKSIG\n>\n> So if you have 2.0 BTC in a vault utxo, you might spend 0.4 BTC by\n> supplying the witness data:\n>\n>   160000000  (1.6BTC in sats)\n>   0 (output 0 puts 1.6BTC goes back into the vault)\n>   <ctvhash> (the outputs where you want the remaining 0.4 BTC to end up)\n>   1 (the output idx that will be spend via the CTV path once the CSV\n>      delay is done)\n>   <sig> (a signature of this transaction via the hot wallet \"key\")\n>\n> That is, the script becomes:\n>\n>   160000000 FORWARD_PARTIAL\n>   0 FORWARD_SELF\n>   1 <ctvhash> 1 \"288 CSV DROP CTV\" FORWARD_LEAF_UPDATE\n>   sig key CHECKSIG\n>\n> Output 1 would then have a tapscript of \"<ctvhash> 288 OP_CSV OP_DROP\n> OP_CTV\", satisfied with an empty witness stack (along with the recovery\n> path, etc).\n>\n> Output 0 is just 1.6BTC back in your vault, and immediately available\n> for use.\n>\n> Other inputs/outputs (for fees etc) would still be committed to by <sig>,\n> so nothing here is malleable. The script here is about 45 bytes (compared\n> to 34 for a simple \"key CHECKSIG\") and the witness data is about 105 bytes\n> (compared to 65 bytes for just a signature), which seems pretty nice.\n>\n> >   ... =\n> >     other (optional) leaves in the taptree\n>\n> This would allow you to have multiple hot wallets (if any of them are\n> compromised you can still use the recovery path to avoid loss of funds;\n> but if some hot wallet becomes temporarily *inaccessible* you can still\n> easily spend the funds via one of the alternative hot wallets), or,\n> if you have multiple watchtowers validating your spends and recovering\n> funds to your cold wallet on a violation, you could have multiple recovery\n> paths to provide some auditability for who triggered the recovery.\n>\n> > Happens via script-path spend to $expr_withdraw, i.e. a timelocked\n> > OP_CTV.\n>\n> Note that if you calculated the OP_CTV incorrectly (eg, you don't set a\n> correct nSequence timelock, so that any tx that passes OP_CTV won't pass\n> the OP_CSV check, and vice-versa) then this spend path becomes invalid,\n> and the funds can only be reclaimed via some other path (key path spend,\n> recovery tapscript, potentially an alternative hotwallet script path).\n>\n> OP_FORWARD_LEAF_UPDATE is equivalent to a very specific form of TLUV,\n> namely \"FALSE <h> 2 TLUV\", where \"<h>\" is calculated by building the\n> script, prefixing the pushes, then doing the Hash_TapLeaf calculation.\n>\n> Not being able to tweak the internal public key (\"FALSE\" rather than\n> \"<x>\") means this can't be used to build a coinpool with unilateral\n> exit -- you can't remove your key from the key path, which screws over\n> everyone who's still in the coinpool.\n>\n> On the other hand, not tweaking the internal public key avoids introducing\n> all the x-only pubkey complications, and keeps it relatively simple,\n> which is nice, and keeping things simple and targeted now means there's\n> still plenty of OP_SUCCESS opcodes available later for something more\n> general, if that turns out to be desirable.\n>\n> Cheers,\n> aj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230309/7c5a5e29/attachment.html>", "summary": "New opcodes proposed for Bitcoin's OP_VAULT concept allow rate-limiting of two-step unvaulting and single-step vaulting, reducing theft risk during watchtower outages."}, {"author": "Anthony Towns", "date": "2023-03-10T01:08:55", "message_text_only": "On 10 March 2023 4:45:15 am AEST, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>1) OP_FORWARD_SELF is a JET of OP_FLU in the revaulting common case. Maybe\n>obvious but I missed this initially and thought it was useful to be pointed\n>out.\n\nThat was true for TLUV - iirc \"FALSE FALSE 0 TLUV\" would preserve the spk - but I don't think it's true for OP_FLU: you can't commit to preserving the current script without a way to observe the current script; trying to include a copy of the script in the script makes the script size infinite, and trying to include a hash of the script inside the script is cryptographically infeasible.\n\nYou could just special case \"0 0 OP_FLU\" to result in the same script rather than an empty one though, which would avoid the need for a dedicated FWD_SELF opcode.\n\n(Not convinced calling things Jets when they're unrelated to simplicity makes sense)\n\nCheers,\naj\n\n-- \nSent from my phone.", "summary": "The email discusses the use of OP_FORWARD_SELF as a JET of OP_FLU in the revaulting common case, with a suggestion to use a special case instead."}, {"author": "Anthony Towns", "date": "2023-03-24T12:10:05", "message_text_only": "On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:\n> I think there are perhaps four opcodes that are interesting in this class:\n> \n>    idx sPK OP_FORWARD_TARGET\n>      -- sends the value to a particular output (given by idx), and\n>         requires that output have a particular scriptPubKey (given\n>         by sPK).\n> \n>    idx [...] n script OP_FORWARD_LEAF_UPDATE\n>      -- sends the value to a particular output (given by idx), and\n> \trequires that output to have almost the same scriptPubKey as this\n> \tinput, _except_ that the current leaf is replaced by \"script\",\n> \twith that script prefixed by \"n\" pushes (of values given by [...])\n> \n>    idx OP_FORWARD_SELF\n>      -- sends the value to a particular output (given by idx), and\n>         requires that output to have the same scriptPubKey as this input\n> \n>    amt OP_FORWARD_PARTIAL\n>      -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n>         rather than the entire balance. opcodes after that affect the\n> \tremaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> \t0, the next OP_FORWARD_* becomes a no-op.\n\nThe BIP 345 draft has been updated [0] [1] and now pretty much defines\nOP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,\nand OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\nthat, for this email I'm going to continue using the OP_FORWARD_*\nnaming convention.\n\nGiven the recent controversy over the Yuga labs ordinal auction [2],\nperhaps it's interesting to consider that these proposed opcodes come\nclose to making it possible to do a fair, non-custodial, on-chain auction\nof ordinals [3].\n\nThe idea here is that you create a utxo on chain that contains the ordinal\nin question, which commits to the address of the current leading bidder,\nand can be spent in two ways:\n\n  1) it can be updated to a new bidder, if the bid is raised by at least\n     K satoshis, in which case the previous bidder is refunded their\n     bid; or,\n\n  2) if there have been no new bids for a day, the current high bidder\n     wins, and the ordinal is moved to their address, while the funds\n     from their winning bid are sent to the original vendor's address.\n\nI believe this can be implemented in script as follows,\nassuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\nOP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),\nand OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\nare all available.\n\nFirst, figure out the parameters:\n\n * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n * Set K to the minimum bid increment [5].\n * Initially, set X equal to VENDOR.\n * Initially, set V to just below the reserve price (V+K is the\n   minimum initial bid).\n\nThen construct the following script:\n\n [X] [V] [SSS] TOALT TOALT TOALT\n 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n DEPTH NOT IF\n   0 10000 FORWARD_PARTIAL\n   0 FROMALT FORWARD_TARGET\n   1 [VENDOR] FWD_TARGET\n   144\n ELSE\n   FROMALT SWAP TUCK FROMALT\n   [K] ADD GREATERTHANOREQUAL VERIFY\n   1 SWAP FORWARD_TARGET\n   DUP FORWARD_PARTIAL\n   0 ROT ROT\n   FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n   0\n ENDIF\n CSV\n 1ADD\n\nwhere \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n.. 1ADD\").\n\nFinally, make that script the sole tapleaf, accompanied by a NUMS point\nas the internal public key, calculate the taproot address corresponding\nto that, and send the ordinal to that address as the first satoshi.\n\nThere are two ways to spend that script. With an empty witness stack,\nthe following will be executed:\n\n [X] [V] [SSS] TOALT TOALT TOALT\n   -- altstack now contains [SSS V X]\n 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n   -- this input is the first, so the ordinal will move to the first\n      output\n DEPTH NOT IF\n   -- take this branch: the auction is over!\n   1 [VENDOR] FWD_TARGET\n   -- output 1 gets the entire value of this input, and pays to\n      the vendor's hardcoded scriptPubKey\n   0 10000 FORWARD_PARTIAL\n   0 FROMALT FORWARD_TARGET\n   -- we forward at least 10k sats to output 0 (if there were 0 sats,\n      the ordinal would end up in output 1 instead, which would be a\n      bug), and output 0 pays to scriptPubKey \"X\"\n   144\n ELSE .. ENDIF\n   -- skip over the other branch\n CSV\n   -- check that this input has baked for 144 blocks (~1 day)\n 1ADD\n   -- leave 145 on the stack, which is true. success!\n\nAlternatively, if you want to increase the bid you provide a stack with\ntwo items: your scriptPubKey and the new bid [X' V']. Execution this\ntime looks like:\n\n [X] [V] [SSS] TOALT TOALT TOALT\n   -- stack contains [X' V'], altstack now contains [SSS V X]\n 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n   -- this input is the first, so the ordinal will move to the first\n      output\n DEPTH NOT IF ... ELSE\n   -- skip over the other branch (without violating minimalif rules)\n   FROMALT SWAP TUCK FROMALT\n   -- stack contains [X' V' X V' V], altstack contains [SSS]\n   [K] ADD GREATERTHANOREQUAL VERIFY\n   -- check V' >= V+K, stack contains [X' V' X]\n   1 SWAP FORWARD_TARGET\n   -- output 1 pays to X (previous bidder's scriptPubKey), and the\n      entire value of this input goes there; stack contains [X' V']\n   DUP FORWARD_PARTIAL\n   -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n   0 ROT ROT\n   -- stack contains [0 X' V']\n   FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n   -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n      that output 0 spends at least V' satoshis back to the same\n      script (because that's how we defined SSS), except the first\n      three pushes (previously X V SSS) are replaced by X' V' SSS.\n   0\n ENDIF\n CSV\n   -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n      which hopefully makes it harder to pin\n 1ADD\n   -- ends with 1 on the stack; success!\n\n(The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\nie a program that outputs its own source code)\n\nI think that script is about 211 witness bytes, with an additional 40\nwitness bytes for X'/V', so when making a bid, your tx would be\nsomething like:\n\n   tx header, 10vb\n   input 0: 103vb for the old bid including witness and control block\n   input 1: 58vb for a taproot key path spend\n   output 0: 43vb for the new bid\n   output 1: 43vb for your change\n\nfor a total of about 257vb -- slightly larger than a regular 2-in-2-out\ntransaction, but not terribly much. Mostly because input 0 doesn't require\na signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\nand the script code twice, along with a little extra to encode the\nvarious numbers (10000, 144, K, V, V').\n\nThis approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\nyour bid succeeds; if it doesn't, you don't pay any fees. A potential\nscalper might want to put in an early low ball bid, then prevent\nhigher bidders from winning the auction, take control of the ordinal,\nand resell it later, but unless they can prevent another miner from\nmining alternative bids for 144 blocks, they will fail at that. The bid\nis fixed by the bidder and committed to by the signature on input 1, so\nfrontrunning a bid can't do anything beyond invalidate the bid entirely.\n\nObviously, this is a pretty limited auction mechanism in various ways;\neg maybe you'd rather specify K as a percentage than an absoute increment;\nmaybe you'd like to have the auction definitely finish by some particular\ntime; maybe you'd like to be able to have the auction be able to continue\nabove 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\nrather than an english auction. I think you can probably do all those\nthings with this set of opcodes and clever scripting, though it probably\ngets ugly.\n\nI don't think this is easily extensible to taro or rgb style assets,\nas rather than being able to ensure the asset is transferred by\ncontrolling the input/output positions, I think you'd need to build\nup merkle trees and do point tweaks beyond what's supported by\nOP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\nOP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\neither.\n\nCheers,\naj\n\n[0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n\n[1] https://twitter.com/jamesob/status/1639019107432513537\n\n[2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n\n[3] Inscriptions remain a wasteful way of publishing/committing\n    to content, however!\n\n[4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n\n[5] Setting K too low probably invites griefing, where a bidder may be\n    able to use rbf pinning vectors to prevent people who would be willing\n    to bid substantially higher from getting their bid confirmed on\n    chain.", "summary": "A proposed update to Bitcoin's scripting language includes new opcodes for conditional transactions. These could enable non-custodial, on-chain auctions of ordinals."}, {"author": "Zac Greenwood", "date": "2023-03-29T07:10:19", "message_text_only": "I\u2019m not sure why any effort should be spent on theorizing how new opcodes\nmight be used to facilitate parasitical use cases of the blockchain.\n\nIf anything, business models relying on the ability to abuse the blockchain\nas a data store must be made less feasible, not more.\n\nZac\n\n\nOn Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev\n> wrote:\n> > I think there are perhaps four opcodes that are interesting in this\n> class:\n> >\n> >    idx sPK OP_FORWARD_TARGET\n> >      -- sends the value to a particular output (given by idx), and\n> >         requires that output have a particular scriptPubKey (given\n> >         by sPK).\n> >\n> >    idx [...] n script OP_FORWARD_LEAF_UPDATE\n> >      -- sends the value to a particular output (given by idx), and\n> >       requires that output to have almost the same scriptPubKey as this\n> >       input, _except_ that the current leaf is replaced by \"script\",\n> >       with that script prefixed by \"n\" pushes (of values given by [...])\n> >\n> >    idx OP_FORWARD_SELF\n> >      -- sends the value to a particular output (given by idx), and\n> >         requires that output to have the same scriptPubKey as this input\n> >\n> >    amt OP_FORWARD_PARTIAL\n> >      -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n> >         rather than the entire balance. opcodes after that affect the\n> >       remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> >       0, the next OP_FORWARD_* becomes a no-op.\n>\n> The BIP 345 draft has been updated [0] [1] and now pretty much defines\n> OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,\n> and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\n> that, for this email I'm going to continue using the OP_FORWARD_*\n> naming convention.\n>\n> Given the recent controversy over the Yuga labs ordinal auction [2],\n> perhaps it's interesting to consider that these proposed opcodes come\n> close to making it possible to do a fair, non-custodial, on-chain auction\n> of ordinals [3].\n>\n> The idea here is that you create a utxo on chain that contains the ordinal\n> in question, which commits to the address of the current leading bidder,\n> and can be spent in two ways:\n>\n>   1) it can be updated to a new bidder, if the bid is raised by at least\n>      K satoshis, in which case the previous bidder is refunded their\n>      bid; or,\n>\n>   2) if there have been no new bids for a day, the current high bidder\n>      wins, and the ordinal is moved to their address, while the funds\n>      from their winning bid are sent to the original vendor's address.\n>\n> I believe this can be implemented in script as follows,\n> assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\n> OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),\n> and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\n> are all available.\n>\n> First, figure out the parameters:\n>\n>  * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n>  * Set K to the minimum bid increment [5].\n>  * Initially, set X equal to VENDOR.\n>  * Initially, set V to just below the reserve price (V+K is the\n>    minimum initial bid).\n>\n> Then construct the following script:\n>\n>  [X] [V] [SSS] TOALT TOALT TOALT\n>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n>  DEPTH NOT IF\n>    0 10000 FORWARD_PARTIAL\n>    0 FROMALT FORWARD_TARGET\n>    1 [VENDOR] FWD_TARGET\n>    144\n>  ELSE\n>    FROMALT SWAP TUCK FROMALT\n>    [K] ADD GREATERTHANOREQUAL VERIFY\n>    1 SWAP FORWARD_TARGET\n>    DUP FORWARD_PARTIAL\n>    0 ROT ROT\n>    FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n>    0\n>  ENDIF\n>  CSV\n>  1ADD\n>\n> where \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n> .. 1ADD\").\n>\n> Finally, make that script the sole tapleaf, accompanied by a NUMS point\n> as the internal public key, calculate the taproot address corresponding\n> to that, and send the ordinal to that address as the first satoshi.\n>\n> There are two ways to spend that script. With an empty witness stack,\n> the following will be executed:\n>\n>  [X] [V] [SSS] TOALT TOALT TOALT\n>    -- altstack now contains [SSS V X]\n>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n>    -- this input is the first, so the ordinal will move to the first\n>       output\n>  DEPTH NOT IF\n>    -- take this branch: the auction is over!\n>    1 [VENDOR] FWD_TARGET\n>    -- output 1 gets the entire value of this input, and pays to\n>       the vendor's hardcoded scriptPubKey\n>    0 10000 FORWARD_PARTIAL\n>    0 FROMALT FORWARD_TARGET\n>    -- we forward at least 10k sats to output 0 (if there were 0 sats,\n>       the ordinal would end up in output 1 instead, which would be a\n>       bug), and output 0 pays to scriptPubKey \"X\"\n>    144\n>  ELSE .. ENDIF\n>    -- skip over the other branch\n>  CSV\n>    -- check that this input has baked for 144 blocks (~1 day)\n>  1ADD\n>    -- leave 145 on the stack, which is true. success!\n>\n> Alternatively, if you want to increase the bid you provide a stack with\n> two items: your scriptPubKey and the new bid [X' V']. Execution this\n> time looks like:\n>\n>  [X] [V] [SSS] TOALT TOALT TOALT\n>    -- stack contains [X' V'], altstack now contains [SSS V X]\n>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n>    -- this input is the first, so the ordinal will move to the first\n>       output\n>  DEPTH NOT IF ... ELSE\n>    -- skip over the other branch (without violating minimalif rules)\n>    FROMALT SWAP TUCK FROMALT\n>    -- stack contains [X' V' X V' V], altstack contains [SSS]\n>    [K] ADD GREATERTHANOREQUAL VERIFY\n>    -- check V' >= V+K, stack contains [X' V' X]\n>    1 SWAP FORWARD_TARGET\n>    -- output 1 pays to X (previous bidder's scriptPubKey), and the\n>       entire value of this input goes there; stack contains [X' V']\n>    DUP FORWARD_PARTIAL\n>    -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n>    0 ROT ROT\n>    -- stack contains [0 X' V']\n>    FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n>    -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n>       that output 0 spends at least V' satoshis back to the same\n>       script (because that's how we defined SSS), except the first\n>       three pushes (previously X V SSS) are replaced by X' V' SSS.\n>    0\n>  ENDIF\n>  CSV\n>    -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n>       which hopefully makes it harder to pin\n>  1ADD\n>    -- ends with 1 on the stack; success!\n>\n> (The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\n> ie a program that outputs its own source code)\n>\n> I think that script is about 211 witness bytes, with an additional 40\n> witness bytes for X'/V', so when making a bid, your tx would be\n> something like:\n>\n>    tx header, 10vb\n>    input 0: 103vb for the old bid including witness and control block\n>    input 1: 58vb for a taproot key path spend\n>    output 0: 43vb for the new bid\n>    output 1: 43vb for your change\n>\n> for a total of about 257vb -- slightly larger than a regular 2-in-2-out\n> transaction, but not terribly much. Mostly because input 0 doesn't require\n> a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\n> and the script code twice, along with a little extra to encode the\n> various numbers (10000, 144, K, V, V').\n>\n> This approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\n> your bid succeeds; if it doesn't, you don't pay any fees. A potential\n> scalper might want to put in an early low ball bid, then prevent\n> higher bidders from winning the auction, take control of the ordinal,\n> and resell it later, but unless they can prevent another miner from\n> mining alternative bids for 144 blocks, they will fail at that. The bid\n> is fixed by the bidder and committed to by the signature on input 1, so\n> frontrunning a bid can't do anything beyond invalidate the bid entirely.\n>\n> Obviously, this is a pretty limited auction mechanism in various ways;\n> eg maybe you'd rather specify K as a percentage than an absoute increment;\n> maybe you'd like to have the auction definitely finish by some particular\n> time; maybe you'd like to be able to have the auction be able to continue\n> above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\n> rather than an english auction. I think you can probably do all those\n> things with this set of opcodes and clever scripting, though it probably\n> gets ugly.\n>\n> I don't think this is easily extensible to taro or rgb style assets,\n> as rather than being able to ensure the asset is transferred by\n> controlling the input/output positions, I think you'd need to build\n> up merkle trees and do point tweaks beyond what's supported by\n> OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\n> OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\n> either.\n>\n> Cheers,\n> aj\n>\n> [0]\n> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n>\n> [1] https://twitter.com/jamesob/status/1639019107432513537\n>\n> [2]\n> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n>\n> [3] Inscriptions remain a wasteful way of publishing/committing\n>     to content, however!\n>\n> [4]\n> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n>\n> [5] Setting K too low probably invites griefing, where a bidder may be\n>     able to use rbf pinning vectors to prevent people who would be willing\n>     to bid substantially higher from getting their bid confirmed on\n>     chain.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230329/66e43c91/attachment.html>", "summary": "Efforts should not be made to facilitate parasitical use cases of the blockchain. Business models relying on blockchain abuse must be made less feasible."}, {"author": "alicexbt", "date": "2023-03-29T19:57:08", "message_text_only": "Hi Zac,\n\nLet me share what those parasites achieved:\n\n- Fees paid: 150 BTC\n- Lot of users and developers trying bitcoin that either never tried or gave up early in 2013-15\n- Mempools of nodes of being busy on weekends and got lots of transactions\n- PSBT became cool and application devs are trying their best to use it in different ways\n- Some developers exploring taproot and multisig\n- AJ shared things how covenants could help in fair, non-custodial, on-chain auction of ordinals that is MEV resistant although I had shared it earlier which involves more steps: https://twitter.com/1440000bytes/status/1634368411760476161\n- Investors exploring about funding projects\n- Bitcoin more than Bitcoin and people excited about it \n\nWe can have difference of opinion, however I want bitcoin to be money and money means different things for people in this world. Please respect that else it will become like Linux, something used by 1% of world. \n\n/dev/fd0\nfloppy disk guy\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> I\u2019m not sure why any effort should be spent on theorizing how new opcodes might be used to facilitate parasitical use cases of the blockchain.\n>\n> If anything, business models relying on the ability to abuse the blockchain as a data store must be made less feasible, not more.\n>\n> Zac\n>\n>\n> On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:\n> > > I think there are perhaps four opcodes that are interesting in this class:\n> > >\n> > > idx sPK OP_FORWARD_TARGET\n> > > -- sends the value to a particular output (given by idx), and\n> > > requires that output have a particular scriptPubKey (given\n> > > by sPK).\n> > >\n> > > idx [...] n script OP_FORWARD_LEAF_UPDATE\n> > > -- sends the value to a particular output (given by idx), and\n> > > requires that output to have almost the same scriptPubKey as this\n> > > input, _except_ that the current leaf is replaced by \"script\",\n> > > with that script prefixed by \"n\" pushes (of values given by [...])\n> > >\n> > > idx OP_FORWARD_SELF\n> > > -- sends the value to a particular output (given by idx), and\n> > > requires that output to have the same scriptPubKey as this input\n> > >\n> > > amt OP_FORWARD_PARTIAL\n> > > -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n> > > rather than the entire balance. opcodes after that affect the\n> > > remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> > > 0, the next OP_FORWARD_* becomes a no-op.\n> >\n> > The BIP 345 draft has been updated [0] [1] and now pretty much defines\n> > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,\n> > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\n> > that, for this email I'm going to continue using the OP_FORWARD_*\n> > naming convention.\n> >\n> > Given the recent controversy over the Yuga labs ordinal auction [2],\n> > perhaps it's interesting to consider that these proposed opcodes come\n> > close to making it possible to do a fair, non-custodial, on-chain auction\n> > of ordinals [3].\n> >\n> > The idea here is that you create a utxo on chain that contains the ordinal\n> > in question, which commits to the address of the current leading bidder,\n> > and can be spent in two ways:\n> >\n> > 1) it can be updated to a new bidder, if the bid is raised by at least\n> > K satoshis, in which case the previous bidder is refunded their\n> > bid; or,\n> >\n> > 2) if there have been no new bids for a day, the current high bidder\n> > wins, and the ordinal is moved to their address, while the funds\n> > from their winning bid are sent to the original vendor's address.\n> >\n> > I believe this can be implemented in script as follows,\n> > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\n> > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),\n> > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\n> > are all available.\n> >\n> > First, figure out the parameters:\n> >\n> > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n> > * Set K to the minimum bid increment [5].\n> > * Initially, set X equal to VENDOR.\n> > * Initially, set V to just below the reserve price (V+K is the\n> > minimum initial bid).\n> >\n> > Then construct the following script:\n> >\n> > [X] [V] [SSS] TOALT TOALT TOALT\n> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > DEPTH NOT IF\n> > 0 10000 FORWARD_PARTIAL\n> > 0 FROMALT FORWARD_TARGET\n> > 1 [VENDOR] FWD_TARGET\n> > 144\n> > ELSE\n> > FROMALT SWAP TUCK FROMALT\n> > [K] ADD GREATERTHANOREQUAL VERIFY\n> > 1 SWAP FORWARD_TARGET\n> > DUP FORWARD_PARTIAL\n> > 0 ROT ROT\n> > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > 0\n> > ENDIF\n> > CSV\n> > 1ADD\n> >\n> > where \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n> > .. 1ADD\").\n> >\n> > Finally, make that script the sole tapleaf, accompanied by a NUMS point\n> > as the internal public key, calculate the taproot address corresponding\n> > to that, and send the ordinal to that address as the first satoshi.\n> >\n> > There are two ways to spend that script. With an empty witness stack,\n> > the following will be executed:\n> >\n> > [X] [V] [SSS] TOALT TOALT TOALT\n> > -- altstack now contains [SSS V X]\n> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > -- this input is the first, so the ordinal will move to the first\n> > output\n> > DEPTH NOT IF\n> > -- take this branch: the auction is over!\n> > 1 [VENDOR] FWD_TARGET\n> > -- output 1 gets the entire value of this input, and pays to\n> > the vendor's hardcoded scriptPubKey\n> > 0 10000 FORWARD_PARTIAL\n> > 0 FROMALT FORWARD_TARGET\n> > -- we forward at least 10k sats to output 0 (if there were 0 sats,\n> > the ordinal would end up in output 1 instead, which would be a\n> > bug), and output 0 pays to scriptPubKey \"X\"\n> > 144\n> > ELSE .. ENDIF\n> > -- skip over the other branch\n> > CSV\n> > -- check that this input has baked for 144 blocks (~1 day)\n> > 1ADD\n> > -- leave 145 on the stack, which is true. success!\n> >\n> > Alternatively, if you want to increase the bid you provide a stack with\n> > two items: your scriptPubKey and the new bid [X' V']. Execution this\n> > time looks like:\n> >\n> > [X] [V] [SSS] TOALT TOALT TOALT\n> > -- stack contains [X' V'], altstack now contains [SSS V X]\n> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > -- this input is the first, so the ordinal will move to the first\n> > output\n> > DEPTH NOT IF ... ELSE\n> > -- skip over the other branch (without violating minimalif rules)\n> > FROMALT SWAP TUCK FROMALT\n> > -- stack contains [X' V' X V' V], altstack contains [SSS]\n> > [K] ADD GREATERTHANOREQUAL VERIFY\n> > -- check V' >= V+K, stack contains [X' V' X]\n> > 1 SWAP FORWARD_TARGET\n> > -- output 1 pays to X (previous bidder's scriptPubKey), and the\n> > entire value of this input goes there; stack contains [X' V']\n> > DUP FORWARD_PARTIAL\n> > -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n> > 0 ROT ROT\n> > -- stack contains [0 X' V']\n> > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n> > that output 0 spends at least V' satoshis back to the same\n> > script (because that's how we defined SSS), except the first\n> > three pushes (previously X V SSS) are replaced by X' V' SSS.\n> > 0\n> > ENDIF\n> > CSV\n> > -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n> > which hopefully makes it harder to pin\n> > 1ADD\n> > -- ends with 1 on the stack; success!\n> >\n> > (The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\n> > ie a program that outputs its own source code)\n> >\n> > I think that script is about 211 witness bytes, with an additional 40\n> > witness bytes for X'/V', so when making a bid, your tx would be\n> > something like:\n> >\n> > tx header, 10vb\n> > input 0: 103vb for the old bid including witness and control block\n> > input 1: 58vb for a taproot key path spend\n> > output 0: 43vb for the new bid\n> > output 1: 43vb for your change\n> >\n> > for a total of about 257vb -- slightly larger than a regular 2-in-2-out\n> > transaction, but not terribly much. Mostly because input 0 doesn't require\n> > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\n> > and the script code twice, along with a little extra to encode the\n> > various numbers (10000, 144, K, V, V').\n> >\n> > This approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\n> > your bid succeeds; if it doesn't, you don't pay any fees. A potential\n> > scalper might want to put in an early low ball bid, then prevent\n> > higher bidders from winning the auction, take control of the ordinal,\n> > and resell it later, but unless they can prevent another miner from\n> > mining alternative bids for 144 blocks, they will fail at that. The bid\n> > is fixed by the bidder and committed to by the signature on input 1, so\n> > frontrunning a bid can't do anything beyond invalidate the bid entirely.\n> >\n> > Obviously, this is a pretty limited auction mechanism in various ways;\n> > eg maybe you'd rather specify K as a percentage than an absoute increment;\n> > maybe you'd like to have the auction definitely finish by some particular\n> > time; maybe you'd like to be able to have the auction be able to continue\n> > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\n> > rather than an english auction. I think you can probably do all those\n> > things with this set of opcodes and clever scripting, though it probably\n> > gets ugly.\n> >\n> > I don't think this is easily extensible to taro or rgb style assets,\n> > as rather than being able to ensure the asset is transferred by\n> > controlling the input/output positions, I think you'd need to build\n> > up merkle trees and do point tweaks beyond what's supported by\n> > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\n> > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\n> > either.\n> >\n> > Cheers,\n> > aj\n> >\n> > [0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n> >\n> > [1] https://twitter.com/jamesob/status/1639019107432513537\n> >\n> > [2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n> >\n> > [3] Inscriptions remain a wasteful way of publishing/committing\n> > to content, however!\n> >\n> > [4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n> >\n> > [5] Setting K too low probably invites griefing, where a bidder may be\n> > able to use rbf pinning vectors to prevent people who would be willing\n> > to bid substantially higher from getting their bid confirmed on\n> > chain.\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev", "summary": "A developer shares the achievements of parasitical use cases of Bitcoin, including increased fees, more users, and developers exploring new features. They advocate for respecting different perspectives to avoid becoming niche like Linux."}, {"author": "Steve Lee", "date": "2023-03-30T00:16:43", "message_text_only": "\"want bitcoin to be money and money means different things for people in\nthis world\"\n\nI think we can all agree that a property of money is fungibility, and by\nits very definition NFTs are not fungible and thus not money.\n\nOn Wed, Mar 29, 2023 at 4:56\u202fPM alicexbt via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Zac,\n>\n> Let me share what those parasites achieved:\n>\n> - Fees paid: 150 BTC\n> - Lot of users and developers trying bitcoin that either never tried or\n> gave up early in 2013-15\n> - Mempools of nodes of being busy on weekends and got lots of transactions\n> - PSBT became cool and application devs are trying their best to use it in\n> different ways\n> - Some developers exploring taproot and multisig\n> - AJ shared things how covenants could help in fair, non-custodial,\n> on-chain auction of ordinals that is MEV resistant although I had shared it\n> earlier which involves more steps:\n> https://twitter.com/1440000bytes/status/1634368411760476161\n> - Investors exploring about funding projects\n> - Bitcoin more than Bitcoin and people excited about it\n>\n> We can have difference of opinion, however I want bitcoin to be money and\n> money means different things for people in this world. Please respect that\n> else it will become like Linux, something used by 1% of world.\n>\n> /dev/fd0\n> floppy disk guy\n>\n> Sent with Proton Mail secure email.\n>\n> ------- Original Message -------\n> On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>\n> > I\u2019m not sure why any effort should be spent on theorizing how new\n> opcodes might be used to facilitate parasitical use cases of the blockchain.\n> >\n> > If anything, business models relying on the ability to abuse the\n> blockchain as a data store must be made less feasible, not more.\n> >\n> > Zac\n> >\n> >\n> > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via\n> bitcoin-dev wrote:\n> > > > I think there are perhaps four opcodes that are interesting in this\n> class:\n> > > >\n> > > > idx sPK OP_FORWARD_TARGET\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output have a particular scriptPubKey (given\n> > > > by sPK).\n> > > >\n> > > > idx [...] n script OP_FORWARD_LEAF_UPDATE\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output to have almost the same scriptPubKey as this\n> > > > input, _except_ that the current leaf is replaced by \"script\",\n> > > > with that script prefixed by \"n\" pushes (of values given by [...])\n> > > >\n> > > > idx OP_FORWARD_SELF\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output to have the same scriptPubKey as this input\n> > > >\n> > > > amt OP_FORWARD_PARTIAL\n> > > > -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n> > > > rather than the entire balance. opcodes after that affect the\n> > > > remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> > > > 0, the next OP_FORWARD_* becomes a no-op.\n> > >\n> > > The BIP 345 draft has been updated [0] [1] and now pretty much defines\n> > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE\n> above,\n> > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\n> > > that, for this email I'm going to continue using the OP_FORWARD_*\n> > > naming convention.\n> > >\n> > > Given the recent controversy over the Yuga labs ordinal auction [2],\n> > > perhaps it's interesting to consider that these proposed opcodes come\n> > > close to making it possible to do a fair, non-custodial, on-chain\n> auction\n> > > of ordinals [3].\n> > >\n> > > The idea here is that you create a utxo on chain that contains the\n> ordinal\n> > > in question, which commits to the address of the current leading\n> bidder,\n> > > and can be spent in two ways:\n> > >\n> > > 1) it can be updated to a new bidder, if the bid is raised by at least\n> > > K satoshis, in which case the previous bidder is refunded their\n> > > bid; or,\n> > >\n> > > 2) if there have been no new bids for a day, the current high bidder\n> > > wins, and the ordinal is moved to their address, while the funds\n> > > from their winning bid are sent to the original vendor's address.\n> > >\n> > > I believe this can be implemented in script as follows,\n> > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\n> > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced\n> above),\n> > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\n> > > are all available.\n> > >\n> > > First, figure out the parameters:\n> > >\n> > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n> > > * Set K to the minimum bid increment [5].\n> > > * Initially, set X equal to VENDOR.\n> > > * Initially, set V to just below the reserve price (V+K is the\n> > > minimum initial bid).\n> > >\n> > > Then construct the following script:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > DEPTH NOT IF\n> > > 0 10000 FORWARD_PARTIAL\n> > > 0 FROMALT FORWARD_TARGET\n> > > 1 [VENDOR] FWD_TARGET\n> > > 144\n> > > ELSE\n> > > FROMALT SWAP TUCK FROMALT\n> > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > 1 SWAP FORWARD_TARGET\n> > > DUP FORWARD_PARTIAL\n> > > 0 ROT ROT\n> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > 0\n> > > ENDIF\n> > > CSV\n> > > 1ADD\n> > >\n> > > where \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n> > > .. 1ADD\").\n> > >\n> > > Finally, make that script the sole tapleaf, accompanied by a NUMS point\n> > > as the internal public key, calculate the taproot address corresponding\n> > > to that, and send the ordinal to that address as the first satoshi.\n> > >\n> > > There are two ways to spend that script. With an empty witness stack,\n> > > the following will be executed:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > -- altstack now contains [SSS V X]\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > -- this input is the first, so the ordinal will move to the first\n> > > output\n> > > DEPTH NOT IF\n> > > -- take this branch: the auction is over!\n> > > 1 [VENDOR] FWD_TARGET\n> > > -- output 1 gets the entire value of this input, and pays to\n> > > the vendor's hardcoded scriptPubKey\n> > > 0 10000 FORWARD_PARTIAL\n> > > 0 FROMALT FORWARD_TARGET\n> > > -- we forward at least 10k sats to output 0 (if there were 0 sats,\n> > > the ordinal would end up in output 1 instead, which would be a\n> > > bug), and output 0 pays to scriptPubKey \"X\"\n> > > 144\n> > > ELSE .. ENDIF\n> > > -- skip over the other branch\n> > > CSV\n> > > -- check that this input has baked for 144 blocks (~1 day)\n> > > 1ADD\n> > > -- leave 145 on the stack, which is true. success!\n> > >\n> > > Alternatively, if you want to increase the bid you provide a stack with\n> > > two items: your scriptPubKey and the new bid [X' V']. Execution this\n> > > time looks like:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > -- stack contains [X' V'], altstack now contains [SSS V X]\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > -- this input is the first, so the ordinal will move to the first\n> > > output\n> > > DEPTH NOT IF ... ELSE\n> > > -- skip over the other branch (without violating minimalif rules)\n> > > FROMALT SWAP TUCK FROMALT\n> > > -- stack contains [X' V' X V' V], altstack contains [SSS]\n> > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > -- check V' >= V+K, stack contains [X' V' X]\n> > > 1 SWAP FORWARD_TARGET\n> > > -- output 1 pays to X (previous bidder's scriptPubKey), and the\n> > > entire value of this input goes there; stack contains [X' V']\n> > > DUP FORWARD_PARTIAL\n> > > -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n> > > 0 ROT ROT\n> > > -- stack contains [0 X' V']\n> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n> > > that output 0 spends at least V' satoshis back to the same\n> > > script (because that's how we defined SSS), except the first\n> > > three pushes (previously X V SSS) are replaced by X' V' SSS.\n> > > 0\n> > > ENDIF\n> > > CSV\n> > > -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n> > > which hopefully makes it harder to pin\n> > > 1ADD\n> > > -- ends with 1 on the stack; success!\n> > >\n> > > (The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\n> > > ie a program that outputs its own source code)\n> > >\n> > > I think that script is about 211 witness bytes, with an additional 40\n> > > witness bytes for X'/V', so when making a bid, your tx would be\n> > > something like:\n> > >\n> > > tx header, 10vb\n> > > input 0: 103vb for the old bid including witness and control block\n> > > input 1: 58vb for a taproot key path spend\n> > > output 0: 43vb for the new bid\n> > > output 1: 43vb for your change\n> > >\n> > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out\n> > > transaction, but not terribly much. Mostly because input 0 doesn't\n> require\n> > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\n> > > and the script code twice, along with a little extra to encode the\n> > > various numbers (10000, 144, K, V, V').\n> > >\n> > > This approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\n> > > your bid succeeds; if it doesn't, you don't pay any fees. A potential\n> > > scalper might want to put in an early low ball bid, then prevent\n> > > higher bidders from winning the auction, take control of the ordinal,\n> > > and resell it later, but unless they can prevent another miner from\n> > > mining alternative bids for 144 blocks, they will fail at that. The bid\n> > > is fixed by the bidder and committed to by the signature on input 1, so\n> > > frontrunning a bid can't do anything beyond invalidate the bid\n> entirely.\n> > >\n> > > Obviously, this is a pretty limited auction mechanism in various ways;\n> > > eg maybe you'd rather specify K as a percentage than an absoute\n> increment;\n> > > maybe you'd like to have the auction definitely finish by some\n> particular\n> > > time; maybe you'd like to be able to have the auction be able to\n> continue\n> > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\n> > > rather than an english auction. I think you can probably do all those\n> > > things with this set of opcodes and clever scripting, though it\n> probably\n> > > gets ugly.\n> > >\n> > > I don't think this is easily extensible to taro or rgb style assets,\n> > > as rather than being able to ensure the asset is transferred by\n> > > controlling the input/output positions, I think you'd need to build\n> > > up merkle trees and do point tweaks beyond what's supported by\n> > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\n> > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\n> > > either.\n> > >\n> > > Cheers,\n> > > aj\n> > >\n> > > [0]\n> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n> > >\n> > > [1] https://twitter.com/jamesob/status/1639019107432513537\n> > >\n> > > [2]\n> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n> > >\n> > > [3] Inscriptions remain a wasteful way of publishing/committing\n> > > to content, however!\n> > >\n> > > [4]\n> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n> > >\n> > > [5] Setting K too low probably invites griefing, where a bidder may be\n> > > able to use rbf pinning vectors to prevent people who would be willing\n> > > to bid substantially higher from getting their bid confirmed on\n> > > chain.\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230329/6f8c48f0/attachment-0001.html>", "summary": "The writer wants Bitcoin to be money, but NFTs are not fungible and thus not money. Parasitical use cases of the blockchain should be made less feasible."}, {"author": "Zac Greenwood", "date": "2023-03-30T10:39:40", "message_text_only": "Hi alicexbtc,\n\nUnder no circumstance should Bitcoin add any functionality intended to\nsupport private businesses that rely on on-chain storage for their business\nmodel.\n\nRegarding \u201cFees paid: 150 BTC\u201d (uh, *citation needed*):\n\nTo optimize for profitability a business would generally attempt to operate\nusing zero- or low-fee transactions. Therefore they tend to contribute\n comparatively little fees but are depriving public use of these cheap\ntransactions. Worse, they exert a constant upward pressure on fee levels,\nmaking it more expensive for everyone else to transact.\n\nUnlike miners, node operators do not receive any compensation. They however\nincur additional cost for bandwidth, electricity and processing time to not\nonly support some current business but all businesses in the past that ever\ntried to turn a profit at their expense, so also after such business failed\nand has been long gone. They foot the bill.\n\nLastly, I don\u2019t believe there is any value in having for instance Ordinals\nspam the blockchain with images of wojaks, bored apes and other crap but\nperhaps you wish to clarify why this might be something to be \u201cexcited\nabout\u201d.\n\nYour other arguments are nonsensical so excuse me for ignoring them.\n\n\nZac\n\n\nOn Thu, 30 Mar 2023 at 03:57, alicexbt <alicexbt at protonmail.com> wrote:\n\n> Hi Zac,\n>\n> Let me share what those parasites achieved:\n>\n> - Fees paid: 150 BTC\n> - Lot of users and developers trying bitcoin that either never tried or\n> gave up early in 2013-15\n> - Mempools of nodes of being busy on weekends and got lots of transactions\n> - PSBT became cool and application devs are trying their best to use it in\n> different ways\n> - Some developers exploring taproot and multisig\n> - AJ shared things how covenants could help in fair, non-custodial,\n> on-chain auction of ordinals that is MEV resistant although I had shared it\n> earlier which involves more steps:\n> https://twitter.com/1440000bytes/status/1634368411760476161\n> - Investors exploring about funding projects\n> - Bitcoin more than Bitcoin and people excited about it\n>\n> We can have difference of opinion, however I want bitcoin to be money and\n> money means different things for people in this world. Please respect that\n> else it will become like Linux, something used by 1% of world.\n>\n> /dev/fd0\n> floppy disk guy\n>\n> Sent with Proton Mail secure email.\n>\n> ------- Original Message -------\n> On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>\n> > I\u2019m not sure why any effort should be spent on theorizing how new\n> opcodes might be used to facilitate parasitical use cases of the blockchain.\n> >\n> > If anything, business models relying on the ability to abuse the\n> blockchain as a data store must be made less feasible, not more.\n> >\n> > Zac\n> >\n> >\n> > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via\n> bitcoin-dev wrote:\n> > > > I think there are perhaps four opcodes that are interesting in this\n> class:\n> > > >\n> > > > idx sPK OP_FORWARD_TARGET\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output have a particular scriptPubKey (given\n> > > > by sPK).\n> > > >\n> > > > idx [...] n script OP_FORWARD_LEAF_UPDATE\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output to have almost the same scriptPubKey as this\n> > > > input, _except_ that the current leaf is replaced by \"script\",\n> > > > with that script prefixed by \"n\" pushes (of values given by [...])\n> > > >\n> > > > idx OP_FORWARD_SELF\n> > > > -- sends the value to a particular output (given by idx), and\n> > > > requires that output to have the same scriptPubKey as this input\n> > > >\n> > > > amt OP_FORWARD_PARTIAL\n> > > > -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n> > > > rather than the entire balance. opcodes after that affect the\n> > > > remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> > > > 0, the next OP_FORWARD_* becomes a no-op.\n> > >\n> > > The BIP 345 draft has been updated [0] [1] and now pretty much defines\n> > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE\n> above,\n> > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\n> > > that, for this email I'm going to continue using the OP_FORWARD_*\n> > > naming convention.\n> > >\n> > > Given the recent controversy over the Yuga labs ordinal auction [2],\n> > > perhaps it's interesting to consider that these proposed opcodes come\n> > > close to making it possible to do a fair, non-custodial, on-chain\n> auction\n> > > of ordinals [3].\n> > >\n> > > The idea here is that you create a utxo on chain that contains the\n> ordinal\n> > > in question, which commits to the address of the current leading\n> bidder,\n> > > and can be spent in two ways:\n> > >\n> > > 1) it can be updated to a new bidder, if the bid is raised by at least\n> > > K satoshis, in which case the previous bidder is refunded their\n> > > bid; or,\n> > >\n> > > 2) if there have been no new bids for a day, the current high bidder\n> > > wins, and the ordinal is moved to their address, while the funds\n> > > from their winning bid are sent to the original vendor's address.\n> > >\n> > > I believe this can be implemented in script as follows,\n> > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\n> > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced\n> above),\n> > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\n> > > are all available.\n> > >\n> > > First, figure out the parameters:\n> > >\n> > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n> > > * Set K to the minimum bid increment [5].\n> > > * Initially, set X equal to VENDOR.\n> > > * Initially, set V to just below the reserve price (V+K is the\n> > > minimum initial bid).\n> > >\n> > > Then construct the following script:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > DEPTH NOT IF\n> > > 0 10000 FORWARD_PARTIAL\n> > > 0 FROMALT FORWARD_TARGET\n> > > 1 [VENDOR] FWD_TARGET\n> > > 144\n> > > ELSE\n> > > FROMALT SWAP TUCK FROMALT\n> > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > 1 SWAP FORWARD_TARGET\n> > > DUP FORWARD_PARTIAL\n> > > 0 ROT ROT\n> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > 0\n> > > ENDIF\n> > > CSV\n> > > 1ADD\n> > >\n> > > where \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n> > > .. 1ADD\").\n> > >\n> > > Finally, make that script the sole tapleaf, accompanied by a NUMS point\n> > > as the internal public key, calculate the taproot address corresponding\n> > > to that, and send the ordinal to that address as the first satoshi.\n> > >\n> > > There are two ways to spend that script. With an empty witness stack,\n> > > the following will be executed:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > -- altstack now contains [SSS V X]\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > -- this input is the first, so the ordinal will move to the first\n> > > output\n> > > DEPTH NOT IF\n> > > -- take this branch: the auction is over!\n> > > 1 [VENDOR] FWD_TARGET\n> > > -- output 1 gets the entire value of this input, and pays to\n> > > the vendor's hardcoded scriptPubKey\n> > > 0 10000 FORWARD_PARTIAL\n> > > 0 FROMALT FORWARD_TARGET\n> > > -- we forward at least 10k sats to output 0 (if there were 0 sats,\n> > > the ordinal would end up in output 1 instead, which would be a\n> > > bug), and output 0 pays to scriptPubKey \"X\"\n> > > 144\n> > > ELSE .. ENDIF\n> > > -- skip over the other branch\n> > > CSV\n> > > -- check that this input has baked for 144 blocks (~1 day)\n> > > 1ADD\n> > > -- leave 145 on the stack, which is true. success!\n> > >\n> > > Alternatively, if you want to increase the bid you provide a stack with\n> > > two items: your scriptPubKey and the new bid [X' V']. Execution this\n> > > time looks like:\n> > >\n> > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > -- stack contains [X' V'], altstack now contains [SSS V X]\n> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > -- this input is the first, so the ordinal will move to the first\n> > > output\n> > > DEPTH NOT IF ... ELSE\n> > > -- skip over the other branch (without violating minimalif rules)\n> > > FROMALT SWAP TUCK FROMALT\n> > > -- stack contains [X' V' X V' V], altstack contains [SSS]\n> > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > -- check V' >= V+K, stack contains [X' V' X]\n> > > 1 SWAP FORWARD_TARGET\n> > > -- output 1 pays to X (previous bidder's scriptPubKey), and the\n> > > entire value of this input goes there; stack contains [X' V']\n> > > DUP FORWARD_PARTIAL\n> > > -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n> > > 0 ROT ROT\n> > > -- stack contains [0 X' V']\n> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n> > > that output 0 spends at least V' satoshis back to the same\n> > > script (because that's how we defined SSS), except the first\n> > > three pushes (previously X V SSS) are replaced by X' V' SSS.\n> > > 0\n> > > ENDIF\n> > > CSV\n> > > -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n> > > which hopefully makes it harder to pin\n> > > 1ADD\n> > > -- ends with 1 on the stack; success!\n> > >\n> > > (The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\n> > > ie a program that outputs its own source code)\n> > >\n> > > I think that script is about 211 witness bytes, with an additional 40\n> > > witness bytes for X'/V', so when making a bid, your tx would be\n> > > something like:\n> > >\n> > > tx header, 10vb\n> > > input 0: 103vb for the old bid including witness and control block\n> > > input 1: 58vb for a taproot key path spend\n> > > output 0: 43vb for the new bid\n> > > output 1: 43vb for your change\n> > >\n> > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out\n> > > transaction, but not terribly much. Mostly because input 0 doesn't\n> require\n> > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\n> > > and the script code twice, along with a little extra to encode the\n> > > various numbers (10000, 144, K, V, V').\n> > >\n> > > This approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\n> > > your bid succeeds; if it doesn't, you don't pay any fees. A potential\n> > > scalper might want to put in an early low ball bid, then prevent\n> > > higher bidders from winning the auction, take control of the ordinal,\n> > > and resell it later, but unless they can prevent another miner from\n> > > mining alternative bids for 144 blocks, they will fail at that. The bid\n> > > is fixed by the bidder and committed to by the signature on input 1, so\n> > > frontrunning a bid can't do anything beyond invalidate the bid\n> entirely.\n> > >\n> > > Obviously, this is a pretty limited auction mechanism in various ways;\n> > > eg maybe you'd rather specify K as a percentage than an absoute\n> increment;\n> > > maybe you'd like to have the auction definitely finish by some\n> particular\n> > > time; maybe you'd like to be able to have the auction be able to\n> continue\n> > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\n> > > rather than an english auction. I think you can probably do all those\n> > > things with this set of opcodes and clever scripting, though it\n> probably\n> > > gets ugly.\n> > >\n> > > I don't think this is easily extensible to taro or rgb style assets,\n> > > as rather than being able to ensure the asset is transferred by\n> > > controlling the input/output positions, I think you'd need to build\n> > > up merkle trees and do point tweaks beyond what's supported by\n> > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\n> > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\n> > > either.\n> > >\n> > > Cheers,\n> > > aj\n> > >\n> > > [0]\n> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n> > >\n> > > [1] https://twitter.com/jamesob/status/1639019107432513537\n> > >\n> > > [2]\n> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n> > >\n> > > [3] Inscriptions remain a wasteful way of publishing/committing\n> > > to content, however!\n> > >\n> > > [4]\n> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n> > >\n> > > [5] Setting K too low probably invites griefing, where a bidder may be\n> > > able to use rbf pinning vectors to prevent people who would be willing\n> > > to bid substantially higher from getting their bid confirmed on\n> > > chain.\n> > > _______________________________________________\n> > > bitcoin-dev mailing list\n> > > bitcoin-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230330/00fa836d/attachment-0001.html>", "summary": "Bitcoin should not add functionality to support private businesses relying on on-chain storage. Such businesses contribute little fees and increase costs for node operators."}, {"author": "alicexbt", "date": "2023-03-30T18:12:46", "message_text_only": "Hi Zac,\n\n> Regarding \u201cFees paid: 150 BTC\u201d (uh, *citation needed*):\n\nhttps://dune.com/queries/2008613/3326984\n\n> Your other arguments are nonsensical so excuse me for ignoring them.\n\nThere were zero browser extensions that could sign PSBT to be used in different bitcoin projects that have web interface earlier. Now there are several open source extensions that could be used to sign PSBT. If such development and interest by developers from other chains to build things on bitcoin makes no sense to you that there is nothing much to debate here.\n\nHumans have inscribed things on money since thousands of years when bitcoin didn't even exist. Trying to fight this and going against market wont work.\n\nI do not agree with other things mentioned in your email.\n\n/dev/fd0\nfloppy disk guy\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Thursday, March 30th, 2023 at 4:09 PM, Zac Greenwood <zachgrw at gmail.com> wrote:\n\n\n> Hi alicexbtc,\n> \n> Under no circumstance should Bitcoin add any functionality intended to support private businesses that rely on on-chain storage for their business model.\n> \n> Regarding \u201cFees paid: 150 BTC\u201d (uh, *citation needed*):\n> \n> To optimize for profitability a business would generally attempt to operate using zero- or low-fee transactions. Therefore they tend to contribute comparatively little fees but are depriving public use of these cheap transactions. Worse, they exert a constant upward pressure on fee levels, making it more expensive for everyone else to transact.\n> \n> Unlike miners, node operators do not receive any compensation. They however incur additional cost for bandwidth, electricity and processing time to not only support some current business but all businesses in the past that ever tried to turn a profit at their expense, so also after such business failed and has been long gone. They foot the bill.\n> \n> Lastly, I don\u2019t believe there is any value in having for instance Ordinals spam the blockchain with images of wojaks, bored apes and other crap but perhaps you wish to clarify why this might be something to be \u201cexcited about\u201d.\n> \n> Your other arguments are nonsensical so excuse me for ignoring them.\n> \n> \n> Zac\n> \n> \n> On Thu, 30 Mar 2023 at 03:57, alicexbt <alicexbt at protonmail.com> wrote:\n> \n> > Hi Zac,\n> > \n> > Let me share what those parasites achieved:\n> > \n> > - Fees paid: 150 BTC\n> > - Lot of users and developers trying bitcoin that either never tried or gave up early in 2013-15\n> > - Mempools of nodes of being busy on weekends and got lots of transactions\n> > - PSBT became cool and application devs are trying their best to use it in different ways\n> > - Some developers exploring taproot and multisig\n> > - AJ shared things how covenants could help in fair, non-custodial, on-chain auction of ordinals that is MEV resistant although I had shared it earlier which involves more steps: https://twitter.com/1440000bytes/status/1634368411760476161\n> > - Investors exploring about funding projects\n> > - Bitcoin more than Bitcoin and people excited about it\n> > \n> > We can have difference of opinion, however I want bitcoin to be money and money means different things for people in this world. Please respect that else it will become like Linux, something used by 1% of world.\n> > \n> > /dev/fd0\n> > floppy disk guy\n> > \n> > Sent with Proton Mail secure email.\n> > \n> > ------- Original Message -------\n> > On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > \n> > \n> > > I\u2019m not sure why any effort should be spent on theorizing how new opcodes might be used to facilitate parasitical use cases of the blockchain.\n> > >\n> > > If anything, business models relying on the ability to abuse the blockchain as a data store must be made less feasible, not more.\n> > >\n> > > Zac\n> > >\n> > >\n> > > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > >\n> > > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:\n> > > > > I think there are perhaps four opcodes that are interesting in this class:\n> > > > >\n> > > > > idx sPK OP_FORWARD_TARGET\n> > > > > -- sends the value to a particular output (given by idx), and\n> > > > > requires that output have a particular scriptPubKey (given\n> > > > > by sPK).\n> > > > >\n> > > > > idx [...] n script OP_FORWARD_LEAF_UPDATE\n> > > > > -- sends the value to a particular output (given by idx), and\n> > > > > requires that output to have almost the same scriptPubKey as this\n> > > > > input, _except_ that the current leaf is replaced by \"script\",\n> > > > > with that script prefixed by \"n\" pushes (of values given by [...])\n> > > > >\n> > > > > idx OP_FORWARD_SELF\n> > > > > -- sends the value to a particular output (given by idx), and\n> > > > > requires that output to have the same scriptPubKey as this input\n> > > > >\n> > > > > amt OP_FORWARD_PARTIAL\n> > > > > -- modifies the next OP_FORWARD_* opcode to only affect \"amt\",\n> > > > > rather than the entire balance. opcodes after that affect the\n> > > > > remaining balance, after \"amt\" has been subtracted. if \"amt\" is\n> > > > > 0, the next OP_FORWARD_* becomes a no-op.\n> > > >\n> > > > The BIP 345 draft has been updated [0] [1] and now pretty much defines\n> > > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,\n> > > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite\n> > > > that, for this email I'm going to continue using the OP_FORWARD_*\n> > > > naming convention.\n> > > >\n> > > > Given the recent controversy over the Yuga labs ordinal auction [2],\n> > > > perhaps it's interesting to consider that these proposed opcodes come\n> > > > close to making it possible to do a fair, non-custodial, on-chain auction\n> > > > of ordinals [3].\n> > > >\n> > > > The idea here is that you create a utxo on chain that contains the ordinal\n> > > > in question, which commits to the address of the current leading bidder,\n> > > > and can be spent in two ways:\n> > > >\n> > > > 1) it can be updated to a new bidder, if the bid is raised by at least\n> > > > K satoshis, in which case the previous bidder is refunded their\n> > > > bid; or,\n> > > >\n> > > > 2) if there have been no new bids for a day, the current high bidder\n> > > > wins, and the ordinal is moved to their address, while the funds\n> > > > from their winning bid are sent to the original vendor's address.\n> > > >\n> > > > I believe this can be implemented in script as follows,\n> > > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),\n> > > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),\n> > > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])\n> > > > are all available.\n> > > >\n> > > > First, figure out the parameters:\n> > > >\n> > > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.\n> > > > * Set K to the minimum bid increment [5].\n> > > > * Initially, set X equal to VENDOR.\n> > > > * Initially, set V to just below the reserve price (V+K is the\n> > > > minimum initial bid).\n> > > >\n> > > > Then construct the following script:\n> > > >\n> > > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > > DEPTH NOT IF\n> > > > 0 10000 FORWARD_PARTIAL\n> > > > 0 FROMALT FORWARD_TARGET\n> > > > 1 [VENDOR] FWD_TARGET\n> > > > 144\n> > > > ELSE\n> > > > FROMALT SWAP TUCK FROMALT\n> > > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > > 1 SWAP FORWARD_TARGET\n> > > > DUP FORWARD_PARTIAL\n> > > > 0 ROT ROT\n> > > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > > 0\n> > > > ENDIF\n> > > > CSV\n> > > > 1ADD\n> > > >\n> > > > where \"SSS\" is a pushdata of the rest of the script (\"TOALT TOALT TOALT\n> > > > .. 1ADD\").\n> > > >\n> > > > Finally, make that script the sole tapleaf, accompanied by a NUMS point\n> > > > as the internal public key, calculate the taproot address corresponding\n> > > > to that, and send the ordinal to that address as the first satoshi.\n> > > >\n> > > > There are two ways to spend that script. With an empty witness stack,\n> > > > the following will be executed:\n> > > >\n> > > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > > -- altstack now contains [SSS V X]\n> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > > -- this input is the first, so the ordinal will move to the first\n> > > > output\n> > > > DEPTH NOT IF\n> > > > -- take this branch: the auction is over!\n> > > > 1 [VENDOR] FWD_TARGET\n> > > > -- output 1 gets the entire value of this input, and pays to\n> > > > the vendor's hardcoded scriptPubKey\n> > > > 0 10000 FORWARD_PARTIAL\n> > > > 0 FROMALT FORWARD_TARGET\n> > > > -- we forward at least 10k sats to output 0 (if there were 0 sats,\n> > > > the ordinal would end up in output 1 instead, which would be a\n> > > > bug), and output 0 pays to scriptPubKey \"X\"\n> > > > 144\n> > > > ELSE .. ENDIF\n> > > > -- skip over the other branch\n> > > > CSV\n> > > > -- check that this input has baked for 144 blocks (~1 day)\n> > > > 1ADD\n> > > > -- leave 145 on the stack, which is true. success!\n> > > >\n> > > > Alternatively, if you want to increase the bid you provide a stack with\n> > > > two items: your scriptPubKey and the new bid [X' V']. Execution this\n> > > > time looks like:\n> > > >\n> > > > [X] [V] [SSS] TOALT TOALT TOALT\n> > > > -- stack contains [X' V'], altstack now contains [SSS V X]\n> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY\n> > > > -- this input is the first, so the ordinal will move to the first\n> > > > output\n> > > > DEPTH NOT IF ... ELSE\n> > > > -- skip over the other branch (without violating minimalif rules)\n> > > > FROMALT SWAP TUCK FROMALT\n> > > > -- stack contains [X' V' X V' V], altstack contains [SSS]\n> > > > [K] ADD GREATERTHANOREQUAL VERIFY\n> > > > -- check V' >= V+K, stack contains [X' V' X]\n> > > > 1 SWAP FORWARD_TARGET\n> > > > -- output 1 pays to X (previous bidder's scriptPubKey), and the\n> > > > entire value of this input goes there; stack contains [X' V']\n> > > > DUP FORWARD_PARTIAL\n> > > > -- execute \"V' FORWARD_PARTIAL\", stack contains [X' V']\n> > > > 0 ROT ROT\n> > > > -- stack contains [0 X' V']\n> > > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE\n> > > > -- execute \"0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE\" which checks\n> > > > that output 0 spends at least V' satoshis back to the same\n> > > > script (because that's how we defined SSS), except the first\n> > > > three pushes (previously X V SSS) are replaced by X' V' SSS.\n> > > > 0\n> > > > ENDIF\n> > > > CSV\n> > > > -- \"0 CSV\" requires nSequnce to be set, which makes the tx rbf'able,\n> > > > which hopefully makes it harder to pin\n> > > > 1ADD\n> > > > -- ends with 1 on the stack; success!\n> > > >\n> > > > (The \"SSS n SSS FORWARD_LEAF_UPDATE\" construct is more or less a quine,\n> > > > ie a program that outputs its own source code)\n> > > >\n> > > > I think that script is about 211 witness bytes, with an additional 40\n> > > > witness bytes for X'/V', so when making a bid, your tx would be\n> > > > something like:\n> > > >\n> > > > tx header, 10vb\n> > > > input 0: 103vb for the old bid including witness and control block\n> > > > input 1: 58vb for a taproot key path spend\n> > > > output 0: 43vb for the new bid\n> > > > output 1: 43vb for your change\n> > > >\n> > > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out\n> > > > transaction, but not terribly much. Mostly because input 0 doesn't require\n> > > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,\n> > > > and the script code twice, along with a little extra to encode the\n> > > > various numbers (10000, 144, K, V, V').\n> > > >\n> > > > This approach seems pretty \"MEV\" resistant: you pay fees via input 1 if\n> > > > your bid succeeds; if it doesn't, you don't pay any fees. A potential\n> > > > scalper might want to put in an early low ball bid, then prevent\n> > > > higher bidders from winning the auction, take control of the ordinal,\n> > > > and resell it later, but unless they can prevent another miner from\n> > > > mining alternative bids for 144 blocks, they will fail at that. The bid\n> > > > is fixed by the bidder and committed to by the signature on input 1, so\n> > > > frontrunning a bid can't do anything beyond invalidate the bid entirely.\n> > > >\n> > > > Obviously, this is a pretty limited auction mechanism in various ways;\n> > > > eg maybe you'd rather specify K as a percentage than an absoute increment;\n> > > > maybe you'd like to have the auction definitely finish by some particular\n> > > > time; maybe you'd like to be able to have the auction be able to continue\n> > > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction\n> > > > rather than an english auction. I think you can probably do all those\n> > > > things with this set of opcodes and clever scripting, though it probably\n> > > > gets ugly.\n> > > >\n> > > > I don't think this is easily extensible to taro or rgb style assets,\n> > > > as rather than being able to ensure the asset is transferred by\n> > > > controlling the input/output positions, I think you'd need to build\n> > > > up merkle trees and do point tweaks beyond what's supported by\n> > > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like\n> > > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals\n> > > > either.\n> > > >\n> > > > Cheers,\n> > > > aj\n> > > >\n> > > > [0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki\n> > > >\n> > > > [1] https://twitter.com/jamesob/status/1639019107432513537\n> > > >\n> > > > [2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism\n> > > >\n> > > > [3] Inscriptions remain a wasteful way of publishing/committing\n> > > > to content, however!\n> > > >\n> > > > [4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md\n> > > >\n> > > > [5] Setting K too low probably invites griefing, where a bidder may be\n> > > > able to use rbf pinning vectors to prevent people who would be willing\n> > > > to bid substantially higher from getting their bid confirmed on\n> > > > chain.\n> > > > _______________________________________________\n> > > > bitcoin-dev mailing list\n> > > > bitcoin-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev", "summary": "Alicexbt argues that businesses using on-chain storage should be allowed in Bitcoin, as it attracts developers and users, and several open-source extensions can now sign PSBT."}, {"author": "Brandon Black", "date": "2023-03-13T19:03:30", "message_text_only": "Hi Gents,\n\n> > I don't think replacing the internal-public-key makes sense -- if it\n> was immediately spendable via the keypath before there's no reason for\n> it not to be immediately spendable now.\n> \n> Slavishly following the current proposal was the idea to make sure all\n> functionality was captured; I agree with this change.\n\nI think we do need to replace the internal key with a hardcoded NUMS\npoint to allow us to batch multiple vault inputs which might have\ndifferent internal keys but the same OP_FLU/OP_VAULT_TRIGGER script to\nthe same time+template-restricted output.\n\nI like that in James' current PR proposal we can explicitly batch via\nthe implied input/output summation rules while avoiding address reuse.\nIf we can retain some or all of that, I think it would be good for on\nchain efficiency and potentially privacy.\n\nMy thoughts on batching:\n\nMany inputs with different internal keys can be combined to satisfy the\ntotal output value for a single output, as long as their scriptpubkeys\nwith FLU and NUMS internal key are equal This enables avoiding address\nreuse within the vault.\n\nMany inputs with the same scriptpubkey can be combined to satisfy a\nsingle CTV output template. This allows a user to unfsck themselves if\nthey initiate a withdrawal that cannot be satisfied because they didn't\nsend enough sats to satisfy their template.\n\nBest,\n\n--Brandon", "summary": "Brandon suggests replacing the internal key with a hardcoded NUMS point to enable batching of multiple vault inputs with the same scriptpubkey."}, {"author": "Greg Sanders", "date": "2023-03-14T14:40:53", "message_text_only": "Hi Brandon,\n\nThank you for chiming in, causing me to think a bit more deeply on the\nprivacy issues\nand what seems possible.\n\n> I like that in James' current PR proposal we can explicitly batch via\nthe implied input/output summation rules while avoiding address reuse.\nIf we can retain some or all of that, I think it would be good for on\nchain efficiency and potentially privacy.\n\nRotating trigger authorization keys maintains batchability and stops\naddress reuse.\nRemember that anytime you share any path, like recovery path, for batching,\nit becomes\nobvious at spend-time. Rotating inner pubkeys only doesn't seem to help\nmuch.\n\nCoinjoins being the other batching scenario which could benefit perhaps are\nquite a heavy\nlift. You'd need the recovery policy(every other branch) to be agreed upon,\nhave everyone unvault\nto this new joint vault, then mix, and withdrawal back to the original\nvault. If someone is going through\nall that effort, I suspect they'll just use a NUMS to reduce fingerprinting.\n\n> Many inputs with different internal keys can be combined to satisfy the\ntotal output value for a single output, as long as their scriptpubkeys\nwith FLU and NUMS internal key are equal This enables avoiding address\nreuse within the vault.\n\nTo reiterate, we can just cycle any key in the $trigger branch with OP_FLU,\nwhich accomplishes the same thing.\nOr in authorization-less $trigger, add a random number which is dropped.\n\n> Many inputs with the same scriptpubkey can be combined to satisfy a\nsingle CTV output template. This allows a user to unfsck themselves if\nthey initiate a withdrawal that cannot be satisfied because they didn't\nsend enough sats to satisfy their template.\n\nI think that would fit the deprecated OP_FORWARD_OUTPUTS, but OP_CTV\ncommits to total\nnumber of inputs to remove txid malleability. I think the real solution to\nthis mistake would be to hit\nthe big red RECOVERY button that you're relying on for vault security\nanyways.\n\nCheers,\nGreg\n\nOn Mon, Mar 13, 2023 at 3:04\u202fPM Brandon Black <freedom at reardencode.com>\nwrote:\n\n> Hi Gents,\n>\n> > > I don't think replacing the internal-public-key makes sense -- if it\n> > was immediately spendable via the keypath before there's no reason for\n> > it not to be immediately spendable now.\n> >\n> > Slavishly following the current proposal was the idea to make sure all\n> > functionality was captured; I agree with this change.\n>\n> I think we do need to replace the internal key with a hardcoded NUMS\n> point to allow us to batch multiple vault inputs which might have\n> different internal keys but the same OP_FLU/OP_VAULT_TRIGGER script to\n> the same time+template-restricted output.\n>\n> I like that in James' current PR proposal we can explicitly batch via\n> the implied input/output summation rules while avoiding address reuse.\n> If we can retain some or all of that, I think it would be good for on\n> chain efficiency and potentially privacy.\n>\n> My thoughts on batching:\n>\n> Many inputs with different internal keys can be combined to satisfy the\n> total output value for a single output, as long as their scriptpubkeys\n> with FLU and NUMS internal key are equal This enables avoiding address\n> reuse within the vault.\n>\n> Many inputs with the same scriptpubkey can be combined to satisfy a\n> single CTV output template. This allows a user to unfsck themselves if\n> they initiate a withdrawal that cannot be satisfied because they didn't\n> send enough sats to satisfy their template.\n>\n> Best,\n>\n> --Brandon\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230314/b2e848e8/attachment.html>", "summary": "Discussion on privacy and efficiency in Bitcoin vaults, including rotating trigger authorization keys and batching multiple inputs with different internal keys."}, {"author": "Luke Dashjr", "date": "2023-03-11T20:53:21", "message_text_only": "I started reviewing the BIP, but stopped part way through, as it seems \nto have a number of conceptual issues.\n\nI left several comments on the PR \n(https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575), \nbut ultimately I think it isn't simplified enough for day-to-day use, \nand would harm privacy quite a bit.\n\nInstead, I would suggest a new approach where:\n\n1) Joe receives funds with a taproot output like normal.\n2) Joe sends funds to Fred, but Fred cannot spend them until N blocks \nlater (covenant-enforced relative locktime). Ideally, this should \nuse/support a taproot keypath spend somehow. It would be nice to blind \nthe particular relative locktime somehow too, but that may be too expensive.\n2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N \nblock window to a recovery output.\n\nUnfortunately, the implementation details for this kind of setup are \nnon-obvious and will likely require yet another address format (or at \nleast recipient-wallet changes), but certainly seems within the scope of \npossibility.\n\nThoughts?\n\nLuke\n\n\nOn 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:\n> Since the last related correspondence on this list [0], a number of\n> improvements have been made to the OP_VAULT draft [1]:\n>\n> * There is no longer a hard dependence on package relay/ephemeral\n> \u00a0 anchors for fee management. When using \"authorized recovery,\" all\n> \u00a0 vault-related transactions can be bundled with unrelated inputs and\n> \u00a0 outputs, facilitating fee management that is self contained to the\n> \u00a0 transaction. Consequently, the contents of this proposal are in theory\n> \u00a0 usable today.\n>\n> * Specific output locations are no longer hardcoded in any of the\n> \u00a0 transaction validation algorithms. This means that the proposal is now\n> \u00a0 compatible with future changes like SIGHASH_GROUP, and\n> \u00a0 transaction shapes for vault operations are more flexible.\n>\n> ---\n>\n> I've written a BIP that fully describes the proposal here:\n>\n> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n>\n> The corresponding PR is here:\n>\n> https://github.com/bitcoin/bips/pull/1421\n>\n> My next steps will be to try for a merge to the inquisition repo.\n>\n> Thanks to everyone who has participated so far, but especially to AJ and\n> Greg for all the advice.\n>\n> James\n>\n> [0]: \n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n> [1]: https://github.com/bitcoin/bitcoin/pull/26857\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev", "summary": "Luke reviewed the BIP but found conceptual issues and suggested a new approach for day-to-day use that would improve privacy. James O'Beirne proposed improvements to the OP_VAULT draft."}, {"author": "Greg Sanders", "date": "2023-03-13T14:55:05", "message_text_only": "Hi Luke,\n\nCan you elaborate why the current idealized functionality of deposit ->\ntrigger -> withdrawal is too complicated for\neveryday use but the above deposit -> withdrawal ->\nresolve(claim/clawback)  wouldn't be? I admit at a high level\nit's a fine paradigm, but in practice would end\n\nLet's ignore implementation for the discussion, since that's in flux.\n\nCheers,\nGreg\n\nOn Sat, Mar 11, 2023 at 3:53\u202fPM Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I started reviewing the BIP, but stopped part way through, as it seems\n> to have a number of conceptual issues.\n>\n> I left several comments on the PR\n> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),\n> but ultimately I think it isn't simplified enough for day-to-day use,\n> and would harm privacy quite a bit.\n>\n> Instead, I would suggest a new approach where:\n>\n> 1) Joe receives funds with a taproot output like normal.\n> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks\n> later (covenant-enforced relative locktime). Ideally, this should\n> use/support a taproot keypath spend somehow. It would be nice to blind\n> the particular relative locktime somehow too, but that may be too\n> expensive.\n> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N\n> block window to a recovery output.\n>\n> Unfortunately, the implementation details for this kind of setup are\n> non-obvious and will likely require yet another address format (or at\n> least recipient-wallet changes), but certainly seems within the scope of\n> possibility.\n>\n> Thoughts?\n>\n> Luke\n>\n>\n> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:\n> > Since the last related correspondence on this list [0], a number of\n> > improvements have been made to the OP_VAULT draft [1]:\n> >\n> > * There is no longer a hard dependence on package relay/ephemeral\n> >   anchors for fee management. When using \"authorized recovery,\" all\n> >   vault-related transactions can be bundled with unrelated inputs and\n> >   outputs, facilitating fee management that is self contained to the\n> >   transaction. Consequently, the contents of this proposal are in theory\n> >   usable today.\n> >\n> > * Specific output locations are no longer hardcoded in any of the\n> >   transaction validation algorithms. This means that the proposal is now\n> >   compatible with future changes like SIGHASH_GROUP, and\n> >   transaction shapes for vault operations are more flexible.\n> >\n> > ---\n> >\n> > I've written a BIP that fully describes the proposal here:\n> >\n> >\n> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n> >\n> > The corresponding PR is here:\n> >\n> > https://github.com/bitcoin/bips/pull/1421\n> >\n> > My next steps will be to try for a merge to the inquisition repo.\n> >\n> > Thanks to everyone who has participated so far, but especially to AJ and\n> > Greg for all the advice.\n> >\n> > James\n> >\n> > [0]:\n> >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n> > [1]: https://github.com/bitcoin/bitcoin/pull/26857\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/922ebcb6/attachment.html>", "summary": "A proposed improvement to the OP_VAULT draft is deemed too complicated and harmful to privacy, and a new approach is suggested involving a covenant-enforced relative locktime."}, {"author": "Greg Sanders", "date": "2023-03-13T14:56:15", "message_text_only": "Didn't finish sentence: but in practice would end up with pretty similar\nusage flows imho, and as noted in PR, would take a different wallet\nparadigm,\namong other technical challenges.\n\nOn Mon, Mar 13, 2023 at 10:55\u202fAM Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> Hi Luke,\n>\n> Can you elaborate why the current idealized functionality of deposit ->\n> trigger -> withdrawal is too complicated for\n> everyday use but the above deposit -> withdrawal ->\n> resolve(claim/clawback)  wouldn't be? I admit at a high level\n> it's a fine paradigm, but in practice would end\n>\n> Let's ignore implementation for the discussion, since that's in flux.\n>\n> Cheers,\n> Greg\n>\n> On Sat, Mar 11, 2023 at 3:53\u202fPM Luke Dashjr via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I started reviewing the BIP, but stopped part way through, as it seems\n>> to have a number of conceptual issues.\n>>\n>> I left several comments on the PR\n>> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),\n>>\n>> but ultimately I think it isn't simplified enough for day-to-day use,\n>> and would harm privacy quite a bit.\n>>\n>> Instead, I would suggest a new approach where:\n>>\n>> 1) Joe receives funds with a taproot output like normal.\n>> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks\n>> later (covenant-enforced relative locktime). Ideally, this should\n>> use/support a taproot keypath spend somehow. It would be nice to blind\n>> the particular relative locktime somehow too, but that may be too\n>> expensive.\n>> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N\n>> block window to a recovery output.\n>>\n>> Unfortunately, the implementation details for this kind of setup are\n>> non-obvious and will likely require yet another address format (or at\n>> least recipient-wallet changes), but certainly seems within the scope of\n>> possibility.\n>>\n>> Thoughts?\n>>\n>> Luke\n>>\n>>\n>> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:\n>> > Since the last related correspondence on this list [0], a number of\n>> > improvements have been made to the OP_VAULT draft [1]:\n>> >\n>> > * There is no longer a hard dependence on package relay/ephemeral\n>> >   anchors for fee management. When using \"authorized recovery,\" all\n>> >   vault-related transactions can be bundled with unrelated inputs and\n>> >   outputs, facilitating fee management that is self contained to the\n>> >   transaction. Consequently, the contents of this proposal are in theory\n>> >   usable today.\n>> >\n>> > * Specific output locations are no longer hardcoded in any of the\n>> >   transaction validation algorithms. This means that the proposal is now\n>> >   compatible with future changes like SIGHASH_GROUP, and\n>> >   transaction shapes for vault operations are more flexible.\n>> >\n>> > ---\n>> >\n>> > I've written a BIP that fully describes the proposal here:\n>> >\n>> >\n>> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n>> >\n>> > The corresponding PR is here:\n>> >\n>> > https://github.com/bitcoin/bips/pull/1421\n>> >\n>> > My next steps will be to try for a merge to the inquisition repo.\n>> >\n>> > Thanks to everyone who has participated so far, but especially to AJ and\n>> > Greg for all the advice.\n>> >\n>> > James\n>> >\n>> > [0]:\n>> >\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n>> > [1]: https://github.com/bitcoin/bitcoin/pull/26857\n>> >\n>> > _______________________________________________\n>> > bitcoin-dev mailing list\n>> > bitcoin-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/263bfcdc/attachment.html>", "summary": "A proposed improvement to Bitcoin's OP_VAULT draft suggests a new approach for day-to-day use, which would harm privacy less and require a new address format."}, {"author": "Luke Dashjr", "date": "2023-03-13T20:55:00", "message_text_only": "In ordinary use cases, you wouldn't clawback; that would only be in the \nextreme case of the wallet being compromised. So typical usage would \njust be receive -> send, like wallets currently do.\n\nLuke\n\n\nOn 3/13/23 10:56, Greg Sanders wrote:\n> Didn't finish sentence: but in practice would end up with pretty \n> similar usage flows imho, and as noted in PR, would take a different \n> wallet paradigm,\n> among other technical challenges.\n>\n> On Mon, Mar 13, 2023 at 10:55\u202fAM Greg Sanders <gsanders87 at gmail.com> \n> wrote:\n>\n>     Hi Luke,\n>\n>     Can you elaborate why the current idealized functionality of\n>     deposit\u00a0-> trigger -> withdrawal is too complicated for\n>     everyday use but the above deposit -> withdrawal ->\n>     resolve(claim/clawback)\u00a0 wouldn't be? I admit at a high level\n>     it's a fine paradigm, but in practice would end\n>\n>     Let's ignore implementation for the discussion, since that's in flux.\n>\n>     Cheers,\n>     Greg\n>\n>     On Sat, Mar 11, 2023 at 3:53\u202fPM Luke Dashjr via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>         I started reviewing the BIP, but stopped part way through, as\n>         it seems\n>         to have a number of conceptual issues.\n>\n>         I left several comments on the PR\n>         (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),\n>\n>         but ultimately I think it isn't simplified enough for\n>         day-to-day use,\n>         and would harm privacy quite a bit.\n>\n>         Instead, I would suggest a new approach where:\n>\n>         1) Joe receives funds with a taproot output like normal.\n>         2) Joe sends funds to Fred, but Fred cannot spend them until N\n>         blocks\n>         later (covenant-enforced relative locktime). Ideally, this should\n>         use/support a taproot keypath spend somehow. It would be nice\n>         to blind\n>         the particular relative locktime somehow too, but that may be\n>         too expensive.\n>         2b) If Joe's funds were stolen, Joe can spend Fred's UTXO\n>         within the N\n>         block window to a recovery output.\n>\n>         Unfortunately, the implementation details for this kind of\n>         setup are\n>         non-obvious and will likely require yet another address format\n>         (or at\n>         least recipient-wallet changes), but certainly seems within\n>         the scope of\n>         possibility.\n>\n>         Thoughts?\n>\n>         Luke\n>\n>\n>         On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:\n>         > Since the last related correspondence on this list [0], a\n>         number of\n>         > improvements have been made to the OP_VAULT draft [1]:\n>         >\n>         > * There is no longer a hard dependence on package\n>         relay/ephemeral\n>         > \u00a0 anchors for fee management. When using \"authorized\n>         recovery,\" all\n>         > \u00a0 vault-related transactions can be bundled with unrelated\n>         inputs and\n>         > \u00a0 outputs, facilitating fee management that is self\n>         contained to the\n>         > \u00a0 transaction. Consequently, the contents of this proposal\n>         are in theory\n>         > \u00a0 usable today.\n>         >\n>         > * Specific output locations are no longer hardcoded in any\n>         of the\n>         > \u00a0 transaction validation algorithms. This means that the\n>         proposal is now\n>         > \u00a0 compatible with future changes like SIGHASH_GROUP, and\n>         > \u00a0 transaction shapes for vault operations are more flexible.\n>         >\n>         > ---\n>         >\n>         > I've written a BIP that fully describes the proposal here:\n>         >\n>         >\n>         https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n>         >\n>         > The corresponding PR is here:\n>         >\n>         > https://github.com/bitcoin/bips/pull/1421\n>         >\n>         > My next steps will be to try for a merge to the inquisition\n>         repo.\n>         >\n>         > Thanks to everyone who has participated so far, but\n>         especially to AJ and\n>         > Greg for all the advice.\n>         >\n>         > James\n>         >\n>         > [0]:\n>         >\n>         https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n>         > [1]: https://github.com/bitcoin/bitcoin/pull/26857\n>         >\n>         > _______________________________________________\n>         > bitcoin-dev mailing list\n>         > bitcoin-dev at lists.linuxfoundation.org\n>         > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>         _______________________________________________\n>         bitcoin-dev mailing list\n>         bitcoin-dev at lists.linuxfoundation.org\n>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/1ee9a035/attachment.html>", "summary": "A proposed BIP for a deposit -> withdrawal -> resolve(claim/clawback) wallet paradigm is deemed too complicated for everyday use and may harm privacy. A new approach is suggested."}, {"author": "Greg Sanders", "date": "2023-03-16T14:44:33", "message_text_only": "Hi Luke,\n\nI think this works as with OP_FLU based construct, for the simplest single\nkey case.\n\ne.g., single key hot wallet(or MuSig2/FROST wallet)\n\n<hot_pubkey> 1 \"<time-delay> OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG\"\nOP_FORWARD_LEAF_UPDATE\n\nThe <hot_pubkey> is appended at spending time.\n\nThis allows the utxo to go to $recover cold storage at any point like\nbefore, otherwise the time matures and the funds can be spent by a single\nkey. Rate-limiting like usual can be bolted on as well using OP_FORWARD_*\nopcodes, I'm pretty sure. This would as you note require wallet support,\nwhere the hot wallet would have to be aware of the vault, or be scanning\ninputs looking for this type of leaf.\n\nUnfortunately this doesn't extend to things like OP_CHECKSIGADD, since the\npubkeys are all pushed first, then the opcodes run. OP_CHECKMULTISIG would\nhave worked probably.\n\nTo generalize I think you'd need recursive taproot, or a proper replacement\nfor Bitcoin script :)\n\nCheers,\nGreg\n\nOn Mon, Mar 13, 2023 at 4:55\u202fPM Luke Dashjr <luke at dashjr.org> wrote:\n\n> In ordinary use cases, you wouldn't clawback; that would only be in the\n> extreme case of the wallet being compromised. So typical usage would just\n> be receive -> send, like wallets currently do.\n>\n> Luke\n>\n>\n> On 3/13/23 10:56, Greg Sanders wrote:\n>\n> Didn't finish sentence: but in practice would end up with pretty similar\n> usage flows imho, and as noted in PR, would take a different wallet\n> paradigm,\n> among other technical challenges.\n>\n> On Mon, Mar 13, 2023 at 10:55\u202fAM Greg Sanders <gsanders87 at gmail.com>\n> wrote:\n>\n>> Hi Luke,\n>>\n>> Can you elaborate why the current idealized functionality of deposit ->\n>> trigger -> withdrawal is too complicated for\n>> everyday use but the above deposit -> withdrawal ->\n>> resolve(claim/clawback)  wouldn't be? I admit at a high level\n>> it's a fine paradigm, but in practice would end\n>>\n>> Let's ignore implementation for the discussion, since that's in flux.\n>>\n>> Cheers,\n>> Greg\n>>\n>> On Sat, Mar 11, 2023 at 3:53\u202fPM Luke Dashjr via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> I started reviewing the BIP, but stopped part way through, as it seems\n>>> to have a number of conceptual issues.\n>>>\n>>> I left several comments on the PR\n>>> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),\n>>>\n>>> but ultimately I think it isn't simplified enough for day-to-day use,\n>>> and would harm privacy quite a bit.\n>>>\n>>> Instead, I would suggest a new approach where:\n>>>\n>>> 1) Joe receives funds with a taproot output like normal.\n>>> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks\n>>> later (covenant-enforced relative locktime). Ideally, this should\n>>> use/support a taproot keypath spend somehow. It would be nice to blind\n>>> the particular relative locktime somehow too, but that may be too\n>>> expensive.\n>>> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N\n>>> block window to a recovery output.\n>>>\n>>> Unfortunately, the implementation details for this kind of setup are\n>>> non-obvious and will likely require yet another address format (or at\n>>> least recipient-wallet changes), but certainly seems within the scope of\n>>> possibility.\n>>>\n>>> Thoughts?\n>>>\n>>> Luke\n>>>\n>>>\n>>> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:\n>>> > Since the last related correspondence on this list [0], a number of\n>>> > improvements have been made to the OP_VAULT draft [1]:\n>>> >\n>>> > * There is no longer a hard dependence on package relay/ephemeral\n>>> >   anchors for fee management. When using \"authorized recovery,\" all\n>>> >   vault-related transactions can be bundled with unrelated inputs and\n>>> >   outputs, facilitating fee management that is self contained to the\n>>> >   transaction. Consequently, the contents of this proposal are in\n>>> theory\n>>> >   usable today.\n>>> >\n>>> > * Specific output locations are no longer hardcoded in any of the\n>>> >   transaction validation algorithms. This means that the proposal is\n>>> now\n>>> >   compatible with future changes like SIGHASH_GROUP, and\n>>> >   transaction shapes for vault operations are more flexible.\n>>> >\n>>> > ---\n>>> >\n>>> > I've written a BIP that fully describes the proposal here:\n>>> >\n>>> >\n>>> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n>>> >\n>>> > The corresponding PR is here:\n>>> >\n>>> > https://github.com/bitcoin/bips/pull/1421\n>>> >\n>>> > My next steps will be to try for a merge to the inquisition repo.\n>>> >\n>>> > Thanks to everyone who has participated so far, but especially to AJ\n>>> and\n>>> > Greg for all the advice.\n>>> >\n>>> > James\n>>> >\n>>> > [0]:\n>>> >\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n>>> > [1]: https://github.com/bitcoin/bitcoin/pull/26857\n>>> >\n>>> > _______________________________________________\n>>> > bitcoin-dev mailing list\n>>> > bitcoin-dev at lists.linuxfoundation.org\n>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230316/89c8d041/attachment.html>", "summary": "Greg suggests a single key hot wallet or MuSig2/FROST wallet with OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG for simple single key cases. This allows funds to be spent by a single key after a time delay, and rate-limiting can be added using OP_FORWARD_* opcodes. However, this does not extend to OP_CHECKSIGADD, and a recursive taproot or proper replacement for Bitcoin script may be needed for generalization."}], "thread_summary": {"title": "BIP for OP_VAULT", "categories": ["bitcoin-dev"], "authors": ["Steve Lee", "Brandon Black", "Anthony Towns", "Andrew Melnychuk Oseen", "alicexbt", "Luke Dashjr", "Zac Greenwood", "James O'Beirne", "Greg Sanders"], "messages_count": 22, "total_messages_chars_count": 151637, "convo_summary": "Developers propose new opcodes and scripts for Bitcoin's OP_VAULT to improve legibility, simplify the spec, and reduce theft risk during watchtower outages. They also suggest new opcodes for conditional transactions and withdrawal authorization, while some argue against facilitating parasitical use cases of the blockchain. Discussions also touch on privacy and efficiency in Bitcoin vaults."}}, {"title": "[bitcoin-dev] BIP proposal: Fee-redistribution contracts", "thread_messages": [{"author": "David A. Harding", "date": "2023-03-01T17:17:58", "message_text_only": "On 2023-02-27 03:32, Rastislav Budinsky via bitcoin-dev wrote:\n> When a miner mines a block he takes all the fees currently. However\n> with the proposed solution he takes only fraction M and remaining\n> fraction C is sent to one of more contracts. One contract at its\n> simplest collects fees from the miner and at the same time\n> redistributes it back to the miner.\n\nHi Rastislav,\n\nI think you've incorrectly made the assumption that the only way a miner \ncan profit from confirming a transaction is by collecting its \ntransaction fees.  Miners can (and many have) accept payment through \nalternative means, which the Bitcoin technical community often calls \n\"out-of-band fees\".[1]  For example, some miners have provided a \n\"transaction accelerator\" service that accepts fiat-denominated credit \ncards to increase their prioritization of certain transactions and I'm \npersonally aware of a large web wallet provider that would occasionally \npay miners out of band to confirm hundreds or thousands of transactions \nrather than fix its broken fee estimation.\n\nOut-of-band fees aren't frequently used in Bitcoin today because they \nhave no advantage over correctly estimated in-band fees, and good fee \nestimation is very accessible to modern wallets.  However, if the \nconsensus rules are changed to require each miner pay a percentage of \nits in-band fees to future miners, then there would be a strong \nincentive for them to prefer out-of-band fees that weren't subject to \nthis redistribution scheme.\n\nI think may have seen a variation on the scheme you propose play out in \nreal life.  Here's how it works where I live: the government imposes \ntaxes on goods, services, and income.  Ostensibly, it redistributes the \ncollected funds back to citizens in the future by providing government \nservices.  When I go to pay someone who trusts my discretion, they often \noffer me a discounted rate if I pay in a way that isn't reported to the \ngovernment (e.g., I pay with cash); even with the discount provided to \nme, they get to keep more of their income than if they had reported the \ntransaction to the government.\n\nIn the case of a government, tax evasion can be reduced by the \ndeployment of investigators and enforcers.  In Bitcoin, we have no \ncontrol over activity that happens outside of the protocol and so even a \nmodest incentive to pay fees out of band might quickly lead to almost \nall fees being paid out of band.  This prevents the effective \nredistribution of fees as in your proposal.  Additionally, previous \ndiscussions on this mailing list about paying out-of-band fees have \nhighlighted that larger miners have an advantage over smaller miners in \ncollecting miner-specific fee payments, undermining the essential \ndecentralization of Bitcoin's transaction confirmation mechanism (moreso \nthan it is already weakened by fundamental economies of scale in \nmining).\n\nIn short, I think serious consideration of your proposal can only \nproceed if it adequately addresses the problem of out-of-band fees.\n\nThat said, thank you and your co-authors for putting serious thought \ninto Bitcoin's long-term economic incentives.\n\n-Dave\n\n[1] https://bitcoinsearch.xyz/?q=out%20of%20band%20fees&size=n_50_n", "summary": "A proposed solution to send a fraction of transaction fees to contracts for redistribution may incentivize miners to prefer out-of-band fees, undermining the redistribution scheme and decentralization of Bitcoin's confirmation mechanism."}], "thread_summary": {"title": "BIP proposal: Fee-redistribution contracts", "categories": ["bitcoin-dev"], "authors": ["David A. Harding"], "messages_count": 1, "total_messages_chars_count": 3212}}, {"title": "[bitcoin-dev] Minimum fees", "thread_messages": [{"author": "Giuseppe B", "date": "2023-03-01T20:18:22", "message_text_only": "Hello everyone,\n\nI'm relatively new here so what I'm proposing could have already been\ndiscussed, or may be flawed or inapplicable. I apologize for that.\n\nI was picturing a situation where block rewards are almost zero, and the\nbase layer is mainly used as a settlement layer for relatively few large\ntransactions, since the majority of smaller ones goes through LN.\n\nIn such a case it may very well be that even if transaction amounts are\nvery consistent, transaction fees end up being very small since there is\nenough space for everyone in a block. Users wouldn't mind paying higher\nfees as they know that that would increase the network security, however\nnobody wants to be the only one doing that. Miners would of course like\nbeing paid more. So everyone involved would prefer higher fees but they\njust stay low because that's the only rational individual choice.\n\nTherefore I was imagining the introduction of a new protocol rule,\nmin_fees, that would work like this:\n- the miner that gets to mine a block appends a min_fee field to the block,\nspecifying the minimum fees that need to be contained in the following\nblock in order for it to be valid.\n- one can also mine an empty block and reset the min_fee, to avoid the\nchain getting stuck.\n\nmin_fees could either represent the total fees of the following block, or\nthe minimal fee for each single transaction, as a percentage of the value\ntransacted. Both seem to have some merits and some potential drawbacks. Of\ncourse min_fees=0 would correspond to the current situation.\n\nIt looks to me that this could have the potential to bring the equilibrium\ncloser to a socially optimal one (as opposed to individually optimal), and\nto benefit the network security in the long term. Of course it's just a\nrough sketch and it would deserve a much deeper analysis. I was just\ninterested in knowing if you think that the principle has some merit or if\nit's not even worth discussing it for some reason that I'm not considering.\n\nCheers,\n\nGiuseppe.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230301/0e1bca3d/attachment-0001.html>", "summary": "Proposal for a new protocol rule, min_fees, to specify minimum fees for the following block, potentially bringing equilibrium closer to socially optimal."}, {"author": "Nadav Ivgi", "date": "2023-03-02T00:39:13", "message_text_only": "Hi Giuseppe,\n\nOne side-effect this has is that until enough fees accumulate in the\nmempool to satisfy min_fees, the rational behaviour for miners would be to\ntry and fork the chain tip, competing for the fees in the latest block\n(+whatever got into the mempool in the meanwhile and can fit in). This\ncould lead to increased reorgs/orphan rates and chain instability. It could\nalso lead to miners preferring to set their low_fee to zero, to avoid other\nminers from forking their blocks off.\n\nI'm also not sure that this would actually change much. If humanity is\nwilling to spend X BTC/day on mining fees, it doesn't really matter if it's\nspread out through fewer or more blocks.\n\nshesek\n\nOn Wed, Mar 1, 2023 at 10:25 PM Giuseppe B via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> I'm relatively new here so what I'm proposing could have already been\n> discussed, or may be flawed or inapplicable. I apologize for that.\n>\n> I was picturing a situation where block rewards are almost zero, and the\n> base layer is mainly used as a settlement layer for relatively few large\n> transactions, since the majority of smaller ones goes through LN.\n>\n> In such a case it may very well be that even if transaction amounts are\n> very consistent, transaction fees end up being very small since there is\n> enough space for everyone in a block. Users wouldn't mind paying higher\n> fees as they know that that would increase the network security, however\n> nobody wants to be the only one doing that. Miners would of course like\n> being paid more. So everyone involved would prefer higher fees but they\n> just stay low because that's the only rational individual choice.\n>\n> Therefore I was imagining the introduction of a new protocol rule,\n> min_fees, that would work like this:\n> - the miner that gets to mine a block appends a min_fee field to the\n> block, specifying the minimum fees that need to be contained in the\n> following block in order for it to be valid.\n> - one can also mine an empty block and reset the min_fee, to avoid the\n> chain getting stuck.\n>\n> min_fees could either represent the total fees of the following block, or\n> the minimal fee for each single transaction, as a percentage of the value\n> transacted. Both seem to have some merits and some potential drawbacks. Of\n> course min_fees=0 would correspond to the current situation.\n>\n> It looks to me that this could have the potential to bring the equilibrium\n> closer to a socially optimal one (as opposed to individually optimal), and\n> to benefit the network security in the long term. Of course it's just a\n> rough sketch and it would deserve a much deeper analysis. I was just\n> interested in knowing if you think that the principle has some merit or if\n> it's not even worth discussing it for some reason that I'm not considering.\n>\n> Cheers,\n>\n> Giuseppe.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/72a05fa8/attachment.html>", "summary": "Proposal for a new protocol rule, min_fees, to specify minimum fees for the following block to increase network security and prevent low fees."}, {"author": "Giuseppe B", "date": "2023-03-03T05:07:29", "message_text_only": "Hi shesek,\n\nMinimum fees may not be the right mechanism. However I disagree with the\ngeneral idea that \"if it's optimal for society to do X then they'll do X\".\nThere's plenty of examples where people fail to coordinate in the absence\nof a suitable framework, see the \"free rider\" problem with public goods or\neven the simple prisoner's dilemma.\n\nOn Thu, Mar 2, 2023, 1:39 AM Nadav Ivgi <nadav at shesek.info> wrote:\n\n> Hi Giuseppe,\n>\n> One side-effect this has is that until enough fees accumulate in the\n> mempool to satisfy min_fees, the rational behaviour for miners would be to\n> try and fork the chain tip, competing for the fees in the latest block\n> (+whatever got into the mempool in the meanwhile and can fit in). This\n> could lead to increased reorgs/orphan rates and chain instability. It could\n> also lead to miners preferring to set their low_fee to zero, to avoid other\n> miners from forking their blocks off.\n>\n> I'm also not sure that this would actually change much. If humanity is\n> willing to spend X BTC/day on mining fees, it doesn't really matter if it's\n> spread out through fewer or more blocks.\n>\n> shesek\n>\n> On Wed, Mar 1, 2023 at 10:25 PM Giuseppe B via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello everyone,\n>>\n>> I'm relatively new here so what I'm proposing could have already been\n>> discussed, or may be flawed or inapplicable. I apologize for that.\n>>\n>> I was picturing a situation where block rewards are almost zero, and the\n>> base layer is mainly used as a settlement layer for relatively few large\n>> transactions, since the majority of smaller ones goes through LN.\n>>\n>> In such a case it may very well be that even if transaction amounts are\n>> very consistent, transaction fees end up being very small since there is\n>> enough space for everyone in a block. Users wouldn't mind paying higher\n>> fees as they know that that would increase the network security, however\n>> nobody wants to be the only one doing that. Miners would of course like\n>> being paid more. So everyone involved would prefer higher fees but they\n>> just stay low because that's the only rational individual choice.\n>>\n>> Therefore I was imagining the introduction of a new protocol rule,\n>> min_fees, that would work like this:\n>> - the miner that gets to mine a block appends a min_fee field to the\n>> block, specifying the minimum fees that need to be contained in the\n>> following block in order for it to be valid.\n>> - one can also mine an empty block and reset the min_fee, to avoid the\n>> chain getting stuck.\n>>\n>> min_fees could either represent the total fees of the following block, or\n>> the minimal fee for each single transaction, as a percentage of the value\n>> transacted. Both seem to have some merits and some potential drawbacks. Of\n>> course min_fees=0 would correspond to the current situation.\n>>\n>> It looks to me that this could have the potential to bring the\n>> equilibrium closer to a socially optimal one (as opposed to individually\n>> optimal), and to benefit the network security in the long term. Of course\n>> it's just a rough sketch and it would deserve a much deeper analysis. I was\n>> just interested in knowing if you think that the principle has some merit\n>> or if it's not even worth discussing it for some reason that I'm not\n>> considering.\n>>\n>> Cheers,\n>>\n>> Giuseppe.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230303/e25eabe3/attachment-0001.html>", "summary": "Proposal for a new protocol rule, min_fees, to specify the minimum fees required in the following block for network security and stability. The author disagrees with the idea that people will always coordinate for the optimal outcome."}, {"author": "jk_14 at op.pl", "date": "2023-03-02T22:27:40", "message_text_only": "> to bring the equilibrium\n\nThe important thing to highlight is that's not equilibrium between active users and miners.\nThis needed in the future equilibrium is between:\n\nActive Users (transactional tax) vs Passive Users (i.e. stakeholders: inflation tax)\n\nAnd miners will only earn as much as these two parties above will pay in \"taxes\".\n\n> to benefit the network security in the long\u00a0term\n\nThe solution to benefit the network security in the long term should be simple enough to understand by Average Joe, in my opinion.\n\nDelay of halving in case of network global hashrate regression - is simple enough mechanism that cannot be played.\n(more here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021362.html )\n\nSummarizing:\n\n1. There are two parties in Bitcoin with opposite interests from network security point of view: passive stakeholders and active users.\n2. There is (still) no mechanism of achieving equilibrium regarding costs of network security between these two parties.\n3a. A system in which all users participate in ensuring its long-term security - is honest.\n3b. A system in which only active of them participate, and passive stakeholders are de facto long-term dishonest free riders - is not honest.\n\nEvery statement above is unfortunately true.\nThere are only two serious issues in Bitcoin in fact: weak long-term security budget and quantum threat.\nAccording to IBM roadmap regarding quantum computing - they may have 4k qubit system starting from 2025.\n\nIf quantum emergency fork (only several years ahead!) will require not soft, but hard version\n- that's the one and only chance for fixing simultaneously this serious flaw of Bitcoin design, in simplest and most conservative way.\nAnd we need to talk about it now - to be mentally prepared :)\n\n\nBest Regards\nJaroslaw\n\n\n\n\n\n\n\nW dniu 2023-03-01 21:25:08 u\u017cytkownik Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa\u0142:\nHello everyone,\n\n\nI'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.\n\n\nI was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.\n\n\nIn such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.\n\n\nTherefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:\u00a0\n- the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.\n- one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.\n\n\nmin_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.\n\n\nIt looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long\u00a0term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth\u00a0discussing it for some reason that\u00a0I'm\u00a0not considering.\n\n\nCheers,\n\n\nGiuseppe.", "summary": "Bitcoin's long-term security budget and quantum threat are the two serious issues. Achieving equilibrium between active and passive users is necessary for network security. A delay in halving can benefit the network security in the long term. A new protocol rule, min_fees, can be introduced to ensure higher fees for increased network security. A hard fork may be required to fix the serious flaw in Bitcoin design due to quantum computing."}, {"author": "WMOURA", "date": "2023-03-03T02:45:02", "message_text_only": "Hello,\n\nIn my amateur opinion, I imagine that this would give excessive power\nto the miner, introducing a bug in the system, because if the miner\nput an absurdly high minimum rate intentionally or not, this would\ncause a serious problem, or not.\n\n\nEm qua., 1 de mar. de 2023 \u00e0s 17:25, Giuseppe B via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> escreveu:\n\n> Hello everyone,\n>\n> I'm relatively new here so what I'm proposing could have already been\n> discussed, or may be flawed or inapplicable. I apologize for that.\n>\n> I was picturing a situation where block rewards are almost zero, and the\n> base layer is mainly used as a settlement layer for relatively few large\n> transactions, since the majority of smaller ones goes through LN.\n>\n> In such a case it may very well be that even if transaction amounts are\n> very consistent, transaction fees end up being very small since there is\n> enough space for everyone in a block. Users wouldn't mind paying higher\n> fees as they know that that would increase the network security, however\n> nobody wants to be the only one doing that. Miners would of course like\n> being paid more. So everyone involved would prefer higher fees but they\n> just stay low because that's the only rational individual choice.\n>\n> Therefore I was imagining the introduction of a new protocol rule,\n> min_fees, that would work like this:\n> - the miner that gets to mine a block appends a min_fee field to the\n> block, specifying the minimum fees that need to be contained in the\n> following block in order for it to be valid.\n> - one can also mine an empty block and reset the min_fee, to avoid the\n> chain getting stuck.\n>\n> min_fees could either represent the total fees of the following block, or\n> the minimal fee for each single transaction, as a percentage of the value\n> transacted. Both seem to have some merits and some potential drawbacks. Of\n> course min_fees=0 would correspond to the current situation.\n>\n> It looks to me that this could have the potential to bring the equilibrium\n> closer to a socially optimal one (as opposed to individually optimal), and\n> to benefit the network security in the long term. Of course it's just a\n> rough sketch and it would deserve a much deeper analysis. I was just\n> interested in knowing if you think that the principle has some merit or if\n> it's not even worth discussing it for some reason that I'm not considering.\n>\n> Cheers,\n>\n> Giuseppe.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/64195ad5/attachment.html>", "summary": "Proposal for a new protocol rule, min_fees, to specify the minimum fees needed in the following block for it to be valid, potentially benefiting network security."}, {"author": "Giuseppe B", "date": "2023-03-03T05:19:44", "message_text_only": "This will indeed give some power to the miners. But they have no incentives\nin posting super high numbers as that means they won't get paid or they\nwill with a lot of delay.\nThis is not simply like setting the price for a product that has a fixed\nquality. In the case of the mining services, setting the price also means\nsetting the quality of the product you offer (as higher price = higher\nsecurity). This is simply a way to let miners have have a say about the\nquality of the product that they offer. They can always set 0 min fees and\nsettle for the lowest quality/ low price service, or maybe find out that\noffering a better product for a higher price actually makes them more\nmoney.\n\n\n\nOn Fri, Mar 3, 2023, 3:45 AM WMOURA <neo.m.revolutions at gmail.com> wrote:\n\n> Hello,\n>\n> In my amateur opinion, I imagine that this would give excessive power to the miner, introducing a bug in the system, because if the miner put an absurdly high minimum rate intentionally or not, this would cause a serious problem, or not.\n>\n>\n> Em qua., 1 de mar. de 2023 \u00e0s 17:25, Giuseppe B via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> escreveu:\n>\n>> Hello everyone,\n>>\n>> I'm relatively new here so what I'm proposing could have already been\n>> discussed, or may be flawed or inapplicable. I apologize for that.\n>>\n>> I was picturing a situation where block rewards are almost zero, and the\n>> base layer is mainly used as a settlement layer for relatively few large\n>> transactions, since the majority of smaller ones goes through LN.\n>>\n>> In such a case it may very well be that even if transaction amounts are\n>> very consistent, transaction fees end up being very small since there is\n>> enough space for everyone in a block. Users wouldn't mind paying higher\n>> fees as they know that that would increase the network security, however\n>> nobody wants to be the only one doing that. Miners would of course like\n>> being paid more. So everyone involved would prefer higher fees but they\n>> just stay low because that's the only rational individual choice.\n>>\n>> Therefore I was imagining the introduction of a new protocol rule,\n>> min_fees, that would work like this:\n>> - the miner that gets to mine a block appends a min_fee field to the\n>> block, specifying the minimum fees that need to be contained in the\n>> following block in order for it to be valid.\n>> - one can also mine an empty block and reset the min_fee, to avoid the\n>> chain getting stuck.\n>>\n>> min_fees could either represent the total fees of the following block, or\n>> the minimal fee for each single transaction, as a percentage of the value\n>> transacted. Both seem to have some merits and some potential drawbacks. Of\n>> course min_fees=0 would correspond to the current situation.\n>>\n>> It looks to me that this could have the potential to bring the\n>> equilibrium closer to a socially optimal one (as opposed to individually\n>> optimal), and to benefit the network security in the long term. Of course\n>> it's just a rough sketch and it would deserve a much deeper analysis. I was\n>> just interested in knowing if you think that the principle has some merit\n>> or if it's not even worth discussing it for some reason that I'm not\n>> considering.\n>>\n>> Cheers,\n>>\n>> Giuseppe.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230303/62aece2e/attachment-0001.html>", "summary": "Proposal for a new protocol rule, min_fees, where miners set a minimum fee for the next block to increase network security and incentivize higher fees."}, {"author": "Andrew Melnychuk Oseen", "date": "2023-03-04T06:21:44", "message_text_only": "From my limited knowledge in the space, and I've taken opinions of people I respect that are far more knowledgeable than me.\n\nI don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.\n\nOpinion: I think as bitcoin's capabilities grow, demand for it will as well. There are a lot of efforts to increase the amount of transactions that can fit into a block. I think the combination of limited block space and a reduced amount of bitcoin's entering the market is the right combination for the system to self sustain. I'm looking forward to seeing the result!\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Wednesday, March 1st, 2023 at 12:18 PM, Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello everyone,\n>\n> I'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.\n>\n> I was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.\n>\n> In such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.\n>\n> Therefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:\n> - the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.\n> - one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.\n>\n> min_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.\n>\n> It looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth discussing it for some reason that I'm not considering.\n>\n> Cheers,\n>\n> Giuseppe.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230304/6a34ff0c/attachment.html>", "summary": "Proposal for a new protocol rule, min_fees, to ensure a socially optimal equilibrium in a scenario where block rewards are almost zero and transaction fees are very small."}, {"author": "vjudeu at gazeta.pl", "date": "2023-03-05T21:58:51", "message_text_only": "> I don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.\n\nI think federations like RSK or additional layers like LN can be a good example of what happens if there are no additional coins. In RSK, all coins are backed by BTC, so all you have is what users deposited, or what was Merge Mined, there are no more coins than that. In LN, there are nodes, and channels are formed only with existing coins, by default there is no mining, so all fees collected by nodes are based only on LN transaction fees (there are ways to reward small miners with LN coins, for example by enabling free LN transactions for those miners, or create channels directly by using outputs of the coinbase transaction, but it is not widely used).\n\nAlso note that when it comes to other chains, we still have testnet3, where there were more halvings than on the mainnet, because of blockstorms. So, if that network will not be resetted, then I guess we will see, how that network will behave, when there will be no other coins. For now, you can see some users complaining that it is hard to get enough test coins, and with each halving you can see, how that network is getting closer and closer to the case you want to observe. So, if we want to check, how potential solutions can solve that problem, using testnet3 will give better results than signet, simply because of more halvings. Also, as testnet3 has blockstorms, it is possible to also test extreme cases with huge reorgs, and see if taking fees from other blocks will still be profitable after introducing proposed changes.\n\nAnother important thing to note is that even if coins are worthless, then still, if there are some minimal fees (like one satoshi per virtual byte), then on-chain amounts simply represents, how many data can be sent by each user. It means that users can simply send zero satoshis (if there is a need to create any additional UTXOs), and place as many coins as they can in their change addresses, and then the whole game is about having any coins, to have the right to broadcast any transaction to the network. Because then, an interesting thing to note is that if there is no coins, then the chain is not going to be halted. It is still possible to create a coinbase transaction with zero coins, and it is still used in all block-based calculations, so mining such blocks can prevent other miners from reorging older blocks, and taking those fees. And then, if you look at the last miners that had some blocks with fees, then you notice that reaching 100 confirmations can encourage them to mine blocks with zero coinbase amount, just to spend their rewards.\n\nOn 2023-03-04 18:32:01 user Andrew Melnychuk Oseen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>From my limited knowledge in the space, and I've taken opinions of people I respect that are far more knowledgeable than me.\n\n\nI don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.\n\n\nOpinion: I think as bitcoin's capabilities grow, demand for it will as well. There are a lot of efforts to increase the amount of transactions that can fit into a block. I think the combination of limited block space and a reduced amount of bitcoin's entering the market is the right combination for the system to self sustain. I'm looking forward to seeing the result!\n\u00a0\n\u00a0\n\n\n\n\nSent with Proton Mail secure email.\n\n\n------- Original Message -------\nOn Wednesday, March 1st, 2023 at 12:18 PM, Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\nHello everyone,\n\n\nI'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.\n\n\nI was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.\n\n\nIn such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.\n\n\nTherefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:\n- the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.\n- one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.\n\n\nmin_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.\n\n\nIt looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth discussing it for some reason that I'm not considering.\n\n\nCheers,\n\n\nGiuseppe.", "summary": "The behavior of a blockchain when the coinbase drops below the fees is unknown, but federations like RSK or additional layers like LN can provide insight. Testnet3 can also be used to test extreme cases. Even if coins are worthless, minimal fees can still be used to send data. A chain can still function with zero coins, and mining blocks with zero coinbase amount can prevent reorgs and encourage miners to spend their rewards."}], "thread_summary": {"title": "Minimum fees", "categories": ["bitcoin-dev"], "authors": ["jk_14 at op.pl", "Giuseppe B", "Nadav Ivgi", "WMOURA", "vjudeu at gazeta.pl", "Andrew Melnychuk Oseen"], "messages_count": 8, "total_messages_chars_count": 28633, "convo_summary": "The group discussed the proposal for a new protocol rule, min_fees, to specify minimum fees for the following block to increase network security and incentivize higher fees. They also talked about the need for achieving equilibrium between active and passive users for network security, the serious issues of Bitcoin's long-term security budget and quantum threat, and the possibility of a hard fork to fix the flaw in Bitcoin design. The behavior of a blockchain when the coinbase drops below the fees is unknown, but federations like RSK or additional layers like LN can provide insight."}}, {"title": "[bitcoin-dev] Using service bit 24 for utreexo signaling in testnet and signet", "thread_messages": [{"author": "kcalvinalvin", "date": "2023-03-02T06:55:19", "message_text_only": "Hello all,\n\nWanted to tell the mailing list that I'll be using service bit 24 (1 << 24) to signal that nodes are Utreexo capable nodes on testnet and signet as requested by the comment in protocol.h in bitcoind (https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). There are plans to release binaries for the utreexo node (github.com/utreexo/utreexod) in the next few months so that power users can try it out. I have no plans to release binaries for mainnet yet.\n\nDo let me know if someone else is using the same bit to signal for something else and we can coordinate accordingly.\n\nBest,\nCalvin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/7f4218b1/attachment.html>", "summary": "Calvin will use service bit 24 to signal Utreexo capable nodes on testnet and signet, with plans to release binaries for utreexo node in the next few months."}, {"author": "Luke Dashjr", "date": "2023-03-02T18:20:35", "message_text_only": "This sounds like something that should be written up as a BIP and use a \nnormal service bit assignment...?\n\nLuke\n\n\nOn 3/2/23 01:55, kcalvinalvin via bitcoin-dev wrote:\n> Hello all,\n>\n> Wanted to tell the mailing list that I'll be using service bit 24 (1 \n> << 24) to signal that nodes are Utreexo capable nodes on testnet and \n> signet as requested by the comment in protocol.h\u00a0in \n> bitcoind\u00a0(https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). \n> There are plans to release binaries for the utreexo node \n> (github.com/utreexo/utreexod)\u00a0in the next few months so that power \n> users can try it out.\u00a0I have no\u00a0plans to release binaries for mainnet \n> yet.\n>\n> Do let me know if someone else is using the same bit to signal for \n> something else and we can coordinate accordingly.\n>\n> Best,\n> Calvin\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev", "summary": "A developer plans to use service bit 24 to signal Utreexo-capable nodes on testnet and signet, with plans to release binaries in the coming months."}, {"author": "Peter Todd", "date": "2023-03-02T21:05:26", "message_text_only": "On March 2, 2023 6:20:35 PM GMT, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>This sounds like something that should be written up as a BIP and use a normal service bit assignment...?\n\nThe purpose of the experimental service bits is experiments. If the details of utreexo aren't nailed down and may change, an experimental service bit makes sense.\n\nBit 24 is fine and AFAIK unused at the moment; full-rbf is using bit 26: https://github.com/petertodd/bitcoin/commit/c15b8d70778238abfa751e4216a97140be6369af#diff-8e2ffc8fe0e0847a6aac311a93b2faeebd2d76ddb2c81741bb8cf7448287807eR297\n\n>Luke\n>\n>\n>On 3/2/23 01:55, kcalvinalvin via bitcoin-dev wrote:\n>> Hello all,\n>> \n>> Wanted to tell the mailing list that I'll be using service bit 24 (1 << 24) to signal that nodes are Utreexo capable nodes on testnet and signet as requested by the comment in protocol.h\u00a0in bitcoind\u00a0(https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). There are plans to release binaries for the utreexo node (github.com/utreexo/utreexod)\u00a0in the next few months so that power users can try it out.\u00a0I have no\u00a0plans to release binaries for mainnet yet.\n>> \n>> Do let me know if someone else is using the same bit to signal for something else and we can coordinate accordingly.\n>> \n>> Best,\n>> Calvin\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>_______________________________________________\n>bitcoin-dev mailing list\n>bitcoin-dev at lists.linuxfoundation.org\n>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev", "summary": "Calvin plans to use service bit 24 to signal Utreexo capable nodes on testnet and signet, with plans to release binaries for utreexo node in the coming months."}], "thread_summary": {"title": "Using service bit 24 for utreexo signaling in testnet and signet", "categories": ["bitcoin-dev"], "authors": ["Luke Dashjr", "Peter Todd", "kcalvinalvin"], "messages_count": 3, "total_messages_chars_count": 3603, "convo_summary": "Calvin will use service bit 24 to signal Utreexo-capable nodes on testnet and signet, with plans to release binaries for Utreexo node in the coming months."}}, {"title": "[bitcoin-dev] BIP: Trust minimized swaps using PSBT, SINGLE|ANYONECANPAY and nostr", "thread_messages": [{"author": "alicexbt", "date": "2023-03-03T01:44:03", "message_text_only": "Hi Bitcoin Developers,\n\nI have written a BIP that describes the process to swap inscriptions however there can be other use cases for it as well: https://gist.github.com/1440000bytes/a7deeb3f1740bc533a61fbcc1fe58d77\n\nFeel free to share your opinion or feedback to improve the usage of PSBTs in swaps.\n\n    BIP: 2023-ordswap\n    Layer: Applications\n    Title: Trust minimized swaps using PSBTs\n    Author: /dev/fd0\n    Status: Draft\n    Created: 2023-03-02\n    License: Public Domain\n  \n  \n### Introduction\n\nThis BIP describes a process for creating offers using PSBTs to swap inscriptions. It was originally shared by [Casey](https://github.com/casey/ord/issues/802). There are two other approaches (`joinpsbts` and coinswap) to swap inscriptions however they degrade the UX and use of SINGLE|ANYONECANPAY works better.\n\n### Specification\n\n[SINGLE|ANYONECANPAY](https://en.bitcoin.it/wiki/Contract#SIGHASH_flags) is used for creating a PSBT by the seller. It is signed and published as offer. Buyer updates the PSBT with appropriate inputs and outputs. Order of inputs and outputs in the PSBT is very important as wrong ordering can burn inscriptions. [Ordinal theory](https://docs.ordinals.com/faq.html?#how-does-ordinal-theory-work) uses an algorithm to determine how satoshis hop from the inputs of a transaction to its outputs.\n\n### Protocol\n\nSequence diagram:\n\n```mermaid\nsequenceDiagram\n    Note right of Seller: Create and Sign PSBT\n    Seller->>+Nostr relays: Publish offer\n    Buyer->>+Nostr relays: Accept offer\n    Note left of Buyer: Add inputs, outputs, sign and broadcast PSBT\n```\n\nSeller:\n\n- Create PSBT with inscription UTXO input and a new address with sell amount as output\n- Sign PSBT\n- Publish PSBT as defined in [NIP](https://github.com/orenyomtov/openordex/blob/main/NIP.md)\n\nBuyer:\n\n- Add new address as output in PSBT to receive inscription\n- Create [dummy UTXO](https://i.imgur.com/8Rw3TFX.png) if not available in wallet (Less than 1000 sats)\n- Add UTXO to pay seller and dummy UTXO as inputs in PSBT\n- Sign and broadcast transaction. \n\nExample tx: https://mempool.space/signet/tx/ee7032f08ed18113c16ab8759d294c09f57492d8d255b5dbd16326df53bbdcac\n\nThis transaction has 3 inputs (dummy, inscription, UTXO used for paying seller) and 4 outputs (inscription, payment, new dummy for future, change)\n\nNote: Openordex creates a dummy UTXO and reuses address if there is no dummy UTXO found for the address entered by buyer. Example: https://mempool.space/signet/tx/388942887f79358a1deba3aae86e97b982a923566b2ef2249eab42288efc5abf\n\nPseudocode or Implementation (2 functions used by openordex for creating PSBTs)\n\n```js\n\t\nasync function generatePSBTListingInscriptionForSale(ordinalOutput, price, paymentAddress) {\n    let psbt = new bitcoin.Psbt({ network });\n\n    const [ordinalUtxoTxId, ordinalUtxoVout] = ordinalOutput.split(':')\n    const tx = bitcoin.Transaction.fromHex(await getTxHexById(ordinalUtxoTxId))\n    for (const output in tx.outs) {\n        try { tx.setWitness(output, []) } catch { }\n    }\n\n    psbt.addInput({\n        hash: ordinalUtxoTxId,\n        index: parseInt(ordinalUtxoVout),\n        nonWitnessUtxo: tx.toBuffer(),\n        // witnessUtxo: tx.outs[ordinalUtxoVout],\n        sighashType: bitcoin.Transaction.SIGHASH_SINGLE | bitcoin.Transaction.SIGHASH_ANYONECANPAY,\n    });\n\n    psbt.addOutput({\n        address: paymentAddress,\n        value: price,\n    });\n\n    return psbt.toBase64();\n}\n\n```\n\n```js\n\n    generatePSBTBuyingInscription = async (payerAddress, receiverAddress, price, paymentUtxos, dummyUtxo) => {\n        const psbt = new bitcoin.Psbt({ network });\n        let totalValue = 0\n        let totalPaymentValue = 0\n\n        // Add dummy utxo input\n        const tx = bitcoin.Transaction.fromHex(await getTxHexById(dummyUtxo.txid))\n        for (const output in tx.outs) {\n            try { tx.setWitness(output, []) } catch { }\n        }\n        psbt.addInput({\n            hash: dummyUtxo.txid,\n            index: dummyUtxo.vout,\n            nonWitnessUtxo: tx.toBuffer(),\n            // witnessUtxo: tx.outs[dummyUtxo.vout],\n        });\n\n        // Add inscription output\n        psbt.addOutput({\n            address: receiverAddress,\n            value: dummyUtxo.value + Number(inscription['output value']),\n        });\n\n        // Add payer signed input\n        psbt.addInput({\n            ...sellerSignedPsbt.data.globalMap.unsignedTx.tx.ins[0],\n            ...sellerSignedPsbt.data.inputs[0]\n        })\n        // Add payer output\n        psbt.addOutput({\n            ...sellerSignedPsbt.data.globalMap.unsignedTx.tx.outs[0],\n        })\n\n        // Add payment utxo inputs\n        for (const utxo of paymentUtxos) {\n            const tx = bitcoin.Transaction.fromHex(await getTxHexById(utxo.txid))\n            for (const output in tx.outs) {\n                try { tx.setWitness(output, []) } catch { }\n            }\n\n            psbt.addInput({\n                hash: utxo.txid,\n                index: utxo.vout,\n                nonWitnessUtxo: tx.toBuffer(),\n                // witnessUtxo: tx.outs[utxo.vout],\n            });\n\n            totalValue += utxo.value\n            totalPaymentValue += utxo.value\n        }\n\n        // Create a new dummy utxo output for the next purchase\n        psbt.addOutput({\n            address: payerAddress,\n            value: dummyUtxoValue,\n        })\n\n        const fee = calculateFee(psbt.txInputs.length, psbt.txOutputs.length, await recommendedFeeRate)\n\n        const changeValue = totalValue - dummyUtxo.value - price - fee\n\n        if (changeValue < 0) {\n            throw `Your wallet address doesn't have enough funds to buy this inscription.\nPrice:          ${satToBtc(price)} BTC\nFees:       ${satToBtc(fee + dummyUtxoValue)} BTC\nYou have:   ${satToBtc(totalPaymentValue)} BTC\nRequired:   ${satToBtc(totalValue - changeValue)} BTC\nMissing:     ${satToBtc(-changeValue)} BTC`\n        }\n\n        // Change utxo\n        psbt.addOutput({\n            address: payerAddress,\n            value: changeValue,\n        });\n\n        return psbt.toBase64();\n    }\n\t\n```\n\nNote: Openordex reuses address for change, however this can be avoided.\n\n### Acknowledgements\n\n- Casey Rodarmor\n- Oren Yomtov\n- Rijndael\n\n/dev/fd0\nfloppy disk guy\n\n\nSent with Proton Mail secure email.", "summary": "A new BIP proposes using PSBTs for trust-minimized swaps of inscriptions in Bitcoin. The process involves creating and signing a PSBT, publishing it as an offer, and updating it with appropriate inputs and outputs. The use of SINGLE|ANYONECANPAY is recommended, and the order of inputs and outputs is crucial to avoid burning inscriptions. The BIP was authored by /dev/fd0 and is currently in draft status."}], "thread_summary": {"title": "BIP: Trust minimized swaps using PSBT, SINGLE|ANYONECANPAY and nostr", "categories": ["bitcoin-dev"], "authors": ["alicexbt"], "messages_count": 1, "total_messages_chars_count": 6266}}, {"title": "[bitcoin-dev] Bitcoin Contracting Primitives WG 5th Meeting, Tuesday 21 Mar. 18:00 UTC", "thread_messages": [{"author": "Antoine Riard", "date": "2023-03-12T16:46:36", "message_text_only": "Hi list,\n\nI'm proposing Tuesday 21st March at 18:00, i.e one week and half from now\nfor the 5th Bitcoin contracting primitives WG (the third Tuesday of March\nmonth, as done previously).\n\nThere is an issue if anyone would like to propose an agenda topic in\nadvance in an open fashion:\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/issues/38\n\nFor now, there is only pinned ANYPREVOUT / \"Eltoo\" as a discussion subject.\nFeel free to add more!\n\nBeyond that, if you would like to host the meeting, don't hesitate to\ncomment on the issue. Good to rotate if we can.\n\nCommunication venue is #bitcoin-contracting-primitives-wg on Libera Chat\nIRC. Logs of the previous session are available here [0].\n\nIf you have any questions or feedback, I'm staying responsive.\n\nCheers,\nAntoine\n\n[0]\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-21-02.md\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230312/41a820b9/attachment.html>", "summary": "Bitcoin contracting primitives working group meeting scheduled for March 21st at 18:00 UTC. Agenda topics can be proposed on GitHub. Communication on Libera Chat IRC."}], "thread_summary": {"title": "Bitcoin Contracting Primitives WG 5th Meeting, Tuesday 21 Mar. 18:00 UTC", "categories": ["bitcoin-dev"], "authors": ["Antoine Riard"], "messages_count": 1, "total_messages_chars_count": 1070}}, {"title": "[bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning", "thread_messages": [{"author": "Greg Sanders", "date": "2023-03-13T16:38:25", "message_text_only": "After getting neutral to negative feedback on the choice, I have switched\nto OP_TRUE on the BIP and implementation.\n\nCheers,\nGreg\n\nOn Sat, Feb 4, 2023 at 11:03\u202fAM Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Feb 03, 2023 at 09:07:29PM -0500, Greg Sanders wrote:\n> > I'm not particularly persuaded, but also not wedded to either idea.\n> >\n> > Fixed up tests for the OP_TRUE case here:\n> > https://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true\n>\n> Thanks.\n>\n> Looking through that, I think a lot of those test cases don't actually\n> need to\n> be changed to OP_2, as they aren't trying to test anything related to\n> standardness.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/d322b383/attachment-0001.html>", "summary": "Greg Sanders switched to OP_TRUE on the BIP and implementation after receiving negative feedback on the previous choice."}], "thread_summary": {"title": "Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning", "categories": ["bitcoin-dev"], "authors": ["Greg Sanders"], "messages_count": 1, "total_messages_chars_count": 894}}, {"title": "[bitcoin-dev] Conjectures on solving the high interactivity issue in payment pools and channel factories", "thread_messages": [{"author": "jlspc", "date": "2023-03-17T20:54:51", "message_text_only": "Hi Antoine,\n\nThanks for your insightful post on the interactivity issue.\n\nSome thoughts are inline below.\n\n> However, those constructions require all the users to be online and\n> exchange rounds of signatures to update the balance distribution. Those\n> liveliness/interactivity requirements are increasing with the number of\n> users, as there are higher odds of *one* lazzy/buggy/offline user stalling\n> the pool/factory updates.\n\n> In echo, the design of LN was envisioned for a network of\n> always-online/self-hosted participants, the early deployment of LN showed\n> the resort to delegated channel hosting solutions, relieving users from the\n> liveliness requirement. While the trust trade-offs of those solutions are\n> significant, they answer the reality of a world made of unreliable networks\n> and mobile devices.\n\nAgreed that signing updates and monitoring the blockchain both create always-online requirements that are not compatible with casual users' desires.\nI think it's helpful to separate these two cases, as they affect different parties and their solutions differ.\nIn particular, limited availability to sign updates affects one's partners and can be addressed by having fewer partners, not partnering with casual users, evicting unresponsive users, etc.\nLimited availability to monitor the blockchain affects the security of one's own funds and can be addressed by increasing one's safety parameters (such as the to_self_delay parameter in Lightning).\n\n> Ideally, I think we would like a trust-minimized solution enabling\n> non-interactive, off-chain updates of the pool/factory, with no or minimal\n> consumption of blockspace.\n\nI would argue that we want a completely trust-free solution, if at all possible, while respecting users' actual availability.\nWe should only consider solutions that require trust if we can't find a trust-free solution that meets all other requirements.\n\n> For the remainder of this post, only the pool use-case will be mentioned.\n> Though, I think the observations/implications can be extended to factories\n> as well.\n\n> Of course, the double-spend issue is already addressed on the Bitcoin\n> base-layer due to nodes consensus convergence on the most-proof-of-work\n> accumulated valid chain of blocks. While reorg can happen, a UTXO cannot be\n> spent twice on the same chain. This security model can be said to be\n> prophylactic, i.e an invalid block cannot be applied to a node's state and\n> should be rejected.\n\n> The double-spend issue is also solved in its own way in payment channels.\n> If a transaction is published, of which the correctness has been revoked\n> w.r.t negotiated, private channel state, the wronged channel users must\n> react in consequence. This security model can be said to be corrective,\n> states updates are applied first on the global ledger then eventually\n> corrected.\n\n> A solution to the pool partition equivocation issue appears as either based\n> on a prophylactic one or a corrective security model.\n\nActually, there's a third class of solutions that are possible, namely ones that use separate control transactions and value transactions (where the value transactions \"spend\", and therefore depend on, the control transactions).\nIf an invalid control transaction is put on-chain, it can be blocked by another user by spending its output(s) before the output(s) can affect the value transaction.\nThus, control transactions can be viewed as proposals for state updates, and those proposals are blocked if they aren't valid.\n\nThese solutions differ from prophylactic solutions, as they allow incorrect transactions to be put on-chain and require another user to block them.\nThey also differ from your definition of a corrective security model, as they never allow the state update to be applied to the value in the channel or pool, so there's nothing to be corrected.\nAn example of this third class of solutions is the Tunable-Penalty Factory protocol [1].\nOf course, this example was not available when you noted that solutions are either prophylactic or corrective.\n\n> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.\n> Alice contacts Bob to form a first partition, then Caroll to form a second\n> one, then Dave to form a last one. If she is successful in that\n> equivocation trick, she can *triple*-spend her balance against any goods or\n> out-of-pool payments.\n\n> However, correction can only\n> be limited to the equivocated balance. Therefore, it appears that\n> corrective security models in the context of multi-party are always\n> producing an economic disequilibrium.\n\nOn the other hand, protocols that use separate control and value transactions do not have this limitation.\nFor example, the Tunable-Penalty Factory protocol is a multi-party protocol in which every dishonest party is penalized and there is no economic disequilibrium.\n\n> I think that leveraging covenants a revocation mechanism could be attached\n> on any equivocating branch of transactions, allowing in the above case a\n> single honest user to punish the publication. While a revocation mechanism\n> does not work in case of multiple defrauded users, I believe the existence\n> of a revocation mechanism makes the formation of malicious coalitions\n> unsafe for their conjurers.\n\n> Indeed, any user entering in the coalition is not guaranteed to be blinded\n> to other equivocating branches generated by the partition initiator.\n> Therefore, the publication of a partition statement by everyone is\n> holistically optimal to discover any equivocating candidate among the pool\n> users.\n\nIf I understand this correctly, I think a penalty mechanism that allows a \"wronged\" user to take some or all of a dishonest user's funds could be exploited by a malicious coalition.\nConsider the case where Alice is an honest user who joins a partition with Bob, where Bob and Carol are in a malicious coalition.\nAlice believes she has pooled her funds with Bob's and so she is able to work with Bob to implement an off-line update of their balances, with Alice believing that she has gained ownership over some of Bob's funds.\nHowever, when the partitioning Update transaction that joins Alice's and Bob's funds is put on-chain, Carol pretends to have been \"wronged\" by Bob and uses the penalty mechanism to seize Bob's funds.\nIn this case, Alice won't be able to get the funds that she thought she had obtained from Bob.\n\nDoes that make sense?\n\nRegards,\nJohn\n\n[1] Law, \"Efficient Factories For Lightning Channels\", available at https://github.com/JohnLaw2/ln-efficient-factories.\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230317/04bc8655/attachment.html>", "summary": "The post discusses the liveliness/interactivity requirements of updating balance distribution in pools and the design of Lightning Network for always-online participants. The author suggests a trust-minimized solution for non-interactive, off-chain updates of the pool/factory. The post also discusses the double-spend issue and proposes solutions based on prophylactic or corrective security models."}], "thread_summary": {"title": "Conjectures on solving the high interactivity issue in payment pools and channel factories", "categories": ["bitcoin-dev"], "authors": ["jlspc"], "messages_count": 1, "total_messages_chars_count": 6783}}, {"title": "[bitcoin-dev] Bitcoin fungibility and inscribed sats", "thread_messages": [{"author": "alicexbt", "date": "2023-03-31T16:30:30", "message_text_only": "Hi Steve and Bitcoin Developers,\n\nI have created a new thread as requested by one of the developers. I respect him and the readers of this list.\n\n> \"want bitcoin to be money and money means different things for people in\nthis world\"\n\n> I think we can all agree that a property of money is fungibility, and by\nits very definition NFTs are not fungible and thus not money.\n\nInscriptions do not affect fungibility of bitcoin:\n\n- There is no token standard being used. These are just sats being considered as inscription in an external protocol or explorer. Bitcoin nodes do not consider them as something special.\n- Users can always sell those inscribed sats or UTXO as normal bitcoin on bisq or any exchange.\n- They can use different amounts for it using tools like https://raritygarden.inscribetheplanet.com/ which is created by super testnet who is active dev in bitcoin and ln.\n- Inscribed sats are different from Ethereum tokens because they will never go to zero and you can always consolidate lot of them to use as normal bitcoin.\n\nBitcoin fungibility is anyways debatable and I cannot change anything about it even though working on a coinjoin implmentation as some post mix UTXOs are censored on some exchanges and its easy to identify them. Some coinjoin implementation themselves work with chain analysis companies to censor inputs used for rounds.\n\nOrdinals theory is a parallel universe in which some users believe in and they have been trying to learn how bitcoin works. Example: I did call with someone this evening to explain how PSBT and multisig works who never used bitcoin before\n\nDevelopers are interested to build things and they have tried to create BIP, DEX, look for libraries, ask questions, projects implementing PSBT etc.\n\nI do not live in first world country and do not attend bitdevs but always wanted bitcoin to be here. I have tried my best but failed. Please let people do what they want with bitcoin without changing consensus rules. It will help Bitcoin.\n\n/dev/fd0\nfloppy disk guy\n\n\nSent with Proton Mail secure email.", "summary": "A developer argues that NFTs are not fungible and thus not money, but inscribed sats in Bitcoin do not affect fungibility and can be sold as normal Bitcoin. The debatable fungibility of Bitcoin is also discussed."}], "thread_summary": {"title": "Bitcoin fungibility and inscribed sats", "categories": ["bitcoin-dev"], "authors": ["alicexbt"], "messages_count": 1, "total_messages_chars_count": 2050}}]