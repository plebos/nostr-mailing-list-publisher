[
    {
        "title": "[bitcoin-dev] Reference example bech32m address for future segwit versions",
        "thread_messages": [
            {
                "author": "Greg Sanders",
                "date": "2023-02-01T00:37:06",
                "message_text_only": "David,\n\nI'm merely speaking in a descriptive sense. I predict that most custodians\nare reluctant to whitelist\na witness version they know is insecure.\n\nI'm not sure what's best for not colliding with future versions, I'll let\nother wiser folks weigh in.\n\nCheers,\nGreg\n\nOn Tue, Jan 31, 2023 at 6:33 PM David A. Harding <dave at dtrt.org> wrote:\n\n> On 2023-01-31 04:30, Greg Sanders wrote:\n> > Hi David,\n> >\n> > From practical experience, I think you'll find that most exchanges\n> > will not enable sends to future segwit versions,\n> > as from a risk perspective it's likely a mistake to send funds there.\n>\n> Hi Greg!,\n>\n> I thought the best practice[1] was that wallets would spend to the\n> output indicated by any valid bech32m address.  You seem to implying\n> that the best practice is the opposite: that wallets should only send to\n> outputs they know can be secured (i.e., which are not currently\n> anyone-can-spend).  The more restrictive approach seems kind of sad to\n> me since any problem which can result in a user accidentally withdrawing\n> to a future segwit version could even more easily result in them\n> withdrawing to a witness program for which there is no solution (i.e.,\n> no key or script is known to spend).\n>\n> If it is a best practice, then I think there's a benefit to being able\n> to test it even when other people's proprietary software is involved.  A\n> wallet or service likely to follow that best practice may be more likely\n> to follow other best practices which cannot be as easily tested for.\n> But, if it's going to be tested, I want the testing to use the address\n> least likely to cause problems for protocol developers in the future.\n> Do you (and others on this list) have any reason to believe OP_16\n> OP_PUSH2 0000 would be a problematic script, or can you think of a\n> better script?\n>\n> Thanks!,\n>\n> -Dave\n>\n> [1] BIP350, emphasis in original: \"[...] we emphatically recommend [...]\n> ensuring that your implementation supports sending to v1 **and higher\n> versions.**\"\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/bcb8b5a9/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-01T01:13:49",
                "message_text_only": "On Tue, Jan 31, 2023 at 01:33:13PM -1000, David A. Harding via bitcoin-dev wrote:\n> I thought the best practice[1] was that wallets would spend to the output\n> indicated by any valid bech32m address.  \n\nI think it depends -- if the wallet in question is non-custodial and\nmight not be upgraded by the time witness v2 addresses are in use, then\nbeing able to send to such addresses now makes sense. \n\nIf it's a custodial wallet where the nominal owner of the coins isn't\nthe one signing the tx, then I could see a pretty strong argument to not\nallowing sending to such addresses until they're in use: (a) nobody will\nbe running the old software, since the custodian can just force everyone\nto upgrade (eg, by deploying a new version of their own website), and (b)\nsigning a tx to send the bitcoins you're holding on Bob's behalf to an\naddress that will just get them stolen could be considered as negligence,\nand you might end up forced to make Bob whole again.\n\nSo maybe the argument is:\n\n * is this a custodial wallet? then what's the point of testing a\n   scenario that's likely years away -- the custodian will probably have\n   changed their system entirely by then anyway\n\n * is it a non-custodial wallet? then it's worth testing -- you might\n   not be able to find compatible software in future to move your\n   private keys and have to dig up the current software and use it. will\n   it still work? but in that case, you ought to be able to capture the\n   tx it generates before broadcasting it, and don't need to publish it\n   on chain, and then it doesn't matter what script you use?\n\n(For libraries and non-wallet software like block explorers or alternate\nnode implementations, it's a different matter)\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Reference example bech32m address for future segwit versions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Greg Sanders"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3917
        }
    },
    {
        "title": "[bitcoin-dev] Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE OP_IF OP_PUSH",
        "thread_messages": [
            {
                "author": "Christopher Allen",
                "date": "2023-02-01T00:46:32",
                "message_text_only": "All other things being equal, which is better if you need to place a\n64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent\ntaproot transaction such as:\n\nOP_FALSE\nOP_IF\nOP_PUSH my64bytes\nOP_ENDIF\n\nI know that the anti-OP_RETURN folk would say \u201cneither.\u201d But if there was\nno other choice for a particular protocol, such as a timestamp or a\ncommitment, which is better? Or is there a safer place to put 64 bytes that\nis more uncensorable but also does not clog UTXO space, only spent\ntransaction `-txindex` space?\n\nMy best guess was that the taproot method is better, but I suspect there\nmight be some who disagree. I'd love to hear all sides.\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/cac8f8b3/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-01T02:07:16",
                "message_text_only": "On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>All other things being equal, which is better if you need to place a\n>64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent\n>taproot transaction such as:\n>\n>OP_FALSE\n>OP_IF\n>OP_PUSH my64bytes\n>OP_ENDIF\n\nWhat's wrong with OpPush <data> OpDrop?\n\n>I know that the anti-OP_RETURN folk would say \u201cneither.\u201d But if there was\n>no other choice for a particular protocol, such as a timestamp or a\n>commitment, which is better? Or is there a safer place to put 64 bytes that\n>is more uncensorable but also does not clog UTXO space, only spent\n>transaction `-txindex` space?\n>\n>My best guess was that the taproot method is better, but I suspect there\n>might be some who disagree. I'd love to hear all sides.\n\nAn important consideration with using taproot is that you need to have the data you are committing too to be able to to spend the txout in the future. OpReturn doesn't have that problem, meaning that in a situation like a hard drive failure, you can still recover the funds from a wallet seed.\n\nAlso, it is incorrect to say that OpReturn outputs \"clog UTXO space\". The whole point of OpReturn is to standardize a way to keep such outputs out of the UTXO set. There is the 75% discount to using witness space. But considering the size of a transaction as a whole using taproot instead of OpReturn doesn't save much.\n\nFinally, _64_ bytes is more than a mere 32 byte commitment. What specific use case do you actually have in mind here? Are you actually publishing data, or simply committing to data? If the latter, you can use ECC commitments and have no extra space at all."
            },
            {
                "author": "Christopher Allen",
                "date": "2023-02-01T02:22:29",
                "message_text_only": "I don't have a concrete proposal in mind, I'm just trying to understand\nvarious tradeoffs in post-taproot bitcoin in more detail.\n\nOn Tue, Jan 31, 2023 at 6:07 PM Peter Todd <pete at petertodd.org> wrote:\n\n>\n> >OP_FALSE\n> >OP_IF\n> >OP_PUSH my64bytes\n> >OP_ENDIF\n>\n> What's wrong with OpPush <data> OpDrop?\n>\n\nI'm not sure pro or con of either. I just saw that proposal above recently.\n\n\n> Also, it is incorrect to say that OpReturn outputs \"clog UTXO space\". The\n> whole point of OpReturn is to standardize a way to keep such outputs out of\n> the UTXO set. There is the 75% discount to using witness space. But\n> considering the size of a transaction as a whole using taproot instead of\n> OpReturn doesn't save much.\n>\n\nThere are OP_RETURN tricks in production that do clog UTXO space. I was\ntrying to avoid consideration of those by just saying to compare apples vs.\napples, by presuming that any form of these transactions holding the 64\nbytes is a spent transaction.\n\nFinally, _64_ bytes is more than a mere 32 byte commitment. What specific\n> use case do you actually have in mind here? Are you actually publishing\n> data, or simply committing to data? If the latter, you can use ECC\n> commitments and have no extra space at all.\n>\n\nI chose 64 bytes for this exercise, as I know there are tricks hiding 32\nbytes as keys. As almost every op_return live out there is >32 bytes, I\nwanted an example that could be a signature, two hashes, a hash plus some\nmetadata, etc. I also considered 96 bytes (for instance a hash and a\nsignature), but as that doesn't fit into OP_RETURN's 80 bytes, that choice\nprohibits comparing the different approaches side-by-side.\n\nTo come back to my question another way, if you ignore the people who say\n\"never put anything except data facilitating coin transactions into the\nbitcoin blockchain\", but if you also are not trying to use the bitcoin\nblockchain as a world database (ala ETH), what is the most pragmatic way to\ndo so that minimizes any potential harm? The answer pre-taproot was\nOP_RETURN. What is it now?\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230131/60e5928e/attachment.html>"
            },
            {
                "author": "Kostas Karasavvas",
                "date": "2023-02-01T08:36:52",
                "message_text_only": "With OP_RETURN you publish some data that are immediately visible in the\nblockchain. I would consider this better (more straightforward) for things\nlike time-stamping.\n\nWith Taproot you need to spend the utxo to make the script visible. This\nseems better when you don't want the data public but you need to be able to\nreveal the data when the time comes.\n\nUnless it is important to reveal later, it seems to me that for 80 bytes or\nless OP_RETURN is still the way to go post-taproot.\n\n\n\nOn Wed, 1 Feb 2023, 04:30 Christopher Allen via bitcoin-dev, <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I don't have a concrete proposal in mind, I'm just trying to understand\n> various tradeoffs in post-taproot bitcoin in more detail.\n>\n> On Tue, Jan 31, 2023 at 6:07 PM Peter Todd <pete at petertodd.org> wrote:\n>\n>>\n>> >OP_FALSE\n>> >OP_IF\n>> >OP_PUSH my64bytes\n>> >OP_ENDIF\n>>\n>> What's wrong with OpPush <data> OpDrop?\n>>\n>\n> I'm not sure pro or con of either. I just saw that proposal above recently.\n>\n>\n>> Also, it is incorrect to say that OpReturn outputs \"clog UTXO space\". The\n>> whole point of OpReturn is to standardize a way to keep such outputs out of\n>> the UTXO set. There is the 75% discount to using witness space. But\n>> considering the size of a transaction as a whole using taproot instead of\n>> OpReturn doesn't save much.\n>>\n>\n> There are OP_RETURN tricks in production that do clog UTXO space. I was\n> trying to avoid consideration of those by just saying to compare apples vs.\n> apples, by presuming that any form of these transactions holding the 64\n> bytes is a spent transaction.\n>\n> Finally, _64_ bytes is more than a mere 32 byte commitment. What specific\n>> use case do you actually have in mind here? Are you actually publishing\n>> data, or simply committing to data? If the latter, you can use ECC\n>> commitments and have no extra space at all.\n>>\n>\n> I chose 64 bytes for this exercise, as I know there are tricks hiding 32\n> bytes as keys. As almost every op_return live out there is >32 bytes, I\n> wanted an example that could be a signature, two hashes, a hash plus some\n> metadata, etc. I also considered 96 bytes (for instance a hash and a\n> signature), but as that doesn't fit into OP_RETURN's 80 bytes, that choice\n> prohibits comparing the different approaches side-by-side.\n>\n> To come back to my question another way, if you ignore the people who say\n> \"never put anything except data facilitating coin transactions into the\n> bitcoin blockchain\", but if you also are not trying to use the bitcoin\n> blockchain as a world database (ala ETH), what is the most pragmatic way to\n> do so that minimizes any potential harm? The answer pre-taproot was\n> OP_RETURN. What is it now?\n>\n> -- Christopher Allen\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/22b11f78/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-01T12:51:38",
                "message_text_only": "On February 1, 2023 8:36:52 AM GMT, Kostas Karasavvas <kkarasavvas at gmail.com> wrote:\n>With OP_RETURN you publish some data that are immediately visible in the\n>blockchain. I would consider this better (more straightforward) for things\n>like time-stamping.\n\nYou are incorrect. Time-stamps merely prove that data existed prior to some point in time. There is absolutely no need for anything to be published in the blockchain to create a timestamp. Indeed, efficient timestamps don't actually publish any meaningful data: for efficiency you always combine many timestamps into a single merkle tree; a merkle tree tip digest is meaningless data by itself.\n\nOpenTimestamps does in fact use OpReturn rather than something more efficient. But it does this only because the efficiency gain isn't significant enough for me to have gotten around to improving it. Reducing fee costs by ~10% isn't a good use of my time.\n\n>With Taproot you need to spend the utxo to make the script visible. This\n>seems better when you don't want the data public but you need to be able to\n>reveal the data when the time comes.\n\nIf your concern is the data being public due to OpReturn vs Taproot, you are confused and need to think more carefully about what exactly you are doing."
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-01T14:02:41",
                "message_text_only": "On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:\n> \n> \n> On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >All other things being equal, which is better if you need to place a\n> >64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent\n> >taproot transaction such as:\n> >\n> >OP_FALSE\n> >OP_IF\n> >OP_PUSH my64bytes\n> >OP_ENDIF\n> \n> What's wrong with OpPush <data> OpDrop?\n>\n\nThis is a technical nit, but the reason is that <data> is limited to 520\nbytes (and I believe, 80 bytes by standardness in Taproot), so if you\nare pushing a ton of data and need multiple pushes, it's more efficient\nto use FALSE IF ... ENDIF since you avoid the repeated DROPs.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/4ed63515/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-02T11:22:23",
                "message_text_only": "On Wed, Feb 01, 2023 at 02:02:41PM +0000, Andrew Poelstra wrote:\n> On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:\n> > \n> > \n> > On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > >All other things being equal, which is better if you need to place a\n> > >64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent\n> > >taproot transaction such as:\n> > >\n> > >OP_FALSE\n> > >OP_IF\n> > >OP_PUSH my64bytes\n> > >OP_ENDIF\n> > \n> > What's wrong with OpPush <data> OpDrop?\n> >\n> \n> This is a technical nit, but the reason is that <data> is limited to 520\n> bytes (and I believe, 80 bytes by standardness in Taproot), so if you\n> are pushing a ton of data and need multiple pushes, it's more efficient\n> to use FALSE IF ... ENDIF since you avoid the repeated DROPs.\n\nYes, for more than 520 bytes you need to wrap the push in an IF/ENDIF so it's\nnot executed. But in this example we're just talking about 64 bytes, so that\nlimit isn't relevant and OpPush <data> OpDrop should be sufficient.\n\nSpecifically for more than 520 bytes you run into the the\nMAX_SCRIPT_ELEMENT_SIZE check in script/interpreter.cpp, which applies to all\nscripts regardless of standardness at script execution:\n\n           //\n           // Read instruction\n           //\n           if (!script.GetOp(pc, opcode, vchPushValue))\n               return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n           if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n               return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/aa281e02/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-02T11:45:42",
                "message_text_only": "As far as I can read nobody replied to the initial question: what is\nconsidered as good/best practice to store in Bitcoin?\n\nReiterating my question: what are the current rules for OP_RETURN, max\nsize and number of OP_RETURN per tx\n\n\nLe 02/02/2023 \u00e0 12:22, Peter Todd via bitcoin-dev a \u00e9crit :\n> On Wed, Feb 01, 2023 at 02:02:41PM +0000, Andrew Poelstra wrote:\n>> On Tue, Jan 31, 2023 at 09:07:16PM -0500, Peter Todd via bitcoin-dev wrote:\n>>>\n>>> On January 31, 2023 7:46:32 PM EST, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>> All other things being equal, which is better if you need to place a\n>>>> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a spent\n>>>> taproot transaction such as:\n>>>>\n>>>> OP_FALSE\n>>>> OP_IF\n>>>> OP_PUSH my64bytes\n>>>> OP_ENDIF\n>>> What's wrong with OpPush <data> OpDrop?\n>>>\n>> This is a technical nit, but the reason is that <data> is limited to 520\n>> bytes (and I believe, 80 bytes by standardness in Taproot), so if you\n>> are pushing a ton of data and need multiple pushes, it's more efficient\n>> to use FALSE IF ... ENDIF since you avoid the repeated DROPs.\n> Yes, for more than 520 bytes you need to wrap the push in an IF/ENDIF so it's\n> not executed. But in this example we're just talking about 64 bytes, so that\n> limit isn't relevant and OpPush <data> OpDrop should be sufficient.\n>\n> Specifically for more than 520 bytes you run into the the\n> MAX_SCRIPT_ELEMENT_SIZE check in script/interpreter.cpp, which applies to all\n> scripts regardless of standardness at script execution:\n>\n>            //\n>            // Read instruction\n>            //\n>            if (!script.GetOp(pc, opcode, vchPushValue))\n>                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n>            if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n>                return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/13100de1/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-02T11:49:32",
                "message_text_only": "On Thu, Feb 02, 2023 at 12:45:42PM +0100, Aymeric Vitte wrote:\n> As far as I can read nobody replied to the initial question: what is\n> considered as good/best practice to store in Bitcoin?\n\nYour answer is beyond not putting unspendable data in the UTXO set, the exact\ndetails don't really matter. Do what makes sense for your specific application.\n\n> Reiterating my question: what are the current rules for OP_RETURN, max\n> size and number of OP_RETURN per tx\n\nMax 80 bytes, one OpReturn output per tx.\n\nThis of course is the standardness rule. With a miner willing to mine non-std\ntransactions anything goes.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/e757e764/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-02T12:24:12",
                "message_text_only": "Thanks, then this limitation should be rethought I think (see the email\nI just sent replying to the coloured thread)\n\nBecause it forces people to store in witness (less easy to track/show I\nbelieve) or adopt some deviant behavior (like storing in addresses where\nthe utxo will remain unspendable forever)\n\n\nLe 02/02/2023 \u00e0 12:49, Peter Todd a \u00e9crit :\n> On Thu, Feb 02, 2023 at 12:45:42PM +0100, Aymeric Vitte wrote:\n>> As far as I can read nobody replied to the initial question: what is\n>> considered as good/best practice to store in Bitcoin?\n> Your answer is beyond not putting unspendable data in the UTXO set, the exact\n> details don't really matter. Do what makes sense for your specific application.\n>\n>> Reiterating my question: what are the current rules for OP_RETURN, max\n>> size and number of OP_RETURN per tx\n> Max 80 bytes, one OpReturn output per tx.\n>\n> This of course is the standardness rule. With a miner willing to mine non-std\n> transactions anything goes.\n>\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-01T12:59:40",
                "message_text_only": "Could someone clarify what is the standard for OP_RETURN? As far as I\nunderstand the data is limited to 80B and only one OP_RETURN is allowed\nin one transaction, if not the tx is non standard, correct?\n\nThen the debate can be to store in witness indeed\n\nOr you can store in output addresses (with super big size), then you\nwill never be able to spend the dust and we have a utxo forever\n\nIn any case there is a storage workaround, probably others exist, not\nsure why people are so opposed to a OP_RETURN bitcoin storage (I thought\nthe max size was 512B, but apparently I am wrong, 80B is ridiculous,\ncan't do anything with this, except bypassing this limit by other worse\nmeans)\n\nStorage is the main difference between bitcoin and other systems\n(ethereum), without it, repeating myself here again the future of\nbitcoin is very limited\n\nPS: I saw the answer of Peter, I am proposing something else for\ntimestamp proofs\n\nLe 01/02/2023 \u00e0 01:46, Christopher Allen via bitcoin-dev a \u00e9crit :\n> All other things being equal, which is better if you need to place a\n> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a\n> spent taproot transaction such as:\n>\n> OP_FALSE\n> OP_IF \n> OP_PUSH my64bytes\n> OP_ENDIF\n>\n> I know that the anti-OP_RETURN folk would say \u201cneither.\u201d But if there\n> was no other choice for a particular protocol, such as a timestamp or\n> a commitment, which is better? Or is there a safer place to put 64\n> bytes that is more uncensorable but also does not clog UTXO space,\n> only spent transaction `-txindex` space?\n>\n> My best guess was that the taproot method is better, but I suspect\n> there might be some who disagree. I'd love to hear all sides.\n>\n> -- Christopher Allen\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230201/0fed77e3/attachment-0001.html>"
            },
            {
                "author": "Rijndael",
                "date": "2023-02-02T13:25:41",
                "message_text_only": "Hello Christopher,\n\nI think if the protocol that you were designing always had <80 bytes,\nI'd prefer the OP_RETURN. I think the \"witness envelope\" has two major\ndisadvantages compared to the OP_RETURN method:\n\n1. You need to first spend to he address that commits to the script that\nencodes your data payload. So you have a two step process of first\nspending to a \"commitment\" address and then a second spend to \"reveal\"\nyour payload. You can CPFP to get them both into the same block, but its\nstill two transactions, so more cost, etc.\n\n2. Because of the two step process in (1), if for some reason you were\nunable to get the \"reveal\" transaction into a block (for example there's\nwidespread censorship of transactions that match the format of the\n\"reveal\" script), then you might have money that's stuck in the \"commit\"\nstage of the protocol. The way out of this would be to get your money\nout via the keypath or another tapleaf, but then you need to spend money\nto cancel a step in your protocol. Of course there could be widespread\ncensorship of your OP_RETURNs too, but you don't have to spend funds on\nthe cancellation spends.\n\nI think (2) is actually a pretty weak argument because as we saw in the\nfull-rbf discussion, as long as there's some threshold number of nodes\nin the network that relay transactions to miners, you can probably find\na path to a miner (IIRC the number was on the order of 15% of the\nnetwork?). So I think the big reason to pick OP_RETURN over the witness\nembedding is that you save a transaction and possibly some\nfailure-recovery/cancellation logic.\n\nObviously if your data is larger than 80 bytes, then you probably want\nto do the witness-embedding method. If your data smaller, then a\npay-to-contract tweak probably the best thing from a space and\nfingerprinting perspective.\n\n- rijndael\n\n\nOn 1/31/23 7:46 PM, Christopher Allen via bitcoin-dev wrote:\n> All other things being equal, which is better if you need to place a\n> 64-bytes into the Bitcoin blockchain? A traditional\u00a0OP_RETURN\u00a0or a\n> spent taproot transaction such as:\n>\n> OP_FALSE\n> OP_IF\n> OP_PUSH my64bytes\n> OP_ENDIF\n>\n> I know that the anti-OP_RETURN folk would say \u201cneither.\u201d But if there\n> was no other choice for a particular protocol, such as a timestamp or\n> a commitment, which is better? Or is there a safer place to put 64\n> bytes that is more uncensorable but also does not clog UTXO space,\n> only spent transaction `-txindex` space?\n>\n> My best guess was that the taproot method is better, but I suspect\n> there might be some who disagree. I'd love to hear all sides.\n>\n> -- Christopher Allen\n>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-03T11:15:14",
                "message_text_only": "Indeed the witness envelope is more costly and less easy to use (or\nread/track)\n\nBut let's take a standard P2PKH or P2WPKH output,  what prevents me from\nadding in the beginning of scriptSig or witness while spending it:\nOP_PUSH <data> OP_DROP ? Non standard ? This one makes one transaction only\n\nThere are probably plenty of ways to store data, another one would be to\nuse a dummy 1 of N multisig where only 1 corresponds to a pubkey and the\nrest is data, but again several transactions...\n\nI think the right way so people don't invent deviant things is to\nincrease the size of OP_RETURN, I don't get this number of 80B, you can\nhardly store a signature (of what?) in there and not the \"what\" if the\n\"what\" is a hash for example\n\n\nLe 02/02/2023 \u00e0 14:25, Rijndael via bitcoin-dev a \u00e9crit :\n> Hello Christopher,\n>\n> I think if the protocol that you were designing always had <80 bytes,\n> I'd prefer the OP_RETURN. I think the \"witness envelope\" has two major\n> disadvantages compared to the OP_RETURN method:\n>\n> 1. You need to first spend to he address that commits to the script that\n> encodes your data payload. So you have a two step process of first\n> spending to a \"commitment\" address and then a second spend to \"reveal\"\n> your payload. You can CPFP to get them both into the same block, but its\n> still two transactions, so more cost, etc.\n>\n> 2. Because of the two step process in (1), if for some reason you were\n> unable to get the \"reveal\" transaction into a block (for example there's\n> widespread censorship of transactions that match the format of the\n> \"reveal\" script), then you might have money that's stuck in the \"commit\"\n> stage of the protocol. The way out of this would be to get your money\n> out via the keypath or another tapleaf, but then you need to spend money\n> to cancel a step in your protocol. Of course there could be widespread\n> censorship of your OP_RETURNs too, but you don't have to spend funds on\n> the cancellation spends.\n>\n> I think (2) is actually a pretty weak argument because as we saw in the\n> full-rbf discussion, as long as there's some threshold number of nodes\n> in the network that relay transactions to miners, you can probably find\n> a path to a miner (IIRC the number was on the order of 15% of the\n> network?). So I think the big reason to pick OP_RETURN over the witness\n> embedding is that you save a transaction and possibly some\n> failure-recovery/cancellation logic.\n>\n> Obviously if your data is larger than 80 bytes, then you probably want\n> to do the witness-embedding method. If your data smaller, then a\n> pay-to-contract tweak probably the best thing from a space and\n> fingerprinting perspective.\n>\n> - rijndael\n>\n>\n> On 1/31/23 7:46 PM, Christopher Allen via bitcoin-dev wrote:\n>> All other things being equal, which is better if you need to place a\n>> 64-bytes into the Bitcoin blockchain? A traditional OP_RETURN or a\n>> spent taproot transaction such as:\n>>\n>> OP_FALSE\n>> OP_IF\n>> OP_PUSH my64bytes\n>> OP_ENDIF\n>>\n>> I know that the anti-OP_RETURN folk would say \u201cneither.\u201d But if there\n>> was no other choice for a particular protocol, such as a timestamp or\n>> a commitment, which is better? Or is there a safer place to put 64\n>> bytes that is more uncensorable but also does not clog UTXO space,\n>> only spent transaction `-txindex` space?\n>>\n>> My best guess was that the taproot method is better, but I suspect\n>> there might be some who disagree. I'd love to hear all sides.\n>>\n>> -- Christopher Allen\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "Christopher Allen",
                "date": "2023-02-03T18:47:17",
                "message_text_only": "On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I think the right way so people don't invent deviant things is to\n> increase the size of OP_RETURN, I don't get this number of 80B, you can\n> hardly store a signature (of what?) in there and not the \"what\" if the\n> \"what\" is a hash for example\n>\n\nUpdating the size of OP_RETURN to support a hash (or two), a signature, and\nmaybe a few more bytes for metadata, would be very helpful in a number of\nscenarios. It is still a limit but a reasonable one. Otherwise, I think\nwe'll have a lot more inscription-style scenarios.\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/b21fe300/attachment.html>"
            },
            {
                "author": "Kostas Karasavvas",
                "date": "2023-02-04T14:11:33",
                "message_text_only": "On Fri, Feb 3, 2023 at 10:17 PM Christopher Allen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I think the right way so people don't invent deviant things is to\n>> increase the size of OP_RETURN, I don't get this number of 80B, you can\n>> hardly store a signature (of what?) in there and not the \"what\" if the\n>> \"what\" is a hash for example\n>>\n>\n> Updating the size of OP_RETURN to support a hash (or two), a signature,\n> and maybe a few more bytes for metadata, would be very helpful in a number\n> of scenarios. It is still a limit but a reasonable one. Otherwise, I think\n> we'll have a lot more inscription-style scenarios.\n>\n\nI wouldn't be against an increase in OP_RETURN but I don't think it will\nmake any difference in how often inscription-style use cases will be used.\nThey will be used primarily for much larger datasets than, say 120 bytes,\nand they also have the segwit discount.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/c2c7730d/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-04T17:01:20",
                "message_text_only": "I don't get very well where all the current (other threats) discussions\nare going, storing on-chain is absurd\n\nIt's absurd also to flood bitcoin with several useless transactions to\nstore in witness or others, looks like ethereum messy stuff\n\nWhat is not absurd is to store the proofs that can be checked using a\nnotorious third party/sidechain but you need more than 80B\n\nWhat is the official bitcoin channel to request the OP_RETURN size\nchange? (press often mentions that ethereum is good to manage changes\nand bitcoin a complete zero)\n\nAs a very bad solution, I think I would be willing to store data in\naddresses, with one single transaction, as people did in the past, then\nburning bitcoins but still not expensive, or less than several txs,\nbecause schemes involving several transactions do not work very well\n\nIn any case, we see the problem, then people will invent something and\nmost likely it will not comply at all with bitcoin good practices\n\n\nLe 04/02/2023 \u00e0 15:11, Kostas Karasavvas via bitcoin-dev a \u00e9crit :\n>\n>\n> On Fri, Feb 3, 2023 at 10:17 PM Christopher Allen via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     On Fri, Feb 3, 2023 at 3:52 AM Aymeric Vitte via bitcoin-dev\n>     <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>         I think the right way so people don't invent deviant things is to\n>         increase the size of OP_RETURN, I don't get this number of\n>         80B, you can\n>         hardly store a signature (of what?) in there and not the\n>         \"what\" if the\n>         \"what\" is a hash for example\n>\n>\n>     Updating the size of OP_RETURN to support a hash (or two), a\n>     signature, and maybe a few more bytes for metadata, would be very\n>     helpful in a number of scenarios. It is still a limit but a\n>     reasonable one. Otherwise, I think we'll have a lot more\n>     inscription-style scenarios.\n>\n>\n> I wouldn't be against an increase in OP_RETURN but I don't think it\n> will make any difference in how often inscription-style use cases will\n> be used. They will be used primarily for much larger datasets than,\n> say 120 bytes, and they also have the segwit discount.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/5dfda935/attachment.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2023-02-04T18:54:41",
                "message_text_only": "On Sat, Feb 4, 2023 at 9:01 AM Aymeric Vitte <aymeric at peersm.com> wrote:\n\n> What is the official bitcoin channel to request the OP_RETURN size change?\n> (press often mentions that ethereum is good to manage changes and bitcoin a\n> complete zero.\n>\nHere is the simplified version:\n\nMost of these changes start with discussions like these, but then are moved\nconcretely to a PR to bitcoin-core with the code changes (in this case\nthere is no fork so pretty easy) and an introductory comment pointing to\ndiscussions elsewhere.\n\nThe conversation will also move to the PR itself. Part of the challenge now\nis getting review of your PRs - you\u2019ll need to evangelize some and/or have\nsocial capital in the bitcoin community to get sufficient ACKs to your PR\n(and some NACKs which you will calmly addres), and someone will likely\npoint something out you missed, so you revise the PR.\n\nAt some point hopefully there looks like all reasonable objections have\nbeen addressed.\n\nIf there is enough interest and few objections there will be discussions by\nthe community & maintainers to merge it. It is this last part that isn\u2019t\nvery transparent, especially for even a good proposal. The maintainers,\nbased on their sense of the community\u2019s interest and consensus, must choose\nwhen to say it is ready, and then decide when and to which release they\nwish to merge it.\n\nThey often start by requesting you to revise your changes to be off by\ndefault, and be turned on as an option for a specific release. Often PR\ncontributors know this is coming and include it.\n\nEven once it is released, this type of change can only happen after\nsufficient miners and nodes update to the release and turn it on. If\nsufficient do, then the maintainers evaluate when to have the feature on by\ndefault.\n\nThese articles offers more perspective:\n\n   -\n\n   https://unchained.com/blog/contributing-bitcoin-core-patience/\n   -\n\n\n   https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core\n   -\n\n   https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365\n\n\u2014 Christopher Allen\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/55d4fec8/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-04T20:55:47",
                "message_text_only": "Thanks Christopher, then I understand the process:\n\n- I must issue a PR where I switch 80 to another number, even if I am\nnot a C/C++ expert it looks easy\n\n- I  must stay calm and answer all outstanding concerns about this\ntrivial change\n\n- Since I am not as clever as the bitcoin devs I must be ready to revise\nmy PR at any time\n\n- This could lead for the change to be from 80B to 82.xB where x comes\nfrom a non understandable crypto formula\n\n- I must evangelize the change worldwide\n\n- Once accepted, I must collude (pay) with the nodes/miners so they\nupdate at a subtile block height decided by the community\n\nAnd then I must pray that the PR does not survive myself\n\nLooks like a pretty straight forward process\n\nI am on this list since quite some time, so, seriously, this change is\nneeded, or, as I said before, deviant behaviours will happen, because\nthe \"witness trick\" or others do not work at all, and are clearly\nsimilar to ethereum messy stuff\n\n\nLe 04/02/2023 \u00e0 19:54, Christopher Allen a \u00e9crit :\n> On Sat, Feb 4, 2023 at 9:01 AM Aymeric Vitte <aymeric at peersm.com\n> <mailto:aymeric at peersm.com>> wrote:\n>\n>     What is the official bitcoin channel to request the OP_RETURN size\n>     change? (press often mentions that ethereum is good to manage\n>     changes and bitcoin a complete zero.\n>\n> Here is the simplified version:\n>\n> Most of these changes start with discussions like these, but then are\n> moved concretely to a PR to bitcoin-core with the code changes (in\n> this case there is no fork so pretty easy) and an introductory comment\n> pointing to discussions elsewhere. \n>\n> The conversation will also move to the PR itself. Part of the\n> challenge now is getting review of your PRs - you\u2019ll need to\n> evangelize some and/or have social capital in the bitcoin community to\n> get sufficient ACKs to your PR (and some NACKs which you will calmly\n> addres), and someone will likely point something out you missed, so\n> you revise the PR. \n>\n> At some point hopefully there looks like all reasonable objections\n> have been addressed.\n>\n> If there is enough interest and few objections there will be\n> discussions by the community & maintainers to merge it. It is this\n> last part that isn\u2019t very transparent, especially for even a good\n> proposal. The maintainers, based on their sense of the community\u2019s\n> interest and consensus, must choose when to say it is ready, and then\n> decide when and to which release they wish to merge it.\n>\n> They often start by requesting you to revise your changes to be off by\n> default, and be turned on as an option for a specific release. Often\n> PR contributors know this is coming and include it.\n>\n> Even once it is released, this type of change can only happen after\n> sufficient miners and nodes update to the release and turn it on. If\n> sufficient do, then the maintainers evaluate when to have the feature\n> on by default.\n>\n> These articles offers more perspective: \n>\n>  *\n>\n>     https://unchained.com/blog/contributing-bitcoin-core-patience/\n>\n>  *\n>\n>     https://jonatack.github.io/articles/how-to-contribute-pull-requests-to-bitcoin-core\n>\n>  *\n>\n>     https://medium.com/@amitiu/onboarding-to-bitcoin-core-7c1a83b20365\n>\n> \u2014 Christopher Allen \n>\n>\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/889a52b1/attachment-0001.html>"
            },
            {
                "author": "Christopher Allen",
                "date": "2023-02-04T22:18:06",
                "message_text_only": "On Sat, Feb 4, 2023 at 12:55 PM Aymeric Vitte <aymeric at peersm.com> wrote:\n\n> Thanks Christopher, then I understand the process:\n>\n> - I must issue a PR where I switch 80 to another number, even if I am not\n> a C/C++ expert it looks easy\n>\nYes, this would be an easy PR, at least to start. I suspect that\nlonger-term, you'd need to draft some assistance to make it turn on/off\nfrom when the bitcoin daemon is initialized. But that could wait until the\nconversation has progressed some.\n\nThe harder part will be writing the initial comment, where you should\ncarefully explain the rationale, link to some existing conversations, try\nto point out in advance the obvious objections and rationale despite them,\nand explain your particular choice of number \u2014 520 because that is a\nsimilar limit in taproot? Some multiple of hash+signature+metadata to\nsatisfy others (that still might not be satisfied by any choice).\n\n> - I  must stay calm and answer all outstanding concerns about this trivial\n> change\n>\n> - Since I am not as clever as the bitcoin devs I must be ready to revise\n> my PR at any time\n>\n> - This could lead for the change to be from 80B to 82.xB where x comes\n> from a non understandable crypto formula\n>\n> - I must evangelize the change worldwide\n>\n> - Once accepted, I must collude (pay) with the nodes/miners so they update\n> at a subtile block height decided by the community\n>\nThat is true for forks, but I don't think this is a fork. It might require\nresolving some mempool issues (for instance for mining pools). But for it\nto become non-optional, you'll need to demonstrate that miners and full\nnodes have turned it on. Thus that is more a conversation than \"collusion\n(pay)\".\n\n> And then I must pray that the PR does not survive myself\n>\n> Looks like a pretty straight forward process.\n>\nI've seen worse. I co-authored TLS 1.0 (6 years) and DID 1.0 (5 years).\n\n> I am on this list since quite some time, so, seriously, this change is\n> needed, or, as I said before, deviant behaviours will happen, because the\n> \"witness trick\" or others do not work at all, and are clearly similar to\n> ethereum messy stuff\n>\nYou have at least Concept ACK from me! ;-)\n\n-- Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/00878238/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-04T23:09:02",
                "message_text_only": "I don't know, what number would you advise? When I made the\nbitcoin-transactions nodejs module some years ago the limit (from the\nspecs) was 512B\n\nIt's not a fork, super easy to do\n\nAnd necessary because bitcoin on ground of I don't know what rule\nallowing the IF/ENDIF \"unlimited\" storage just mimics ethereum for the\nworse, and is again quite dubious to use\n\n\nLe 04/02/2023 \u00e0 23:18, Christopher Allen a \u00e9crit :\n> 520 because that is a similar limit in taproot? Some multiple of\n> hash+signature+metadata to satisfy others (that still might not be\n> satisfied by any choice)."
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-05T00:04:04",
                "message_text_only": "On February 5, 2023 12:09:02 AM GMT+01:00, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>I don't know, what number would you advise? When I made the\n>bitcoin-transactions nodejs module some years ago the limit (from the\n>specs) was 512B\n\n1) Allowing only one OpReturn output causes problems trying to compose different uses of OpReturn. We should allow any number of OpReturn outputs.\n\n2) There's no reason to put a size limit given all the other ways people can publish data, including with a 75% discount. Let the fee market deal with it."
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-05T11:40:38",
                "message_text_only": "I think logically:\n\n- if you want to store something big and can afford several txs in your\ndesign, then you use something like witness\n\n- if you want to store small things like signatures, addresses hashes\nand some metadata and your design does not make several txs easy, then\nyou use OP_RETURN\n\nThen how can we move forward with several OP_RETURN and no size limit?\n\nI can start posting a bug/enhancement proposal in bitcoin repo but can't\nwrite the PR\n\n\nLe 05/02/2023 \u00e0 01:04, Peter Todd a \u00e9crit :\n>\n> On February 5, 2023 12:09:02 AM GMT+01:00, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> I don't know, what number would you advise? When I made the\n>> bitcoin-transactions nodejs module some years ago the limit (from the\n>> specs) was 512B\n> 1) Allowing only one OpReturn output causes problems trying to compose different uses of OpReturn. We should allow any number of OpReturn outputs.\n>\n> 2) There's no reason to put a size limit given all the other ways people can publish data, including with a 75% discount. Let the fee market deal with it.\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-05T12:06:33",
                "message_text_only": "On February 5, 2023 12:40:38 PM GMT+01:00, Aymeric Vitte <aymeric at peersm.com> wrote:\n>I think logically:\n>\n>- if you want to store something big and can afford several txs in your\n>design, then you use something like witness\n>\n>- if you want to store small things like signatures, addresses hashes\n>and some metadata and your design does not make several txs easy, then\n>you use OP_RETURN\n>\n>Then how can we move forward with several OP_RETURN and no size limit?\n\nBecause what matters is the impact on other users. OpReturn isn't in UTXO space and doesn't even take advantage of the witness discount, so it clearly has minimal impact.\n\nSince it has minimal impact, there's no reason to micromanage exactly how people use it. Let them decide for themselves with the fee market. This is exactly the same as how we didn't put artificial limits on Taproot."
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-05T12:47:38",
                "message_text_only": "Yes I agree, let people decide and since taproot has no limits then it\nsould be the same for OP_RETURN\n\nI posted https://github.com/bitcoin/bitcoin/issues/27043\n\n\nLe 05/02/2023 \u00e0 13:06, Peter Todd a \u00e9crit :\n>\n> On February 5, 2023 12:40:38 PM GMT+01:00, Aymeric Vitte <aymeric at peersm.com> wrote:\n>> I think logically:\n>>\n>> - if you want to store something big and can afford several txs in your\n>> design, then you use something like witness\n>>\n>> - if you want to store small things like signatures, addresses hashes\n>> and some metadata and your design does not make several txs easy, then\n>> you use OP_RETURN\n>>\n>> Then how can we move forward with several OP_RETURN and no size limit?\n> Because what matters is the impact on other users. OpReturn isn't in UTXO space and doesn't even take advantage of the witness discount, so it clearly has minimal impact.\n>\n> Since it has minimal impact, there's no reason to micromanage exactly how people use it. Let them decide for themselves with the fee market. This is exactly the same as how we didn't put artificial limits on Taproot.\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-05T00:11:35",
                "message_text_only": "Since bytes in the witness are cheaper than bytes in the script pubkey,\nthere is a crossover point in data size where it will simply be cheaper to\nuse witness data.  Where that crossover point is depends on the finer\ndetails of the overhead of the two methods, but you could make some\nreasonable assumptions.  Such a calculation could form the basis of a\nreasonable OP_RETURN proposal.  I don't know if it would be persuasive, but\nit would at least be coherent.\n\nOn Sat., Feb. 4, 2023, 18:17 Aymeric Vitte via bitcoin-dev, <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I don't know, what number would you advise? When I made the\n> bitcoin-transactions nodejs module some years ago the limit (from the\n> specs) was 512B\n>\n> It's not a fork, super easy to do\n>\n> And necessary because bitcoin on ground of I don't know what rule\n> allowing the IF/ENDIF \"unlimited\" storage just mimics ethereum for the\n> worse, and is again quite dubious to use\n>\n>\n> Le 04/02/2023 \u00e0 23:18, Christopher Allen a \u00e9crit :\n> > 520 because that is a similar limit in taproot? Some multiple of\n> > hash+signature+metadata to satisfy others (that still might not be\n> > satisfied by any choice).\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/248ec360/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-05T02:01:08",
                "message_text_only": "On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>Since bytes in the witness are cheaper than bytes in the script pubkey,\n>there is a crossover point in data size where it will simply be cheaper to\n>use witness data.  Where that crossover point is depends on the finer\n>details of the overhead of the two methods, but you could make some\n>reasonable assumptions.  Such a calculation could form the basis of a\n>reasonable OP_RETURN proposal.  I don't know if it would be persuasive, but\n>it would at least be coherent.\n\nI don't think it's worth the technical complexity trying to carefully argue a specific limit. Let users decide for themselves how they want to use OpReturn."
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-05T18:12:52",
                "message_text_only": "On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org> wrote:\n\n>\n>\n> On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >Since bytes in the witness are cheaper than bytes in the script pubkey,\n> >there is a crossover point in data size where it will simply be cheaper to\n> >use witness data.  Where that crossover point is depends on the finer\n> >details of the overhead of the two methods, but you could make some\n> >reasonable assumptions.  Such a calculation could form the basis of a\n> >reasonable OP_RETURN proposal.  I don't know if it would be persuasive,\n> but\n> >it would at least be coherent.\n>\n> I don't think it's worth the technical complexity trying to carefully\n> argue a specific limit. Let users decide for themselves how they want to\n> use OpReturn.\n>\n\nEven better.\n\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230205/bfa453c8/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-12T16:23:59",
                "message_text_only": "https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403\n\n\"What is the process to have someone do the PR for this? Or I do it and\nmost likely it will be a very shxtty one since I am not a C/C++ expert,\nthen wasting the time of everybody\n\nIt's urgently required, I did consider OP_RETURN as a dart in the past\nbut changed my mind, it's adapted to the current evolutions, not\nflooding bitcoin with 2 txs while only 1 is needed\n\nIf not the best 1 tx solution is super simple: store in addresses, and\nsuper bad at the end because burning bitcoins, while still not expensive\nif you don't need to store big things\"\n\n\nLe 05/02/2023 \u00e0 19:12, Russell O'Connor via bitcoin-dev a \u00e9crit :\n>\n>\n> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org\n> <mailto:pete at petertodd.org>> wrote:\n>\n>\n>\n>     On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via\n>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>     >Since bytes in the witness are cheaper than bytes in the script\n>     pubkey,\n>     >there is a crossover point in data size where it will simply be\n>     cheaper to\n>     >use witness data.  Where that crossover point is depends on the finer\n>     >details of the overhead of the two methods, but you could make some\n>     >reasonable assumptions.  Such a calculation could form the basis of a\n>     >reasonable OP_RETURN proposal.  I don't know if it would be\n>     persuasive, but\n>     >it would at least be coherent.\n>\n>     I don't think it's worth the technical complexity trying to\n>     carefully argue a specific limit. Let users decide for themselves\n>     how they want to use OpReturn.\n>\n>\n> Even better.\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230212/715d4cbc/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-16T18:23:55",
                "message_text_only": "It's super unclear how long it could take for such a change to be adopted\n\nThen the answer is simple, see:\nhttps://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation\n\nOutstandingly, very, mega, bad, but working, bringing bitcoin back 10\nyears ago\n\nBut why not? If bitcoin folks don't get that we need a 1tx storage\nsolution for the future, then let's bring back bitcoin into the past and\ndestroy coins\n\nLe 12/02/2023 \u00e0 17:23, Aymeric Vitte a \u00e9crit :\n>\n> https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403\n>\n> \"What is the process to have someone do the PR for this? Or I do it\n> and most likely it will be a very shxtty one since I am not a C/C++\n> expert, then wasting the time of everybody\n>\n> It's urgently required, I did consider OP_RETURN as a dart in the past\n> but changed my mind, it's adapted to the current evolutions, not\n> flooding bitcoin with 2 txs while only 1 is needed\n>\n> If not the best 1 tx solution is super simple: store in addresses, and\n> super bad at the end because burning bitcoins, while still not\n> expensive if you don't need to store big things\"\n>\n>\n> Le 05/02/2023 \u00e0 19:12, Russell O'Connor via bitcoin-dev a \u00e9crit :\n>>\n>>\n>> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org\n>> <mailto:pete at petertodd.org>> wrote:\n>>\n>>\n>>\n>>     On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via\n>>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>     >Since bytes in the witness are cheaper than bytes in the script\n>>     pubkey,\n>>     >there is a crossover point in data size where it will simply be\n>>     cheaper to\n>>     >use witness data.  Where that crossover point is depends on the\n>>     finer\n>>     >details of the overhead of the two methods, but you could make some\n>>     >reasonable assumptions.  Such a calculation could form the basis\n>>     of a\n>>     >reasonable OP_RETURN proposal.  I don't know if it would be\n>>     persuasive, but\n>>     >it would at least be coherent.\n>>\n>>     I don't think it's worth the technical complexity trying to\n>>     carefully argue a specific limit. Let users decide for themselves\n>>     how they want to use OpReturn.\n>>\n>>\n>> Even better.\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> -- \n> Sophia-Antipolis, France\n> CV: https://www.peersm.com/CVAV.pdf\n> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n> GitHub : https://www.github.com/Ayms\n> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\n> Peersm : http://www.peersm.com\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/59e07bc2/attachment-0001.html>"
            },
            {
                "author": "Claus Ehrenberg",
                "date": "2023-02-16T19:59:06",
                "message_text_only": "I propose to require all data to be in the op_return output PLUS add a\nrequired op_return_hash field, which is checked by consensus. So that node\ncan re-validate the chain without having to store/download/look at the\ncontents of op_return data. The benefit of that little redundancy is that\n\"content-sensitive\" communities can ignore the date they don't like.\n\nCheers\nClaus\n\nOn Thu, Feb 16, 2023 at 7:30 PM Aymeric Vitte via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It's super unclear how long it could take for such a change to be adopted\n>\n> Then the answer is simple, see:\n> https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation\n>\n> Outstandingly, very, mega, bad, but working, bringing bitcoin back 10\n> years ago\n>\n> But why not? If bitcoin folks don't get that we need a 1tx storage\n> solution for the future, then let's bring back bitcoin into the past and\n> destroy coins\n> Le 12/02/2023 \u00e0 17:23, Aymeric Vitte a \u00e9crit :\n>\n> https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403\n>\n> \"What is the process to have someone do the PR for this? Or I do it and\n> most likely it will be a very shxtty one since I am not a C/C++ expert,\n> then wasting the time of everybody\n>\n> It's urgently required, I did consider OP_RETURN as a dart in the past but\n> changed my mind, it's adapted to the current evolutions, not flooding\n> bitcoin with 2 txs while only 1 is needed\n>\n> If not the best 1 tx solution is super simple: store in addresses, and\n> super bad at the end because burning bitcoins, while still not expensive if\n> you don't need to store big things\"\n>\n> Le 05/02/2023 \u00e0 19:12, Russell O'Connor via bitcoin-dev a \u00e9crit :\n>\n>\n>\n> On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org> wrote:\n>\n>>\n>>\n>> On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor via\n>> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> >Since bytes in the witness are cheaper than bytes in the script pubkey,\n>> >there is a crossover point in data size where it will simply be cheaper\n>> to\n>> >use witness data.  Where that crossover point is depends on the finer\n>> >details of the overhead of the two methods, but you could make some\n>> >reasonable assumptions.  Such a calculation could form the basis of a\n>> >reasonable OP_RETURN proposal.  I don't know if it would be persuasive,\n>> but\n>> >it would at least be coherent.\n>>\n>> I don't think it's worth the technical complexity trying to carefully\n>> argue a specific limit. Let users decide for themselves how they want to\n>> use OpReturn.\n>>\n>\n> Even better.\n>\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> --\n> Sophia-Antipolis, France\n> CV: https://www.peersm.com/CVAV.pdf\n> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n> GitHub : https://www.github.com/Ayms\n> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\n> Peersm : http://www.peersm.com\n>\n>\n> --\n> Sophia-Antipolis, France\n> CV: https://www.peersm.com/CVAV.pdf\n> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n> GitHub : https://www.github.com/Ayms\n> A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n> A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\n> Peersm : http://www.peersm.com\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/8a0f80cf/attachment.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-17T10:56:19",
                "message_text_only": "Hi Claus,\n\nThanks but I am not sure to understand the solution, how the transaction\nwill look like and will it be standard ?\n\nRegards\n\nAymeric\n\n\nLe 16/02/2023 \u00e0 20:59, Claus Ehrenberg a \u00e9crit :\n> I propose to require all data to be in the op_return output PLUS add a\n> required op_return_hash field, which is checked by consensus. So that\n> node can re-validate the chain without having to store/download/look\n> at the contents of op_return data. The benefit of that little\n> redundancy is that \"content-sensitive\" communities can ignore the date\n> they don't like.\n>\n> Cheers\n> Claus\n>\n> On Thu, Feb 16, 2023 at 7:30 PM Aymeric Vitte via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org\n> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>\n>     It's super unclear how long it could take for such a change to be\n>     adopted\n>\n>     Then the answer is simple, see:\n>     https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7#workaround-to-the-80b-op_return-limitation\n>\n>     Outstandingly, very, mega, bad, but working, bringing bitcoin back\n>     10 years ago\n>\n>     But why not? If bitcoin folks don't get that we need a 1tx storage\n>     solution for the future, then let's bring back bitcoin into the\n>     past and destroy coins\n>\n>     Le 12/02/2023 \u00e0 17:23, Aymeric Vitte a \u00e9crit :\n>>\n>>     https://github.com/bitcoin/bitcoin/issues/27043#issuecomment-1427069403\n>>\n>>     \"What is the process to have someone do the PR for this? Or I do\n>>     it and most likely it will be a very shxtty one since I am not a\n>>     C/C++ expert, then wasting the time of everybody\n>>\n>>     It's urgently required, I did consider OP_RETURN as a dart in the\n>>     past but changed my mind, it's adapted to the current evolutions,\n>>     not flooding bitcoin with 2 txs while only 1 is needed\n>>\n>>     If not the best 1 tx solution is super simple: store in\n>>     addresses, and super bad at the end because burning bitcoins,\n>>     while still not expensive if you don't need to store big things\"\n>>\n>>\n>>     Le 05/02/2023 \u00e0 19:12, Russell O'Connor via bitcoin-dev a \u00e9crit :\n>>>\n>>>\n>>>     On Sat., Feb. 4, 2023, 21:01 Peter Todd, <pete at petertodd.org\n>>>     <mailto:pete at petertodd.org>> wrote:\n>>>\n>>>\n>>>\n>>>         On February 5, 2023 1:11:35 AM GMT+01:00, Russell O'Connor\n>>>         via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org\n>>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:\n>>>         >Since bytes in the witness are cheaper than bytes in the\n>>>         script pubkey,\n>>>         >there is a crossover point in data size where it will\n>>>         simply be cheaper to\n>>>         >use witness data.  Where that crossover point is depends on\n>>>         the finer\n>>>         >details of the overhead of the two methods, but you could\n>>>         make some\n>>>         >reasonable assumptions.  Such a calculation could form the\n>>>         basis of a\n>>>         >reasonable OP_RETURN proposal.  I don't know if it would be\n>>>         persuasive, but\n>>>         >it would at least be coherent.\n>>>\n>>>         I don't think it's worth the technical complexity trying to\n>>>         carefully argue a specific limit. Let users decide for\n>>>         themselves how they want to use OpReturn.\n>>>\n>>>\n>>>     Even better.\n>>>\n>>>\n>>>\n>>>     _______________________________________________\n>>>     bitcoin-dev mailing list\n>>>     bitcoin-dev at lists.linuxfoundation.org\n>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>     -- \n>>     Sophia-Antipolis, France\n>>     CV: https://www.peersm.com/CVAV.pdf\n>>     LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n>>     GitHub : https://www.github.com/Ayms\n>>     A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n>>     A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n>>     Move your coins by yourself (browser version): https://peersm.com/wallet\n>>     Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n>>     torrent-live: https://github.com/Ayms/torrent-live\n>>     node-Tor : https://www.github.com/Ayms/node-Tor\n>>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\n>>     Peersm : http://www.peersm.com\n>\n>     -- \n>     Sophia-Antipolis, France\n>     CV: https://www.peersm.com/CVAV.pdf\n>     LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n>     GitHub : https://www.github.com/Ayms\n>     A Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n>     A bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n>     Move your coins by yourself (browser version): https://peersm.com/wallet\n>     Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n>     torrent-live: https://github.com/Ayms/torrent-live\n>     node-Tor : https://www.github.com/Ayms/node-Tor\n>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\n>     Peersm : http://www.peersm.com\n>\n>     _______________________________________________\n>     bitcoin-dev mailing list\n>     bitcoin-dev at lists.linuxfoundation.org\n>     <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/e26f5760/attachment-0001.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-05T18:06:18",
                "message_text_only": "On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> Since bytes in the witness are cheaper than bytes in the script pubkey,\n> there is a crossover point in data size where it will simply be cheaper to\n> use witness data.  Where that crossover point is depends on the finer\n> details of the overhead of the two methods, but you could make some\n> reasonable assumptions.  Such a calculation could form the basis of a\n> reasonable OP_RETURN proposal.  I don't know if it would be persuasive, but\n> it would at least be coherent.\n>\n\nI agree with Peter that, given that users have found ways to store arbitrary\namounts of data on-chain if they really want, we might as well just make\nOP_RETURN a free-for-all.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230205/210aac82/attachment.sig>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-17T12:49:41",
                "message_text_only": "On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> Since bytes in the witness are cheaper than bytes in the script pubkey,\n> there is a crossover point in data size where it will simply be cheaper to\n> use witness data.\n\nGiven today's standardness constraints, that's true (because you first\nneed to construct a p2wsh/tapscript output that commits to the data,\nthen you have to spend it), but it needn't stay that way. Allowing a data\ncarrier entry in the annex (as contemplated for eltoo [0]) would allow\nyou to publish the data with a single transaction, with malleability\nprevented because the annex content is committed to by the signature.\n\n[0] https://github.com/bitcoin-inquisition/bitcoin/pull/22\n\nI think the cost for publishing data via the witness today is roughly:\n\n  115 vb - for the commitment tx\n  115 vb + datalen/4 - for the publication tx\n\nversus\n\n  125 vb + datalen - for a tx with an OP_RETURN output\n\nso the crossover point is at a datalen of about 140 bytes. Perhaps\nslightly more or less depending on how much you can combine these\ninputs/outputs with other txs you would have made anyway.\n\nWith a datacarrier in the annex that has similar or higher limits than\nOP_RETURN, I don't think OP_RETURN would ever be cheaper.\n\nThe other advantage to using the witness for random data compared to\nOP_RETURN is that the txid commits to OP_RETURN output, so you must\ndownload all OP_RETURN data to validate a block's merkle tree, whereas\nyou can partially validate a block (in particular, you can validate the\nspendable utxo set) without downloading witness data [1].\n\n[1] https://github.com/bitcoin/bitcoin/pull/27050\n\nCheers,\naj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-18T18:38:00",
                "message_text_only": "So with datacarrier we can store data in taproot annex with one tx which\nwill be data and/or extension of the script validation via PUSH_ANNEX\n\nI looked at your links and plenty of others, but had some hard time to\nfind the proposal\n(https://github.com/bitcoin/bips/blob/9dc3f74b384f143b7f1bdad30dc0fe2529c8e63f/bip-annex.mediawiki\nI suppose), when do you think datacarrier can happen for real on the\nnetwork?\n\nNow I think the OP_RETURN debate remains relevant, it's a quite trivial\nmodification to do, from my standpoint it is certainly not intended to\nstore big things (but 80B, what do you want to do with this?), but if\npeople want to store big things and pay for it... what is the real\nissue? (I saw your argument of \"partial\" block validation and others\nlike skipping witness data, at the end nodes must validate the whole thing)\n\n\nLe 17/02/2023 \u00e0 13:49, Anthony Towns a \u00e9crit :\n> On Sat, Feb 04, 2023 at 07:11:35PM -0500, Russell O'Connor via bitcoin-dev wrote:\n>> Since bytes in the witness are cheaper than bytes in the script pubkey,\n>> there is a crossover point in data size where it will simply be cheaper to\n>> use witness data.\n> Given today's standardness constraints, that's true (because you first\n> need to construct a p2wsh/tapscript output that commits to the data,\n> then you have to spend it), but it needn't stay that way. Allowing a data\n> carrier entry in the annex (as contemplated for eltoo [0]) would allow\n> you to publish the data with a single transaction, with malleability\n> prevented because the annex content is committed to by the signature.\n>\n> [0] https://github.com/bitcoin-inquisition/bitcoin/pull/22\n>\n> I think the cost for publishing data via the witness today is roughly:\n>\n>   115 vb - for the commitment tx\n>   115 vb + datalen/4 - for the publication tx\n>\n> versus\n>\n>   125 vb + datalen - for a tx with an OP_RETURN output\n>\n> so the crossover point is at a datalen of about 140 bytes. Perhaps\n> slightly more or less depending on how much you can combine these\n> inputs/outputs with other txs you would have made anyway.\n>\n> With a datacarrier in the annex that has similar or higher limits than\n> OP_RETURN, I don't think OP_RETURN would ever be cheaper.\n>\n> The other advantage to using the witness for random data compared to\n> OP_RETURN is that the txid commits to OP_RETURN output, so you must\n> download all OP_RETURN data to validate a block's merkle tree, whereas\n> you can partially validate a block (in particular, you can validate the\n> spendable utxo set) without downloading witness data [1].\n>\n> [1] https://github.com/bitcoin/bitcoin/pull/27050\n>\n> Cheers,\n> aj\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            }
        ],
        "thread_summary": {
            "title": "Debate: 64 bytes in OP_RETURN VS taproot OP_FALSE OP_IF OP_PUSH",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "Claus Ehrenberg",
                "Rijndael",
                "Anthony Towns",
                "Aymeric Vitte",
                "Peter Todd",
                "Andrew Poelstra",
                "Russell O'Connor",
                "Kostas Karasavvas"
            ],
            "messages_count": 34,
            "total_messages_chars_count": 75198
        }
    },
    {
        "title": "[bitcoin-dev] Pseudocode for robust tail emission",
        "thread_messages": [
            {
                "author": "jk_14 at op.pl",
                "date": "2023-02-01T22:04:11",
                "message_text_only": "'only' in this sentence: \"only two orders of magnitude higher\"\n- is just like in this one:\n\n\"We're raising $100,000 for the Tesla S and we're not short of $99,900, we're only short of $99,000...\"\n\n\n\n\nW dniu 2023-01-22 16:13:42 u\u017cytkownik John Tromp via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa\u0142:\n> > Right now the total reward per transaction is $63, three orders of magnitude\n> higher than typical fees.\n\nNo need to exaggerate; this is only two orders of magnitude higher\nthan current fees, which are typically over $0.50\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Pseudocode for robust tail emission",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "jk_14 at op.pl"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 720
        }
    },
    {
        "title": "[bitcoin-dev] Costless bribes against time-sensitive protocols",
        "thread_messages": [
            {
                "author": "Gleb Naumenko",
                "date": "2023-02-02T08:40:04",
                "message_text_only": "## Intro\n\nMost of it feels like implicit knowledge, but I couldn't find anything written so here it is. The ideas towards anchor outputs and the conclusions probably have some new perspectives.\n\nThis post is about the game-theoretic security of time-sensitive protocols if miners are open to censorship for a reward. To become practical, the following has to happen.\n\n1) a substantial hashrate has to be willing to participate in this behaviour, according to the known formula from the Whitepaper. The more blocks it takes to attack (defined by a particular protocol configuration and could be tuned), the exponentially higher % hashrate is required.\n\n2) a communication layer is required to send bribes to these miners. This could be a private transaction relay network, or a mempool allowing still-time-locked transactions. It could be even an announcement board (e.g., submitting raw txs under a Twitter hashtag and inviting miners to monitor it).\n\n3) a bribe transaction construction (will be explained later).\n\nIn this post, I talk about the case when:\n1. a significant hashrate (e.g., 95%+) is open to take these bribes;\n2. but miners don't trust each other;\n3. and there is no reorgs.\n\nAssumption \\*(2) is more nuanced. What I mean here is roughly \"miner X would rather take an immediate gain than commit to a lenghty scenario where many miners coordinate to take reward on behalf of each other and then distribute it accordingly to the hashrate\". The game theory of this assumption should be better defined in the future.\n\nWe will see, how widely known tweaks lift the bar for (2) and (3) and how this could be further improved.\n\n*A special case of this scenario is miners withholding Alice's transaction to force her to bump fees, even if Bob hasn't submitted a bribe. Here I assume miners won't do it unless there is an external incentive (Bob's bribe), although this issue is also interesting.*\n\n## Simple opcode-based construction\n\nThe simplest time-sensitive two-party contract is PowSwap (a bet on the future block issuance rate), a single on-chain UTXO with the following spending conditions:\n- Alice\u2019s key can spend if height=H is reached;\n- Bob\u2019s key can spend if Time=T is reached.\n\nSay H is approaching quickly, and T is far behind. Bob now uses a private mining relay to submit his non-mineable transaction paying e.g. half of the UTXO value towards fees.\n\nAlice has two problems: 1) she can\u2019t figure out why her transaction isn\u2019t mined and how much fee to overpay; 2) the attack is free for Bob (he has nothing to lose), while Alice loses everything up to the full UTXO value.\n\n## Simple nLockTime-based construction\n\nIf parties use pre-signed transactions with nLockTime (instead of the opcodes), Bob\u2019s fee can be pre-signed to a rather low value, so that Alice can reasonably overbid it without much loss (she probably doesn't even need to take any action).\n\nBob can, however, bump the fee by creating a CPFP transaction with super-high fee. All it requires now is submitting twice as much data to the private mining relay (and burning slightly more in fees).\n\n## nLockTime-based construction with OP_CSV output\n\nIf Bob\u2019s output can\u2019t be spent right away, but is forced to be deterred to even one block in the future, it makes taking this bribe not rational: a censoring miner can\u2019t be sure about the deferred reward (remember, miners don't trust each other). At the same time, mining the honest transaction and taking its fee is always available earlier.\n\nSmart contracts could possibly make it rational for miners (see [1]), e.g. by allowing Bob to allocate the bribe based on the historic hashrate distribution linked to coinbase pubkeys.\n\nAt the same time, this approach makes dynamic fee management impossible.\n\n## Anchor outputs\n\nAnchor outputs allow bringing external capital for fee management while locking internal capital. Bob can use this capital for a bribe. If the attack fails, Bob's external capital remains safe, so this is not so bad for Bob.\n\nThe attack can be more costly if this external capital was claimable:\n- by Alice: e.g., Alice can steal a (covenanted) anchor output if it's revealed before Bob's nLockTime makes it mineable (requires her to monitor the private relay);\n- or by miners, e.g. if Alice forces Bob, at contract setup, to use a reverse time-lock (the anchor can be stolen by miner if seen before time=T); or if mining Alice's honest transaction also allows miners to take Bob's fee output (e.g., Alice's honest transaction *could* act as a parent/preimage, conditionally, although this may require reverse time-locking Alice to protect Bob...)\n\n*Ephemeral anchors doesn\u2019t do much w.r.t. our trade-off, as it is a mempool-oriented thing.*\n\n## Lightning\n\nLightning is different from the described protocol in two things:\n1) It relies on intermediate transactions (e.g., Commitment in Poon-Dryja);\n2) Usually both parties have some balance in the channel.\n\nI believe that (1) doesn\u2019t change the situation much, it just makes it more nuanced.\n(2) is irrelevant because an attacker can just spend the entire channel before the attack.\nThus, most of these concerns apply to lightning equally.\n\n## Related work\n\nThe LN paper briefly mentioned this problem, although it was claimed impractical due to a high degree of required collusion. We already see private mining relay in\u00a0mevwatch.info\u00a0(ethereum), and we had FIBRE (I think it was neutral).\n\n[2] discussed constructions and economics for bribing miners. [1] suggests more practical considerations for achieving this. Both don\u2019t focus on the risks of particular time-sensitive protocol constructions.\n\n[3] highlighted a similar protocol risk, but the proposed solution seems to work only if an attacker has funds to lose locked in the contract (e.g., collateral, lightning balance, powswap payout).\n\n## Conclusions\n\nTo increase the attack bar w.r.t the configuration described in the intro, we should either:\n- stick to the *nLockTime-based construction with OP_CSV output*, forget about dynamic fee management, and hope that bribe allocation smart contracts doesn't work out;\n- use anchor outputs (or another external fee scheme), but enforce a way to steal/burn the external fee if it's an attack;\n- design new fee/channel constructions.\n\nThese ideas may also be helpful for alternative payment channels designs as well (v3+ephemeral anchors, SIGHASH_GROUP, etc.), or in the future to protect against more powerful covenants allowing stronger bribes (see [1]).\n\nThanks to Antoine Riard and Greg Sanders for initial discussion.\n\n-------------------------\n\n## References\n\n1. TxWithhold Smart Contracts by Gleb Naumenko | BitMEX Blog (https://blog.bitmex.com/txwithhold-smart-contracts/)\n2. Temporary Censorship Attacks in the Presence of Rational Miners (https://eprint.iacr.org/2019/748.pdf)\n3. MAD-HTLC: Because HTLC is Crazy-Cheap to Attack (https://arxiv.org/pdf/2006.12031.pdf)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/275a0387/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Costless bribes against time-sensitive protocols",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Gleb Naumenko"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 7074
        }
    },
    {
        "title": "[bitcoin-dev] Purely off-chain coin colouring",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2023-02-02T09:15:33",
                "message_text_only": "Hi *,\n\nCasey Rodarmor's ordinals use the technique of tracking the identity of\nindividual satoshis throughout their lifetime:\n\nOn Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n> Briefly, newly mined satoshis are sequentially numbered in the order in\n> which they are mined. These numbers are called \"ordinal numbers\" or\n> \"ordinals\". When satoshis are spent in a transaction, the input satoshi\n> ordinal numbers are assigned to output satoshis using a simple\n> first-in-first-out algorithm.\n\nThis is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408\n\nWhen accompanied by a standard for associating some data or right with\nsuch an identity, this allows the creation of non-fungible tokens (or\nsemi-fungible tokens) whose ownership can be transferred by a bitcoin\ntransaction.\n\nThe proposed BIP doesn't document any method for associating data or a\nright with an ordinal, but the \"ord\" tool defines \"inscriptions\" to fill\nthis gap [0], providing a way of including mime-encoded data in a taproot\nwitness. To make such an inscription, two transactions are required:\none paying some sats to a special scriptPubKey that commits to the\ninscribed data, and a second that spends those sats to the owner of the\nnewly inscribed ordinal, and in so doing revealing the full inscription.\n\n[0] https://docs.ordinals.com/inscriptions.html\n\nI think, however, that you can move inscriptions entirely off-chain. I\nwrote a little on this idea on twitter already [1], but after a bit more\nthought, I think pushing things even further off-chain would be plausible.\n\n[1] https://twitter.com/ajtowns/status/1619554871166013441\n\nIn particular, rather than looking at it as being the owner of the sats\nthat inscribes some content on those sats (analogously to signing a $100\nbill [2]), you could look at it as saying \"the owner of this thing is\nwhoever owns this particular sat\" (eg instead of \"whoever owns this\nshare certificate is a shareholder\", it's \"whoever owns the $1 bill with\nserial number X is a shareholder\").\n\n[2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers\n\nImplementing that is fairly straightforward: you just need a protocol\nfor creating an asset offchain and associating it with an ordinal --\nnothing needs to happen on-chain at all. That is, you can do something\nas simple as posting a single nostr message:\n\n  {\n    \"pubkey\": <creator's pubkey>\n    \"kind\": 0,\n    \"tags\": [\n      [\"ord\", \"txid:vout:sat\"]\n    ],\n    \"content\": [jpeg goes here],\n    \"id\": <hash of the above>\n    \"sig\": <signature of id by creator's pubkey>\n  }\n\nYou can prove current ownership of the message by showing a custody\nchain, that is the transaction specified by \"txid\" in the \"ord\" tag,\nthen every transaction that spent the given sat, until you get to one\nthat's still in the utxo set [3]. You don't need to provide witness\ndata or validate any of these tx's signatures, as that is already\nimplicit in that you end up at a tx in the utxo set. Just calculating\nthe txids and comparing against the output containing the sat you're\ninterested in is sufficient.\n\n[3] If the satoshi was lost to fees at some point, you could continue to\n    follow ownership by including an entire block in the custody chain.\n    But seems better to just consider it as \"abandoned\" or \"lost to the\n    public domain\" at that point.\n\nThis approach allows all the \"inscription\" data to be entirely off-chain,\nthe only thing that requires a transaction on-chain is transferring\nownership to someone else. That allows the NFT's existance can be kept\nentirely private if desired; it also makes it cheap to create a new NFT\n(you don't need to pay any on-chain fees at all); and it doesn't impose\nan outsized overhead on people who aren't interested in your inscriptions,\nbut may be interested either in bitcoin per se, or in other inscriptions.\n\nFor things that have real intrinsic value -- equity rights in a company,\nbragging rights for supporting an artist, etc -- this seems like it's\nprobably a viable approach: owners can \"self-custody\" all the information\nabout the things they own without having to rely on third parties,\ntransfers are no more censorable than any other bitcoin transaction\n(especially if the association of the NFT with some particular sat is\nnot widely known), etc.\n\nThe \"inscription\" approach might still be desirable for broadcasting\ninformation that might otherwise be subject to heavy censorship; presuming\nthat the censoring entity isn't also willing and able to censor bitcoin\nitself. It's not clear that there's any \"rights\" to be owned for such a\ncase -- you can't buy the right to be the person that first published\nit, and the point of widely broadcasting the information is so it's\nnot a secret only known to a few anymore. Also, claiming ownership of\nsuch information would presumably make you a target for the censor,\neven if just as an example for others. So I'm dubious of the value of\nassociating an inscription with an ordinal for that use case.\n\nIt's also possible that the perceived value of the NFT isn't due to\nthe inscription, but rather due to the scarcity of the blockspace it\nwas inscribed in (eg [4]). This is different from Bitcoin's scarcity\n-- by 2100 or so there'll be a total of 2100T satoshis available,\nbut in that same time there will only have been about 4T vbytes of\nblockspace available, and perhaps it could make sense to value spent\nvbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that\ncase if you spent 50kvb inscribing a jpeg, perhaps the \"rights\" to that\njpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't\nseem like a sound argument to me -- there's always more blockspace being\ncreated, by fewer and fewer sats being created, and ordinals are far more\nawkward to deal with, but I suppose it's still conceivable, and people\nat least claim to believe it. If it were true, this argument suggests\nthe price for blockspace today should be around 2488sat/vB (19.28MBTC /\n774700 MvB), rather than 1sat/vB.\n\n[4] https://twitter.com/vnprc/status/1619876888687820801\n\nAnyway, comparisons to ordinal inscriptions aside, I think there's\nanother interesting point from all this.\n\nPresume you have a tool that implements the nostr ordinal assignment\nsuggested above: that is, a small modification of the \"ord\" tool that\ncan track a chain of custody for an ordinal specified in a nostr event\nlike the above. That allows you to do NFTs completely unobservably --\nyou don't have to publish anything to the blockchain apart from ordinary\nlooking transactions to transfer ownership of your NFT. To your benefit,\nthat makes it hard for anyone to censor you; but to bitcoin more broadly,\nI think it means that the possibility of coloured bitcoins is largely\nunavoidable and simply something that must be dealt with, rather than\nsomething we should spend time trying to prevent/avoid. Compare with:\n\n> My personal, and possibly controversial, opinion is that colored coin\n> protocols have no business being on the Bitcoin chain, possibly beyond\n> committing to an occasional batched state update or so. Both because\n> there is little benefit for tokens with a trusted issuer already, and\n> because it competes with using Bitcoin for BTC - the token that pays\n> for its security (at least as long as the subsidy doesn't run out).\n>\n> Of course, personal opinions are no reason to dictate what people should\n> or can use the chain for, but I do think it's reason to voice hesitancy\n> to worsening the system's scalability properties only to benefit what\n> I consider misguided use.\n\n -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html\n\nI don't think this actually results in majorly misaligned incentives\nthough: in the nostr-nfts-on-btc world, everyone is still optimising\nbitcoin transactions for the same thing -- transfer of value. It's just\nthat in some cases some sats are valued differently than others --\nperhaps my uninscribed sats are worth 0.025 cents each, but you have\na particular inscribed sat that's worth $100k. But we're both dealing\njust spending utxos and creating new utxos, doing signatures and maybe\nsome timelocks or hash reveals. And it's always been possible that\nyour transaction transferring $100k won't get charged higher fees than\nmy transfer of $50 -- we care about transaction size, not value after\nall. How much does it matter if your tx matters more to your because\nsomeone wants your particular sat, rather than what could happen today\nwhere you have a utxo with 4 BTC while my utxo only has 0.002 BTC?\n\nI think the only way to prevent that sort of NFT structure would be\nto have every transaction use fancy zero-knowledge proofs that make it\nimpossible to associate who received bitcoin with who spent it -- *even\nif* both the sender and recipient were willing to cooperate to reveal\nthat information. I think it would be hard to achieve that while still\nmaking it easy to audit bitcoin's total supply, but I might be wrong.\n\nNote that off-chain colouring here means that someone can create an NFT\nthat you don't want it, and just assign it to a sat that's already in your\nwallet. However, they can do this anyway, by first creating the NFT, then\nsending it to your wallet address. A difference though is that they could\ncreate an NFT and assign it to the same ordinal/sat as some existing NFT\nthat you do value, at which point it's (presumably) impossible to discard\none without discarding both. But again, this is simply something they\ncan do, just be writing a patch to ord and composing a nostr message;\nit's not something you can actually prevent even if you dislike it.\n\nParticularly for semi-fungible tokens, this is perhaps inferior to\nLiquid's multi-asset model -- here if you have a utxo with 1M sats, 500\nof which are inscribed to each represent rights to $1 worth of USDT,\nthen rather than acting like a stable coin and being worth $500; it's\nactually worth $500+0.01BTC, which is more like $750, and changes as\nthe value of bitcoin changes.\n\nCheers,\naj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-02T12:19:28",
                "message_text_only": "In your system what is the off-chain mechanism? And what prevent a thief\nto steal your NFT?\n\nI have submitted several time \"A Bitcoin NFT system\"\nhttps://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\n\nIt's more simple, the NFT (whether real or electronic) is referenced by\na initial hash (which is not the hash for example of your jpeg file\nbecause easy to fake) and then get a final reference which is the hash\nof the initial hash\n\nThe idea is that the real owner must prove that he has the knowledge of\nthe initial hash (for example luxury bag, you print the double hash on\nit, and give the initial hash to the buyer, if the owner/seller can't\nprove that he knows the inital hash, the bag is stolen or counterfeit\n(with the double hash))\n\nThe NFT owner references the NFT signed by him in some trusted third\nparty allowing a timestanp (wayback machine for example), it proves that\nhe is the first one to have the knowledge of the double hash, so a thief\ncannot intercept the \"minting\" transaction (if any because not really\nnecessary since the public key of the owner is known from the third\nparty) and steal the NFT for himself or do/replay a transaction with\nthis NFT, minting it or selling it several time\n\nA third party is involved but it remains decentralized\n\nThen the NFT owner and buyer exchange some information like for\nlightning and do one transaction on Bitcoin storing the deal, see the\ndetails in the proposals depending on what kind of deal occur between\nthe buyer and the seller, like lightning, if someone cheats, then he\nloses his bitcoin\n\nIt's minimal, understandable, secured, decentralized and not expensive,\nthat's why I don't see very well why to complicate with ordinals\n\nThe proposal envisions the concept of \"secret\" NFTs also\n\n\nThe continuation of this proposal is \"A Universal Coin Swap system based\non Bitcoin\" https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\n\nIt's simple also, you go from Decentraland to the Sandbox but don't have\nSAND and want to pay with MANA, you agree on a MANA/SAND deal with the\nseller which is stored in Bitcoin signed by both, then you pay with\nMANA, other use cases are described in the proposal\n\nNote: both proposals need to be modified since I thought OP_RETURN max\nsize was 512B and it is in fact 80B, which does not work for all cases\n\n\nLe 02/02/2023 \u00e0 10:15, Anthony Towns via bitcoin-dev a \u00e9crit :\n> Hi *,\n>\n> Casey Rodarmor's ordinals use the technique of tracking the identity of\n> individual satoshis throughout their lifetime:\n>\n> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n>> Briefly, newly mined satoshis are sequentially numbered in the order in\n>> which they are mined. These numbers are called \"ordinal numbers\" or\n>> \"ordinals\". When satoshis are spent in a transaction, the input satoshi\n>> ordinal numbers are assigned to output satoshis using a simple\n>> first-in-first-out algorithm.\n> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408\n>\n> When accompanied by a standard for associating some data or right with\n> such an identity, this allows the creation of non-fungible tokens (or\n> semi-fungible tokens) whose ownership can be transferred by a bitcoin\n> transaction.\n>\n> The proposed BIP doesn't document any method for associating data or a\n> right with an ordinal, but the \"ord\" tool defines \"inscriptions\" to fill\n> this gap [0], providing a way of including mime-encoded data in a taproot\n> witness. To make such an inscription, two transactions are required:\n> one paying some sats to a special scriptPubKey that commits to the\n> inscribed data, and a second that spends those sats to the owner of the\n> newly inscribed ordinal, and in so doing revealing the full inscription.\n>\n> [0] https://docs.ordinals.com/inscriptions.html\n>\n> I think, however, that you can move inscriptions entirely off-chain. I\n> wrote a little on this idea on twitter already [1], but after a bit more\n> thought, I think pushing things even further off-chain would be plausible.\n>\n> [1] https://twitter.com/ajtowns/status/1619554871166013441\n>\n> In particular, rather than looking at it as being the owner of the sats\n> that inscribes some content on those sats (analogously to signing a $100\n> bill [2]), you could look at it as saying \"the owner of this thing is\n> whoever owns this particular sat\" (eg instead of \"whoever owns this\n> share certificate is a shareholder\", it's \"whoever owns the $1 bill with\n> serial number X is a shareholder\").\n>\n> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers\n>\n> Implementing that is fairly straightforward: you just need a protocol\n> for creating an asset offchain and associating it with an ordinal --\n> nothing needs to happen on-chain at all. That is, you can do something\n> as simple as posting a single nostr message:\n>\n>   {\n>     \"pubkey\": <creator's pubkey>\n>     \"kind\": 0,\n>     \"tags\": [\n>       [\"ord\", \"txid:vout:sat\"]\n>     ],\n>     \"content\": [jpeg goes here],\n>     \"id\": <hash of the above>\n>     \"sig\": <signature of id by creator's pubkey>\n>   }\n>\n> You can prove current ownership of the message by showing a custody\n> chain, that is the transaction specified by \"txid\" in the \"ord\" tag,\n> then every transaction that spent the given sat, until you get to one\n> that's still in the utxo set [3]. You don't need to provide witness\n> data or validate any of these tx's signatures, as that is already\n> implicit in that you end up at a tx in the utxo set. Just calculating\n> the txids and comparing against the output containing the sat you're\n> interested in is sufficient.\n>\n> [3] If the satoshi was lost to fees at some point, you could continue to\n>     follow ownership by including an entire block in the custody chain.\n>     But seems better to just consider it as \"abandoned\" or \"lost to the\n>     public domain\" at that point.\n>\n> This approach allows all the \"inscription\" data to be entirely off-chain,\n> the only thing that requires a transaction on-chain is transferring\n> ownership to someone else. That allows the NFT's existance can be kept\n> entirely private if desired; it also makes it cheap to create a new NFT\n> (you don't need to pay any on-chain fees at all); and it doesn't impose\n> an outsized overhead on people who aren't interested in your inscriptions,\n> but may be interested either in bitcoin per se, or in other inscriptions.\n>\n> For things that have real intrinsic value -- equity rights in a company,\n> bragging rights for supporting an artist, etc -- this seems like it's\n> probably a viable approach: owners can \"self-custody\" all the information\n> about the things they own without having to rely on third parties,\n> transfers are no more censorable than any other bitcoin transaction\n> (especially if the association of the NFT with some particular sat is\n> not widely known), etc.\n>\n> The \"inscription\" approach might still be desirable for broadcasting\n> information that might otherwise be subject to heavy censorship; presuming\n> that the censoring entity isn't also willing and able to censor bitcoin\n> itself. It's not clear that there's any \"rights\" to be owned for such a\n> case -- you can't buy the right to be the person that first published\n> it, and the point of widely broadcasting the information is so it's\n> not a secret only known to a few anymore. Also, claiming ownership of\n> such information would presumably make you a target for the censor,\n> even if just as an example for others. So I'm dubious of the value of\n> associating an inscription with an ordinal for that use case.\n>\n> It's also possible that the perceived value of the NFT isn't due to\n> the inscription, but rather due to the scarcity of the blockspace it\n> was inscribed in (eg [4]). This is different from Bitcoin's scarcity\n> -- by 2100 or so there'll be a total of 2100T satoshis available,\n> but in that same time there will only have been about 4T vbytes of\n> blockspace available, and perhaps it could make sense to value spent\n> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that\n> case if you spent 50kvb inscribing a jpeg, perhaps the \"rights\" to that\n> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't\n> seem like a sound argument to me -- there's always more blockspace being\n> created, by fewer and fewer sats being created, and ordinals are far more\n> awkward to deal with, but I suppose it's still conceivable, and people\n> at least claim to believe it. If it were true, this argument suggests\n> the price for blockspace today should be around 2488sat/vB (19.28MBTC /\n> 774700 MvB), rather than 1sat/vB.\n>\n> [4] https://twitter.com/vnprc/status/1619876888687820801\n>\n> Anyway, comparisons to ordinal inscriptions aside, I think there's\n> another interesting point from all this.\n>\n> Presume you have a tool that implements the nostr ordinal assignment\n> suggested above: that is, a small modification of the \"ord\" tool that\n> can track a chain of custody for an ordinal specified in a nostr event\n> like the above. That allows you to do NFTs completely unobservably --\n> you don't have to publish anything to the blockchain apart from ordinary\n> looking transactions to transfer ownership of your NFT. To your benefit,\n> that makes it hard for anyone to censor you; but to bitcoin more broadly,\n> I think it means that the possibility of coloured bitcoins is largely\n> unavoidable and simply something that must be dealt with, rather than\n> something we should spend time trying to prevent/avoid. Compare with:\n>\n>> My personal, and possibly controversial, opinion is that colored coin\n>> protocols have no business being on the Bitcoin chain, possibly beyond\n>> committing to an occasional batched state update or so. Both because\n>> there is little benefit for tokens with a trusted issuer already, and\n>> because it competes with using Bitcoin for BTC - the token that pays\n>> for its security (at least as long as the subsidy doesn't run out).\n>>\n>> Of course, personal opinions are no reason to dictate what people should\n>> or can use the chain for, but I do think it's reason to voice hesitancy\n>> to worsening the system's scalability properties only to benefit what\n>> I consider misguided use.\n>  -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html\n>\n> I don't think this actually results in majorly misaligned incentives\n> though: in the nostr-nfts-on-btc world, everyone is still optimising\n> bitcoin transactions for the same thing -- transfer of value. It's just\n> that in some cases some sats are valued differently than others --\n> perhaps my uninscribed sats are worth 0.025 cents each, but you have\n> a particular inscribed sat that's worth $100k. But we're both dealing\n> just spending utxos and creating new utxos, doing signatures and maybe\n> some timelocks or hash reveals. And it's always been possible that\n> your transaction transferring $100k won't get charged higher fees than\n> my transfer of $50 -- we care about transaction size, not value after\n> all. How much does it matter if your tx matters more to your because\n> someone wants your particular sat, rather than what could happen today\n> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?\n>\n> I think the only way to prevent that sort of NFT structure would be\n> to have every transaction use fancy zero-knowledge proofs that make it\n> impossible to associate who received bitcoin with who spent it -- *even\n> if* both the sender and recipient were willing to cooperate to reveal\n> that information. I think it would be hard to achieve that while still\n> making it easy to audit bitcoin's total supply, but I might be wrong.\n>\n> Note that off-chain colouring here means that someone can create an NFT\n> that you don't want it, and just assign it to a sat that's already in your\n> wallet. However, they can do this anyway, by first creating the NFT, then\n> sending it to your wallet address. A difference though is that they could\n> create an NFT and assign it to the same ordinal/sat as some existing NFT\n> that you do value, at which point it's (presumably) impossible to discard\n> one without discarding both. But again, this is simply something they\n> can do, just be writing a patch to ord and composing a nostr message;\n> it's not something you can actually prevent even if you dislike it.\n>\n> Particularly for semi-fungible tokens, this is perhaps inferior to\n> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500\n> of which are inscribed to each represent rights to $1 worth of USDT,\n> then rather than acting like a stable coin and being worth $500; it's\n> actually worth $500+0.01BTC, which is more like $750, and changes as\n> the value of bitcoin changes.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "Rijndael",
                "date": "2023-02-02T13:46:35",
                "message_text_only": "Hi AJ and List,\n\nThis reminds me of a series of blog posts Peter Todd wrote a few years\nago about using \"single use seals\" for tracking (fungible) assets\nanchored to Bitcoin[0]. I believe that the RBG Protocol Project and Taro\nare both using the same underlying principle.\n\nHaving the actual application data offchain, but with a commitment to a\nUTXO and then using Bitcoin only as a proof-of-publication system to\nprevent double-spends seems like a really good idea. As you point out,\nin addition to being cheaper and more scalable, it means that not\neveryone on the network has to know that there's an asset involved. It\njust looks like plain old bitcoin transfers.\n\nA lot of people have written about or are (I think) working on\nimplementations of this idea. I really like your suggestion of using\nnostr. Clients can keep the asset metadata chains locally in their\nclient and (re)broadcast them to application-specific nostr relays, or\nto general public relays depending on application needs. Maybe there's a\nmarketplace application that has its own relays and also broadcasts\nasset metadata to relays used by popular gallery systems. Or maybe your\nclient just sends to any relay it sees that doesnt have the event. Big\ndesign space there.\n\n- rijndael\n\n0: https://petertodd.org/2017/scalable-single-use-seal-asset-transfer\n\n\nOn 2/2/23 4:15 AM, Anthony Towns via bitcoin-dev wrote:\n> Hi *,\n>\n> Casey Rodarmor's ordinals use the technique of tracking the identity of\n> individual satoshis throughout their lifetime:\n>\n> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n>> Briefly, newly mined satoshis are sequentially numbered in the order in\n>> which they are mined. These numbers are called \"ordinal numbers\" or\n>> \"ordinals\". When satoshis are spent in a transaction, the input satoshi\n>> ordinal numbers are assigned to output satoshis using a simple\n>> first-in-first-out algorithm.\n> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408\n>\n> When accompanied by a standard for associating some data or right with\n> such an identity, this allows the creation of non-fungible tokens (or\n> semi-fungible tokens) whose ownership can be transferred by a bitcoin\n> transaction.\n>\n> The proposed BIP doesn't document any method for associating data or a\n> right with an ordinal, but the \"ord\" tool defines \"inscriptions\" to fill\n> this gap [0], providing a way of including mime-encoded data in a taproot\n> witness. To make such an inscription, two transactions are required:\n> one paying some sats to a special scriptPubKey that commits to the\n> inscribed data, and a second that spends those sats to the owner of the\n> newly inscribed ordinal, and in so doing revealing the full inscription.\n>\n> [0] https://docs.ordinals.com/inscriptions.html\n>\n> I think, however, that you can move inscriptions entirely off-chain. I\n> wrote a little on this idea on twitter already [1], but after a bit more\n> thought, I think pushing things even further off-chain would be plausible.\n>\n> [1] https://twitter.com/ajtowns/status/1619554871166013441\n>\n> In particular, rather than looking at it as being the owner of the sats\n> that inscribes some content on those sats (analogously to signing a $100\n> bill [2]), you could look at it as saying \"the owner of this thing is\n> whoever owns this particular sat\" (eg instead of \"whoever owns this\n> share certificate is a shareholder\", it's \"whoever owns the $1 bill with\n> serial number X is a shareholder\").\n>\n> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers\n>\n> Implementing that is fairly straightforward: you just need a protocol\n> for creating an asset offchain and associating it with an ordinal --\n> nothing needs to happen on-chain at all. That is, you can do something\n> as simple as posting a single nostr message:\n>\n>    {\n>      \"pubkey\": <creator's pubkey>\n>      \"kind\": 0,\n>      \"tags\": [\n>        [\"ord\", \"txid:vout:sat\"]\n>      ],\n>      \"content\": [jpeg goes here],\n>      \"id\": <hash of the above>\n>      \"sig\": <signature of id by creator's pubkey>\n>    }\n>\n> You can prove current ownership of the message by showing a custody\n> chain, that is the transaction specified by \"txid\" in the \"ord\" tag,\n> then every transaction that spent the given sat, until you get to one\n> that's still in the utxo set [3]. You don't need to provide witness\n> data or validate any of these tx's signatures, as that is already\n> implicit in that you end up at a tx in the utxo set. Just calculating\n> the txids and comparing against the output containing the sat you're\n> interested in is sufficient.\n>\n> [3] If the satoshi was lost to fees at some point, you could continue to\n>      follow ownership by including an entire block in the custody chain.\n>      But seems better to just consider it as \"abandoned\" or \"lost to the\n>      public domain\" at that point.\n>\n> This approach allows all the \"inscription\" data to be entirely off-chain,\n> the only thing that requires a transaction on-chain is transferring\n> ownership to someone else. That allows the NFT's existance can be kept\n> entirely private if desired; it also makes it cheap to create a new NFT\n> (you don't need to pay any on-chain fees at all); and it doesn't impose\n> an outsized overhead on people who aren't interested in your inscriptions,\n> but may be interested either in bitcoin per se, or in other inscriptions.\n>\n> For things that have real intrinsic value -- equity rights in a company,\n> bragging rights for supporting an artist, etc -- this seems like it's\n> probably a viable approach: owners can \"self-custody\" all the information\n> about the things they own without having to rely on third parties,\n> transfers are no more censorable than any other bitcoin transaction\n> (especially if the association of the NFT with some particular sat is\n> not widely known), etc.\n>\n> The \"inscription\" approach might still be desirable for broadcasting\n> information that might otherwise be subject to heavy censorship; presuming\n> that the censoring entity isn't also willing and able to censor bitcoin\n> itself. It's not clear that there's any \"rights\" to be owned for such a\n> case -- you can't buy the right to be the person that first published\n> it, and the point of widely broadcasting the information is so it's\n> not a secret only known to a few anymore. Also, claiming ownership of\n> such information would presumably make you a target for the censor,\n> even if just as an example for others. So I'm dubious of the value of\n> associating an inscription with an ordinal for that use case.\n>\n> It's also possible that the perceived value of the NFT isn't due to\n> the inscription, but rather due to the scarcity of the blockspace it\n> was inscribed in (eg [4]). This is different from Bitcoin's scarcity\n> -- by 2100 or so there'll be a total of 2100T satoshis available,\n> but in that same time there will only have been about 4T vbytes of\n> blockspace available, and perhaps it could make sense to value spent\n> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that\n> case if you spent 50kvb inscribing a jpeg, perhaps the \"rights\" to that\n> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't\n> seem like a sound argument to me -- there's always more blockspace being\n> created, by fewer and fewer sats being created, and ordinals are far more\n> awkward to deal with, but I suppose it's still conceivable, and people\n> at least claim to believe it. If it were true, this argument suggests\n> the price for blockspace today should be around 2488sat/vB (19.28MBTC /\n> 774700 MvB), rather than 1sat/vB.\n>\n> [4] https://twitter.com/vnprc/status/1619876888687820801\n>\n> Anyway, comparisons to ordinal inscriptions aside, I think there's\n> another interesting point from all this.\n>\n> Presume you have a tool that implements the nostr ordinal assignment\n> suggested above: that is, a small modification of the \"ord\" tool that\n> can track a chain of custody for an ordinal specified in a nostr event\n> like the above. That allows you to do NFTs completely unobservably --\n> you don't have to publish anything to the blockchain apart from ordinary\n> looking transactions to transfer ownership of your NFT. To your benefit,\n> that makes it hard for anyone to censor you; but to bitcoin more broadly,\n> I think it means that the possibility of coloured bitcoins is largely\n> unavoidable and simply something that must be dealt with, rather than\n> something we should spend time trying to prevent/avoid. Compare with:\n>\n>> My personal, and possibly controversial, opinion is that colored coin\n>> protocols have no business being on the Bitcoin chain, possibly beyond\n>> committing to an occasional batched state update or so. Both because\n>> there is little benefit for tokens with a trusted issuer already, and\n>> because it competes with using Bitcoin for BTC - the token that pays\n>> for its security (at least as long as the subsidy doesn't run out).\n>>\n>> Of course, personal opinions are no reason to dictate what people should\n>> or can use the chain for, but I do think it's reason to voice hesitancy\n>> to worsening the system's scalability properties only to benefit what\n>> I consider misguided use.\n>   -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html\n>\n> I don't think this actually results in majorly misaligned incentives\n> though: in the nostr-nfts-on-btc world, everyone is still optimising\n> bitcoin transactions for the same thing -- transfer of value. It's just\n> that in some cases some sats are valued differently than others --\n> perhaps my uninscribed sats are worth 0.025 cents each, but you have\n> a particular inscribed sat that's worth $100k. But we're both dealing\n> just spending utxos and creating new utxos, doing signatures and maybe\n> some timelocks or hash reveals. And it's always been possible that\n> your transaction transferring $100k won't get charged higher fees than\n> my transfer of $50 -- we care about transaction size, not value after\n> all. How much does it matter if your tx matters more to your because\n> someone wants your particular sat, rather than what could happen today\n> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?\n>\n> I think the only way to prevent that sort of NFT structure would be\n> to have every transaction use fancy zero-knowledge proofs that make it\n> impossible to associate who received bitcoin with who spent it -- *even\n> if* both the sender and recipient were willing to cooperate to reveal\n> that information. I think it would be hard to achieve that while still\n> making it easy to audit bitcoin's total supply, but I might be wrong.\n>\n> Note that off-chain colouring here means that someone can create an NFT\n> that you don't want it, and just assign it to a sat that's already in your\n> wallet. However, they can do this anyway, by first creating the NFT, then\n> sending it to your wallet address. A difference though is that they could\n> create an NFT and assign it to the same ordinal/sat as some existing NFT\n> that you do value, at which point it's (presumably) impossible to discard\n> one without discarding both. But again, this is simply something they\n> can do, just be writing a patch to ord and composing a nostr message;\n> it's not something you can actually prevent even if you dislike it.\n>\n> Particularly for semi-fungible tokens, this is perhaps inferior to\n> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500\n> of which are inscribed to each represent rights to $1 worth of USDT,\n> then rather than acting like a stable coin and being worth $500; it's\n> actually worth $500+0.01BTC, which is more like $750, and changes as\n> the value of bitcoin changes.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "alicexbt",
                "date": "2023-02-02T14:22:10",
                "message_text_only": "Hi Anthony,\n\n> I think, however, that you can move inscriptions entirely off-chain. I\nwrote a little on this idea on twitter already [1], but after a bit more\nthought, I think pushing things even further off-chain would be plausible.\n\nWhole point of inscriptions is to keep something on-chain associated with your sats so this approach goes against the concept and what makes them interesting in the first place.\n\n> Implementing that is fairly straightforward: you just need a protocol\nfor creating an asset offchain and associating it with an ordinal --\nnothing needs to happen on-chain at all. That is, you can do something\nas simple as posting a single nostr message:\n\nAll events may not be permanently stored by Nostr relays. In addition to rendering inscriptions meaningless, this creates a dependency.\n\n> The \"inscription\" approach might still be desirable for broadcasting\ninformation that might otherwise be subject to heavy censorship; presuming\nthat the censoring entity isn't also willing and able to censor bitcoin\nitself.\n\nIf bitcoin transactions can be censored then we have bigger problems to care about as bitcoin will have no value without censorship resistance.\n\nLastly, I would add that inscriptions involve \"financial\" transactions, associating sats with image is freedom and got historical reasons for it. Writing something on paper or drawing an image on copper is not same as doing it on gold.\n\nDisclaimer: My opinion on inscriptions can be biased because I am working on a startup that will use inscriptions and satscard(coinkite)\n\n\n/dev/fd0\nfloppy disc guy\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Thursday, February 2nd, 2023 at 2:45 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> Hi *,\n> \n> Casey Rodarmor's ordinals use the technique of tracking the identity of\n> individual satoshis throughout their lifetime:\n> \n> On Tue, Feb 22, 2022 at 04:43:52PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n> \n> > Briefly, newly mined satoshis are sequentially numbered in the order in\n> > which they are mined. These numbers are called \"ordinal numbers\" or\n> > \"ordinals\". When satoshis are spent in a transaction, the input satoshi\n> > ordinal numbers are assigned to output satoshis using a simple\n> > first-in-first-out algorithm.\n> \n> \n> This is proposed as a BIP at https://github.com/bitcoin/bips/pull/1408\n> \n> When accompanied by a standard for associating some data or right with\n> such an identity, this allows the creation of non-fungible tokens (or\n> semi-fungible tokens) whose ownership can be transferred by a bitcoin\n> transaction.\n> \n> The proposed BIP doesn't document any method for associating data or a\n> right with an ordinal, but the \"ord\" tool defines \"inscriptions\" to fill\n> this gap [0], providing a way of including mime-encoded data in a taproot\n> witness. To make such an inscription, two transactions are required:\n> one paying some sats to a special scriptPubKey that commits to the\n> inscribed data, and a second that spends those sats to the owner of the\n> newly inscribed ordinal, and in so doing revealing the full inscription.\n> \n> [0] https://docs.ordinals.com/inscriptions.html\n> \n> I think, however, that you can move inscriptions entirely off-chain. I\n> wrote a little on this idea on twitter already [1], but after a bit more\n> thought, I think pushing things even further off-chain would be plausible.\n> \n> [1] https://twitter.com/ajtowns/status/1619554871166013441\n> \n> In particular, rather than looking at it as being the owner of the sats\n> that inscribes some content on those sats (analogously to signing a $100\n> bill [2]), you could look at it as saying \"the owner of this thing is\n> whoever owns this particular sat\" (eg instead of \"whoever owns this\n> share certificate is a shareholder\", it's \"whoever owns the $1 bill with\n> serial number X is a shareholder\").\n> \n> [2] https://www.espn.com/nfl/story/_/id/14375536/owner-100-bill-autograph-cleveland-browns-qb-johnny-manziel-getting-offers\n> \n> Implementing that is fairly straightforward: you just need a protocol\n> for creating an asset offchain and associating it with an ordinal --\n> nothing needs to happen on-chain at all. That is, you can do something\n> as simple as posting a single nostr message:\n> \n> {\n> \"pubkey\": <creator's pubkey>\n> \n> \"kind\": 0,\n> \"tags\": [\n> [\"ord\", \"txid:vout:sat\"]\n> ],\n> \"content\": [jpeg goes here],\n> \"id\": <hash of the above>\n> \n> \"sig\": <signature of id by creator's pubkey>\n> \n> }\n> \n> You can prove current ownership of the message by showing a custody\n> chain, that is the transaction specified by \"txid\" in the \"ord\" tag,\n> then every transaction that spent the given sat, until you get to one\n> that's still in the utxo set [3]. You don't need to provide witness\n> data or validate any of these tx's signatures, as that is already\n> implicit in that you end up at a tx in the utxo set. Just calculating\n> the txids and comparing against the output containing the sat you're\n> interested in is sufficient.\n> \n> [3] If the satoshi was lost to fees at some point, you could continue to\n> follow ownership by including an entire block in the custody chain.\n> But seems better to just consider it as \"abandoned\" or \"lost to the\n> public domain\" at that point.\n> \n> This approach allows all the \"inscription\" data to be entirely off-chain,\n> the only thing that requires a transaction on-chain is transferring\n> ownership to someone else. That allows the NFT's existance can be kept\n> entirely private if desired; it also makes it cheap to create a new NFT\n> (you don't need to pay any on-chain fees at all); and it doesn't impose\n> an outsized overhead on people who aren't interested in your inscriptions,\n> but may be interested either in bitcoin per se, or in other inscriptions.\n> \n> For things that have real intrinsic value -- equity rights in a company,\n> bragging rights for supporting an artist, etc -- this seems like it's\n> probably a viable approach: owners can \"self-custody\" all the information\n> about the things they own without having to rely on third parties,\n> transfers are no more censorable than any other bitcoin transaction\n> (especially if the association of the NFT with some particular sat is\n> not widely known), etc.\n> \n> The \"inscription\" approach might still be desirable for broadcasting\n> information that might otherwise be subject to heavy censorship; presuming\n> that the censoring entity isn't also willing and able to censor bitcoin\n> itself. It's not clear that there's any \"rights\" to be owned for such a\n> case -- you can't buy the right to be the person that first published\n> it, and the point of widely broadcasting the information is so it's\n> not a secret only known to a few anymore. Also, claiming ownership of\n> such information would presumably make you a target for the censor,\n> even if just as an example for others. So I'm dubious of the value of\n> associating an inscription with an ordinal for that use case.\n> \n> It's also possible that the perceived value of the NFT isn't due to\n> the inscription, but rather due to the scarcity of the blockspace it\n> was inscribed in (eg [4]). This is different from Bitcoin's scarcity\n> -- by 2100 or so there'll be a total of 2100T satoshis available,\n> but in that same time there will only have been about 4T vbytes of\n> blockspace available, and perhaps it could make sense to value spent\n> vbytes proportionally, so 4 spent vbytes is worth 2100 sats. In that\n> case if you spent 50kvb inscribing a jpeg, perhaps the \"rights\" to that\n> jpeg should be worth the same as 50k/4*2100 sats or 0.26 BTC. Doesn't\n> seem like a sound argument to me -- there's always more blockspace being\n> created, by fewer and fewer sats being created, and ordinals are far more\n> awkward to deal with, but I suppose it's still conceivable, and people\n> at least claim to believe it. If it were true, this argument suggests\n> the price for blockspace today should be around 2488sat/vB (19.28MBTC /\n> 774700 MvB), rather than 1sat/vB.\n> \n> [4] https://twitter.com/vnprc/status/1619876888687820801\n> \n> Anyway, comparisons to ordinal inscriptions aside, I think there's\n> another interesting point from all this.\n> \n> Presume you have a tool that implements the nostr ordinal assignment\n> suggested above: that is, a small modification of the \"ord\" tool that\n> can track a chain of custody for an ordinal specified in a nostr event\n> like the above. That allows you to do NFTs completely unobservably --\n> you don't have to publish anything to the blockchain apart from ordinary\n> looking transactions to transfer ownership of your NFT. To your benefit,\n> that makes it hard for anyone to censor you; but to bitcoin more broadly,\n> I think it means that the possibility of coloured bitcoins is largely\n> unavoidable and simply something that must be dealt with, rather than\n> something we should spend time trying to prevent/avoid. Compare with:\n> \n> > My personal, and possibly controversial, opinion is that colored coin\n> > protocols have no business being on the Bitcoin chain, possibly beyond\n> > committing to an occasional batched state update or so. Both because\n> > there is little benefit for tokens with a trusted issuer already, and\n> > because it competes with using Bitcoin for BTC - the token that pays\n> > for its security (at least as long as the subsidy doesn't run out).\n> > \n> > Of course, personal opinions are no reason to dictate what people should\n> > or can use the chain for, but I do think it's reason to voice hesitancy\n> > to worsening the system's scalability properties only to benefit what\n> > I consider misguided use.\n> \n> \n> -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019500.html\n> \n> I don't think this actually results in majorly misaligned incentives\n> though: in the nostr-nfts-on-btc world, everyone is still optimising\n> bitcoin transactions for the same thing -- transfer of value. It's just\n> that in some cases some sats are valued differently than others --\n> perhaps my uninscribed sats are worth 0.025 cents each, but you have\n> a particular inscribed sat that's worth $100k. But we're both dealing\n> just spending utxos and creating new utxos, doing signatures and maybe\n> some timelocks or hash reveals. And it's always been possible that\n> your transaction transferring $100k won't get charged higher fees than\n> my transfer of $50 -- we care about transaction size, not value after\n> all. How much does it matter if your tx matters more to your because\n> someone wants your particular sat, rather than what could happen today\n> where you have a utxo with 4 BTC while my utxo only has 0.002 BTC?\n> \n> I think the only way to prevent that sort of NFT structure would be\n> to have every transaction use fancy zero-knowledge proofs that make it\n> impossible to associate who received bitcoin with who spent it -- even\n> if both the sender and recipient were willing to cooperate to reveal\n> that information. I think it would be hard to achieve that while still\n> making it easy to audit bitcoin's total supply, but I might be wrong.\n> \n> Note that off-chain colouring here means that someone can create an NFT\n> that you don't want it, and just assign it to a sat that's already in your\n> wallet. However, they can do this anyway, by first creating the NFT, then\n> sending it to your wallet address. A difference though is that they could\n> create an NFT and assign it to the same ordinal/sat as some existing NFT\n> that you do value, at which point it's (presumably) impossible to discard\n> one without discarding both. But again, this is simply something they\n> can do, just be writing a patch to ord and composing a nostr message;\n> it's not something you can actually prevent even if you dislike it.\n> \n> Particularly for semi-fungible tokens, this is perhaps inferior to\n> Liquid's multi-asset model -- here if you have a utxo with 1M sats, 500\n> of which are inscribed to each represent rights to $1 worth of USDT,\n> then rather than acting like a stable coin and being worth $500; it's\n> actually worth $500+0.01BTC, which is more like $750, and changes as\n> the value of bitcoin changes.\n> \n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-02T14:30:11",
                "message_text_only": "On Thu, Feb 02, 2023 at 07:15:33PM +1000, Anthony Towns via bitcoin-dev wrote:\n> Hi *,\n> \n> Casey Rodarmor's ordinals use the technique of tracking the identity of\n> individual satoshis throughout their lifetime:\n\n<snip>\n\n> I think, however, that you can move inscriptions entirely off-chain. I\n> wrote a little on this idea on twitter already [1], but after a bit more\n> thought, I think pushing things even further off-chain would be plausible.\n\nOn the FAQ of the Ordinals website they discuss off-chain data storage and\nreject the idea:\n\n    \"Some Ethereum NFT content is on-chain, but much is off-chain, and is stored on\n    platforms like IPFS or Arweave, or on traditional, fully centralized web\n    servers. Content on IPFS is not guaranteed to continue to be available, and\n    some NFT content stored on IPFS has already been lost. Platforms like Arweave\n    rely on weak economic assumptions, and will likely fail catastrophically when\n    these economic assumptions are no longer met. Centralized web servers may\n    disappear at any time.\"\n    https://web.archive.org/web/20230130012343/https://docs.ordinals.com/faq.html\n\nThat same FAQ also mention RGB and Taro, which already implements an off-chain\ndata model based on my Proofmarshal work. The Ordinals community is well aware\nof the trade-offs and have chosen to publish their data on chain. This is a\ncollectables market based on artificial scarcity after all, so some conspicuous\nconsumption isn't going to be a deterrent.\n\nFrankly, I think further discussion of this on the bitcoin-dev mailing list,\nwith the aim of getting Ordinals and others to do something else, is a waste of\neveryones' time. The fact that publishing data on chain lets you take\nadvantage of the very large network of archival Bitcoin nodes to publish and\nstore your data indefinitely is a clear benefit that people will always be\nwilling to pay for. The only realistic thing Bitcoin can do to discourage this\nis tweaks to the blocksize and segwit discount, which of course has well-known\ndownsides.\n\nThere's a clear social/economic benefit to the Ordinals community that the\ncomplete set of Ordinalds - and their inscriptions - is easy to extract and\nwill be available as long as Bitcoin block data itself will be available.\nThat's not going away and we should acknowledge that benefit honestly.\n\n> Implementing that is fairly straightforward: you just need a protocol\n> for creating an asset offchain and associating it with an ordinal --\n> nothing needs to happen on-chain at all. That is, you can do something\n> as simple as posting a single nostr message:\n> \n>   {\n>     \"pubkey\": <creator's pubkey>\n>     \"kind\": 0,\n>     \"tags\": [\n>       [\"ord\", \"txid:vout:sat\"]\n>     ],\n>     \"content\": [jpeg goes here],\n>     \"id\": <hash of the above>\n>     \"sig\": <signature of id by creator's pubkey>\n>   }\n\nnostr doesn't even have a clear data persistence model. As you know, nostr\nmessages are passed around by relays that make no enforceable promise of\nactually keeping those messages or making them available. nostr doesn't have\nany kind of blockchain, making it diffcult for others to archive messages\ncompletely.  Advocating for its use in a protocol designed to support valuable\ncollectables expected to be owned for a significant amount of time is reckless.\n\nYou know, we've been through all this before, years ago when colored coins were\nfirst being discussed. Bitcoin Core devs who knew better would try to\ndiscourage use of the Bitcoin chain for purposes they didn't approve of, by\nsuggesting solutions that they knew full well didn't really work. Solutions\nlike using OpenTimestamps inappropriately, alternative publication methods that\nfailed to provide the same level of security as Bitcoin, etc. It was dishonest\nthen, and it's disappointing to see a new generation of Bitcoin devs continue\nthis pattern of dishonesty.\n\n> You can prove current ownership of the message by showing a custody\n> chain, that is the transaction specified by \"txid\" in the \"ord\" tag,\n> then every transaction that spent the given sat, until you get to one\n> that's still in the utxo set [3]. You don't need to provide witness\n> data or validate any of these tx's signatures, as that is already\n> implicit in that you end up at a tx in the utxo set. Just calculating\n> the txids and comparing against the output containing the sat you're\n> interested in is sufficient.\n\nThe RGB protocol already does off-chain custody proofs, and implements NFTs.\nYou can already use this for real with Iris Wallet - the ownership chain of a\nRGB asset is _not_ visible on the blockchain, as ownership does not follow\nsatoshis. With more work, digital assets can even be transferred with\nO(log_2(n)) scaling allowing billions of transfers per second:\n\n    https://petertodd.org/2017/scalable-single-use-seal-asset-transfer\n\nThis of course is irrelevant to Ordinals, which will never have such a large\nmarket.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/661f9b15/attachment.sig>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-02T16:06:02",
                "message_text_only": "I am not an expert with RGB, but it looks limited (only bitcoin chains\nfrom the github repo, apparently on hold), distributed over the\n\"lightning network\" or LN nodes (what is it?), or Bifrost extension,\nwith a dubious token floating around, like ethereum mess as RGB docs\ndescribe Ethereum (and myself also), layer2 or layer3, certainly not\ndecentralized (like still Bitcoin and Ethereum)\n\nIt's of course useless to trust IPFS or Bittorrent to store things\nbecause you cannot control the seeders who have zero incentive to seed\nsuch things\n\nThat's why in my much more simple proposals a well known third party is\nthere, wayback machine, github, twitter, etc, if they disappear then\nprobably internet has disappeared too, if they get censored you can\nstill get a snapshot of what you did\n\nThe intent is certainly not to store NFTs in Bitcoin, only hashes,\nsignatures and addresses, same for the third party proof, the NFT\ncontent if not real is stored elsewhere (up to people to decide where)\n\nAdditionally you can store in the third party the proof that something\nexists (the secret NFT), for example a small copy of the NFT electronic\nart, the buyer will get the full version once the deal is done and once\nhe gets the decryption key, having the NFT for himself only\n\nMy proposals are not addressing wider D-stuff topics, supposedly\ndecentralized, but no\n\nSo I don't think that it's a waste of time to change the OP_RETURN max\nsize, currently it cannot even store <short message and/or hash> +\n<signature>, probably it's logical to align it to the script size limit\n(520B)\n\nOr as I said previously deviant practices can happen, not expensive and\njust burning satoshis, which is not a super idea\n\nI don't get why on bitcoin all proposals must always be super\ncomplicate, mine are simple, then take 5mn to read them\n\n\nLe 02/02/2023 \u00e0 15:30, Peter Todd via bitcoin-dev a \u00e9crit :\n> On Thu, Feb 02, 2023 at 07:15:33PM +1000, Anthony Towns via bitcoin-dev wrote:\n>> Hi *,\n>>\n>> Casey Rodarmor's ordinals use the technique of tracking the identity of\n>> individual satoshis throughout their lifetime:\n> <snip>\n>\n>> I think, however, that you can move inscriptions entirely off-chain. I\n>> wrote a little on this idea on twitter already [1], but after a bit more\n>> thought, I think pushing things even further off-chain would be plausible.\n> On the FAQ of the Ordinals website they discuss off-chain data storage and\n> reject the idea:\n>\n>     \"Some Ethereum NFT content is on-chain, but much is off-chain, and is stored on\n>     platforms like IPFS or Arweave, or on traditional, fully centralized web\n>     servers. Content on IPFS is not guaranteed to continue to be available, and\n>     some NFT content stored on IPFS has already been lost. Platforms like Arweave\n>     rely on weak economic assumptions, and will likely fail catastrophically when\n>     these economic assumptions are no longer met. Centralized web servers may\n>     disappear at any time.\"\n>     https://web.archive.org/web/20230130012343/https://docs.ordinals.com/faq.html\n>\n> That same FAQ also mention RGB and Taro, which already implements an off-chain\n> data model based on my Proofmarshal work. The Ordinals community is well aware\n> of the trade-offs and have chosen to publish their data on chain. This is a\n> collectables market based on artificial scarcity after all, so some conspicuous\n> consumption isn't going to be a deterrent.\n>\n> Frankly, I think further discussion of this on the bitcoin-dev mailing list,\n> with the aim of getting Ordinals and others to do something else, is a waste of\n> everyones' time. The fact that publishing data on chain lets you take\n> advantage of the very large network of archival Bitcoin nodes to publish and\n> store your data indefinitely is a clear benefit that people will always be\n> willing to pay for. The only realistic thing Bitcoin can do to discourage this\n> is tweaks to the blocksize and segwit discount, which of course has well-known\n> downsides.\n>\n> There's a clear social/economic benefit to the Ordinals community that the\n> complete set of Ordinalds - and their inscriptions - is easy to extract and\n> will be available as long as Bitcoin block data itself will be available.\n> That's not going away and we should acknowledge that benefit honestly.\n>\n>> Implementing that is fairly straightforward: you just need a protocol\n>> for creating an asset offchain and associating it with an ordinal --\n>> nothing needs to happen on-chain at all. That is, you can do something\n>> as simple as posting a single nostr message:\n>>\n>>   {\n>>     \"pubkey\": <creator's pubkey>\n>>     \"kind\": 0,\n>>     \"tags\": [\n>>       [\"ord\", \"txid:vout:sat\"]\n>>     ],\n>>     \"content\": [jpeg goes here],\n>>     \"id\": <hash of the above>\n>>     \"sig\": <signature of id by creator's pubkey>\n>>   }\n> nostr doesn't even have a clear data persistence model. As you know, nostr\n> messages are passed around by relays that make no enforceable promise of\n> actually keeping those messages or making them available. nostr doesn't have\n> any kind of blockchain, making it diffcult for others to archive messages\n> completely.  Advocating for its use in a protocol designed to support valuable\n> collectables expected to be owned for a significant amount of time is reckless.\n>\n> You know, we've been through all this before, years ago when colored coins were\n> first being discussed. Bitcoin Core devs who knew better would try to\n> discourage use of the Bitcoin chain for purposes they didn't approve of, by\n> suggesting solutions that they knew full well didn't really work. Solutions\n> like using OpenTimestamps inappropriately, alternative publication methods that\n> failed to provide the same level of security as Bitcoin, etc. It was dishonest\n> then, and it's disappointing to see a new generation of Bitcoin devs continue\n> this pattern of dishonesty.\n>\n>> You can prove current ownership of the message by showing a custody\n>> chain, that is the transaction specified by \"txid\" in the \"ord\" tag,\n>> then every transaction that spent the given sat, until you get to one\n>> that's still in the utxo set [3]. You don't need to provide witness\n>> data or validate any of these tx's signatures, as that is already\n>> implicit in that you end up at a tx in the utxo set. Just calculating\n>> the txids and comparing against the output containing the sat you're\n>> interested in is sufficient.\n> The RGB protocol already does off-chain custody proofs, and implements NFTs.\n> You can already use this for real with Iris Wallet - the ownership chain of a\n> RGB asset is _not_ visible on the blockchain, as ownership does not follow\n> satoshis. With more work, digital assets can even be transferred with\n> O(log_2(n)) scaling allowing billions of transfers per second:\n>\n>     https://petertodd.org/2017/scalable-single-use-seal-asset-transfer\n>\n> This of course is irrelevant to Ordinals, which will never have such a large\n> market.\n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/bab6d696/attachment.html>"
            },
            {
                "author": "Casey Rodarmor",
                "date": "2023-02-03T06:39:21",
                "message_text_only": "Good evening list,\n\nApologies for posting! I've tried to keep discussion of ordinals and\ninscriptions off-list, because I consider it to be of little relevance to\ngeneral Bitcoin development. Also, apologies for the HTML mail, but I don't\nhave my email client configured correctly. And finally, also apologies if\nthis breaks the thread, I was subscribed but not receiving mail, so I can't\nrespond to the original message.\n\nAJ Towns writes:\n\nI think, however, that you can move inscriptions entirely off-chain. I\nwrote a little on this idea on twitter already [1], but after a bit more\nthought, I think pushing things even further off-chain would be plausible.\n\n\nActually, my initial sketch for Ordinal NFTs worked in a similar fashion,\nwith off-chain messages pointing to an ordinal, which could be tracked by\nfollowing the chain of custody of that particular sat. I gave a workshop\nlast year where I handed out paper wallets to participants with a private\nkey that controlled some sats, which could both be assigned NFTs and used\nto sign messages as a form of provenance:\n\nhttps://www.youtube.com/watch?v=j5V33kV3iqo\n\nUltimately, I decided against this design, and Peter provided an excellent\nexplanation of some of the trade-offs of such a design in his mail, but to\nat least partially recap and explain my own thinking:\n\nNFT collectors have a strong revealed preference for on-chain content. The\ncontent of high-value NFTs is often stored partially or completely on\nchain, even if details of the NFT protocol involved actually prevents that\ncontent from being what you see when you view the NFT on a website or\nmarketplace.\n\nUser protection when off-chain content is involved is fraught. Users are\nnot equipped, due to lack of technical knowledge, easily available,\nuser-friendly tools, and education, to protect themselves when they buy a\ncollectable whose content is stored off-chain. When a user buys an NFT with\noff-chain content, they now have the primary economic incentive to preserve\nthat content, so that their NFT retains value and can be enjoyed or sold.\nMany existing NFT marketplaces that sell off-chain content do not explain\nthis to users, or give users tools that the average, non-technical person\ncan understand or use, which enables them to protect themselves. Even if\nthey did give users these tools, there are tricky considerations involved.\nIPFS functions much like BitTorrent, so even if users were provided with an\nIPFS application that could persist their off-chain NFT content\nautomatically, they might reveal their IP address, which would then be\nlinked to ownership of their NFT, which would have privacy and safety\nconsiderations.\n\nAnother issue is salience and scarcity, as has been mentioned. Off-chain\ncontent is unbounded, and thus less scarce. Usually, we design for\nefficiency, volume, and scale. For NFT designs, which are intended to be\ncollectable, this is in some ways counterproductive.\n\nThe above issues also make the specification and implementation of NFTs\nwith off-chain content much more difficult. Ordinals is a project largely\nwritten by a single developer, me, with the assistance of two part time\ninterns. It is very intentionally the simplest thing that could possibly\nwork, much like Bitcoin itself. Sometimes I refer to it as \"cave-man\ntechnology\". If I was designing an off-chain NFT protocol, I would likely\nhave had to raise money and recruit a large team, which I have not done, or\nbe at risk of never launching anything at all.\n\nI would absolutely love for the ordinals protocol, that is, the numbering\nand transfer of individual satoshis, be used as the basis for alternative,\noff-chain NFT and colored coin schemes, with proper consideration given to\nthe issues above.\n\nHowever, I would request that, to avoid confusion, these alternative\nschemes never be called inscriptions.\n\nI'm a dev, not a cop, but fine distinctions are hard to properly explain\nand understand. Inscriptions, that is, the NFT protocol which embeds\ncontent in transaction witnesses, has a particular set of trade-offs and\nguarantees. I want users to know that if they buy or value something they\nor others call an \"inscription\", they can rely on those trade-offs and\nguarantees. Another NFT protocol named \"inscriptions\" would make this very\ndifficult.\n\nAdditionally, I think the term \"inscription\" which has a connotation of\npermanence, and of an indelible association with a particular satoshi, is\ninappropriate for an off-chain NFT protocol.\n\nSorry to belabor this point! Inscriptions have already proven very popular\nfor a nascent protocol, beyond my expectations, and the terminology and\nnaming is still new, so it's a critical phase in terms of understanding and\neducation.\n\nIf others are interested in developing ordinals further, a great first step\nwould be to provide review and feedback on the BIP PR:\n\nhttps://github.com/bitcoin/bips/pull/1408\n\nI have never written a BIP, so style and content feedback is especially\nwelcome.\n\nInscriptions themselves have no BIP, although at least one alternative\nimplementation of the inscription parser has been written:\n\nhttps://ordinals.com/content/6f46a2a830a90e406245b188631cd15ffea31b8be146255ec39d4d46bbe15663i0\n\nI hope to write a BIP for inscriptions as the implementation and protocol\nmature.\n\nIn general, although I do love the ordinals protocol, it has many\ndownsides, which I hope people will consider when considering it for\nalternative colored coin schemes. These include the fact that divisibility\nis limited, both by the use of real sats and the dust limit, that cardinal\nsatoshis must be used to pay fees, the general insanity of ordinal-aware\ntransaction construction[0], and difficult in lifting ordinals onto an L2.\nI consider ordinals ideal for art projects like inscriptions and\nordinal-theory-powered satoshi numismatics, where aesthetic and technical\nconsiderations are nearly equally important.\n\nPlease feel free to contact me privately by email, or on the ordinals\nproject GitHub[1] if you'd like to respond! My intention with this message\nis not to spark debate, since I consider it mostly off-topic for this list.\n\nBest regards,\nCasey Rodarmor\n\n[0]\nhttps://github.com/casey/ord/blob/master/src/subcommand/wallet/transaction_builder.rs\n[1] https://github.com/casey/ord\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/f969f9f8/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-04T10:38:54",
                "message_text_only": "On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n> Apologies for posting! I've tried to keep discussion of ordinals and\n> inscriptions off-list, because I consider it to be of little relevance to\n> general Bitcoin development.\n\nAnything that potentially uses up a large percentage of blockspace seems\npretty relevant to general Bitcoin development to me...\n\n> AJ Towns writes:\n> > I think, however, that you can move inscriptions entirely off-chain. I\n> > wrote a little on this idea on twitter already [1], but after a bit more\n> > thought, I think pushing things even further off-chain would be plausible.\n\nI guess I should have explained why I think moving things off-chain is\na worthwhile goal. Riffing off:\n\n> Another issue is salience and scarcity, as has been mentioned. Off-chain\n> content is unbounded, and thus less scarce. Usually, we design for\n> efficiency, volume, and scale. For NFT designs, which are intended to be\n> collectable, this is in some ways counterproductive.\n\n\"scarce\" has two meanings -- one is that there's not much of it, the\nother is that it's highly valued (or a third, where it's is consistently\nunderpriced and unavailable even for people who'd pay more, but that\nhopefully doesn't apply).\n\nI think for bitcoin's blockspace, we ideally only want the first of\nthese to be true. We want small blocks because that makes it cheap to\nverify bitcoin, which reduces the need to trust third parties and aids in\ndecentralisation. But we don't want blockspace to be especially valuable,\nas that makes it expensive to use bitcoin, which then limits who can\nuse it.\n\nMoving things off-chain helps with both these goals: it doesn't make it\nharder to validate bitcoin, and it also decreases demand for blockspace,\nmaking it cheaper for those cases where things can't be moved off-chain.\n\nAs a result of this approach, bitcoin blockspace is currently quite\ncheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in\na peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a\nluxury purchase.\n\nIf you keep jpegs on-chain, as far as I can see, there's three outcomes:\n\n * blockspace stays relatively cheap, and there's no \"scarcity\" benefit to\n   minting via on-chain inscriptions; it's cheap enough to just mint\n   any random meme, and there's no prestige to doing so\n\n * blockspace becomes filled with jpegs, driving up costs for everyone,\n   making jpeg collectors happy, but transactors sad\n\n * the amount of blockspace is increased, keeping prices low, and\n   reducing \"scarcity\" in both senses, so also making it harder to\n   validate bitcoin. no one really wins.\n\nI'd guess the first of these is the most likely, personally.\n\nAs far as salience/notability goes, personally, I'd see ownership of\ninscriptions as a negative indicator; \"hey, when I was young and foolish I\nwasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a\npermanent cost for everyone trying to use bitcoin in future\". That's not\nunforgivable; people do all sorts of foolish things, and bitcoin's meant\nto survive attacks, not just foolish pranks. But it doesn't seem like\nsomething to brag about or encourage, either, at least if you want bitcoin\nto be a monetary network that's usable in practice by many/most people.\n\n(Even if one day that goes the other way, and there is real (and\ntransferable) social value in being able to say \"I donated x sats to fees\nto help secure bitcoin\", such a claim is more charitable/admirable/value\nwith a smaller on-chain footprint, both in that it again keeps\nvalidation easier, but also in that it makes it easier for others to\nalso simultaneously make the same charitable contribution)\n\n> NFT collectors have a strong revealed preference for on-chain content. The\n> content of high-value NFTs is often stored partially or completely on\n> chain, \n\nWhen you identify an NFT by a url that points at someone else's server,\nthat's an obvious vulnerability, as Moxie demonstrated pretty well.\n\nBut solving that by saying \"okay, we'll just externalise the storage\ncosts to the public, while privatising all the benefits\" isn't a good\napproach either.\n\n> User protection when off-chain content is involved is fraught.\n\nI mean, that seems trivially solvable? Users already have to store the\nprivate key that controls ownership of these digital assets; storing the\nasset as well, which doesn't need to be private, isn't a big ask. And if\na public site like ordinals.net is willing to store all the inscriptions\nthat might be on the blockchain, they could just as easily store the\nsame amount of off-chain digital assets.\n\n> When a user buys an NFT with\n> off-chain content, they now have the primary economic incentive to preserve\n> that content, so that their NFT retains value and can be enjoyed or sold.\n\nYes -- the people who potentially benefit from the NFT should be the\nones paying the costs of preserving that NFT.\n\n> Many existing NFT marketplaces that sell off-chain content do not explain\n> this to users, or give users tools that the average, non-technical person\n> can understand or use, which enables them to protect themselves. Even if\n> they did give users these tools, there are tricky considerations involved.\n> IPFS functions much like BitTorrent,\n\nExternalising the costs to some different network while privatising the\nbenefits isn't any better than doing it to bitcoin; except in that maybe\nyou're inconveniencing fewer people.\n\nGoing back to this:\n\n> Another issue is salience and scarcity, as has been mentioned. Off-chain\n> content is unbounded, and thus less scarce. Usually, we design for\n> efficiency, volume, and scale. For NFT designs, which are intended to be\n> collectable, this is in some ways counterproductive.\n\nObviously blockchains aren't the only \"scarce\" good out there. If scarcity\nis your goal, there's two very easy ways to make your own scarcity. \n\nOne is requiring proof of work -- you could have a digital\nasset marketplace that only allows works that have a hash with\nat least 32 leading zero-bits [0] and use timestamping [1] (or a\ncertificate-transparency approach) to ensure that as proof-of-work\ntechonology improves, it can't be used to backdate mints.\n\n[0] https://github.com/nostr-protocol/nips/blob/master/13.md\n[1] https://github.com/nostr-protocol/nips/blob/master/03.md\n\nOr the other approach is you just require people to pay you some sats\nover lightning to host an NFT. That way you're the one collecting the\nfees, not miners; and you're (perhaps) the one incurring an obligation\nto preserve the NFT on behalf of its owners, rather than random bitcoin\nnode operators.\n\n> The above issues also make the specification and implementation of NFTs\n> with off-chain content much more difficult.\n\nI'm not meaning to criticise you for doing what you think's interesting,\nso if it's coming off that way I apologise in advance. I think it's\ninteresting, too. I just think that, when possible, off-chain is always\nbetter than on-chain, and it's worth exploring that idea further.\n\nIn particular, I don't think it *is* actually much more difficult? Here's\nhow I'd change what you've done to turn ordinals.net into an off-chain\ndigital asset site:\n\n - setup a nostr relay, with submissions gated by proof of work, and\n   no expiry. maybe https://github.com/Cameri/nostream ?\n\n - for any event that includes an \"ordinal\" tag, treat it as a digital\n   asset, and add it to your digital asset database, just like you do now\n   for inscriptions. either have your own nostr client that subscribes\n   to your relay, or just query your relay's db directly.\n\n - have a regular proof of work adjustment targeting say 200MB worth of\n   events per day (vs the 576MB per day of possible witness data).\n\n - update the ord tool to be able to encode digital artifacts into a nostr\n   event, apply proof of work to it, and send it to (by default)\n   your relay.\n\nThat would let nostr clients immediately just add your relay and get a\nfeed of minted digital artifacts, that's already spam-free due to the\nproof of work requirement. They could follow all of them, or just follow\na particular artist by pubkey, too. An artist could publish a collection\nby publishing an event defining the collection, then linking each artwork\nto the collection as a \"reply\", making it pretty easy for nostr clients\nto follow a collection, while still having each artwork linked to its\nown ordinal, and I think without requiring any work on your behalf.\n\nYou don't need to change the way ordinals are spent at all for any of\nthis, I think; all you're doing is replacing the initial two transactions\nthat link the digital artifact with the ordinal with an off-chain message\nachieving the same thing.\n\nThen to go beyond what you've got you could:\n\n - add some support for the current owner of an ordinal to link that\n   back to their nostr profile -- eg, sign a message with the pubkey\n   based on the current utxo holding the ordinal, referencing the digial\n   asset; you could perhaps use NIP-2 \"following\" messages for this.\n   if you've already using an open social network, might as well take\n   advantage of it.\n\n - add some support for the \"social legitimacy\" aspect -- eg linking\n   all the assets created by the same public key as an artist's portfolio;\n   make it easy to go from their nft-related pubkey to their regular\n   nostr profile or similar.\n\n - let creators that have already somehow demonstrated \"social legitimacy\"\n   bypass the proof of work requirement, since \"great art\" is already\n   naturally scarce. creators who've demonstrated their quality shouldn't\n   need to waste time or money doing proof of work or paying blockchain\n   fees\n\nAdding a lightning based patreon-type setup could be awesome there --\ncontent creators post content to a closed relay, patrons pay a fee\nover lightning to be able to receive events, and 90%+ of those fees\nare passed on to creators. If creators are happy with subscriptions,\nthey just do that; if they want to auction off NFTs, they can do that;\nif they want both, that works too...\n\n> Additionally, I think the term \"inscription\" which has a connotation of\n> permanence, and of an indelible association with a particular satoshi, is\n> inappropriate for an off-chain NFT protocol.\n\nNo objections about the \"inscription\" definition, but I'm not sure if the\nabove means you're misunderstanding what I'm saying. In the off-chain\nscheme I'm talking about, the \"digital asset\" includes the ordinal\nthat controls ownership, and is identified by the hash of its contents,\nincluding that ordinal's identity -- so there is an indelible association\nwith a particular satoshi, despite it being an off-chain NFT protocol.\n\nFor example if you take two identical digital assets, such as:\n\n  https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0\n\n  https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0\n\nthen in the off-chain world, they would look like two events:\n\n  {\n    pubkey: <Alice>\n    kind: 0\n    tags: [\n      ord: \"8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0\"\n    ]\n    content: <av1.jpeg>\n    id: <XXXX - hash of the above>\n    sig: <sig by alice of XXXX>\n  }\n\nand\n\n  {\n    pubkey: <Alice>\n    kind: 0\n    tags: [\n      ord: \"31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0\"\n    ]\n    content: <av1.jpeg>\n    id: <YYYY = hash of the above>\n    sig: <sig by alice of YYYY>\n  }\n\nie two unique digital assets, with two unique identifiers (XXXX and YYYY)\nthat are each indelibly linked with particular satoshis.\n\nObviously there's nothing stopping Alice minting the exact same content\nto two different ordinals -- presumably that's what happened with\nthe two inscriptions above -- nor is there anything stopping Bob from\nright-click-save-as and doing the same; but as above, that's obviously\ntrue for inscriptions as well. The only truly unique thing is the specific\nhash and the specific content that generated the hash.\n\nThe relationship does go the other way compared to inscriptions --\nhere you keep the association so long as you remember the asset; with\ninscriptions you keep the association so long as you have bitcoin's\nhistorical blocks. As I've said above, the off-chain approach seems\nmuch better aligned with incentives to me, with the people who gain the\nbenefit from that association paying the cost of preserving it.\n\nCheers,\naj"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-04T11:36:54",
                "message_text_only": "I still don't see in both proposals how you avoid that someone steals\nyour NFT, double mint it or sell it several time, because the thief can\ndo the very same that what your are describing, a hash of the content is\nnot enough, you can slightly modify an image or a document and it gives\nanother hash, as far as I know in all existing systems today there are\nzero protection against this, I am quoting also Moxie's experience in my\nproposals\n\nThat's why I am proposing the third party with a timestamp and a double\nhash not related to the content itself, and the secret NFT, I don't see\nthe point to buy millions some electronic art that everyone can get for free\n\nAnyway, I mostly consider that a NFT is a real good that you buy in the\nmetaverse, not only an electronic thing\n\n\nLe 04/02/2023 \u00e0 11:38, Anthony Towns via bitcoin-dev a \u00e9crit :\n> On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n>> Apologies for posting! I've tried to keep discussion of ordinals and\n>> inscriptions off-list, because I consider it to be of little relevance to\n>> general Bitcoin development.\n> Anything that potentially uses up a large percentage of blockspace seems\n> pretty relevant to general Bitcoin development to me...\n>\n>> AJ Towns writes:\n>>> I think, however, that you can move inscriptions entirely off-chain. I\n>>> wrote a little on this idea on twitter already [1], but after a bit more\n>>> thought, I think pushing things even further off-chain would be plausible.\n> I guess I should have explained why I think moving things off-chain is\n> a worthwhile goal. Riffing off:\n>\n>> Another issue is salience and scarcity, as has been mentioned. Off-chain\n>> content is unbounded, and thus less scarce. Usually, we design for\n>> efficiency, volume, and scale. For NFT designs, which are intended to be\n>> collectable, this is in some ways counterproductive.\n> \"scarce\" has two meanings -- one is that there's not much of it, the\n> other is that it's highly valued (or a third, where it's is consistently\n> underpriced and unavailable even for people who'd pay more, but that\n> hopefully doesn't apply).\n>\n> I think for bitcoin's blockspace, we ideally only want the first of\n> these to be true. We want small blocks because that makes it cheap to\n> verify bitcoin, which reduces the need to trust third parties and aids in\n> decentralisation. But we don't want blockspace to be especially valuable,\n> as that makes it expensive to use bitcoin, which then limits who can\n> use it.\n>\n> Moving things off-chain helps with both these goals: it doesn't make it\n> harder to validate bitcoin, and it also decreases demand for blockspace,\n> making it cheaper for those cases where things can't be moved off-chain.\n>\n> As a result of this approach, bitcoin blockspace is currently quite\n> cheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in\n> a peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a\n> luxury purchase.\n>\n> If you keep jpegs on-chain, as far as I can see, there's three outcomes:\n>\n>  * blockspace stays relatively cheap, and there's no \"scarcity\" benefit to\n>    minting via on-chain inscriptions; it's cheap enough to just mint\n>    any random meme, and there's no prestige to doing so\n>\n>  * blockspace becomes filled with jpegs, driving up costs for everyone,\n>    making jpeg collectors happy, but transactors sad\n>\n>  * the amount of blockspace is increased, keeping prices low, and\n>    reducing \"scarcity\" in both senses, so also making it harder to\n>    validate bitcoin. no one really wins.\n>\n> I'd guess the first of these is the most likely, personally.\n>\n> As far as salience/notability goes, personally, I'd see ownership of\n> inscriptions as a negative indicator; \"hey, when I was young and foolish I\n> wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a\n> permanent cost for everyone trying to use bitcoin in future\". That's not\n> unforgivable; people do all sorts of foolish things, and bitcoin's meant\n> to survive attacks, not just foolish pranks. But it doesn't seem like\n> something to brag about or encourage, either, at least if you want bitcoin\n> to be a monetary network that's usable in practice by many/most people.\n>\n> (Even if one day that goes the other way, and there is real (and\n> transferable) social value in being able to say \"I donated x sats to fees\n> to help secure bitcoin\", such a claim is more charitable/admirable/value\n> with a smaller on-chain footprint, both in that it again keeps\n> validation easier, but also in that it makes it easier for others to\n> also simultaneously make the same charitable contribution)\n>\n>> NFT collectors have a strong revealed preference for on-chain content. The\n>> content of high-value NFTs is often stored partially or completely on\n>> chain, \n> When you identify an NFT by a url that points at someone else's server,\n> that's an obvious vulnerability, as Moxie demonstrated pretty well.\n>\n> But solving that by saying \"okay, we'll just externalise the storage\n> costs to the public, while privatising all the benefits\" isn't a good\n> approach either.\n>\n>> User protection when off-chain content is involved is fraught.\n> I mean, that seems trivially solvable? Users already have to store the\n> private key that controls ownership of these digital assets; storing the\n> asset as well, which doesn't need to be private, isn't a big ask. And if\n> a public site like ordinals.net is willing to store all the inscriptions\n> that might be on the blockchain, they could just as easily store the\n> same amount of off-chain digital assets.\n>\n>> When a user buys an NFT with\n>> off-chain content, they now have the primary economic incentive to preserve\n>> that content, so that their NFT retains value and can be enjoyed or sold.\n> Yes -- the people who potentially benefit from the NFT should be the\n> ones paying the costs of preserving that NFT.\n>\n>> Many existing NFT marketplaces that sell off-chain content do not explain\n>> this to users, or give users tools that the average, non-technical person\n>> can understand or use, which enables them to protect themselves. Even if\n>> they did give users these tools, there are tricky considerations involved.\n>> IPFS functions much like BitTorrent,\n> Externalising the costs to some different network while privatising the\n> benefits isn't any better than doing it to bitcoin; except in that maybe\n> you're inconveniencing fewer people.\n>\n> Going back to this:\n>\n>> Another issue is salience and scarcity, as has been mentioned. Off-chain\n>> content is unbounded, and thus less scarce. Usually, we design for\n>> efficiency, volume, and scale. For NFT designs, which are intended to be\n>> collectable, this is in some ways counterproductive.\n> Obviously blockchains aren't the only \"scarce\" good out there. If scarcity\n> is your goal, there's two very easy ways to make your own scarcity. \n>\n> One is requiring proof of work -- you could have a digital\n> asset marketplace that only allows works that have a hash with\n> at least 32 leading zero-bits [0] and use timestamping [1] (or a\n> certificate-transparency approach) to ensure that as proof-of-work\n> techonology improves, it can't be used to backdate mints.\n>\n> [0] https://github.com/nostr-protocol/nips/blob/master/13.md\n> [1] https://github.com/nostr-protocol/nips/blob/master/03.md\n>\n> Or the other approach is you just require people to pay you some sats\n> over lightning to host an NFT. That way you're the one collecting the\n> fees, not miners; and you're (perhaps) the one incurring an obligation\n> to preserve the NFT on behalf of its owners, rather than random bitcoin\n> node operators.\n>\n>> The above issues also make the specification and implementation of NFTs\n>> with off-chain content much more difficult.\n> I'm not meaning to criticise you for doing what you think's interesting,\n> so if it's coming off that way I apologise in advance. I think it's\n> interesting, too. I just think that, when possible, off-chain is always\n> better than on-chain, and it's worth exploring that idea further.\n>\n> In particular, I don't think it *is* actually much more difficult? Here's\n> how I'd change what you've done to turn ordinals.net into an off-chain\n> digital asset site:\n>\n>  - setup a nostr relay, with submissions gated by proof of work, and\n>    no expiry. maybe https://github.com/Cameri/nostream ?\n>\n>  - for any event that includes an \"ordinal\" tag, treat it as a digital\n>    asset, and add it to your digital asset database, just like you do now\n>    for inscriptions. either have your own nostr client that subscribes\n>    to your relay, or just query your relay's db directly.\n>\n>  - have a regular proof of work adjustment targeting say 200MB worth of\n>    events per day (vs the 576MB per day of possible witness data).\n>\n>  - update the ord tool to be able to encode digital artifacts into a nostr\n>    event, apply proof of work to it, and send it to (by default)\n>    your relay.\n>\n> That would let nostr clients immediately just add your relay and get a\n> feed of minted digital artifacts, that's already spam-free due to the\n> proof of work requirement. They could follow all of them, or just follow\n> a particular artist by pubkey, too. An artist could publish a collection\n> by publishing an event defining the collection, then linking each artwork\n> to the collection as a \"reply\", making it pretty easy for nostr clients\n> to follow a collection, while still having each artwork linked to its\n> own ordinal, and I think without requiring any work on your behalf.\n>\n> You don't need to change the way ordinals are spent at all for any of\n> this, I think; all you're doing is replacing the initial two transactions\n> that link the digital artifact with the ordinal with an off-chain message\n> achieving the same thing.\n>\n> Then to go beyond what you've got you could:\n>\n>  - add some support for the current owner of an ordinal to link that\n>    back to their nostr profile -- eg, sign a message with the pubkey\n>    based on the current utxo holding the ordinal, referencing the digial\n>    asset; you could perhaps use NIP-2 \"following\" messages for this.\n>    if you've already using an open social network, might as well take\n>    advantage of it.\n>\n>  - add some support for the \"social legitimacy\" aspect -- eg linking\n>    all the assets created by the same public key as an artist's portfolio;\n>    make it easy to go from their nft-related pubkey to their regular\n>    nostr profile or similar.\n>\n>  - let creators that have already somehow demonstrated \"social legitimacy\"\n>    bypass the proof of work requirement, since \"great art\" is already\n>    naturally scarce. creators who've demonstrated their quality shouldn't\n>    need to waste time or money doing proof of work or paying blockchain\n>    fees\n>\n> Adding a lightning based patreon-type setup could be awesome there --\n> content creators post content to a closed relay, patrons pay a fee\n> over lightning to be able to receive events, and 90%+ of those fees\n> are passed on to creators. If creators are happy with subscriptions,\n> they just do that; if they want to auction off NFTs, they can do that;\n> if they want both, that works too...\n>\n>> Additionally, I think the term \"inscription\" which has a connotation of\n>> permanence, and of an indelible association with a particular satoshi, is\n>> inappropriate for an off-chain NFT protocol.\n> No objections about the \"inscription\" definition, but I'm not sure if the\n> above means you're misunderstanding what I'm saying. In the off-chain\n> scheme I'm talking about, the \"digital asset\" includes the ordinal\n> that controls ownership, and is identified by the hash of its contents,\n> including that ordinal's identity -- so there is an indelible association\n> with a particular satoshi, despite it being an off-chain NFT protocol.\n>\n> For example if you take two identical digital assets, such as:\n>\n>   https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0\n>\n>   https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0\n>\n> then in the off-chain world, they would look like two events:\n>\n>   {\n>     pubkey: <Alice>\n>     kind: 0\n>     tags: [\n>       ord: \"8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0\"\n>     ]\n>     content: <av1.jpeg>\n>     id: <XXXX - hash of the above>\n>     sig: <sig by alice of XXXX>\n>   }\n>\n> and\n>\n>   {\n>     pubkey: <Alice>\n>     kind: 0\n>     tags: [\n>       ord: \"31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0\"\n>     ]\n>     content: <av1.jpeg>\n>     id: <YYYY = hash of the above>\n>     sig: <sig by alice of YYYY>\n>   }\n>\n> ie two unique digital assets, with two unique identifiers (XXXX and YYYY)\n> that are each indelibly linked with particular satoshis.\n>\n> Obviously there's nothing stopping Alice minting the exact same content\n> to two different ordinals -- presumably that's what happened with\n> the two inscriptions above -- nor is there anything stopping Bob from\n> right-click-save-as and doing the same; but as above, that's obviously\n> true for inscriptions as well. The only truly unique thing is the specific\n> hash and the specific content that generated the hash.\n>\n> The relationship does go the other way compared to inscriptions --\n> here you keep the association so long as you remember the asset; with\n> inscriptions you keep the association so long as you have bitcoin's\n> historical blocks. As I've said above, the off-chain approach seems\n> much better aligned with incentives to me, with the people who gain the\n> benefit from that association paying the cost of preserving it.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n-- \nSophia-Antipolis, France\nCV: https://www.peersm.com/CVAV.pdf\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nGitHub : https://www.github.com/Ayms\nA Universal Coin Swap system based on Bitcoin: https://gist.github.com/Ayms/029125db2583e1cf9c3209769eb2cdd7\nA bitcoin NFT system: https://gist.github.com/Ayms/01dbfebf219965054b4a3beed1bfeba7\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com\nPeersm : http://www.peersm.com"
            },
            {
                "author": "alicexbt",
                "date": "2023-02-04T13:02:44",
                "message_text_only": "Hi Anthony,\n\n> As far as salience/notability goes, personally, I'd see ownership of\ninscriptions as a negative indicator; \"hey, when I was young and foolish I\nwasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a\npermanent cost for everyone trying to use bitcoin in future\". That's not\nunforgivable; people do all sorts of foolish things, and bitcoin's meant\nto survive attacks, not just foolish pranks. But it doesn't seem like\nsomething to brag about or encourage, either, at least if you want bitcoin\nto be a monetary network that's usable in practice by many/most people.\n\nMoving transactions off-chain because of emotions or personal opinions does not make sense. \nEveryone running a bitcoin node is aware of block limits and they could be filled with different type of transactions including [non-inscription txs][0] that use witness for complex scripts.\n\n> And if\na public site like ordinals.net is willing to store all the inscriptions\nthat might be on the blockchain, they could just as easily store the\nsame amount of off-chain digital assets.\n\n[Ord explorer][1] is open source and gets inscriptions from blockchain.\n\n> Obviously blockchains aren't the only \"scarce\" good out there. If scarcity\nis your goal, there's two very easy ways to make your own scarcity. \n\nUsing pow doesn't make nostr relays \"scarce\". Its mainly used to avoid spam but some spammers on nostr have proved it isn't enough. \n\n> then in the off-chain world, they would look like two events:\n\nNostr relays do not guarantee that these events will be stored [forever][2].\n\n> As I've said above, the off-chain approach seems\nmuch better aligned with incentives to me, with the people who gain the\nbenefit from that association paying the cost of preserving it.\n\nCost for running bitcoin node do not change with inscriptions and do not depend on the content or intent of any bitcoin transaction. It is a permissionless network and users can decide how to use money and blockspace.\n\nCampaigns to censor such transactions or other efforts to move them off-chain are creating a slippery slope that could affect bitcoin more than some inscriptions. If Casey is harassed enough on social media and ord project moves inscriptions off-chain, there would be forks of it doing it on-chain.\n\n\n[0]: https://twitter.com/mononautical/status/1621663167582437376\n[1]: https://github.com/casey/ord\n[2]: https://twitter.com/damusapp/status/1621431556048035841\n\n\ndev/fd0\nfloppy disc guy\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Saturday, February 4th, 2023 at 4:08 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On Thu, Feb 02, 2023 at 10:39:21PM -0800, Casey Rodarmor via bitcoin-dev wrote:\n> \n> > Apologies for posting! I've tried to keep discussion of ordinals and\n> > inscriptions off-list, because I consider it to be of little relevance to\n> > general Bitcoin development.\n> \n> \n> Anything that potentially uses up a large percentage of blockspace seems\n> pretty relevant to general Bitcoin development to me...\n> \n> > AJ Towns writes:\n> > \n> > > I think, however, that you can move inscriptions entirely off-chain. I\n> > > wrote a little on this idea on twitter already [1], but after a bit more\n> > > thought, I think pushing things even further off-chain would be plausible.\n> \n> \n> I guess I should have explained why I think moving things off-chain is\n> a worthwhile goal. Riffing off:\n> \n> > Another issue is salience and scarcity, as has been mentioned. Off-chain\n> > content is unbounded, and thus less scarce. Usually, we design for\n> > efficiency, volume, and scale. For NFT designs, which are intended to be\n> > collectable, this is in some ways counterproductive.\n> \n> \n> \"scarce\" has two meanings -- one is that there's not much of it, the\n> other is that it's highly valued (or a third, where it's is consistently\n> underpriced and unavailable even for people who'd pay more, but that\n> hopefully doesn't apply).\n> \n> I think for bitcoin's blockspace, we ideally only want the first of\n> these to be true. We want small blocks because that makes it cheap to\n> verify bitcoin, which reduces the need to trust third parties and aids in\n> decentralisation. But we don't want blockspace to be especially valuable,\n> as that makes it expensive to use bitcoin, which then limits who can\n> use it.\n> \n> Moving things off-chain helps with both these goals: it doesn't make it\n> harder to validate bitcoin, and it also decreases demand for blockspace,\n> making it cheaper for those cases where things can't be moved off-chain.\n> \n> As a result of this approach, bitcoin blockspace is currently quite\n> cheap -- so inscribing at 100kB jpeg at 25kvB might cost perhaps $60 in\n> a peak period, or $6 if you wait for 1sat/vb to confirm. Not exactly a\n> luxury purchase.\n> \n> If you keep jpegs on-chain, as far as I can see, there's three outcomes:\n> \n> * blockspace stays relatively cheap, and there's no \"scarcity\" benefit to\n> minting via on-chain inscriptions; it's cheap enough to just mint\n> any random meme, and there's no prestige to doing so\n> \n> * blockspace becomes filled with jpegs, driving up costs for everyone,\n> making jpeg collectors happy, but transactors sad\n> \n> * the amount of blockspace is increased, keeping prices low, and\n> reducing \"scarcity\" in both senses, so also making it harder to\n> validate bitcoin. no one really wins.\n> \n> I'd guess the first of these is the most likely, personally.\n> \n> As far as salience/notability goes, personally, I'd see ownership of\n> inscriptions as a negative indicator; \"hey, when I was young and foolish I\n> wasted x-thousand bytes on the bitcoin blockchain, pointlessly creating a\n> permanent cost for everyone trying to use bitcoin in future\". That's not\n> unforgivable; people do all sorts of foolish things, and bitcoin's meant\n> to survive attacks, not just foolish pranks. But it doesn't seem like\n> something to brag about or encourage, either, at least if you want bitcoin\n> to be a monetary network that's usable in practice by many/most people.\n> \n> (Even if one day that goes the other way, and there is real (and\n> transferable) social value in being able to say \"I donated x sats to fees\n> to help secure bitcoin\", such a claim is more charitable/admirable/value\n> with a smaller on-chain footprint, both in that it again keeps\n> validation easier, but also in that it makes it easier for others to\n> also simultaneously make the same charitable contribution)\n> \n> > NFT collectors have a strong revealed preference for on-chain content. The\n> > content of high-value NFTs is often stored partially or completely on\n> > chain,\n> \n> \n> When you identify an NFT by a url that points at someone else's server,\n> that's an obvious vulnerability, as Moxie demonstrated pretty well.\n> \n> But solving that by saying \"okay, we'll just externalise the storage\n> costs to the public, while privatising all the benefits\" isn't a good\n> approach either.\n> \n> > User protection when off-chain content is involved is fraught.\n> \n> \n> I mean, that seems trivially solvable? Users already have to store the\n> private key that controls ownership of these digital assets; storing the\n> asset as well, which doesn't need to be private, isn't a big ask. And if\n> a public site like ordinals.net is willing to store all the inscriptions\n> that might be on the blockchain, they could just as easily store the\n> same amount of off-chain digital assets.\n> \n> > When a user buys an NFT with\n> > off-chain content, they now have the primary economic incentive to preserve\n> > that content, so that their NFT retains value and can be enjoyed or sold.\n> \n> \n> Yes -- the people who potentially benefit from the NFT should be the\n> ones paying the costs of preserving that NFT.\n> \n> > Many existing NFT marketplaces that sell off-chain content do not explain\n> > this to users, or give users tools that the average, non-technical person\n> > can understand or use, which enables them to protect themselves. Even if\n> > they did give users these tools, there are tricky considerations involved.\n> > IPFS functions much like BitTorrent,\n> \n> \n> Externalising the costs to some different network while privatising the\n> benefits isn't any better than doing it to bitcoin; except in that maybe\n> you're inconveniencing fewer people.\n> \n> Going back to this:\n> \n> > Another issue is salience and scarcity, as has been mentioned. Off-chain\n> > content is unbounded, and thus less scarce. Usually, we design for\n> > efficiency, volume, and scale. For NFT designs, which are intended to be\n> > collectable, this is in some ways counterproductive.\n> \n> \n> Obviously blockchains aren't the only \"scarce\" good out there. If scarcity\n> is your goal, there's two very easy ways to make your own scarcity.\n> \n> One is requiring proof of work -- you could have a digital\n> asset marketplace that only allows works that have a hash with\n> at least 32 leading zero-bits [0] and use timestamping [1] (or a\n> certificate-transparency approach) to ensure that as proof-of-work\n> techonology improves, it can't be used to backdate mints.\n> \n> [0] https://github.com/nostr-protocol/nips/blob/master/13.md\n> [1] https://github.com/nostr-protocol/nips/blob/master/03.md\n> \n> Or the other approach is you just require people to pay you some sats\n> over lightning to host an NFT. That way you're the one collecting the\n> fees, not miners; and you're (perhaps) the one incurring an obligation\n> to preserve the NFT on behalf of its owners, rather than random bitcoin\n> node operators.\n> \n> > The above issues also make the specification and implementation of NFTs\n> > with off-chain content much more difficult.\n> \n> \n> I'm not meaning to criticise you for doing what you think's interesting,\n> so if it's coming off that way I apologise in advance. I think it's\n> interesting, too. I just think that, when possible, off-chain is always\n> better than on-chain, and it's worth exploring that idea further.\n> \n> In particular, I don't think it is actually much more difficult? Here's\n> how I'd change what you've done to turn ordinals.net into an off-chain\n> digital asset site:\n> \n> - setup a nostr relay, with submissions gated by proof of work, and\n> no expiry. maybe https://github.com/Cameri/nostream ?\n> \n> - for any event that includes an \"ordinal\" tag, treat it as a digital\n> asset, and add it to your digital asset database, just like you do now\n> for inscriptions. either have your own nostr client that subscribes\n> to your relay, or just query your relay's db directly.\n> \n> - have a regular proof of work adjustment targeting say 200MB worth of\n> events per day (vs the 576MB per day of possible witness data).\n> \n> - update the ord tool to be able to encode digital artifacts into a nostr\n> event, apply proof of work to it, and send it to (by default)\n> your relay.\n> \n> That would let nostr clients immediately just add your relay and get a\n> feed of minted digital artifacts, that's already spam-free due to the\n> proof of work requirement. They could follow all of them, or just follow\n> a particular artist by pubkey, too. An artist could publish a collection\n> by publishing an event defining the collection, then linking each artwork\n> to the collection as a \"reply\", making it pretty easy for nostr clients\n> to follow a collection, while still having each artwork linked to its\n> own ordinal, and I think without requiring any work on your behalf.\n> \n> You don't need to change the way ordinals are spent at all for any of\n> this, I think; all you're doing is replacing the initial two transactions\n> that link the digital artifact with the ordinal with an off-chain message\n> achieving the same thing.\n> \n> Then to go beyond what you've got you could:\n> \n> - add some support for the current owner of an ordinal to link that\n> back to their nostr profile -- eg, sign a message with the pubkey\n> based on the current utxo holding the ordinal, referencing the digial\n> asset; you could perhaps use NIP-2 \"following\" messages for this.\n> if you've already using an open social network, might as well take\n> advantage of it.\n> \n> - add some support for the \"social legitimacy\" aspect -- eg linking\n> all the assets created by the same public key as an artist's portfolio;\n> make it easy to go from their nft-related pubkey to their regular\n> nostr profile or similar.\n> \n> - let creators that have already somehow demonstrated \"social legitimacy\"\n> bypass the proof of work requirement, since \"great art\" is already\n> naturally scarce. creators who've demonstrated their quality shouldn't\n> need to waste time or money doing proof of work or paying blockchain\n> fees\n> \n> Adding a lightning based patreon-type setup could be awesome there --\n> content creators post content to a closed relay, patrons pay a fee\n> over lightning to be able to receive events, and 90%+ of those fees\n> are passed on to creators. If creators are happy with subscriptions,\n> they just do that; if they want to auction off NFTs, they can do that;\n> if they want both, that works too...\n> \n> > Additionally, I think the term \"inscription\" which has a connotation of\n> > permanence, and of an indelible association with a particular satoshi, is\n> > inappropriate for an off-chain NFT protocol.\n> \n> \n> No objections about the \"inscription\" definition, but I'm not sure if the\n> above means you're misunderstanding what I'm saying. In the off-chain\n> scheme I'm talking about, the \"digital asset\" includes the ordinal\n> that controls ownership, and is identified by the hash of its contents,\n> including that ordinal's identity -- so there is an indelible association\n> with a particular satoshi, despite it being an off-chain NFT protocol.\n> \n> For example if you take two identical digital assets, such as:\n> \n> https://ordinals.net/inscription/8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8i0\n> \n> https://ordinals.net/inscription/31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561i0\n> \n> then in the off-chain world, they would look like two events:\n> \n> {\n> pubkey: <Alice>\n> \n> kind: 0\n> tags: [\n> ord: \"8ed2594cecbd43e5673168ff160ba00a6d8953fea7ab6b15a112f3bc94adc2f8:0:0\"\n> ]\n> content: <av1.jpeg>\n> \n> id: <XXXX - hash of the above>\n> \n> sig: <sig by alice of XXXX>\n> \n> }\n> \n> and\n> \n> {\n> pubkey: <Alice>\n> \n> kind: 0\n> tags: [\n> ord: \"31e9577f9af1d1823bc00539291f061e4ac9ba727162a8e0d8d7b80512966561:0:0\"\n> ]\n> content: <av1.jpeg>\n> \n> id: <YYYY = hash of the above>\n> \n> sig: <sig by alice of YYYY>\n> \n> }\n> \n> ie two unique digital assets, with two unique identifiers (XXXX and YYYY)\n> that are each indelibly linked with particular satoshis.\n> \n> Obviously there's nothing stopping Alice minting the exact same content\n> to two different ordinals -- presumably that's what happened with\n> the two inscriptions above -- nor is there anything stopping Bob from\n> right-click-save-as and doing the same; but as above, that's obviously\n> true for inscriptions as well. The only truly unique thing is the specific\n> hash and the specific content that generated the hash.\n> \n> The relationship does go the other way compared to inscriptions --\n> here you keep the association so long as you remember the asset; with\n> inscriptions you keep the association so long as you have bitcoin's\n> historical blocks. As I've said above, the off-chain approach seems\n> much better aligned with incentives to me, with the people who gain the\n> benefit from that association paying the cost of preserving it.\n> \n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-04T13:06:32",
                "message_text_only": "On Sat, Feb 04, 2023 at 08:38:54PM +1000, Anthony Towns via bitcoin-dev wrote:\n> I think for bitcoin's blockspace, we ideally only want the first of\n> these to be true. We want small blocks because that makes it cheap to\n> verify bitcoin, which reduces the need to trust third parties and aids in\n> decentralisation. But we don't want blockspace to be especially valuable,\n> as that makes it expensive to use bitcoin, which then limits who can\n> use it.\n\nWe certainly do want blockspace to be valuable, as transaction fees have to\nboth be in constant demand, and rise enough to replace the inflation subsidy if\nBitcoin is to remain secure in the future. In fact at the moment, the inflation\nsubsidy pays miners about 50x more than fees do. Ordinals and other publication\nmechanisms are of course ways that we can drive consistent demand for block\nspace, keeping Bitcoin secure.\n\nAre you arguing that we should change the inflation subsidy phase-out, eg by\nintroducing tail emission(1) or demurrage?\n\n1) https://petertodd.org/2022/surprisingly-tail-emission-is-not-inflationary\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/a526f596/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Purely off-chain coin colouring",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rijndael",
                "Anthony Towns",
                "Aymeric Vitte",
                "Peter Todd",
                "alicexbt",
                "Casey Rodarmor"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 112060
        }
    },
    {
        "title": "[bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2023-02-02T14:52:09",
                "message_text_only": "On Fri, Jan 27, 2023 at 09:05:20AM -0500, Greg Sanders via bitcoin-dev wrote:\n> Hello again dev,\n> \n> Due to the interest in the proposal and the prodding of certain folks, I've\n> written up a short draft BIP of the Ephemeral Anchors idea here:\n> https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki\n> \n> The pull request at https://github.com/bitcoin/bitcoin/pull/26403 has been\n> refreshed on top of the latest V3 proposal, but the BIP itself is\n> unaffected.\n\nThe BIP states that:\n\n    Why OP_2 not OP_TRUE? OP_TRUE is often used in test vectors, using OP_2 has\n    the same benefits and none of these common collisions.\n\nWhy is a \"collision\" harmful in this case?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/9ef319d4/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2023-02-02T14:59:09",
                "message_text_only": "Hi Peter,\n\nFor the most principled of reasons:\n\nBecause I have to change test vectors everywhere!\n\nGreg\n\nOn Thu, Feb 2, 2023 at 9:52 AM Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Jan 27, 2023 at 09:05:20AM -0500, Greg Sanders via bitcoin-dev\n> wrote:\n> > Hello again dev,\n> >\n> > Due to the interest in the proposal and the prodding of certain folks,\n> I've\n> > written up a short draft BIP of the Ephemeral Anchors idea here:\n> >\n> https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki\n> >\n> > The pull request at https://github.com/bitcoin/bitcoin/pull/26403 has\n> been\n> > refreshed on top of the latest V3 proposal, but the BIP itself is\n> > unaffected.\n>\n> The BIP states that:\n>\n>     Why OP_2 not OP_TRUE? OP_TRUE is often used in test vectors, using\n> OP_2 has\n>     the same benefits and none of these common collisions.\n>\n> Why is a \"collision\" harmful in this case?\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/d53025db/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-02T15:06:53",
                "message_text_only": "On Thu, Feb 02, 2023 at 09:59:09AM -0500, Greg Sanders wrote:\n> Hi Peter,\n> \n> For the most principled of reasons:\n> \n> Because I have to change test vectors everywhere!\n\nSpecifically, you mean you'd have to change tests that test something is\nnon-standard?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/755e81a0/attachment-0001.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2023-02-02T18:36:24",
                "message_text_only": "Quickly checked, it fails a number of standardness tests in unit/functional\ntests in Bitcoin Core, at least.\n\nOP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I\njust independently arrived at the same conclusion.\n\nOn Thu, Feb 2, 2023 at 10:06 AM Peter Todd <pete at petertodd.org> wrote:\n\n> On Thu, Feb 02, 2023 at 09:59:09AM -0500, Greg Sanders wrote:\n> > Hi Peter,\n> >\n> > For the most principled of reasons:\n> >\n> > Because I have to change test vectors everywhere!\n>\n> Specifically, you mean you'd have to change tests that test something is\n> non-standard?\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/48dcb48f/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-02T20:22:38",
                "message_text_only": "On Thu, Feb 02, 2023 at 01:36:24PM -0500, Greg Sanders wrote:\n> Quickly checked, it fails a number of standardness tests in unit/functional\n> tests in Bitcoin Core, at least.\n> \n> OP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I\n> just independently arrived at the same conclusion.\n\nWell, frankly I really don't like the idea of using OP_2 just to avoid changing\nsome unit tests. We're doing something that many people will use for years to\ncome, that's unnecessarily obscure just because we don't want to spend a bit of\nsome modifying some tests to pass.\n\nOP_TRUE is the obvious way to do this, and it results with a 1 on the stack,\nwhich plays better with other standardness rules. OP_2 means we *also* may need\nto special case having a 2 on the stack in certain implementations of other\nstandardness rules.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/e0de4880/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2023-02-02T20:47:28",
                "message_text_only": "> OP_TRUE is the obvious way to do this, and it results with a 1 on the\nstack,\nwhich plays better with other standardness rules.\n\nWhat other standardness rules? MINAMALIF? How does that interact with the\nproposal?\n\nOn Thu, Feb 2, 2023 at 3:22 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Thu, Feb 02, 2023 at 01:36:24PM -0500, Greg Sanders wrote:\n> > Quickly checked, it fails a number of standardness tests in\n> unit/functional\n> > tests in Bitcoin Core, at least.\n> >\n> > OP_2 was actually Luke Jr's idea circa 2017 for about the same reasons, I\n> > just independently arrived at the same conclusion.\n>\n> Well, frankly I really don't like the idea of using OP_2 just to avoid\n> changing\n> some unit tests. We're doing something that many people will use for years\n> to\n> come, that's unnecessarily obscure just because we don't want to spend a\n> bit of\n> some modifying some tests to pass.\n>\n> OP_TRUE is the obvious way to do this, and it results with a 1 on the\n> stack,\n> which plays better with other standardness rules. OP_2 means we *also* may\n> need\n> to special case having a 2 on the stack in certain implementations of other\n> standardness rules.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230202/b4d28f33/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-03T22:10:43",
                "message_text_only": "On Thu, Feb 02, 2023 at 03:47:28PM -0500, Greg Sanders wrote:\n> > OP_TRUE is the obvious way to do this, and it results with a 1 on the\n> stack,\n> which plays better with other standardness rules.\n> \n> What other standardness rules? MINAMALIF? How does that interact with the\n> proposal?\n\nIt makes sense to require scripts to leave just a single OP_TRUE on the stack\nat the end of execution, as otherwise that can be a source of malleability in\ncertain circumstances where the scriptSig ends up providing the OP_TRUE. I\ndon't believe we actually implement this as a rule right now. But you could\neasily imagine that happening in a future upgrade.\n\nLeaving an OP_2 on the stack doesn't achieve that and would require a\nspecial-cased workaround. Spending the time now to do the obvious thing - use\nOP_TRUE as the canonical anyone-can-spend output - avoids this issue.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/e563fd6c/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2023-02-04T02:07:29",
                "message_text_only": "I'm not particularly persuaded, but also not wedded to either idea.\n\nFixed up tests for the OP_TRUE case here:\nhttps://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true\n\nOn Fri, Feb 3, 2023 at 5:10 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Thu, Feb 02, 2023 at 03:47:28PM -0500, Greg Sanders wrote:\n> > > OP_TRUE is the obvious way to do this, and it results with a 1 on the\n> > stack,\n> > which plays better with other standardness rules.\n> >\n> > What other standardness rules? MINAMALIF? How does that interact with the\n> > proposal?\n>\n> It makes sense to require scripts to leave just a single OP_TRUE on the\n> stack\n> at the end of execution, as otherwise that can be a source of malleability\n> in\n> certain circumstances where the scriptSig ends up providing the OP_TRUE. I\n> don't believe we actually implement this as a rule right now. But you could\n> easily imagine that happening in a future upgrade.\n>\n> Leaving an OP_2 on the stack doesn't achieve that and would require a\n> special-cased workaround. Spending the time now to do the obvious thing -\n> use\n> OP_TRUE as the canonical anyone-can-spend output - avoids this issue.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/f6d3bb53/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-04T16:02:45",
                "message_text_only": "On Fri, Feb 03, 2023 at 09:07:29PM -0500, Greg Sanders wrote:\n> I'm not particularly persuaded, but also not wedded to either idea.\n> \n> Fixed up tests for the OP_TRUE case here:\n> https://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true\n\nThanks.\n\nLooking through that, I think a lot of those test cases don't actually need to\nbe changed to OP_2, as they aren't trying to test anything related to\nstandardness.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/f63c63cb/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Greg Sanders"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 9520
        }
    },
    {
        "title": "[bitcoin-dev] Ordinal Inscription Size Limits",
        "thread_messages": [
            {
                "author": "Melvin Carvalho",
                "date": "2023-02-03T19:56:16",
                "message_text_only": "p\u00e1 27. 1. 2023 v 13:47 odes\u00edlatel Robert Dickinson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> napsal:\n\n> I'm curious what opinions exist and what actions might be taken by core\n> developers regarding storing unlimited amounts of NFT (or other?) content\n> as witness data (https://docs.ordinals.com/inscriptions.html). The\n> ordinal scheme is elegant and genius IMHO, but when I think about the\n> future disk use of all unpruned nodes, I question whether unlimited storage\n> is wise to allow for such use cases. Wouldn't it be better to find a way to\n> impose a size limit similar to OP_RETURN for such inscriptions?\n>\n> I think it would be useful to link a sat to a deed or other legal\n> construct for proof of ownership in the real world, so that real property\n> can be transferred on the blockchain using ordinals, but storing the\n> property itself on the blockchain seems nonsensical to me.\n>\n\nLow tech solution: miners charge a premium for storing images in the block\nchain.  Say 2x, 5x, 10x.\n\nThis encourages bitcoin to be used as a financial network, while increasing\nthe security budget.\n\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230203/ecd518a8/attachment.html>"
            },
            {
                "author": "Kostas Karasavvas",
                "date": "2023-02-04T14:25:58",
                "message_text_only": "On Fri, Feb 3, 2023 at 10:17 PM Melvin Carvalho via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n>\n> p\u00e1 27. 1. 2023 v 13:47 odes\u00edlatel Robert Dickinson via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> napsal:\n>\n>> I'm curious what opinions exist and what actions might be taken by core\n>> developers regarding storing unlimited amounts of NFT (or other?) content\n>> as witness data (https://docs.ordinals.com/inscriptions.html). The\n>> ordinal scheme is elegant and genius IMHO, but when I think about the\n>> future disk use of all unpruned nodes, I question whether unlimited storage\n>> is wise to allow for such use cases. Wouldn't it be better to find a way to\n>> impose a size limit similar to OP_RETURN for such inscriptions?\n>>\n>>\nPersonally, I was always considering future disk use at full capacity\nanyway (and planning accordingly). Even without inscriptions/ordinals that\nwould happen. The latter competes for block space and are paying tx fees so\nI don't see it as that much harmful (esp.now that it is out there... I\nwould be more conservative if we were talking about introducing it!).\n\n\n\n> I think it would be useful to link a sat to a deed or other legal\n>> construct for proof of ownership in the real world, so that real property\n>> can be transferred on the blockchain using ordinals, but storing the\n>> property itself on the blockchain seems nonsensical to me.\n>>\n>\n> Low tech solution: miners charge a premium for storing images in the block\n> chain.  Say 2x, 5x, 10x.\n>\n> This encourages bitcoin to be used as a financial network, while\n> increasing the security budget.\n>\n\nHow would you enforce this technically?  I only see it feasible if miners\nagree by social contract.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/864a905e/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2023-02-06T16:39:14",
                "message_text_only": "its trivial to store images in such a way that they look like legit\ntransactions.\n\nthis was done, in the past, using large numbers of multisig output\naddresses that encode the images.\n\ngiven the goals of the project, introducing this sort of censorship into\nbitcoin seems fundamentally undesirable\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/54dd7165/attachment.html>"
            },
            {
                "author": "Claus Ehrenberg",
                "date": "2023-02-06T17:31:45",
                "message_text_only": "The inscriptions are designed to be easy to use, they even specify that\nmime types should be used. I'd say, the way the data is stored is anything\nbut 'obscure'. UIs will be popping up to make this really easy. The main\nchain can't be censored, what's in a block is in a block. I'm predicting a\nhuge success.\n\nSo, are we ready to accept that we'll likely see the first pictures with\ninsults or worse in the Bitcoin chain? I really like the idea, but the risk\nis pretty obvious. I think it would be prudent to have at least an opt-out\nfeature for the data. So that it's possible to use the chain without the\npotentially malicious content. That means the content shouldn't live in the\nessential data of the main chain. Better would be something like the\nextension blocks in Litecoin.\n\nBest Regards\nClaus\n\nOn Fri, Jan 27, 2023 at 1:47 PM Robert Dickinson via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I'm curious what opinions exist and what actions might be taken by core\n> developers regarding storing unlimited amounts of NFT (or other?) content\n> as witness data (https://docs.ordinals.com/inscriptions.html). The\n> ordinal scheme is elegant and genius IMHO, but when I think about the\n> future disk use of all unpruned nodes, I question whether unlimited storage\n> is wise to allow for such use cases. Wouldn't it be better to find a way to\n> impose a size limit similar to OP_RETURN for such inscriptions?\n>\n> I think it would be useful to link a sat to a deed or other legal\n> construct for proof of ownership in the real world, so that real property\n> can be transferred on the blockchain using ordinals, but storing the\n> property itself on the blockchain seems nonsensical to me.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/b8d52343/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2023-02-06T18:05:05",
                "message_text_only": "there are already images encoded in the chain using multisig.  when we\neliminated the max-witness size in 2017, that made it a bit cheaper, that's\nall (one tx instead of many)\n\nhttps://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html\n\nmy favorite one is the javascript exploit for people that like to render\nuntrusted blockchain data in their browser\n\nthe script to interpret these is trivial, and it's not much harder to add a\nmime type\n\n\n\nOn Mon, Feb 6, 2023 at 12:34 PM Claus Ehrenberg via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The inscriptions are designed to be easy to use, they even specify that\n> mime types should be used. I'd say, the way the data is stored is anything\n> but 'obscure'. UIs will be popping up to make this really easy. The main\n> chain can't be censored, what's in a block is in a block. I'm predicting a\n> huge success.\n>\n> So, are we ready to accept that we'll likely see the first pictures with\n> insults or worse in the Bitcoin chain? I really like the idea, but the risk\n> is pretty obvious. I think it would be prudent to have at least an opt-out\n> feature for the data. So that it's possible to use the chain without the\n> potentially malicious content. That means the content shouldn't live in the\n> essential data of the main chain. Better would be something like the\n> extension blocks in Litecoin.\n>\n> Best Regards\n> Claus\n>\n> On Fri, Jan 27, 2023 at 1:47 PM Robert Dickinson via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I'm curious what opinions exist and what actions might be taken by core\n>> developers regarding storing unlimited amounts of NFT (or other?) content\n>> as witness data (https://docs.ordinals.com/inscriptions.html). The\n>> ordinal scheme is elegant and genius IMHO, but when I think about the\n>> future disk use of all unpruned nodes, I question whether unlimited storage\n>> is wise to allow for such use cases. Wouldn't it be better to find a way to\n>> impose a size limit similar to OP_RETURN for such inscriptions?\n>>\n>> I think it would be useful to link a sat to a deed or other legal\n>> construct for proof of ownership in the real world, so that real property\n>> can be transferred on the blockchain using ordinals, but storing the\n>> property itself on the blockchain seems nonsensical to me.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/8b27df91/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2023-02-07T12:17:24",
                "message_text_only": "Le 06/02/2023 \u00e0 19:05, Erik Aronesty via bitcoin-dev a \u00e9crit :\n> my favorite one is the javascript exploit for people that like to\n> render untrusted blockchain data in their browser\n\nTaking this example to show that from my standpoint it's not a good idea\nto store \"big things\" in the blockchain, but it's a good idea to store\nproofs of something ( then this is the rationale for this change request\nhttps://github.com/bitcoin/bitcoin/issues/27043), we all know that there\nare plenty of useless things already stored in the blockchain, now if\npeople want to pay to store big things, then let them do it\n\nBut how can you validate what is stored? Simple answer: you can't, I\ntake in my NFT proposal the example of js code loading, it's impossible\nto be sure of the code loaded (and it is supposed to evolve, then which\nversion is correct in the blockchain can be mysterious) without using a\nthird party, that's what I am doing here: https://peersm.com/wallet, the\nthird party is my github repo, the code self validates that it is the\ncorrect one and the user must check the hash, of course the code could\nlie then you should better embed the check in a bookmarklet, the page\ncan't lie, and of course I could be  a thief then others should check\nthe code and seed the hash somewhere, even if clearly explained that the\ncode must be used off line it's not difficult to invent different things\nto steal the keys\n\nSame principle applies with my NFT proposal (which can be real things,\nso impossible to store in the blockchain): a third party allowing a\ntimestamp is used to prove that you are the seeder of the NFT (first\nowner), minting can't be trusted and then becomes useless with the third\nparty, so you spare some bitcoin transactions\n\nUsing a third party does not mean that the blockchain is of no use,\nagain the blockchain will validate the life of the NFT and it remains\ndecentralized like lightning"
            }
        ],
        "thread_summary": {
            "title": "Ordinal Inscription Size Limits",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Claus Ehrenberg",
                "Aymeric Vitte",
                "Erik Aronesty",
                "Melvin Carvalho",
                "Kostas Karasavvas"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 10757
        }
    },
    {
        "title": "[bitcoin-dev] A proposal for Full RBF to not exclude Zero Conf use case",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2023-02-04T16:27:47",
                "message_text_only": "On Sat, Jan 14, 2023 at 10:15:30PM +0200, Daniel Lipshitz wrote:\n> We have standard commercial information about the payment processors, non\n> custodial liquidity providers and merchants which become our clients - we\n> do not have any kyc/aml information or telephone number on who is sending\n> our clients the bitcoin for deposit.  For us these are just bitcoin Trx\n> which our clients choose to benefit from 0-conf deposit recognition. Our\n> service is provided via API with the only information our clients share\n> with us, regarding a specific bitcoin transaction, being public bitcoin\n> information like trx hash and output address.\n\nYou know who your clients are, and thus every request for information on a\ntransaction is reasonably likely to be a deposit associated with the client who\nrequested it. Learning what addresses are associated with what entity is a\nsignificant benefit to Chainalysis operations, and there's every reason to\nexpect that the data you learn will either be sold or leaked to Chainalysis\ncompanies.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230204/cbbcc901/attachment-0001.sig>"
            },
            {
                "author": "Daniel Lipshitz",
                "date": "2023-02-06T12:08:40",
                "message_text_only": "On Sat, Feb 4, 2023 at 6:28 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Sat, Jan 14, 2023 at 10:15:30PM +0200, Daniel Lipshitz wrote:\n> > We have standard commercial information about the payment processors, non\n> > custodial liquidity providers and merchants which become our clients - we\n> > do not have any kyc/aml information or telephone number on who is sending\n> > our clients the bitcoin for deposit.  For us these are just bitcoin Trx\n> > which our clients choose to benefit from 0-conf deposit recognition. Our\n> > service is provided via API with the only information our clients share\n> > with us, regarding a specific bitcoin transaction, being public bitcoin\n> > information like trx hash and output address.\n>\n> You know who your clients are, and thus every request for information on a\n> transaction is reasonably likely to be a deposit associated with the\n> client who\n> requested it. Learning what addresses are associated with what entity is a\n> significant benefit to Chainalysis operations, and there's every reason to\n> expect that the data you learn will either be sold or leaked to Chainalysis\n> companies.\n>\n\nI would estimate based on general discussions with clients and open\nresearch more than 90% of our clients use different AML trx analysis\nservice providers for trx deposited on their platforms -\ncompletely irrelevant to us or 0-conf. So if these clients were to stop\nrecognising 0-conf this would have no impact on these AML service providers\naccess to the data. We service payment processors and liquidity providers\nand have little or no insight into which wallets or merchants our clients\nservice.\n\n Further to this many of the cluster addresses of our clients and just like\nother service providers in the bitcoin space are publicly known - just as\nMax had no issue sharing the cluster of his deposit address in his email\nwhich I posted to the list.\n\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230206/ad228af5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "A proposal for Full RBF to not exclude Zero Conf use case",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Daniel Lipshitz",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3497
        }
    },
    {
        "title": "[bitcoin-dev] Unenforceable fee obligations in multiparty protocols with Taproot inputs",
        "thread_messages": [
            {
                "author": "Yuval Kogman",
                "date": "2023-02-07T02:49:28",
                "message_text_only": "## Summary\n\nSince Taproot (more generally any kind of MAST) spends have variable size which\ndepends on the path being used, the last such input to be signed in a multiparty\ntransaction can always use a larger than estimated signature to unfairly extract\na fee contribution from the other parties to the transaction (keeping the\nabsolute fees the same and reducing the feerate for the transaction).\n\n## Attack Scenario\n\nAlice et al wish to perform a multiparty transaction, such as a CoinJoin or\nlightning dual funding at a relatively high feerate.\n\nMallory has a P2TR output with a large script spend path, e.g. an ordinal\ninscription commitment transaction output.\n\nMallory registers this coin as an input into the multiparty transaction with a\nfee obligation calculated on the basis of a key spend. When all other\nparticipants have provided signatures, the script spend path can be used.\n\nSince the absolute fee amount is already committed to by the provided\n(`SIGHASH_ALL`) signatures but the total transaction weight is not, Mallory can\nbroadcast any valid signatures up to the maximum standard weight and minimum\nrelay fees, or in collusion with a miner, up to consensus limits.\n\nThis effectively steals a fee from Alice et al, as their signatures do not\ncommit to a feerate directly or indirectly.\n\n## Mitigations\n\n### RBF\n\nAll parties could negotiate a (series of) transaction(s) ahead of time at a\nlower feerate, giving a lower bound minimum feerate that Mallory can force.\n\n### Minimum Weight Before Signing\n\nEnforcing a minimal weight for all non-witness data in the transaction before\nthe transaction is considered fully constructed can limit the effectiveness of\nthis attack, since the difference between the predicted weight and the maximum\nweight decreases.\n\n### Trusted Coordinator\n\nIn the centralized setting if BIP-322 ownership proofs are required for\nparticipation and assuming the server can be trusted not to collude with\nMallory, the server can reject signatures that do not exercise the same spend\npath as the ownership proof, which makes the ownership proof a commitment to the\nspend weight of the input.\n\n### Reputation\n\nMultiparty protocols with publicly verifiable protocol transcripts can be\nprovided as weak evidence of a history of honest participation in multiparty\ntransactions.\n\nA ring signature from keys used in the transaction or its transcript committing\nto the new proposed transaction can provide weak evidence for the honesty of the\npeer.\n\nSuch proofs are more compelling to an entity which has participated in (one of)\nthe transcripts, or proximal transactions. Incentives are theoretically aligned\nif public coordinators publish these transcripts as a kind of server reputation.\n\n### Increasing Costliness\n\nA minimum feerate for the previous transaction or a minimum confirmation age\n(coindays destroyed implies time value, analogous to fidelity bonds) can be\nrequired for inputs to be added, in order to make such attacks less lucrative\n(but there is still a positive payoff for the attacker).\n\n### Signature Ordering\n\nSignatures from potentially exploitative inputs can be required ahead of legacy\nor SegWit v0 ones. The prescribed order can be determined based on reputation or\ncostliness as described in the previous paragraphs."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2023-02-07T04:38:30",
                "message_text_only": "Hi Yuval,\n\nThis is an interesting attack. Usually I think of spending with a big\nweight witness in the context of slowing down a confirmation of a\ntransaction, especially a DLC creation tx. There you can delay its\nconfirmation past some time (i.e. see if your team won the game, and then\neither trying to confirm it by providing the slimmed down witness or double\ncancelling it by double spending). In this case you are not trying to delay\nit but to dilute your portion of the fee.\n\nAnother mitigation is to aggresively RBF double spend your input any time a\ncounterparty doesn't use the spending path they said they would and don't\ndeal with them again. Of course, various pinning attacks may prevent this\ndepending on how your joint tx is structured.\n\nLL\n\nOn Tue, 7 Feb 2023 at 13:59, Yuval Kogman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> ## Summary\n>\n> Since Taproot (more generally any kind of MAST) spends have variable size\n> which\n> depends on the path being used, the last such input to be signed in a\n> multiparty\n> transaction can always use a larger than estimated signature to unfairly\n> extract\n> a fee contribution from the other parties to the transaction (keeping the\n> absolute fees the same and reducing the feerate for the transaction).\n>\n> ## Attack Scenario\n>\n> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or\n> lightning dual funding at a relatively high feerate.\n>\n> Mallory has a P2TR output with a large script spend path, e.g. an ordinal\n> inscription commitment transaction output.\n>\n> Mallory registers this coin as an input into the multiparty transaction\n> with a\n> fee obligation calculated on the basis of a key spend. When all other\n> participants have provided signatures, the script spend path can be used.\n>\n> Since the absolute fee amount is already committed to by the provided\n> (`SIGHASH_ALL`) signatures but the total transaction weight is not,\n> Mallory can\n> broadcast any valid signatures up to the maximum standard weight and\n> minimum\n> relay fees, or in collusion with a miner, up to consensus limits.\n>\n> This effectively steals a fee from Alice et al, as their signatures do not\n> commit to a feerate directly or indirectly.\n>\n> ## Mitigations\n>\n> ### RBF\n>\n> All parties could negotiate a (series of) transaction(s) ahead of time at a\n> lower feerate, giving a lower bound minimum feerate that Mallory can force.\n>\n> ### Minimum Weight Before Signing\n>\n> Enforcing a minimal weight for all non-witness data in the transaction\n> before\n> the transaction is considered fully constructed can limit the\n> effectiveness of\n> this attack, since the difference between the predicted weight and the\n> maximum\n> weight decreases.\n>\n> ### Trusted Coordinator\n>\n> In the centralized setting if BIP-322 ownership proofs are required for\n> participation and assuming the server can be trusted not to collude with\n> Mallory, the server can reject signatures that do not exercise the same\n> spend\n> path as the ownership proof, which makes the ownership proof a commitment\n> to the\n> spend weight of the input.\n>\n> ### Reputation\n>\n> Multiparty protocols with publicly verifiable protocol transcripts can be\n> provided as weak evidence of a history of honest participation in\n> multiparty\n> transactions.\n>\n> A ring signature from keys used in the transaction or its transcript\n> committing\n> to the new proposed transaction can provide weak evidence for the honesty\n> of the\n> peer.\n>\n> Such proofs are more compelling to an entity which has participated in\n> (one of)\n> the transcripts, or proximal transactions. Incentives are theoretically\n> aligned\n> if public coordinators publish these transcripts as a kind of server\n> reputation.\n>\n> ### Increasing Costliness\n>\n> A minimum feerate for the previous transaction or a minimum confirmation\n> age\n> (coindays destroyed implies time value, analogous to fidelity bonds) can be\n> required for inputs to be added, in order to make such attacks less\n> lucrative\n> (but there is still a positive payoff for the attacker).\n>\n> ### Signature Ordering\n>\n> Signatures from potentially exploitative inputs can be required ahead of\n> legacy\n> or SegWit v0 ones. The prescribed order can be determined based on\n> reputation or\n> costliness as described in the previous paragraphs.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/95202031/attachment.html>"
            },
            {
                "author": "Nadav Ivgi",
                "date": "2023-02-07T09:36:58",
                "message_text_only": "> Since Taproot (more generally any kind of MAST) spends have variable size\n\nIsn't this the case with any arbitrary script execution? Non-taproot\nP2(W)SH can also have multiple (OP_IF-gated) script branches. For example\nwith `<pk> CHECKSIG IF SHA256 <hash> EQUALVERIFY ENDIF`, Mallory can\ninitially demonstrate that she can spend with `FALSE <sig>`, then later\nswitch to spending with `<some large preimage> TRUE <sig>`. (or I guess\neven `DROP <pk> CHECKSIG`, then just switch from DROPing a 0 length item to\na larger one)\n\nIt seems that supporting arbitrary scripts would require analyzing them and\nverifying that all spend paths are acceptable, with or without Taproot/MAST.\n\nIf the goal is to only allow registering simple singlesig-encumbered UTXOs\nlike P2(W)PKH, the participants could be asked to prove that their P2TR\noutput commits to an unspendable script path [0].\n\nshesek\n\n[0]\nhttps://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-23-0\n\nOn Tue, Feb 7, 2023 at 4:59 AM Yuval Kogman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> ## Summary\n>\n> Since Taproot (more generally any kind of MAST) spends have variable size\n> which\n> depends on the path being used, the last such input to be signed in a\n> multiparty\n> transaction can always use a larger than estimated signature to unfairly\n> extract\n> a fee contribution from the other parties to the transaction (keeping the\n> absolute fees the same and reducing the feerate for the transaction).\n>\n> ## Attack Scenario\n>\n> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or\n> lightning dual funding at a relatively high feerate.\n>\n> Mallory has a P2TR output with a large script spend path, e.g. an ordinal\n> inscription commitment transaction output.\n>\n> Mallory registers this coin as an input into the multiparty transaction\n> with a\n> fee obligation calculated on the basis of a key spend. When all other\n> participants have provided signatures, the script spend path can be used.\n>\n> Since the absolute fee amount is already committed to by the provided\n> (`SIGHASH_ALL`) signatures but the total transaction weight is not,\n> Mallory can\n> broadcast any valid signatures up to the maximum standard weight and\n> minimum\n> relay fees, or in collusion with a miner, up to consensus limits.\n>\n> This effectively steals a fee from Alice et al, as their signatures do not\n> commit to a feerate directly or indirectly.\n>\n> ## Mitigations\n>\n> ### RBF\n>\n> All parties could negotiate a (series of) transaction(s) ahead of time at a\n> lower feerate, giving a lower bound minimum feerate that Mallory can force.\n>\n> ### Minimum Weight Before Signing\n>\n> Enforcing a minimal weight for all non-witness data in the transaction\n> before\n> the transaction is considered fully constructed can limit the\n> effectiveness of\n> this attack, since the difference between the predicted weight and the\n> maximum\n> weight decreases.\n>\n> ### Trusted Coordinator\n>\n> In the centralized setting if BIP-322 ownership proofs are required for\n> participation and assuming the server can be trusted not to collude with\n> Mallory, the server can reject signatures that do not exercise the same\n> spend\n> path as the ownership proof, which makes the ownership proof a commitment\n> to the\n> spend weight of the input.\n>\n> ### Reputation\n>\n> Multiparty protocols with publicly verifiable protocol transcripts can be\n> provided as weak evidence of a history of honest participation in\n> multiparty\n> transactions.\n>\n> A ring signature from keys used in the transaction or its transcript\n> committing\n> to the new proposed transaction can provide weak evidence for the honesty\n> of the\n> peer.\n>\n> Such proofs are more compelling to an entity which has participated in\n> (one of)\n> the transcripts, or proximal transactions. Incentives are theoretically\n> aligned\n> if public coordinators publish these transcripts as a kind of server\n> reputation.\n>\n> ### Increasing Costliness\n>\n> A minimum feerate for the previous transaction or a minimum confirmation\n> age\n> (coindays destroyed implies time value, analogous to fidelity bonds) can be\n> required for inputs to be added, in order to make such attacks less\n> lucrative\n> (but there is still a positive payoff for the attacker).\n>\n> ### Signature Ordering\n>\n> Signatures from potentially exploitative inputs can be required ahead of\n> legacy\n> or SegWit v0 ones. The prescribed order can be determined based on\n> reputation or\n> costliness as described in the previous paragraphs.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/85947d66/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-07T12:50:13",
                "message_text_only": "On Tue, Feb 07, 2023 at 11:36:58AM +0200, Nadav Ivgi via bitcoin-dev wrote:\n> > Since Taproot (more generally any kind of MAST) spends have variable size\n> \n> Isn't this the case with any arbitrary script execution? Non-taproot\n\nThis is even been true for P2PKH inputs: you can double the space of your\nscriptSigs by using uncompressed pubkeys instead of compressed pubkeys.\n\n> If the goal is to only allow registering simple singlesig-encumbered UTXOs\n> like P2(W)PKH, the participants could be asked to prove that their P2TR\n> output commits to an unspendable script path [0].\n\nTechnically, only the last person to sign needs to prove this in advance.\nEveryone else can prove it with their signatures.\n\nThis distinction could be useful to support coinjoin participants spending\ncomplex P2TR outputs into coinjoins, a perfectly valid use-case in theory so\nlong as they're paying appropriate fees. Though due to how difficult it is to\nvalidate scripts reliably outside the consensus code base, allowing this for\narbitrary scripts could lead to DoS attacks where someone takes advantage of a\nbug in script execution to create an invalid transaction.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/03253ed3/attachment.sig>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-07T13:46:22",
                "message_text_only": "On Tue, Feb 07, 2023 at 04:49:28AM +0200, Yuval Kogman via bitcoin-dev wrote:\n> \n> Since Taproot (more generally any kind of MAST) spends have variable size which\n> depends on the path being used, the last such input to be signed in a multiparty\n> transaction can always use a larger than estimated signature to unfairly extract\n> a fee contribution from the other parties to the transaction (keeping the\n> absolute fees the same and reducing the feerate for the transaction).\n>\n\nUsing Miniscript [1] it is possible for all participants to determine\nthe maximum witness size of the tree, which can bound the size of this\nattack. In fact, they can bound the size *given that their own signature\nis used*, or subject to other whatever other conditions they would like,\nand only sign under those conditions.\n\nFurthermore, under Taproot individual signatures have a maximum size of\n65 bytes; an \"attacker\" can reduce this to 64 by not including a sighash\nflag, but he has one byte of play. (Pre-Taproot signatures could take up\nto 73 bytes with significant room to reduce this by using crypto tricks\nand/or grinding).\n\nPeter Todd also suggests in this thread that the use of uncompressed\nkeys can cause \"surprise\" witness inflation, but (a) since segwit\nuncompressed keys are also banned, so keys are a fixed 33 bytes (32 in\nTaproot), and (b) we expect users of Miniscript to always know all the\nkeys used in a script that they're signing. Except perhaps in obscure\ncases where, say, the \"victim\" is a somewhat passive countersigner of\na transaction, e.g. BitGo, ... in which case they're not the one putting\nup fees or with an interest in the transaction going through.\n\n\nWith Miniscript, the problem is narrower:\n\n* There is some more-expensive branch that could be taken without\n  Alice's signature. In which case Alice is only signing at all to\n  optimistically reduce the witness size... but she cannot assume\n  that she is going to be successful!\n\n  Notably, in this case Alice does not really have any interest in the\n  coins, in the sense that they can move entirely without her consent,\n  so it's hard to imagine that she has an interest in the transaction's\n  speedy confirmation.\n\n* There is some more-expensive branch that could be taken by moving\n  Alice's signature. This is the case that you identify in the thread.\n\nWhile the attack remains in both cases, fortunately Miniscript gives\nAlice the tools to (a) determine which, if any, case applies to the\nscript under question, and (b) determine what the maximum witness size\nmight be, and just sign assuming that, treating any savings as \"bonus\".\n\n\n\n[1] https://bitcoin.sipa.be/miniscript/\n[2] In Taproot, if you want to prevent signatures migrating to another\n    branch or within a branch, you can use the CODESEPARATOR opcode\n    which was redisegned in Taproot for exactly this purpose... we\n    really did about witness malleation in its design!\n\n    If you want to prevent signatures from moving around *within* a\n    branch,\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/bd1c6f4e/attachment.sig>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-07T18:10:10",
                "message_text_only": "Some people highlighted some minor problems with my last email:\n\nOn Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n> \n> <snip> \n> \n> [1] https://bitcoin.sipa.be/miniscript/\n> [2] In Taproot, if you want to prevent signatures migrating to another\n>     branch or within a branch, you can use the CODESEPARATOR opcode\n>     which was redisegned in Taproot for exactly this purpose... we\n>     really did about witness malleation in its design!\n\nIn Taproot the tapleaf hash is always covered by the signature (though\nnot in some ANYONECANPAY proposals) so you can never migrate signatures\nbetween tapbranches.\n\nI had thought this was the case, but then I re-confused myself by\nreading BIP 341 .... which has much of the sighash specified, but not\nall of it! The tapleaf hash is added in BIP 342.\n\n> \n>     If you want to prevent signatures from moving around *within* a\n>     branch,\n>\n\nAnd this sentence I just meant to delete :)\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/8d59f739/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-07T18:35:12",
                "message_text_only": "There is a bug in Taproot that allows the same Tapleaf to be repeated\nmultiple times in the same Taproot, potentially at different Taplevels\nincurring different Tapfee rates.\n\nThe countermeasure is that you should always know the entire Taptree when\ninteracting with someone's Tapspend.\n\n\nOn Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Some people highlighted some minor problems with my last email:\n>\n> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev\n> wrote:\n> >\n> > <snip>\n> >\n> > [1] https://bitcoin.sipa.be/miniscript/\n> > [2] In Taproot, if you want to prevent signatures migrating to another\n> >     branch or within a branch, you can use the CODESEPARATOR opcode\n> >     which was redisegned in Taproot for exactly this purpose... we\n> >     really did about witness malleation in its design!\n>\n> In Taproot the tapleaf hash is always covered by the signature (though\n> not in some ANYONECANPAY proposals) so you can never migrate signatures\n> between tapbranches.\n>\n> I had thought this was the case, but then I re-confused myself by\n> reading BIP 341 .... which has much of the sighash specified, but not\n> all of it! The tapleaf hash is added in BIP 342.\n>\n> >\n> >     If you want to prevent signatures from moving around *within* a\n> >     branch,\n> >\n>\n> And this sentence I just meant to delete :)\n>\n>\n> --\n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> The sun is always shining in space\n>     -Justin Lewis-Webster\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/57930553/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-07T19:04:00",
                "message_text_only": "On Tue, Feb 07, 2023 at 01:35:12PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> There is a bug in Taproot that allows the same Tapleaf to be repeated\n> multiple times in the same Taproot, potentially at different Taplevels\n> incurring different Tapfee rates.\n> \n> The countermeasure is that you should always know the entire Taptree when\n> interacting with someone's Tapspend.\n\nAnother countermeasure could be to implement RBF on taproot witnesses, allowing\ntransactions with deeper, less efficient, tapleaf scripts to be replaced with\nshallower, more efficient, tapleafs. If implemented by giving your peer some\nkind of delta encoded update, the bandwidth efficiency may be sufficient to\nalways allow such updates.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/38829718/attachment.sig>"
            },
            {
                "author": "Michael Folkson",
                "date": "2023-02-08T09:34:57",
                "message_text_only": "Hi Andrew\n\n> There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.\n>> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.\n\nI wouldn't say it is a \"bug\" unless there is a remedy for the bug that wasn't (and retrospectively should have been) included in the Taproot design. In retrospect and assuming you could redesign the Taproot consensus rules again today would you prevent spending from a valid P2TR address if a repeated Tapleaf hash was used to prove that a spending path was embedded in a Taproot tree? That's the only thing I can think of to attempt to remedy this \"bug\" and it would only be a partial protection as proving a spending path exists within a Taproot tree only requires a subset of the Tapleaf hashes.\n\nI only point this out because there seems to be a push to find \"bugs\" and \"accidental blowups\" in the Taproot design currently. No problem with this if there are any, they should definitely be highlighted and discussed if they do exist. The nearest to a possible inferior design decision thus far that I'm aware of is x-only pubkeys in BIP340 [0].\n\nThanks\nMichael\n\n[0]: https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340\n\n--\nMichael Folkson\nEmail: michaelfolkson at [protonmail.com](http://protonmail.com/)\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n------- Original Message -------\nOn Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.\n>\n> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.\n>\n> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Some people highlighted some minor problems with my last email:\n>>\n>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n>>>\n>>> <snip>\n>>>\n>>> [1] https://bitcoin.sipa.be/miniscript/\n>>> [2] In Taproot, if you want to prevent signatures migrating to another\n>>> branch or within a branch, you can use the CODESEPARATOR opcode\n>>> which was redisegned in Taproot for exactly this purpose... we\n>>> really did about witness malleation in its design!\n>>\n>> In Taproot the tapleaf hash is always covered by the signature (though\n>> not in some ANYONECANPAY proposals) so you can never migrate signatures\n>> between tapbranches.\n>>\n>> I had thought this was the case, but then I re-confused myself by\n>> reading BIP 341 .... which has much of the sighash specified, but not\n>> all of it! The tapleaf hash is added in BIP 342.\n>>\n>>>\n>>> If you want to prevent signatures from moving around *within* a\n>>> branch,\n>>>\n>>\n>> And this sentence I just meant to delete :)\n>>\n>> --\n>> Andrew Poelstra\n>> Director of Research, Blockstream\n>> Email: apoelstra at wpsoftware.net\n>> Web: https://www.wpsoftware.net/andrew\n>>\n>> The sun is always shining in space\n>> -Justin Lewis-Webster\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/6a71e08e/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-08T14:00:48",
                "message_text_only": "On Wed, Feb 08, 2023 at 09:34:57AM +0000, Michael Folkson wrote:\n> Hi Andrew\n> \n> > There is a bug in Taproot that allows the same Tapleaf to be repeated multiple times in the same Taproot, potentially at different Taplevels incurring different Tapfee rates.\n> >> The countermeasure is that you should always know the entire Taptree when interacting with someone's Tapspend.\n> \n> I wouldn't say it is a \"bug\" unless there is a remedy for the bug that wasn't (and retrospectively should have been) included in the Taproot design. In retrospect and assuming you could redesign the Taproot consensus rules again today would you prevent spending from a valid P2TR address if a repeated Tapleaf hash was used to prove that a spending path was embedded in a Taproot tree? That's the only thing I can think of to attempt to remedy this \"bug\" and it would only be a partial protection as proving a spending path exists within a Taproot tree only requires a subset of the Tapleaf hashes.\n> \n> I only point this out because there seems to be a push to find \"bugs\" and \"accidental blowups\" in the Taproot design currently. No problem with this if there are any, they should definitely be highlighted and discussed if they do exist. The nearest to a possible inferior design decision thus far that I'm aware of is x-only pubkeys in BIP340 [0].\n> \n\nI'm actually not certain what Russell's referring to, but if it's indeed\npossible to construct TapTrees where the \"same\" leafhash appears multiple\ntimes at different heights, that's something unintended and which we\ncould've fixed by changing the Merkle structure. I don't even think\nthere would've been an efficiency tradeoff.\n\nSo I think it's totally reasonable to call such a thing a \"bug\".\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/81f97b92/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-08T14:04:16",
                "message_text_only": "The fix for the bug is to sign the entire tapbranch instead of the tapleaf.\n\nOn Wed., Feb. 8, 2023, 04:35 Michael Folkson, <michaelfolkson at protonmail.com>\nwrote:\n\n> Hi Andrew\n>\n> > There is a bug in Taproot that allows the same Tapleaf to be repeated\n> multiple times in the same Taproot, potentially at different Taplevels\n> incurring different Tapfee rates.\n> >\n> > The countermeasure is that you should always know the entire Taptree\n> when interacting with someone's Tapspend.\n>\n> I wouldn't say it is a \"bug\" unless there is a remedy for the bug that\n> wasn't (and retrospectively should have been) included in the Taproot\n> design. In retrospect and assuming you could redesign the Taproot consensus\n> rules again today would you prevent spending from a valid P2TR address if a\n> repeated Tapleaf hash was used to prove that a spending path was embedded\n> in a Taproot tree? That's the only thing I can think of to attempt to\n> remedy this \"bug\" and it would only be a partial protection as proving a\n> spending path exists within a Taproot tree only requires a subset of the\n> Tapleaf hashes.\n>\n> I only point this out because there seems to be a push to find \"bugs\" and\n> \"accidental blowups\" in the Taproot design currently. No problem with this\n> if there are any, they should definitely be highlighted and discussed if\n> they do exist. The nearest to a possible inferior design decision thus far\n> that I'm aware of is x-only pubkeys in BIP340 [0].\n>\n> Thanks\n> Michael\n>\n> [0]:\n> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at protonmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>\n> ------- Original Message -------\n> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> There is a bug in Taproot that allows the same Tapleaf to be repeated\n> multiple times in the same Taproot, potentially at different Taplevels\n> incurring different Tapfee rates.\n>\n> The countermeasure is that you should always know the entire Taptree when\n> interacting with someone's Tapspend.\n>\n>\n> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> Some people highlighted some minor problems with my last email:\n>>\n>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev\n>> wrote:\n>> >\n>> > <snip>\n>> >\n>> > [1] https://bitcoin.sipa.be/miniscript/\n>> > [2] In Taproot, if you want to prevent signatures migrating to another\n>> > branch or within a branch, you can use the CODESEPARATOR opcode\n>> > which was redisegned in Taproot for exactly this purpose... we\n>> > really did about witness malleation in its design!\n>>\n>> In Taproot the tapleaf hash is always covered by the signature (though\n>> not in some ANYONECANPAY proposals) so you can never migrate signatures\n>> between tapbranches.\n>>\n>> I had thought this was the case, but then I re-confused myself by\n>> reading BIP 341 .... which has much of the sighash specified, but not\n>> all of it! The tapleaf hash is added in BIP 342.\n>>\n>> >\n>> > If you want to prevent signatures from moving around *within* a\n>> > branch,\n>> >\n>>\n>> And this sentence I just meant to delete :)\n>>\n>>\n>> --\n>> Andrew Poelstra\n>> Director of Research, Blockstream\n>> Email: apoelstra at wpsoftware.net\n>> Web: https://www.wpsoftware.net/andrew\n>>\n>> The sun is always shining in space\n>> -Justin Lewis-Webster\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/d4adc425/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-11T05:14:55",
                "message_text_only": "On 9 February 2023 12:04:16 am AEST, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>The fix for the bug is to sign the entire tapbranch instead of the tapleaf.\n>\n>On Wed., Feb. 8, 2023, 04:35 Michael Folkson, <michaelfolkson at protonmail.com>\n>wrote:\n>\n>> Hi Andrew\n>>\n>> > There is a bug in Taproot that allows the same Tapleaf to be repeated\n>> multiple times in the same Taproot, potentially at different Taplevels\n>> incurring different Tapfee rates.\n>> >\n>> > The countermeasure is that you should always know the entire Taptree\n>> when interacting with someone's Tapspend.\n>>\n>> I wouldn't say it is a \"bug\" unless there is a remedy for the bug that\n>> wasn't (and retrospectively should have been) included in the Taproot\n>> design. In retrospect and assuming you could redesign the Taproot consensus\n>> rules again today would you prevent spending from a valid P2TR address if a\n>> repeated Tapleaf hash was used to prove that a spending path was embedded\n>> in a Taproot tree? That's the only thing I can think of to attempt to\n>> remedy this \"bug\" and it would only be a partial protection as proving a\n>> spending path exists within a Taproot tree only requires a subset of the\n>> Tapleaf hashes.\n>>\n>> I only point this out because there seems to be a push to find \"bugs\" and\n>> \"accidental blowups\" in the Taproot design currently. No problem with this\n>> if there are any, they should definitely be highlighted and discussed if\n>> they do exist. The nearest to a possible inferior design decision thus far\n>> that I'm aware of is x-only pubkeys in BIP340 [0].\n>>\n>> Thanks\n>> Michael\n>>\n>> [0]:\n>> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340\n>>\n>> --\n>> Michael Folkson\n>> Email: michaelfolkson at protonmail.com\n>> Keybase: michaelfolkson\n>> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>>\n>> ------- Original Message -------\n>> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>> There is a bug in Taproot that allows the same Tapleaf to be repeated\n>> multiple times in the same Taproot, potentially at different Taplevels\n>> incurring different Tapfee rates.\n>>\n>> The countermeasure is that you should always know the entire Taptree when\n>> interacting with someone's Tapspend.\n>>\n>>\n>> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>>\n>>> Some people highlighted some minor problems with my last email:\n>>>\n>>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev\n>>> wrote:\n>>> >\n>>> > <snip>\n>>> >\n>>> > [1] https://bitcoin.sipa.be/miniscript/\n>>> > [2] In Taproot, if you want to prevent signatures migrating to another\n>>> > branch or within a branch, you can use the CODESEPARATOR opcode\n>>> > which was redisegned in Taproot for exactly this purpose... we\n>>> > really did about witness malleation in its design!\n>>>\n>>> In Taproot the tapleaf hash is always covered by the signature (though\n>>> not in some ANYONECANPAY proposals) so you can never migrate signatures\n>>> between tapbranches.\n>>>\n>>> I had thought this was the case, but then I re-confused myself by\n>>> reading BIP 341 .... which has much of the sighash specified, but not\n>>> all of it! The tapleaf hash is added in BIP 342.\n>>>\n>>> >\n>>> > If you want to prevent signatures from moving around *within* a\n>>> > branch,\n>>> >\n>>>\n>>> And this sentence I just meant to delete :)\n>>>\n>>>\n>>> --\n>>> Andrew Poelstra\n>>> Director of Research, Blockstream\n>>> Email: apoelstra at wpsoftware.net\n>>> Web: https://www.wpsoftware.net/andrew\n>>>\n>>> The sun is always shining in space\n>>> -Justin Lewis-Webster\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>>\n\nIs this something that should be fixed in bip118 signatures then?\n\nCheers,\naj\n-- \nSent from my phone."
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-11T14:40:38",
                "message_text_only": "Yes.  If you would otherwise sign the tapleaf, then I would recommend also\nsigning the entire tapbranch.\n\n\n\nOn Sat, Feb 11, 2023 at 12:15 AM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On 9 February 2023 12:04:16 am AEST, Russell O'Connor via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >The fix for the bug is to sign the entire tapbranch instead of the\n> tapleaf.\n> >\n> >On Wed., Feb. 8, 2023, 04:35 Michael Folkson, <\n> michaelfolkson at protonmail.com>\n> >wrote:\n> >\n> >> Hi Andrew\n> >>\n> >> > There is a bug in Taproot that allows the same Tapleaf to be repeated\n> >> multiple times in the same Taproot, potentially at different Taplevels\n> >> incurring different Tapfee rates.\n> >> >\n> >> > The countermeasure is that you should always know the entire Taptree\n> >> when interacting with someone's Tapspend.\n> >>\n> >> I wouldn't say it is a \"bug\" unless there is a remedy for the bug that\n> >> wasn't (and retrospectively should have been) included in the Taproot\n> >> design. In retrospect and assuming you could redesign the Taproot\n> consensus\n> >> rules again today would you prevent spending from a valid P2TR address\n> if a\n> >> repeated Tapleaf hash was used to prove that a spending path was\n> embedded\n> >> in a Taproot tree? That's the only thing I can think of to attempt to\n> >> remedy this \"bug\" and it would only be a partial protection as proving a\n> >> spending path exists within a Taproot tree only requires a subset of the\n> >> Tapleaf hashes.\n> >>\n> >> I only point this out because there seems to be a push to find \"bugs\"\n> and\n> >> \"accidental blowups\" in the Taproot design currently. No problem with\n> this\n> >> if there are any, they should definitely be highlighted and discussed if\n> >> they do exist. The nearest to a possible inferior design decision thus\n> far\n> >> that I'm aware of is x-only pubkeys in BIP340 [0].\n> >>\n> >> Thanks\n> >> Michael\n> >>\n> >> [0]:\n> >>\n> https://btctranscripts.com/london-bitcoin-devs/2022-08-11-tim-ruffing-musig2/#a-retrospective-look-at-bip340\n> >>\n> >> --\n> >> Michael Folkson\n> >> Email: michaelfolkson at protonmail.com\n> >> Keybase: michaelfolkson\n> >> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n> >>\n> >> ------- Original Message -------\n> >> On Tuesday, February 7th, 2023 at 18:35, Russell O'Connor via\n> bitcoin-dev <\n> >> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> There is a bug in Taproot that allows the same Tapleaf to be repeated\n> >> multiple times in the same Taproot, potentially at different Taplevels\n> >> incurring different Tapfee rates.\n> >>\n> >> The countermeasure is that you should always know the entire Taptree\n> when\n> >> interacting with someone's Tapspend.\n> >>\n> >>\n> >> On Tue, Feb 7, 2023 at 1:10 PM Andrew Poelstra via bitcoin-dev <\n> >> bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >>>\n> >>> Some people highlighted some minor problems with my last email:\n> >>>\n> >>> On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via\n> bitcoin-dev\n> >>> wrote:\n> >>> >\n> >>> > <snip>\n> >>> >\n> >>> > [1] https://bitcoin.sipa.be/miniscript/\n> >>> > [2] In Taproot, if you want to prevent signatures migrating to\n> another\n> >>> > branch or within a branch, you can use the CODESEPARATOR opcode\n> >>> > which was redisegned in Taproot for exactly this purpose... we\n> >>> > really did about witness malleation in its design!\n> >>>\n> >>> In Taproot the tapleaf hash is always covered by the signature (though\n> >>> not in some ANYONECANPAY proposals) so you can never migrate signatures\n> >>> between tapbranches.\n> >>>\n> >>> I had thought this was the case, but then I re-confused myself by\n> >>> reading BIP 341 .... which has much of the sighash specified, but not\n> >>> all of it! The tapleaf hash is added in BIP 342.\n> >>>\n> >>> >\n> >>> > If you want to prevent signatures from moving around *within* a\n> >>> > branch,\n> >>> >\n> >>>\n> >>> And this sentence I just meant to delete :)\n> >>>\n> >>>\n> >>> --\n> >>> Andrew Poelstra\n> >>> Director of Research, Blockstream\n> >>> Email: apoelstra at wpsoftware.net\n> >>> Web: https://www.wpsoftware.net/andrew\n> >>>\n> >>> The sun is always shining in space\n> >>> -Justin Lewis-Webster\n> >>>\n> >>> _______________________________________________\n> >>> bitcoin-dev mailing list\n> >>> bitcoin-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>>\n> >>\n> >>\n>\n> Is this something that should be fixed in bip118 signatures then?\n>\n> Cheers,\n> aj\n> --\n> Sent from my phone.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230211/40833a03/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-12T06:47:31",
                "message_text_only": "On Sat, Feb 11, 2023 at 09:40:38AM -0500, Russell O'Connor via bitcoin-dev wrote:\n> Yes.  If you would otherwise sign the tapleaf, then I would recommend also\n> signing the entire tapbranch.\n\nOpened https://github.com/bitcoin-inquisition/bitcoin/issues/19 for\nthis.\n\n(I think it's better to call it the path to the leaf, as \"tapbranch\"\nseems more to refer to each splitting step in the tree)\n\nCheers,\naj"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-07T18:12:36",
                "message_text_only": "On Tue, Feb 07, 2023 at 01:46:22PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n> Peter Todd also suggests in this thread that the use of uncompressed\n> keys can cause \"surprise\" witness inflation, but (a) since segwit\n> uncompressed keys are also banned, so keys are a fixed 33 bytes (32 in\n> Taproot)\n\nTo be clear, I was just pointing out that this problem has existed, in theory\nat least, since the beginning of Bitcoin (compressed pubkeys were supported in\nv0.1.0). P2PKH addresses are the pre-P2SH ones that start with 1.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230207/483ec009/attachment-0001.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2023-02-08T00:56:30",
                "message_text_only": "Hi Yuval,\n\n\n> Since the absolute fee amount is already committed to by the provided\n\n> (`SIGHASH_ALL`) signatures but the total transaction weight is not,\nMallory can\n\n> broadcast any valid signatures up to the maximum standard weight and\nminimum\n\n> relay fees, or in collusion with a miner, up to consensus limits.\n\n>\n\n> This effectively steals a fee from Alice et al, as their signatures do not\n\n> commit to a feerate directly or indirectly.\n\n\n>From what I understand, there are many inputs for the coinjoin transaction,\nthe latest signer provides an inflated witness downgrading the multi-party\ntransaction feerate. It doesn't sound to me a fee siphoning as occurring\nwith loose malleability [0], rather another case of transaction-relay\njamming where the adversary's goal is to slow down the confirmation of the\ntransaction to waste everyone timevalue.\n\n\nI think the issue has already been mentioned to advocate updating Core's\nmempool acceptance policy, and allows wtxid-replacement [1]. There is also\na description available here [2].\n\n\nTo mitigate, among the peer-to-peer style of mitigations, one is of course a\nreputation strategy or monetary strategy, where the asymmetries in\ncounterparties reputation are compensated with out-of-band\nfees/credentials. I don't think increasing adversary costliness is that\nefficient as there is a scaling effect (e.g the feerate of the previous\ntransaction can be used to feed N outputs for N dissociated attack\ncontexts). Signature ordering supposes also a reputation basis, and it\ndoesn't exclude giving a transaction construction edge to the reputational\ncounterparty (e.g a LSP \"promising\" a dual-funding UTXO to X distinct\nparticipant, picking up the first to yield back a signature).\n\n\nBest,\n\nAntoine\n\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-September/002796.html\n\n[1] https://github.com/bitcoin/bitcoin/pull/19645\n\n[2]\nhttps://gist.github.com/ariard/7e509bf2c81ea8049fd0c67978c521af#witness-malleability\n\nLe mar. 7 f\u00e9vr. 2023 \u00e0 02:59, Yuval Kogman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> ## Summary\n>\n> Since Taproot (more generally any kind of MAST) spends have variable size\n> which\n> depends on the path being used, the last such input to be signed in a\n> multiparty\n> transaction can always use a larger than estimated signature to unfairly\n> extract\n> a fee contribution from the other parties to the transaction (keeping the\n> absolute fees the same and reducing the feerate for the transaction).\n>\n> ## Attack Scenario\n>\n> Alice et al wish to perform a multiparty transaction, such as a CoinJoin or\n> lightning dual funding at a relatively high feerate.\n>\n> Mallory has a P2TR output with a large script spend path, e.g. an ordinal\n> inscription commitment transaction output.\n>\n> Mallory registers this coin as an input into the multiparty transaction\n> with a\n> fee obligation calculated on the basis of a key spend. When all other\n> participants have provided signatures, the script spend path can be used.\n>\n> Since the absolute fee amount is already committed to by the provided\n> (`SIGHASH_ALL`) signatures but the total transaction weight is not,\n> Mallory can\n> broadcast any valid signatures up to the maximum standard weight and\n> minimum\n> relay fees, or in collusion with a miner, up to consensus limits.\n>\n> This effectively steals a fee from Alice et al, as their signatures do not\n> commit to a feerate directly or indirectly.\n>\n> ## Mitigations\n>\n> ### RBF\n>\n> All parties could negotiate a (series of) transaction(s) ahead of time at a\n> lower feerate, giving a lower bound minimum feerate that Mallory can force.\n>\n> ### Minimum Weight Before Signing\n>\n> Enforcing a minimal weight for all non-witness data in the transaction\n> before\n> the transaction is considered fully constructed can limit the\n> effectiveness of\n> this attack, since the difference between the predicted weight and the\n> maximum\n> weight decreases.\n>\n> ### Trusted Coordinator\n>\n> In the centralized setting if BIP-322 ownership proofs are required for\n> participation and assuming the server can be trusted not to collude with\n> Mallory, the server can reject signatures that do not exercise the same\n> spend\n> path as the ownership proof, which makes the ownership proof a commitment\n> to the\n> spend weight of the input.\n>\n> ### Reputation\n>\n> Multiparty protocols with publicly verifiable protocol transcripts can be\n> provided as weak evidence of a history of honest participation in\n> multiparty\n> transactions.\n>\n> A ring signature from keys used in the transaction or its transcript\n> committing\n> to the new proposed transaction can provide weak evidence for the honesty\n> of the\n> peer.\n>\n> Such proofs are more compelling to an entity which has participated in\n> (one of)\n> the transcripts, or proximal transactions. Incentives are theoretically\n> aligned\n> if public coordinators publish these transcripts as a kind of server\n> reputation.\n>\n> ### Increasing Costliness\n>\n> A minimum feerate for the previous transaction or a minimum confirmation\n> age\n> (coindays destroyed implies time value, analogous to fidelity bonds) can be\n> required for inputs to be added, in order to make such attacks less\n> lucrative\n> (but there is still a positive payoff for the attacker).\n>\n> ### Signature Ordering\n>\n> Signatures from potentially exploitative inputs can be required ahead of\n> legacy\n> or SegWit v0 ones. The prescribed order can be determined based on\n> reputation or\n> costliness as described in the previous paragraphs.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/2fb22540/attachment-0001.html>"
            },
            {
                "author": "Yuval Kogman",
                "date": "2023-02-10T19:35:06",
                "message_text_only": "On Wed, 8 Feb 2023 at 02:56, Antoine Riard <antoine.riard at gmail.com> wrote:\n> From what I understand, there are many inputs for the coinjoin transaction, the latest signer provides an inflated witness downgrading the multi-party transaction feerate.\n\nYep!\n\n>  It doesn't sound to me a fee siphoning as occurring with loose malleability [0], rather another case of transaction-relay jamming where the adversary's goal is to slow down the confirmation of the transaction to waste everyone timevalue.\n>\n> I think the issue has already been mentioned to advocate updating Core's mempool acceptance policy, and allows wtxid-replacement [1]. There is also a description available here [2].\n\nYep, the mechanism is basically the same as witness malleability based jamming.\n\nApologies for not citing, I think I must have seen that before but\nonly remembered the pinning variants, and so did not recall it at the\ntime that I wrote this up, which I did rather hastily.\n\nHowever, I do think the adversary model should be broadened, as there\nis a potential positive externality to a party which simply wishes to\nget some witness data confirmed in a block while paying less than the\nmarket rate, without needing to assume time sensitive contracts in the\nthreat model.\n\nWhat I had in mind was the estimated witness size messages in the dual\nfunding proposal and felt they would create a false sense of\nvalidation, specifically in the context of an adversary interested in\nhaving their ordinal inscriptions being paid for by someone else by\nsubverting the a priori agreed upon feerate. From my point of view\nthis is primarily an argument for RBF by default (ideally full RBF, as\nrule 3 of BIP 125 imposes difficult constraints on multiparty\ntransaction construction) in such protocols.\n\n> I don't think increasing adversary costliness is that efficient as there is a scaling effect (e.g the feerate of the previous transaction can be used to feed N outputs for N dissociated attack contexts).\n\nYes, that doesn't make things incentive compatible but allows the\npotential victims to have clearer bounds on the potential positive\npayoff to the adversary. I think that's mainly useful in conjunction\nconstraining the order of signature submission, going from smallest to\nlargest input seems intuitively compelling but it seems to me like\nordering by feerate of creating transaction or perhaps some\ncombination of the two might provide a stronger deterrent.\n\nEither way the main takeaway in my opinion is not that this is a\nserious attack, as it's hard to exploit in theory and as far as I know\nnone of the currently deployed protocols are in any way vulnerable:\n\n1. dual funding supports RBF and quite amenable to reputation based mitigations\n2. in JoinMarket the taker can protect themselves\n3. centralized coinjoins, despite misleading claims to the contrary by\nboth vendors, currently strongly rely on a trusted server for many\nother aspects of the protocol and all three protocols are not\ncurrently exploitable as described (the attacker can't broadcast the\ntransaction with a witness that would otherwise be rejected by the\nserver)\n\n... but rather that (full) RBF is required for incentive compatible\nmultiparty transactions (or the closest approximation of incentive\ncompatibility possible barring future soft forks)."
            },
            {
                "author": "Antoine Riard",
                "date": "2023-02-15T03:33:24",
                "message_text_only": "> Apologies for not citing, I think I must have seen that before but\n> only remembered the pinning variants, and so did not recall it at the\n> time that I wrote this up, which I did rather hastily.\n\n> However, I do think the adversary model should be broadened, as there\n> is a potential positive externality to a party which simply wishes to\n> get some witness data confirmed in a block while paying less than the\n> market rate, without needing to assume time sensitive contracts in the\n> threat model.\n\n\nPlease no apologies - Message matters more than the messenger in\n\nopen-source. Yes, on the adversary model I would like to note there is a\n\npotential negative externality in the context of time-sensitive contract,\ne.g\n\nfor a DLC with short-term maturity you can delay confirmation of the funding\n\ntransaction in function of the event outcome progression (e.g a basketball\nquarters),\n\nand if the outcome turns in your defavor, you just double-spend a funding\ninput.\n\n\n> What I had in mind was the estimated witness size messages in the dual\n> funding proposal and felt they would create a false sense of\n> validation, specifically in the context of an adversary interested in\n> having their ordinal inscriptions being paid for by someone else by\n> subverting the a priori agreed upon feerate. From my point of view\n> this is primarily an argument for RBF by default (ideally full RBF, as\n> rule 3 of BIP 125 imposes difficult constraints on multiparty\n> transaction construction) in such protocols.\n\n\nWe could have miniscript embedded in the backend of a Lightning\n\nimplementation, to reject any malleable witness (maybe with some tolerance\nbounds ?),\n\nto restrain a counterparty downgrading a posteriori its feerate\ncontribution.\n\nFull rbf effectively would prevent timevalue DoS inflicted to the\nmost-utxo-value\n\ncontributor in dual-funding, however in the present flow, I don't know if it\n\nchanges something, the witness downgrading counterparty benefits from\n\na feerate discount, not lack of confirmation.\n\n\n> Yes, that doesn't make things incentive compatible but allows the\n> potential victims to have clearer bounds on the potential positive\n> payoff to the adversary. I think that's mainly useful in conjunction\n> constraining the order of signature submission, going from smallest to\n> largest input seems intuitively compelling but it seems to me like\n> ordering by feerate of creating transaction or perhaps some\n> combination of the two might provide a stronger deterrent.\n\n\nI think some combination of the two can makes sense, as if the feerate\n\nis what you paid, the input value is your \"economically subjective\"\nliquidity\n\nrisk, and as such you might pay a better signature submission place for\n\na feerate contribution increase. Quite sophisticated for the basic\ndual-funding flow.\n\n\n> Either way the main takeaway in my opinion is not that this is a\n> serious attack, as it's hard to exploit in theory and as far as I know\n> none of the currently deployed protocols are in any way vulnerable:\n\n> 1. dual funding supports RBF and quite amenable to reputation based\nmitigations\n> 2. in JoinMarket the taker can protect themselves\n> 3. centralized coinjoins, despite misleading claims to the contrary by\n> both vendors, currently strongly rely on a trusted server for many\n> other aspects of the protocol and all three protocols are not\n> currently exploitable as described (the attacker can't broadcast the\n> transaction with a witness that would otherwise be rejected by the\n> server)\n\n> ... but rather that (full) RBF is required for incentive compatible\n> multiparty transactions (or the closest approximation of incentive\n> compatibility possible barring future soft forks).\n\n\nYep yep, all types of DoS are less concerning than \"loss of funds\"\n\nseverity pinning attacks, and doesn't sounds to affect currently\n\ndeployed protocols. Still concerned all those DoS once accumulated\n\nmight be a \"practical\" show-stopper, like we have with channel jamming.\n\n\n\nLe ven. 10 f\u00e9vr. 2023 \u00e0 19:35, Yuval Kogman <nothingmuch at woobling.org> a\n\u00e9crit :\n\n> On Wed, 8 Feb 2023 at 02:56, Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n> > From what I understand, there are many inputs for the coinjoin\n> transaction, the latest signer provides an inflated witness downgrading the\n> multi-party transaction feerate.\n>\n> Yep!\n>\n> >  It doesn't sound to me a fee siphoning as occurring with loose\n> malleability [0], rather another case of transaction-relay jamming where\n> the adversary's goal is to slow down the confirmation of the transaction to\n> waste everyone timevalue.\n> >\n> > I think the issue has already been mentioned to advocate updating Core's\n> mempool acceptance policy, and allows wtxid-replacement [1]. There is also\n> a description available here [2].\n>\n> Yep, the mechanism is basically the same as witness malleability based\n> jamming.\n>\n> Apologies for not citing, I think I must have seen that before but\n> only remembered the pinning variants, and so did not recall it at the\n> time that I wrote this up, which I did rather hastily.\n>\n> However, I do think the adversary model should be broadened, as there\n> is a potential positive externality to a party which simply wishes to\n> get some witness data confirmed in a block while paying less than the\n> market rate, without needing to assume time sensitive contracts in the\n> threat model.\n>\n> What I had in mind was the estimated witness size messages in the dual\n> funding proposal and felt they would create a false sense of\n> validation, specifically in the context of an adversary interested in\n> having their ordinal inscriptions being paid for by someone else by\n> subverting the a priori agreed upon feerate. From my point of view\n> this is primarily an argument for RBF by default (ideally full RBF, as\n> rule 3 of BIP 125 imposes difficult constraints on multiparty\n> transaction construction) in such protocols.\n>\n> > I don't think increasing adversary costliness is that efficient as there\n> is a scaling effect (e.g the feerate of the previous transaction can be\n> used to feed N outputs for N dissociated attack contexts).\n>\n> Yes, that doesn't make things incentive compatible but allows the\n> potential victims to have clearer bounds on the potential positive\n> payoff to the adversary. I think that's mainly useful in conjunction\n> constraining the order of signature submission, going from smallest to\n> largest input seems intuitively compelling but it seems to me like\n> ordering by feerate of creating transaction or perhaps some\n> combination of the two might provide a stronger deterrent.\n>\n> Either way the main takeaway in my opinion is not that this is a\n> serious attack, as it's hard to exploit in theory and as far as I know\n> none of the currently deployed protocols are in any way vulnerable:\n>\n> 1. dual funding supports RBF and quite amenable to reputation based\n> mitigations\n> 2. in JoinMarket the taker can protect themselves\n> 3. centralized coinjoins, despite misleading claims to the contrary by\n> both vendors, currently strongly rely on a trusted server for many\n> other aspects of the protocol and all three protocols are not\n> currently exploitable as described (the attacker can't broadcast the\n> transaction with a witness that would otherwise be rejected by the\n> server)\n>\n> ... but rather that (full) RBF is required for incentive compatible\n> multiparty transactions (or the closest approximation of incentive\n> compatibility possible barring future soft forks).\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/d24c50a6/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Unenforceable fee obligations in multiparty protocols with Taproot inputs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Michael Folkson",
                "Antoine Riard",
                "Anthony Towns",
                "Yuval Kogman",
                "Lloyd Fournier",
                "Peter Todd",
                "Nadav Ivgi",
                "Andrew Poelstra",
                "Russell O'Connor"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 59089
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Contracting Primitives WG 4rd Meeting, Tuesday 21 Feb. 18:00 UTC",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2023-02-08T01:59:59",
                "message_text_only": "Hi list,\n\nI'm proposing Tuesday 21st February at 18:00, i.e 2 weeks from now for the\n4th Bitcoin contracting primitives WG meeting (the third Tuesday of\nFebruary month, as done previously).\n\nAs mentioned during the previous session, there is an issue if anyone would\nlike to propose an agenda topic in advance in an open fashion:\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34\n\nI would like to propose 2 topics for this upcoming meeting.\n\nFirstly, ANYPREVOUT / \"Eltoo\", there has been a work in progress during the\nlast year for eltoo lightning channels [0]. I think there are still few\nhigh-level open questions around fee-bumping and watchtowers, how the\nproposal would benefit other off-chain constructions, how the proposal\nworks compared to other update mechanisms and a bunch of other things.\n\nSecondly, if there is sufficient interest, setting up an open meatspace\nevent during S2 2023 or S1 2024. Meatspace events can be a great thing to\naccelerate the development pace of contracting protocols. From my\nexperience in-person whiteboard sessions are highly valuable to sync on\ncomplex subjects and it has been already evoked in the context of this\ncommunity process. Ideally, the event would piggyback on some existing\nbitcoin conference. And I would see this as complementary to the other\nbitcoin engineering meetings we've already scheduled, just open contracting\nprimitives R&D to a large set of people beyond the usual crowd contributing\nalready to Bitcoin Core [1].\n\nIf we have time remaining, we could listen to everyone blockers in their\ncontracting primitives/covenant research.\n\nCommunication venue is #bitcoin-contracting-primitives-wg on Libera Chat\nIRC. Logs of the previous session are available here [2].\n\nIf you have any questions or feedback, I'm staying responsive.\n\nCheers,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003788.html\n[1] In term of janitorial role decentralization, I think it would be\nvaluable to have the event organization carried on by someone else reliable\nother than myself. Contributed to CoreDev Zurich 2021 organisation, so I\ncan share the operational practices.\n[2]\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-17-01.md\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230208/bccc5f33/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2023-02-21T00:40:48",
                "message_text_only": "Reminder: this is happening this _upcoming_ Tuesday.\n\nLooking forward to the fourth session to roam over things like anyprevout,\nthe annex, vault primitive, annexcarrier!\n\nIssue opened if anyone would like to propose an agenda topic:\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34\n\nBest,\nAntoine\n\nLe mer. 8 f\u00e9vr. 2023 \u00e0 01:59, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Hi list,\n>\n> I'm proposing Tuesday 21st February at 18:00, i.e 2 weeks from now for the\n> 4th Bitcoin contracting primitives WG meeting (the third Tuesday of\n> February month, as done previously).\n>\n> As mentioned during the previous session, there is an issue if anyone\n> would like to propose an agenda topic in advance in an open fashion:\n> https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/34\n>\n> I would like to propose 2 topics for this upcoming meeting.\n>\n> Firstly, ANYPREVOUT / \"Eltoo\", there has been a work in progress during\n> the last year for eltoo lightning channels [0]. I think there are still few\n> high-level open questions around fee-bumping and watchtowers, how the\n> proposal would benefit other off-chain constructions, how the proposal\n> works compared to other update mechanisms and a bunch of other things.\n>\n> Secondly, if there is sufficient interest, setting up an open meatspace\n> event during S2 2023 or S1 2024. Meatspace events can be a great thing to\n> accelerate the development pace of contracting protocols. From my\n> experience in-person whiteboard sessions are highly valuable to sync on\n> complex subjects and it has been already evoked in the context of this\n> community process. Ideally, the event would piggyback on some existing\n> bitcoin conference. And I would see this as complementary to the other\n> bitcoin engineering meetings we've already scheduled, just open contracting\n> primitives R&D to a large set of people beyond the usual crowd contributing\n> already to Bitcoin Core [1].\n>\n> If we have time remaining, we could listen to everyone blockers in their\n> contracting primitives/covenant research.\n>\n> Communication venue is #bitcoin-contracting-primitives-wg on Libera Chat\n> IRC. Logs of the previous session are available here [2].\n>\n> If you have any questions or feedback, I'm staying responsive.\n>\n> Cheers,\n> Antoine\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003788.html\n> [1] In term of janitorial role decentralization, I think it would be\n> valuable to have the event organization carried on by someone else reliable\n> other than myself. Contributed to CoreDev Zurich 2021 organisation, so I\n> can share the operational practices.\n> [2]\n> https://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-17-01.md\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230221/c113d883/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Contracting Primitives WG 4rd Meeting, Tuesday 21 Feb. 18:00 UTC",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5412
        }
    },
    {
        "title": "[bitcoin-dev] Testing censorship resistance of bitcoin p2p network",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2023-02-13T12:34:30",
                "message_text_only": "Hi Bitcoin Developers,\n\nThere is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: \"I disapprove of what you say, but I will defend to the death your right to say it.\" I'm curious to know how many Bitcoin developers share this sentiment.\n\nRecently there was a lot of enthusiasm on social media to run bitcoin core with a [patch][0] that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?\n\nI understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.\n\n- Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers. \n- I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.\n\nWhat would an ideal tool for testing censorship resistance look like?\n\n- Allows user to construct different types of transactions that might be considered \"bad\" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.\n- Option to broadcast transaction to specific nodes\n- Verify if the transaction was relayed successfully or rejected\n- Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners\n\nThere was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.\n\n[0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831\n[1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf\n[2]: https://twitter.com/1440000bytes/status/1574225052240777216\n[3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/\n[4]: https://twitter.com/jamesob/status/1623827708168863747\n\n/dev/fd0\nfloppy disc guy\n\nSent with Proton Mail secure email."
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2023-02-17T14:56:31",
                "message_text_only": "> [0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831\n\nI wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because \"OP_FALSE OP_IF <anything> OP_ENDIF\" is effectively the same as \"OP_NOP\", and putting NOPs in many places is considered non-standard. The same is true for \"OP_TRUE OP_NOTIF <anything> OP_ENDIF\", and also there are many variants, where someone could use \"OP_FALSE OP_NOT\" instead of \"OP_TRUE\", or check if \"2+2==4\" by using \"OP_2 OP_2 OP_ADD OP_4 OP_EQUAL\" (instead of putting \"OP_TRUE\").\n\nThere are endless combinations, and even if there will be a rule to evaluate constant values on the input stack, and put OP_NOP, where any non-empty set of opcodes will evaluate into nothing, then still, there are ways to include spam on-chain. So, the question is: how strict should those rules be?\n\n> \"I disapprove of what you say, but I will defend to the death your right to say it.\"\n\nYes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).\n\nWhen it comes to the solution, I think a commitment to a signature should handle all cases. In this way, it can be done for any address type that can support OP_CHECKSIG. To validate such commitment, all that is needed, is converting R-value of a signature into the Taproot address, and then checking if a given commitment matches such key.\n\n> I agree with Peter that, given that users have found ways to store arbitrary amounts of data on-chain if they really want, we might as well just make OP_RETURN a free-for-all.\n\nI think we should go in the opposite direction. Using OP_RETURN means that all nodes will store such data. Using witness means that only witness nodes will keep that. So, if it is already possible to have a node that cannot see witness data, and still remain in the network, I think commitments should be stored only by nodes that will enable them explicitly. So, from that point of view, commitment is \"a witness of a signature\", it is additional information that can be skipped if needed.\n\nOn 2023-02-13 14:08:21 user alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Hi Bitcoin Developers,\n\nThere is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: \"I disapprove of what you say, but I will defend to the death your right to say it.\" I'm curious to know how many Bitcoin developers share this sentiment.\n\nRecently there was a lot of enthusiasm on social media to run bitcoin core with a [patch][0] that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?\n\nI understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.\n\n- Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers. \n- I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.\n\nWhat would an ideal tool for testing censorship resistance look like?\n\n- Allows user to construct different types of transactions that might be considered \"bad\" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.\n- Option to broadcast transaction to specific nodes\n- Verify if the transaction was relayed successfully or rejected\n- Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners\n\nThere was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.\n\n[0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831\n[1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf\n[2]: https://twitter.com/1440000bytes/status/1574225052240777216\n[3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/\n[4]: https://twitter.com/jamesob/status/1623827708168863747\n\n/dev/fd0\nfloppy disc guy\n\nSent with Proton Mail secure email.\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-17T23:35:34",
                "message_text_only": "On Fri, Feb 17, 2023 at 03:56:31PM +0100, vjudeu via bitcoin-dev wrote:\n> > [0]: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831\n> \n> I wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because \"OP_FALSE OP_IF <anything> OP_ENDIF\" is effectively the same as \"OP_NOP\", and putting NOPs in many places is considered non-standard. The same is true for \"OP_TRUE OP_NOTIF <anything> OP_ENDIF\", and also there are many variants, where someone could use \"OP_FALSE OP_NOT\" instead of \"OP_TRUE\", or check if \"2+2==4\" by using \"OP_2 OP_2 OP_ADD OP_4 OP_EQUAL\" (instead of putting \"OP_TRUE\").\n>\n\nIf you ban any of these specific script fragments then spammers will\njust use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.\nAnd banning *this* would ban legitimate use cases.\n\nYou could try statically analyze `<anything>` to determine whether the\nIF branch could ever be taken. For example there is no path through\nthe \"inscription script\" that would result in all the crap being dropped\nby the end of the script, violating the CLEANSTACK rule.\n\nThis sort of filtering, assuming it could be reliably and efficiently\ndone, would at least force inscription scripts to be \"plausible\", and\nwould greatly increase their space cost by e.g. requiring OP_DROP to be\nadded somewhere hundreds of times.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/c02a60b1/attachment-0001.sig>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-17T23:39:11",
                "message_text_only": "On Fri, Feb 17, 2023 at 11:35:34PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n> \n> If you ban any of these specific script fragments then spammers will\n> just use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.\n> And banning *this* would ban legitimate use cases.\n>\n\nI realize this is confusingly worded. I mean, they'd provide the `FALSE`\nas a separate witness element rather than being part of the witnessScript.\n\n\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230217/ac844572/attachment.sig>"
            },
            {
                "author": "vjudeu at gazeta.pl",
                "date": "2023-02-18T09:48:02",
                "message_text_only": "> By standardness rules (where you can have up to 80-byte pushes), a little over 1%. By consensus (520-byte pushes) less than 0.2%.\n\nNote that instead of \"OP_DROP OP_DROP\", people can use \"OP_2DROP\", so the number of dropping opcodes could be halved.\n\n> I mean, they'd provide the `FALSE` as a separate witness element rather than being part of the witnessScript.\n\nThat means people can still reject an official alternative (for example commitments), so a different approach is needed to fight that spam. Assuming that transactions will be sent directly to the miners, they will be included, that way or another. So, the solution should assume that we will have large NOPs in the chain. And then, if we want to deal with them, some kind of pruning is needed. Switching from witness to non-witness node is not an option, because it would require additional witness validation, and because rules for OP_RETURN can be also lifted.\n\nSo, how to prune the Script? In a typical hash function, like SHA-256, data are splitted into smaller chunks, and then processed linearly. I think it is possible to store the first and the last chunk, and keep the internal state of SHA-256, before entering the last chunk. In this way, it should be possible to prune those OP_NOPs. Because that solution will also cover raw scripts (people can switch to them if witness will be more restricted than now).\n\nAlso, it gives us a hint, that if any Script upgrade will be considered in the future, we can think about doing it in a way, where unused parts can be pruned, without invalidating signatures.\n\nOn 2023-02-18 00:39:16 user Andrew Poelstra <apoelstra at wpsoftware.net> wrote:\n> On Fri, Feb 17, 2023 at 11:35:34PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n> \n> If you ban any of these specific script fragments then spammers will\n> just use `IF <anything> ENDIF` and provide the `FALSE` as a zero push.\n> And banning *this* would ban legitimate use cases.\n>\n\nI realize this is confusingly worded. I mean, they'd provide the `FALSE`\nas a separate witness element rather than being part of the witnessScript.\n\n\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-18T18:03:45",
                "message_text_only": "On Sat, Feb 18, 2023 at 5:11 AM vjudeu via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Also, it gives us a hint, that if any Script upgrade will be considered in\n> the future, we can think about doing it in a way, where unused parts can be\n> pruned, without invalidating signatures.\n>\n\nFWIW, pruning unused case branches is a core design principle of the\nSimplicity language I am developing.\n\nThat being said, even this is not enough to thwart agents that specifically\ndesire to post unused data blobs as part of their programs.  This is\nlargely because there are many mathematical expressions for what is\nequivalently an identity function.  Think computing (x ^ 257) mod 257 (see\nFermat's little theorem).\n\nEven in Simplicity users can write Word *<some data blob>*; unit which is\nroughly equivalent PUSH *<data blob>* DROP in Script.  I don't even bother\ntrying to prevent it.  Doing so just adds more consensus complexity, and\nonly raises the bar slightly on how to work around it.\n\nSimplicity's pruning is instead meant as a way to (usually) lower costs for\nusers who aren't actively trying to spam the network.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230218/2db79aa2/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-18T00:03:15",
                "message_text_only": "On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev \n>You could try statically analyze `<anything>` to determine whether the\n>IF branch could ever be taken. For example there is no path through\n>the \"inscription script\" that would result in all the crap being dropped\n>by the end of the script, violating the CLEANSTACK rule.\n>\n>This sort of filtering, assuming it could be reliably and efficiently\n>done, would at least force inscription scripts to be \"plausible\", and\n>would greatly increase their space cost by e.g. requiring OP_DROP to be\n>added somewhere hundreds of times.\n\n\"greatly increase their space cost\"?\n\nTell me, what is the actual % increase to adding OP_DROPs like you propose?"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-18T01:28:38",
                "message_text_only": "On Sat, Feb 18, 2023 at 02:03:15AM +0200, Peter Todd wrote:\n> On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev \n> >You could try statically analyze `<anything>` to determine whether the\n> >IF branch could ever be taken. For example there is no path through\n> >the \"inscription script\" that would result in all the crap being dropped\n> >by the end of the script, violating the CLEANSTACK rule.\n> >\n> >This sort of filtering, assuming it could be reliably and efficiently\n> >done, would at least force inscription scripts to be \"plausible\", and\n> >would greatly increase their space cost by e.g. requiring OP_DROP to be\n> >added somewhere hundreds of times.\n> \n> \"greatly increase their space cost\"?\n> \n> Tell me, what is the actual % increase to adding OP_DROPs like you propose?\n>\n\nBy standardness rules (where you can have up to 80-byte pushes), a\nlittle over 1%. By consensus (520-byte pushes) less than 0.2%.\n\nPerhaps \"greatly increase\" is a stretch :) but if the fee market is\nfunctioning and we're talking about large amounts of data, it's not\ntrivial either.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230218/dcd75895/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-22T16:39:04",
                "message_text_only": "On Sat, Feb 18, 2023 at 01:28:38AM +0000, Andrew Poelstra wrote:\n> On Sat, Feb 18, 2023 at 02:03:15AM +0200, Peter Todd wrote:\n> > On February 18, 2023 1:35:34 AM GMT+02:00, Andrew Poelstra via bitcoin-dev \n> > >You could try statically analyze `<anything>` to determine whether the\n> > >IF branch could ever be taken. For example there is no path through\n> > >the \"inscription script\" that would result in all the crap being dropped\n> > >by the end of the script, violating the CLEANSTACK rule.\n> > >\n> > >This sort of filtering, assuming it could be reliably and efficiently\n> > >done, would at least force inscription scripts to be \"plausible\", and\n> > >would greatly increase their space cost by e.g. requiring OP_DROP to be\n> > >added somewhere hundreds of times.\n> > \n> > \"greatly increase their space cost\"?\n> > \n> > Tell me, what is the actual % increase to adding OP_DROPs like you propose?\n> >\n> \n> By standardness rules (where you can have up to 80-byte pushes), a\n> little over 1%. By consensus (520-byte pushes) less than 0.2%.\n> \n> Perhaps \"greatly increase\" is a stretch :) but if the fee market is\n> functioning and we're talking about large amounts of data, it's not\n> trivial either.\n\nI would definitely call ~1% trivial. Fees vary more by that on an hour to hour\nbasis.\n\nAnyway, it goes to show that protocols relying on data embedded in Bitcoin\ntransactions would do well to have flexible encoding rules, eg by considering\nall PUSHDATA's with certain characteristics to be data, so that encoders can be\nadapted on the fly if there are any censorship issues. It's also useful if the\nrules allow data to be encoded in UTXO outputs, so that censorship of witness\ndata always risks people switching to filling up the UTXO set. A kind of\nMutually Assured Destruction threat in a way.\n\nFWIW, OpenTimestamps was deliberately designed to have this property. So don't\nmess with it. :D\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/4d5cfae9/attachment.sig>"
            },
            {
                "author": "alicexbt",
                "date": "2023-02-19T00:33:11",
                "message_text_only": "Hi vjudeu,\n\nBefore I respond to your email, I would like to share the [python script][0] that could be used to do 3 things:\n\n1) List peers\n2) Broadcast a transaction to peers and see if it was relayed\n3) Ban peers that did not relay your transaction\n\nThe primary goal of this script is testing however it can be used by anyone as it does not make sense to waste resources connecting to peers that do not relay your transactions. There is another [solution][1] for users to ensure all transactions get relayed properly.\n\nNote: There could be some false positives and it mainly uses libbtc\n\n> Yes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).\n\nWhy do you think people don't stop and willing to pay for inscribing something on-chain although it could be done for free using BitTorrent? As far as 'spam' is concerned these are bitcoin transactions until you open ordinals explorer or believe in ordinals theory to track the ownership of inscription. There are some bitcoin transactions that I could consider spam and have no interest in keeping them on my disk. However I believe people should be free to do anything with their money and I don't care about the content or intent of any bitcoin transaction as long as its valid, paid fee etc. (except vulnerability) Blocks cannot exceed their limit and I was prepared for a fee market with new limits since segwit got activated.\n\nHere's my opinion why people don't stop doing it and we could always disagree:\n\nMoney or financial transactions have been done differently in countries, cultures, communities etc. across the world. People have done inscriptions on paper money issued by governments for graffiti, political, personal or other reasons. Since years inscriptions have been on different types of [coins][2]. Example: Jahangir issued many gold and silver [coins with poetic verses][3] on them and was the only Mughal emperor to bestow the right of coinage to his royal consort.\n\nSome positives of inscriptions that I have observed in last couple of weeks:\n\n- More users interested in running full nodes (non-pruned) and trying bitcoin wallets, lightning etc.\n- Taproot usage increased\n- More developers interested in learning bitcoin development and looking for libraries, docs etc.\n- Demand for block space has increased\n- ~50 BTC paid in fees to miners for creating inscriptions until now\n\nIt creates more opportunities for bitcoin developers and everyone involved in bitcoin.\n\n[0]: https://ordinals.com/content/f39b5f0a9e9af05da03ab0c52a407972b9678e8db80160febd6bd899acebe141i0\n[1]: https://github.com/casey/ord/pull/1783\n[2]: https://en.wikipedia.org/wiki/Coinage_of_India\n[3]: https://web.archive.org/web/20180705070913/https://www.mintageworld.com/blog/coins-of-jahangir/\n\n\n/dev/fd0\nfloppy disk guy\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Friday, February 17th, 2023 at 8:26 PM, vjudeu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> \n> I wonder how far should that rule go: SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS. Because \"OP_FALSE OP_IF <anything> OP_ENDIF\" is effectively the same as \"OP_NOP\", and putting NOPs in many places is considered non-standard. The same is true for \"OP_TRUE OP_NOTIF <anything> OP_ENDIF\", and also there are many variants, where someone could use \"OP_FALSE OP_NOT\" instead of \"OP_TRUE\", or check if \"2+2==4\" by using \"OP_2 OP_2 OP_ADD OP_4 OP_EQUAL\" (instead of putting \"OP_TRUE\").\n> \n> \n> There are endless combinations, and even if there will be a rule to evaluate constant values on the input stack, and put OP_NOP, where any non-empty set of opcodes will evaluate into nothing, then still, there are ways to include spam on-chain. So, the question is: how strict should those rules be?\n> \n> > \"I disapprove of what you say, but I will defend to the death your right to say it.\"\n> \n> \n> Yes, I disapprove spamming the blockchain. But because people will rather die than stop it, creating some kind of official alternative is needed. I think most of the time it is not needed to store that data on-chain, all that is needed, is just proving they existed, and that they are connected to a certain transaction (so, it is about timestamping, not about storage).\n> \n> When it comes to the solution, I think a commitment to a signature should handle all cases. In this way, it can be done for any address type that can support OP_CHECKSIG. To validate such commitment, all that is needed, is converting R-value of a signature into the Taproot address, and then checking if a given commitment matches such key.\n> \n> > I agree with Peter that, given that users have found ways to store arbitrary amounts of data on-chain if they really want, we might as well just make OP_RETURN a free-for-all.\n> \n> \n> I think we should go in the opposite direction. Using OP_RETURN means that all nodes will store such data. Using witness means that only witness nodes will keep that. So, if it is already possible to have a node that cannot see witness data, and still remain in the network, I think commitments should be stored only by nodes that will enable them explicitly. So, from that point of view, commitment is \"a witness of a signature\", it is additional information that can be skipped if needed.\n> \n> On 2023-02-13 14:08:21 user alicexbt via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> \n> > Hi Bitcoin Developers,\n> \n> \n> There is a famous quote attributed to Evelyn Beatrice Hall in her biography of Voltaire: \"I disapprove of what you say, but I will defend to the death your right to say it.\" I'm curious to know how many Bitcoin developers share this sentiment.\n> \n> Recently there was a lot of enthusiasm on social media to run bitcoin core with a patch that would reject some transactions in mempool. Bitcoin Knots already has an option to reject transactions that reuse addresses. What if such practices become common and some projects that provide easy to use node software start censoring transactions? How would government agencies take advantage of this whole drama?\n> \n> I understand it is difficult to censor different type of transaction because there will be some nodes relaying them and miners including in blocks. It is still important to discuss this and different ways to test censorship resistance.\n> \n> - Peter Todd had written a [blog post][1] in which counting number of INVs (step 5,6,7 and 8) helps in testing if your transactions are getting relayed by the connected peers.\n> - I had tried broadcasting transaction to specific nodes using [libbtc][2]. Based on my understanding it uses GETDATA to confirm your transaction was seen on other nodes after broadcasting.\n> \n> What would an ideal tool for testing censorship resistance look like?\n> \n> - Allows user to construct different types of transactions that might be considered \"bad\" by some people. Example: OFAC address in output, Inscription, OP_RETURN, Address reuse etc.\n> - Option to broadcast transaction to specific nodes\n> - Verify if the transaction was relayed successfully or rejected\n> - Ban such peers using [setban][3] RPC as it would increase the probability of tx getting propagated to miners\n> \n> There was even some discussion about an [external mempool][4] that could be used for non-standard transactions. It could also help in avoiding censorship in some cases. I welcome your thoughts and feedback on this topic.\n> \n> 0: https://gist.github.com/luke-jr/4c022839584020444915c84bdd825831\n> [1]: https://petertodd.org/2022/bitcoin-core-nodes-running-fullrbf\n> [2]: https://twitter.com/1440000bytes/status/1574225052240777216\n> [3]: https://bitcoincore.org/en/doc/24.0.0/rpc/network/setban/\n> [4]: https://twitter.com/jamesob/status/1623827708168863747\n> \n> /dev/fd0\n> floppy disc guy\n> \n> Sent with Proton Mail secure email.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Testing censorship resistance of bitcoin p2p network",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Andrew Poelstra",
                "vjudeu at gazeta.pl",
                "alicexbt",
                "Russell O'Connor"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 26644
        }
    },
    {
        "title": "[bitcoin-dev] BIP for OP_VAULT",
        "thread_messages": [
            {
                "author": "James O'Beirne",
                "date": "2023-02-13T21:09:29",
                "message_text_only": "Since the last related correspondence on this list [0], a number of\nimprovements have been made to the OP_VAULT draft [1]:\n\n* There is no longer a hard dependence on package relay/ephemeral\n  anchors for fee management. When using \"authorized recovery,\" all\n  vault-related transactions can be bundled with unrelated inputs and\n  outputs, facilitating fee management that is self contained to the\n  transaction. Consequently, the contents of this proposal are in theory\n  usable today.\n\n* Specific output locations are no longer hardcoded in any of the\n  transaction validation algorithms. This means that the proposal is now\n  compatible with future changes like SIGHASH_GROUP, and\n  transaction shapes for vault operations are more flexible.\n\n---\n\nI've written a BIP that fully describes the proposal here:\n\n\nhttps://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki\n\nThe corresponding PR is here:\n\n  https://github.com/bitcoin/bips/pull/1421\n\nMy next steps will be to try for a merge to the inquisition repo.\n\nThanks to everyone who has participated so far, but especially to AJ and\nGreg for all the advice.\n\nJames\n\n[0]:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html\n[1]: https://github.com/bitcoin/bitcoin/pull/26857\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230213/d2e99148/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP for OP_VAULT",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "James O'Beirne"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1460
        }
    },
    {
        "title": "[bitcoin-dev] About the Japanese list defined in BIP39",
        "thread_messages": [
            {
                "author": "XEM Book",
                "date": "2023-02-15T14:08:22",
                "message_text_only": "Hi , I am XEMBook.\nnice to meet you.\n\nThe Japanese language list currently defined in BIP39 is not consistent or\nuniform, and includes insults to a person's appearance.\n\n\u305c\u3093\u3089 \u3067\u306c\u304b\u3048 \u3058\u3083\u307e \u3072\u308d\u3086\u304d \u3061\u3057\u308a\u3087\u3046\n\u3067\u3063\u3071 \u3069\u3076\u304c\u308f \u306d\u304f\u3089 \u306d\u3053\u305c \u3071\u3093\u3064 \u3077\u3046\u305f\u308d\u3046\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0039/japanese.txt\n\nHere I would like to make a suggestion about a new Japanese word list.\n\nhttps://github.com/xembook/bips/blob/master/bip-0039/japanese_seasonal.txt\n\nThese beautiful words are from the Saijiki.\nThe Saijiki is said to have originated in the \"Nihon Saijiki\" (Japanese\nchronicle of the seasons) by Ekiken Kaibara in 1688 (Jokyo 5), published by\nKyoto Nisshindo.\nThis is a word list with over 300 years of history on word choice.\n\nPlease consider including this word list Japanese Seasonal in BIP39.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/b61e8eb8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "About the Japanese list defined in BIP39",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "XEM Book"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 965
        }
    },
    {
        "title": "[bitcoin-dev]  bitcoin-inquistion 24.0",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2023-02-16T00:34:26",
                "message_text_only": "Hi *,\n \nBitcoin Inquisition 24.0 is tagged with guix builds available:\n \n  https://github.com/bitcoin-inquisition/bitcoin/releases/tag/inq-v24.0\n\nIt includes support for BIP 118 (ANYPREVOUT) and BIP 119\n(CHECKTEMPLATEVERIFY) on regtest and signet.\n\nThe main change since 23.0 is simply the rebase on top of Bitcoin Core\n24.0, though the patchsets for both BIPs have been tightened up a little\nas well.\n\nAdditional soft forks or relay policy changes may be proposed by filing\na pull request, and work in progress is tracked on a project board:\n\n  https://github.com/bitcoin-inquisition/bitcoin/pulls?q=is%3Apr\n  https://github.com/orgs/bitcoin-inquisition/projects/2/views/1\n\nFor more background, the 23.0 announcement may be worth reading:\n\n  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-December/021275.html\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-inquistion 24.0",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 836
        }
    },
    {
        "title": "[bitcoin-dev] Codex32",
        "thread_messages": [
            {
                "author": "Russell O'Connor",
                "date": "2023-02-16T02:16:02",
                "message_text_only": "I've been asked by Dr. Curr and Professor Snead to forward this message to\nthis mailing list, as it may be of general interest to Bitcoin users.\n\nDear Colleague:\n\nIn 1967, during excavation for the construction of a new shopping center in\nMonroeville, Pennsylvania, workers uncovered a vault containing a cache of\nancient scrolls[1].  Most were severely damaged, but those that could be\nrecovered confirmed the existence of a secret society long suspected to\nhave\nbeen active in the region around the year 200 BC.\n\nBased on a translation of these documents, we now know that the society,\nthe\nCult of the Bound Variable, was devoted to the careful study of\ncomputation,\nover two millennia before the invention of the digital computer.\n\nWhile the Monroeville scrolls make reference to computing machines made of\nsandstone, most researchers believed this to be a poetic metaphor and that\nthe\n\"computers\" were in fact the initiates themselves, carrying out the\nunimaginably tedious steps of their computations with reed pens on\nparchment.\n\nWithin the vault, a collection of sandstone wheels marked in a language\nconsisting of 32 glyphs was found. After 15 years of study, we have\nsuccessfully\ncompleted the translation of what is known as \"Codex32,\" a document that\ndescribes the functions of the wheels. It was discovered that the wheels\noperate\na system of cryptographic computations that was used by cult members to\nsafeguard their most valuable secrets.\n\nThe Codex32 system allows secrets to be carved into multiple tablets and\nscattered to the far corners of the earth. When a sufficient number of\ntablets are\nbrought together the stone wheels are manipulated in a manner to recover the\nsecrets. This finding may be of particular interest to the Bitcoin\ncommunity.\n\nBelow we provide a summary of the cult's secret sharing system, which is\ngraciously hosted at\n<\nhttps://github.com/apoelstra/bips/blob/2023-02--volvelles/bip-0000.mediawiki\n>.\nWe are requesting a record assignment in the Bibliography of Immemorial\nPhilosophy (BIP) repository.\n\nThank you for your consideration.\n\nDr. Leon O. Curr and Professor Pearlwort Snead\nDepartment of Archaeocryptography\nHarry Q. Bovik Institute for the Advancement\n\n[1] http://www.boundvariable.org/task.shtml\n\n-----BEGIN BIP-----\n\n<pre>\n  BIP: ????\n  Layer: Applications\n  Title: codex32\n  Author: Leon Olsson Curr and Pearlwort Sneed <pearlwort at wpsoftware.net>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n  Status: Draft\n  Type: ????\n  Created: 2023-02-13\n  License: BSD-3-Clause\n  Post-History: FIXME\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document describes a standard for backing up and restoring the master\nseed of a\n[https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032]\nhierarchical deterministic wallet, using Shamir's secret sharing.\nIt includes an encoding format, a BCH error-correcting checksum, and\nalgorithms for share generation and secret recovery.\nSecret data can be split into up to 31 shares.\nA minimum threshold of shares, which can be between 1 and 9, is needed to\nrecover the secret, whereas without sufficient shares, no information about\nthe secret is recoverable.\n\n===Copyright===\n\nThis document is licensed under the 3-clause BSD license.\n\n===Motivation===\n\nBIP-0032 master seed data is the source entropy used to derive all private\nkeys in an HD wallet.\nSafely storing this secret data is the hardest and most important part of\nself-custody.\nHowever, there is a tension between security, which demands limiting the\nnumber of backups, and resilience, which demands widely replicated backups.\nEncrypting the seed does not change this fundamental tradeoff, since it\nleaves essentially the same problem of how to back up the encryption key(s).\n\nTo allow users freedom to make this tradeoff, we use Shamir's secret\nsharing, which guarantees that any number of shares less than the threshold\nleaks no information about the secret.\nThis approach allows increasing safety by widely distributing the generated\nshares, while also providing security against the compromise of one or more\nshares (as long as fewer than the threshold have been compromised).\n\n[https://github.com/satoshilabs/slips/blob/master/slip-0039.md SLIP-0039]\nhas essentially the same motivations as this standard.\nHowever, unlike SLIP-0039, this standard also aims to be simple enough for\nhand computation.\nUsers who demand a higher level of security for particular secrets, or have\na general distrust in digital electronic devices, have the option of using\nhand computation to backup and restore secret data in an interoperable\nmanner.\nNote that hand computation is optional, the particular details of hand\ncomputation are outside the scope of this standard, and implementers do not\nneed to be concerned with this possibility.\n\n[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039]\nserves the same purpose as this standard: encoding master seeds for storage\nby users.\nHowever, BIP-0039 has no error-correcting ability, cannot sensibly be\nextended to support secret sharing, has no support for versioning or other\nmetadata, and has many technical design decisions that make implementation\nand interoperability difficult (for example, the use of SHA-512 to derive\nseeds, or the use of 11-bit words).\n\n==Specification==\n\n===codex32===\n\nA codex32 string is similar to a Bech32 string defined in [\nhttps://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173].\nIt reuses the base32 character set from BIP-0173, and consists of:\n\n* A human-readable part, which is the string \"ms\" (or \"MS\").\n* A separator, which is always \"1\".\n* A data part which is in turn subdivided into:\n** A threshold parameter, which MUST be a single digit between \"2\" and \"9\",\nor the digit \"0\".\n*** If the threshold parameter is \"0\" then the share index, defined below,\nMUST have a value of \"s\" (or \"S\").\n** An identifier consisting of 4 Bech32 characters.\n** A share index, which is any Bech32 character. Note that a share index\nvalue of \"s\" (or \"S\") is special and denotes the unshared secret (see\nsection \"Unshared Secret\").\n** A payload which is a sequence of up to 74 Bech32 characters. (However,\nsee '''Long codex32 Strings''' below for an exception to this limit.)\n** A checksum which consists of 13 Bech32 characters as described below.\n\nAs with Bech32 strings, a codex32 string MUST be entirely uppercase or\nentirely lowercase.\nThe lowercase form is used when determining a character's value for\nchecksum purposes.\nFor presentation, lowercase is usually preferable, but uppercase SHOULD be\nused for handwritten codex32 strings.\n\n===Checksum===\n\nThe last thirteen characters of the data part form a checksum and contain\nno information.\nValid strings MUST pass the criteria for validity specified by the Python3\ncode snippet below.\nThe function <code>ms32_verify_checksum</code> must return true when its\nargument is the data part as a list of integers representing the characters\nconverted using the bech32 character table from BIP-0173.\n\nTo construct a valid checksum given the data-part characters (excluding the\nchecksum), the <code>ms32_create_checksum</code> function can be used.\n\n<source lang=\"python\">\nMS32_CONST = 0x10ce0795c2fd1e62a\n\ndef ms32_polymod(values):\n    GEN = [\n        0x19dc500ce73fde210,\n        0x1bfae00def77fe529,\n        0x1fbd920fffe7bee52,\n        0x1739640bdeee3fdad,\n        0x07729a039cfc75f5a,\n    ]\n    residue = 0x23181b3\n    for v in values:\n        b = (residue >> 60)\n        residue = (residue & 0x0fffffffffffffff) << 5 ^ v\n        for i in range(5):\n            residue ^= GEN[i] if ((b >> i) & 1) else 0\n    return residue\n\ndef ms32_verify_checksum(data):\n    if len(data) >= 96:                      # See Long codex32 Strings\n        return ms32_verify_long_checksum(data)\n    if len(data) <= 93:\n        return ms32_polymod(data) == MS32_CONST\n    return False\n\ndef ms32_create_checksum(data):\n    if len(data) > 80:                       # See Long codex32 Strings\n        return ms32_create_long_checksum(data)\n    values = data\n    polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST\n    return [(polymod >> 5 * (12 - i)) & 31 for i in range(13)]\n</source>\n\n===Error Correction===\n\nA codex32 string without a valid checksum MUST NOT be used.\nThe checksum is designed to be an error correcting code that can correct up\nto 4 character substitutions, up to 8 unreadable characters (called\nerasures), or up to 13 consecutive erasures.\nImplementations SHOULD provide the user with a corrected valid codex32\nstring if possible.\nHowever, implementations SHOULD NOT automatically proceed with a corrected\ncodex32 string without user confirmation of the corrected string, either by\nprompting the user, or returning a corrected string in an error message and\nallowing the user to repeat their action.\nWe do not specify how an implementation should implement error correction.\nHowever, we recommend that:\n\n* Implementations make suggestions to substitute non-bech32 characters with\nbech32 characters in some situations, such as replacing \"B\" with \"8\", \"O\"\nwith \"0\", \"I\" with \"l\", etc.\n* Implementations interpret \"?\" as an erasure.\n* Implementations optionally interpret other non-bech32 characters, or\ncharacters with incorrect case, as erasures.\n* If a string with 8 or fewer erasures can have those erasures filled in to\nmake a valid codex32 string, then the implementation suggests such a string\nas a correction.\n* If a string consisting of valid Bech32 characters in the proper case can\nbe made valid by substituting 4 or fewer characters, then the\nimplementation suggests such a string as a correction.\n\n===Unshared Secret===\n\nWhen the share index of a valid codex32 string (converted to lowercase) is\nthe letter \"s\", we call the string a codex32 secret.\nThe subsequent data characters in a codex32 secret, excluding the final\nchecksum of 13 characters, is a direct encoding of a BIP-0032 HD master\nseed.\n\nThe master seed is decoded by converting the data to bytes:\n\n* Translate the characters to 5 bits values using the bech32 character\ntable from BIP-0173, most significant bit first.\n* Re-arrange those bits into groups of 8 bits. Any incomplete group at the\nend MUST be 4 bits or less, and is discarded.\n\nNote that unlike the decoding process in BIP-0173, we do NOT require that\nthe incomplete group be all zeros.\n\nFor an unshared secret, the threshold parameter (the first character of the\ndata part) is ignored (beyond the fact it must be a digit for the codex32\nstring to be valid).\nWe recommend using the digit \"0\" for the threshold parameter in this case.\nThe 4 character identifier also has no effect beyond aiding users in\ndistinguishing between multiple different master seeds in cases where they\nhave more than one.\n\n===Recovering Master Seed===\n\nWhen the share index of a valid codex32 string (converted to lowercase) is\nnot the letter \"s\", we call the string an codex32 share.\nThe first character of the data part indicates the threshold of the share,\nand it is required to be a non-\"0\" digit.\n\nIn order to recover a master seed, one needs a set of valid codex32 shares\nsuch that:\n\n* All shares have the same threshold value, the same identifier, and the\nsame length.\n* All of the share index values are distinct.\n* The number of codex32 shares is exactly equal to the (common) threshold\nvalue.\n\nIf all the above conditions are satisfied, the <code>ms32_recover</code>\nfunction will return a codex32 secret when its argument is the list of\ncodex32 shares with each share represented as a list of integers\nrepresenting the characters converted using the bech32 character table from\nBIP-0173.\n\n<source lang=\"python\">\nbech32_inv = [\n    0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,\n    22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,\n]\n\ndef bech32_mul(a, b):\n    res = 0\n    for i in range(5):\n        res ^= a if ((b >> i) & 1) else 0\n        a *= 2\n        a ^= 41 if (32 <= a) else 0\n    return res\n\ndef bech32_lagrange(l, x):\n    n = 1\n    c = []\n    for i in l:\n        n = bech32_mul(n, i ^ x)\n        m = 1\n        for j in l:\n            m = bech32_mul(m, (x if i == j else i) ^ j)\n        c.append(m)\n    return [bech32_mul(n, bech32_inv[i]) for i in c]\n\ndef ms32_interpolate(l, x):\n    w = bech32_lagrange([s[5] for s in l], x)\n    res = []\n    for i in range(len(l[0])):\n        n = 0\n        for j in range(len(l)):\n            n ^= bech32_mul(w[j], l[j][i])\n        res.append(n)\n    return res\n\ndef ms32_recover(l):\n    return ms32_interpolate(l, 16)\n</source>\n\n===Generating Shares===\n\nIf we already have ''t'' valid codex32 strings such that:\n\n* All strings have the same threshold value ''t'', the same identifier, and\nthe same length\n* All of the share index values are distinct\n\nThen we can derive additional shares with the <code>ms32_interpolate</code>\nfunction by passing it a list of exactly ''t'' of these codex32 strings,\ntogether with a fresh share index distinct from all of the existing share\nindexes.\nThe newly derived share will have the provided share index.\n\nOnce a user has generated ''n'' codex32 shares, they may discard the\ncodex32 secret (if it exists).\nThe ''n'' shares form a ''t'' of ''n'' Shamir's secret sharing scheme of a\ncodex32 secret.\n\nThere are two ways to create an initial set of ''t'' valid codex32 strings,\ndepending on whether the user already has an existing master seed to split.\n\n====For an existing master seed====\n\nBefore generating shares for an existing master seed, it first must be\nconverted into a codex32 secret, as described above.\nThe conversion process consists of:\n\n* Choosing a threshold value ''t'' between 2 and 9, inclusive\n* Choosing a 4 bech32 character identifier\n** We do not define how to choose the identifier, beyond noting that it\nSHOULD be distinct for every master seed the user may need to disambiguate.\n* Setting the share index to \"s\"\n* Setting the payload to a Bech32 encoding of the master seed, padded with\narbitrary bits\n* Generating a valid checksum in accordance with the Checksum section\n\nAlong with the codex32 secret, the user must generate ''t''-1 other codex32\nshares, each with the same threshold value, the same identifier, and a\ndistinct share index.\nThe set of share indexes may be chosen arbitrarily.\nThe payload of each of these codex32 shares is chosen uniformly at random\nsuch that it has the same length as the payload of the codex32 secret.\nFor each share, a valid checksum must be generated in accordance with the\nChecksum section.\n\nThe codex32 secret and the ''t''-1 codex32 shares form a set of ''t'' valid\ncodex32 strings from which additional shares can be derived as described\nabove.\n\n====For a fresh master seed====\n\nIn the case that the user wishes to generate a fresh master seed, the user\nchooses a threshold value ''t'' and an identifier, then generates ''t''\nrandom codex32 shares, using the generation procedure from the previous\nsection.\nAs before, each share must have the same threshold value ''t'', the same\nidentifier, and a distinct share index.\n\nWith this set of ''t'' codex32 shares, new shares can be derived as\ndiscussed above. This process generates a fresh master seed, whose value\ncan be retrieved by running the recovery process on any ''t'' of these\nshares.\n\n===Long codex32 Strings===\n\nThe 13 character checksum design only supports up to 80 data characters.\nExcluding the threshold, identifier and index characters, this limits the\npayload to 74 characters or 46 bytes.\nWhile this is enough to support the 32-byte advised size of BIP-0032 master\nseeds, BIP-0032 allows seeds to be up to 64 bytes in size.\nWe define a long codex32 string format to support these longer seeds by\ndefining an alternative checksum.\n\n<source lang=\"python\">\nMS32_LONG_CONST = 0x43381e570bf4798ab26\n\ndef ms32_long_polymod(values):\n    GEN = [\n        0x3d59d273535ea62d897,\n        0x7a9becb6361c6c51507,\n        0x543f9b7e6c38d8a2a0e,\n        0x0c577eaeccf1990d13c,\n        0x1887f74f8dc71b10651,\n    ]\n    residue = 0x23181b3\n    for v in values:\n        b = (residue >> 70)\n        residue = (residue & 0x3fffffffffffffffff) << 5 ^ v\n        for i in range(5):\n            residue ^= GEN[i] if ((b >> i) & 1) else 0\n    return residue\n\ndef ms32_verify_long_checksum(data):\n    return ms32_long_polymod(data) == MS32_LONG_CONST\n\ndef ms32_create_long_checksum(data):\n    values = data\n    polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST\n    return [(polymod >> 5 * (14 - i)) & 31 for i in range(15)]\n</source>\n\nA long codex32 string follows the same specification as a regular codex32\nstring with the following changes.\n\n* The payload is a sequence of between 75 and 103 Bech32 characters.\n* The checksum consists of 15 Bech32 characters as defined above.\n\nA codex32 string with a data part of 94 or 95 characters is never legal as\na regular codex32 string is limited to 93 data characters and a long\ncodex32 string is at least 96 characters.\n\nGeneration of long shares and recovery of the master seed from long shares\nproceeds in exactly the same way as for regular shares with the\n<code>ms32_interpolate</code> function.\n\nThe long checksum is designed to be an error correcting code that can\ncorrect up to 4 character substitutions, up to 8 unreadable characters\n(called erasures), or up to 15 consecutive erasures.\nAs with regular checksums we do not specify how an implementation should\nimplement error correction, and all our recommendations for error\ncorrection of regular codex32 strings also apply to long codex32 strings.\n\n==Rationale==\n\nThis scheme is based on the observation that the Lagrange interpolation of\nvalid codewords in a BCH code will always be a valid codeword.\nThis means that derived shares will always have valid checksum, and a\nsufficient threshold of shares with valid checksums will derive a secret\nwith a valid checksum.\n\nThe header system is also compatible with Lagrange interpolation, meaning\nall derived shares will have the same identifier and will have the\nappropriate share index.\nThis fact allows the header data to be covered by the checksum.\n\nThe checksum size and identifier size have been chosen so that the encoding\nof 128-bit seeds and shares fit within 48 characters.\nThis is a standard size for many common seed storage formats, which has\nbeen popularized by the 12 four-letter word format of the BIP-0039 mnemonic.\n\nThe 13 character checksum is adequate to correct 4 errors in up to 93\ncharacters (80 characters of data and 13 characters of the checksum). This\nis somewhat better quality than the checksum used in SLIP-0039.\n\nFor 256-bit seeds and shares our strings are 74 characters, which fits into\nthe 96 character format of the 24 four-letter word format of the BIP-0039\nmnemonic, with plenty of room to spare.\n\nA longer checksum is needed to support up to 512-bit seeds, the longest\nseed length specified in BIP-0032, as the 13 character checksum isn't\nadequate for more than 80 data characters.\nWhile we could use the 15 character checksum for both cases, we prefer to\nkeep the strings as short as possible for the more common cases of 128-bit\nand 256-bit master seeds.\nWe only guarantee to correct 4 characters no matter how long the string is.\nLonger strings mean more chances for transcription errors, so shorter\nstrings are better.\n\nThe longest data part using the regular 13 character checksum is 93\ncharacters and corresponds to a 400-bit secret.\nAt this length, the prefix <code>MS1</code> is not covered by the checksum.\nThis is acceptable because the checksum scheme itself requires you to know\nthat the <code>MS1</code> prefix is being used in the first place.\nIf the prefix is damaged and a user is guessing that the data might be\nusing this scheme, then the user can enter the available data explicitly\nusing the suspected <code>MS1</code> prefix.\n\n==Backwards Compatibility==\n\ncodex32 is an alternative to BIP-0039 and SLIP-0039.\nIt is technically possible to derive the BIP32 master seed from seed words\nencoded in one of these schemes, and then to encode this seed in codex32.\nFor BIP-0039 this process is irreversible, since it involves hashing the\noriginal words.\nFurthermore, the resulting seed will be 512 bits long, which may be too\nlarge to be safely and conveniently handled.\n\nSLIP-0039 seed words can be reversibly converted to master seeds, so it is\npossible to interconvert between SLIP-0039 and codex32.\nHowever, SLIP-0039 '''shares''' cannot be converted to codex32 shares\nbecause the two schemes use a different underlying field.\n\nThe authors of this BIP do not recommend interconversion.\nInstead, users who wish to switch to codex32 should generate a fresh seed\nand sweep their coins.\n\n==Reference Implementation==\n\n* [https://secretcodex32.com/docs/2023-02-14--bw.ps Reference PostScript\nImplementation]\n* FIXME add Python implementation\n* FIXME add Rust implementation\n\n==Test Vectors==\n\n===Test vector 1===\n\nThis example shows the codex32 format, when used without splitting the\nsecret into any shares.\nThe data part contains 26 Bech32 characters, which corresponds to 130 bits.\nWe truncate the last two bits in order to obtain a 128-bit master seed.\n\ncodex32 secret (Bech32):\n<code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code>\n\nMaster secret (hex): <code>318c6318c6318c6318c6318c6318c631</code>\n\n* human-readable part: <code>ms</code>\n* separator: <code>1</code>\n* k value: <code>0</code> (no secret splitting)\n* identifier: <code>test</code>\n* share index: <code>s</code> (the secret)\n* data: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code>\n* checksum: <code>4nzvca9cmczlw</code>\n\n===Test vector 2===\n\nThis example shows generating a new master seed using \"random\" codex32\nshares, as well as deriving an additional codex32 share, using ''k''=2 and\nan identifier of <code>NAME</code>.\nAlthough codex32 strings are canonically all lowercase, it's also valid to\nuse all uppercase.\n\nShare with index <code>A</code>:\n<code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code>\n\nShare with index <code>C</code>:\n<code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code>\n\n* Derived share with index <code>D</code>:\n<code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code>\n* Secret share with index <code>S</code>:\n<code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code>\n* Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code>\n\nNote that per BIP-0173, the lowercase form is used when determining a\ncharacter's value for checksum purposes.\nIn particular, given an all uppercase codex32 string, we still use\nlowercase <code>ms</code> as the human-readable part during checksum\nconstruction.\n\n===Test vector 3===\n\nThis example shows splitting an existing 128-bit master seed into \"random\"\ncodex32 shares, using ''k''=3 and an identifier of <code>cash</code>.\nWe appended two zero bits in order to obtain 26 Bech32 characters (130 bits\nof data) from the 128-bit master seed.\n\nMaster secret (hex): <code>ffeeddccbbaa99887766554433221100</code>\n\nSecret share with index <code>s</code>:\n<code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n\nShare with index <code>a</code>:\n<code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code>\n\nShare with index <code>c</code>:\n<code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code>\n\n* Derived share with index <code>d</code>:\n<code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code>\n* Derived share with index <code>e</code>:\n<code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code>\n* Derived share with index <code>f</code>:\n<code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code>\n\nAny three of the five shares among <code>acdef</code> can be used to\nrecover the secret.\n\nNote that the choice to append two zero bits was arbitrary, and any of the\nfollowing four secret shares would have been valid choices.\nHowever, each choice would have resulted in a different set of derived\nshares.\n\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code>\n\n===Test vector 4===\n\nThis example shows converting a 256-bit secret into a codex32 secret,\nwithout splitting the secret into any shares.\nWe appended four zero bits in order to obtain 52 Bech32 characters (260\nbits of data) from the 256-bit secret.\n\n256-bit secret (hex):\n<code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code>\n\n* codex32 secret:\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n\nNote that the choice to append four zero bits was arbitrary, and any of the\nfollowing sixteen codex32 secrets would have been valid:\n\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code>\n*\n<code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code>\n\n===Test vector 5===\n\nThis example shows generating a new 512-bit master seed using \"random\"\ncodex32 characters and appending a checksum.\nThe payload contains 103 Bech32 characters, which corresponds to 515 bits.\nThe last three bits are discarded when converting to a 512-bit master seed.\n\nThis is an example of a '''Long codex32 String'''.\n\n* Secret share with index <code>S</code>:\n<code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code>\n* Master secret (hex):\n<code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code>\n\n==Appendix==\n\n===Mathematical Companion===\n\nBelow we use the Bech32 character set to denote values in GF[32].\nIn Bech32, the letter <code>Q</code> denotes zero and the letter\n<code>P</code> denotes one.\nThe digits <code>0</code> and <code>2</code> through <code>9</code> do\n''not'' denote their numeric values.\nThey are simply elements of GF[32].\n\nThe generating polynomial for our BCH code is as follows.\n\nWe extend GF[32] to GF[1024] by adjoining a primitive cube root of unity,\n<code>\u03b6</code>, satisfying <code>\u03b6^2 = \u03b6 + P</code>.\n\nWe select <code>\u03b2 := G \u03b6</code> which has order 93, and construct the\nproduct <code>(x - \u03b2^i)</code> for <code>i</code> in <code>{17, 20, 46, 49,\n52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.\nThe resulting polynomial is our generating polynomial for our 13 character\nchecksum:\n\n    x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E x^5\n+ L x^4 + M x^3 + C x^2 + S x + S\n\nFor our long checksum, we select <code>\u03b3 := E + X \u03b6</code>, which has order\n1023, and construct the product <code>(x - \u03b3^i)</code> for <code>i</code>\nin <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021, 1022, 1023,\n1024, 1025, 1026}</code>.\nThe resulting polynomial is our generating polynomial for our 15 character\nchecksum for long strings:\n\n    x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X\nx^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H\n\n(Reminder: the character <code>0</code> does ''not'' denote the zero of the\nfield.)\n\n-----END BIP-----\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230215/4ef5f4ec/attachment-0001.html>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2023-02-16T11:50:12",
                "message_text_only": "Hi!\n\nThe BIP states that its only advantage over SLIP-0039, which has been used\nin production for nearly three years (in at at least 3 SW/HW wallet\nimplementations), is that it aims to be simple enough for hand computation.\nHowever, the BIP also indicates that \"details of hand computation are\noutside the scope of this standard, and implementers do not need to be\nconcerned with this possibility.\" Therefore, I am curious about how\nsignificant this advantage over SLIP-0039 really is. If hand computation is\nnot straightforward and there are no other substantial advantages over\nSLIP-0039, I cannot help but feel that this BIP is simply a result of\nnot-invented-here syndrome, but please correct me if I am wrong.\n\nKeep in mind that the encoded shares in SLIP-0039 consist of exactly 200 or\n330 bits, both of which are divisible by 5. This makes it straightforward\nto encode them as Bech32 strings.\n\nOn Thu, 16 Feb 2023 at 09:30, Russell O'Connor via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I've been asked by Dr. Curr and Professor Snead to forward this message to\n> this mailing list, as it may be of general interest to Bitcoin users.\n>\n> Dear Colleague:\n>\n> In 1967, during excavation for the construction of a new shopping center\n> in\n> Monroeville, Pennsylvania, workers uncovered a vault containing a cache of\n> ancient scrolls[1].  Most were severely damaged, but those that could be\n> recovered confirmed the existence of a secret society long suspected to\n> have\n> been active in the region around the year 200 BC.\n>\n> Based on a translation of these documents, we now know that the society,\n> the\n> Cult of the Bound Variable, was devoted to the careful study of\n> computation,\n> over two millennia before the invention of the digital computer.\n>\n> While the Monroeville scrolls make reference to computing machines made of\n> sandstone, most researchers believed this to be a poetic metaphor and that\n> the\n> \"computers\" were in fact the initiates themselves, carrying out the\n> unimaginably tedious steps of their computations with reed pens on\n> parchment.\n>\n> Within the vault, a collection of sandstone wheels marked in a language\n> consisting of 32 glyphs was found. After 15 years of study, we have\n> successfully\n> completed the translation of what is known as \"Codex32,\" a document that\n> describes the functions of the wheels. It was discovered that the wheels\n> operate\n> a system of cryptographic computations that was used by cult members to\n> safeguard their most valuable secrets.\n>\n> The Codex32 system allows secrets to be carved into multiple tablets and\n> scattered to the far corners of the earth. When a sufficient number of\n> tablets are\n> brought together the stone wheels are manipulated in a manner to recover\n> the\n> secrets. This finding may be of particular interest to the Bitcoin\n> community.\n>\n> Below we provide a summary of the cult's secret sharing system, which is\n> graciously hosted at\n> <\n> https://github.com/apoelstra/bips/blob/2023-02--volvelles/bip-0000.mediawiki\n> >.\n> We are requesting a record assignment in the Bibliography of Immemorial\n> Philosophy (BIP) repository.\n>\n> Thank you for your consideration.\n>\n> Dr. Leon O. Curr and Professor Pearlwort Snead\n> Department of Archaeocryptography\n> Harry Q. Bovik Institute for the Advancement\n>\n> [1] http://www.boundvariable.org/task.shtml\n>\n> -----BEGIN BIP-----\n>\n> <pre>\n>   BIP: ????\n>   Layer: Applications\n>   Title: codex32\n>   Author: Leon Olsson Curr and Pearlwort Sneed <pearlwort at wpsoftware.net>\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n>   Status: Draft\n>   Type: ????\n>   Created: 2023-02-13\n>   License: BSD-3-Clause\n>   Post-History: FIXME\n> </pre>\n>\n> ==Introduction==\n>\n> ===Abstract===\n>\n> This document describes a standard for backing up and restoring the master\n> seed of a\n> [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032]\n> hierarchical deterministic wallet, using Shamir's secret sharing.\n> It includes an encoding format, a BCH error-correcting checksum, and\n> algorithms for share generation and secret recovery.\n> Secret data can be split into up to 31 shares.\n> A minimum threshold of shares, which can be between 1 and 9, is needed to\n> recover the secret, whereas without sufficient shares, no information about\n> the secret is recoverable.\n>\n> ===Copyright===\n>\n> This document is licensed under the 3-clause BSD license.\n>\n> ===Motivation===\n>\n> BIP-0032 master seed data is the source entropy used to derive all private\n> keys in an HD wallet.\n> Safely storing this secret data is the hardest and most important part of\n> self-custody.\n> However, there is a tension between security, which demands limiting the\n> number of backups, and resilience, which demands widely replicated backups.\n> Encrypting the seed does not change this fundamental tradeoff, since it\n> leaves essentially the same problem of how to back up the encryption key(s).\n>\n> To allow users freedom to make this tradeoff, we use Shamir's secret\n> sharing, which guarantees that any number of shares less than the threshold\n> leaks no information about the secret.\n> This approach allows increasing safety by widely distributing the\n> generated shares, while also providing security against the compromise of\n> one or more shares (as long as fewer than the threshold have been\n> compromised).\n>\n> [https://github.com/satoshilabs/slips/blob/master/slip-0039.md SLIP-0039]\n> has essentially the same motivations as this standard.\n> However, unlike SLIP-0039, this standard also aims to be simple enough for\n> hand computation.\n> Users who demand a higher level of security for particular secrets, or\n> have a general distrust in digital electronic devices, have the option of\n> using hand computation to backup and restore secret data in an\n> interoperable manner.\n> Note that hand computation is optional, the particular details of hand\n> computation are outside the scope of this standard, and implementers do not\n> need to be concerned with this possibility.\n>\n> [https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039]\n> serves the same purpose as this standard: encoding master seeds for storage\n> by users.\n> However, BIP-0039 has no error-correcting ability, cannot sensibly be\n> extended to support secret sharing, has no support for versioning or other\n> metadata, and has many technical design decisions that make implementation\n> and interoperability difficult (for example, the use of SHA-512 to derive\n> seeds, or the use of 11-bit words).\n>\n> ==Specification==\n>\n> ===codex32===\n>\n> A codex32 string is similar to a Bech32 string defined in [\n> https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173].\n> It reuses the base32 character set from BIP-0173, and consists of:\n>\n> * A human-readable part, which is the string \"ms\" (or \"MS\").\n> * A separator, which is always \"1\".\n> * A data part which is in turn subdivided into:\n> ** A threshold parameter, which MUST be a single digit between \"2\" and\n> \"9\", or the digit \"0\".\n> *** If the threshold parameter is \"0\" then the share index, defined below,\n> MUST have a value of \"s\" (or \"S\").\n> ** An identifier consisting of 4 Bech32 characters.\n> ** A share index, which is any Bech32 character. Note that a share index\n> value of \"s\" (or \"S\") is special and denotes the unshared secret (see\n> section \"Unshared Secret\").\n> ** A payload which is a sequence of up to 74 Bech32 characters. (However,\n> see '''Long codex32 Strings''' below for an exception to this limit.)\n> ** A checksum which consists of 13 Bech32 characters as described below.\n>\n> As with Bech32 strings, a codex32 string MUST be entirely uppercase or\n> entirely lowercase.\n> The lowercase form is used when determining a character's value for\n> checksum purposes.\n> For presentation, lowercase is usually preferable, but uppercase SHOULD be\n> used for handwritten codex32 strings.\n>\n> ===Checksum===\n>\n> The last thirteen characters of the data part form a checksum and contain\n> no information.\n> Valid strings MUST pass the criteria for validity specified by the Python3\n> code snippet below.\n> The function <code>ms32_verify_checksum</code> must return true when its\n> argument is the data part as a list of integers representing the characters\n> converted using the bech32 character table from BIP-0173.\n>\n> To construct a valid checksum given the data-part characters (excluding\n> the checksum), the <code>ms32_create_checksum</code> function can be used.\n>\n> <source lang=\"python\">\n> MS32_CONST = 0x10ce0795c2fd1e62a\n>\n> def ms32_polymod(values):\n>     GEN = [\n>         0x19dc500ce73fde210,\n>         0x1bfae00def77fe529,\n>         0x1fbd920fffe7bee52,\n>         0x1739640bdeee3fdad,\n>         0x07729a039cfc75f5a,\n>     ]\n>     residue = 0x23181b3\n>     for v in values:\n>         b = (residue >> 60)\n>         residue = (residue & 0x0fffffffffffffff) << 5 ^ v\n>         for i in range(5):\n>             residue ^= GEN[i] if ((b >> i) & 1) else 0\n>     return residue\n>\n> def ms32_verify_checksum(data):\n>     if len(data) >= 96:                      # See Long codex32 Strings\n>         return ms32_verify_long_checksum(data)\n>     if len(data) <= 93:\n>         return ms32_polymod(data) == MS32_CONST\n>     return False\n>\n> def ms32_create_checksum(data):\n>     if len(data) > 80:                       # See Long codex32 Strings\n>         return ms32_create_long_checksum(data)\n>     values = data\n>     polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST\n>     return [(polymod >> 5 * (12 - i)) & 31 for i in range(13)]\n> </source>\n>\n> ===Error Correction===\n>\n> A codex32 string without a valid checksum MUST NOT be used.\n> The checksum is designed to be an error correcting code that can correct\n> up to 4 character substitutions, up to 8 unreadable characters (called\n> erasures), or up to 13 consecutive erasures.\n> Implementations SHOULD provide the user with a corrected valid codex32\n> string if possible.\n> However, implementations SHOULD NOT automatically proceed with a corrected\n> codex32 string without user confirmation of the corrected string, either by\n> prompting the user, or returning a corrected string in an error message and\n> allowing the user to repeat their action.\n> We do not specify how an implementation should implement error correction.\n> However, we recommend that:\n>\n> * Implementations make suggestions to substitute non-bech32 characters\n> with bech32 characters in some situations, such as replacing \"B\" with \"8\",\n> \"O\" with \"0\", \"I\" with \"l\", etc.\n> * Implementations interpret \"?\" as an erasure.\n> * Implementations optionally interpret other non-bech32 characters, or\n> characters with incorrect case, as erasures.\n> * If a string with 8 or fewer erasures can have those erasures filled in\n> to make a valid codex32 string, then the implementation suggests such a\n> string as a correction.\n> * If a string consisting of valid Bech32 characters in the proper case can\n> be made valid by substituting 4 or fewer characters, then the\n> implementation suggests such a string as a correction.\n>\n> ===Unshared Secret===\n>\n> When the share index of a valid codex32 string (converted to lowercase) is\n> the letter \"s\", we call the string a codex32 secret.\n> The subsequent data characters in a codex32 secret, excluding the final\n> checksum of 13 characters, is a direct encoding of a BIP-0032 HD master\n> seed.\n>\n> The master seed is decoded by converting the data to bytes:\n>\n> * Translate the characters to 5 bits values using the bech32 character\n> table from BIP-0173, most significant bit first.\n> * Re-arrange those bits into groups of 8 bits. Any incomplete group at the\n> end MUST be 4 bits or less, and is discarded.\n>\n> Note that unlike the decoding process in BIP-0173, we do NOT require that\n> the incomplete group be all zeros.\n>\n> For an unshared secret, the threshold parameter (the first character of\n> the data part) is ignored (beyond the fact it must be a digit for the\n> codex32 string to be valid).\n> We recommend using the digit \"0\" for the threshold parameter in this case.\n> The 4 character identifier also has no effect beyond aiding users in\n> distinguishing between multiple different master seeds in cases where they\n> have more than one.\n>\n> ===Recovering Master Seed===\n>\n> When the share index of a valid codex32 string (converted to lowercase) is\n> not the letter \"s\", we call the string an codex32 share.\n> The first character of the data part indicates the threshold of the share,\n> and it is required to be a non-\"0\" digit.\n>\n> In order to recover a master seed, one needs a set of valid codex32 shares\n> such that:\n>\n> * All shares have the same threshold value, the same identifier, and the\n> same length.\n> * All of the share index values are distinct.\n> * The number of codex32 shares is exactly equal to the (common) threshold\n> value.\n>\n> If all the above conditions are satisfied, the <code>ms32_recover</code>\n> function will return a codex32 secret when its argument is the list of\n> codex32 shares with each share represented as a list of integers\n> representing the characters converted using the bech32 character table from\n> BIP-0173.\n>\n> <source lang=\"python\">\n> bech32_inv = [\n>     0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,\n>     22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,\n> ]\n>\n> def bech32_mul(a, b):\n>     res = 0\n>     for i in range(5):\n>         res ^= a if ((b >> i) & 1) else 0\n>         a *= 2\n>         a ^= 41 if (32 <= a) else 0\n>     return res\n>\n> def bech32_lagrange(l, x):\n>     n = 1\n>     c = []\n>     for i in l:\n>         n = bech32_mul(n, i ^ x)\n>         m = 1\n>         for j in l:\n>             m = bech32_mul(m, (x if i == j else i) ^ j)\n>         c.append(m)\n>     return [bech32_mul(n, bech32_inv[i]) for i in c]\n>\n> def ms32_interpolate(l, x):\n>     w = bech32_lagrange([s[5] for s in l], x)\n>     res = []\n>     for i in range(len(l[0])):\n>         n = 0\n>         for j in range(len(l)):\n>             n ^= bech32_mul(w[j], l[j][i])\n>         res.append(n)\n>     return res\n>\n> def ms32_recover(l):\n>     return ms32_interpolate(l, 16)\n> </source>\n>\n> ===Generating Shares===\n>\n> If we already have ''t'' valid codex32 strings such that:\n>\n> * All strings have the same threshold value ''t'', the same identifier,\n> and the same length\n> * All of the share index values are distinct\n>\n> Then we can derive additional shares with the\n> <code>ms32_interpolate</code> function by passing it a list of exactly\n> ''t'' of these codex32 strings, together with a fresh share index distinct\n> from all of the existing share indexes.\n> The newly derived share will have the provided share index.\n>\n> Once a user has generated ''n'' codex32 shares, they may discard the\n> codex32 secret (if it exists).\n> The ''n'' shares form a ''t'' of ''n'' Shamir's secret sharing scheme of a\n> codex32 secret.\n>\n> There are two ways to create an initial set of ''t'' valid codex32\n> strings, depending on whether the user already has an existing master seed\n> to split.\n>\n> ====For an existing master seed====\n>\n> Before generating shares for an existing master seed, it first must be\n> converted into a codex32 secret, as described above.\n> The conversion process consists of:\n>\n> * Choosing a threshold value ''t'' between 2 and 9, inclusive\n> * Choosing a 4 bech32 character identifier\n> ** We do not define how to choose the identifier, beyond noting that it\n> SHOULD be distinct for every master seed the user may need to disambiguate.\n> * Setting the share index to \"s\"\n> * Setting the payload to a Bech32 encoding of the master seed, padded with\n> arbitrary bits\n> * Generating a valid checksum in accordance with the Checksum section\n>\n> Along with the codex32 secret, the user must generate ''t''-1 other\n> codex32 shares, each with the same threshold value, the same identifier,\n> and a distinct share index.\n> The set of share indexes may be chosen arbitrarily.\n> The payload of each of these codex32 shares is chosen uniformly at random\n> such that it has the same length as the payload of the codex32 secret.\n> For each share, a valid checksum must be generated in accordance with the\n> Checksum section.\n>\n> The codex32 secret and the ''t''-1 codex32 shares form a set of ''t''\n> valid codex32 strings from which additional shares can be derived as\n> described above.\n>\n> ====For a fresh master seed====\n>\n> In the case that the user wishes to generate a fresh master seed, the user\n> chooses a threshold value ''t'' and an identifier, then generates ''t''\n> random codex32 shares, using the generation procedure from the previous\n> section.\n> As before, each share must have the same threshold value ''t'', the same\n> identifier, and a distinct share index.\n>\n> With this set of ''t'' codex32 shares, new shares can be derived as\n> discussed above. This process generates a fresh master seed, whose value\n> can be retrieved by running the recovery process on any ''t'' of these\n> shares.\n>\n> ===Long codex32 Strings===\n>\n> The 13 character checksum design only supports up to 80 data characters.\n> Excluding the threshold, identifier and index characters, this limits the\n> payload to 74 characters or 46 bytes.\n> While this is enough to support the 32-byte advised size of BIP-0032\n> master seeds, BIP-0032 allows seeds to be up to 64 bytes in size.\n> We define a long codex32 string format to support these longer seeds by\n> defining an alternative checksum.\n>\n> <source lang=\"python\">\n> MS32_LONG_CONST = 0x43381e570bf4798ab26\n>\n> def ms32_long_polymod(values):\n>     GEN = [\n>         0x3d59d273535ea62d897,\n>         0x7a9becb6361c6c51507,\n>         0x543f9b7e6c38d8a2a0e,\n>         0x0c577eaeccf1990d13c,\n>         0x1887f74f8dc71b10651,\n>     ]\n>     residue = 0x23181b3\n>     for v in values:\n>         b = (residue >> 70)\n>         residue = (residue & 0x3fffffffffffffffff) << 5 ^ v\n>         for i in range(5):\n>             residue ^= GEN[i] if ((b >> i) & 1) else 0\n>     return residue\n>\n> def ms32_verify_long_checksum(data):\n>     return ms32_long_polymod(data) == MS32_LONG_CONST\n>\n> def ms32_create_long_checksum(data):\n>     values = data\n>     polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST\n>     return [(polymod >> 5 * (14 - i)) & 31 for i in range(15)]\n> </source>\n>\n> A long codex32 string follows the same specification as a regular codex32\n> string with the following changes.\n>\n> * The payload is a sequence of between 75 and 103 Bech32 characters.\n> * The checksum consists of 15 Bech32 characters as defined above.\n>\n> A codex32 string with a data part of 94 or 95 characters is never legal as\n> a regular codex32 string is limited to 93 data characters and a long\n> codex32 string is at least 96 characters.\n>\n> Generation of long shares and recovery of the master seed from long shares\n> proceeds in exactly the same way as for regular shares with the\n> <code>ms32_interpolate</code> function.\n>\n> The long checksum is designed to be an error correcting code that can\n> correct up to 4 character substitutions, up to 8 unreadable characters\n> (called erasures), or up to 15 consecutive erasures.\n> As with regular checksums we do not specify how an implementation should\n> implement error correction, and all our recommendations for error\n> correction of regular codex32 strings also apply to long codex32 strings.\n>\n> ==Rationale==\n>\n> This scheme is based on the observation that the Lagrange interpolation of\n> valid codewords in a BCH code will always be a valid codeword.\n> This means that derived shares will always have valid checksum, and a\n> sufficient threshold of shares with valid checksums will derive a secret\n> with a valid checksum.\n>\n> The header system is also compatible with Lagrange interpolation, meaning\n> all derived shares will have the same identifier and will have the\n> appropriate share index.\n> This fact allows the header data to be covered by the checksum.\n>\n> The checksum size and identifier size have been chosen so that the\n> encoding of 128-bit seeds and shares fit within 48 characters.\n> This is a standard size for many common seed storage formats, which has\n> been popularized by the 12 four-letter word format of the BIP-0039 mnemonic.\n>\n> The 13 character checksum is adequate to correct 4 errors in up to 93\n> characters (80 characters of data and 13 characters of the checksum). This\n> is somewhat better quality than the checksum used in SLIP-0039.\n>\n> For 256-bit seeds and shares our strings are 74 characters, which fits\n> into the 96 character format of the 24 four-letter word format of the\n> BIP-0039 mnemonic, with plenty of room to spare.\n>\n> A longer checksum is needed to support up to 512-bit seeds, the longest\n> seed length specified in BIP-0032, as the 13 character checksum isn't\n> adequate for more than 80 data characters.\n> While we could use the 15 character checksum for both cases, we prefer to\n> keep the strings as short as possible for the more common cases of 128-bit\n> and 256-bit master seeds.\n> We only guarantee to correct 4 characters no matter how long the string is.\n> Longer strings mean more chances for transcription errors, so shorter\n> strings are better.\n>\n> The longest data part using the regular 13 character checksum is 93\n> characters and corresponds to a 400-bit secret.\n> At this length, the prefix <code>MS1</code> is not covered by the checksum.\n> This is acceptable because the checksum scheme itself requires you to know\n> that the <code>MS1</code> prefix is being used in the first place.\n> If the prefix is damaged and a user is guessing that the data might be\n> using this scheme, then the user can enter the available data explicitly\n> using the suspected <code>MS1</code> prefix.\n>\n> ==Backwards Compatibility==\n>\n> codex32 is an alternative to BIP-0039 and SLIP-0039.\n> It is technically possible to derive the BIP32 master seed from seed words\n> encoded in one of these schemes, and then to encode this seed in codex32.\n> For BIP-0039 this process is irreversible, since it involves hashing the\n> original words.\n> Furthermore, the resulting seed will be 512 bits long, which may be too\n> large to be safely and conveniently handled.\n>\n> SLIP-0039 seed words can be reversibly converted to master seeds, so it is\n> possible to interconvert between SLIP-0039 and codex32.\n> However, SLIP-0039 '''shares''' cannot be converted to codex32 shares\n> because the two schemes use a different underlying field.\n>\n> The authors of this BIP do not recommend interconversion.\n> Instead, users who wish to switch to codex32 should generate a fresh seed\n> and sweep their coins.\n>\n> ==Reference Implementation==\n>\n> * [https://secretcodex32.com/docs/2023-02-14--bw.ps Reference PostScript\n> Implementation]\n> * FIXME add Python implementation\n> * FIXME add Rust implementation\n>\n> ==Test Vectors==\n>\n> ===Test vector 1===\n>\n> This example shows the codex32 format, when used without splitting the\n> secret into any shares.\n> The data part contains 26 Bech32 characters, which corresponds to 130\n> bits. We truncate the last two bits in order to obtain a 128-bit master\n> seed.\n>\n> codex32 secret (Bech32):\n> <code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code>\n>\n> Master secret (hex): <code>318c6318c6318c6318c6318c6318c631</code>\n>\n> * human-readable part: <code>ms</code>\n> * separator: <code>1</code>\n> * k value: <code>0</code> (no secret splitting)\n> * identifier: <code>test</code>\n> * share index: <code>s</code> (the secret)\n> * data: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code>\n> * checksum: <code>4nzvca9cmczlw</code>\n>\n> ===Test vector 2===\n>\n> This example shows generating a new master seed using \"random\" codex32\n> shares, as well as deriving an additional codex32 share, using ''k''=2 and\n> an identifier of <code>NAME</code>.\n> Although codex32 strings are canonically all lowercase, it's also valid to\n> use all uppercase.\n>\n> Share with index <code>A</code>:\n> <code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code>\n>\n> Share with index <code>C</code>:\n> <code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code>\n>\n> * Derived share with index <code>D</code>:\n> <code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code>\n> * Secret share with index <code>S</code>:\n> <code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code>\n> * Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code>\n>\n> Note that per BIP-0173, the lowercase form is used when determining a\n> character's value for checksum purposes.\n> In particular, given an all uppercase codex32 string, we still use\n> lowercase <code>ms</code> as the human-readable part during checksum\n> construction.\n>\n> ===Test vector 3===\n>\n> This example shows splitting an existing 128-bit master seed into \"random\"\n> codex32 shares, using ''k''=3 and an identifier of <code>cash</code>.\n> We appended two zero bits in order to obtain 26 Bech32 characters (130\n> bits of data) from the 128-bit master seed.\n>\n> Master secret (hex): <code>ffeeddccbbaa99887766554433221100</code>\n>\n> Secret share with index <code>s</code>:\n> <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n>\n> Share with index <code>a</code>:\n> <code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code>\n>\n> Share with index <code>c</code>:\n> <code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code>\n>\n> * Derived share with index <code>d</code>:\n> <code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code>\n> * Derived share with index <code>e</code>:\n> <code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code>\n> * Derived share with index <code>f</code>:\n> <code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code>\n>\n> Any three of the five shares among <code>acdef</code> can be used to\n> recover the secret.\n>\n> Note that the choice to append two zero bits was arbitrary, and any of the\n> following four secret shares would have been valid choices.\n> However, each choice would have resulted in a different set of derived\n> shares.\n>\n> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code>\n> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code>\n> * <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code>\n>\n> ===Test vector 4===\n>\n> This example shows converting a 256-bit secret into a codex32 secret,\n> without splitting the secret into any shares.\n> We appended four zero bits in order to obtain 52 Bech32 characters (260\n> bits of data) from the 256-bit secret.\n>\n> 256-bit secret (hex):\n> <code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code>\n>\n> * codex32 secret:\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n>\n> Note that the choice to append four zero bits was arbitrary, and any of\n> the following sixteen codex32 secrets would have been valid:\n>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code>\n> *\n> <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code>\n>\n> ===Test vector 5===\n>\n> This example shows generating a new 512-bit master seed using \"random\"\n> codex32 characters and appending a checksum.\n> The payload contains 103 Bech32 characters, which corresponds to 515 bits.\n> The last three bits are discarded when converting to a 512-bit master seed.\n>\n> This is an example of a '''Long codex32 String'''.\n>\n> * Secret share with index <code>S</code>:\n> <code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code>\n> * Master secret (hex):\n> <code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code>\n>\n> ==Appendix==\n>\n> ===Mathematical Companion===\n>\n> Below we use the Bech32 character set to denote values in GF[32].\n> In Bech32, the letter <code>Q</code> denotes zero and the letter\n> <code>P</code> denotes one.\n> The digits <code>0</code> and <code>2</code> through <code>9</code> do\n> ''not'' denote their numeric values.\n> They are simply elements of GF[32].\n>\n> The generating polynomial for our BCH code is as follows.\n>\n> We extend GF[32] to GF[1024] by adjoining a primitive cube root of unity,\n> <code>\u03b6</code>, satisfying <code>\u03b6^2 = \u03b6 + P</code>.\n>\n> We select <code>\u03b2 := G \u03b6</code> which has order 93, and construct the\n> product <code>(x - \u03b2^i)</code> for <code>i</code> in <code>{17, 20, 46, 49,\n> 52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.\n> The resulting polynomial is our generating polynomial for our 13 character\n> checksum:\n>\n>     x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E\n> x^5 + L x^4 + M x^3 + C x^2 + S x + S\n>\n> For our long checksum, we select <code>\u03b3 := E + X \u03b6</code>, which has\n> order 1023, and construct the product <code>(x - \u03b3^i)</code> for\n> <code>i</code> in <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021,\n> 1022, 1023, 1024, 1025, 1026}</code>.\n> The resulting polynomial is our generating polynomial for our 15 character\n> checksum for long strings:\n>\n>     x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X\n> x^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H\n>\n> (Reminder: the character <code>0</code> does ''not'' denote the zero of\n> the field.)\n>\n> -----END BIP-----\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n-- \nBest Regards / S pozdravom,\n\nPavol \"Stick\" Rusnak\nCo-Founder, SatoshiLabs\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/d2e67885/attachment-0001.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-16T13:49:53",
                "message_text_only": "On Thu, Feb 16, 2023 at 12:50:12PM +0100, Pavol Rusnak via bitcoin-dev wrote:\n> Hi!\n> \n> The BIP states that its only advantage over SLIP-0039, which has been used\n> in production for nearly three years (in at at least 3 SW/HW wallet\n> implementations), is that it aims to be simple enough for hand computation.\n> However, the BIP also indicates that \"details of hand computation are\n> outside the scope of this standard, and implementers do not need to be\n> concerned with this possibility.\" Therefore, I am curious about how\n> significant this advantage over SLIP-0039 really is. If hand computation is\n> not straightforward and there are no other substantial advantages over\n> SLIP-0039, I cannot help but feel that this BIP is simply a result of\n> not-invented-here syndrome, but please correct me if I am wrong.\n>\n\nIn my view, the hand computation is actually the main benefit of this\nscheme. The process *is* straightforward, but tedious enough (and the\nsecurity benefits obscure enough, though they really shouldn't be...\n\"computers are opaque and untrustworthy\" should be a common sentiment)\nthat it's hard to expect more than a small absolute number of users to\nactually do it.\n\nBut for the purpose of the *standard*, what is important is that it is\npossible to implement and use this within a normal hww workflow. This is\nimportant for hand-computing users who know that their coins will not\ndie with them (since the 'standard' has fallen into obscurity), and\nimportant for \"normal\" users who have the option to seamlessly switch\nover to hand computation as the BTC price goes up or the world becomes\nscarier.\n\nFor what it's worth, the draft lists several benefits over SLIP-0039.\nI agree that none of them are particularly strong [1], and even together\nthey probably wouldn't meet the threshold to take the time to write a\nstandard, but I assure you the motivation was not NIH :).\n\n> Keep in mind that the encoded shares in SLIP-0039 consist of exactly 200 or\n> 330 bits, both of which are divisible by 5. This makes it straightforward\n> to encode them as Bech32 strings.\n> \n\nThis is true! And very convenient for people who may want to simply\n\"layer on\" the codex32 checksum/splitting logic onto their SLIP39 words.\nThey can use a lookup table to do the conversion, spend years or\nwhataever doing hand-computation on them, and then use a lookup table\nto go back.\n\n\n[1] One listed reason is that \"a SLIP is not a BIP\". I have heard people\n    speculate that this is one reason SLIP-0039 is not nearly as\n    widespread as BIP-0039, even though it is objectively a far better\n    standard. I'm unsure whether I believe this, but \"there is no other\n    BIP\" does seem like a good reason for BIP-0039's continued\n    dominance.\n\n    At the very least, it means that on BIP-0039 itself we have nothing\n    that we could say \"supercedes\" or \"is recommended instead of\" the\n    BIP. See https://github.com/bitcoin/bips/pull/1413\n\n    So it's something of an aside, but I think it would probably be good\n    for the ecosystem (though maybe bad for this BIP's prospects :)) if\n    you would request a BIP number for SLIP-0039.\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/7f6aa147/attachment.sig>"
            },
            {
                "author": "David A. Harding",
                "date": "2023-02-19T20:13:33",
                "message_text_only": "On 2023-02-16 03:49, Andrew Poelstra via bitcoin-dev wrote:\n> the draft lists several benefits over SLIP-0039.\n\nThe only benefit over SLIP39 that I see explicitly mentioned in the\ndraft BIP is \"simple enough for hand computation\".  In the FAQ[1] on the\nproject's website, I see some additional reasons:\n\n| This scheme is essentially the same as SLIP39, with the following \ndifferences:\n|\n| - The checksum is longer, slightly stronger, and designed to be\n|   computable by hand.\n|\n| - Our encoding is more compact, giving us room for a bit of more\n|   metadata, which is also designed to be readable by hand.\n|\n| - Unlike SLIP39, we do not support passphrases or hardening of any\n|   form.\n|\n| - Unlike SLIP39, we have no hardware wallet support. But we hope that\n|   will change!\n\n From having perused the extended documentation myself, I think I would\npersonally note the following differences.\n\n- Alphabet: Codex32 uses the bech32 alphabet rather than SLIP39's\n   alphabet consisting of English words.  The benefit to human-language\n   words is easier memorization for those proficient in the particular\n   language (in this case, SLIP39 only allows the use of English).  A\n   disadvantage, IMO, is that it encourages the practice of memorization\n   (which does have a few advantages but also a lot of drawbacks).\n\n   Interestingly, Codex32 addresses what I think is the main problems of\n   memorization: difficult-to-prove successful recollection.  Someone who\n   wants to reliably keep seed-related material only in their head\n   needs to practice recalling it on a regular basis, but for BIP39,\n   SLIP39, Aezeed, etc... there's no way for them to confirm they\n   successfully recalled it short of going through the entire recovery\n   process; they probably just judge how confident they feel about the\n   recollection and assume that feeling like they recalled it correctly\n   is the same thing as recalling it correctly.\n\n   Codex32 allows the individual to periodically perform their\n   recollection on paper in a private room without electronics and use\n   nothing but a pen and some loookup tables (or a paper device) to\n   verify that they recalled the string correctly (and its checksum can\n   help with correcting up to several errors, although you might need a\n   computer for error location and correction assistance).\n\n- Hierarchy: Codex32 does not natively provide support for nested SSSS\n   whereas SLIP39 does.  E.g., in SLIP39, you can require 2-of-3 for\n   {me, family, friends} where me is 2-of-3 {fire_safe, bank_safe,\n   buried_in_woods}, family is 1-of-3 {alice, bob, carol}, and friends\n   are 2-of-5 {d, e, f, g, h}.  I assume you can do the same with Codex32\n   by using the share for one level as the secret for the next level,\n   although this is not described in the protocol.\n\n- Versioning: Codex32's metadata can store version information for\n   wallets that use implicit BIP32 paths (e.g. BIP44/49/84/86), although\n   this would cut into the space available for users to set their own\n   metadata and it is not specified in the draft BIP.  SLIP39 also\n   doesn't specify anything about implicit path versioning and, AFAICT,\n   doesn't have any room to store such metadata without reducing seed\n   entropy.\n\n- Plausible deniability dummy wallets: Codex32 doesn't support this;\n   SLIP39 does.  Much has been written by other people about whether\n   dummy wallets are a good idea or not, with strong opinions on both\n   sides, so maybe we can just leave it at that.\n\n---\n\nWhen I first saw the post about this, it was unclear to me that it was a\nserious project, but I've become increasingly interested as I researched\nit.  I'm not personally that interested in generating entropy from dice\nor encoding shares by hand---it's already imperative that I acquire a\ntrustworthy computer and load it with trustworthy software in order to\nuse my seed securely, so I might as well have it generate my seeds and \nmy\nrecovery codes for me.\n\nWhat really did catch my attention, but which was kind of buried in the\nproject documentation, is the ability to verify the integrity of each\nshare independently without using a computer.  For example, if I store a\nshare with some relative who lives thousands of kilometers away, I'll be\nable to take that share out of its tamper-evident bag on my annual\nholiday visit, verify that I can still read it accurately by validating\nits checksum, and put it into a new bag for another year.  For this\nprocedure, I don't need to bring copies of any of my other shares,\nallowing them (and my seed) to stay safe.\n\n---\n\nI do have one question after watching an excellent video[2] about the\nmotivation for this system.  In the video, one of the threat models\ndescribed is a disarrangement of the words in a metal backup system.\nThe implication seems to be that this would be an accidental\ndisarrangement, which obviously the Codex32 checksum would catch during\nperiodic offline verification.  But what about deliberate modification\nof a recovery code?  For example, Bob doesn't keep his seed loaded on\nany computer; it only exists in Codex32 shares which Bob plans to\ncombine together in 20 years when he retires, although he makes regular\ndeposits to the pubkeys derived from the seed's master xpub.  Mallory is\nable to obtain access to Bob's shares, allowing her to immediately steal\nhis current funds---but also allowing her to replace them with \nsimilar-looking\nshares with the same metadata and valid checksums so that Bob\ncontinues making deposits to the wallet.\n\nI'm curious about whether there's a way to prevent this attack without\notherwise compromising the properties of the code?  For example, some\nextra data that Bob can carry around (or memorize) for verifying the\nshares haven't changed, but which is not otherwise needed for recovery\n(so there's no problem if it's lost).\n\nThanks,\n\n-Dave\n\n[1] https://secretcodex32.com/faq/index.html\n[2] \nhttps://www.youtube.com/watch?v=kf48oPoiHX0&list=PLyOGyBytgcuQLi9DC5g88DOEGnqBDPmq1&index=2"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-19T22:12:51",
                "message_text_only": "On Sun, Feb 19, 2023 at 10:13:33AM -1000, David A. Harding wrote:\n> On 2023-02-16 03:49, Andrew Poelstra via bitcoin-dev wrote:\n> > the draft lists several benefits over SLIP-0039.\n> \n> The only benefit over SLIP39 that I see explicitly mentioned in the\n> draft BIP is \"simple enough for hand computation\".  In the FAQ[1] on the\n> project's website, I see some additional reasons:\n>\n\nOh, you're right! I think we removed this text in one of our revisions.\nI'll see if it makes sense to put it back.\n\n> | This scheme is essentially the same as SLIP39, with the following\n> differences:\n> |\n> | - The checksum is longer, slightly stronger, and designed to be\n> |   computable by hand.\n> |\n> | - Our encoding is more compact, giving us room for a bit of more\n> |   metadata, which is also designed to be readable by hand.\n> |\n> | - Unlike SLIP39, we do not support passphrases or hardening of any\n> |   form.\n> |\n> | - Unlike SLIP39, we have no hardware wallet support. But we hope that\n> |   will change!\n> \n\nThese are roughly the benefits -- a more compact encoding which is\nalways a fixed width. We also list \"not supporting features such as\npassphrases\" as a benefit, for users who don't need/want this.\n\n> <snip>\n> \n> When I first saw the post about this, it was unclear to me that it was a\n> serious project, but I've become increasingly interested as I researched\n> it.  I'm not personally that interested in generating entropy from dice\n> or encoding shares by hand---it's already imperative that I acquire a\n> trustworthy computer and load it with trustworthy software in order to\n> use my seed securely, so I might as well have it generate my seeds and my\n> recovery codes for me.\n>\n\nYes, we've been a bit coy about how serious this project is, because on\nits face it's such a silly thing. But for my part, I've been using it\nfor real coins for over a year and I consider it to be serious.\n\n> What really did catch my attention, but which was kind of buried in the\n> project documentation, is the ability to verify the integrity of each\n> share independently without using a computer.  For example, if I store a\n> share with some relative who lives thousands of kilometers away, I'll be\n> able to take that share out of its tamper-evident bag on my annual\n> holiday visit, verify that I can still read it accurately by validating\n> its checksum, and put it into a new bag for another year.  For this\n> procedure, I don't need to bring copies of any of my other shares,\n> allowing them (and my seed) to stay safe.\n> \n\nThis is good feedback. I strongly agree that this is the big selling\npoint for this -- that you can vet shares/seeds which *aren't* being\nactively used, without exposing them to the sorts of threats associated\nwith active use.\n\nWe should make this more prominent in the BIP motivation.\n\n> \n> I do have one question after watching an excellent video[2] about the\n> motivation for this system.  In the video, one of the threat models\n> described is a disarrangement of the words in a metal backup system.\n> The implication seems to be that this would be an accidental\n> disarrangement, which obviously the Codex32 checksum would catch during\n> periodic offline verification.  But what about deliberate modification\n> of a recovery code?  For example, Bob doesn't keep his seed loaded on\n> any computer; it only exists in Codex32 shares which Bob plans to\n> combine together in 20 years when he retires, although he makes regular\n> deposits to the pubkeys derived from the seed's master xpub.  Mallory is\n> able to obtain access to Bob's shares, allowing her to immediately steal\n> his current funds---but also allowing her to replace them with\n> similar-looking\n> shares with the same metadata and valid checksums so that Bob\n> continues making deposits to the wallet.\n> \n> I'm curious about whether there's a way to prevent this attack without\n> otherwise compromising the properties of the code?  For example, some\n> extra data that Bob can carry around (or memorize) for verifying the\n> shares haven't changed, but which is not otherwise needed for recovery\n> (so there's no problem if it's lost).\n>\n\nUnfortunately not, as near as I can tell ... one way to think of this is\nthat Alice can flip a lot of random tiles then \"error correct\" it to get\na new valid, but incorrect, seed. So as long as we support error\ncorrection it'll be possible to wreck seeds in this way.\n\nIt's actually even worse than this ... as long as there's a clearly\ndefined \"checksum\" at the end of a share, Alice will be able to mangele\ntiles and then just re-compute the checksum at the end.\n\nSo what we really need to prevent this is something like a MAC: where\nBob has a secret value which gets input into the checksum somehow, which\nAlice can't create valid checksums without knowing. Unfortunately I\ndon't see any way to do this with linear codes. With a hash-based\n\"checksum\" a la BIP39 it would definitely be possible, but of course,\nnot hand-computable.\n\nBTW, to execute this attack Alice doesn't need to compromise *all* the\nshares. Just enough that Bob no longer has threshold-many un-tampered\nones left.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/56f6c656/attachment-0001.sig>"
            },
            {
                "author": "Christopher Allen",
                "date": "2023-02-19T23:05:12",
                "message_text_only": "An easy but possibly very important tip:\n\nIf you use only UPPER CASE alpha and numbers in codex32, and avoid most\npunctuation, it makes QR rendering of it significantly smaller. This is\nbecause the QR code to the ISO SPEC, when seeing lowercase, assumes the\nvalue is binary, then converts it to a two byte value. If instead, the\ncodex32 is all upper, and it uses only the 45 allowed characters (see\nhttps://www.thonky.com/qr-code-tutorial/alphanumeric-table) , it will leave\nit single byte and try to compress it. Of course it doesn\u2019t compress well,\nbut that is OK because it at least didn\u2019t double the size first.\n\nSee our research on this topic at\nhttps://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-003-uri-binary-compatibility.md\n\nA superior QR codec can do better (see our\nhttps://github.com/BlockchainCommons/QRCodeGenerator or\nhttps://www.nayuki.io/page/qr-code-generator-library) but many platforms\nand more basic QR codecs will double the size of the QR if you have any\nlower case.\n\n\u2014 Christopher Allen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/34d9d295/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-20T00:52:36",
                "message_text_only": "On Sun, Feb 19, 2023 at 5:13 PM Andrew Poelstra via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sun, Feb 19, 2023 at 10:13:33AM -1000, David A. Harding wrote:\n>\n> I'm curious about whether there's a way to prevent this attack without\n> > otherwise compromising the properties of the code?  For example, some\n> > extra data that Bob can carry around (or memorize) for verifying the\n> > shares haven't changed, but which is not otherwise needed for recovery\n> > (so there's no problem if it's lost).\n> >\n>\n> Unfortunately not, as near as I can tell ... one way to think of this is\n> that Alice can flip a lot of random tiles then \"error correct\" it to get\n> a new valid, but incorrect, seed. So as long as we support error\n> correction it'll be possible to wreck seeds in this way.\n>\n> It's actually even worse than this ... as long as there's a clearly\n> defined \"checksum\" at the end of a share, Alice will be able to mangele\n> tiles and then just re-compute the checksum at the end.\n>\n> So what we really need to prevent this is something like a MAC: where\n> Bob has a secret value which gets input into the checksum somehow, which\n> Alice can't create valid checksums without knowing. Unfortunately I\n> don't see any way to do this with linear codes. With a hash-based\n> \"checksum\" a la BIP39 it would definitely be possible, but of course,\n> not hand-computable.\n>\n\nSpeaking off the cuff and as a non-cryptographer (i.e do NOT rush off and\ndo this without any vetting) but Christopher Allen once referred me to an\ncypher tile set called LS47 <https://gitea.blesmrt.net/exa/ls47>.  If we\nset aside the cypertext, I suspect we can form a MAC by recording some\nrandom initial tile configuration, running the LS47 algorithm, and\nrecording the final tile configuration.  These records are not sensitive as\n(presumably!) the share data is not recoverable from just knowing these two\nconfigurations.  So one can keep these records with you, digitally sign\nthem or whatever, and then take them to your share on a regular basis to\nrerun the LS47 algorithm to see if you still get the same final state from\nthe initial state.\n\nPerhaps something more specific to Bech32 could be designed, but otherwise\nthis (alleged) MAC process isn't Codex32 specific.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230219/7fa702ff/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2023-02-22T16:29:03",
                "message_text_only": "On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev wrote:\n> > What really did catch my attention, but which was kind of buried in the\n> > project documentation, is the ability to verify the integrity of each\n> > share independently without using a computer.  For example, if I store a\n> > share with some relative who lives thousands of kilometers away, I'll be\n> > able to take that share out of its tamper-evident bag on my annual\n> > holiday visit, verify that I can still read it accurately by validating\n> > its checksum, and put it into a new bag for another year.  For this\n> > procedure, I don't need to bring copies of any of my other shares,\n> > allowing them (and my seed) to stay safe.\n> > \n> \n> This is good feedback. I strongly agree that this is the big selling\n> point for this -- that you can vet shares/seeds which *aren't* being\n> actively used, without exposing them to the sorts of threats associated\n> with active use.\n> \n> We should make this more prominent in the BIP motivation.\n\nI don't think that use-case is a good selling point. The checksum that Codex32\nuses is much more complex than necessary if you are simply verifying a share by\nitself.\n\nA *much* simpler approach would be to use a simple mod N = 0 checksum, either\nby creating the seed such that each share passes, or by just storing an\nadditional word/symbol with the seed in such a way that sum(words) mod N = 0\npasses. This approach is not only possible to compute by hand with a\nword/symbol->number lookup table, and pen and paper or a calculator. It's so\nsimple they could probably *remember* how to do it themselves.\n\n\nSecondly, if all shares have mod N checksums, it may be sufficient for everyone\nto write down the checksums of the *other* shares, to verify they are the\ncorrect ones and a different (otherwise correct) share hasn't accidentally been\nsubstituted.\n\nIndeed, with some brute forcing and small checksums, I'd expect it to be\nmathematically possible to generate Shamir's secret sharing shards such that\nevery shard can share the *same* checksum. In which case the share verification\nprocedure would be to simply ask every share holder to verify the checksum\nmanually using the mod N procedure, and then verify that each share holder has\nthe same checksum. This would be less error prone in terms of leaking\ninformation accidentally if the checksum was obviously *not* part of the share:\neg by encoding the share with words, and the checksum with a number.\n\nObviously, small checksums aren't fool proof. But we're probably better off\ncreating a relatively easy procedure with a 1-in-1000 chance of an error going\nundetected than a complex procedure that people don't actually do at all.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/b56aa2ec/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-22T19:01:10",
                "message_text_only": "After some poking around at the math, I do see that the 13 character\ngenerator (for regular sized shares) is reasonably \"smooth\", having roots\nat T{11}, S{16}, and C{24}.\n\nThis means we could build a \"quick check\" worksheet to evaluate the string\nmodulo (x - T) to verify a 5 bit checksum, whose operation would be similar\nto the existing checksum worksheet in structure but significantly less work.\n\nPerhaps 5 bits is too short, and it is more reasonable working modulo (x -\nT)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum is\nalso an option, and possibly others well depending on the size of the other\nfactors.  I think this process is would be about as simple as any other\ncomparable hand operated checksum over the bech32 alphabet would be.\n\nI haven't looked into the smoothness of the long generator for seeds that\nare greater than 400 bits.  If it isn't smooth and smoother options are\navailable, perhaps it should be changed.\n\nOn Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev\n> wrote:\n> > > What really did catch my attention, but which was kind of buried in the\n> > > project documentation, is the ability to verify the integrity of each\n> > > share independently without using a computer.  For example, if I store\n> a\n> > > share with some relative who lives thousands of kilometers away, I'll\n> be\n> > > able to take that share out of its tamper-evident bag on my annual\n> > > holiday visit, verify that I can still read it accurately by validating\n> > > its checksum, and put it into a new bag for another year.  For this\n> > > procedure, I don't need to bring copies of any of my other shares,\n> > > allowing them (and my seed) to stay safe.\n> > >\n> >\n> > This is good feedback. I strongly agree that this is the big selling\n> > point for this -- that you can vet shares/seeds which *aren't* being\n> > actively used, without exposing them to the sorts of threats associated\n> > with active use.\n> >\n> > We should make this more prominent in the BIP motivation.\n>\n> I don't think that use-case is a good selling point. The checksum that\n> Codex32\n> uses is much more complex than necessary if you are simply verifying a\n> share by\n> itself.\n>\n> A *much* simpler approach would be to use a simple mod N = 0 checksum,\n> either\n> by creating the seed such that each share passes, or by just storing an\n> additional word/symbol with the seed in such a way that sum(words) mod N =\n> 0\n> passes. This approach is not only possible to compute by hand with a\n> word/symbol->number lookup table, and pen and paper or a calculator. It's\n> so\n> simple they could probably *remember* how to do it themselves.\n>\n>\n> Secondly, if all shares have mod N checksums, it may be sufficient for\n> everyone\n> to write down the checksums of the *other* shares, to verify they are the\n> correct ones and a different (otherwise correct) share hasn't accidentally\n> been\n> substituted.\n>\n> Indeed, with some brute forcing and small checksums, I'd expect it to be\n> mathematically possible to generate Shamir's secret sharing shards such\n> that\n> every shard can share the *same* checksum. In which case the share\n> verification\n> procedure would be to simply ask every share holder to verify the checksum\n> manually using the mod N procedure, and then verify that each share holder\n> has\n> the same checksum. This would be less error prone in terms of leaking\n> information accidentally if the checksum was obviously *not* part of the\n> share:\n> eg by encoding the share with words, and the checksum with a number.\n>\n> Obviously, small checksums aren't fool proof. But we're probably better off\n> creating a relatively easy procedure with a 1-in-1000 chance of an error\n> going\n> undetected than a complex procedure that people don't actually do at all.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/8b9500fc/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-23T03:30:10",
                "message_text_only": "After some consultation, I now see that generators for all degree 2 BCH\ncodes, such as ours, are smooth and factor into quadratic and linear\ncomponents.\n\nAnyhow the upshot of all this is that you can perform a \"quickcheck\"\nverification of the codex32 strings for whatever size of verification you\nwant to do, 1 character, 2 characters, 3 characters, upto the full 13\ncharacters.  Each of these partial verifications will have BCH properties.\nA 1 character quickchecksum will guarantee to detect any 1 character\nerror.  A 3 character quickchecksum will guarantee to detect any 2\ncharacter error, etc.  There remains a 1 in 32^n chance of failing to\ndetect larger numbers of errors where n is the size of your quickcheck.\n\nTo illustrate, let's consider a quickcheck of size 2.  This can detect any\n1 character error and will only have a 1/1024 chance of failing to detect\nother random errors.  Let's take the second test vector as our example: \"\nMS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM\"\n\nYou start in a specified initial state with a pair of bech32 characters.\nFor MS1 strings and a size 2 quickcheck it would be the pair of Bech32\ncharacters 'AS'.\n\nNext we \"add\" the first character after the prefix, which is '2' by using\nthe addition volvelle or lookup table.  \"Adding\" '2' to 'S' yields '6' and\nour state becomes 'A6'.\n\nNext we have to look up 'A6' in a lookup table.  This table is too big to\nfit in the margin of this email, so I will have to omit it.  But it would\nhave an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'\n\n>From this point we have an even number of remaining characters in the input\nstring and we can work 2 characters at a time. We \"add\" the next two data\ncharacters from our string, which are 'NA'.  Again, using the volvelle or\nlookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to\n'M' yields 'X'.  So our state is now 'NX'\n\nNext we look up 'NX' in this table I haven't given you and we will find an\nentry mapping 'NX' -> 'DX', making 'DX' our new state.\n\nWe keep repeating this process alternating between adding pairs of\ncharacters and using this unstated lookup table all the way until the end\nwhere we will reach a final state which will be 'H9'.\n\nIf you follow this procedure with any string (upto 400 bit master seeds)\nyou will always end up in the state 'H9'.\n\nA specialized worksheet would help guide the process making the process\neasier to follow.\n\n\nThis process is somewhat close to Peter Todd's suggestion of using a lookup\ntable on \"words\", which in this case would be pairs of bech32 characters,\nand adding values together.  The catch is that the addition is done with\nBech32 addition rather than calculator addition, which I accept is a\nmoderately large catch.\n\nAnyhow, the point is that you can do this sort of partial verification by\nhand to whatever degree you like, if you are in a rush and are willing to\naccept larger chances of failing to catch random errors.\n\n\nOn Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>\nwrote:\n\n> After some poking around at the math, I do see that the 13 character\n> generator (for regular sized shares) is reasonably \"smooth\", having roots\n> at T{11}, S{16}, and C{24}.\n>\n> This means we could build a \"quick check\" worksheet to evaluate the string\n> modulo (x - T) to verify a 5 bit checksum, whose operation would be similar\n> to the existing checksum worksheet in structure but significantly less work.\n>\n> Perhaps 5 bits is too short, and it is more reasonable working modulo (x -\n> T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum is\n> also an option, and possibly others well depending on the size of the other\n> factors.  I think this process is would be about as simple as any other\n> comparable hand operated checksum over the bech32 alphabet would be.\n>\n> I haven't looked into the smoothness of the long generator for seeds that\n> are greater than 400 bits.  If it isn't smooth and smoother options are\n> available, perhaps it should be changed.\n>\n> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via bitcoin-dev\n>> wrote:\n>> > > What really did catch my attention, but which was kind of buried in\n>> the\n>> > > project documentation, is the ability to verify the integrity of each\n>> > > share independently without using a computer.  For example, if I\n>> store a\n>> > > share with some relative who lives thousands of kilometers away, I'll\n>> be\n>> > > able to take that share out of its tamper-evident bag on my annual\n>> > > holiday visit, verify that I can still read it accurately by\n>> validating\n>> > > its checksum, and put it into a new bag for another year.  For this\n>> > > procedure, I don't need to bring copies of any of my other shares,\n>> > > allowing them (and my seed) to stay safe.\n>> > >\n>> >\n>> > This is good feedback. I strongly agree that this is the big selling\n>> > point for this -- that you can vet shares/seeds which *aren't* being\n>> > actively used, without exposing them to the sorts of threats associated\n>> > with active use.\n>> >\n>> > We should make this more prominent in the BIP motivation.\n>>\n>> I don't think that use-case is a good selling point. The checksum that\n>> Codex32\n>> uses is much more complex than necessary if you are simply verifying a\n>> share by\n>> itself.\n>>\n>> A *much* simpler approach would be to use a simple mod N = 0 checksum,\n>> either\n>> by creating the seed such that each share passes, or by just storing an\n>> additional word/symbol with the seed in such a way that sum(words) mod N\n>> = 0\n>> passes. This approach is not only possible to compute by hand with a\n>> word/symbol->number lookup table, and pen and paper or a calculator. It's\n>> so\n>> simple they could probably *remember* how to do it themselves.\n>>\n>>\n>> Secondly, if all shares have mod N checksums, it may be sufficient for\n>> everyone\n>> to write down the checksums of the *other* shares, to verify they are the\n>> correct ones and a different (otherwise correct) share hasn't\n>> accidentally been\n>> substituted.\n>>\n>> Indeed, with some brute forcing and small checksums, I'd expect it to be\n>> mathematically possible to generate Shamir's secret sharing shards such\n>> that\n>> every shard can share the *same* checksum. In which case the share\n>> verification\n>> procedure would be to simply ask every share holder to verify the checksum\n>> manually using the mod N procedure, and then verify that each share\n>> holder has\n>> the same checksum. This would be less error prone in terms of leaking\n>> information accidentally if the checksum was obviously *not* part of the\n>> share:\n>> eg by encoding the share with words, and the checksum with a number.\n>>\n>> Obviously, small checksums aren't fool proof. But we're probably better\n>> off\n>> creating a relatively easy procedure with a 1-in-1000 chance of an error\n>> going\n>> undetected than a complex procedure that people don't actually do at all.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/8bca8605/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-23T16:36:59",
                "message_text_only": "Sorry for the repeated replies, but I would like to make one more remark\nregarding the 1 character \"quick check\".\n\nBecause the 1 character \"quick check\" state is so small, the procedure\nbecomes simplified to just using a single table.  You start with the\nspecified initial state, which would be the bech32 character '9', and then\nyou have a lookup mapping (<current state>, <next input character>) ->\n<next state>.  You go through the table for each character after the\nprefix, updating the state as you go along. ('9','2') -> '0', then\n('0','N') -> '4', and so on until you reach the final state which should be\n'5'.  If you like volvelles, one could be designed to implement this lookup\ntable.\n\nHowever, I do want to note that an adjustment could be made to the codex32\ngenerator so that this 1 character \"quick check\" table would become\nidentical to the Bech32 addition table.  In other words the 1 character\nquick check would become the same as adding up all the characters and\nchecking that you get the required final constant.\n\nIf this change were free to make, I would probably make it.  However such\nan adjustment would come at a cost.  The current generator was chosen to\nhave three identical coefficients in a row (you can find the generator in\nthe appendix of the draft BIP).  This special property slightly eases the\ncomputation needed when creating checksums by hand (no compromise to the\nquality of the checksum itself).  If we made the above adjustment to the\ncodex32 generator, we would lose this property of having three identical\ncoefficients in a row.\n\nTherefore, I am pretty hesitant to make this adjustment.  Firstly the 1\ncharacter quick check is simply too small to be safely used.  While it does\nguarantee to detect single character errors, it has a 1 in 32 chance of\nfailing to detect more errors.  I think a 3% failure rate is pretty bad,\nand would definitely recommend people performing quick checks use a minimum\nsize of 2 (which has a 0.1% failure rate).  Secondly the difference between\nusing the addition table/volvelle versus a specific table/volvelle for the\npurpose of performing 1 character quick checks (which you ought not to be\ndoing anyways) is pretty minimal.  The addition table is possibly slightly\nless error prone to use because it is symmetric, but other than that the\namount of work to do is pretty much the same either way.\n\nMy conclusion is that it isn't worth compromising the ease of hand\ncomputation for the sake of possibly making a\ntoo-low-quality-checksum-that-no-one-should-be-using slightly more\nconvenient, but I thought I should mention it at least.\n\n\nOn Wed, Feb 22, 2023 at 10:30 PM Russell O'Connor <roconnor at blockstream.com>\nwrote:\n\n> After some consultation, I now see that generators for all degree 2 BCH\n> codes, such as ours, are smooth and factor into quadratic and linear\n> components.\n>\n> Anyhow the upshot of all this is that you can perform a \"quickcheck\"\n> verification of the codex32 strings for whatever size of verification you\n> want to do, 1 character, 2 characters, 3 characters, upto the full 13\n> characters.  Each of these partial verifications will have BCH properties.\n> A 1 character quickchecksum will guarantee to detect any 1 character\n> error.  A 3 character quickchecksum will guarantee to detect any 2\n> character error, etc.  There remains a 1 in 32^n chance of failing to\n> detect larger numbers of errors where n is the size of your quickcheck.\n>\n> To illustrate, let's consider a quickcheck of size 2.  This can detect any\n> 1 character error and will only have a 1/1024 chance of failing to detect\n> other random errors.  Let's take the second test vector as our example: \"\n> MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM\"\n>\n> You start in a specified initial state with a pair of bech32 characters.\n> For MS1 strings and a size 2 quickcheck it would be the pair of Bech32\n> characters 'AS'.\n>\n> Next we \"add\" the first character after the prefix, which is '2' by using\n> the addition volvelle or lookup table.  \"Adding\" '2' to 'S' yields '6' and\n> our state becomes 'A6'.\n>\n> Next we have to look up 'A6' in a lookup table.  This table is too big to\n> fit in the margin of this email, so I will have to omit it.  But it would\n> have an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'\n>\n> From this point we have an even number of remaining characters in the\n> input string and we can work 2 characters at a time. We \"add\" the next two\n> data characters from our string, which are 'NA'.  Again, using the volvelle\n> or lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to\n> 'M' yields 'X'.  So our state is now 'NX'\n>\n> Next we look up 'NX' in this table I haven't given you and we will find an\n> entry mapping 'NX' -> 'DX', making 'DX' our new state.\n>\n> We keep repeating this process alternating between adding pairs of\n> characters and using this unstated lookup table all the way until the end\n> where we will reach a final state which will be 'H9'.\n>\n> If you follow this procedure with any string (upto 400 bit master seeds)\n> you will always end up in the state 'H9'.\n>\n> A specialized worksheet would help guide the process making the process\n> easier to follow.\n>\n>\n> This process is somewhat close to Peter Todd's suggestion of using a\n> lookup table on \"words\", which in this case would be pairs of bech32\n> characters, and adding values together.  The catch is that the addition is\n> done with Bech32 addition rather than calculator addition, which I accept\n> is a moderately large catch.\n>\n> Anyhow, the point is that you can do this sort of partial verification by\n> hand to whatever degree you like, if you are in a rush and are willing to\n> accept larger chances of failing to catch random errors.\n>\n>\n> On Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>\n> wrote:\n>\n>> After some poking around at the math, I do see that the 13 character\n>> generator (for regular sized shares) is reasonably \"smooth\", having roots\n>> at T{11}, S{16}, and C{24}.\n>>\n>> This means we could build a \"quick check\" worksheet to evaluate the\n>> string modulo (x - T) to verify a 5 bit checksum, whose operation would be\n>> similar to the existing checksum worksheet in structure but significantly\n>> less work.\n>>\n>> Perhaps 5 bits is too short, and it is more reasonable working modulo (x\n>> - T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum\n>> is also an option, and possibly others well depending on the size of the\n>> other factors.  I think this process is would be about as simple as any\n>> other comparable hand operated checksum over the bech32 alphabet would be.\n>>\n>> I haven't looked into the smoothness of the long generator for seeds that\n>> are greater than 400 bits.  If it isn't smooth and smoother options are\n>> available, perhaps it should be changed.\n>>\n>> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via\n>>> bitcoin-dev wrote:\n>>> > > What really did catch my attention, but which was kind of buried in\n>>> the\n>>> > > project documentation, is the ability to verify the integrity of each\n>>> > > share independently without using a computer.  For example, if I\n>>> store a\n>>> > > share with some relative who lives thousands of kilometers away,\n>>> I'll be\n>>> > > able to take that share out of its tamper-evident bag on my annual\n>>> > > holiday visit, verify that I can still read it accurately by\n>>> validating\n>>> > > its checksum, and put it into a new bag for another year.  For this\n>>> > > procedure, I don't need to bring copies of any of my other shares,\n>>> > > allowing them (and my seed) to stay safe.\n>>> > >\n>>> >\n>>> > This is good feedback. I strongly agree that this is the big selling\n>>> > point for this -- that you can vet shares/seeds which *aren't* being\n>>> > actively used, without exposing them to the sorts of threats associated\n>>> > with active use.\n>>> >\n>>> > We should make this more prominent in the BIP motivation.\n>>>\n>>> I don't think that use-case is a good selling point. The checksum that\n>>> Codex32\n>>> uses is much more complex than necessary if you are simply verifying a\n>>> share by\n>>> itself.\n>>>\n>>> A *much* simpler approach would be to use a simple mod N = 0 checksum,\n>>> either\n>>> by creating the seed such that each share passes, or by just storing an\n>>> additional word/symbol with the seed in such a way that sum(words) mod N\n>>> = 0\n>>> passes. This approach is not only possible to compute by hand with a\n>>> word/symbol->number lookup table, and pen and paper or a calculator.\n>>> It's so\n>>> simple they could probably *remember* how to do it themselves.\n>>>\n>>>\n>>> Secondly, if all shares have mod N checksums, it may be sufficient for\n>>> everyone\n>>> to write down the checksums of the *other* shares, to verify they are the\n>>> correct ones and a different (otherwise correct) share hasn't\n>>> accidentally been\n>>> substituted.\n>>>\n>>> Indeed, with some brute forcing and small checksums, I'd expect it to be\n>>> mathematically possible to generate Shamir's secret sharing shards such\n>>> that\n>>> every shard can share the *same* checksum. In which case the share\n>>> verification\n>>> procedure would be to simply ask every share holder to verify the\n>>> checksum\n>>> manually using the mod N procedure, and then verify that each share\n>>> holder has\n>>> the same checksum. This would be less error prone in terms of leaking\n>>> information accidentally if the checksum was obviously *not* part of the\n>>> share:\n>>> eg by encoding the share with words, and the checksum with a number.\n>>>\n>>> Obviously, small checksums aren't fool proof. But we're probably better\n>>> off\n>>> creating a relatively easy procedure with a 1-in-1000 chance of an error\n>>> going\n>>> undetected than a complex procedure that people don't actually do at all.\n>>>\n>>> --\n>>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230223/0526acda/attachment.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-23T18:26:17",
                "message_text_only": "One more thing (Again apologies. This idea of doing partial verification is\nnovel to me, and I see now that I should have just waited to give a\nconsolidated reply).\n\nFocusing in on the example of performing 2 character quick checks.  There\nare 7 different ways of building the table used in this quick check\nverification process (actually there are 8, but we only need 7 of them for\nour purposes here).  Fun fact: If you perform the 2 character quick check\nin all 7 different ways, this is equivalent to doing a full checksum\nverification.\n\nThis suggests a strategy of visiting your shares on a regular basis and\nperforming a different 2 character quick check each time, rotating through\nthe 7 different ways of performing it.\n\nMoreover, these 7 different 2 character quick checks come with a prescribed\norder that will accumulate BCH guarantees as you go along.  Assuming the\nstring isn't changing between visits then\n\n* After the 1st table you are guaranteed to detect any 1 character error.\n* After the 2nd table you are guaranteed to detect any 2 character error.\n* After the 3rd table you are guaranteed to detect any 4 character error.\n* After the 4th table you are guaranteed to detect any 5 character error.\n* After the 5th table you are guaranteed to detect any 6 character error.\n* After the 6th table you are guaranteed to detect any 7 character error.\n* After the 7th table you are guaranteed to detect any 8 character error,\nwhich is the guarantee of the full 13 character checksum.  You are also\nguaranteed that the full 13 character checksum is now correct.\n\nYou could perform the checks out of order, and that is okay.  You will\neventually reach these BCH levels of guarantees, just not as quickly as if\nyou follow the prescribed order.\n\nOf course, doing a series of 7 different 2 character quick checks is\noverall more work than doing the full 13 character checksum validation.\nBut there is certainly an advantage in spreading the work out over time.\nEach time you visit you still have the guarantee of catching any new 1\ncharacter error introduced since the last time you visited and a 99.9%\nchance of catching any other random errors introduced since your last\nvisit.  Personally I am likely to follow such a validation strategy myself,\nnow that I am aware of it.\n\n\nOn Wed, Feb 22, 2023 at 10:30 PM Russell O'Connor <roconnor at blockstream.com>\nwrote:\n\n> After some consultation, I now see that generators for all degree 2 BCH\n> codes, such as ours, are smooth and factor into quadratic and linear\n> components.\n>\n> Anyhow the upshot of all this is that you can perform a \"quickcheck\"\n> verification of the codex32 strings for whatever size of verification you\n> want to do, 1 character, 2 characters, 3 characters, upto the full 13\n> characters.  Each of these partial verifications will have BCH properties.\n> A 1 character quickchecksum will guarantee to detect any 1 character\n> error.  A 3 character quickchecksum will guarantee to detect any 2\n> character error, etc.  There remains a 1 in 32^n chance of failing to\n> detect larger numbers of errors where n is the size of your quickcheck.\n>\n> To illustrate, let's consider a quickcheck of size 2.  This can detect any\n> 1 character error and will only have a 1/1024 chance of failing to detect\n> other random errors.  Let's take the second test vector as our example: \"\n> MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM\"\n>\n> You start in a specified initial state with a pair of bech32 characters.\n> For MS1 strings and a size 2 quickcheck it would be the pair of Bech32\n> characters 'AS'.\n>\n> Next we \"add\" the first character after the prefix, which is '2' by using\n> the addition volvelle or lookup table.  \"Adding\" '2' to 'S' yields '6' and\n> our state becomes 'A6'.\n>\n> Next we have to look up 'A6' in a lookup table.  This table is too big to\n> fit in the margin of this email, so I will have to omit it.  But it would\n> have an entry mapping 'A6' -> 'QM'.  Our state becomes 'QM'\n>\n> From this point we have an even number of remaining characters in the\n> input string and we can work 2 characters at a time. We \"add\" the next two\n> data characters from our string, which are 'NA'.  Again, using the volvelle\n> or lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to\n> 'M' yields 'X'.  So our state is now 'NX'\n>\n> Next we look up 'NX' in this table I haven't given you and we will find an\n> entry mapping 'NX' -> 'DX', making 'DX' our new state.\n>\n> We keep repeating this process alternating between adding pairs of\n> characters and using this unstated lookup table all the way until the end\n> where we will reach a final state which will be 'H9'.\n>\n> If you follow this procedure with any string (upto 400 bit master seeds)\n> you will always end up in the state 'H9'.\n>\n> A specialized worksheet would help guide the process making the process\n> easier to follow.\n>\n>\n> This process is somewhat close to Peter Todd's suggestion of using a\n> lookup table on \"words\", which in this case would be pairs of bech32\n> characters, and adding values together.  The catch is that the addition is\n> done with Bech32 addition rather than calculator addition, which I accept\n> is a moderately large catch.\n>\n> Anyhow, the point is that you can do this sort of partial verification by\n> hand to whatever degree you like, if you are in a rush and are willing to\n> accept larger chances of failing to catch random errors.\n>\n>\n> On Wed, Feb 22, 2023 at 2:01 PM Russell O'Connor <roconnor at blockstream.com>\n> wrote:\n>\n>> After some poking around at the math, I do see that the 13 character\n>> generator (for regular sized shares) is reasonably \"smooth\", having roots\n>> at T{11}, S{16}, and C{24}.\n>>\n>> This means we could build a \"quick check\" worksheet to evaluate the\n>> string modulo (x - T) to verify a 5 bit checksum, whose operation would be\n>> similar to the existing checksum worksheet in structure but significantly\n>> less work.\n>>\n>> Perhaps 5 bits is too short, and it is more reasonable working modulo (x\n>> - T)*(x - S) to get a 10 bit checksum.  A worksheet for a 15 bit checksum\n>> is also an option, and possibly others well depending on the size of the\n>> other factors.  I think this process is would be about as simple as any\n>> other comparable hand operated checksum over the bech32 alphabet would be.\n>>\n>> I haven't looked into the smoothness of the long generator for seeds that\n>> are greater than 400 bits.  If it isn't smooth and smoother options are\n>> available, perhaps it should be changed.\n>>\n>> On Wed, Feb 22, 2023 at 11:29 AM Peter Todd via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Sun, Feb 19, 2023 at 10:12:51PM +0000, Andrew Poelstra via\n>>> bitcoin-dev wrote:\n>>> > > What really did catch my attention, but which was kind of buried in\n>>> the\n>>> > > project documentation, is the ability to verify the integrity of each\n>>> > > share independently without using a computer.  For example, if I\n>>> store a\n>>> > > share with some relative who lives thousands of kilometers away,\n>>> I'll be\n>>> > > able to take that share out of its tamper-evident bag on my annual\n>>> > > holiday visit, verify that I can still read it accurately by\n>>> validating\n>>> > > its checksum, and put it into a new bag for another year.  For this\n>>> > > procedure, I don't need to bring copies of any of my other shares,\n>>> > > allowing them (and my seed) to stay safe.\n>>> > >\n>>> >\n>>> > This is good feedback. I strongly agree that this is the big selling\n>>> > point for this -- that you can vet shares/seeds which *aren't* being\n>>> > actively used, without exposing them to the sorts of threats associated\n>>> > with active use.\n>>> >\n>>> > We should make this more prominent in the BIP motivation.\n>>>\n>>> I don't think that use-case is a good selling point. The checksum that\n>>> Codex32\n>>> uses is much more complex than necessary if you are simply verifying a\n>>> share by\n>>> itself.\n>>>\n>>> A *much* simpler approach would be to use a simple mod N = 0 checksum,\n>>> either\n>>> by creating the seed such that each share passes, or by just storing an\n>>> additional word/symbol with the seed in such a way that sum(words) mod N\n>>> = 0\n>>> passes. This approach is not only possible to compute by hand with a\n>>> word/symbol->number lookup table, and pen and paper or a calculator.\n>>> It's so\n>>> simple they could probably *remember* how to do it themselves.\n>>>\n>>>\n>>> Secondly, if all shares have mod N checksums, it may be sufficient for\n>>> everyone\n>>> to write down the checksums of the *other* shares, to verify they are the\n>>> correct ones and a different (otherwise correct) share hasn't\n>>> accidentally been\n>>> substituted.\n>>>\n>>> Indeed, with some brute forcing and small checksums, I'd expect it to be\n>>> mathematically possible to generate Shamir's secret sharing shards such\n>>> that\n>>> every shard can share the *same* checksum. In which case the share\n>>> verification\n>>> procedure would be to simply ask every share holder to verify the\n>>> checksum\n>>> manually using the mod N procedure, and then verify that each share\n>>> holder has\n>>> the same checksum. This would be less error prone in terms of leaking\n>>> information accidentally if the checksum was obviously *not* part of the\n>>> share:\n>>> eg by encoding the share with words, and the checksum with a number.\n>>>\n>>> Obviously, small checksums aren't fool proof. But we're probably better\n>>> off\n>>> creating a relatively easy procedure with a 1-in-1000 chance of an error\n>>> going\n>>> undetected than a complex procedure that people don't actually do at all.\n>>>\n>>> --\n>>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230223/4b73d4e8/attachment-0001.html>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2023-02-22T17:24:19",
                "message_text_only": "On Sun, Feb 19, 2023 at 3:13 PM David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>    Codex32 allows the individual to periodically perform their\n>    recollection on paper in a private room without electronics and use\n>    nothing but a pen and some loookup tables (or a paper device) to\n>    verify that they recalled the string correctly (and its checksum can\n>    help with correcting up to several errors, although you might need a\n>    computer for error location and correction assistance).\n>\n\nWhile perhaps not entirely impossible, doing error correction by hand is\nfar more difficult than just the error detection process.\nFortunately, error correction can be aided by a computer needing very\nlittle trust.\n\nWhen doing hand computation of the checksum, there is an error if the final\n\"residue\" is different from the value given in the codex32 spec.\nAfter double checking your hand computation by redoing it, if you still get\nthe same incorrect residue, there is an error in your share data somewhere.\n\nWhat you can do is plug in the residue that you did compute into a\ncomputer, and have it produce an error correction string.\nYou can then, by hand, add this error correction string to your share to\nget a corrected share.\n\nIf it were the case that all types of character errors were equally likely\n(as in during an error any character is equally likely to be transformed\ninto any other character), then the computer would gain zero information\nabout your actual share data.  Of course, it is not in fact the case that\nall transcription errors are equally likely, and so the computer can learn\na little bit about your share. The fewer errors that are made, the less\ndata it can recover. If you only have one character in error, then 5 bits\nis the most data it can recover, and that is assuming that it can somehow\ninfer your error perfectly from the delta of the error correction, which\nisn't actually going to be the case.\n\nOf course, a single share from a split secret has no information about your\nmaster seed (the master seed is hidden in the correlation between different\nshares).  So learning partial information about one share isn't going to be\nenough by itself to even begin compromising your master key.\n\nThis all still needs to be written up in more detail, but I figured I would\ngive a preview here.\n\n- Hierarchy: Codex32 does not natively provide support for nested SSSS\n>    whereas SLIP39 does.  E.g., in SLIP39, you can require 2-of-3 for\n>    {me, family, friends} where me is 2-of-3 {fire_safe, bank_safe,\n>    buried_in_woods}, family is 1-of-3 {alice, bob, carol}, and friends\n>    are 2-of-5 {d, e, f, g, h}.  I assume you can do the same with Codex32\n>    by using the share for one level as the secret for the next level,\n>    although this is not described in the protocol.\n>\n\nThere was a design for a second level share scheme floating around\nsomewhere. I'll have to dig it up. As I recall this is made slightly more\ncomplicated by needing to incorporate share metadata (i.e. the share index)\nwhen doing a second split, but it seemed doable at the time.\n\n\n> - Versioning: Codex32's metadata can store version information for\n>    wallets that use implicit BIP32 paths (e.g. BIP44/49/84/86), although\n>    this would cut into the space available for users to set their own\n>    metadata and it is not specified in the draft BIP.  SLIP39 also\n>    doesn't specify anything about implicit path versioning and, AFAICT,\n>    doesn't have any room to store such metadata without reducing seed\n>    entropy.\n>\n\nPersonally, I don't consider the derivation path / descriptor data as that\nsensitive, and I would recommend making wide backups of that data.\nIt certainly would make sense to store descriptor data alongside wherever\nyou keep your shares, and more places beyond that.\nOn the other hand, if you are trying to keep your shares innocuous somehow,\nperhaps you won't be able to keep the descriptor data alongside your shares.\n\nWhen I first saw the post about this, it was unclear to me that it was a\n> serious project, but I've become increasingly interested as I researched\n> it.  I'm not personally that interested in generating entropy from dice\n> or encoding shares by hand---it's already imperative that I acquire a\n> trustworthy computer and load it with trustworthy software in order to\n> use my seed securely, so I might as well have it generate my seeds and\n> my\n> recovery codes for me.\n>\n\nI do think hardware wallets are great, and overall provide a lot of\npractical protection.  What is notable is that once the secrets are loaded\nonto a hardware wallet, as long as that wallet remains isolated, it cannot\nleak any secrets.\n\nOf course, a wallet needs to interact with the Bitcoin protocol and P2P\nnetwork, at least indirectly, in order to  function, so we must break that\nisolation.  However, if we can limit the communication capabilities of a\nhardware wallet, even a malicious wallet shouldn't be able to leak the\nsecret data.\n\nThere are three main vectors a hardware wallet can try to communicate that\nI am aware of:\n\n1. Compromise at seed/master secret (or in this case shares of the master\nsecret) during generation time.\n2. Lie about public keys at public key generation time.\n3. Exfiltrate data though signature data or otherwise during signature\ngeneration time.\n\n#3 is largely mitigated through using anti-exfil signing and air gapping\nthe hardware wallet (e.g. using QR codes, or using RS-232\n<https://en.wikipedia.org/wiki/RS-232> if you consider that air gaping).\nUsing multiple wallets from different vendors doing deterministic signing\nis another possibility, but I consider the method deprecated in favour of\nanti-exfil.\n\nAddressing #1 is where codex32 lies, by taking master secret handling\nfunctions out of the hardware wallet.\n\nMy understanding is that it is difficult for digital hardware, which tries\nvery hard to be deterministic, to generate randomness, especially for\nisolated hardware devices like hardware wallets.\nAlso it is hard for hardware to tell if their hardware random number\ngenerator is broken.  Generally I don't trust small pieces of isolated\ndigital hardware to generate master seeds, even when they are not\nmalicious. This may just be due to my ignorance of how they operate.\n\n#2 seems to be the hardest issue to address.  My current thinking is to\ngenerate addresses on a diverse set of hardware and/or using public\nderivations.\nPerhaps an alternative to BIP-32 could be designed to make it easy to\ngenerate zero-knowledge proofs of pubkey derivations.\n\nOf course there are other ways for a hardware wallets to exfiltrate data:\nThe wallet can blink lights, make noise, or it can try to use radio\nbroadcasts, etc.  These other attack vectors seem to require physically\nlocal support, which is a fairly big hurdle to overcome.  I suppose even\nthese vectors could be mitigated through various levels of tinfoil.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230222/041a5132/attachment-0001.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2023-02-20T18:44:36",
                "message_text_only": "On Wed, Feb 15, 2023 at 09:16:02PM -0500, Russell O'Connor via bitcoin-dev wrote:\n> I've been asked by Dr. Curr and Professor Snead to forward this message to\n> this mailing list, as it may be of general interest to Bitcoin users.\n>\n> <snip>\n>\n\nI have opened a PR to the BIPs repo for this scheme: https://github.com/bitcoin/bips/pull/1425\n\nThanks very much to Pavol Rusnak, David Harding, and Christopher Allen\nfor their comments on this list. We've updated the draft text to try to\naddress your concerns. In particular:\n\n  * Added more text to \"Motivation\" distinguishing the scheme from SLIP-39\n  * Added more details to \"Rationale\"  about error correction capabilities\n    of the code, and to explain that the code does not defend against\n    malicious errors\n  * Added a note to use uppercase for QR codes\n  * Rearranged and clarified the \"creating shares\" instructions\n  * Added text about hand-computation, in particular hand-computation\n    of share verification, to \"Motivation\".\n\nIf any of you would like to be listed under Acknowledgements, please let\nme know here or on the PR.\n\n\nCheers\nAndrew\n\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230220/38465703/attachment.sig>"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2023-02-20T18:48:32",
                "message_text_only": "Thanks Andrew!\n\nNew draft makes it much more obvious what are the differences between\nCodex32 and SLIP-0039 scheme.\n-- \nBest Regards / S pozdravom,\n\nPavol \"Stick\" Rusnak\nCo-Founder, SatoshiLabs\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230220/3b001b72/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Codex32",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Christopher Allen",
                "David A. Harding",
                "Pavol Rusnak",
                "Peter Todd",
                "Russell O'Connor",
                "Andrew Poelstra"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 122879
        }
    },
    {
        "title": "[bitcoin-dev] Refreshed BIP324",
        "thread_messages": [
            {
                "author": "Dhruv M",
                "date": "2023-02-16T17:43:22",
                "message_text_only": "Attempting to summarize the thread thus far:\n\nProblem:\n\n- 1 byte message type IDs are lacking a co-ordination mechanism when multiple in-flight BIPs are proposing new message types as the id space is reduced form 12 ASCII bytes to 1 byte.\n- 1 byte IDs are scarce and should be allocated judiciously, especially given that gains on bandwidth are very much non-uniform across message types.\n\nSolutions:\n\n- Uniform encoding using the high-bit increases the available ID space drastically, however, there's still the issue of making sure that the most frequent message types get the shorter IDs.\n- Making type IDs negotiable(editable, really) per direction per connection solves that issue at the cost of some increased complexity.\n\nSince we don't really know the extent to which the protocol will ossify over time and that BIP324 is already quite a large change, we might want to optimize for the least additional complexity that doesn't close the doors on any of the solutions. How about this:\n\n- BIP324 restricts type IDs to [1, 127]\n- We remove 1 byte allocations for messages that are sent at most once per connection per direction\n- Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.\n\nBest,\n\n-Dhruv\n\nOn 1/9/23 00:11, Anthony Towns via bitcoin-dev wrote:\n\n> On Fri, Jan 06, 2023 at 09:12:50AM +1000, Anthony Towns via bitcoin-dev wrote:\n>\n>> On Thu, Jan 05, 2023 at 10:06:29PM +0000, Pieter Wuille via bitcoin-dev wrote:\n>>\n>>> Oh, yes. I meant this as an encoding scheme, not as a (replacement for) the negotiation/coordination mechanism. There could still be an initial assignment for 1-byte encodings, and/or an explicit mechanism to negotiate other assignment, and/or nothing at all for now.\n>\n>> The current implementation for 324 does the aliasing\n>> as part of V2TransportDeserializer::GetMessage and\n>> V2TransportSerializer::prepareForTransport. That makes a lot of sense,\n>> [...]\n>\n> So I think you can make this setup work with a negotiated assignment of\n> shortids, perhaps starting off something like:\n> https://github.com/ajtowns/bitcoin/commit/6b8edd754bdcb582e293e4f5d0b41297711bdbb7\n> That has a 242 element array per peer giving the mappings (which\n> is just ~250 bytes per peer) for deserialization, which seems\n> workable. [0]\n>\n> It also has a single global map for serialization, so we'll always shorten\n> CFILTER to shortid 39 for every peer that supports shortids, even, eg, for\n> a peer who's told us they'll send CFILTER as shortid 99 and that we should\n> interpret shortid 39 from them as NEWFEATUREX. That has three advantages:\n>\n>  * each peer can choose a mapping that minimises their own outbound\n>    traffic, even potentially for asymmetric connections, and don't need\n>    to coordinate with the other peer to decide a common optimal mapping\n>    that they both use across their connection\n>\n>  * you don't have to have different serialization tables per-peer,\n>    reducing memory usage / implementation complexity\n>\n>  * you can leave V2TransportSerializer as a `const` object, and not have\n>    to introduce additional locking logic to be able to update its\n>    state...\n>\n> I'm not seeing a good way to introduce shortids for future one-shot\n> negotiation messages though (like VERSION, VERACK, SENDADDRV2,\n> WTXIDRELAY, SENDTXRCNCL):\n>\n>  * if you explicitly announce the mapping first, you're just wasting\n>    bytes (\"99=FOOBAR; 99 baz quux\" vs just \"FOOBAR baz quux\")\n>  * if you negotiate the tables you support between VERSION/VERACK and\n>    then choose a mutually supported table after VERACK, that's too late\n>    for pre-VERACK negotation messages\n>  * announcing the tables you support as part of the VERSION message\n>    would work, but seems a bit klunky\n>\n> Also, if you did want to shift to a new table, you'd probably want to\n> always support sending/receiving {37, 44, 46, 47, 36} messages?\n>\n> I guess I still kind-of think it'd make more sense to just reserve\n> shortids for post-VERACK messages that are going to be sent more\n> than once per connection... At that point, even if you don't have any\n> table in common with your peer, just following VERACK with an immediate\n> announcement of each shortid you want to use and its meaning would still\n> make reasonable sense.\n>\n> If we included the ability to define your own shortids concurrently\n> with bip324 rollout, then I think nodes could always have a static set\n> of shortids they use for all their peers for outbound messages, which,\n> as above, seems like it would make for simpler implementations.\n>\n> ie, you might send:\n>\n>    VERSION\n>    SHORTIDTBLS [\"\",\"awesomeshortids\"]\n>    WTXIDRELAY\n>    SENDADDRV2\n>    SENDPACKAGES 1\n>    VERACK\n>    SHORTID \"\" [(52,\"getpkgtxns\"), (53, \"pkgtxns\"), (54, \"ancpkginfo\")]\n>\n> ...but you'd do all that long form, and only switch to shortids for\n> messages after you've declared exactly what your shortids are going to\n> be.\n>\n> (where \"\" is the table name for bip324's table, and \"awesomeshortids\"\n> is an updated table that includes the package relay commands already,\n> perhaps)\n>\n> Cheers,\n> aj\n>\n> [0] m_deserializer is used from the SocketHandler thread in\n>     CNode::ReceiveMsgBytes(), but the p2p protocol is managed from the\n>     MessageHandler thread; with multiple messages potentially deserialized\n>     into vRecvMsg() at once -- but that means that if the first message\n>     redefines shortid decoding, and the second message uses one of the\n>     redefined shortids, it will have already been decoded incorrectly.\n>     So that would need some futzing about still.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230216/43ace413/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-17T15:51:19",
                "message_text_only": "On Thu, Feb 16, 2023 at 05:43:22PM +0000, Dhruv M via bitcoin-dev wrote:\n> Problem:\n> - 1 byte message type IDs are lacking a co-ordination mechanism when multiple in-flight BIPs are proposing new message types as the id space is reduced form 12 ASCII bytes to 1 byte.\n> - 1 byte IDs are scarce and should be allocated judiciously, especially given that gains on bandwidth are very much non-uniform across message types.\n\nACK.\n\n> Solutions:\n> - Uniform encoding using the high-bit increases the available ID space drastically, however, there's still the issue of making sure that the most frequent message types get the shorter IDs.\n> - Making type IDs negotiable(editable, really) per direction per connection solves that issue at the cost of some increased complexity.\n> \n> Since we don't really know the extent to which the protocol will ossify over time and that BIP324 is already quite a large change, we might want to optimize for the least additional complexity that doesn't close the doors on any of the solutions. \n\nI think it's probably less complex to close *some* of the doors?\n\nIn particular, I think there's two questions that have to get answered:\n\n 1) how do you distinguish the command from the payload for\n    non short-ids -- by a length prefix, or by setting the high-bit\n    of the final command byte?\n\n 2) are short ids available/meaningful to send prior to VERACK being\n    completed?\n\n> How about this:\n> - BIP324 restricts type IDs to [1, 127]\n\nIs this for short ids (currently [13-255] per the bip) or for every byte\nin a non-short-id command (for p2p v1, IsCommandValid() restricts each\nbyte to being in the printable ascii range, ie [32-126])?\n\nHere's another approach:\n\n idea: we use short ids to minimise bandwidth, and don't care about\n       bandwidth for long ids\n\n implementation:\n       short id 0 is reserved for long commands. when received, we\n       decode the first 12 bytes of the payload and treat them\n       exactly the same as a v1 p2p message (trailing 0-bytes, etc)\n       (if there's not 12 bytes of payload, it's just treated as an\n       invalid command and dropped)\n\n       short ids 1-255 are available for use as aliases of particular\n       long commands\n\n(That's exactly compatible with p2p v1, and also avoids the temptation\nto try to choose short command names rather than descriptive ones -- the\n0-padding to 12 bytes prevents you from saving any bandwidth that way;\nbut that's what we have short ids for anyway)\n\nIf we decide we want >255 short ids, we can figure out how to extend\nthem later, in a fairly open ended way I think, eg by having [128-255]\nimply a 2 byte short id, so that seems fine?\n\n> - We remove 1 byte allocations for messages that are sent at most once per connection per direction\n\nI think this leaves 32 commands that get short ids initially:\n\n    misc: ADDR, ADDRV2, BLOCK, FEEFILTER, GETBLOCKS, GETDATA, GETHEADERS,\n          HEADERS, INV, NOTFOUND, PING, PONG, TX\n    bip 35/37: FILTERADD, FILTERCLEAR, FILTERLOAD, MEMPOOL, MERKLEBLOCK\n    bip 152: BLOCKTXN, CMPCTBLOCK, GETBLOCKTXN\n    bip 157: CFCHECKPT, CFHEADERS, CFILTER, GETCFCHCKPT, GETCFHEADERS,\n        GETCFILTERS\n    bip 330: RECONCILDIFF, REQRECON, REQSKETCHEXT, SENDCMPCT, SKETCH\n\nwhich drops:\n\n    VERSION, VERACK, GETADDR, SENDADDRV2, SENDHEADERS, SENDTXRCNCL,\n    WTXIDRELAY  \n\ncompared to bip 324 currently.\n\nI think the things missing from the current list (and not currently in\nuse by bitcoin core) are:\n\n    bip 61: REJECT\n    bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO\n\n> - Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.\n\nI agree that's fine, though I expect that we'll probably want to do it\nnot long after bip 331 is ready for merge (or some other p2p improvement\ncomes along)...\n\nCheers,\naj"
            },
            {
                "author": "Pieter Wuille",
                "date": "2023-02-17T22:13:05",
                "message_text_only": "On Friday, February 17th, 2023 at 10:51 AM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I think it's probably less complex to close some of the doors?\n \n> 2) are short ids available/meaningful to send prior to VERACK being\n> completed?\n\nAh, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for *re*-negotiating.\n\n> Here's another approach:\n> \n> idea: we use short ids to minimise bandwidth, and don't care about\n> bandwidth for long ids\n> \n> implementation:\n> short id 0 is reserved for long commands. when received, we\n> decode the first 12 bytes of the payload and treat them\n> exactly the same as a v1 p2p message (trailing 0-bytes, etc)\n> (if there's not 12 bytes of payload, it's just treated as an\n> invalid command and dropped)\n> \n> short ids 1-255 are available for use as aliases of particular\n> long commands\n> \n> (That's exactly compatible with p2p v1, and also avoids the temptation\n> to try to choose short command names rather than descriptive ones -- the\n> 0-padding to 12 bytes prevents you from saving any bandwidth that way;\n> but that's what we have short ids for anyway)\n\nI like this idea. It avoids the variable-length encoding question and related complexity entirely for things where we admittedly don't care about the bandwidth impact anyway.\n\nIt may also have another (rather weak) advantage, in that it may reduce how much information a passive observe may learn about application level features (sendheaders, sendaddrv2, ...) from the packet size sent (which would otherwise depend on command lengths), even when decoys are not in use, if no short commands are included for these messages.\n\n> > - We remove 1 byte allocations for messages that are sent at most once per connection per direction\n> \n> I think this leaves 32 commands that get short ids initially:\n> \n> misc: ADDR, ADDRV2, BLOCK, FEEFILTER, GETBLOCKS, GETDATA, GETHEADERS,\n> HEADERS, INV, NOTFOUND, PING, PONG, TX\n> bip 35/37: FILTERADD, FILTERCLEAR, FILTERLOAD, MEMPOOL, MERKLEBLOCK\n> bip 152: BLOCKTXN, CMPCTBLOCK, GETBLOCKTXN\n> bip 157: CFCHECKPT, CFHEADERS, CFILTER, GETCFCHCKPT, GETCFHEADERS,\n> GETCFILTERS\n> bip 330: RECONCILDIFF, REQRECON, REQSKETCHEXT, SENDCMPCT, SKETCH\n\nSounds right.\n\n> which drops:\n> \n> VERSION, VERACK, GETADDR, SENDADDRV2, SENDHEADERS, SENDTXRCNCL,\n> WTXIDRELAY\n\nIndeed.\n\n> compared to bip 324 currently.\n> \n> I think the things missing from the current list (and not currently in\n> use by bitcoin core) are:\n> \n> bip 61: REJECT\n> bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO\n\nDo you feel REJECT should be included?\n\n> > - Optionally, in the implementation we can attempt to move the type id mapping to the p2p layer away from the transport layer. I suspect this could also be done after the implementation is merged but might be cleaner as the mapping is a p2p concern.\n>\n> I agree that's fine, though I expect that we'll probably want to do it\n> not long after bip 331 is ready for merge (or some other p2p improvement\n> comes along)...\n\nI do prefer that as well; it feels like the transport layer shouldn't be aware of the different command names that exist, but this is very much just an implementation issue.\n\nPerhaps a possibility is having the transport layer translate short-command-number-N to the 12-byte command \"\\x00\\x00...\" + byte(N), and hand that to the application layer, which could then do the mapping?\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-19T23:56:02",
                "message_text_only": "On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> > I think it's probably less complex to close some of the doors?\n> > 2) are short ids available/meaningful to send prior to VERACK being\n> > completed?\n> Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for *re*-negotiating.\n\nI think you still need/want two negotiation steps -- once to tell each\nother what tables you know about, once to choose a mutually recognised\ntable and specify any additions.\n\n> > I think the things missing from the current list (and not currently in\n> > use by bitcoin core) are:\n> > bip 61: REJECT\n> > bip 331: GETPKGTXNS, PKGTXNS, ANCPKGINFO\n> Do you feel REJECT should be included?\n\nI don't think it matters much; reject messages are both rare and include\na reason so you'd only be saving maybe 12 bytes out of 62 (~20%)\nfor maybe 6000 messages a day per peer that sends reject messages,\nso 72kB/day/reject-peer?\n\n> Perhaps a possibility is having the transport layer translate short-command-number-N to the 12-byte command \"\\x00\\x00...\" + byte(N), and hand that to the application layer, which could then do the mapping?\n\nPresuming the transport layer also continues to reject commands that\nhave a '\\x00' byte at the start or in the middle (ie !IsCommandValid()),\nthat seems pretty reasonable...\n\nCheers,\naj"
            },
            {
                "author": "Pieter Wuille",
                "date": "2023-02-20T15:22:30",
                "message_text_only": "On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> \n> > > I think it's probably less complex to close some of the doors?\n> > > 2) are short ids available/meaningful to send prior to VERACK being\n> > > completed?\n> > > Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.\n> \n> I think you still need/want two negotiation steps -- once to tell each\n> other what tables you know about, once to choose a mutually recognised\n> table and specify any additions.\n\nRight, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Anthony Towns",
                "date": "2023-02-21T16:03:37",
                "message_text_only": "On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:\n> > On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> > > > I think it's probably less complex to close some of the doors?\n> > > > 2) are short ids available/meaningful to send prior to VERACK being\n> > > > completed?\n> > > > Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.\n> > I think you still need/want two negotiation steps -- once to tell each\n> > other what tables you know about, once to choose a mutually recognised\n> > table and specify any additions.\n> Right, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.\n\nYeah; I was just thinking of the fact that currently the negotiation is:\n\n * send your VERSION message\n * see what their VERSION message is\n\n * announce a bunch of features, depending on the version (or service\n   flags)\n * send the VERACK (and GETADDR and final ALERT)\n\n * wait for their announcements and VERACK\n * negotiation is finished; we know everything; we're ready to go\n\nwhich only gets you two steps if you send the short id stuff as part of\nthe VERSION message. Obviously you could just add an extra phase either\njust before or just after the VERACK, though.\n\nI suppose being able to choose your own short id mapping from day 0 would\nmean that every bip324 node could use a single short id mapping for all\noutgoing messages, which might also make implementation marginally easier\n(no need to use one table for modern nodes, but also support the original\ntable for old bip324 implementations)...\n\nCheers,\naj"
            },
            {
                "author": "Dhruv M",
                "date": "2023-02-28T18:07:06",
                "message_text_only": "The relevant changes from this discussion about short 1-byte message\ntype IDs are now in a PR for the bips repo:\nhttps://github.com/bitcoin/bips/pull/1428\n\nOn 2/21/23 08:03, Anthony Towns via bitcoin-dev wrote:\n> On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev wrote:\n>> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <aj at erisian.com.au> wrote:\n>>> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n>>>>> I think it's probably less complex to close some of the doors?\n>>>>> 2) are short ids available/meaningful to send prior to VERACK being\n>>>>> completed?\n>>>>> Ah, I hadn't considered this nuance. If we don't care about them being available before VERACK negotiation, then it may be possible to introduce a way to negotiate a different short id mapping table without needing a mechanism for re-negotiating.\n>>> I think you still need/want two negotiation steps -- once to tell each\n>>> other what tables you know about, once to choose a mutually recognised\n>>> table and specify any additions.\n>> Right, I wasn't talking about how many steps/messages the negotiation takes. I just meant that if all negotiation of the mapping table happens just once (before VERACK) and that negotiation itself happens without use of short commands, then there is no need for re-negotiating short commands after they are already in use. Nothing concrete, but I can imagine that that may simplify some implementations.\n> Yeah; I was just thinking of the fact that currently the negotiation is:\n>\n>   * send your VERSION message\n>   * see what their VERSION message is\n>\n>   * announce a bunch of features, depending on the version (or service\n>     flags)\n>   * send the VERACK (and GETADDR and final ALERT)\n>\n>   * wait for their announcements and VERACK\n>   * negotiation is finished; we know everything; we're ready to go\n>\n> which only gets you two steps if you send the short id stuff as part of\n> the VERSION message. Obviously you could just add an extra phase either\n> just before or just after the VERACK, though.\n>\n> I suppose being able to choose your own short id mapping from day 0 would\n> mean that every bip324 node could use a single short id mapping for all\n> outgoing messages, which might also make implementation marginally easier\n> (no need to use one table for modern nodes, but also support the original\n> table for old bip324 implementations)...\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Erik Aronesty",
                "date": "2023-02-28T21:02:41",
                "message_text_only": "you can always do what protocols usually do.   1 byte is fine for now, but\nreserve the top bit for \"this is a two byte id\" (128 choices).   then when\nyou run out of room, set the top bit which means \"this is a 2 byte id\n(again with one reserved) and so-on.   ie: how protobuf stores integers.\n\nOn Tue, Feb 28, 2023 at 1:42 PM Dhruv M via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The relevant changes from this discussion about short 1-byte message\n> type IDs are now in a PR for the bips repo:\n> https://github.com/bitcoin/bips/pull/1428\n>\n> On 2/21/23 08:03, Anthony Towns via bitcoin-dev wrote:\n> > On Mon, Feb 20, 2023 at 03:22:30PM +0000, Pieter Wuille via bitcoin-dev\n> wrote:\n> >> On Sunday, February 19th, 2023 at 6:56 PM, Anthony Towns <\n> aj at erisian.com.au> wrote:\n> >>> On Fri, Feb 17, 2023 at 10:13:05PM +0000, Pieter Wuille via\n> bitcoin-dev wrote:\n> >>>>> I think it's probably less complex to close some of the doors?\n> >>>>> 2) are short ids available/meaningful to send prior to VERACK being\n> >>>>> completed?\n> >>>>> Ah, I hadn't considered this nuance. If we don't care about them\n> being available before VERACK negotiation, then it may be possible to\n> introduce a way to negotiate a different short id mapping table without\n> needing a mechanism for re-negotiating.\n> >>> I think you still need/want two negotiation steps -- once to tell each\n> >>> other what tables you know about, once to choose a mutually recognised\n> >>> table and specify any additions.\n> >> Right, I wasn't talking about how many steps/messages the negotiation\n> takes. I just meant that if all negotiation of the mapping table happens\n> just once (before VERACK) and that negotiation itself happens without use\n> of short commands, then there is no need for re-negotiating short commands\n> after they are already in use. Nothing concrete, but I can imagine that\n> that may simplify some implementations.\n> > Yeah; I was just thinking of the fact that currently the negotiation is:\n> >\n> >   * send your VERSION message\n> >   * see what their VERSION message is\n> >\n> >   * announce a bunch of features, depending on the version (or service\n> >     flags)\n> >   * send the VERACK (and GETADDR and final ALERT)\n> >\n> >   * wait for their announcements and VERACK\n> >   * negotiation is finished; we know everything; we're ready to go\n> >\n> > which only gets you two steps if you send the short id stuff as part of\n> > the VERSION message. Obviously you could just add an extra phase either\n> > just before or just after the VERACK, though.\n> >\n> > I suppose being able to choose your own short id mapping from day 0 would\n> > mean that every bip324 node could use a single short id mapping for all\n> > outgoing messages, which might also make implementation marginally easier\n> > (no need to use one table for modern nodes, but also support the original\n> > table for old bip324 implementations)...\n> >\n> > Cheers,\n> > aj\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230228/e41051b1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Refreshed BIP324",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Pieter Wuille",
                "Erik Aronesty",
                "Dhruv M"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 24633
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal: Fee-redistribution contracts",
        "thread_messages": [
            {
                "author": "Rastislav Budinsky",
                "date": "2023-02-27T13:32:01",
                "message_text_only": "Hello,\n\nI am working on my Bachelor's thesis, in which a new way of collecting\ntransaction fees is introduced or rather how they are distributed.\n\nWhen a miner mines a block he takes all the fees currently. However with\nthe proposed solution he takes only fraction M and remaining fraction C is\nsent to one of more contracts. One contract at its simplest collects fees\nfrom the miner and at the same time redistributes it back to the miner.\n\nThis means no new Bitcoins are introduced, only the one collected from fees\nare collected, averaged and rewarded back to the miner in a \"smarter\" way.\n\nWe can have multiple such contracts, where each averages the collected fees\nover different time frames. I would like to refer you to our paper for more\ndetails [1], which is not yet in the final form.\n\nBenefits are discussed in the paper [1] as well, mainly it should make\nmining more secure and predictable against drastic fluctuations in fees. I\npersonally do not think miners should oppose this solution as for most\nminers it should make a better mining environment. Similarly in a sense to\nwhat mining pools bring.\n\nI would like to know your opinions about this proposal and we can also\ndiscuss the needed parameters introduced with such a solution if you are in\nfavor of it or think it might be interesting.\n\nIntroducing this solution soon enough will not make a great difference to\nminers with current block rewards and at the same time the contracts will\nbe adapted before transaction fees become the main source of income for\nminers.\n\nAs I have very little to none developer experience from blockchain's point\n(especially on Bitcoin), I am not sure if this would be possible as\nsoft-fork as scripts in Bitcoin are stateless I suppose.\nHowever maybe a generally spendable script by anyone holding the funds is\ncreated, which a miner of the block would be the one spending it, and the\ncorrect logic of following the contracts is embedded into consensus nodes\nthemselves. Thus perhaps a less disruptive solution to hard-fork.\n\nOnce again, I would love to know your opinions about this & I apologize for\nmaking this a bit less conventional BIP proposal.\n\n[1] https://arxiv.org/abs/2302.04910\n\nBest regards.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230227/707b50c7/attachment.html>"
            },
            {
                "author": "HcaFc_jbe",
                "date": "2023-02-27T21:41:35",
                "message_text_only": "Greetings, Brno is a beautiful city.\n\nLong term miner incentives remain an open question, and this is an interesting proposal, but it has flaws.\n\n-----To intervene or not intervene\n\n--No intervention: When block subsidies do run out, years from now, it's possible that we live in a world where ordinals, LN-settlements, and on-chain transactions will be filling block space to the extent that miners are incentivized to continue mining. --Intervention: Tail-emissions? Demurrage? Fee-redistribution schemes like this one?\n\nReally, it is too early to say whether mining incentives _will even_ be a problem, let alone _what_ the solution(s) should be.\n\nThis fee-redistribution scheme aims to solve\n\n1. Undercutting attacks [which have been precluded AFAIK with anti fee-sniping\n\nnLocktime since Core 0.11]\n\n2. Fee-variance between blocks, whether due to the mining gap or variance in block\n\ndemand.\n\n--Flaws\n\n0. A miner in this world could be more aggressive in excluding certain blocks to the detriment of their counter parties. I.e. If a miner can ignore high-fee transactions, knowing they won't receive the _benefits_ of mining them [or less benefit], they can exclude these transactions without losing fees. E.g. if a miner is or represents a counterparty in a LN commitment transaction, and this counter party prefers that a time threshold is reached [so that they can mine a different version of the commitment transaction] then under this scheme they can avoid mining the first commitment transaction without really losing its fee, since it's fee is socialized anyway. This attack then becomes free or very cheap.\n\n1. How would this smart-contract actually be constructed? The paper contains no references to op_codes or implementations. You do mention that you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_ with the current Script, and could remain impossible. Maybe DLCs could be applied somehow. IDK.\n\n2.0. I think it will be difficult to convince the ecosystem that the mining incentive structure should be changed from competitive to cooperative. This effectively changes the mining ecosystem into one giant mining pool. How would this affect mining centralization?\n\n2.1. How do we achieve miner consensus in implementing the fee-redistribution scheme? And what is the consensus for updating?\n\n---Paper-nits:\n\nI believe the distribution in block creation is not exponential, but poisson -> on page two it's described as exponential.\n\nCheers,\n\n-Paul\n\n------- Original Message -------\nOn Monday, February 27th, 2023 at 8:32 AM, Rastislav Budinsky via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> I am working on my Bachelor's thesis, in which a new way of collecting transaction fees is introduced or rather how they are distributed.\n>\n> When a miner mines a block he takes all the fees currently. However with the proposed solution he takes only fraction M and remaining fraction C is sent to one of more contracts. One contract at its simplest collects fees from the miner and at the same time redistributes it back to the miner.\n>\n> This means no new Bitcoins are introduced, only the one collected from fees are collected, averaged and rewarded back to the miner in a \"smarter\" way.\n>\n> We can have multiple such contracts, where each averages the collected fees over different time frames. I would like to refer you to our paper for more details [1], which is not yet in the final form.\n>\n> Benefits are discussed in the paper [1] as well, mainly it should make mining more secure and predictable against drastic fluctuations in fees. I personally do not think miners should oppose this solution as for most miners it should make a better mining environment. Similarly in a sense to what mining pools bring.\n>\n> I would like to know your opinions about this proposal and we can also discuss the needed parameters introduced with such a solution if you are in favor of it or think it might be interesting.\n>\n> Introducing this solution soon enough will not make a great difference to miners with current block rewards and at the same time the contracts will be adapted before transaction fees become the main source of income for miners.\n>\n> As I have very little to none developer experience from blockchain's point (especially on Bitcoin), I am not sure if this would be possible as soft-fork as scripts in Bitcoin are stateless I suppose.\n> However maybe a generally spendable script by anyone holding the funds is created, which a miner of the block would be the one spending it, and the correct logic of following the contracts is embedded into consensus nodes themselves. Thus perhaps a less disruptive solution to hard-fork.\n>\n> Once again, I would love to know your opinions about this & I apologize for making this a bit less conventional BIP proposal.\n>\n> [1] https://arxiv.org/abs/2302.04910\n>\n> Best regards.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230227/bbfc0651/attachment-0001.html>"
            },
            {
                "author": "shymaa arafat",
                "date": "2023-02-28T10:02:47",
                "message_text_only": "If you allow me to comment (just with a bird eye, have not read the paper\nonly the abstract)\n\nI think the Bitcoin community may consider the intuition of somewhat\n\"Future Saving\" through TX fees:\nie, the idea of saving a ratio of the fees (say half to be decreased to\nhalf with each reward halving)is worth thinking of:\nKeep in mind that the block reward problem will not start only in 2140, but\nwhen the mining cost becomes comparable to the reward value (could this be\nas near as 2040?I don't know, you know the answer better than me)\n.\n-So, why not start a fee splitting  mechanism in analogy to reward\nsplitting mechanism\n*(the saved ratio is half the total now, and to be halved with every\nBitcoin reward halving until a threshold is reached where the saved amounts\ngets added to the low block reward)*\n\nOfcourse this is very rough, a game theoritic model has to be built with\nthe appropriate incentives and costs to get the exact numbers\n.\nThank you for letting me comment in your list\n.\nRegards\n.\nShymaa M Arafat\n\nOn Tue, Feb 28, 2023, 02:18 HcaFc_jbe via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Greetings, Brno is a beautiful city.\n>\n>\n>\n>\n> Long term miner incentives remain an open question, and this is an\n> interesting proposal, but it has flaws.\n>\n>\n>\n>\n> -----To intervene or not intervene\n>\n> --No intervention:  When block subsidies do run out, years from now, it's\n> possible that we live in a world where ordinals, LN-settlements, and\n> on-chain transactions will be filling block space to the extent that miners\n> are incentivized to continue mining.\n>\n>                       --Intervention: Tail-emissions? Demurrage?\n> Fee-redistribution schemes like this one?\n>\n> Really, it is too early to say whether mining incentives _will even_ be a\n> problem, let alone _what_ the solution(s) should be.\n>\n> This fee-redistribution scheme aims to solve\n>\n>      1. Undercutting attacks [which have been precluded AFAIK with anti\n> fee-sniping\n>\n> nLocktime since Core 0.11]\n>\n>      2. Fee-variance between blocks, whether due to the mining gap or\n> variance in block\n>\n> demand.\n>\n>\n>\n> --Flaws\n>\n> 0. A miner in this world could be more aggressive in excluding certain\n> blocks to the detriment of their counter parties. I.e. If a miner can\n> ignore high-fee transactions, knowing they won't receive the _benefits_ of\n> mining them [or less benefit], they can exclude these transactions without\n> losing fees. E.g. if a miner is or represents a counterparty in a LN\n> commitment transaction, and this counter party prefers that a time\n> threshold is reached [so that they can mine a different version of the\n> commitment transaction] then under this scheme they can avoid mining the\n> first commitment transaction without really losing its fee, since it's fee\n> is socialized anyway. This attack then becomes free or very cheap.\n>\n> 1. How would this smart-contract actually be constructed? The paper\n> contains no references to op_codes or implementations. You do mention that\n> you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_\n> with the current Script, and could remain impossible. Maybe DLCs could be\n> applied somehow. IDK.\n>\n> 2.0. I think it will be difficult to convince the ecosystem that the\n> mining incentive structure should be changed from competitive to\n> cooperative. This effectively changes the mining ecosystem into one giant\n> mining pool. How would this affect mining centralization?\n>\n> 2.1. How do we achieve miner consensus in implementing the\n> fee-redistribution scheme? And what is the consensus for updating?\n>\n> ---Paper-nits:\n>\n> I believe the distribution in block creation is not exponential, but\n> poisson -> on page two it's described as exponential.\n>\n> Cheers,\n>\n> -Paul\n>\n> ------- Original Message -------\n> On Monday, February 27th, 2023 at 8:32 AM, Rastislav Budinsky via\n> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hello,\n>\n> I am working on my Bachelor's thesis, in which a new way of collecting\n> transaction fees is introduced or rather how they are distributed.\n>\n> When a miner mines a block he takes all the fees currently. However with\n> the proposed solution he takes only fraction M and remaining fraction C is\n> sent to one of more contracts. One contract at its simplest collects fees\n> from the miner and at the same time redistributes it back to the miner.\n>\n> This means no new Bitcoins are introduced, only the one collected from\n> fees are collected, averaged and rewarded back to the miner in a \"smarter\"\n> way.\n>\n> We can have multiple such contracts, where each averages the collected\n> fees over different time frames. I would like to refer you to our paper for\n> more details [1], which is not yet in the final form.\n>\n> Benefits are discussed in the paper [1] as well, mainly it should make\n> mining more secure and predictable against drastic fluctuations in fees. I\n> personally do not think miners should oppose this solution as for most\n> miners it should make a better mining environment. Similarly in a sense to\n> what mining pools bring.\n>\n> I would like to know your opinions about this proposal and we can also\n> discuss the needed parameters introduced with such a solution if you are in\n> favor of it or think it might be interesting.\n>\n> Introducing this solution soon enough will not make a great difference to\n> miners with current block rewards and at the same time the contracts will\n> be adapted before transaction fees become the main source of income for\n> miners.\n>\n> As I have very little to none developer experience from blockchain's point\n> (especially on Bitcoin), I am not sure if this would be possible as\n> soft-fork as scripts in Bitcoin are stateless I suppose.\n> However maybe a generally spendable script by anyone holding the funds is\n> created, which a miner of the block would be the one spending it, and the\n> correct logic of following the contracts is embedded into consensus nodes\n> themselves. Thus perhaps a less disruptive solution to hard-fork.\n>\n> Once again, I would love to know your opinions about this & I apologize\n> for making this a bit less conventional BIP proposal.\n>\n> [1] https://arxiv.org/abs/2302.04910\n>\n> Best regards.\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230228/ce1d3450/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP proposal: Fee-redistribution contracts",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rastislav Budinsky",
                "shymaa arafat",
                "HcaFc_jbe"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 14071
        }
    }
]