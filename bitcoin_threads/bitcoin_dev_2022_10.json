[
    {
        "title": "[bitcoin-dev] Trustless Address Server ? Outsourcing handing out addresses",
        "thread_messages": [
            {
                "author": "Peter",
                "date": "2022-10-01T04:36:44",
                "message_text_only": "Hi Ruben,\n\nI think this is an important conversation you have raised. I want to add some points for discussion.\n\n1) handing out xpubs makes the gap limit problem quadratic.\n\nEach customer, of a given business, on an invoice must be given a unique address or xpub but they may pay in cash or credit card or bank wire. How do we present more than 20 customers with an \"invoice address\" (regular address or xpub)?\n\n(In Lightning world you give a Lightning address that uses plus addresses. Like castiron+customer1.invoice1 at LSP.com\n\nIf you hand out xpubs it can be the case that you hand out a consecutive streak of 20 xpubs that are never used. Your wallet has to scan 20 xpubs and their 20 first receive addresses.\n\n2) Whether you give the sender an address for reuse or an xpub for reuse there needs to be an expiry such that the receiver can confirm they still have the corresponding keys. How can we make a layer 1 address that expires like a PGP key where it can still be used but raises a warning to the sender?\n\n(In Lightning we have that)\n\n3) Could there be some more exotic deterministic path that doesn't split receive and change addresses? What is the first principle of splitting change and receive? What's wrong with an address reused exactly twice? The sender and receiver both with know what was a payment and what was change. Will it create plausible deniability about change addresses?\n\nSatoshi original wallet concept was an ever growing key pool with a 100 address \"gap\". Maybe the solution to the gap limit is to add invoice functionality to wallets that manage issuing fresh addresses even without them being used and have a configurable gap limit. Is that what Btcpayserver does?\n\nRegards\n\nPeter Kroll\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221001/bb46bc67/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-10-01T10:18:49",
                "message_text_only": "Hi Peter,\n\nThanks for your comments.\n\n>handing out xpubs makes the gap limit problem quadratic\n\nYes, my thinking on this is that if you're handing out xpubs you can lower\nthe gap limit for addresses generated by those xpubs, provided you assume\nthose addresses will be used by the same person, so there is less of a\nreason to expect a gap. This thread is related:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020954.html\n\n>How can we make a layer 1 address that expires\n\nThis was brought up by Sjors Provoost in relation to Silent Payments. He\nsuggested embedding a sunset date in the address format.\n\n>Could there be some more exotic deterministic path that doesn't split\nreceive and change addresses\n\nI don't follow this one. I see no reason not to split the two, and I do see\npotential pitfalls when you don't. Conceptually, I think receiving money\ntwice on the same address is never good. Even if you're doing it to\nactively mislead people, that attempt is still leaking information that\nsimply didn't need to be leaked.\n\nCheers,\nRuben\n\nOn Sat, Oct 1, 2022 at 10:57 AM Peter via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Ruben,\n>\n>\n> I think this is an important conversation you have raised. I want to add\n> some points for discussion.\n>\n>\n> 1) handing out xpubs makes the gap limit problem quadratic.\n>\n>\n> Each customer, of a given business, on an invoice must be given a unique\n> address or xpub but they may pay in cash or credit card or bank wire. How\n> do we present more than 20 customers with an \"invoice address\" (regular\n> address or xpub)?\n>\n> (In Lightning world you give a Lightning address that uses plus addresses.\n> Like castiron+customer1.invoice1 at LSP.com\n>\n>\n> If you hand out xpubs it can be the case that you hand out a consecutive\n> streak of 20 xpubs that are never used. Your wallet has to scan 20 xpubs\n> and their 20 first receive addresses.\n>\n>\n>\n> 2) Whether you give the sender an address for reuse or an xpub for reuse\n> there needs to be an expiry such that the receiver can confirm they still\n> have the corresponding keys. How can we make a layer 1 address that expires\n> like a PGP key where it can still be used but raises a warning to the\n> sender?\n>\n> (In Lightning we have that)\n>\n>\n> 3) Could there be some more exotic deterministic path that doesn't split\n> receive and change addresses? What is the first principle of splitting\n> change and receive? What's wrong with an address reused exactly twice? The\n> sender and receiver both with know what was a payment and what was change.\n> Will it create plausible deniability about change addresses?\n>\n>\n> Satoshi original wallet concept was an ever growing key pool with a 100\n> address \"gap\". Maybe the solution to the gap limit is to add invoice\n> functionality to wallets that manage issuing fresh addresses even without\n> them being used and have a configurable gap limit. Is that what\n> Btcpayserver does?\n>\n>\n> Regards\n>\n> Peter Kroll\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221001/d620ebcc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Trustless Address Server ? Outsourcing handing out addresses",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ruben Somsen",
                "Peter"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5265
        }
    },
    {
        "title": "[bitcoin-dev] New transaction policies (nVersion=3) for contracting protocols",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2022-10-01T09:59:55",
                "message_text_only": "Hi Bastien,\n\n>Greg already has a draft design that addresses your concerns\n\nThanks, that is very nice. In that case I currently have no outstanding\nobjections.\n\n>I'm curious why you would need more than one such output\n\nMy reasoning was actually to allow only one OP_TRUE output per transaction,\nso I think we agree. Apologies if that wasn't clear.\n\nTo summarize:\n\n1. OP_TRUE output must be spent\n2. Only one child allowed per transaction\n\nThis ensures there is no scenario where a child is propagated that does not\nspend the OP_TRUE output.\n\nCheers,\nRuben\n\nOn Fri, Sep 30, 2022 at 2:17 PM Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> It's likely better if the ephemeral output can be any value, including\n> dust. This lets contract designers put \"trimmed output\" value indirectly\n> towards CPFP fees without making the parent tx have fees itself.\n>\n> On Fri, Sep 30, 2022, 8:08 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>\n>> Hey Ruben,\n>>\n>> I discussed this further over IRC, and I now agree that this particular\n>> change would be very desirable and can likely fit in the initial release\n>> (even though I'm not the one writing that code, but I'd be happy to\n>> review it and test it).\n>>\n>> Greg already has a draft design that addresses your concerns: if there is\n>> an \"ephemeral output\" (0-value, OP_TRUE) in an unconfirmed v3 transaction,\n>> it MUST be spent by any child v3 transaction. This way, you ensure that\n>> any child transaction spending the unconfirmed parent spends the ephemeral\n>> output(s). @Greg, correct me if I misunderstood something here. Note that\n>> we will need to precisely define the criteria for those \"ephemeral\n>> outputs\"\n>> (it can probably simply be \"outputs that are 0 sats\").\n>>\n>> Coupled with transactions that pay no fees (and thus require a child to\n>> CPFP in order to be included in a block), this ensures those outputs can\n>> never leak into the utxo set. How does that sound?\n>>\n>> I'm curious why you would need more than one such output, can you detail?\n>> I believe we only ever need one, spendable by anyone.\n>>\n>> Cheers,\n>> Bastien\n>>\n>> Le ven. 30 sept. 2022 \u00e0 02:14, Ruben Somsen <rsomsen at gmail.com> a \u00e9crit :\n>>\n>>> Hi Bastien,\n>>>\n>>> >The other change mentioned (making OP_TRUE standard and allowing outputs\n>>> that are below dust) can be added later, as those won't be standard until\n>>> we start allowing them, so there shouldn't be any backwards-compatibility\n>>> issue with postponing this change. But maybe it's still worth having from\n>>> the get-go, even though it may take a bit more time? Again, I'm curious\n>>> to\n>>> have other people's opinion here\n>>>\n>>> I'm sensitive to not wanting to overload the current discussion but this\n>>> also interests me, provided it can be done in a way that is acceptable\n>>> (i.e. minimizing the potential UTXO set impact). It would solve a big cost\n>>> issue in my spacechains design if transactions could be 0 fees and have a 0\n>>> sat output that could be used in order to pay all the fees with CPFP.\n>>>\n>>> My current view is that a tx containing a single 0 sat OP_TRUE output\n>>> should only get relayed if it is a package where the OP_TRUE output is\n>>> currently being spent in a way that increases the overall fee rate. But\n>>> even then, one theoretical edge case remains:\n>>> - Another CPFP tx can feebump the package on a different (non-OP_TRUE)\n>>> output with an even higher fee rate\n>>> - Subsequently, the tx that is spending the OP_TRUE might fall out of\n>>> the mempool if the mempool fee rate rises\n>>> - This could cause the 0 sat output to enter the UTXO set (specifically,\n>>> rational miners wouldn't refuse to mine such a tx)\n>>>\n>>> It doesn't seem like this would happen much in practice (nor is there an\n>>> incentive to do it on purpose), but the chance isn't 0.\n>>>\n>>> Cheers,\n>>> Ruben\n>>>\n>>>\n>>>\n>>> On Thu, Sep 29, 2022 at 4:50 PM Greg Sanders via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> > Right, good catch, this does require new logic to handle this case.\n>>>> As Gloria points out, this should be doable, and is definitely worth\n>>>> adding (those CSV 1 on every other output are really hacky, glad to\n>>>> find a way to get rid of them).\n>>>>\n>>>> For the record, it turns out ephemeral anchors + v3 solves this\n>>>> already, as the anchor must be spent, and the parent tx may only have one\n>>>> child. Somehow I missed this implication for a few months. It's great news\n>>>> if we can directly source fees from any output claimable, including HTLCs!\n>>>>\n>>>> On Thu, Sep 29, 2022 at 5:15 AM Bastien TEINTURIER <bastien at acinq.fr>\n>>>> wrote:\n>>>>\n>>>>> Hi Gloria, Greg,\n>>>>>\n>>>>> > I interpret most of the discussion around limitations as ideas for\n>>>>> > future improvements rather than criticisms of the proposal\n>>>>>\n>>>>> As far as I'm concerned, definitely!\n>>>>>\n>>>>> My current understanding is that the main change/improvement that would\n>>>>> make sense here is restricting the whole v3 package's size (instead of\n>>>>> just the child) via committing to a specific value in the taproot annex\n>>>>> (also note that it's probably not just the v3 package's size, it should\n>>>>> be the whole unconfirmed package including potential v2 unconfirmed\n>>>>> ancestors).\n>>>>>\n>>>>> While I think this would be very valuable and would like to see this\n>>>>> happen, I believe that can be done in a second, separate step since\n>>>>> this\n>>>>> would make relay policy stricter (some v3 transactions that previously\n>>>>> propagated wouldn't propagate under this new rule). As long as you are\n>>>>> able to find a path to miners through upgraded peers that use this\n>>>>> annex\n>>>>> approach, you should be able to resolve ACP pinning issues?\n>>>>>\n>>>>> I'm curious to know how other people feel about that: is it ok to do\n>>>>> later or should we try to implement this for the first release of v3\n>>>>> transactions?\n>>>>>\n>>>>> The other change mentioned (making OP_TRUE standard and allowing\n>>>>> outputs\n>>>>> that are below dust) can be added later, as those won't be standard\n>>>>> until\n>>>>> we start allowing them, so there shouldn't be any\n>>>>> backwards-compatibility\n>>>>> issue with postponing this change. But maybe it's still worth having\n>>>>> from\n>>>>> the get-go, even though it may take a bit more time? Again, I'm\n>>>>> curious to\n>>>>> have other people's opinion here, I'd be happy to get all of those\n>>>>> directly\n>>>>> in the first release of v3 transactions, but I don't know how much\n>>>>> implementation will have to go into that.\n>>>>>\n>>>>> > For clarification, package RBF is ParentTx*s*(plural), and\n>>>>> ChildTx(singular),\n>>>>> > so it might be a bit more complicated than we're thinking\n>>>>>\n>>>>> Right, good catch, this does require new logic to handle this case.\n>>>>> As Gloria points out, this should be doable, and is definitely worth\n>>>>> adding (those CSV 1 on every other output are really hacky, glad to\n>>>>> find a way to get rid of them).\n>>>>>\n>>>>> Thanks,\n>>>>> Bastien\n>>>>>\n>>>>> Le lun. 26 sept. 2022 \u00e0 18:48, Gloria Zhao <gloriajzhao at gmail.com> a\n>>>>> \u00e9crit :\n>>>>>\n>>>>>> Hi Greg, Antoine, Bastien,\n>>>>>>\n>>>>>> Thanks very much for the feedback! I interpret most of the discussion\n>>>>>> around limitations as ideas for future improvements rather than criticisms\n>>>>>> of the proposal (please correct me if I'm wrong). I'll try to respond to as\n>>>>>> much as possible.\n>>>>>>\n>>>>>> Also I realize that I didn't contextualize this proposal clearly\n>>>>>> enough; it is very tailored for LN Penalty and definitely doesn't close all\n>>>>>> pinning attacks possible (sorry for confusing anyone). I also agree that\n>>>>>> some bits can be a little ugly or tack-on; I would definitely prefer a\n>>>>>> comprehensive RBF revamp to fix all our problems and enable other\n>>>>>> fee-bumping strategies such as\n>>>>>> sign-ANYONECANPAY-then-bring-your-own-fees-by-adding-inputs-at-broadcast. I\n>>>>>> was hoping to get some ideas with the \"RBF Improvements\" post in January,\n>>>>>> but it doesn't seem like we're much closer to a workable proposal. I think\n>>>>>> this is a minimally-invasive step that works for Lightning today, a small\n>>>>>> fix similar to CPFP carve out.\n>>>>>>\n>>>>>> > As you likely know from previous discussions the biggest scenario\n>>>>>> this does not fix in my estimation is ANYONECANPAY situations. If the\n>>>>>> parent transaction can be \"inflated\" by tacking on additional inputs, this\n>>>>>> means the total weight of the parent tx lowers the effective feerate of the\n>>>>>> package.\n>>>>>>\n>>>>>> (For more context to other readers I wrote an explanation for this in\n>>>>>> \"SIGHASH_ANYONECANPAY Pinning\" section of RBF ML post).  Yes, this\n>>>>>> unfortunately doesn't fix any of the existing pinning attacks for single\n>>>>>> transaction RBF but also doesn't make them worse. This boils down to adding\n>>>>>> an incentive compatibility rule that ensures you can't replace a\n>>>>>> transaction with something that will confirm slower. Package RBF has an\n>>>>>> ancestor feerate-based rule for this (note it is quite conservative and not\n>>>>>> perfect).\n>>>>>>\n>>>>>> So in the scenario above with the \"inflated\" parent that was signed\n>>>>>> ACP, the replacement would be rejected because the package ancestor feerate\n>>>>>> is lower than the feerate of what is being replaced. But it is imperfect\n>>>>>> (explained below) and thus I wouldn't recommend it for single transaction\n>>>>>> replacement. So that attack still exists for single transactions, yes.\n>>>>>>\n>>>>>> The strategy of using ACP to bring-your-own-fees has its own\n>>>>>> challenges but hopefully has no current use cases as you say. AFAIK LN\n>>>>>> Penalty is not affected by this since it doesn't use ACP, though obviously\n>>>>>> I agree we should fix it for the future.\n>>>>>>\n>>>>>> So when I said \"this is intended for fee-bumping presigned txns in\n>>>>>> contracting protocols,\" I should have said \"this is intended for\n>>>>>> fee-bumping presigned txns specifically using CPFP and anchor outputs.\"\n>>>>>> Apologies for forgetting to contextualize, I've been sitting on this for\n>>>>>> too long.\n>>>>>>\n>>>>>> > The other scenario it doesn't really fix is where\n>>>>>> HTLC/commitment-like transactions are being resolved in a batch, but due to\n>>>>>> relative time constraints, you may want to accelerate some and not others.\n>>>>>> Now you must pay higher rates to replace all of the transaction bumps. This\n>>>>>> is a \"self-pin\" and \"get good at utxos noob\" type problem, but it's\n>>>>>> something that axing rule#3 in favor of a Replace-by-ancestor-feerate\n>>>>>> system would get us.\n>>>>>>\n>>>>>> I understand you to mean \"if you don't have enough UTXOs and you're\n>>>>>> forced to batch-bump, you over-pay because you need to bring them all to\n>>>>>> the highest target feerate.\" Isn't this kind of separate, wallet-related\n>>>>>> problem? Contracting or not, surely every wallet needs to have enough UTXOs\n>>>>>> to not batch transactions that shouldn't be batched... I don't see how a\n>>>>>> replace-by-ancestor-feerate policy would make any difference for this?\n>>>>>>\n>>>>>> Also in general I'd like to reiterate that ancestor feerate is not a\n>>>>>> panacea to all our RBF incentive compatibility concerns. Like individual\n>>>>>> feerate, unless we run the mining algorithm, it cannot tell us exactly how\n>>>>>> quickly this transaction would be mined.\n>>>>>>\n>>>>>> We're estimating the incentive compatibility of the original\n>>>>>> transaction(s) and replacement transaction(s), with the goal of not letting\n>>>>>> a transaction replace something that would have been more incentive\n>>>>>> compatible to mine. As such, we don't want to overestimate how good the\n>>>>>> replacement is, and we don't want to underestimate how good the original\n>>>>>> transactions are. This rule \"The minimum between package feerate and\n>>>>>> ancestor feerate of the child is not lower than the individual feerates of\n>>>>>> all directly conflicting transactions and the ancestor feerates of all\n>>>>>> original transactions\" is a conservative estimate.\n>>>>>>\n>>>>>> > Would kind of be nice if package RBF would detect a \"sibling output\n>>>>>> spend\" conflict, and knock it out of the mempool via the other replacement\n>>>>>> rules? Getting rid of the requirement to 1 block csv lock every output\n>>>>>> would be quite nice from a smart contracting composability point of view.\n>>>>>>\n>>>>>> Interesting, so when a transaction hits a mempool tx's descendant\n>>>>>> limit, we consider evicting one of its descendants in favor of this\n>>>>>> transaction, based on the RBF rules.\n>>>>>> Cool idea! After chewing on this for a bit, I think this *also* just\n>>>>>> boils down to the fact that RBF should require replacements to be better\n>>>>>> mining candidates. As in, if we added this policy and it can make us evict\n>>>>>> the sibling and accept a transaction with a bunch of low-feerate ancestor\n>>>>>> junk, it would be a new pinning vector.\n>>>>>>\n>>>>>> > If you're a miner and you receive a non-V3, second descendant of an\n>>>>>> unconfirmed V3 transaction, if the offered fee is in the top mempool\n>>>>>> backlog, I think you would have an interest to accept such a transaction.\n>>>>>>\n>>>>>> > So I'm not sure if those two rules are compatible with miners\n>>>>>> incentives...\n>>>>>>\n>>>>>> The same argument can be made for the 26th descendant of a mempool\n>>>>>> transaction; it's also not entirely incentive-compatible to reject it, but\n>>>>>> that is not the *only* design goal in mempool policy. Of course, the\n>>>>>> difference here is that the 25-descendant limit rule is a sensible DoS\n>>>>>> protection, while this 1-descendant limit rule is more of a \"help the\n>>>>>> Bitcoin ecosystem\" policy, just like CPFP carve-out, dust limit, etc. I can\n>>>>>> of course understand why not everyone would be in favor of this, but I do\n>>>>>> think it's worth it.\n>>>>>>\n>>>>>> > > 4. A V3 transaction that has an unconfirmed V3 ancestor cannot be\n>>>>>>\n>>>>>> > >    larger than 1000 virtual bytes.\n>>>>>>\n>>>>>> > If I understand correctly the 1000 vb upper bound rational, it\n>>>>>> would be to constraint the pinning counterparty to attach a high fee to a\n>>>>>> child due to the limited size, if they would like this transaction to be\n>>>>>> stuck in the network mempools. By doing so  this child has high odds to\n>>>>>> confirm.\n>>>>>>\n>>>>>> Yeah exactly, the \"Rule 3 pin\" is done by adding a child that's\n>>>>>> high-fee (so you have to pay that much to evict it). Because they *don't*\n>>>>>> want this tx to confirm, normally, this child would be really large. If\n>>>>>> they only have 1000vB for the child, they can't increase the replacement\n>>>>>> cost without also fee-bumping the transaction to make it confirm faster.\n>>>>>>\n>>>>>> > As of today, I think yes you can already fingerprint LN\n>>>>>> transactions on the  spec-defined amount value of the anchor outputs, 330\n>>>>>> sats. There is always one of them on post-anchor commitment transactions.\n>>>>>> And sadly I would say we'll always have tricky fingerprints leaking from\n>>>>>> unilateral LN closures such as HTLC/PTLC timelocks...\n>>>>>>\n>>>>>> > I agree with you, this isn't worse than today, unilateral closes\n>>>>>> will\n>>>>>> probably always be identifiable on-chain.\n>>>>>>\n>>>>>> Great to hear that there is no privacy worsening!\n>>>>>>\n>>>>>> Best,\n>>>>>> Gloria\n>>>>>>\n>>>>>> On Mon, Sep 26, 2022 at 5:02 PM Greg Sanders <gsanders87 at gmail.com>\n>>>>>> wrote:\n>>>>>>\n>>>>>>> Bastien,\n>>>>>>>\n>>>>>>> > This may be already covered by the current package RBF logic, in\n>>>>>>> that\n>>>>>>> scenario we are simply replacing [ParentTx, ChildTx1] with\n>>>>>>> [ParentTx, ChildTx2] that pays more fees, right?\n>>>>>>>\n>>>>>>> For clarification, package RBF is ParentTx*s*(plural), and\n>>>>>>> ChildTx(singular), so it might be a bit more complicated than we're\n>>>>>>> thinking, and currently the V3 proposal would first de-duplicate the\n>>>>>>> ParentTx based on what is in the mempool, then look at the \"rest\" of the\n>>>>>>> transactions as a package, then individually. Not the same, not sure how\n>>>>>>> different. I'll defer to experts.\n>>>>>>>\n>>>>>>> Best,\n>>>>>>> Greg\n>>>>>>>\n>>>>>>> On Mon, Sep 26, 2022 at 11:48 AM Bastien TEINTURIER via bitcoin-dev <\n>>>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>>>>\n>>>>>>>> Thanks Gloria for this great post.\n>>>>>>>>\n>>>>>>>> This is very valuable work for L2 contracts, and will greatly\n>>>>>>>> improve\n>>>>>>>> their security model.\n>>>>>>>>\n>>>>>>>> > \"Only 1 anchor output? What if I need to bump counterparty's\n>>>>>>>> commitment tx in mempool?\"\n>>>>>>>> > You won't need to fee-bump a counterparty's commitment tx using\n>>>>>>>> CPFP.\n>>>>>>>> > You would just package RBF it by attaching a high-feerate child to\n>>>>>>>> > your commitment tx.\n>>>>>>>>\n>>>>>>>> Note that we can also very easily make that single anchor spendable\n>>>>>>>> by\n>>>>>>>> both participants (or even anyone), so if you see your\n>>>>>>>> counterparty's\n>>>>>>>> commitment in your mempool, you can bump it without publishing your\n>>>>>>>> own commitment, which is quite desirable (your own commitment tx has\n>>>>>>>> CSV delays on your outputs, whereas your counterparty's commitment\n>>>>>>>> tx\n>>>>>>>> doesn't).\n>>>>>>>>\n>>>>>>>> > \"Is this a privacy issue, i.e. doesn't it allow fingerprinting LN\n>>>>>>>> transactions based on nVersion?\"\n>>>>>>>>\n>>>>>>>> I agree with you, this isn't worse than today, unilateral closes\n>>>>>>>> will\n>>>>>>>> probably always be identifiable on-chain.\n>>>>>>>>\n>>>>>>>> > Would kind of be nice if package RBF would detect a \"sibling\n>>>>>>>> output spend\"\n>>>>>>>> > conflict, and knock it out of the mempool via the other\n>>>>>>>> replacement rules?\n>>>>>>>> > Getting rid of the requirement to 1 block csv lock every output\n>>>>>>>> would be\n>>>>>>>> > quite nice from a smart contracting composability point of view.\n>>>>>>>>\n>>>>>>>> +1, that would be very neat!\n>>>>>>>>\n>>>>>>>> This may be already covered by the current package RBF logic, in\n>>>>>>>> that\n>>>>>>>> scenario we are simply replacing [ParentTx, ChildTx1] with\n>>>>>>>> [ParentTx, ChildTx2] that pays more fees, right?\n>>>>>>>>\n>>>>>>>> > 1) I do think that we should seriously consider allowing OP_TRUE\n>>>>>>>> to become\n>>>>>>>> > a standard script type as part of this policy update. If pinning\n>>>>>>>> is solved,\n>>>>>>>> > then there's no reason to require all those extra bytes for\n>>>>>>>> \"binding\" an\n>>>>>>>> > anchor to a specific wallet/user. We can save quite a few bytes\n>>>>>>>> by having\n>>>>>>>> > the input be empty of witness data.\n>>>>>>>> > 2) If we allow for a single dust-value(0 on up) output which is\n>>>>>>>> immediately\n>>>>>>>> > spent by the package, anchors become even easier to to design. No\n>>>>>>>> value has\n>>>>>>>> > to be \"sapped\" from contract participants to make an anchor\n>>>>>>>> output. There's\n>>>>>>>> > more complications for this, such as making sure the parent\n>>>>>>>> transaction is\n>>>>>>>> > dropped if the child spend is dropped, but maybe it's worth the\n>>>>>>>> squeeze.\n>>>>>>>>\n>>>>>>>> I also think both of these could be quite useful. This would\n>>>>>>>> probably always\n>>>>>>>> be used in combination with a parent transaction that pays 0 fees,\n>>>>>>>> so the\n>>>>>>>> 0-value output would always be spent in the same block.\n>>>>>>>>\n>>>>>>>> But this means we could end up with 0-value outputs in the utxo\n>>>>>>>> set, if for\n>>>>>>>> some reason the parent tx is CPFP-ed via another output than the\n>>>>>>>> 0-value one,\n>>>>>>>> which would be a utxo set bloat issue. But I'd argue that we're\n>>>>>>>> probably\n>>>>>>>> already creating utxo set bloat with the 330 sat anchor outputs\n>>>>>>>> (especially\n>>>>>>>> since we use two of them, but only one is usually spent), so it\n>>>>>>>> would\n>>>>>>>> probably be *better* than what we're doing today.\n>>>>>>>>\n>>>>>>>> Thanks,\n>>>>>>>> Bastien\n>>>>>>>>\n>>>>>>>> Le lun. 26 sept. 2022 \u00e0 03:22, Antoine Riard via bitcoin-dev <\n>>>>>>>> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>>>>>>>>\n>>>>>>>>> Hi Gloria,\n>>>>>>>>>\n>>>>>>>>> Thanks for the progress on package RBF, few early questions.\n>>>>>>>>>\n>>>>>>>>> > 2. Any descendant of an unconfirmed V3 transaction must also be\n>>>>>>>>> V3.\n>>>>>>>>>\n>>>>>>>>> > 3. An unconfirmed V3 transaction cannot have more than 1\n>>>>>>>>> descendant.\n>>>>>>>>>\n>>>>>>>>> If you're a miner and you receive a non-V3, second descendant of\n>>>>>>>>> an unconfirmed V3 transaction, if the offered fee is in the top mempool\n>>>>>>>>> backlog, I think you would have an interest to accept such a transaction.\n>>>>>>>>>\n>>>>>>>>> So I'm not sure if those two rules are compatible with miners\n>>>>>>>>> incentives...\n>>>>>>>>>\n>>>>>>>>> > 4. A V3 transaction that has an unconfirmed V3 ancestor cannot be\n>>>>>>>>> >    larger than 1000 virtual bytes.\n>>>>>>>>>\n>>>>>>>>> If I understand correctly the 1000 vb upper bound rational, it\n>>>>>>>>> would be to constraint the pinning counterparty to attach a high fee to a\n>>>>>>>>> child due to the limited size, if they would like this transaction to be\n>>>>>>>>> stuck in the network mempools. By doing so  this child has high odds to\n>>>>>>>>> confirm.\n>>>>>>>>>\n>>>>>>>>> I still wonder if this compatible with miner incentives in period\n>>>>>>>>> of empty mempools, in the sense that if you've already a V3 transaction of\n>>>>>>>>> size 100Kvb offering 2 sat/vb, it's more interesting than a V3 replacement\n>>>>>>>>> candidate of size 1000 vb offering 10 sat/vb. It could be argued the former\n>>>>>>>>> should be conserved.\n>>>>>>>>>\n>>>>>>>>> (That said, the hard thing with any replacement strategy we might\n>>>>>>>>> evict a parent transaction *now* to which is attached a high-feerate child\n>>>>>>>>> *latter* making for a utxo considered the best ancestor set. Maybe in the\n>>>>>>>>> long-term miners should keep every transaction ever accepted...)\n>>>>>>>>>\n>>>>>>>>> > (Lower bound) the smaller this limit, the fewer UTXOs a child\n>>>>>>>>> may use\n>>>>>>>>> > to fund this fee-bump. For example, only allowing the V3 child\n>>>>>>>>> to have\n>>>>>>>>> > 2 inputs would require L2 protocols to manage a wallet with\n>>>>>>>>> high-value\n>>>>>>>>> > UTXOs and make batched fee-bumping impossible. However, as the\n>>>>>>>>> > fee-bumping child only needs to fund fees (as opposed to\n>>>>>>>>> payments),\n>>>>>>>>> > just a few UTXOs should suffice.\n>>>>>>>>>\n>>>>>>>>> Reminder for L2 devs, batched fee-bumping of time-sensitive\n>>>>>>>>> confirmations of commitment transactions is unsafe, as the counterparty\n>>>>>>>>> could enter in a \"cat-and-mouse\" game to replace one of the batch element\n>>>>>>>>> at each block to delay confirmation of the remaining elements in the batch,\n>>>>>>>>> I think.\n>>>>>>>>>\n>>>>>>>>> On the other hand, I wonder if we wouldn't want a higher bound. LN\n>>>>>>>>> wallets are likely to have one big UTXO in their fee-bumping reserve pool,\n>>>>>>>>> as the cost of acquiring UTXO is non-null and in the optimistic case, you\n>>>>>>>>> don't need to do unilateral closure. Let's say you close dozens of channels\n>>>>>>>>> at the same time, a UTXO pool management strategy might be to fan-out the\n>>>>>>>>> first spends UTXOs in N fan-out outputs ready to feed the remaining\n>>>>>>>>> in-flight channels.\n>>>>>>>>>\n>>>>>>>>> > 1. The rule around unconfirmed inputs was\n>>>>>>>>> > originally \"A package may include new unconfirmed inputs, but the\n>>>>>>>>> > ancestor feerate of the child must be at least as high as the\n>>>>>>>>> ancestor\n>>>>>>>>> > feerates of every transaction being replaced.\"\n>>>>>>>>>\n>>>>>>>>> Note, I think we would like this new RBF rule to also apply to\n>>>>>>>>> single transaction package, e.g second-stage HTLC transactions, where a\n>>>>>>>>> counterparty pins a HTLC-preimage by abusing rule 3. In that case, the\n>>>>>>>>> honest LN node should be able to broadcast a \"at least as high ancestor\n>>>>>>>>> feerate\" HTLC-timeout transaction. With `option_anchor_outputs\" there is no\n>>>>>>>>> unconfirmed ancestor to replace, as the commitment transaction, whatever\n>>>>>>>>> the party it is originating from, should already be confirmed.\n>>>>>>>>>\n>>>>>>>>> > \"Is this a privacy issue, i.e. doesn't it allow fingerprinting LN\n>>>>>>>>> transactions based on nVersion?\"\n>>>>>>>>>\n>>>>>>>>> As of today, I think yes you can already fingerprint LN\n>>>>>>>>> transactions on the  spec-defined amount value of the anchor outputs, 330\n>>>>>>>>> sats. There is always one of them on post-anchor commitment transactions.\n>>>>>>>>> And sadly I would say we'll always have tricky fingerprints leaking from\n>>>>>>>>> unilateral LN closures such as HTLC/PTLC timelocks...\n>>>>>>>>>\n>>>>>>>>> > \"Can a V2 transaction replace a V3 transaction and vice versa?\"\n>>>>>>>>>\n>>>>>>>>> IIUC, a V3 package could replace a V2 package, with the benefit of\n>>>>>>>>> the new package RBF rules applied. I think this would be a significant\n>>>>>>>>> advantage for LN, as for the current ~85k of opened channels, the old V2\n>>>>>>>>> states shouldn't be pinning vectors. Currently, commitment transactions\n>>>>>>>>> signal replaceability.\n>>>>>>>>>\n>>>>>>>>> Le ven. 23 sept. 2022 \u00e0 11:26, Gloria Zhao via bitcoin-dev <\n>>>>>>>>> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>>>>>>>>>\n>>>>>>>>>> Hi everyone,\n>>>>>>>>>>\n>>>>>>>>>> I'm writing to propose a very simple set of mempool/transaction\n>>>>>>>>>> relay\n>>>>>>>>>> policies intended to aid L2/contract protocols. I realized that\n>>>>>>>>>> the previously proposed Package Mempool Accept package RBF [1]\n>>>>>>>>>> had a few remaining problems after digging into the RBF logic\n>>>>>>>>>> more [2].\n>>>>>>>>>> This additional set of policies solves them without requiring a\n>>>>>>>>>> huge RBF overhaul.\n>>>>>>>>>>\n>>>>>>>>>> I've written an implementation (and docs) for Bitcoin Core:\n>>>>>>>>>> https://github.com/bitcoin/bitcoin/pull/25038\n>>>>>>>>>>\n>>>>>>>>>> (You may notice that this proposal incorporates feedback on the\n>>>>>>>>>> PR - thanks Suhas Daftuar, Gregory Sanders, Bastien Teinturier, Anthony\n>>>>>>>>>> Towns, and others.)\n>>>>>>>>>>\n>>>>>>>>>> If you are interested in using package RBF/relay to bump presigned\n>>>>>>>>>> transactions, I think you may be interested in reviewing this\n>>>>>>>>>> proposal.\n>>>>>>>>>> This should solve Rule 3 pinning and perhaps allow us\n>>>>>>>>>> to get rid of CPFP carve-out (yay!). I'm keen to hear if people\n>>>>>>>>>> find\n>>>>>>>>>> the 1-anchor-output, 1000vB child limit too restrictive. Also, if\n>>>>>>>>>> you find a\n>>>>>>>>>> pinning attack or something that makes it unusable for you, I\n>>>>>>>>>> would\n>>>>>>>>>> really really like to know.\n>>>>>>>>>>\n>>>>>>>>>> Note that transactions with nVersion=3 (\"V3 transactions\") are\n>>>>>>>>>> currently non-standard in Bitcoin Core. That means **anything\n>>>>>>>>>> that was\n>>>>>>>>>> standard before this policy change would still be standard\n>>>>>>>>>> afterwards.** If you don't want your transactions to be subject to\n>>>>>>>>>> these rules, just continue whatever you're doing and don't use\n>>>>>>>>>> nVersion=3. AFAICT this shouldn't break anything, but let me know\n>>>>>>>>>> if\n>>>>>>>>>> this would be disruptive for you?\n>>>>>>>>>>\n>>>>>>>>>> **New Policies:**\n>>>>>>>>>>\n>>>>>>>>>> This includes:\n>>>>>>>>>> - a set of additional policy rules applying to V3 transactions\n>>>>>>>>>> - modifications to package RBF rules\n>>>>>>>>>>\n>>>>>>>>>> **V3 transactions:**\n>>>>>>>>>>\n>>>>>>>>>> Existing standardness rules apply to V3 (e.g. min/max tx weight,\n>>>>>>>>>> standard output types, cleanstack, etc.). The following additional\n>>>>>>>>>> rules apply to V3:\n>>>>>>>>>>\n>>>>>>>>>> 1. A V3 transaction can be replaced, even if it does not signal\n>>>>>>>>>> BIP125\n>>>>>>>>>>    replaceability. (It must also meet the other RBF rules around\n>>>>>>>>>> fees,\n>>>>>>>>>> etc. for replacement to happen).\n>>>>>>>>>>\n>>>>>>>>>> 2. Any descendant of an unconfirmed V3 transaction must also be\n>>>>>>>>>> V3.\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: Combined with Rule 1, this gives us the property of\n>>>>>>>>>> \"inherited\" replaceability signaling when descendants of\n>>>>>>>>>> unconfirmed\n>>>>>>>>>> transactions are created. Additionally, checking whether a\n>>>>>>>>>> transaction\n>>>>>>>>>> signals replaceability this way does not require mempool\n>>>>>>>>>> traversal,\n>>>>>>>>>> and does not change based on what transactions are mined. It also\n>>>>>>>>>> makes subsequent rules about descendant limits much easier to\n>>>>>>>>>> check.\n>>>>>>>>>>\n>>>>>>>>>> *Note*: The descendant of a *confirmed* V3 transaction does not\n>>>>>>>>>> need to be V3.\n>>>>>>>>>>\n>>>>>>>>>> 3. An unconfirmed V3 transaction cannot have more than 1\n>>>>>>>>>> descendant.\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: (Upper bound) the larger the descendant limit, the\n>>>>>>>>>> more\n>>>>>>>>>> transactions may need to be replaced. This is a problematic\n>>>>>>>>>> pinning\n>>>>>>>>>> attack, i.e., a malicious counterparty prevents the transaction\n>>>>>>>>>> from\n>>>>>>>>>> being replaced by adding many descendant transactions that aren't\n>>>>>>>>>> fee-bumping.\n>>>>>>>>>>\n>>>>>>>>>> (Lower bound) at least 1 descendant is required to allow CPFP of\n>>>>>>>>>> the\n>>>>>>>>>> presigned transaction. The contract protocol can create presigned\n>>>>>>>>>> transactions paying 0 fees and 1 output for attaching a CPFP at\n>>>>>>>>>> broadcast time (\"anchor output\"). Without package RBF, multiple\n>>>>>>>>>> anchor\n>>>>>>>>>> outputs would be required to allow each counterparty to fee-bump\n>>>>>>>>>> any\n>>>>>>>>>> presigned transaction. With package RBF, since the presigned\n>>>>>>>>>> transactions can replace each other, 1 anchor output is\n>>>>>>>>>> sufficient.\n>>>>>>>>>>\n>>>>>>>>>> 4. A V3 transaction that has an unconfirmed V3 ancestor cannot be\n>>>>>>>>>>    larger than 1000 virtual bytes.\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: (Upper bound) the larger the descendant size limit,\n>>>>>>>>>> the\n>>>>>>>>>> more vbytes may need to be replaced. With default limits, if the\n>>>>>>>>>> child\n>>>>>>>>>> is e.g. 100,000vB, that might be an additional 100,000sats (at\n>>>>>>>>>> 1sat/vbyte) or more, depending on the feerate.\n>>>>>>>>>>\n>>>>>>>>>> (Lower bound) the smaller this limit, the fewer UTXOs a child may\n>>>>>>>>>> use\n>>>>>>>>>> to fund this fee-bump. For example, only allowing the V3 child to\n>>>>>>>>>> have\n>>>>>>>>>> 2 inputs would require L2 protocols to manage a wallet with\n>>>>>>>>>> high-value\n>>>>>>>>>> UTXOs and make batched fee-bumping impossible. However, as the\n>>>>>>>>>> fee-bumping child only needs to fund fees (as opposed to\n>>>>>>>>>> payments),\n>>>>>>>>>> just a few UTXOs should suffice.\n>>>>>>>>>>\n>>>>>>>>>> With a limit of 1000 virtual bytes, depending on the output\n>>>>>>>>>> types, the\n>>>>>>>>>> child can have 6-15 UTXOs, which should be enough to fund a\n>>>>>>>>>> fee-bump\n>>>>>>>>>> without requiring a carefully-managed UTXO pool. With 1000 virtual\n>>>>>>>>>> bytes as the descendant limit, the cost to replace a V3\n>>>>>>>>>> transaction\n>>>>>>>>>> has much lower variance.\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: This makes the rule very easily \"tacked on\" to\n>>>>>>>>>> existing\n>>>>>>>>>> logic for policy and wallets. A transaction may be up to 100KvB\n>>>>>>>>>> on its\n>>>>>>>>>> own (`MAX_STANDARD_TX_WEIGHT`) and 101KvB with descendants\n>>>>>>>>>> (`DEFAULT_DESCENDANT_SIZE_LIMIT_KVB`). If an existing V3\n>>>>>>>>>> transaction\n>>>>>>>>>> in the mempool is 100KvB, its descendant can only be 1000vB, even\n>>>>>>>>>> if\n>>>>>>>>>> the policy is 10KvB.\n>>>>>>>>>>\n>>>>>>>>>> **Package RBF modifications:**\n>>>>>>>>>>\n>>>>>>>>>> 1. The rule around unconfirmed inputs was\n>>>>>>>>>> originally \"A package may include new unconfirmed inputs, but the\n>>>>>>>>>> ancestor feerate of the child must be at least as high as the\n>>>>>>>>>> ancestor\n>>>>>>>>>> feerates of every transaction being replaced.\"\n>>>>>>>>>>\n>>>>>>>>>> The package may still include new unconfirmed inputs. However,\n>>>>>>>>>> the new rule is modified to be \"The minimum between package\n>>>>>>>>>> feerate\n>>>>>>>>>> and ancestor feerate of the child is not lower than the individual\n>>>>>>>>>> feerates of all directly conflicting transactions and the ancestor\n>>>>>>>>>> feerates of all original transactions.\"\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: We are attempting to ensure that the replacement\n>>>>>>>>>> transactions are not less incentive-compatible to mine. However, a\n>>>>>>>>>> package/transaction's ancestor feerate is not perfectly\n>>>>>>>>>> representative\n>>>>>>>>>> of its incentive compatibility; it may overestimate (some subset\n>>>>>>>>>> of\n>>>>>>>>>> the ancestors could be included by itself if it has other\n>>>>>>>>>> high-feerate\n>>>>>>>>>> descendants or are themselves higher feerate than this\n>>>>>>>>>> package/transaction). Instead, we use the minimum between the\n>>>>>>>>>> package\n>>>>>>>>>> feerate and ancestor feerate of the child as a more conservative\n>>>>>>>>>> value\n>>>>>>>>>> than what was proposed originally.\n>>>>>>>>>>\n>>>>>>>>>> 2. A new rule is added, requiring that all package transactions\n>>>>>>>>>> with\n>>>>>>>>>> mempool conflicts to be V3. This also means the \"sponsoring\"\n>>>>>>>>>> child transaction must be V3.\n>>>>>>>>>>\n>>>>>>>>>> *Note*: Combined with the V3 rules, this means the package must be\n>>>>>>>>>> a child-with-parents package. Since package validation is only\n>>>>>>>>>> attempted if the transactions do not pay sufficient fees to be\n>>>>>>>>>> accepted on their own, this effectively means that only V3\n>>>>>>>>>> transactions can pay to replace their ancestors' conflicts, and\n>>>>>>>>>> only\n>>>>>>>>>> V3 transactions' replacements may be paid for by a descendant.\n>>>>>>>>>>\n>>>>>>>>>> *Rationale*: The fee-related rules are economically rational for\n>>>>>>>>>> ancestor packages, but not necessarily other types of packages.\n>>>>>>>>>> A child-with-parents package is a type of ancestor package. It\n>>>>>>>>>> may be fine to allow any ancestor package, but it's more difficult\n>>>>>>>>>> to account for all of the possibilities. For example, it gets much\n>>>>>>>>>> harder to see that we're applying the descendant limits correctly\n>>>>>>>>>> if\n>>>>>>>>>> the package has a gnarly, many-generation, non-tree shape. I'm\n>>>>>>>>>> also\n>>>>>>>>>> not sure if this policy is 100% incentive-compatible if the\n>>>>>>>>>> sponsor\n>>>>>>>>>> is not a direct descendant of the sponsee.\n>>>>>>>>>>\n>>>>>>>>>> Please see doc/policy/version3_transactions.md and\n>>>>>>>>>> doc/policy/packages.md in the PR for the full set of rules.\n>>>>>>>>>>\n>>>>>>>>>> **Intended usage for LN:**\n>>>>>>>>>>\n>>>>>>>>>> Commitment transactions should be V3 and have 1 anchor output.\n>>>>>>>>>> They\n>>>>>>>>>> can be signed with 0 fees (or 1sat/vbyte) once package relay is\n>>>>>>>>>> deployed\n>>>>>>>>>> on a significant portion of the network. If the commitment tx must\n>>>>>>>>>> be broadcast, determine the desired feerate at broadcast time and\n>>>>>>>>>> spend the anchor output in a high feerate transaction. I'm going\n>>>>>>>>>> to\n>>>>>>>>>> call the broadcasted commitment tx \"the parent\" and the attached\n>>>>>>>>>> fee-bumping tx \"the child.\"\n>>>>>>>>>>\n>>>>>>>>>> - This child must be V3.\n>>>>>>>>>> - This child must be at most 1000vB. Note this restricts the\n>>>>>>>>>>   number of inputs you can use to fund the fee bump. Depending\n>>>>>>>>>> on the output types, this is around 6-15.\n>>>>>>>>>> - One child may fund fees for multiple commitment tx (\"batched\n>>>>>>>>>>   fee-bumping\").\n>>>>>>>>>> - To do a second fee-bump to add more fees, replace the\n>>>>>>>>>>   *child* with a higher-feerate tx. Do not try to attach a\n>>>>>>>>>> grandchild.\n>>>>>>>>>>\n>>>>>>>>>> Otherwise, never try to spend from an unconfirmed V3 transaction.\n>>>>>>>>>> The\n>>>>>>>>>> descendant limits for V3 transactions are very restrictive.\n>>>>>>>>>>\n>>>>>>>>>> **Expected Questions:**\n>>>>>>>>>>\n>>>>>>>>>> \"Does this fix Rule 3 Pinning?\"\n>>>>>>>>>> Yes. The V3 descendant limit restricts both you and your\n>>>>>>>>>> counterparty.\n>>>>>>>>>> Assuming nodes adopted this policy, you may reasonably assume\n>>>>>>>>>> that you\n>>>>>>>>>> only need to replace the commitment transaction + up to 1000vB.\n>>>>>>>>>>\n>>>>>>>>>> \"Only 1 anchor output? What if I need to bump counterparty's\n>>>>>>>>>> commitment tx in mempool?\"\n>>>>>>>>>> You won't need to fee-bump a counterparty's commitment tx using\n>>>>>>>>>> CPFP.\n>>>>>>>>>> You would just package RBF it by attaching a high-feerate child to\n>>>>>>>>>> your commitment tx.\n>>>>>>>>>>\n>>>>>>>>>> \"Is this a privacy issue, i.e. doesn't it allow fingerprinting LN\n>>>>>>>>>> transactions based on nVersion?\"\n>>>>>>>>>> Indeed it may be unrealistic to assume V3 transactions will be in\n>>>>>>>>>> widespread use outside of L2. IIUC, unilateral closes are already\n>>>>>>>>>> obvious LN transactions because of the HTLC inputs. For e.g.\n>>>>>>>>>> cooperative closes and opens, I think it makes sense to continue\n>>>>>>>>>> using\n>>>>>>>>>> V2. So, unless I'm missing something, this shouldn't make it\n>>>>>>>>>> worse.\n>>>>>>>>>>\n>>>>>>>>>> \"So a V3 transaction that doesn't signal BIP125 replaceability is\n>>>>>>>>>> replaceable? Is that a backward compatibility issue?\"\n>>>>>>>>>> Yes it's replaceable. It's not an issue AFAICT because,\n>>>>>>>>>> under previous policy, the V3 transaction wouldn't have been\n>>>>>>>>>> in the mempool in the first place.\n>>>>>>>>>>\n>>>>>>>>>> \"Can a V2 transaction replace a V3 transaction and vice versa?\"\n>>>>>>>>>> Yes, otherwise someone can use V3 transactions to censor V2\n>>>>>>>>>> transactions spending shared inputs. Note if the\n>>>>>>>>>> original V3 transaction has an unconfirmed V3 parent, this would\n>>>>>>>>>> violate the \"inherited V3\" rule and would be rejected.\n>>>>>>>>>>\n>>>>>>>>>> Thanks for reading! Feedback and review would be much appreciated.\n>>>>>>>>>>\n>>>>>>>>>> [1]:\n>>>>>>>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019464.html\n>>>>>>>>>> [2]:\n>>>>>>>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html\n>>>>>>>>>>\n>>>>>>>>>> Best,\n>>>>>>>>>> Gloria\n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> bitcoin-dev mailing list\n>>>>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>>>>\n>>>>>>>>> _______________________________________________\n>>>>>>>>> bitcoin-dev mailing list\n>>>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>>>\n>>>>>>>> _______________________________________________\n>>>>>>>> bitcoin-dev mailing list\n>>>>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>>>>\n>>>>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221001/353840a2/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "New transaction policies (nVersion=3) for contracting protocols",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ruben Somsen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 39275
        }
    },
    {
        "title": "[bitcoin-dev] bitcoin-inquistion: evaluating soft forks on signet",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2022-10-02T04:06:54",
                "message_text_only": "On Wed, Sep 28, 2022 at 11:48:32AM +0000, Michael Folkson via bitcoin-dev wrote:\n> SegWit was added\n> to a new testnet (Segnet) for testing rather than the pre-existing testnet\n> and I think future soft fork proposals should follow a similar approach.\n\nI think past history falls into a few groups:\n\n * p2sh was briefly tested on testnet (and an alternative was tested on\n   mainnet)\n    https://bitcointalk.org/index.php?topic=58579.msg786939#msg786939\n\n * cltv and csv were mostly tested on elements alpha (liquid precursor\n   testnet); though they were activated on testnet 6 and 11 weeks prior\n   to mainnet\n    http://diyhpl.us/wiki/transcripts/gmaxwell-sidechains-elements/\n\n * segwit was also tested via elements alpha, though in a different\n   form to what was deployed for bitcoin (ie, the elements approach\n   would have been a hard fork). because of the p2p changes (you need\n   additional data to validate blocks post segwit), segwit had dedicated\n   test networks, up to segnet4, from 1st Jan 2016 to 30th Mar 2016.\n   segwit was activated on testnet on 13th May 2016, merged into core on\n   25th June 2016, and included in the 0.13.1 released on 27th October\n   2016. I couldn't find very good public references about segnet, and\n   don't think it saw much use outside of people implementing segwit\n   consensus features themselves.\n\n * taproot was merged 15th October 2020 (#18267), and activated on\n   signet as of genesis around 21st October 2020 (#20157). It was locked\n   in on mainnet on 12th June 2021, activated on testnet on 8th July\n   2021, and activated on mainnet on 14th November 2021.\n\n * CTV had ctv-signet created around 17th December 2020, but it wasn't\n   really announced or encouraged until 17th Feb 2022. The core PR\n   (#21702) was opened 16th April 2021.\n    https://www.erisian.com.au/bitcoin-core-dev/log-2020-12-17.html#l-845\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019925.html\n\n * I think Drivechains has a DriveNet testnet (since 2018 or earlier?),\n   though I don't see an explorer, and it looks like the bitcoin code\n   it's based on predates taproot.\n\n * Other than CTV, Drivechains and ideas being explored on Liquid,\n   most other ideas for bitcoin consensus changes haven't really\n   progressed past a gist, mailing list post, bip or draft patch\n   to somewhere that you can actually experiment (great consensus\n   cleanup, anyprevout, OP_TX/TXHASH, TLUV, SIGHASH_GROUP, PUSH_ANNEX,\n   checkblockatheight, g'root/graftroot, etc...)\n\nI thing segnet was mostly used for development of segwit itself, rather\nthan testing or application development -- it was reset about once a\nmonth as changes to the segwit design occurred, and after the design\nwas finalised, was active on testnet, either using -addnode to connect\ndirectly to know segwit-enabled peers, or, eventually, with seed nodes\nupdated and filtering via the WITNESS feature. The 23rd June 2016\nmeeting logs have some relevant discussion:\n https://www.erisian.com.au/bitcoin-core-dev/log-2016-06-23.html#l-178\n\n> Even if there is community consensus on what soft fork proposals should be added to the default signet today (which may or may not be case) I find it highly unlikely this will always be the case.\n\nThe point of doing it via signet and outside of core is there doesn't\nneed to be any community consensus on soft forks. Unlike mainnet, signet\nsBTC isn't money, and it isn't permissionless; and unlike merging it\ninto core, there isn't a risk of a mege having unintended side effects\nimpacting mainnet operation.\n\n> We then get into the situation where the block signers (currently AJ and Kalle) are the gatekeepers on what soft fork proposals are added.\n\nBecause signet mining is a closed set (determined by the first block\nafter genesis when the signetchallenge is locked in), signet soft forks\nalways have gatekeepers. If signet miners don't opt-in to new soft forks\n(by upgrading their node to allow mempool acceptance according to new\nsoft fork rules, and thus allow inclusion in block templates; or, if\nthey're running with -acceptnonstdtxn, to reject txs that don't comply\nwith the rules, so that funds using the new rules aren't actually anyone\ncan spend) then you can't test the new soft fork rules on signet.\n\n> I don't think it is fair on the signet block signers to put them in that position and I don't think it is wise to put other Bitcoin Core contributors/maintainers in the position of having to defend why some proposed soft forks are accessible on the default signet while others aren't.\n\nSo, I think it's more accurate to say signet miners are fundamentally\n*already* in that position. They can delegate that power of course,\nsaying \"we'll just implement the default rules for the software we run\",\nbut that just moves the responsibility around.\n\n> The default signet was a long term project to address the unreliability and weaknesses of testnet.\n\nThat's certainly one goal. For me, that's one facet of the broader goal,\nwhich is to make it easier to develop and test new and improved bitcoin\napplications. So applications like vaults and eltoo that rely on the\ncreation of new consensus (or relay) features are important to me too.\n\nHaving taproot enabled on signet relatively early seemed like a win to me,\nand, personally, I think it's something we should work out how to repeat.\n\n> Many default signet users won't be interested in testing soft fork proposals and it is not reasonable for them to be subject to a stalling or forked blockchain \n\nSure, that's absolutely a concern. I even raised it in the original\npost:\n\n>>> before actually mining blocks I want to make the signet miner able\n>>> to automatically detect/recover if the bitcoin-inquisition node either\n>>> crashes or starts producing incompatible blocks.\n\nI think I've got a specific approach there that I'm happy with now; it's\nPRed as https://github.com/bitcoin-inquisition/bitcoin/pull/7\n\nThe idea is that if you want to mine \"inquisition\" blocks to test out a\nsoft fork, you run both a core and an inquistion bitcoind, but only use\nthe inquisition bitcoind for generating blocks -- you *always* submit\nblocks to the core bitcoind (and if core rejects and inquisition block,\nyou generate a new template using core and mine and submit that). That\nway blocks are never submitted to the network unless they satisfy core's\nconsensus rules, and from core's perspective the chain always progresses.\n\n> because changes to a soft fork proposal or a buggy soft fork proposal pushed to the default signet makes previous valid/invalid transactions invalid/valid.\n\nThe above addresses the invalid to valid case for consensus rules (ie,\nthe part that would make a change not be a \"soft fork\").\n\nThe normal cases for a soft fork are:\n * making a consensus valid transaction, invalid\n * making a relay invalid transaction, valid\n\nThat leaves the final category for buggy behaviour as making a relay\nvalid transaction invalid for relay. It's not clear to me that dealing\nwith that automatically is a good idea -- that's a pretty severe class\nof bug that could result in people being unable to spend their funds;\nso maybe the best thing is for txs like that to be ignored by the\nminers until the build up in the mempool and people start complaining\nand insisting the bug get fixed?\n\nThat's also a reason to have it happen on the global signet: you don't\nwant people developing new soft fork rules to introduce such a bug and\nnot notice it because the people making such transactions don't care about\nthe soft fork, and then have it suddenly appear once it's already locked\nin on mainnet. Better to have the bug impact signet transactions first,\nbefore there's any risk of bugs affecting real money.\n\n> If they want to test proposed soft forks on a custom signet they are opting in to possible disruption rather than it being forced upon them.\n\nIf you don't want to risk any disruption, then regtest or a private\nsignet is a better option. A global p2p network *always* has risk of\ndisruption at some level or another.\n\nBut again, opting-in to potential disruption from future soft forks that\nare anywhere near the deployment phase is a *good* idea: far better for\nthe potential disruption to become real and observable when it only\naffects fake money, and to fix it then, rather than having the risk\nof losing real money  due to bugs in features you didn't think you\ncared about.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-02T06:12:10",
                "message_text_only": "On Fri, Sep 16, 2022 at 05:15:45PM +1000, Anthony Towns via bitcoin-dev wrote:\n> So that's the concept. For practical purposes, I haven't yet merged\n> either CTV or APO support into the bitcoin-inquisition 23.0 branch yet\n\nI've now merged CTV and updated my signet miner to enforce both CTV and\nAPO (though you'd need to be either lucky or put some effort into it to\nfigure out how to get a CTV/APO transaction relayed to my miner).\n\nUpdating APO to be compatible with CTV actually seems to have found a\npreviously unknown bug in the CTV PR against core [0], so that seems\nproductive at the very least.\n\n[0] https://github.com/bitcoin-inquisition/bitcoin/pull/8\n    https://github.com/bitcoin/bitcoin/pull/21702#pullrequestreview-1118047730\n\nI've also mined a couple of test APO transactions [1]; both reusing an\nAPOAS signature [2], including demonstrating the case where a third party\ncan replay APO signatures to send funds from duplicate UTXOs to fees,\nby spending those UTXOs in a single tx [3] [4].\n\n[1] https://mempool.space/signet/address/tb1pesae595q3cpzp8j3gy07gussw9t9hh580xj027sfz6g8e530u3nqscn0yn\n\n[2] \"ec764a8ed632916868ca6dbfdc5bed95f74b83be62d01397aba7ec916982c6721c923fa22d29b5e0c4fddde0148233f0cf401758df23d8cc89c88f04beffc3c3c1\" -- sighash of 0xc1 = ANYPREVOUTANYSCRIPT|ALL\n\n    https://mempool.space/signet/tx/ee6f6eda93a3d80f4f65f2e1000334132c9a014b3ed3dec888fdcc1f3441f52c\n    https://mempool.space/signet/tx/2cbcc4857e6ee8510d9479c01fbf133a9a2cde3f5c61ccf9439c69b7b83334ba\n\n[3] https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki#Signature_replay\n\n[4] https://mempool.space/signet/tx/53a9747546e378956072795351e8436cf704da72d235c8ac7560787b554a4d3f\n\nCheers,\naj"
            },
            {
                "author": "Michael Folkson",
                "date": "2022-10-02T15:25:19",
                "message_text_only": "Thanks for this AJ, especially the history on prior soft forks, the vast majority of which I was unclear on.\n\n> The point of doing it via signet and outside of core is there doesn't\nneed to be any community consensus on soft forks. Unlike mainnet, signet\nsBTC isn't money, and it isn't permissionless; and unlike merging it\ninto core, there isn't a risk of a mege having unintended side effects\nimpacting mainnet operation.\n\nAgreed. I'm obviously much happier with proposed consensus changes being activated prematurely on a signet (default or custom) than on mainnet.\n\n> Because signet mining is a closed set (determined by the first block\nafter genesis when the signetchallenge is locked in), signet soft forks\nalways have gatekeepers.\n\nI'm also perfectly happy with the status quo of the default signet having block signers and gatekeepers for soft forks activated on the default signet. I'm more concerned with those gatekeepers being under pressure to merge unfinished, buggy soft fork proposals on the default signet which need to be reversed or changed disrupting all default signet users. The bar for mainnet activations is obviously much higher than for the default signet but the default signet does still need a bar.\n\n> If you don't want to risk any disruption, then regtest or a private\nsignet is a better option. A global p2p network *always* has risk of\ndisruption at some level or another.\n\nRight but disruption isn't boolean, it is a spectrum. It isn't disruption or zero disruption. The more soft fork proposals that are enabled on the default signet (and the more changes to those soft fork proposals pushed to the default signet) the higher the risk of a stalling blockchain (your signet node rejects a block the rest of the signet network accepts). The small number of block signers (currently 2) should prevent you being forked off entirely onto a different default signet chain with new mined blocks being added to your blockchain tip but your blockchain could stall.\n\nWhat should happen in this scenario? Say I'm a default signet full node runner and I don't want to run any code outside of say the Bitcoin Core repo. I don't care about the proposed soft forks being tested on the default signet, I just care about testing my application with the existing consensus rules on mainnet. However, my default signet blockchain has stalled because of some consensus rule adjustment (an effective hard fork) made by the signet miners and the block signers. I have to run a patch from bitcoin-inquisition to get my node adding blocks again? I'm essentially being forced to run code from bitcoin-inquisition or wait many months for a default signet checkpoint in a Core release.\n\nI looked into linux-next[0] which you mentioned as an interesting parallel in the Linux ecosystem on last week's Bitcoin Optech Twitter Spaces [1]. In that link linux-next is described as:\n\n\"The linux-next tree is the holding area for patches aimed at the next kernel merge window.\"\n\nI guess I'd also want expectations to be tempered a little for consensus changes on bitcoin-inquisition versus say this description of linux-next. I don't know where the bar will be set for default signet soft fork activations by the block signers and the miners but wherever it is set it will be lower than mainnet. And to be considered for activation on mainnet these proposals do require community consensus if we want to minimize the risk of mainnet chain splits. There are no block signers or regularly updated checkpoints on mainnet. It is certainly possible that soft fork proposals that get activated on the default signet never get activated on mainnet and that being activated on the default signet offers no guarantees or even intentions/aims for the next Bitcoin Core (or any alternative implementation) release. I'd like to avoid the \"my soft fork proposal has been activated on the default signet so you should expect it to be activated on mainnet within x months or y years\" type thing.\n\nThanks\nMichael\n\n[0]: https://www.kernel.org/doc/man-pages/linux-next.html\n[1]: https://twitter.com/bitcoinoptech/status/1574697495325974528?s=20&t=XWkpA459C9qxOOrBuP2fYA\n\n--\nMichael Folkson\nEmail: michaelfolkson at protonmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n\n------- Original Message -------\nOn Sunday, October 2nd, 2022 at 07:12, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On Fri, Sep 16, 2022 at 05:15:45PM +1000, Anthony Towns via bitcoin-dev wrote:\n> \n> > So that's the concept. For practical purposes, I haven't yet merged\n> > either CTV or APO support into the bitcoin-inquisition 23.0 branch yet\n> \n> \n> I've now merged CTV and updated my signet miner to enforce both CTV and\n> APO (though you'd need to be either lucky or put some effort into it to\n> figure out how to get a CTV/APO transaction relayed to my miner).\n> \n> Updating APO to be compatible with CTV actually seems to have found a\n> previously unknown bug in the CTV PR against core [0], so that seems\n> productive at the very least.\n> \n> [0] https://github.com/bitcoin-inquisition/bitcoin/pull/8\n> https://github.com/bitcoin/bitcoin/pull/21702#pullrequestreview-1118047730\n> \n> I've also mined a couple of test APO transactions [1]; both reusing an\n> APOAS signature [2], including demonstrating the case where a third party\n> can replay APO signatures to send funds from duplicate UTXOs to fees,\n> by spending those UTXOs in a single tx [3] [4].\n> \n> [1] https://mempool.space/signet/address/tb1pesae595q3cpzp8j3gy07gussw9t9hh580xj027sfz6g8e530u3nqscn0yn\n> \n> [2] \"ec764a8ed632916868ca6dbfdc5bed95f74b83be62d01397aba7ec916982c6721c923fa22d29b5e0c4fddde0148233f0cf401758df23d8cc89c88f04beffc3c3c1\" -- sighash of 0xc1 = ANYPREVOUTANYSCRIPT|ALL\n> \n> https://mempool.space/signet/tx/ee6f6eda93a3d80f4f65f2e1000334132c9a014b3ed3dec888fdcc1f3441f52c\n> https://mempool.space/signet/tx/2cbcc4857e6ee8510d9479c01fbf133a9a2cde3f5c61ccf9439c69b7b83334ba\n> \n> [3] https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki#Signature_replay\n> \n> [4] https://mempool.space/signet/tx/53a9747546e378956072795351e8436cf704da72d235c8ac7560787b554a4d3f\n> \n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-03T22:54:04",
                "message_text_only": "On Sun, Oct 02, 2022 at 03:25:19PM +0000, Michael Folkson via bitcoin-dev wrote:\n> I'm also perfectly happy with the status quo of the default signet\n> having block signers and gatekeepers for soft forks activated on the\n> default signet. I'm more concerned with those gatekeepers being under\n> pressure to merge unfinished, buggy soft fork proposals on the default\n> signet which need to be reversed or changed disrupting all default\n> signet users.\n\nFirst, I think it's far better for signet miners to be under that pressure\nthan either mainnet miners or maintainers/devs of bitcoin core. Or for\nthat matter, users of bitcoin who are just trying to use bitcoin and\nnot lose their money to bank confiscation or central bank hyperinflation.\n\nThat's where we stand today, whether you look solely at historical\nprecedent (cltv, csv, segwit were only testable on blockstream's elements\nalpha prior to being merged into core, and combined with confidential\nassets, that's not really a 1:1 test environment; taproot wasn't really\ntestable anywhere prior to being merged into core), or you consider the\nfocus of people actively trying to get forks deployed currently (ctv\nhas been pushing for a merge [0], and considered trying to get users\nand miners to adopt it [1]; likewise the great consensus cleanup first\nproposed a PR for core [2] before posting a bip draft [3] and progress\nstopped when the PR didn't move forwards; likewise drivechains/bip300's\ncurrent deployment approach is \"do a uasf on mainnet\"); or see sentiment\nsuch as [4].\n\n[0] https://www.erisian.com.au/bitcoin-core-dev/log-2022-01-13.html#l-490\n    https://rubin.io/bitcoin/2021/12/24/advent-27/\n\n[1] https://rubin.io/bitcoin/2022/04/17/next-steps-bip119/\n\n[2] https://github.com/bitcoin/bitcoin/pull/15482\n\n[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016714.html\n\n[4] https://twitter.com/CobraBitcoin/status/1570380739010793479\n\nIt's *great* that core maintainers, reviewers, devs, URSF advocates, etc\nare able to resist pressure to merge bad things; what's not great is\ndirecting the time and attention of researchers and devs and businesses\nwho are trying to come up with good things for bitcoin at something that\ndoesn't encourage useful forward progress.\n\nBut second, APO and CTV aren't being kept out of core because they're\n\"unfinished and buggy\" per se (which isn't to say they aren't buggy or\nshouldn't be kept out for that reason); at least in my view, they're\nbeing kept out because of a combination of (a) it's not clear that\nthey're desirable to deploy on mainnet (whether at all, or in comparison\nto other ways of obtaining similar functionality); and (b) prioritising\nreducing risk on mainnet, vs improving the ability to test new ideas\noutside of mainnet.\n\nBugs are much easier to deal with in comparison: you put a bunch of\ntesting/dev effort in to figure out what bugs there might be, then you\nanalyse them, then you fix them. If it were just a matter of finding\nand fixing bugs, that's still hard, sure, but it's something we know\nhow to do.\n\nIt's the broader questions that are trickier: eg, do we want CTV first, or\nCTV+APO at the same time, or just APO first? do we want some subtle tweaks\nto CTV or APO rules to make them better? do we want OP_TXHASH or OP_TX\nor some other variant instead? do we want to skip the intermediate steps\nand go straight to simplicity/lisp? do we want to never have anything\nthat may risk covenant-like behaviour ever? Without even an idea how to\nget answers to those, it's not clear that it even makes sense to spend\nthe time working on finding/fixing obscure implementation bugs in the\nproposals.\n\n(Ultimately, in my opinion, it's the same thing with drivechains and the\ngreat consensus cleanup: are these ideas sensible to deploy on mainnet? If\nthe answer to that were a clear yes for either of them, then it would\nmake sense to work on merging them in core and activating on mainnet;\nbut at least to me, it's not clear whether the answer should be yes,\nyes after some specific set of changes, or no. Nor is it clear what work\nwould help produce a clear answer)\n\nI think breaking the loop there is helpful: get these ideas out on\nsignet, where finding and fixing bugs does matter and is worth doing, but\nwhere you *don't* have to deal with deep existential questions because\nyou're not messing with a multi billion dollar system and committing to\nsupporting the feature for the entire future of humanity.\n\nThen, if there are alternative approaches that people think might be\nbetter, get them out on signet too so that you can do apples-to-apples\ncomparisons: see how much code they are to actually implement, how\nconvenient they are to build on, whether there are any unexpected\ndifferences between theory and practice, etc. Then you can build up real\nanswers to \"is this a sensible thing to deploy on mainnet?\"\n\nFor that, to get things onto signet you really only need to establish:\n\n * it's interesting enough to be worth spending time on\n * it's gone through a decent level of review and there are no known\n   bugs\n * it doesn't conflict too heavily with the other interesting changes\n   we'd like to look at\n\nand as a result you get to see the change in a production-like\nenvironment, and can use that to help get better answers to the deeper,\nharder questions.\n\nThere's definitely some threshold where a proposed soft fork would be\ntoo much effort to add to inquisition -- perhaps that comes with adding\nsomething like Simplicity (\"227 changed files with 72,617 additions\"\n[5]), or perhaps it would be doing something like confidential assets\nwhich is both intrusive and perhaps undesirable for mainnet deployment,\nor perhaps it's just numbers: I had to adjust the APO patches to rebase\nthem on top of CTV; doing that N-1 times (in perhaps N**2 locations?) for\nN soft forks will no doubt get tedious as N increases -- so maybe only\nmerging the \"top 10\" proposals in any six month period would make sense? I\ndon't really see the problem with crossing that bridge when we come to\nit though.\n\n[5] https://github.com/ElementsProject/elements/compare/simplicity\n\nI guess I don't really mind if it's just me and Kalle deciding what the\n\"top 10\" proposals are, or deciding at what point additional PRs get\ntoo hard to merge. But in my ideal world, we'd have multiple devs and\nresearchers reviewing PRs in the inquisition repo, and as the ones doing\nthe work, it would make sense for them also to be the ones deciding what\nprojects are the most interesting and worth spending that effort on, and\nthus which proposals are included and which ones aren't. At least that\nway wannabe gatekeepers have to at least contribute useful review effort.\n\n> Right but disruption isn't boolean, it is a spectrum. It isn't\n> disruption or zero disruption. The more soft fork proposals that are\n> enabled on the default signet (and the more changes to those soft fork\n> proposals pushed to the default signet) the higher the risk of a stalling\n> blockchain\n\nLike I said, I believe PR#7 makes that particular risk negligible (ie,\nfor people following signet with bitcoin core, the risk of a stalling\nchain is no greater than it would be if all the signet miners were also\nonly running bitcoin core).\n\nBut you're right, it is a spectrum: eg, there's also the risk that\na bug in one soft fork interferes with testing another soft fork\n(perhaps core nodes see signet continuing to add blocks, but inquisition\nnodes do not, because the inquisition node's getblocktemplate resulted\nin a block that core accepts but inquisition rejects). There's three\npotential ways of mitigating that risk:\n\n * finding bugs like that during review, before merging the code, let\n   alone running it\n * quickly noticing such bugs, and reorging blocks that trigger them out\n * using the -renounce feature of bitcoin-inquisition to temporarily\n   disable enforcing a buggy soft fork, until a fix can be merged and\n   deployed\n\nBut that risk only affects people following signet using an inquisition\nnode, and occurs whether or not it's a shared chain with bitcoin core\nnodes. I'd hope that we can have good enough review that consensus bugs\nare pretty rare in practice; but in the event that we do have them,\nprobably better that inquisition nodes do fail in obvious ways, so that\nthe bugs get noticed quickly and fixed.\n\n> \"The linux-next tree is the holding area for patches aimed at the next kernel merge window.\"\n> I guess I'd also want expectations to be tempered a little for consensus changes on bitcoin-inquisition versus say this description of linux-next.\n\nI think you're misinterpreting that description. \"aimed at\" doesn't\nmean \"will be accepted during\", and more importantly, linux-next\nis just an inspiration, not a template to follow literally. Anyway,\nhttps://lwn.net/Articles/287155/ might be a better jumping off point if\nyou're interested in that rabbit hole.\n\n> I'd like to avoid the \"my soft fork proposal has been activated on\n> the default signet so you should expect it to be activated on mainnet\n> within x months or y years\" type thing.\n\nLike I said: this is a way to improve the \"evaluation phase\". Think of\nit like the proposal being a kid sitting an exam; that they sit the exam\ndoesn't mean they're going to get an A+, even if you already have to do\na lot of work to sit the exam in the first place.\n\nI think the ideal result from a soft fork proposal evaluation would be:\n\n - this is the explicit proposal [bipN], here are the corresponding\n   changes to the code [PR#N]\n\n - the performance impact on validators/miners of this change is [p]\n   so in the context of the applications mentioned above, that's [x.p,\n   y.p, z.p]. you can observe worst case performance under normal\n   conditions (where relay rules apply) by looking at signet blocks\n   [a, b, c]; worst case performance if a miner is attacking (using\n   non-standard transactions) may look like [d].\n\n - people have come up with other alternative ideas [x, y]. this\n   proposal is superior to [x] because of [objective reason],\n   and superior to [y] because [when we tried it, y turned out to\n   be too annoying to implement/use].\n\n - here are real, functioning examples of useful, new/improved\n   applications that you can build with this feature. if it were activated\n   on mainnet, they could be deployed on day 1, and see real use: [x,\n   y, z]\n\nWe've been pretty good at the first two already; it's the second two\nthat I think are holding back current proposals, and that this would help\nimprove. At least for me, an \"A+\" answer to all of the above would cause\nme to advocate for a proposal to be deployed on mainnet. My concept of\nan A+ answer here is \"this is such a good idea that it's now obvious to\nessentially everyone, and there's no meaningful debate left to have\".\n\nA \"B\" answer, where, say, applications using the feature exist, but\ndon't seem very interesting or valuable is also possible; I'd think\nthat's a \"needs improvement\" result, where maybe you go back and try\nto come up with a better proposal that enables more useful results,\nrather than trying to get it deployed on mainnet. A \"B\" answer still\nleaves open the question of \"is there really a point? changes are risky,\nand signet's not going to test every possible scenario...\"\n\nHaving the outcome of an evaluation be an \"F\" for fail is also useful\n-- maybe it turns out that despite a bunch of people thinking CTV\nor drivechains are cool, that they do make it too easy to destroy\neverything. In that case, having an objective demonstration of the\nfailure mode is a great outcome of an evaluation process: it allows us\nto say \"sorry, it's a waste of time working on this; you'll need to come\nup with an entirely new approach that avoids this flaw\" and have R&D\neffort spent on useful things instead. Far better that than not giving\nan answer and letting people assume \"oh, we just need to hire someone\nfull time to advocate and shepherd the proposal\" and spend more\nR&D effort on a dead end.\n\n(In the event that a proposed soft fork that gets added to inquisition\nenables interesting/non-obvious miner-only attacks -- drivechains\nmaybe? -- I think I'd be open to the idea of manually mining some\nnon-standard signet blocks in order to crystallize what that sort of\nattack might look like)\n\nI'd say the \"length of time\" thing should look more like:\n\n - here's our awesome idea, isn't it exciting?\n - wow, people really are excited, let's implement it and deploy it\n   on signet!\n - great, it's been on signet for a while: here's the applications\n   people have built using our idea: you should have a look!\n - it seems like we've resolved all the issues, and people are pretty\n   excited about using the new apps with real money, let's deploy it\n   on mainnet\n\nthat is \"it's been on signet a long time\" is more about \"here are the\napps that people have developed in that time\" and \"here's the adversarial\nanalysis people have done over that period to see if the idea is safe\nor not\". Whether something gets deployed on mainnet is more a question\nof \"are these apps actually valuable\", \"have the risks been thoroughly\nexplored and minimised\", and \"have alternatives been explored\". If the\nanswer to some/all of those is still \"no\", then having had a long time\nfor that work to happen is probably more a negative than a positive...\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "bitcoin-inquistion: evaluating soft forks on signet",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Michael Folkson"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 29803
        }
    },
    {
        "title": "[bitcoin-dev] Trustless Address Server \u2013 Outsourcing handing out addresses to prevent address reuse",
        "thread_messages": [
            {
                "author": "David A. Harding",
                "date": "2022-10-02T22:48:21",
                "message_text_only": "On 2022-09-29 05:39, Ruben Somsen via bitcoin-dev wrote:\n> An alternative mitigation (more user friendly, but more implementation\n> complexity) would be to require the sender to reveal their intended\n> transaction to the server prior to receiving the address[^9]. This is\n> not a privacy degradation, since the server could already learn this\n> information regardless. If the transaction doesn't end up getting\n> sent, any subsequent attempt to reuse one of the inputs should either\n> be (temporarily) blacklisted or responded to with the same address\n> that was given out earlier\n> [...]\n> [^9]: *This would essentially look like an incomplete but signed\n> transaction where the output address is still missing.*\n\nHi Ruben,\n\nInstead of maintaining a database of inputs that should be blocked or \nmapped to addresses, have the spender submit to you (but not the \nnetwork) a valid transaction paying a placeholder address and in return \ngive them a guaranteed unique address.  They can then broadcast a \ntransaction using the same inputs to pay the guaranteed unique address.  \nIf you don't see that transaction within a reasonable amount of time, \nbroadcast the transaction paying the placeholder address.  This makes it \ncost the same to them whether they use the unique address or not.  By \nplaceholder address, I mean an address of yours that's never received a \npayment but which may have been provided in a previous invoice (e.g. to \nprevent exceeding the gap limit).\n\nIn short, what I think I've described is the BIP78 payjoin protocol \nwithout any payjoining going on (which is allowed by BIP78).  BTCPay \nalready implements BIP78, as do several wallets, and I think it \nsatisfies all the design constraints you've described.\n\n-Dave"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-10-03T23:01:06",
                "message_text_only": "Hi David,\n\nThanks for the excellent suggestion, that makes the protocol much more\nelegant and actually increases my optimism about its practicality. Also,\ninteresting observation that there is overlap with BIP78. From the\nperspective of the recipient it does mean there's a potential privacy\nreduction when a placeholder transaction goes through (these should perhaps\nbe marked in the wallet?), but I suppose this is still better than no\npayment at all. I also like your point that it doubles as a way to\npotentially bridge gaps.\n\nCheers,\nRuben\n\n\n\n\n\n\n\nOn Mon, Oct 3, 2022 at 12:48 AM David A. Harding <dave at dtrt.org> wrote:\n\n> On 2022-09-29 05:39, Ruben Somsen via bitcoin-dev wrote:\n> > An alternative mitigation (more user friendly, but more implementation\n> > complexity) would be to require the sender to reveal their intended\n> > transaction to the server prior to receiving the address[^9]. This is\n> > not a privacy degradation, since the server could already learn this\n> > information regardless. If the transaction doesn't end up getting\n> > sent, any subsequent attempt to reuse one of the inputs should either\n> > be (temporarily) blacklisted or responded to with the same address\n> > that was given out earlier\n> > [...]\n> > [^9]: *This would essentially look like an incomplete but signed\n> > transaction where the output address is still missing.*\n>\n> Hi Ruben,\n>\n> Instead of maintaining a database of inputs that should be blocked or\n> mapped to addresses, have the spender submit to you (but not the\n> network) a valid transaction paying a placeholder address and in return\n> give them a guaranteed unique address.  They can then broadcast a\n> transaction using the same inputs to pay the guaranteed unique address.\n> If you don't see that transaction within a reasonable amount of time,\n> broadcast the transaction paying the placeholder address.  This makes it\n> cost the same to them whether they use the unique address or not.  By\n> placeholder address, I mean an address of yours that's never received a\n> payment but which may have been provided in a previous invoice (e.g. to\n> prevent exceeding the gap limit).\n>\n> In short, what I think I've described is the BIP78 payjoin protocol\n> without any payjoining going on (which is allowed by BIP78).  BTCPay\n> already implements BIP78, as do several wallets, and I think it\n> satisfies all the design constraints you've described.\n>\n> -Dave\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221004/e94a81c6/attachment-0001.html>"
            },
            {
                "author": "rot13maxi",
                "date": "2022-10-17T23:26:15",
                "message_text_only": "Hi all,\n\nI'm working on a light wallet and have been kicking around a really similar idea (we already have a hosted component that knows the user's xpub, why not provide an endpoint that can vend fresh receive addresses to senders and try to make the easy-path for sending bitcoin to our users also be the more private one). I wanted to throw in another thing you can build with this setup: address authentication.\n\nBitcoin addresses don't (generally) carry any semantic information that humans can use at-a-glance to distinguish legitimate addresses from illegitimate addresses. There have been instances of clipboard-hijacking malware that have used this fact to steal bitcoin -- a user goes to a webpage (or email, or IM or whatever), copies an address, and then pastes it into their bitcoin wallet. Unbeknownst to them, the clipboard contents have been replaced with an address controlled by some bad actor. The wallet just builds the transaction to whatever addresses the \"user\" supplied, and the user is none-the-wiser until after the funds have left their wallet.\n\nNow imagine instead that the wallet has some address book with a pubkey for each recipient the user wants to send bitcoin to. Alice wants to pay Bob, so she clicks \"Bob\" in her transaction UI. Her wallet goes and asks the address server for an address for Bob. The address server picks an unused address, and has it signed (depending on the setup, this could be that the address server also has the Address Authentication privkey for bob, or it could be that bob gets some callback or notification, or that bob has pre-signed a batch of addresses. it will depend on the implementation). The address server sends a signed blob back to alice that contains an address and a signature proving that the address is in fact Bob's. Now Alice's wallet can tell whether or not the address it's putting in the transaction output belongs to Bob, even if that data was intercepted between the address server and the wallet (this doesn't help if the address server is malicious or has been compromised, but that's a different problem).\n\nIt would be really nice to have a protocol here that can make wallets interoperable in fetching fresh addresses from Address Servers and in the return schema that can include signatures and other metadata (like optimistic expirations, maybe other invoice data?).\n\nLove the conversation so far. Happy to dig into this further with anyone else interested :)\n\nCheers,\nrijndael\n\n------- Original Message -------\nOn Monday, October 3rd, 2022 at 7:01 PM, Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi David,\n>\n> Thanks for the excellent suggestion, that makes the protocol much more elegant and actually increases my optimism about its practicality. Also, interesting observation that there is overlap with BIP78. From the perspective of the recipient it does mean there's a potential privacy reduction when a placeholder transaction goes through (these should perhaps be marked in the wallet?), but I suppose this is still better than no payment at all. I also like your point that it doubles as a way to potentially bridge gaps.\n>\n> Cheers,\n> Ruben\n>\n> On Mon, Oct 3, 2022 at 12:48 AM David A. Harding <dave at dtrt.org> wrote:\n>\n>> On 2022-09-29 05:39, Ruben Somsen via bitcoin-dev wrote:\n>>> An alternative mitigation (more user friendly, but more implementation\n>>> complexity) would be to require the sender to reveal their intended\n>>> transaction to the server prior to receiving the address[^9]. This is\n>>> not a privacy degradation, since the server could already learn this\n>>> information regardless. If the transaction doesn't end up getting\n>>> sent, any subsequent attempt to reuse one of the inputs should either\n>>> be (temporarily) blacklisted or responded to with the same address\n>>> that was given out earlier\n>>> [...]\n>>> [^9]: *This would essentially look like an incomplete but signed\n>>> transaction where the output address is still missing.*\n>>\n>> Hi Ruben,\n>>\n>> Instead of maintaining a database of inputs that should be blocked or\n>> mapped to addresses, have the spender submit to you (but not the\n>> network) a valid transaction paying a placeholder address and in return\n>> give them a guaranteed unique address. They can then broadcast a\n>> transaction using the same inputs to pay the guaranteed unique address.\n>> If you don't see that transaction within a reasonable amount of time,\n>> broadcast the transaction paying the placeholder address. This makes it\n>> cost the same to them whether they use the unique address or not. By\n>> placeholder address, I mean an address of yours that's never received a\n>> payment but which may have been provided in a previous invoice (e.g. to\n>> prevent exceeding the gap limit).\n>>\n>> In short, what I think I've described is the BIP78 payjoin protocol\n>> without any payjoining going on (which is allowed by BIP78). BTCPay\n>> already implements BIP78, as do several wallets, and I think it\n>> satisfies all the design constraints you've described.\n>>\n>> -Dave\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/6f8d600b/attachment.html>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2022-10-18T00:07:07",
                "message_text_only": "On Mon, Oct 17, 2022 at 7:05 PM rot13maxi via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Unbeknownst to them, the clipboard contents have been replaced with an\n> address controlled by some bad actor.\n>\n[snip]\n\n> Now imagine instead that the wallet has some address book with a pubkey\n> for each recipient the user wants to send bitcoin to.\n>\n\nIsn't this the same problem but now for copy-pasting pubkeys instead of an\naddress?\n\n- Bryan\nhttps://twitter.com/kanzure\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/b48635dc/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-10-18T12:40:38",
                "message_text_only": "Hi Rijndael,\n\nI think your thoughts are pretty much compatible with this proposal, as\nwhat I'm describing (the recipient signing their keys) is also essentially\na form of authentication.\n\nIt's a good observation that in general this makes the communication of\naddresses more secure. I do wish to re-emphasize Bryan's remark that you\nstill need to ensure the pubkey itself is securely communicated.\n\n>depending on the setup, this could be that the address server also has the\nAddress Authentication privkey for bob, or it could be that bob gets some\ncallback or notification, or that bob has pre-signed a batch of addresses\n\nIn my opinion the only meaningful distinction is whether Bob runs the\nTrustless Address Server himself (full privacy) or not. In either case I\nsee no reason to diverge from the model where Bob deposits a batch of\nsigned keys to the server, ensuring that no malicious addresses can be\nhanded out.\n\nNote I discussed the Trustless Address Server design in the first 20\nminutes of this podcast:\nhttps://twitter.com/bitcoinoptech/status/1580573594656333825\n\nAnd I also brought it up in my presentation at Tabconf last Saturday, but\nthat video isn't online yet.\n\nCheers,\nRuben\n\n\n\nOn Tue, Oct 18, 2022 at 2:07 AM Bryan Bishop via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Mon, Oct 17, 2022 at 7:05 PM rot13maxi via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Unbeknownst to them, the clipboard contents have been replaced with an\n>> address controlled by some bad actor.\n>>\n> [snip]\n>\n>> Now imagine instead that the wallet has some address book with a pubkey\n>> for each recipient the user wants to send bitcoin to.\n>>\n>\n> Isn't this the same problem but now for copy-pasting pubkeys instead of an\n> address?\n>\n> - Bryan\n> https://twitter.com/kanzure\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/090a0721/attachment.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2022-10-18T12:42:21",
                "message_text_only": "On Mon, Oct 17, 2022 at 07:07:07PM -0500, Bryan Bishop via bitcoin-dev wrote:\n> \n> Isn't this the same problem but now for copy-pasting pubkeys instead of an\n> address?\n>\n\nNo, as I understand the proposal, the \"public key\" held by the wallet is simply\na signing key used to authenticate addresses, and never leaves the wallet. Yes,\nif the wallet's own memory is compromised, it can be tricked into accepting bad\naddresses, but this is much much harder than compromising data on the clipboard,\nwhich basically any application can do without any \"real\" exploits or special\npermissions.\n\nAs an extreme, this proposal could be run on a hardware wallet which had some\nout-of-band way to obtain and authenticate public keys (similar to Signal QR\ncodes).\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/4b4311f4/attachment.sig>"
            },
            {
                "author": "rot13maxi",
                "date": "2022-10-18T22:46:13",
                "message_text_only": "Hello Andrew and Bryan,\n\n> No, as I understand the proposal, the \"public key\" held by the wallet is simply\n> a signing key used to authenticate addresses, and never leaves the wallet. \n\nThat's right (or at least, that's the intent). Think of importing someone's GPG key and then using it to validate future signed messages from them. In this case, the public key stays in your \"address book\" entry for a person and then whenever you need to fetch a fresh address for them from the Address Server, your wallet can validate that it's for their wallet. \n\nMaking sure that you import a legitimate/authentic public key is a problem, but you only need to do it once per recipient, instead of doing it every time you need to transact with that person. Maybe that's something you solve in UI (i.e. Signal has you compare strings with your counter-party), or something you can solve through other metadata (GPG had WoT, or if you're already using an address server maybe there's some PKI scheme that's appropriate, etc.). \n\n\nRubin, I think you responded on another branch of the thread, but thanks for the podcast link. I'll check it out!\n\nCheers,\n\nRijndael\n\n------- Original Message -------\nOn Tuesday, October 18th, 2022 at 8:42 AM, Andrew Poelstra <apoelstra at wpsoftware.net> wrote:\n\n\n> On Mon, Oct 17, 2022 at 07:07:07PM -0500, Bryan Bishop via bitcoin-dev wrote:\n>\n> > Isn't this the same problem but now for copy-pasting pubkeys instead of an\n> > address?\n>\n>\n> No, as I understand the proposal, the \"public key\" held by the wallet is simply\n> a signing key used to authenticate addresses, and never leaves the wallet. Yes,\n> if the wallet's own memory is compromised, it can be tricked into accepting bad\n> addresses, but this is much much harder than compromising data on the clipboard,\n> which basically any application can do without any \"real\" exploits or special\n> permissions.\n>\n> As an extreme, this proposal could be run on a hardware wallet which had some\n> out-of-band way to obtain and authenticate public keys (similar to Signal QR\n> codes).\n>\n> --\n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web: https://www.wpsoftware.net/andrew\n>\n> The sun is always shining in space\n> -Justin Lewis-Webster"
            }
        ],
        "thread_summary": {
            "title": "Trustless Address Server \u2013 Outsourcing handing out addresses to prevent address reuse",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "rot13maxi",
                "Bryan Bishop",
                "David A. Harding",
                "Andrew Poelstra",
                "Ruben Somsen"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 15921
        }
    },
    {
        "title": "[bitcoin-dev] MuSig2 BIP",
        "thread_messages": [
            {
                "author": "Jonas Nick",
                "date": "2022-10-03T20:41:08",
                "message_text_only": "Since the initial publication of the BIP draft, we incorporated feedback from\nthis mailing list and the development git repository and made significant\nimprovements compared to the initial version. There are multiple implementations\ntoday, and there have been no requests for major changes or features in the past\nweeks. This indicates that now is a good time to proceed with the next step\nof the BIP process. We opened a pull request with the MuSig2 BIP in the git\nrepository:\n\nhttps://github.com/bitcoin/bips/pull/1372\n\nSpecial thanks goes to my co-authors Tim Ruffing and Elliott Jin as well as Adam\nGibson, Anthony Towns, arik-so, Bastien Teinturier, Brandon Black, Greg Sanders,\nJesse Posner, Lloyd Fournier, mplsgrant, nickfarrow, niftynei, Olaoluwa\nOsuntokun, Pieter Wuille, Riccardo Casatta, Russell O'Connor and Rusty Russell\nfor their valuable feedback."
            },
            {
                "author": "Jonas Nick",
                "date": "2022-10-11T15:34:23",
                "message_text_only": "It is still true that cryptography is hard, unfortunately. Yannick Seurin, Tim\nRuffing, Elliott Jin, and I discovered an attack against the latest version of\nBIP MuSig2 in the case that a signer's individual key A = a*G is tweaked before\ngiving it as input to key aggregation.\n\nIn more detail, a signer may be vulnerable if _all_ of the following conditions\nare true:\n\n1. The signer supports signing with a tweaked individual key (as provided to\n    key aggregation) and the tweak is known to the attacker (e.g., as in BIP 32\n    unhardened derivation).\n2. The signer's public key appears at least two times with different tweaks in\n    the set of public keys that are aggregated. This would, for example, be the\n    case if a signer with public key A=a*G creates partial signatures for an\n    aggregate key corresponding to public key set {A, A+t*G} where t is some\n    tweak. Note that an attacker could make this condition true by using the key\n    B = A+t*G after having seen A.\n3. The signer uses \"concurrent signing\", i.e., the signer stores secnonces for\n    multiple signing sessions.\n4. The secret key provided to the Sign algorithm is not yet fully determined when the\n    NonceGen algorithm is called. This would, for example, be the case if the\n    attacker, after having seen the nonce of the signer, can influence whether a\n    or a+t will be provided as a secret key to Sign.\n\nIn this scenario, an attacker may forge a signature for any message and any\naggregate public key that contains the signer's individual public key A (with\nany attacker-chosen tweak). In particular, the attacker may forge a signature\nfor any message and the public key A itself.\n\nCondition 4 should only apply in relatively rare cases unless the signer is\ntricked into such a situation.\n\nFix:\nNote that if the optional secret key argument is provided to the NonceGen\nalgorithm and matches the secret key provided to the Sign algorithm, then\nCondition 4 will not hold. Thus, one definite fix is to make the secret key\nargument to the NonceGen algorithm mandatory. We are investigating other options\nand will follow up shortly with a concrete fix of the BIP draft.\n\nThis discovery does not invalidate the security proof of the scheme as presented\nin the MuSig2 paper because the security model in the paper does not support\ntweaking a signer's key.\n\nIf you've implemented the BIP draft in your library or are already using it in\nproduction don't hesitate to reach out to clarify the implications of this\ndiscovery.\n\nTim Ruffing, Elliott Jin, Jonas Nick"
            }
        ],
        "thread_summary": {
            "title": "MuSig2 BIP",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Jonas Nick"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3403
        }
    },
    {
        "title": "[bitcoin-dev] Third version of Silent Payment implementation",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2022-10-03T23:41:10",
                "message_text_only": "Hi,\n\nApologies, the link I sent in my previous post was incorrect and should\nhave been:\nhttps://github.com/bitcoin/bitcoin/pull/24897#issuecomment-1218641521\n\nLet me also use this opportunity to share another clarifying comment:\n\n\"There seems to be some confusion about the function of the identifier. Its\nfunction is not to create more than one identity, but to be able to\ndistinguish why someone paid you. For example, when the same entity is\nraising money on behalf of two different charities and wants to know for\nwhich of the two charities the sender intended their donation.\n\nTo be absolutely clear, the payments that appear on-chain are still\nabsolutely unlinkable by a third party observer, nor are they able to tell\nwhich identifier was used.\n\nIn cases where you don't want people to know that you're the same entity,\nthe identifier is insufficient \u2013 you'll need a completely separate Silent\nPayment address which (roughly) doubles your scanning efforts, so it's much\nmore costly in terms of performance.\"\n\nThis comment can be found here:\nhttps://github.com/bitcoin/bitcoin/pull/24897#issuecomment-1266193417\n\nCheers,\nRuben\n\nOn Fri, Sep 30, 2022 at 1:03 AM Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi woltx,\n>\n> Excellent work.\n>\n> >Implements the new scheme suggested by Ruben Somsen that allows multiple\n> silent addresses per wallet with minimal overhead\n>\n> To expand on this, the scheme basically allows the resulting address to be\n> recognizably marked (only recognizable by the recipient of course), which\n> enables you to distinguish between different payment purposes (e.g. some\n> people donate to you for purpose A, others for purpose B). Here's my\n> original comment describing it:\n>\n> \"Naively, the issue is that two keys means twice the scanning, but an\n> interesting alternative would be to simply use the same key (assuming\n> you're OK with using the same identity) but add a public identifier f to it\n> when tweaking. So instead of hash(i*X)*G + X you get hash(i*X)*G + X + f*G\n> . This means every additional \"address\" only costs one additional ECC\n> addition when scanning (relatively cheap compared to doing ECC\n> multiplications).\n>\n> The main downside with this is that f becomes crucial for recovering from\n> backup. If we set f as an index (0, 1, 2, 3...) then you'd only have to\n> remember how many \"addresses\" you issued (and perhaps overshoot when\n> unsure) to ensure recovery of funds, though of course you'd rather also\n> remember which index is associated with what payment reason.\n>\n> Absolute worst case scenario you could even do something similar to the\n> gap limit where you scan the full history (not just the UTXO set so you\n> don't miss spent outputs) with a default max index of e.g. 100, and then if\n> you find out most of them are in use, you scan the next 100, etc. Costly,\n> but thorough, and only needed as a last resort.\"\n>\n> Original comment here:\n>\n> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#xpub-sharing\n>\n> Also good to note that f needs to be communicated to the sender somehow,\n> perhaps as part of the address format.\n>\n> Cheers,\n> Ruben\n>\n> On Fri, Sep 30, 2022 at 12:35 AM woltx via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> This new version addresses most (or all) requests made in PR:\n>>\n>> . Implements the new scheme suggested by Ruben Somsen that allows\n>> multiple silent addresses per wallet with minimal overhead.\n>> . Implements a new RPC to retrieve silent addresses, which allows users\n>> to assign different labels to different addresses. That way, the user knows\n>> which silent address the UTXO came from.\n>>\n>> Example:\n>>\n>> ./src/bitcoin-cli -signet -rpcwallet=\"receiver\" getspaddress\n>> tsp001pjgcwd9p6f2rcgf35dlgvj77h2afylg6lp5cdn0cztrk4k54w99kqxn48tq\n>>\n>> # This will return the same address as above (both have no label)\n>> ./src/bitcoin-cli -signet -rpcwallet=\"receiver\" getspaddress\n>> tsp001pjgcwd9p6f2rcgf35dlgvj77h2afylg6lp5cdn0cztrk4k54w99kqxn48tq\n>>\n>> # New label, new address\n>> ./src/bitcoin-cli -signet -rpcwallet=\"receiver\" getspaddress 'donation'\n>> tsp011pjgcwd9p6f2rcgf35dlgvj77h2afylg6lp5cdn0cztrk4k54w99kq80t7lt\n>>\n>> In this new scheme, the address has a new field called identifier, which\n>> tells the receiver and sender how to set the address correctly.\n>>\n>> If the receiver, for whatever reason, doesn't know which identifiers have\n>> been used, there is no problem. The wallet can scan all identifiers from 0\n>> to 99. Currently, only 100 different identifiers per wallet are allowed.\n>> This limit, however, can be increased at any time in the future.\n>>\n>> Unlike address formats so far, sp addresses are not script-related and\n>> may eventually include any additional information needed, such as an\n>> expiration timestamp (or block height). That way, users don't have to track\n>> the address indefinitely.\n>>\n>> As usual I wrote a step by step tutorial:\n>> https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221004/f743b6b1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Third version of Silent Payment implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ruben Somsen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5375
        }
    },
    {
        "title": "[bitcoin-dev] Packaged Transaction Relay",
        "thread_messages": [
            {
                "author": "Suhas Daftuar",
                "date": "2022-10-04T15:15:42",
                "message_text_only": "(Apologies for the double-post -- I'm resending this message to the list\nwith much of the quoted text trimmed, because my first message was placed\nin the moderation queue for being too large)\n\nHi,\n\nThanks for sharing your thoughts on packaged transaction relay.\n\nThe sole objective, as expressed in the OP proposal, is to:\n\n\"Propagate transactions that are incentive-compatible to mine, even if they\n> don't meet minimum feerate alone.\"\n\n\nI actually do think there are additional goals we should include in any\nprotocol change involving transaction relay, such as ensuring that we\nminimize bandwidth waste as much as possible (as I mentioned in a previous\nmessage in this thread).\n\nWhile I understand your proposal seeks to improve on an idea of static\npackages in favor of dynamic package construction based on knowledge a node\nshould have of its peers, I think the main drawback of your proposal is\nthat it doesn't take into account the complexities of what a peer's\n\"minimum feerate\" might mean.  The consequence of this is that it's not\ngenerally possible for a node to accurately guess whether a given\ntransaction should be sent in a package to a given peer, or not, and so in\naddition to any \"packaged transaction relay\" mechanism that is implemented\nby a transaction announcer, we'd still need to add protocol support for a\nreceiving peer to retrieve a package as well.\n\nFirst of all, a node's feerate is a dynamic value.  BIP 133 allows for\nnodes to send feefilter messages at any time during the lifetime of a peer\nconnection.  If we were to compare the feerate of ancestors of a relayed\ntransaction to the feerate in place at a peer as indicated by feefilter\nmessages, and use that determine whether those ancestors would have been\nsuccessfully relayed or not, then doing so accurately would seem to require\ncaching relay success for each transaction, for each peer, at the time such\ntransaction is relayed (or perhaps caching feefilter values that are\nreceived from a peer?).  This seems likely to be undesirable, and, at any\nrate, is more complex than merely comparing a pair of feerates.\n\nBut even more fundamental than feerates being dynamic is that feerate\nitself is not a well-defined concept when applied to arbitrary transaction\n(sub-)graphs, and this is at the crux of the difficulty in coming up with\nproposals that would meet the objective of ensuring that transactions which\nare incentive-compatible to mine all get relayed successfully across the\nnetwork.  Here are a couple examples that illustrate this:\n\n- Let A be a low feerate transaction (below any peer's minimum feerate).\nLet B and C be descendants of A (but are otherwise unrelated).  Suppose\nthese transactions are relayed to a node in the order A, B, C.  In the\nalgorithm you proposed, I believe the determination for whether C should be\nannounced to a given peer as a package (A, C) or as a singleton would\neither (1) depend on whether the package (A, B) was sufficient to meet the\npeer's feerate, or (2) waste bandwidth by engaging in packaged relay\nwhenever A was already successfully relayed as part of a package.  Both of\nthese approaches seem undesirable.\n\n- Let A be a high fee, but low feerate transaction.  Suppose B is a\ntransaction that conflicts with A, has a high feerate, but lower total\nfee.  In this situation, two different nodes that learned of these two\ntransactions in opposite order [(A, B) vs (B, A)] might be expected to have\ndiffering mempools -- this at least would be the case in the BIP 125\nalgorithm (which requires that both feerate and total fee must increase\nwhen replacing an existing transaction), and at any rate it's not obvious\nfrom the information given which would be more optimal to include in a\nblock, as that depends on factors that go beyond just these two\ntransactions.  Suppose further that a new transaction C is relayed on the\nnetwork, which is a child of B and very high feerate, such that B + C have\nhigher fee and higher feerate than A, when taken together.  In this case\nwe'd want our relay protocol to ensure that even nodes which saw A first\nshould still have a chance to consider transaction C, but the packaging\ndesign you propose (which would compare transaction B's feerate to the\npeer's, and conclude packaging is unnecessary because B's feerate might\nalready exceed the peer's feerate) would not facilitate this.\n\nTo summarize, the point I'd make from these examples is that we should not\nexpect that \"feerate\" (whatever that means) alone will be a sufficient\npredictor of what is in our peer's mempools.  So while there may be some\nsituations where a transaction relayer might be able to usefully package up\na transaction with its dependencies (perhaps in narrowly defined\nsituations), there will also always be situations where this isn't\npossible, and what I conclude from that is that it should be helpful to add\nto the protocol some way for the recipient of a transaction to request the\ndependencies directly.\n\nTaken together, I roughly understand Gloria's efforts here to be a\ncombination of these two approaches: add some amount of packaged\ntransaction relay for simple cases (ie where the transaction graph has been\nsufficiently narrowed, to minimize bandwidth waste while reducing latency),\nand also allow for a fallback mechanism where the recipient of a\ntransaction can efficiently retrieve dependencies.  There seems to be a\ntradeoff involving latency, bandwidth, and robustness of these two\napproaches (and maybe also implementation complexity), so I think it's\nnatural to expect that it will take some discussion and understanding of\nwhat practices are common on the network and what behaviors wallet or other\nsoftware might adopt, given potential protocol changes, to figure out how\nbest to balance these ideas.\n\nOn Wed, Jun 8, 2022 at 6:43 PM <eric at voskuil.org> wrote:\n\n> Hi Suhas/Gloria,\n>\n> Good questions. I've started a new thread because it became something\n> else...\n>\n> Various ideas about packaging seem to be focused on the idea of an atomic\n> message that is gossiped around the network like a transaction or block.\n> From my perspective that seems to create a set of problems without good\n> solutions, and it is not a proper analogy to those atomic structures. It\n> may be worth taking the time to step back and take a close look at the\n> underlying objective.\n>\n> The sole objective, as expressed in the OP proposal, is to:\n>\n> \"Propagate transactions that are incentive-compatible to mine, even if\n> they don't meet minimum feerate alone.\"\n>\n> Effectively producing this outcome with an atomic packaging approach while\n> at the same time maintaining network invariants seems unlikely, if not\n> impossible.\n>\n> Fees:\n>\n> A node knows what fee rate a peer will accept, and announces individual\n> txs that satisfy peer.feerate. Similarly a node knows its own feerate, and\n> SHOULD drop any peer that announces txs that do not satisfy node.feerate.\n>\n> Orphans:\n>\n> A node MAY drop a peer that announces txs that the node sees as orphans\n> against its DAG. It SHOULD drop the orphan tx and MAY request missing\n> ancestors. Presumably after some amount of time connected to peer, node\n> does not expect to see any more orphans from that peer, so these choices\n> could evolve with the channel. However, the design that can only consider\n> each tx in isolation will continue to cause orphan announcements on the\n> channel. A below peer.feerate tx does not get announced to peer, and later\n> a descendant high peer.feerate does get announced to the peer - as an\n> orphan.\n>\n> BIP133 (feefilter):\n>\n> \"There could be a small number of edge cases where a node's mempool min\n> fee is actually less than the filter value a peer is aware of and\n> transactions with fee rates between these values will now be newly\n> inhibited.\"\n>\n> https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki\n>\n> Whether the problem is \"small\" or not depends on the disparity between\n> node fee rates, which is not a matter of protocol. This is an existing\n> problem that can and should be dealt with in packaging, as part of the\n> above objective.\n>\n> Packaged Transaction Relay:\n>\n> One might instead think of packaging as a per-connection function,\n> operating over its transaction (input->output) DAG and the feerate of its\n> own node and that of the peer. Logically a \"package\" is nothing more than a\n> set of transactions (optimized by announcement). Only a node can\n> effectively determine the packaging required by each of its peers, since\n> only the node is aware of peer.feerate.\n>\n> The only way to avoid dead-ending packages (including individual\n> transactions, as is the objective) is for a node to package txs for each\n> peer. The origination of any package is then just a wallet peer doing what\n> a node does - packaging transactions that satisfy peer.feerate (i.e. that\n> of its node).\n>\n> Current transaction relay (txB->txA):\n> ===============================\n> Node0\n> txA.feerate > node.feerate, and not orphaned (accept txA)\n> txA.feerate > peer1.feerate (announce txA to peer1)\n> txA.feerate < peer2.feerate (do not announce txA to peer2)\n> -----\n> txB.feerate > node.feerate (accept txB)\n> txB.feerate > peer1.feerate (announce txB to peer1)\n> txB.feerate > peer2.feerate (announce txB to peer2)\n>\n> Node1\n> Sees/accepts txA and txB.\n>\n> Node2\n> Never sees txA, sees/rejects txB (as an orphan).\n>\n> Packaged transaction relay (txB->txA):\n> ===============================\n> Node0\n> txA.feerate > node.feerate, and not orphaned (accept txA)\n> txA.feerate > peer1.feerate (announce txA to peer1)\n> txA.feerate < peer2.feerate (do not announce txA to peer2)\n> -----\n> txB.feerate > node1.feerate (accept txB)\n> txB.feerate > peer1.feerate (announce txB to peer1)\n> txB.feerate > peer2.feerate (do not announce txB to peer2) <== avoid\n> predictable orphan\n> txA.feerate + txB.feerate > peer2.feerate (announce pkg(A, B) to peer2) <=\n> create minimal package\n>\n> Node1\n> Sees/accepts txA and txB.\n>\n> Node2\n> pkg(A, B) > node2.feerate (accept txA, txB)\n> txA.feerate > peer3.feerate (announce txA to peer3)\n> txB.feerate > peer3.feerate (announce txB to peer3)\n>\n> Sees/accepts pkg(A, B).\n>\n> Node3\n> Sees/accepts txA and txB. <= avoided unnecessary packaging\n>\n> Summary:\n>\n> In this design, any node that receives an announcement for a pkg (or tx)\n> later determined to be less than node.feerate SHOULD drop the announcing\n> peer. Unlike with existing tx relay, a node can become \"current\" and\n> subsequently see few if any tx or pkg orphans, and MAY at some point decide\n> to drop any peer that announces one. Notice that packages are created\n> dynamically, and any package that doesn't need to be grouped gets trimmed\n> down to individual transactions. Furthermore any tx that is \"stuck\" can be\n> freed by simply sending another tx. The nodes at which the tx has become\n> stuck will just package it up and relay it to peers. In other words, there\n> is no impact on wallet implementation apart from raising the aggregate fee\n> using a descendant transaction.\n>\n> This is barely a protocol change - it's primarily implementation. All that\n> should be required is an additional INV element type, such as\n> MSG_TX_PACKAGE.\n>\n> Additional constraints:\n>\n> * All elements of MSG_TX_PACKAGE in one INV message MUST to be of the same\n> package.\n> * A package MUST must define a set that can be mined into one block\n> (size/sigops constraint).\n> * A package SHOULD not contain confirmed txs (a race may cause this).\n> * A package MUST minimally satisfy peer.feerate.\n> * A partial tx order, as in the manner of the block.txs ordering, MUST be\n> imposed.\n> * A node SHOULD drop a peer that sends a package (or tx) below\n> node.feerate.\n> * A node MAY drop a peer that sends a non-minimal package according to\n> node.feerate.\n>\n> The partial ordering of block.txs introduces an ordering constraint that\n> precludes full parallelism in validating input attachment. This is an\n> implementation artifact that made its way into consensus. However in the\n> case of packaging, the set of txs is not presumed to be valid under the\n> proof of work DoS guard. As such constraints should minimize the\n> work/traffic required to invalidate the message. The partial order\n> constraint ensures that the DAG can be built incrementally, dropping the\n> attempt (and peer as desired) as soon as the first orphan is discovered. As\n> a result the network traffic and work required is not materially different\n> than with tx relay, with two exceptions.\n>\n> These are the two central aspects of this approach (Avoiding Predictable\n> Orphans and Creating Minimal Packages). These are graph search algorithms,\n> some basic computer science. Minimality requires only that the package does\n> not introduce txs that are not necessary to reach the peer.feerate (as\n> these can always be packaged separately). It does not require that nodes\n> all generate the same packages. It does not require negotiation, package\n> identity, cryptography, or hashing. As a graph search it should be O(n)\n> where n is the unconfirmed ancestry of the package, but should typically be\n> much lower, if not a single step.\n>\n> Sufficiently-low-fee nodes will see only single txs. Moderate-fee nodes\n> may cause partial breakup of packages. Sufficiently high fee nodes will\n> cause peers (having received and completed the acceptance of a tx/pkg with\n> pkg.feerate < peer.feerate) to navigate from each tx/package external input\n> until reaching txs above peer.feerate, or confirmed (both of which the peer\n> is presumed to already have). If the pkg.feerate is sufficiently high to\n> connect all external inputs to the intervening txs, they are added to the\n> package and it is announced to the high fee peer. Note that the individual\n> tx.feerate > peer.feerate is insufficient to ensure that the peer should\n> have the tx, as there may be ancestor txs that do not, and for which the tx\n> was insufficient to cause them to be packaged. So a non-caching algorithm\n> must be able to chase each package external input to a confirmed tx (or\n> cache the unconfirmed ancestry fee rate at each tx). Note that fee rates\n> are not directly additive, both size/weight and fee are required for\n> summation (and aggregate sigops should be considered).\n>\n> This makes no assumptions about current implementations. The design would\n> call for maintenance of a transaction (input->output) DAG with tx.feerate\n> on each tx. This could be the unconfirmed tx graph (i.e. \"memory pool\")\n> though it does not require maintenance of anything more than the parameters\n> necessary to confirm a set of validated txs within a block. It is very\n> reasonable to require this of any participating node. A simple version\n> negotiation can identify a package-accepting/sending nodes.\n>\n> I have thought about this for some time, but have not implemented either\n> the graph search, source code, or BIP. Just wrote this off the top of my\n> head. So I am sure there are some things I have incorrect or failed to\n> consider. But I think it's worth discussing it at this point.\n>\n> e\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221004/7cac036f/attachment-0001.html>"
            },
            {
                "author": "eric at voskuil.org",
                "date": "2022-10-05T00:01:04",
                "message_text_only": "> Hi,\n> \n> Thanks for sharing your thoughts on packaged transaction relay.\n\nHello, thanks for the reply.\n\n>> The sole objective, as expressed in the OP proposal, is to:\n>> \"Propagate transactions that are incentive-compatible to mine, even\n>> if they don't meet minimum feerate alone.\"\n> \n> I actually do think there are additional goals we should include in any protocol\n> change involving transaction relay, such as ensuring that we minimize\n> bandwidth waste as much as possible (as I mentioned in a previous message\n> in this thread).\n\nYes - there is always the presumption of an optimally-performing protocol (not limited to bandwidth), this is just a restatement from the OP.\n\nThe OP fails to eliminate orphan announcement, fails to prevent packages with insufficient fee from getting stuck in the same manner as txs (without explicitly re-announcing them again in an even larger package of higher feerate), and results in orphaned package announcements for the same reason (a static package is effectively just a larger tx).\n\nDue to the resulting orphaning, a node must allow its peer to continue to broadcast unverifiable orphans to it, potentially chasing ancestry. So in addition to bandwidth waste, there is also an inherent problem of bandwidth DOS. These are problems specifically addressed by packaged relay.\n\n[Regarding bandwidth waste: I've pointed out in years past that breaking the Bitcoin versioning scheme creates a requirement that any unknown message type be considered valid. Up until a recently-deployed protocol change, it had always been possible to validate messages by type. I noticed recently that validating nodes have been dropping peers at an increasing rate (a consequence of that deployment). Despite being an undocumented compatibility break, it is now unfortunately a matter of protocol that a peer must allow its peers to waste its bandwidth to remain compatible - something which we should eliminate.]\n\n> While I understand your proposal seeks to improve on an idea of static\n> packages in favor of dynamic package construction based on knowledge a\n> node should have of its peers, I think the main drawback of your proposal is\n> that it doesn't take into account the complexities of what a peer's \"minimum\n> feerate\" might mean. The consequence of this is that it's not generally\n> possible for a node to accurately guess whether a given transaction should\n> be sent in a package to a given peer, or not, and so in addition to any\n> \"packaged transaction relay\" mechanism that is implemented by a\n> transaction announcer, we'd still need to add protocol support for a receiving\n> peer to retrieve a package as well.\n\nIt is certainly possible that there is ambiguity in BIP133 (and BIPs that modify it). However it's not clear to me which such ambiguity you are referring to. There is no guessing proposed.\n\n> First of all, a node's feerate is a dynamic value.  BIP 133 allows for nodes to\n> send feefilter messages at any time during the lifetime of a peer connection.\n> If we were to compare the feerate of ancestors of a relayed transaction to\n> the feerate in place at a peer as indicated by feefilter messages, and use that\n> determine whether those ancestors would have been successfully relayed or\n> not, then doing so accurately would seem to require caching relay success for\n> each transaction, for each peer, at the time such transaction is relayed (or\n> perhaps caching feefilter values that are received from a peer?).  This seems\n> likely to be undesirable,\n\nThis is a possible implementation. What makes it undesirable?\n\n> and, at any rate, is more complex than merely comparing a pair of feerates.\n\nThere are no necessary protocol changes (though a new INV type is ideal), so the relative complexity you are implying could only arise from implementation. While implementation considerations are relevant, achieving simplicity in the protocol is presumably the priority. Further, implementation complexity must be considered from what is necessary to actually achieve the objectives, and not from the perspective of any given implementation.\n\nMerely comparing a pair of feerates produces the problems described above, which includes not resolving the central problem, so this is an apples-to-oranges comparison. It's also more complex than doing nothing, but that also doesn't resolve the problem.\n\n> But even more fundamental than feerates being dynamic is that feerate\n> itself is not a well-defined concept when applied to arbitrary transaction\n> (sub-)graphs, and this is at the crux of the difficulty in coming up with\n> proposals that would meet the objective of ensuring that transactions which\n> are incentive-compatible to mine all get relayed successfully across the\n> network.  Here are a couple examples that illustrate this:\n> \n> - Let A be a low feerate transaction (below any peer's minimum feerate).  Let\n> B and C be descendants of A (but are otherwise unrelated).  Suppose these\n> transactions are relayed to a node in the order A, B, C.  In the algorithm you\n> proposed, I believe the determination for whether C should be announced\n> to a given peer as a package (A, C) or as a singleton would either (1) depend\n> on whether the package (A, B) was sufficient to meet the peer's feerate,\n\nYes\n\n> or (2) waste bandwidth by engaging in packaged relay whenever A was already\n> successfully relayed as part of a package.  Both of these approaches seem\n> undesirable.\n> \n> - Let A be a high fee, but low feerate transaction.\n\nLow feerate means low fee (as high/low can only be relative to size), it's not clear how these can both be true.\n\n>  Suppose B is a transaction\n> that conflicts with A, has a high feerate, but lower total fee.  In this situation,\n> two different nodes that learned of these two transactions in opposite order\n> [(A, B) vs (B, A)] might be expected to have differing mempools -- this at\n> least would be the case in the BIP 125 algorithm (which requires that both\n> feerate and total fee must increase when replacing an existing transaction),\n\nAs a node knows which txs it has relayed to its peer, order of arrival is inconsequential.\n\n> and at any rate it's not obvious from the information given which would be\n> more optimal to include in a block, as that depends on factors that go beyond\n> just these two transactions. \n\nBlock inclusion in not pertinent, either may be included.\n\n> Suppose further that a new transaction C is\n> relayed on the network, which is a child of B and very high feerate, such that\n> B + C have higher fee and higher feerate than A, when taken together.  In\n> this case we'd want our relay protocol to ensure that even nodes which saw\n> A first should still have a chance to consider transaction C, but the packaging\n> design you propose (which would compare transaction B's feerate to the\n> peer's, and conclude packaging is unnecessary because B's feerate might\n> already exceed the peer's feerate) would not facilitate this.\n\nGiven that A and B are conflicts, A and B+C are conflicts. This is no different than the original conflict of A and B, and decided based on the required BIP125 fee increment. If A arrives first, B must be an increment over A, and vice versa. Upon the arrival of C, given prior acceptance of both A and B, B+C must be an increment over A, as the conflict arises from A/B.\n\n> To summarize, the point I'd make from these examples is that we should not\n> expect that \"feerate\" (whatever that means) alone will be a sufficient\n> predictor of what is in our peer's mempools.\n\nPredicting a peer's set of confirmable transactions (\"mempool\") is not the objective or a requirement. As far as I can tell it is sufficient to achieve requirements to the extent there are no unpublished policies.\n\nUpon startup and connection to a peer, a node may have an empty mempool. In this case there will be no orphan or redundant announcements from the peer.\n\nA node with a populated mempool may connect to a peer. In that case the peer will receive announcements from the peer for txs which it may already have. This will also occur due to multiple peer connections. Redundancy is not within the scope of this or the OP proposals (there are other proposals for limiting this redundancy in both scenarios to the extent desirable).\n\nOnce a node has been connected to the network for some amount of time, there will be no orphans or connection-specific redundancies announced to it. This provides a basis for the node to drop non-conforming peers (that support packaged relay), improving protection against bandwidth-wasting peers.\n\nAny node which implements unpublished policies can expect to receive orphan announcements. This raises the question of whether the protocol should incorporate a facility for such a node to chase down orphans in the case where it is orphaning them by deleting their ancestors, even though it publishes that it accepts them based on feerate/rbf. This would imply that there is some other discretionary aspect of transactions that, as a matter of protocol, should be considered for relay.\n\nAny such aspect internal to a tx would be economically-irrational to consider (which includes censorship), in which case it would seem preferrable to let such nodes simply accept the fact that they are creating orphans for themselves.\n\nAny such aspect external to the tx would also be economically-irrational (mining wants the greatest possible fee opportunity), but may be a consequence of resource limitations. Storing confirmable txs in RAM constrains such resources by orders of magnitude, and an assumption that an implementation must do this would be an error (some do not). Yet storage remains finite, so this remains a possible though marginal consideration given the presumption that all accepted txs are both confirmable and satisfy feerate/rbf policy. In the case where a node is discarding previously accepted and yet-unconfirmed txs, the node accepts the possibility that this will result in it receiving orphan announcements.\n\nThe rational way to reduce the size of the mempool is to raise the published feerate, discarding txs that no longer conform. While this was not specifically described in the fairly informal proposal, the receipt of a reduced peer feerate message can cause a node to update its state for that peer, eliminating the possibility of orphan announcements to it.\n\n>  So while there may be some\n> situations where a transaction relayer might be able to usefully package up a\n> transaction with its dependencies (perhaps in narrowly defined situations),\n> there will also always be situations where this isn't possible, and what I\n> conclude from that is that it should be helpful to add to the protocol some\n> way for the recipient of a transaction to request the dependencies directly.\n\nI don't think this has been shown, but finding such issues is of course why we discuss it.\n\n> Taken together, I roughly understand Gloria's efforts here to be a\n> combination of these two approaches: add some amount of packaged\n> transaction relay for simple cases (ie where the transaction graph has been\n> sufficiently narrowed, to minimize bandwidth waste while reducing latency),\n> and also allow for a fallback mechanism where the recipient of a transaction\n> can efficiently retrieve dependencies.  There seems to be a tradeoff\n> involving latency, bandwidth, and robustness of these two approaches (and\n> maybe also implementation complexity), so I think it's natural to expect that\n> it will take some discussion and understanding of what practices are common\n> on the network and what behaviors wallet or other software might adopt,\n> given potential protocol changes, to figure out how best to balance these\n> ideas.\n\nThe problems that I see with static packaging are:\n\n1) Does not fully resolve the problem - a static package itself can get stuck for the same reason as a tx.\n2) Requires wallet formation of a static packages - to resolve what is fundamentally a network issue.\n3) Adds a complex new protocol to achieve what can be accomplished with almost no protocol change.\n4) Is not bandwidth optimal, as it continues to relay/chase orphans (singular and packaged).\n5) Is not DOS optimal, as it requires allowance for orphans and redundancies.\n\nRegarding complexity - searching and marking a DAG is basic CS, and there isn't much else to the necessary implementation. There are no new messages, just a version bump and a preferably a new INV type. In terms of performance and therefore any possible increase to relay latency, this is easily measured in terms of complexity. Whether this would be a latency increase or decrease in relation to the OP is unclear.\n\nThe complexity of the search for is linear in the size of the mempool subgraph (1) induced by the traversal of ancestors from the potential package's last tx, and (2) reduced by the set of txs known to the peer. (2) includes both txs sent to and received from the peer. This would appear to be a marginal cost.\n\nA draft of the search algorithm is available here:\n\nhttps://github.com/libbitcoin/libbitcoin-network/wiki/Iterative-Channel-Package-Computation\n\nBest,\ne"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-05T06:55:39",
                "message_text_only": "On Tue, Oct 04, 2022 at 05:01:04PM -0700, Eric Voskuil via bitcoin-dev wrote:\n> [Regarding bandwidth waste: I've pointed out in years past that\n> breaking the Bitcoin versioning scheme creates a requirement that any\n> unknown message type be considered valid. Up until a recently-deployed\n> protocol change, it had always been possible to validate messages by\n> type. I noticed recently that validating nodes have been dropping peers\n> at an increasing rate (a consequence of that deployment). Despite being\n> an undocumented compatibility break, it is now unfortunately a matter\n> of protocol that a peer must allow its peers to waste its bandwidth to\n> remain compatible - something which we should eliminate.]\n\nThe only message listed as not being preceded by a bumped version number\nin:\n\nhttps://github.com/libbitcoin/libbitcoin-network/wiki/Protocol-Versioning\n\nis addrv2 (though addrv2 is gated on mutual exchange of sendaddrv2, so\nit's presumably the sendaddrv2 message at issue), however since [0]\nsendaddrv2 messages are only sent to nodes advertising version 70016 or\nlater (same as wtxidrelay). ADDRV2 was introduced May 20 2020 after the\n0.20 branch, and SENDADDRV2 gating was merged Dec 9 2020 and included\nfrom 0.21.0rc3 onwards.\n\n[0] https://github.com/bitcoin/bitcoin/pull/20564\n\nI'm only seeing \"bytesrecv_per_msg.*other*\" entries for nodes advertising\na version of 0.17 and 0.18, which I presume is due to REJECT messages (for\ntaproot txs, perhaps?). Otherwise, I don't think there are any unexpected\nmessages you should be receiving when advertising version 70015 or lower.\n\nCheers,\naj"
            },
            {
                "author": "Eric Voskuil",
                "date": "2022-10-05T20:43:10",
                "message_text_only": ">> [Regarding bandwidth waste: I've pointed out in years past that\n>> breaking the Bitcoin versioning scheme creates a requirement that any\n>> unknown message type be considered valid. Up until a recently-deployed\n>> protocol change, it had always been possible to validate messages by\n>> type. I noticed recently that validating nodes have been dropping peers\n>> at an increasing rate (a consequence of that deployment). Despite being\n>> an undocumented compatibility break, it is now unfortunately a matter\n>> of protocol that a peer must allow its peers to waste its bandwidth to\n>> remain compatible - something which we should eliminate.]\n> \n> The only message listed as not being preceded by a bumped version number\n> in:\n> \n> https://github.com/libbitcoin/libbitcoin-network/wiki/Protocol-Versioning\n\nGood find, still a work in progress.\n\n> is addrv2 (though addrv2 is gated on mutual exchange of sendaddrv2, so\n> it's presumably the sendaddrv2 message at issue),\n\naddrv2 is listed as the BIP title, the message that would cause the break is sendaddrv2 (quoted text).\n\n> however since [0]\n> sendaddrv2 messages are only sent to nodes advertising version 70016 or\n> later (same as wtxidrelay).\n\nI don\u2019t see this constraint in BIP155. Do you mean that addrv2 support was released in Core at the same time as wtxidrelay, or that it is an undocumented version constraint implemented in Core?\n\n> ADDRV2 was introduced May 20 2020 after the\n> 0.20 branch, and SENDADDRV2 gating was merged Dec 9 2020 and included\n> from 0.21.0rc3 onwards.\n\nTo clarify, there was no Core release of addrv2 without sendaddrv2 apart from 0.21 release candidates?\n\n> [0] https://github.com/bitcoin/bitcoin/pull/20564\n> \n> I'm only seeing \"bytesrecv_per_msg.*other*\" entries for nodes advertising\n> a version of 0.17 and 0.18,\n\n> which I presume is due to REJECT messages (for taproot txs, perhaps?).\n\nIdeally you should not be seeing reject messages as protocol \u201cother\u201d, as these are valid messages as of protocol version 70002, and they are excluded by negotiated version before that. While there is no requirement to send them (BIP61 only defines a new message type), they remain defined messages until removed by a future protocol version.\n\n> Otherwise, I don't think there are any unexpected\n> messages you should be receiving when advertising version 70015 or lower.\n\nYet nodes with an advertised protocol version of 70013 are receiving sendaddrv2. I've removed the IP address from the log extract below.\n\n17:53:45.022347 DEBUG [network] Peer [x.x.x.x:8333] protocol version (70016) user agent: /Satoshi:0.21.0()/\n17:53:45.022377 DEBUG [network] Negotiated protocol version (70013) for [x.x.x.x.135:8333]\n17:53:45.022767 INFO [network] Connected outbound channel [x.x.x.x.135:8333]\n17:53:45.022913 DEBUG [node] Ask [x.x.x.x:8333] for headers after [00000000000000000002e8c1c59fc86f721ba3a3294d2b1165597ddb910058e6]\n17:53:45.023184 WARNING [network] Invalid sendaddrv2 payload from [x.x.x.x:8333] object does not exist\n17:53:45.023317 DEBUG [network] Stop protocol version on [x.x.x.x:8333] object does not exist\n17:53:45.023359 DEBUG [network] Outbound channel stopped [x.x.x.x:8333] success\n\nTo my knowledge the only other time we've seen consistent invalid message traffic on the network was during the work on BIP150 (withdrawn), at which point BIP150 nodes were being deployed on mainnet. I made comments here on the issue at the time, which as I recall were generally rejected in favor of forcing nodes to allow all invalid traffic. In any case BIP150 was withdrawn and BIP324 proposed, which fixes this particular issue (using a service bit).\n\nSome argued at the time that allowance for invalid messages was a longstanding requirement in the protocol. I knew that this was not the case (except for BIP37, break documented in BIP60) because libbitcoin validates all messages, which led me to eventually document it. Recently I updated and posted that documentation (the github wiki link you found). This was a consequence of reviewing the Generic Package Relay proposal, which is also incompatible. In doing so I noticed this issue with BIP155 and BIP330 as well. This led us to check the logs for peer disconnects as a result of invalid messages, at which point the above was found to be an increasingly common occurrence.\n\nBest,\ne\n\n> Cheers,\n> aj"
            },
            {
                "author": "eric at voskuil.org",
                "date": "2022-10-06T04:32:29",
                "message_text_only": ">> ...sendaddrv2 messages are only sent to nodes advertising version 70016 or later (same as wtxidrelay)\n\n> I don\u2019t see this constraint in BIP155. Do you mean that addrv2 support was\n> released in Core at the same time as wtxidrelay, or that it is an\n> undocumented version constraint implemented in Core?\n\nI see that it is the latter:\n\n// BIP155 defines addrv2 and sendaddrv2 for all protocol versions, but some\n// implementations reject messages they don't know. As a courtesy, don't send\n// it to nodes with a version before 70016, as no software is known to support\n// BIP155 that doesn't announce at least that protocol version number.\n\nhttps://github.com/bitcoin/bitcoin/pull/20564/files#diff-6875de769e90cec84d2e8a9c1b962cdbcda44d870d42e4215827e599e11e90e3R2366-R2370\n\nThe version string in the log message I posted implies it may not be a Core release. Yet it is BIP155 compliant.\n\nProtocol cannot be defined on an ad-hoc basis as a \"courtesy\" - and it's not exactly a courtesy to keep yourself from getting dropped by peers. It is not clear to me why such a comment would be accepted instead of specifying this properly. A new protocol cannot define a message for \"all versions\", it can only assume that older versions will disregard all unknown message traffic - or that implementers will patch it in this ad-hoc matter.\n\nI would suggest that authors update BIP155 and BIP330 (both still in Draft status), as well any pending proposals that may have picked up this pattern from BIP155.\n\nI doubt that anyone who's worked with it is terribly fond of Bitcoin's P2P protocol versioning. I've spent some time on a proposal to update it, though it hasn't been a priority. If anyone is interested in collaborating on it please contact me directly.\n\ne"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-07T06:31:39",
                "message_text_only": "On Wed, Oct 05, 2022 at 09:32:29PM -0700, Eric Voskuil via bitcoin-dev wrote:\n> Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n\nBIPs are a courtesy in the first place. There's no central authority to\nenforce some particular way of doing things.\n\n> - and it's not exactly a courtesy to keep yourself from getting dropped by peers. It is not clear to me why such a comment would be accepted instead of specifying this properly. \n\nIf you think that the version restriction should be part of the BIP,\nwhy not do a pull request? The BIP is still marked as \"Draft\".\n\n> I doubt that anyone who's worked with it is terribly fond of Bitcoin's P2P protocol versioning. I've spent some time on a proposal to update it, though it hasn't been a priority. If anyone is interested in collaborating on it please contact me directly.\n\nBottlenecking a proposal on someone who doesn't see it as a priority\ndoesn't seem smart?\n\nHere's what I think makes sense:\n\nhttps://github.com/ajtowns/bips/blob/202210-p2pfeatures/bip-p2pfeatures.mediawiki\n\nCheers,\naj"
            },
            {
                "author": "eric at voskuil.org",
                "date": "2022-10-08T19:58:35",
                "message_text_only": "> From: Anthony Towns <aj at erisian.com.au>\n> On Wed, Oct 05, 2022 at 09:32:29PM -0700, Eric Voskuil via bitcoin-dev\nwrote:\n> > Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n> \n> BIPs are a courtesy in the first place.\n\nI suppose if you felt that you were the authority then this would be your\nperspective. However in the case of community software development, open\nstandards are a tool to preempt such centralization.\n\nThe BIP process was created by Amir specifically because Bitcoin standards\nwere being discussed and developed behind closed doors. That process was\nbeing funded almost entirely by a corporate consortium (the Bitcoin\nFoundation). It was also clear that one implementation leads directly to\nthis type of authority complex, which is why he also started libbitcoin.\nIt's not surprising to learn that you feel this way, and it's nice of you to\nshare those thoughts publicly.\n\n> There's no central authority to enforce some particular way of doing\nthings.\n\nAs if reaching consensus with other people implies a singular authority.\n\n> > - and it's not exactly a courtesy to keep yourself from getting dropped\nby\n> peers. It is not clear to me why such a comment would be accepted instead\n> of specifying this properly.\n> \n> If you think that the version restriction should be part of the BIP, why\nnot do\n> a pull request? The BIP is still marked as \"Draft\".\n\nI did not implement and ship a deviation from the posted proposal. The\ndevelopers who did so spent almost as much time writing a comment about the\nintentional deviation as they would have spent issuing a PR to the BIP.\nPresumably, given that years have passed, there has been enough time to\ncorrect that \"mistake\". At this point there are at least 5 implementations\noperating on mainnet that are inconsistent with Core.\n\n> > I doubt that anyone who's worked with it is terribly fond of Bitcoin's\nP2P\n> protocol versioning. I've spent some time on a proposal to update it,\nthough\n> it hasn't been a priority. If anyone is interested in collaborating on it\nplease\n> contact me directly.\n> \n> Bottlenecking a proposal on someone who doesn't see it as a priority\ndoesn't\n> seem smart?\n\nI didn't realize I was holding you up. As far as I've been able to gather,\nit hasn't been a priority for anyone. Yet somehow, on the same day that I\nposted the fact that I was working on it, it became your top priority.\n\n> Here's what I think makes sense:\n> \n> https://github.com/ajtowns/bips/blob/202210-p2pfeatures/bip-\n> p2pfeatures.mediawiki\n\nLooks like you put about 10 minutes of thought into it. In your words, BIPs\nare a courtesy - feel free to do what you want.\n\nI'm well aware of your contributions to Bitcoin, but I find the arrogance\noff-putting. I have spent many years contributing to Bitcoin development and\nunderstanding, entirely on my own dime, even paying others to do so - as\nwell as raising donations for them. I do this intentionally, not because\nI/we haven't had offers. Many corporate and state-funded Bitcoin Core\ndevelopers have repeatedly, aggressively, openly and self-servingly worked\nto put a stop to such community efforts. To them the BIP process is a\n\"courtesy\" - just sometimes documenting what they happen to be doing in the\nprotocols. And without actual alternatives, that's exactly what it is.\n\nSo I'll just leave you with this:\n\n\"MIT Digital Currency Initiative (DCI) announces research collaboration with\nthe Bank of England on central bank digital currency\n\nThe Bank of England announced an agreement to collaborate on a twelve-month\nCentral Bank Digital Currency (CBDC) research project with MIT Digital\nCurrency Initiative. The agreement supports and builds on DCI's ongoing\nresearch into CBDC, while also contributing to the Bank of England's wider\nresearch and exploration of central bank digital currencies. While no\ndecision has been made on whether or not to introduce a CBDC in the UK, the\nwork will investigate and experiment with potential CBDC technology designs\nand approaches, and evaluate key tradeoffs, opportunities, and risks. This\ntype of research can help inform wider policy development by contributing\nimportant technical ideas and questions. \n\nAs part of OpenCBDC, DCI's open-source codebase and research initiative, MIT\nDCI aims to fill this gap by engaging technologists, user researchers,\ncentral bankers, private sector leaders, and academics in service of a more\naccessible, trusted, fair, and resilient economy. We don't yet know if or in\nwhat contexts CBDCs can help improve the broader international monetary\nsystem, or how they might be best designed to do so, but we believe engaging\nin technical research is an important step in answering these questions.\"\n\nhttps://dci.mit.edu/research/2022/3/31/mit-digital-currency-initiative-dci-a\nnnounces-research-collaboration-with-the-bank-of-england-on-central-bank-dig\nital-currency\n\nhttps://ras.mit.edu/finding-funding/find-funding/federal-funding\n\nhttps://dci.mit.edu/anthony-aj-towns\n\nSome might call this a conflict of interest. A widespread community of\nindependent implementations is not in the interest of those who both make\nand must comply with regulatory diktat.\n\nThen of course there's this:\n\n\"Joichi Ito, director of MIT's Media Lab, resigned Saturday (Sept. 7 [2019])\nafter The New Yorker published an investigation into his attempts to conceal\nfinancial contributions from pedophile Jeffrey Epstein. Although Ito\nstewarded MIT's lab, his work and legacy in the crypto community have\nlargely passed under the radar.\n\nIto established the Digital Currency Initiative (DCI) at MIT, helping\nbitcoin survive some of its darkest days in 2015. That year, when the\nBitcoin Foundation, a nonprofit dedicated to the cryptocurrency's\ndevelopment faced \"funding constraints,\" the DCI welcomed bitcoin core\ndevelopers Gavin Andresen, Cory Fields, and Wladimir van der Laan in\nfull-time roles.\"\n\nhttps://qz.com/1704325/revisiting-mits-digital-currency-initiative-after-joi\n-ito-epstein/\n\nDCI jumps in to \"help Bitcoin survive some of its darkest days\". What\nexactly was dark about these days apart from the fact that this corporate\nconsortium fell apart? It fell apart due to widespread community rejection -\ninitially driven by Amir. What fell apart was the attempt at corporate\ninfluence/control, with development largely driven by Gavin and Mike Hearn\non the payroll - both of whom eventually disgraced themselves.\n\nYour contributions notwithstanding, you are in no place to exhibit such\narrogance.\n\nBest,\ne\n\n> Cheers,\n> aj"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-09T05:52:42",
                "message_text_only": "On Sat, Oct 08, 2022 at 12:58:35PM -0700, Eric Voskuil via bitcoin-dev wrote:\n> > > Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n> > BIPs are a courtesy in the first place.\n> I suppose if you felt that you were the authority then this would be your\n> perspective. \n\nYou seem to think that I'm arguing courtesy is not a good thing, or that\nwe couldn't use more of it?\n\nIf it helps: courtesy is a good thing, and we could use more of it.\n\n> The BIP process was created by Amir specifically because Bitcoin standards\n> were being discussed and developed behind closed doors.\n\nIt definitely bothers me that Bitcoin development is not being discussed\nout in the open as much as I would like, and to counter that, I try to\nencourage people to post their ideas to this list, and write them up as\na BIP; and likewise try to do both myself as well.\n\nBut how much value do you think anyone's actually getting from posting\ntheir development ideas to this list these days? Do you really think\npeople reading your mail will be more inspired to discuss their ideas\nin the open, or that they'll prefer to get in a room with their friends\nand allies, and close the doors so they can work in peace?\n\n> > There's no central authority to enforce some particular way of doing\n> > things.\n> As if reaching consensus with other people implies a singular authority.\n\nReaching consensus with other people doesn't require putting a document\nin some particular github repo, either. Which is a good thing, or the\npeople in control of that repo would become that singular authority.\n\n> > If you think that the version restriction should be part of the BIP,\n> > why not do a pull request? The BIP is still marked as \"Draft\".\n> I did not implement and ship a deviation from the posted proposal.\n\nYou think BIP 155 is suboptimal, and would rather see it changed, no?\n\nBut if you won't put any effort into changing it (and how much effort do\nyou think a PR to change it document it as being gated by version 70016\nwould be?), why do you imagine the people who are happy with the BIP as\nit is would put any effort in?\n\n> > > I doubt that anyone who's worked with it is terribly fond of Bitcoin's\n> > > P2P  protocol versioning. I've spent some time on a proposal to\n> > > update it, though it hasn't been a priority. If anyone is \n> > > interested in collaborating on it please contact me directly.\n\n\"contact me directly\" and wanting something other than standards \"being\ndiscussed and developed behind closed doors\" seems quite contradictory\nto me.\n\n(In my opinion, a big practical advantage of doing things in public is\nthat it's easy for people to contribute, even if it's not a particular\npriority, and that it's also easy for someone new to take over, if the\npeople previously working on it decide they no longer have time for that\nparticular project)\n\n> > Bottlenecking a proposal on someone who doesn't see it as a priority\n> > doesn't seem smart?\n> I didn't realize I was holding you up. As far as I've been able to gather,\n> it hasn't been a priority for anyone. Yet somehow, on the same day that I\n> posted the fact that I was working on it, it became your top priority.\n\nIt's not my top priority; it's just that writing a BIP and posting\nit publicly is fundamentally no harder than writing an email to\nbitcoin-dev. So since I'm willing to do one, why waste anyone's time by\nnot also doing the other? Would've been even easier if I'd remembered\nSuhas had already written up a draft BIP two years ago...\n\nAnd if I'm going to suggest you should post a patch to a BIP you think\nis flawed, then not drafting a BIP to improve on a practice I think is\nflawed would be pretty hypocritical, no?\n\n(I didn't read what you said to imply that you were working on it,\njust that you'd spent time thinking about it, were interested, and\nmight do more if people contacted you. If you have been working on\nit, why not do so in public? You already have a public bips fork at\nhttps://github.com/evoskuil/bips/branches -- how about just pushing your\nwork-in-progress there?)\n\n(Ah, I also see now that I did contact you in Dec 2020/Jan 2021 on this\ntopic, but never received a response. Apologies; the above was meant as\na general statement in favour of just collaborating in public from the\nstart for the practical advantages I outline above, not a personal dig)\n\n> > Here's what I think makes sense:\n> > https://github.com/ajtowns/bips/blob/202210-p2pfeatures/bip-\n> > p2pfeatures.mediawiki\n> Looks like you put about 10 minutes of thought into it. In your words, BIPs\n> are a courtesy - feel free to do what you want.\n\nSo, you wrote a lot of stuff after this, but unless I missed it, it\ndidn't include any substantive criticism of the proposal, or specific\nsuggestions for changing it, or even any indication why you would have\nany difficulty supporting/implementing it in the software you care about.\n\n> Your contributions notwithstanding, you are in no place to exhibit such\n> arrogance.\n\nI don't understand what you think is arrogant about posting a public\nproposal about how I think things should work, even if I had only put\n10 minutes thought into it. If that *is* arrogance, I guess I think we\ncould use more of it, as well as more courtesy...\n\n(I mean, if I *had* only spent 10 minutes on it then posting it to the\nlist might be a waste of everyone else's time; but I could still put it in\nmy bips fork, and blog/tweet about it, or mention it on irc or similar,\nwhich is at least still a public proposal. And in this case I've been\nthinking about it on and of since 2020, and do know that other people\nshare similar views, so I don't think it's wasting people's time)\n\nCheers,\naj"
            },
            {
                "author": "eric at voskuil.org",
                "date": "2022-10-09T07:00:04",
                "message_text_only": "On Sat, Oct 08, 2022, Anthony Towns via bitcoin-dev wrote:\n> > > > Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n> > > BIPs are a courtesy in the first place.\n> > I suppose if you felt that you were the authority then this would be\n> > your perspective.\n> \n> You seem to think that I'm arguing courtesy is not a good thing, or that\nwe\n> couldn't use more of it?\n\nThat is neither what I said nor implied. You were clearly dismissing the\npublic process, not advocating for politeness.\n\n> > The BIP process was created by Amir specifically because Bitcoin\n> > standards were being discussed and developed behind closed doors.\n> \n> It definitely bothers me that Bitcoin development is not being discussed\nout\n> in the open as much as I would like, and to counter that, I try to\nencourage\n> people to post their ideas to this list, and write them up as a BIP; and\nlikewise\n> try to do both myself as well.\n> \n> But how much value do you think anyone's actually getting from posting\ntheir\n> development ideas to this list these days? Do you really think people\nreading\n> your mail will be more inspired to discuss their ideas in the open, or\nthat\n> they'll prefer to get in a room with their friends and allies, and close\nthe\n> doors so they can work in peace?\n\nMy comments have nothing to do with posting to this list.\n\n> > > There's no central authority to enforce some particular way of doing\n> > > things.\n> > As if reaching consensus with other people implies a singular authority.\n> \n> Reaching consensus with other people doesn't require putting a document in\n> some particular github repo, either. Which is a good thing, or the people\nin\n> control of that repo would become that singular authority.\n\nIt is the public process that the community has clearly established. It has\nbeen challenged at times, which anyone is free to do - creating their own if\nthey feel it becomes necessary. There is certainly no such issue in this\ncase, so it is not at all clear what you mean to imply here. Is this just a\nblanket rejection of community standards development, or is it that you feel\nthis community is limited to \"friends and allies\"?\n\nDevelopers of Bitcoin Core have stated countless times that they consider\nBitcoin Core to be the protocol documentation, implying that their internal\nprocess is the process of arriving at community consensus. What was that you\nsaid about \"some particular github repo\" becoming the \"singular authority\"?\n\n> > > If you think that the version restriction should be part of the BIP,\n> > > why not do a pull request? The BIP is still marked as \"Draft\".\n> > I did not implement and ship a deviation from the posted proposal.\n> \n> You think BIP 155 is suboptimal, and would rather see it changed, no?\n\nThe Bitcoin Core developers who deployed the deviation apparently also\nthought the BIP was suboptimal. Whether I agree with the change isn't\nrelevant.\n\n> But if you won't put any effort into changing it (and how much effort do\nyou\n> think a PR to change it document it as being gated by version 70016 would\n> be?), why do you imagine the people who are happy with the BIP as it is\n> would put any effort in?\n\nYes, that's it. I'm lazy. It's all about effort, not about the process\nwhich, by your own measure, the owners of a single repo aim to be the\n\"singular authority\".\n\n> > > > I doubt that anyone who's worked with it is terribly fond of\n> > > > Bitcoin's P2P  protocol versioning. I've spent some time on a\n> > > > proposal to update it, though it hasn't been a priority. If anyone\n> > > > is interested in collaborating on it please contact me directly.\n> \n> \"contact me directly\" and wanting something other than standards \"being\n> discussed and developed behind closed doors\" seems quite contradictory to\n> me.\n\nIt's the public process that is at issue, and you of course know that -\nhence your varied attempts here to make it about something else.\n\n> > Your contributions notwithstanding, you are in no place to exhibit\n> > such arrogance.\n> \n> I don't understand what you think is arrogant about posting a public\nproposal\n> about how I think things should work, even if I had only put\n> 10 minutes thought into it. If that *is* arrogance, I guess I think we\ncould use\n> more of it, as well as more courtesy...\n\nAs if I was referring to this.\n\n\"BIPs are a courtesy in the first place\" says it all.\n\nBest,\ne"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-09T13:27:42",
                "message_text_only": "On Sun, Oct 09, 2022 at 12:00:04AM -0700, eric at voskuil.org wrote:\n> On Sat, Oct 08, 2022, Anthony Towns via bitcoin-dev wrote:\n> > > > > Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n> > > > BIPs are a courtesy in the first place.\n> > > I suppose if you felt that you were the authority then this would be\n> > > your perspective.\n> > You seem to think that I'm arguing courtesy is not a good thing, or that\n> we\n> > couldn't use more of it?\n> That is neither what I said nor implied. You were clearly dismissing the\n> public process, not advocating for politeness.\n\nAnd that is neither what I said nor implied, nor something I believe. If\nyou think courtesy is something that can be ignored in a public process,\nI don't think you should expect much success.\n\nIf you'd like to actually participate in public standards development,\nplease feel free to make some technical comments on my proposals, or\nothers, or make your own proposal, either here or on github, or heck,\nanywhere else.\n\nI mean, that's what I'd suggest anyway; I'm not your boss. I promise to\nat least be entertainingly surprised if you make any progress with your\ncurrent approach though.\n\nCheers,\naj"
            },
            {
                "author": "eric at voskuil.org",
                "date": "2022-10-10T22:05:38",
                "message_text_only": "> -----Original Message-----\n> From: Anthony Towns <aj at erisian.com.au>\n> Subject: Re: [bitcoin-dev] Packaged Transaction Relay\n> > > > > > Protocol cannot be defined on an ad-hoc basis as a \"courtesy\"\n> > > > > BIPs are a courtesy in the first place.\n> > > > I suppose if you felt that you were the authority then this would\n> > > > be your perspective.\n> > > You seem to think that I'm arguing courtesy is not a good thing, or\n> > > that we couldn't use more of it?\n> > That is neither what I said nor implied. You were clearly dismissing\n> > the public process, not advocating for politeness.\n> \n> And that is neither what I said nor implied, nor something I believe. If\nyou\n> think courtesy is something that can be ignored in a public process, I\ndon't\n> think you should expect much success.\n\n\"BIPs are a courtesy in the first place.\"\n\n> If you'd like to actually participate in public standards development,\nplease\n> feel free to make some technical comments on my proposals, or others, or\n> make your own proposal, either here or on github, or heck, anywhere else.\n\n\"RE: [bitcoin-dev] Packaged Transaction Relay\"\n\n> I mean, that's what I'd suggest anyway; I'm not your boss. I promise to at\n> least be entertainingly surprised if you make any progress with your\ncurrent\n> approach though.\n\nGrow up Anthony.\n\ne"
            }
        ],
        "thread_summary": {
            "title": "Packaged Transaction Relay",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Suhas Daftuar",
                "Anthony Towns",
                "eric at voskuil.org",
                "Eric Voskuil"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 56146
        }
    },
    {
        "title": "[bitcoin-dev] RFC for a BIP32 recurrent address derivation scheme",
        "thread_messages": [
            {
                "author": "El_Hoy",
                "date": "2022-10-04T19:08:34",
                "message_text_only": "Hi Ruben,\n\nThanks for your comments.\n\nI've noticed that there are lots of mentions of using a scheme like this,\nbut there is no framework to ease the usage of such a scheme and to add\ninteroperability between different implementations. So any implementation\nrequires some manual work on both parties. The idea is to have a BIP to\nmake this easy for developers to implement and users to use.\n\nThe main advantage against silent payments or BIP47 is just that it should\nbe easier to implement on both parties involved.\n\nRegarding the `contact`, you are right, it is just a counter, and Carol\nsimply increments this one with each `contact` created. The association\nbetween a `contact` and the metadata of the contact needs to be stored\noff-chain, so when recovering the wallet that information is lost if there\nis no backup.\n\nRegarding the gap limit, I think that we can be quite strict with it, to\nmake it easier to implement, I would use a gap limit of 2 for contacts and\nno gap limit for the index, there is no point in someone skipping an\naddress.\n\nRegards.\n\n---  Eloy\n\n\nOn Thu, Sep 29, 2022 at 7:41 PM Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi Eloy,\n>\n> Nice idea.\n>\n> Note I thought about and succinctly described a similar scheme here (which\n> in turn was derived from work by Kixunil):\n>\n> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#xpub-sharing\n>\n> I agree with your general assessment that this is a scheme that seems like\n> an improvement over the status quo. Note that both BIP47 and Silent\n> Payments don't require any interaction with the sender, while this scheme\n> requires one-time interaction (e.g. this wouldn't be suitable for one-time\n> donations). I think this would mostly be a convenience feature that\n> improves the regular interactive payment flow (interact once, instead of\n> repeatedly asking for addresses with each payment).\n>\n> >master / purpose' / coin_type' / contact' / index\n>\n> Despite your explanation, it's still not fully clear to me how \"contact\"\n> is defined, but I assume it's just a counter? Just in case, note that you\n> can't let Bob define it for Carol, as then you can't deterministically\n> recover your payments without also backing up how it's defined (the seed\n> alone won't be enough).\n>\n> The gap limit also needs to be kept in mind. If we allow each xpub to have\n> its own gap limit, you potentially get an exponential blowup (gaps in the\n> xpub * gaps in the addresses generated from the xpubs). It may be OK to\n> define a low default gap limit for these xpubs, since there should be no\n> reason to expect the same sender to leave any gaps, though this may depend\n> on how the xpubs are used (e.g. it may also be used to derive addresses for\n> others) so it's probably important to be explicit about this.\n>\n> Cheers,\n> Ruben\n>\n>\n>\n> On Thu, Sep 22, 2022 at 5:18 PM El_Hoy via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> There is a known issue on bitcoin, that is that every transaction\n>> requires a new address to prevent address reuse, making it uncomfortable to\n>> make recurring payments, as every payment requires a new off-chain\n>> interaction. A scheme is already mentioned on the [on the BIP32 itself][1],\n>> but it cannot be implemented as is.\n>>\n>> Here I propose a scheme that follows the structure described on [BIP44]\n>> that should make it possible to send recurring payments using a single\n>> offline interaction.\n>>\n>> The proposed scheme is:\n>>\n>>     master / purpose' / coin_type' / contact' / index\n>>\n>> Where the definitions of all the levels follow BIP44, except for\n>> `contact` that is described below.\n>>\n>> Example usage: Bob wants to make recurring payments to Carol, so he asks\n>> her for a _contact address_, that is, an extended public key.\n>>\n>> Bob can use that public key to generate multiple derived addresses to\n>> make multiple recurring payments to Carol, the contact address is stored\n>> off-chain, anyone inspecting the chain will just see normal transactions\n>> on-chain.\n>>\n>> ## Considerations\n>>\n>> [BIP47] tries to solve the same issue, but the solution is more complex\n>> and involves more on-chain transactions that involve data, this\n>> implementation simpler and requires less work to implement.\n>>\n>> Also, the derivation path might need some adjustments for different\n>> address types on bitcoin.\n>>\n>> Finally, this only works in a single direction and does not make it\n>> possible for Carol to send anything to Bob, as it would require Bob sending\n>> her a contact address.\n>>\n>> ## Advantages\n>>\n>> A positive side effect of using this, is that Bob can choose to send\n>> payments to Carol using multiple outputs, giving him more privacy.\n>>\n>> Also, those payments can be easily labeled by the receiving wallet, as\n>> they are received.\n>>\n>> Regards.\n>>\n>> ### References\n>>\n>> [1]:\n>> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#recurrent-business-to-business-transactions-nmih0\n>> [BIP47]: https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki\n>> \"Reusable Payment Codes for Hierarchical Deterministic Wallets\"\n>> [BIP43]:\n>> https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki#Purpose\n>>\n>> --- Eloy\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221004/e37c720d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "RFC for a BIP32 recurrent address derivation scheme",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "El_Hoy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5583
        }
    },
    {
        "title": "[bitcoin-dev] On a new community process to specify covenants",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2022-10-07T15:33:12",
                "message_text_only": "Hi all,\n\nFollowing up my September's mail on the setting of a new decentralized,\nopen and neutral community process dedicated to covenants R&D, a.k.a\n\"Bitcoin Contracting Primitives WG\", few updates.\n\nAfter collecting feedback on the adequate communication channel, a low\naccess bar and pseudonymous participation sounds to be recurring criterias.\nAs such, I would like to propose using IRC on Libera Chat.\n\nOpened the following chan:\n\n#bitcoin-contracting-primitives-wg\n\nIf there are still strong likes for another communication channel, we can\nstill consider it.\n\nFor the 1st meeting date, I was thinking about the second week of November\nstarting the 7th. About the day and time, we have the following list of\nBitcoin open-source meetings happening across the ecosystem:\n- Bitcoin Core general developer meeting Thursday 19:00 UTC\n- Bitcoin Core wallet developer meeting Friday 19:00 UTC (every second week)\n- Bitcoin Core PR review club Wednesday 17:00 UTC\n- Lightning developer meeting Monday 20:00 UTC (bi-weekly, modulo weird\nAustralian timezones details that I don't understand)\n- Core Lightning developer meeting Monday 20:00 UTC (every second week)\n- LDK developer meeting Monday 17:00 UTC (every second week)\n- LND PR review club Thursday 17:00 UTC (every second week)\n- LDK PR review club Tuesday 18:00 UTC (every second week)\n- DLC specs meeting Tuesday 19:00 CST (monthly)\n- LSP specs meeting Wednesday 10:00 UTC (every second week)\n\nThis is a best effort to collect all the open-source engineering meetings\nacross the ecosystem, though we might have more, feel free to point out the\nones I'm forgetting.\n\nMinding all those meetings happenings and all the time zones, the usual\ntimes slots fitting most of the people are probably the ones between 16:00\nUTC and 21:00 UTC.\n\nLooking forward to collecting what would be a good time slot for the\nhappening of Bitcoin Contracting primitives WG.\n\nFor the meeting frequency, I think we can start with a monthly frequency,\nthen in function of the pace and sustained interest move to bi-weekly. No\nagenda, we'll see how things are evolving unconf style.\n\nIn the process to collect and document all the known contracting protocol\nuse-cases at:\nhttps://github.com/ariard/bitcoin-contracting-primitives-wg\n\nSo far I've bookmarked the following list:\n- vaults\n- payment pools\n- channel factories\n- drivechains\n- eltoo channels\n- decentralized mining pools\n- scalable stateful contracts (e.g DLCs)\n- congestion control redux\n- non-interactive channels setups\n- state channels\n\nThough we're likely to see more emerge with time, feel free to point to the\nones I'm forgetting.\n\nRecently, during a panel at a Bitcoin conference, I've been asked why such\na primitives working group rather than a specialized WG on the use-case I'm\nmostly interested in (i.e payment pools). From my experience, the\ncontracting primitives or covenant you're designing is more likely to be a\nfunction of the use-case properties you've in mind (e.g economic efficiency\nor flexibility), however it might not generalize well to the other\ncontracting use-cases envisioned by a lot of other folks. One wishful\nthinking of setting up this R&D effort could yield one common contracting\nprimitives toolchain servicing all the known use-cases. Though this is only\nwishful thinking and we'll see what happens, in fine Bitcoin development is\nkinda like jazz music, loosely structured, you launch the first few notes\nand then you listen to what the other musicians keep going on.\n\nStill open to more feedback on what the ideal Bitcoin contracting\nprimitives WG would look like.\n\nCheers,\nAntoine\n\nLe mer. 20 juil. 2022 \u00e0 16:42, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Hi,\n>\n> Discussions on covenants have been prolific and intense on this mailing\n> list and within the wider Bitcoin technical circles, I believe however\n> without succeeding to reach consensus on any new set of contracting\n> primitives satisfying the requirements of known covenant-enabled use-cases.\n> I think that's a fact to deplore as covenants would not only offer vast\n> extensions of the capabilities of Bitcoin as a system, i.e enabling new\n> types of multi-party contract protocols. But also empowering Bitcoin on its\n> fundamental value propositions of store of value (e.g by making vaults more\n> flexible) and payment system (e.g by making realistic channel\n> factories/payment pools).\n>\n> If we retain as a covenant definition, a spending constraint restricting\n> the transaction to which the spent UTXO can be spent, and enabling to\n> program contracts/protocols at the transaction-level instead of the\n> script-level, the list of Script primitives proposed during the last years\n> has grown large : ANYPREVOUT [0], CHECKSIGFROMSTACK [1],\n> CHECK_TEMPLATE_VERIFY [2], TAPROOT_LEAF_UPDATE_VERIFY [3], TXHASH [4],\n> PUSHTXDATA [5], CAT [6], EVICT [7], Grafroot delegation [8], SIGHASH_GROUP\n> [9], MERKLEBRANCHVERIFY [10] and more than I can't remember. Of course, all\n> the listed primitives are at different states of formalization, some\n> already fully fleshed-out in BIPs, other still ideas on whiteboard, yet\n> they all extend the range of workable multi-party contract protocols.\n>\n> Indeed this range has grown wild. Without aiming to be exhaustive (I'm\n> certainly missing some interesting proposals lost in the abyss of\n> bitcointalk.org), we can mention the following use-cases: multi-party\n> stateful contracts [11], congestion trees [12], payment pools [13], \"eltoo\"\n> layered commitments [14], programmable vaults [15], multi-events contracts\n> [16], blockchain-as-oracle bets [17], spacechains [18], trustless\n> collateral lending [19], ...\n>\n> Minding all those facts, I would say the task of technical evaluation of\n> any covenant proposal sounds at least two fold. There is first reasoning\n> about the enabled protocols on a range of criterias such as scalability,\n> efficiency, simplicity, extensibility, robustness, data confidentiality,\n> etc. Asking questions like what are the interactions between layers, if any\n> ? Or how robust is the protocol, not just interactivity failure between\n>  participant nodes but in the face of mempools spikes or internet\n> disruption ? Or if the performance is still acceptable on shared resources\n> like blockspace or routing tables if everyone is using this protocol ? Or\n> if the protocol minimizes regulatory attack surface or centralization\n> vectors ?\n>\n> Though once this step is achieved, there is still more reasoning work to\n> evaluate how good a fit is a proposed Script primitive, the\n> efficiency/simplicity/ease to use trade-offs, but also if there are no\n> functionality overlap or hard constraints on the use-cases design\n> themselves or evolvability w.rt future Script extensions or generalization\n> of the opcode operations.\n>\n> Moreover, if you would like your evaluation of a covenant proposal to be\n> complete, I don't believe you can squeeze the implications with the mempool\n> rules and combination with any consistent fee-bumping strategy. To say\n> things politely, those areas have been a quagmire of vulnerabilities,\n> attacks and defects for second-layers Bitcoin protocols during the last\n> years [20].\n>\n> Considering the abundant problem-space offered by covenants, I believe\n> there is a reasonable groundwork to pursue in building the use-cases\n> understanding (e.g prototype, pseudo-specification, documentation, ...) and\n> building consensus on the framework of criterias on which to evaluate them\n> [21]. It might raise a really high bar for any covenant proposal compared\n> to previous softforks, however I think it would adequately reflect the\n> growth in Bitcoin complexity and funds at stakes during the last years.\n>\n> Moving towards this outcome, I would like to propose a new covenant open\n> specification process, in the same spirit as we have with the BOLTs or\n> dlcspecs. We would have regular meetings (biweekly/monthly ?), an open\n> agenda where topics of discussion can be pinned in advance and\n> documentation artifacts would be built with time driven by consensus (e.g\n> 1st phase could be to collect, pseudo-specify and find champion(s) for\n> known use-cases ?) and no timeframe. Starting date could be September /\n> October / November (later, 2023 ?), giving time for anyone interested in\n> such a covenant process to allocate development and contribution bandwidth\n> in function of their involvement interest.\n>\n> Learning from the good but specially from the bad with setting up the L2\n> onchain support meetings last year, I think it would be better to keep the\n> agenda open, loose and free as much we can in a \"burn-the-roadmap\" spirit,\n> avoiding to create a sense of commitment or perceived signaling in the\n> process participants towards any covenant solution. I would guess things to\n> be experimental and evolutionary and folks to spend the first meetings\n> actually to express what they would like the covenant process to be about\n> (and yes that means if you're a domain expert and you find the pace of\n> things too slow sometimes, you have to learn to handle your own\n> frustration...).\n>\n> In a \"decentralize-everything\" fashion, I believe it would be good to have\n> rotating meeting chairs and multiple covenant documentation archivists. I'm\n> super happy to spend the time and energy bootstrapping well such covenant\n> process effort, though as it's Bitcoin learn to decentralize yourself.\n>\n> I'm really curious what the outcome of such a covenant process would look\n> like. We might end up concluding that complex covenants are too unsafe by\n> enabling sophisticated MEV-attacks against LN [22]. Or even if there is an\n> emergent technical consensus, it doesn't mean there is a real market\n> interest for such covenant solutions. That said, I'm not sure if it's\n> really a subject of concern when you're reasoning as a scientist/engineer\n> and you value technical statements in terms of accuracy, systematic\n> relevance and intrinsic interest.\n>\n> Overall, my motivation to kick-start such a process stays in the fact that\n> covenants are required building blocks to enable scalable payments pools\n> design like CoinPool. I believe payments pools are a) cool and b) a good\n> shot at scaling Bitcoin as a payment system once we have reached\n> scalability limits of Lightning, still under the same security model for\n> users. However, as a community we might sense it's not the good timing for\n> a covenant process. I'm really fine with that outcome as there are still\n> holes to patch in LN to keep me busy enough for the coming years.\n>\n> Zooming out, I believe with any discussion about covenants or other soft\n> forks, the hard part isn't about coming up with the best technical solution\n> to a set of problems but in the iterative process where all voices are\n> listened to reach (or not) consensus on what is actually meant by \"best\"\n> and if the problems are accurate. The real physics of Bitcoin is the\n> physics of people. It's a work of patience.\n>\n> Anyways, eager to collect feedbacks on what the ideal covenant\n> specification process looks like. As usual, all opinions and mistakes are\n> my own.\n>\n> Cheers,\n> Antoine\n>\n> [0] https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki\n> [1] https://bitcoinops.org/en/topics/op_checksigfromstack/\n> [2] https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki\n> [3]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html\n> [4]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html\n> [5] https://github.com/jl2012/bips/blob/vault/bip-0ZZZ.mediawiki\n> [6] https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298\n> [7]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019926.html\n> [8]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015700.html\n> [9]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html\n> [10] https://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki\n> [11]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html\n> [12]\n> https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki#Congestion_Controlled_Transactions\n> [13]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017964.html\n> [14]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html\n> [15] http://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf\n> [16]\n> https://github.com/ariard/talk-slides/blob/master/advanced-contracts.pdf\n> [17] https://blog.bitmex.com/taproot-you-betcha/\n> [18]\n> https://gist.github.com/RubenSomsen/c9f0a92493e06b0e29acced61ca9f49a#spacechains\n> [19] https://gist.github.com/RubenSomsen/bf08664b3d174551ab7361ffb835fcef\n> [20] https://github.com/jamesob/mempool.work\n> [21] https://github.com/bitcoinops/bitcoinops.github.io/pull/806\n> [22] https://blog.bitmex.com/txwithhold-smart-contracts/\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221007/d039720c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "On a new community process to specify covenants",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 13123
        }
    },
    {
        "title": "[bitcoin-dev] [Opt-in full-RBF] Zero-conf apps in immediate danger",
        "thread_messages": [
            {
                "author": "Dario Sneidermanis",
                "date": "2022-10-07T16:20:49",
                "message_text_only": "Hello list,\n\nI'm Dario, from Muun wallet, a mobile non-custodial bitcoin wallet. For the\npast\nfew days we've been reviewing the latest bitcoin core release candidate,\nand we\nfound some troubling facts related to the opt-in full-RBF deployment.\n\nWe first learned about the opt-in full-RBF proposal last June when it was\nannounced on the mailing list. Closing the gap between the protocol's relay\npolicies and the miner incentives is inevitable, so it was a welcomed\naddition.\nFurthermore, allowing transaction replacements that remove the opt-in RBF\nflag\nwas deeply problematic.\n\nAt the time, we understood we had at least a year from the initial opt-in\ndeployment until opt-out was deployed, giving us enough time to adapt Muun\nto\nthe new policies. However, when reviewing the 24.0 release candidate just a\nfew\ndays ago, we realized that zero-conf apps (like Muun) must *immediately turn\noff* their zero-conf features.\n\nI understand this wasn't the intention when designing the opt-in deployment\nmechanism. Given this new information, do you see a path where we can delay\nthe\nopt-in deployment and find a safer way to deploy full-RBF?\n\nIt'd be great for this deployment to be a success so that we can continue\nfixing\nthe remaining relay policy problems, such as package relay and the RBF\nrules.\nMaybe we could go straight to an opt-out deployment locked by code at a\ncertain\nheight in the future to give time to everyone and, at the same time, avoid a\nhuge mempool divergence event?\n\nBelow is our analysis of how zero-conf apps break with opt-in full-RBF. I\nhope\nit helps.\n\nCheers,\nDario\n\n\n# How do zero-conf apps work\n\nWhile the workings and trade-offs of zero-conf applications might be known\nby\nmany in this list, it's useful to define precisely how they work to\nunderstand\nhow they break.\n\nWe call zero-conf applications to entities that accept on-chain payments\nfrom\n*untrusted parties* and will sometimes deliver the paid-for product or\nservice\nwithout waiting for the transaction to be included in a block.\n\nSome examples of zero-conf apps:\n\n- Muun's submarine swaps for outgoing lightning payments\n- Bitrefill's on-chain payments for gift cards and phone top-ups\n- Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at\nleast\n  the two biggest bitcoin ATM manufacturers support this: Genesis Coin and\n  General Byte)\n\nAll of these applications are receiving incoming on-chain transactions for\nwhich\nthey don't control the inputs, and performing a risk analysis to decide\nwhether\nthey are ok with accepting the payment without confirmation.\n\nIn practice, this works because once the bitcoin P2P network has fully\npropagated a non-RBF transaction, you need the collaboration of a miner to\nreplace it, which isn't easy to get today. Even though many of the biggest\nminers offer off-band transaction broadcasting services, they currently\nwon't\nprocess conflicting transactions.\n\nRoughly, the risk analysis goes like this:\n\n1. if an incoming transaction is RBF (direct or inherited)\n   --> too risky, wait for 1 conf (or more) since it can be replaced at any\ntime\n2. if the payment is for an amount greater than X\n   --> too risky, wait for 1 conf (or more), since the amount is worthy of a\n       sophisticated attacker\n3. wait for full(ish) propagation of the incoming transaction\n4. if there's no double-spend attempt\n   --> accept 0-conf\n\nAs with any other risk analysis, there's always a false-negative detection\nrate,\nleading to an expected loss, which the zero-conf app should be willing to\nbear.\nNotice that the expected loss is tunable via the amount X in the above\nanalysis.\n\n\n# Why are zero-conf apps not protected with an opt-in deployment\n\nFull-RBF adoption works on three different layers:\n\n- The transaction application layer\n- The transaction relaying layer\n- The transaction mining layer\n\nIf an application wants to replace with full-RBF an *outgoing* transaction,\nit\nwill need:\n\n- An upgraded node that opted into full-RBF, from which it can broadcast the\n  replacement transaction\n- A connected component of upgraded nodes that opted into full-RBF, that can\n  relay the replacement transaction\n- A miner in that connected component with an upgraded node that opted into\n  full-RBF, that can mine the replacement transaction\n\nHowever, an application cannot control whether a replacement to an\n*incoming*\ntransaction is relayed via full-RBF. As soon as a single application can\ngenerate replacements easily via full-RBF, all other applications have to\nassume\nthat any incoming transaction from an untrusted party might be replaced via\nfull-RBF. That is, for the application layer this is a forced upgrade.\n\nAs soon as an unsophisticated attacker can use opt-in full-RBF, the risk\nanalysis performed by zero-conf applications stops working because the\ntransactions to analyze are all incoming transactions from untrusted\nparties.\nSince some wallets already implement cancel functionality for opt-in RBF\ntransactions, enabling the same functionality for every transaction wouldn't\nrequire much work, making canceling any unconfirmed transaction a one-click\nexperience. After this, the security model of zero-conf applications goes\nfrom\n\"susceptible to attacks from miners\" to \"anyone can perform an attack, with\nan\neasy-to-use interface\".\n\nThat is, the opt-in deployment of full-RBF doesn't protect zero-conf\napplications from having to turn off their zero-conf features very soon\nafter\nthe initial deployment. All mitigations are mostly ineffective against\nuntrusted parties.\n\n\n# Other things we have to fix\n\nWhile it's clear how full-RBF breaks zero-conf applications, other more\nsubtle\nthings break in *many* wallets (Muun included). If given the opportunity, we\nwould like to fix them before deployment. One could argue that these things\nwere already broken, but they get considerably worse as the network adopts\nfull-RBF (even with an opt-in deployment), so we should fix them.\n\n## Mental model for unconfirmed incoming transactions\n\nMany wallets with support for on-chain payments (Muun included) show\nincoming\nexternal transactions in some way to their users before they confirm. This\nis a\ncommon practice because not showing them leads users to worry that their\nmoney\ndisappeared (exchanges doing this is the #1 issue we have to deal with in\nour\ncustomer support channels).\n\nWith full-RBF, wallets should make it extremely clear to users that\nunconfirmed\nfunds are not theirs (yet). Otherwise, protocol-unaware users that are\ntransacting on-chain with untrusted parties can be easily scammed if they\ndon't\nknow they have to wait for a confirmation. Eg. in Argentina, it's pretty\ncommon\nto meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n\n## Block explorers as payment receipts\n\nMost wallets with support for on-chain payments (Muun included) use the\ntransaction view of a block explorer as a shareable payment receipt. The\nsender\nof an on-chain transaction usually shares this link with the receiver to let\nthem know they made a payment. Protocol-unaware receivers sometimes take\nthis\nlink as proof of payment.\n\nMost explorers currently don't track payment replacements and, more\nimportantly,\ndon't warn users that unconfirmed funds are not theirs (yet). With full-RBF,\nwallets should either stop relying on explorers for this functionality or\nwait\nfor them to support it explicitly.\n\n\n# Impact at Muun\n\nWork to transition Muun from using zero-conf submarine swaps to using\npayment\nchannels is ongoing, but we are still several months away from being\nproduction\nready. This means we would have to turn off outgoing lightning payments for\n+100k monthly active users, which is a good chunk of all users making\nnon-custodial lightning payments today.\n\nFurthermore, the more subtle fixes imply non-trivial amounts of product work\nthat we cannot reasonably deploy before they start affecting users.\n\nWhile I cannot talk for other applications, there are many impacted in one\nway\nor another, and none of the ones I checked with were aware of this change,\nor\nits implications.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221007/d8b61478/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2022-10-07T17:21:29",
                "message_text_only": "On 2022-10-07 06:20, Dario Sneidermanis via bitcoin-dev wrote:\n> Hello list,\n> \n> I'm Dario, from Muun wallet [...] we've been reviewing the latest \n> bitcoin core release\n> candidate [...] we understood we had at least a year from the initial\n> opt-in  deployment until opt-out was deployed, giving us enough time to \n> adapt\n> Muun to the new policies. However, when reviewing the 24.0 release \n> candidate\n> just a few  days ago, we realized that zero-conf apps (like Muun) must\n> *immediately turn off* their zero-conf features.\n\nHi Dario,\n\nI'm wondering if there's been some confusion.  There are two RBF-related \nitems in the current release notes draft:[1]\n\n1. \"A new mempoolfullrbf option has been added, which enables the \nmempool to accept transaction replacement without enforcing BIP125 \nreplaceability signaling. (#25353)\"\n\n2. \"The -walletrbf startup option will now default to true. The wallet \nwill now default to opt-in RBF on transactions that it creates. \n(#25610)\"\n\nThe first item (from PR #25353) does allow a transaction without a \nBIP125 signal to be replaced, but this configuration option is set to \ndisabled by default.[2]  There have been software forks of Bitcoin Core \nsince at least 2015 which have allowed replacement of non-signaling \ntransactions, so this option just makes that behavior a little bit more \naccessible to users of Bitcoin Core.  Some developers have announced \ntheir intention to propose enabling this option by default in a future \nrelease, which I think is the behavior you're concerned about, but \nthat's not planned for the release of 24.0 to the best of my knowledge.\n\nThe second item (from PR #25610) only affects Bitcoin Core's wallet, and \nin particular transactions created with it through the RPC interface.  \nThose transactions will now default to signaling BIP125 replacability.  \nThis option has been default false for many years for the RPC, but for \nthe GUI it's been default true since Bitcoin Core 0.16, released in \nearly 2018[3].  It's no different than another popular wallet beginning \nto signal BIP125 support by default.\n\nIn short, I don't think anything in Bitcoin Core 24.0 RC1 significantly \nchanges the current situation related to transaction replacability.  All \nit does is give Bitcoin Core RPC users by default the same settings long \nused for GUI users and introduce an option that those who object to \nnon-signalled RBF will later be able to use to disable their relay of \nnon-signalled replacements.\n\nDoes the above information resolve your concerns?\n\nThanks,\n\n-Dave\n\n[1] \nhttps://github.com/bitcoin-core/bitcoin-devwiki/wiki/24.0-Release-Notes-draft\n\n[2] $ bin/bitcoind -help | grep -A3 mempoolfullrbf\n   -mempoolfullrbf\n        Accept transaction replace-by-fee without requiring \nreplaceability\n        signaling (default: 0)\n\n[3] \nhttps://bitcoincore.org/en/2018/02/26/release-0.16.0/#replace-by-fee-by-default-in-gui"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-07T17:28:28",
                "message_text_only": "David, Dario,\n\nThe only other effort I'm aware of is\nhttps://github.com/bitcoin/bitcoin/pull/25600 , which as you can see, has\nno consensus yet, isn't in 24.0, so at earliest would be 25.0, even if\nsomehow immediate resolution to the discussions were found.\n\nCheers,\nGreg\n\nOn Fri, Oct 7, 2022 at 1:21 PM David A. Harding via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On 2022-10-07 06:20, Dario Sneidermanis via bitcoin-dev wrote:\n> > Hello list,\n> >\n> > I'm Dario, from Muun wallet [...] we've been reviewing the latest\n> > bitcoin core release\n> > candidate [...] we understood we had at least a year from the initial\n> > opt-in  deployment until opt-out was deployed, giving us enough time to\n> > adapt\n> > Muun to the new policies. However, when reviewing the 24.0 release\n> > candidate\n> > just a few  days ago, we realized that zero-conf apps (like Muun) must\n> > *immediately turn off* their zero-conf features.\n>\n> Hi Dario,\n>\n> I'm wondering if there's been some confusion.  There are two RBF-related\n> items in the current release notes draft:[1]\n>\n> 1. \"A new mempoolfullrbf option has been added, which enables the\n> mempool to accept transaction replacement without enforcing BIP125\n> replaceability signaling. (#25353)\"\n>\n> 2. \"The -walletrbf startup option will now default to true. The wallet\n> will now default to opt-in RBF on transactions that it creates.\n> (#25610)\"\n>\n> The first item (from PR #25353) does allow a transaction without a\n> BIP125 signal to be replaced, but this configuration option is set to\n> disabled by default.[2]  There have been software forks of Bitcoin Core\n> since at least 2015 which have allowed replacement of non-signaling\n> transactions, so this option just makes that behavior a little bit more\n> accessible to users of Bitcoin Core.  Some developers have announced\n> their intention to propose enabling this option by default in a future\n> release, which I think is the behavior you're concerned about, but\n> that's not planned for the release of 24.0 to the best of my knowledge.\n>\n> The second item (from PR #25610) only affects Bitcoin Core's wallet, and\n> in particular transactions created with it through the RPC interface.\n> Those transactions will now default to signaling BIP125 replacability.\n> This option has been default false for many years for the RPC, but for\n> the GUI it's been default true since Bitcoin Core 0.16, released in\n> early 2018[3].  It's no different than another popular wallet beginning\n> to signal BIP125 support by default.\n>\n> In short, I don't think anything in Bitcoin Core 24.0 RC1 significantly\n> changes the current situation related to transaction replacability.  All\n> it does is give Bitcoin Core RPC users by default the same settings long\n> used for GUI users and introduce an option that those who object to\n> non-signalled RBF will later be able to use to disable their relay of\n> non-signalled replacements.\n>\n> Does the above information resolve your concerns?\n>\n> Thanks,\n>\n> -Dave\n>\n> [1]\n>\n> https://github.com/bitcoin-core/bitcoin-devwiki/wiki/24.0-Release-Notes-draft\n>\n> [2] $ bin/bitcoind -help | grep -A3 mempoolfullrbf\n>    -mempoolfullrbf\n>         Accept transaction replace-by-fee without requiring\n> replaceability\n>         signaling (default: 0)\n>\n> [3]\n>\n> https://bitcoincore.org/en/2018/02/26/release-0.16.0/#replace-by-fee-by-default-in-gui\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221007/631f5053/attachment-0001.html>"
            },
            {
                "author": "Dario Sneidermanis",
                "date": "2022-10-07T21:37:38",
                "message_text_only": "Hello David,\n\nThanks for the fast answer! It seems I missed the link to the PR, sorry for\nthe\nconfusion. I'm referring to the opt-in flag for full-RBF from #25353\n(https://github.com/bitcoin/bitcoin/pull/25353).\n\nOn Fri, Oct 7, 2022 at 2:21 PM David A. Harding <dave at dtrt.org> wrote:\n\n> On 2022-10-07 06:20, Dario Sneidermanis via bitcoin-dev wrote:\n> > Hello list,\n> >\n> > I'm Dario, from Muun wallet [...] we've been reviewing the latest\n> > bitcoin core release\n> > candidate [...] we understood we had at least a year from the initial\n> > opt-in  deployment until opt-out was deployed, giving us enough time to\n> > adapt\n> > Muun to the new policies. However, when reviewing the 24.0 release\n> > candidate\n> > just a few  days ago, we realized that zero-conf apps (like Muun) must\n> > *immediately turn off* their zero-conf features.\n>\n> Hi Dario,\n>\n> I'm wondering if there's been some confusion.  There are two RBF-related\n> items in the current release notes draft:[1]\n>\n> 1. \"A new mempoolfullrbf option has been added, which enables the\n> mempool to accept transaction replacement without enforcing BIP125\n> replaceability signaling. (#25353)\"\n>\n> 2. \"The -walletrbf startup option will now default to true. The wallet\n> will now default to opt-in RBF on transactions that it creates.\n> (#25610)\"\n>\n> The first item (from PR #25353) does allow a transaction without a\n> BIP125 signal to be replaced, but this configuration option is set to\n> disabled by default.[2]  There have been software forks of Bitcoin Core\n> since at least 2015 which have allowed replacement of non-signaling\n> transactions, so this option just makes that behavior a little bit more\n> accessible to users of Bitcoin Core.\n\n\nThe \"activation\" of full-RBF after deployment works in a pretty interesting\nway:\n\n1. If no miner is running full-RBF or there aren't easily accessible\nconnected\n   components of nodes running full-RBF connected to the miners, then\nfull-RBF\n   is mostly ineffective since replacements aren't relayed and/or mined.\n2. There's a middle ground where *some* connected components of full-RBF\nnodes\n   can relay and mine replacements, where some full-RBF nodes will be able\nto\n   replace via full-RBF and some won't (depending on their peers).\n3. With high enough adoption, the relay graph has enough density of full-RBF\n   nodes that almost all full-RBF nodes can replace transactions via\nfull-RBF.\n\nWhile there have been forks of Bitcoin Core (like Bitcoin Knots) running\nfull-RBF for a while, today most nodes (by far) are running Bitcoin Core.\nSo,\nBitcoin Core adding an opt-in flag (ie. off by default) makes it easier to\nbe\npicked up by most node operators. Making the flag opt-out (ie. on by\ndefault)\nwould make it easier still. We are dealing with a gradient going from hard\nenough that we are still in 1, to easy enough that we get to 3.\n\nThe question then is whether an opt-in flag for full-RBF will have enough\nadoption to get us from 1 to 2. If it isn't, then #25353 won't meet its\nobjective of allowing nodes participating in multi-party funding protocols\nto\nassume that they can rely on full-RBF. If it is, then zero-conf applications\nwill be at severe risk (per the logic in the initial email).\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221007/a17e3454/attachment.html>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2022-10-11T16:18:10",
                "message_text_only": "On Friday, October 7th, 2022 at 5:37 PM, Dario Sneidermanis via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> Hello David,\n> \n> Thanks for the fast answer! It seems I missed the link to the PR, sorry for the\n> confusion. I'm referring to the opt-in flag for full-RBF from #25353\n> (https://github.com/bitcoin/bitcoin/pull/25353).\n\nHello Dario,\n\nIt is not clear to me why you believe the merging of this particular pull request poses an immediate risk to you.\n\nAs explained by others, it's only a configuration option that is default off, and the possibility of running rull-RBF policy nodes on the network have been trivial for anyone who wanted to for a long time on the network.\n\nI don't want to sound dismissive of your concerns, but at this point I'm not convinced you're actually aware of what this PR does and doesn't do.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-12T05:42:14",
                "message_text_only": "On Tue, Oct 11, 2022 at 04:18:10PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> On Friday, October 7th, 2022 at 5:37 PM, Dario Sneidermanis via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Thanks for the fast answer! It seems I missed the link to the PR, sorry for the\n> > confusion. I'm referring to the opt-in flag for full-RBF from #25353\n> > (https://github.com/bitcoin/bitcoin/pull/25353).\n> It is not clear to me why you believe the merging of this particular pull request poses an immediate risk to you.\n\nDid you see the rest of Dario's reply, bottom-posted after the quoted\ntext? Namely:\n\nOn Fri, Oct 07, 2022 at 06:37:38PM -0300, Dario Sneidermanis via bitcoin-dev wrote:\n> The \"activation\" of full-RBF after deployment works in a pretty interesting\n> way:\n> \n> 1. If no miner is running full-RBF or there aren't easily accessible\n> connected components of nodes running full-RBF connected to the miners, then\n> full-RBF is mostly ineffective since replacements aren't relayed and/or mined.\n> 2. There's a middle ground where *some* connected components of full-RBF\n>    nodes can relay and mine replacements, where some full-RBF nodes will be\n>    able to replace via full-RBF and some won't (depending on their peers).\n> 3. With high enough adoption, the relay graph has enough density of full-RBF\n>    nodes that almost all full-RBF nodes can replace transactions via\n>    full-RBF.\n> \n> While there have been forks of Bitcoin Core (like Bitcoin Knots) running\n> full-RBF for a while, today most nodes (by far) are running Bitcoin Core.\n> So,\n> Bitcoin Core adding an opt-in flag (ie. off by default) makes it easier to\n> be\n> picked up by most node operators. Making the flag opt-out (ie. on by\n> default)\n> would make it easier still. We are dealing with a gradient going from hard\n> enough that we are still in 1, to easy enough that we get to 3.\n> \n> The question then is whether an opt-in flag for full-RBF will have enough\n> adoption to get us from 1 to 2. If it isn't, then #25353 won't meet its\n> objective of allowing nodes participating in multi-party funding protocols\n> to assume that they can rely on full-RBF. If it is, then zero-conf applications\n> will be at severe risk (per the logic in the initial email).\n\nThat logic seems reasonably sound to me:\n\n - if adding the option does nothing, then there's no point adding it,\n   and no harm in restricting it to test nets only\n\n - if adding the option does do something, then businesses using zero-conf\n   need to react immediately, or will go from approximately zero risk of\n   losing funds, to substantial risk\n\n(I guess having the option today may allow you to manually switch your\nnode over to supporting fullrbf in future when the majority of the network\nsupports it, without needing to do an additional upgrade in the meantime;\nbut that seems like a pretty weak benefit)\n\nCheers,\naj"
            },
            {
                "author": "Pieter Wuille",
                "date": "2022-10-12T16:11:05",
                "message_text_only": "On Wednesday, October 12th, 2022 at 1:42 AM, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Tue, Oct 11, 2022 at 04:18:10PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> \n> > On Friday, October 7th, 2022 at 5:37 PM, Dario Sneidermanis via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > \n> > > Thanks for the fast answer! It seems I missed the link to the PR, sorry for the\n> > > confusion. I'm referring to the opt-in flag for full-RBF from #25353\n> > > (https://github.com/bitcoin/bitcoin/pull/25353).\n> > > It is not clear to me why you believe the merging of this particular pull request poses an immediate risk to you.\n> \n> \n> Did you see the rest of Dario's reply, bottom-posted after the quoted\n> text? Namely:\n\nOh, my mail client for some reason chose to hide all that. Dario, I'm sorry for missing this; I see now that you were certainly aware of what the PR under consideration did.\n\nFurther comments inline.\n\n> On Fri, Oct 07, 2022 at 06:37:38PM -0300, Dario Sneidermanis via\n\n> > The question then is whether an opt-in flag for full-RBF will have enough\n> > adoption to get us from 1 to 2. If it isn't, then #25353 won't meet its\n> > objective of allowing nodes participating in multi-party funding protocols\n> > to assume that they can rely on full-RBF. If it is, then zero-conf applications\n> > will be at severe risk (per the logic in the initial email).\n\n> \n> \n> That logic seems reasonably sound to me:\n> \n> - if adding the option does nothing, then there's no point adding it,\n> and no harm in restricting it to test nets only\n> \n> - if adding the option does do something, then businesses using zero-conf\n> need to react immediately, or will go from approximately zero risk of\n> losing funds, to substantial risk\n> \n> (I guess having the option today may allow you to manually switch your\n> node over to supporting fullrbf in future when the majority of the network\n> supports it, without needing to do an additional upgrade in the meantime;\n> but that seems like a pretty weak benefit)\n\nI certainly recognize that adding the flag is a likely step towards, over time, the full RBF policy becoming more widely adopted on the network. That is presumably the reason why people are in favor of having the flag, even default off - including me. I believe that policy's adoption is inevitable eventually, but the speed at which that is achieved is certainly a function of availability and adopted of software which provides the option.\n\nThat said, I think it's a bit of a jump to conclude that the only two options are that either the existence of the flag either has no effect at all, or poses an immediate threat to those relying on its absence. In my view, it is just what I said: a step towards getting full RBF on the network, by allowing experimentation and socializing the notion that developers believe it is time. So I have a hard time imagining how it would change anything *immediately* on the network at large (without things like default on and/or preferential peering, ...), but I still believe it's an important step.\n\nCheers,\n\n-- \nPieter"
            },
            {
                "author": "Dario Sneidermanis",
                "date": "2022-10-12T21:44:13",
                "message_text_only": "Hello Pieter,\n\nThanks for taking the time to comment! I'll answer inline.\n\nOn Wed, Oct 12, 2022 at 2:51 PM Pieter Wuille <bitcoin-dev at wuille.net>\nwrote:\n> I certainly recognize that adding the flag is a likely step towards, over\n> time, the full RBF policy becoming more widely adopted on the network.\nThat is\n> presumably the reason why people are in favor of having the flag, even\ndefault\n> off - including me. I believe that policy's adoption is inevitable\neventually,\n> but the speed at which that is achieved is certainly a function of\n> availability and adopted of software which provides the option.\n\nAs stated in the original posting, I believe too that a full-RBF network is\nnot\nonly inevitable but also desirable. Miner incentives will eventually win,\nso we\nshould address them before they fully kick in (ie. before transaction fees\nbecome a meaningful portion of the block reward).\n\n> So I have a hard time imagining how it would change anything\n*immediately* on\n> the network at large (without things like default on and/or preferential\n> peering, ...), but I still believe it's an important step.\n\nNotice that I'm not saying this changes anything immediately on the network\nat\nlarge. In fact, it is unlikely that the opt-in flag alone would be enough to\nmigrate the network at large to full-RBF.\n\nThere's a real possibility that, after deployment of the opt-in flag,\neither no\nmeaningful hashing power adopts it or no connected component of\ntransaction-relaying nodes adopts it. If that's the case, the deployment\nwon't\nhelp nodes participating in multi-party funded transactions protect against\nthe\nclass of attacks described in [1] (which was, as I understand, the original\nintention of #25353).\n\nIf that's not the case, it means that at least some meaningful hashing power\nadopted it and that there exist some connected components of\ntransaction-relaying nodes that adopted it. This is certainly far from\nhaving\nwide adoption of full-RBF in the network at large. However, once we reach\nthat\nminimal level of adoption in the mining and relaying layers, any node on a\nfull-RBF connected component can send an on-chain payment to an application\nand\nthen get a replacement mined. That is, applications that accept incoming\non-chain payments from untrusted parties can be immediately exposed to\nfull-RBF\ntransaction replacements, even if they didn't opt into full-RBF in their\nnodes.\n\nIn an adversarial setting, such as the one for zero-conf applications (as\ndefined in the original posting), this increases the risk of an attack\nsubstantially, making the entire strategy moot.\n\n> In my view, it is just what I said: a step towards getting full RBF on the\n> network, by allowing experimentation and socializing the notion that\n> developers believe it is time.\n\nThose are worthy goals. I believe we can design a deployment strategy for\nfull-RBF that takes them into account and, at the same time, gives a clear\ntimeline for any affected application to adapt.\n\nThis could be one such proposal:\n\n1. We activate opt-in full-RBF on testnet now.\n2. We commit now (in the code) to a block height in the future at which\nopt-out\n   full-RBF will activate on mainnet.\n\nThe first point will allow for experimentation and give a testing ground to\nall\naffected applications. The second point socializes the notion that\ndevelopers\nbelieve it is time, giving a clear message and timeline for anyone affected\nto\nadapt. It also has the benefit that many more nodes will have upgraded by\nthe\ntime we reach the activation block height, making the transition to a\nfull-RBF\nnetwork much more predictable and easy to reason about.\n\nThere's an argument to be made that the miner incentive incompatibility\nproblem\nof a non-full-RBF network gets measurably worse at the time of the next\nhalving.\nTo fix this, we could choose any block height before that, giving a clear\nand\npredictable transition timeline.\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\nOn Wed, Oct 12, 2022 at 1:11 PM Pieter Wuille <bitcoin-dev at wuille.net>\nwrote:\n\n> On Wednesday, October 12th, 2022 at 1:42 AM, Anthony Towns <\n> aj at erisian.com.au> wrote:\n>\n> > On Tue, Oct 11, 2022 at 04:18:10PM +0000, Pieter Wuille via bitcoin-dev\n> wrote:\n> >\n> > > On Friday, October 7th, 2022 at 5:37 PM, Dario Sneidermanis via\n> bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > >\n> > > > Thanks for the fast answer! It seems I missed the link to the PR,\n> sorry for the\n> > > > confusion. I'm referring to the opt-in flag for full-RBF from #25353\n> > > > (https://github.com/bitcoin/bitcoin/pull/25353).\n> > > > It is not clear to me why you believe the merging of this particular\n> pull request poses an immediate risk to you.\n> >\n> >\n> > Did you see the rest of Dario's reply, bottom-posted after the quoted\n> > text? Namely:\n>\n> Oh, my mail client for some reason chose to hide all that. Dario, I'm\n> sorry for missing this; I see now that you were certainly aware of what the\n> PR under consideration did.\n>\n> Further comments inline.\n>\n> > On Fri, Oct 07, 2022 at 06:37:38PM -0300, Dario Sneidermanis via\n>\n> > > The question then is whether an opt-in flag for full-RBF will have\n> enough\n> > > adoption to get us from 1 to 2. If it isn't, then #25353 won't meet its\n> > > objective of allowing nodes participating in multi-party funding\n> protocols\n> > > to assume that they can rely on full-RBF. If it is, then zero-conf\n> applications\n> > > will be at severe risk (per the logic in the initial email).\n>\n> >\n> >\n> > That logic seems reasonably sound to me:\n> >\n> > - if adding the option does nothing, then there's no point adding it,\n> > and no harm in restricting it to test nets only\n> >\n> > - if adding the option does do something, then businesses using zero-conf\n> > need to react immediately, or will go from approximately zero risk of\n> > losing funds, to substantial risk\n> >\n> > (I guess having the option today may allow you to manually switch your\n> > node over to supporting fullrbf in future when the majority of the\n> network\n> > supports it, without needing to do an additional upgrade in the meantime;\n> > but that seems like a pretty weak benefit)\n>\n> I certainly recognize that adding the flag is a likely step towards, over\n> time, the full RBF policy becoming more widely adopted on the network. That\n> is presumably the reason why people are in favor of having the flag, even\n> default off - including me. I believe that policy's adoption is inevitable\n> eventually, but the speed at which that is achieved is certainly a function\n> of availability and adopted of software which provides the option.\n>\n> That said, I think it's a bit of a jump to conclude that the only two\n> options are that either the existence of the flag either has no effect at\n> all, or poses an immediate threat to those relying on its absence. In my\n> view, it is just what I said: a step towards getting full RBF on the\n> network, by allowing experimentation and socializing the notion that\n> developers believe it is time. So I have a hard time imagining how it would\n> change anything *immediately* on the network at large (without things like\n> default on and/or preferential peering, ...), but I still believe it's an\n> important step.\n>\n> Cheers,\n>\n> --\n> Pieter\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221012/5280640b/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-13T04:35:22",
                "message_text_only": "On Wed, Oct 12, 2022 at 04:11:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> In my view, it is just what I said: a step towards getting full RBF\n> on the network, by allowing experimentation and socializing the notion\n> that developers believe it is time.\n\nWe \"believe it is time\" for what exactly, though? (a) To start\ndeprerecating accepting zeroconf txs on mainnet, over the next 6, 12 or\n18 months; or (b) to start switching mainnet mining and relay nodes over\nto full RBF?\n\nAs far as experimentation goes, I don't really see this option as being\nvery likely to help: the default for this option is still false, so it's\nlikely going to be difficult to get non-opt-in RBF txs relayed or mined\nanywhere, even on testnet or signet, no? (Maybe that's a difficulty that's\nresolved by an addnode, but it's still a difficulty) If experimentation's\nthe goal, making the default be true for testnet/signet at least seems\nlike it would be pretty useful at least. Meaningful experimentation is\nprobably kind of difficult in the first place while fees are low and\nthere's often no backlog in the mempool, as well; something that perhaps\napplies more to test nets than mainnet even.\n\nIf we're trying to socialise the idea that zeroconf deprecation is\nhappening and that your business now has a real deadline for migrating\naway from accepting unconfirmed txs if the risk of being defrauded\nconcerns you, then enabling experimentation on test nets and not touching\nmainnet until a later release seems fairly fine to me -- similar to\nactivating soft forks on test nets prior to activating it on mainnet.\n\n> So I have a hard time imagining how it\n> would change anything *immediately* on the network at large (without\n> things like default on and/or preferential peering, ...), but I still\n> believe it's an important step.\n\nIf we're instead trying to socialise the idea that relaying and mining\nfull RBF txs on mainnet should be starting now, then I think that's\nexactly how this *would* change things almost immediately on the network\nat large.\n\nI think all it would take in practice to be able to repeatedly defraud\nbusinesses accepting unconfirmed txs is perhaps 5% or 10% of blocks\nto include full RBF txs [0] [1], and knowing some IP addresses to\naddnode so that your txs relayed to those miners. And if core devs are\nadvocating that full RBF is ready now [2], and a patch to easily enable\nit is included in a bitcoin core release, why wouldn't some small pools\nstart trying it out, leading to exactly that situation?\n\nIf most of the network doesn't relay your full-rbf txs, then that's\nannoying for protocol developers who'd like to rely on it, but it's fine\nfor an attacker: it just means the business you're trying to trick has\nless chance of noticing the attack before it's too late, because they'll\nbe less likely to see the conflicting tx via both their own node or\npublic explorers.\n\nCheers,\naj\n\n[0] A few months ago, Peter Todd reported switching an OTS calendar to do\n    non-opt-in RBF, and didn't observe bumped txs being mined, which seems\n    to indicate there's not much hash power currently mining full RBF.\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n\n[1] Also why I remain surprised that accepting zeroconf is safe enough\n    in practice for anyone to do it. I suppose 5% of hashpower is perhaps\n    $100M+ investment in ASICs and $900k/day in revenue, and perhaps\n    all the current ways of enabling full RBF are considered too risky\n    to mess around with at that level.\n\n[2] Antoine Riard's mail from June (that Peter's mail above was in reply\n    to) announced such a public node, and encouraged miners to start\n    adoption: \"If you're a mining operator looking to increase your\n    income, you might be interested to experiment with full-rbf\n    as a policy.\" Presuming the IRC channel \"##uafrbf\" stands\n    for \"user-activated full rbf\", that also seems in line with\n    the goal being to socialise doing full RBF on mainnet immediately...\n    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-16T08:08:49",
                "message_text_only": "On Thu, Oct 13, 2022 at 02:35:22PM +1000, Anthony Towns via bitcoin-dev wrote:\n> On Wed, Oct 12, 2022 at 04:11:05PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> > In my view, it is just what I said: a step towards getting full RBF\n> > on the network, by allowing experimentation and socializing the notion\n> > that developers believe it is time.\n> We \"believe it is time\" for what exactly, though? (a) To start\n> deprerecating accepting zeroconf txs on mainnet, over the next 6, 12 or\n> 18 months; or (b) to start switching mainnet mining and relay nodes over\n> to full RBF?\n\nFor what it's worth, that was a serious question: I don't feel like I\nknow what other people's answer to it is.\n\nSeems to me like there's fundamentally maybe three approaches:\n\n 1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n    payments indefinitely\n\n 2) Draw a line in the sand now, but give people who are currently\n    accepting unconfirmed txs time to update their software and business\n    model\n\n 3) Encourage mainnet miners and relay nodes to support unconditional\n    RBF immediately, no matter how much that increases the risk to\n    existing businesses that are still accepting unconfirmed txs\n\nI think Antoine gave a pretty decent rationale for why we shouldn't\nindefinitely continue with conditional RBF in [0] [1] -- it makes it\neasy to disrupt decentralised pooling protocols, whether that be for\nestablishing lightning channels or coinjoins or anything else.\n\n[0] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n\nIt's also an unstable equilibrium -- if everyone does first-seen-is-final\nat the mempool level, everything is fine; but it only takes a few\ndefectors to start relaying and mining full RBF txs to spoil zeroconf\nfor everyone -- so even if it were desirable to maintain it forever,\nit's probably not actually possible to maintain it indefinitely.\n\nIf so, that leaves the choice between (2) and (3). You might argue\nthat there's a 4th option: ignore the problem and think about it later;\nbut to me that seems like it will just eventually result in outcome (3).\n\n\nAt least a few people are already running full RBF relay nodes [2] [3]\n[4], and there's a report that non-signalling RBF txs are now getting\nmined [5] when they weren't a few months ago [6]. I wasn't able to\nconfirm the latter to my satisfaction: looking at mempool.observer, the\nnon-RBF signalling conflicting txs don't seem to have been consistently\npaying a higher feerate, so I couldn't rule out the possibility that\nthe difference might just be due to inconsistent relaying.\n\n[2] https://twitter.com/murchandamus/status/1552488955328831492\n[3] https://twitter.com/LukeDashjr/status/977211607947317254\n[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n[5] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n[6] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n\nIt seems to me that the best approach for implementing (3) would be\nto change the default for -mempoolfullrbf to true immediately, which\nis both what Knots has been doing for years, and what #26305 proposes\n[7].  So from seeing what people are actually *doing*, I could easily\nbe convinced that (3) is the goal people are actually working towards.\n\n[7] https://github.com/bitcoin/bitcoin/pull/26305\n\nBut if (3) *is* what we're really trying to do, I think it's a bit\ndisingenuous to assume that that effort will fail, and tell people that\nnothing's going to change on mainnet in the near future [8] [9] [10]\n[11]. If pools are starting to allow replacements of txs that didn't\nsignal according to BIP 125 and mine blocks including those replacements,\nthen it's true that zero-conf apps are in much more immediate danger\nthan they were a month ago, and as far as I can see, we shouldn't be\npretending otherwise.\n\n[8] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n[9] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1276682043\n[10] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/020981.html\n[11] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021006.html\n\nPersonally, I prefer an approach like (2) -- commit to doing something\nfirst, give people time to prepare for it, and then do it, and outside\nof Knots, I don't think there's been any clear commitment to deprecating\nzeroconf txs up until now. But what we're currently doing is suboptimal\nfor that in two ways:\n\n - there's no real commitment that the change will actually happen\n - even if it does, there's no indication when that will be\n - it's not easy to test your apps against the new world order, because\n   it's not well supported on either testnet or signet, being disabled\n   by default on both those networks\n\nDario suggested an approach [12] that seems like it would resolve all\nthese issues:\n\n] This could be one such proposal:\n] 1. We activate [..] full-RBF on testnet now.\n] 2. We commit now (in the code) to a block height in the future at\n]    which [..] full-RBF will activate on mainnet.\n\n(I've delted the words \"opt-in\" and \"opt-out\" from the quote above,\nbecause they didn't make sense to me)\n\n[12] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021007.html\n\nI've made up a patch along these lines [13]; it's easy to use a timestamp\nrather than a block height, so I've arbitrarily picked 1st May (slightly\nover 6 months away) as the changeover time. If people are willing to\ngive zeroconf businesses some time to adapt, including something along\nthose lines in 24.0 seems a better approach to me:\n\n * it gives a clear deadline for businesses to adapt, so that they don't\n   defer it and suddenly complain \"oh no, we didn't think you were\n   serious, please give us more time\" later\n\n * it gives plenty(?) of time to update your code and test it, as well\n   as teach customers and customer support about the new behaviour\n\n * when the deadline hits, presumably plenty of nodes and miners will\n   immediately start supporting the new behaviour on mainnet, so that\n   protocols can quickly start relying on that method of tx pinning no\n   longer being applicable\n\n * nodes on signet and testnet will quickly adopt the new behaviour,\n   well before it's available on mainnet, making testing easier\n\n[13] https://github.com/bitcoin/bitcoin/pull/26323\n\nTo me, this seems like a good way of achieving what I said previously:\n\n> If we're trying to socialise the idea that zeroconf deprecation is\n> happening and that your business now has a real deadline for migrating\n> away from accepting unconfirmed txs if the risk of being defrauded\n> concerns you, then enabling experimentation on test nets and not touching\n> mainnet until a later release seems fairly fine to me -- similar to\n> activating soft forks on test nets prior to activating it on mainnet.\n\nCheers,\naj"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-17T14:25:33",
                "message_text_only": "AJ,\n\nThanks for the latest PR and discussion, even if we know we're all (very,\nvery, very) tired of it running almost 10 years now. I think we're close to\na resolution, (2), or (3) as you note.\n\nAs ariard notes in\nhttps://github.com/bitcoin/bitcoin/pull/26323#issuecomment-1280071572 we\nseem to have sketched out the sane design space for the transition, so now\nit's time to choose how we want to spend our energy and time on this.\n\nI do think patch complexity is a real concern, which\nmeans fullrbf-signalling PR has a harder road to deployment and gets push\nback from fullrbf-default-now folks who correctly argue this. It seems\nuseful to \"prove a point\" on the nature of these schemes, but not much else.\n\nPersonally I have no qualms with kicking back flag-day-fullrbf another\nrelease cycle and 6 additional months to obviate the need for a 24.0\nbackport(however small!) and to give a bit more time to weigh choices.\nPeople can begin testing with their node software on an opt-in basis(but\nnot the required ~10% of nodes), 25.0+ nodes will flag-day, then a year\nfrom now the community can start testing if miners have picked up said\nchanges.\n\nSpeaking to no one in particular, there's no virtue in dragging on the\ndiscussion to \"prove a point\" to \"merchants\"/\"Core devs\" when we could be\nspending our time more wisely fixing the many other issues with our mempool\nand wallet ecosystem.\n\nBest,\nGreg\n\nOn Sun, Oct 16, 2022 at 4:09 AM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Oct 13, 2022 at 02:35:22PM +1000, Anthony Towns via bitcoin-dev\n> wrote:\n> > On Wed, Oct 12, 2022 at 04:11:05PM +0000, Pieter Wuille via bitcoin-dev\n> wrote:\n> > > In my view, it is just what I said: a step towards getting full RBF\n> > > on the network, by allowing experimentation and socializing the notion\n> > > that developers believe it is time.\n> > We \"believe it is time\" for what exactly, though? (a) To start\n> > deprerecating accepting zeroconf txs on mainnet, over the next 6, 12 or\n> > 18 months; or (b) to start switching mainnet mining and relay nodes over\n> > to full RBF?\n>\n> For what it's worth, that was a serious question: I don't feel like I\n> know what other people's answer to it is.\n>\n> Seems to me like there's fundamentally maybe three approaches:\n>\n>  1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n>     payments indefinitely\n>\n>  2) Draw a line in the sand now, but give people who are currently\n>     accepting unconfirmed txs time to update their software and business\n>     model\n>\n>  3) Encourage mainnet miners and relay nodes to support unconditional\n>     RBF immediately, no matter how much that increases the risk to\n>     existing businesses that are still accepting unconfirmed txs\n>\n> I think Antoine gave a pretty decent rationale for why we shouldn't\n> indefinitely continue with conditional RBF in [0] [1] -- it makes it\n> easy to disrupt decentralised pooling protocols, whether that be for\n> establishing lightning channels or coinjoins or anything else.\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n>\n> It's also an unstable equilibrium -- if everyone does first-seen-is-final\n> at the mempool level, everything is fine; but it only takes a few\n> defectors to start relaying and mining full RBF txs to spoil zeroconf\n> for everyone -- so even if it were desirable to maintain it forever,\n> it's probably not actually possible to maintain it indefinitely.\n>\n> If so, that leaves the choice between (2) and (3). You might argue\n> that there's a 4th option: ignore the problem and think about it later;\n> but to me that seems like it will just eventually result in outcome (3).\n>\n>\n> At least a few people are already running full RBF relay nodes [2] [3]\n> [4], and there's a report that non-signalling RBF txs are now getting\n> mined [5] when they weren't a few months ago [6]. I wasn't able to\n> confirm the latter to my satisfaction: looking at mempool.observer, the\n> non-RBF signalling conflicting txs don't seem to have been consistently\n> paying a higher feerate, so I couldn't rule out the possibility that\n> the difference might just be due to inconsistent relaying.\n>\n> [2] https://twitter.com/murchandamus/status/1552488955328831492\n> [3] https://twitter.com/LukeDashjr/status/977211607947317254\n> [4]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n> [5]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n> [6]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n>\n> It seems to me that the best approach for implementing (3) would be\n> to change the default for -mempoolfullrbf to true immediately, which\n> is both what Knots has been doing for years, and what #26305 proposes\n> [7].  So from seeing what people are actually *doing*, I could easily\n> be convinced that (3) is the goal people are actually working towards.\n>\n> [7] https://github.com/bitcoin/bitcoin/pull/26305\n>\n> But if (3) *is* what we're really trying to do, I think it's a bit\n> disingenuous to assume that that effort will fail, and tell people that\n> nothing's going to change on mainnet in the near future [8] [9] [10]\n> [11]. If pools are starting to allow replacements of txs that didn't\n> signal according to BIP 125 and mine blocks including those replacements,\n> then it's true that zero-conf apps are in much more immediate danger\n> than they were a month ago, and as far as I can see, we shouldn't be\n> pretending otherwise.\n>\n> [8] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n> [9] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1276682043\n> [10]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/020981.html\n> [11]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021006.html\n>\n> Personally, I prefer an approach like (2) -- commit to doing something\n> first, give people time to prepare for it, and then do it, and outside\n> of Knots, I don't think there's been any clear commitment to deprecating\n> zeroconf txs up until now. But what we're currently doing is suboptimal\n> for that in two ways:\n>\n>  - there's no real commitment that the change will actually happen\n>  - even if it does, there's no indication when that will be\n>  - it's not easy to test your apps against the new world order, because\n>    it's not well supported on either testnet or signet, being disabled\n>    by default on both those networks\n>\n> Dario suggested an approach [12] that seems like it would resolve all\n> these issues:\n>\n> ] This could be one such proposal:\n> ] 1. We activate [..] full-RBF on testnet now.\n> ] 2. We commit now (in the code) to a block height in the future at\n> ]    which [..] full-RBF will activate on mainnet.\n>\n> (I've delted the words \"opt-in\" and \"opt-out\" from the quote above,\n> because they didn't make sense to me)\n>\n> [12]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021007.html\n>\n> I've made up a patch along these lines [13]; it's easy to use a timestamp\n> rather than a block height, so I've arbitrarily picked 1st May (slightly\n> over 6 months away) as the changeover time. If people are willing to\n> give zeroconf businesses some time to adapt, including something along\n> those lines in 24.0 seems a better approach to me:\n>\n>  * it gives a clear deadline for businesses to adapt, so that they don't\n>    defer it and suddenly complain \"oh no, we didn't think you were\n>    serious, please give us more time\" later\n>\n>  * it gives plenty(?) of time to update your code and test it, as well\n>    as teach customers and customer support about the new behaviour\n>\n>  * when the deadline hits, presumably plenty of nodes and miners will\n>    immediately start supporting the new behaviour on mainnet, so that\n>    protocols can quickly start relying on that method of tx pinning no\n>    longer being applicable\n>\n>  * nodes on signet and testnet will quickly adopt the new behaviour,\n>    well before it's available on mainnet, making testing easier\n>\n> [13] https://github.com/bitcoin/bitcoin/pull/26323\n>\n> To me, this seems like a good way of achieving what I said previously:\n>\n> > If we're trying to socialise the idea that zeroconf deprecation is\n> > happening and that your business now has a real deadline for migrating\n> > away from accepting unconfirmed txs if the risk of being defrauded\n> > concerns you, then enabling experimentation on test nets and not touching\n> > mainnet until a later release seems fairly fine to me -- similar to\n> > activating soft forks on test nets prior to activating it on mainnet.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/b9415d4b/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-17T21:41:48",
                "message_text_only": "Hi AJ,\n\n>  1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n>     payments indefinitely\n>\n>  2) Draw a line in the sand now, but give people who are currently\n>     accepting unconfirmed txs time to update their software and business\n>     model\n>\n>  3) Encourage mainnet miners and relay nodes to support unconditional\n>     RBF immediately, no matter how much that increases the risk to\n>     existing businesses that are still accepting unconfirmed txs\n\nTo give more context, the initial approach of enabling full RBF through\n#25353 + #25600 wasn't making the assumption the enablement itself would\nreach agreement of the economic majority or unanimity. Rather, it would\ngive the tools to node operators to build full-rbf relay paths and as such\nto fulfill their applications requirements (e.g lightning dual-funding).\nWithout denying that such equilibrium would be unstable, it was designed to\nremove the responsibility of the Core project itself to \"draw a hard line\"\non the subject. Moreover, relying on node operators turning on the setting\nprovides a smoother approach offering time to zero-conf services to react\nin consequence.\n\nSo the current path definitely belongs more to a 3) approach. While this\nway cannot be denied to be a zero-risk deployment for business accepting\nunconfirmed transactions, it should be weighed in face of multi-party\ncontracting protocols encumbering an annoying pinning vector. It sounds to\nme that an adequate way to resolve such a \"split-risk\" situation has been\nto adopt a \"micro\" release practice rather than a \"macro\" one, namely offer\nthe options to node operators and let them vote with their respective\neconomic traffics.\n\nSince Dario's mail, I think we have learnt new data points, a) on the long\nterm full RBF to align miner incentives is acknowledged and b) a clear\ntimeline based on e.g a block height is favored over the pollination\ndeployment.\n\nAs such, I think it makes sense to revise the full RBF deployment approach,\nconcentrating the discussion on the reasonable time buffer we should adopt\nbefore activating full RBF on mainet. A time buffer realistic with respect\nto the engineering,\noperational and vendoring needs of the zero-conf businesses/applications. I\nhope both #26305 and #26323 answer those criterias. Tie-breaking between\nboth, I believe I would favor something like #26323 though only post 24.0\nto avoid introducing a bikeshedding precedent in terms of release process,\nand with a longer timeline to be sure we ship 25.0 before the activation\nday. Though listening to more feedback and decision factors, if we have\nmore things to consider.\n\n> But if (3) *is* what we're really trying to do, I think it's a bit\n> disingenuous to assume that that effort will fail, and tell people that\n> nothing's going to change on mainnet in the near future [8] [9] [10]\n> [11]. If pools are starting to allow replacements of txs that didn't\n> signal according to BIP 125 and mine blocks including those replacements,\n> then it's true that zero-conf apps are in much more immediate danger\n> than they were a month ago, and as far as I can see, we shouldn't be\n> pretending otherwise.\n\nConcerning my statement only, it should be re-contextualize with the other\nstatements calling the zero-conf operators to adapt their services, or\nraise concerns, or be proactive at least [0]. On the other hand, from my\nperspective, a status quo situation is also unsafe, as we left things like\nmulti-party coinjoins being DoSed by deanonymizing attackers. So in case of\nrisk arbitrage situation, as developers, best we can do is be vocal about\nit and if possible find a common ground among all stakeholders. And I think\nthis is what this current thread aims to achieve, which I would say is a\nhealthy release process.\n\nBest,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n\nLe dim. 16 oct. 2022 \u00e0 04:09, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> On Thu, Oct 13, 2022 at 02:35:22PM +1000, Anthony Towns via bitcoin-dev\n> wrote:\n> > On Wed, Oct 12, 2022 at 04:11:05PM +0000, Pieter Wuille via bitcoin-dev\n> wrote:\n> > > In my view, it is just what I said: a step towards getting full RBF\n> > > on the network, by allowing experimentation and socializing the notion\n> > > that developers believe it is time.\n> > We \"believe it is time\" for what exactly, though? (a) To start\n> > deprerecating accepting zeroconf txs on mainnet, over the next 6, 12 or\n> > 18 months; or (b) to start switching mainnet mining and relay nodes over\n> > to full RBF?\n>\n> For what it's worth, that was a serious question: I don't feel like I\n> know what other people's answer to it is.\n>\n> Seems to me like there's fundamentally maybe three approaches:\n>\n>  1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n>     payments indefinitely\n>\n>  2) Draw a line in the sand now, but give people who are currently\n>     accepting unconfirmed txs time to update their software and business\n>     model\n>\n>  3) Encourage mainnet miners and relay nodes to support unconditional\n>     RBF immediately, no matter how much that increases the risk to\n>     existing businesses that are still accepting unconfirmed txs\n>\n> I think Antoine gave a pretty decent rationale for why we shouldn't\n> indefinitely continue with conditional RBF in [0] [1] -- it makes it\n> easy to disrupt decentralised pooling protocols, whether that be for\n> establishing lightning channels or coinjoins or anything else.\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n>\n> It's also an unstable equilibrium -- if everyone does first-seen-is-final\n> at the mempool level, everything is fine; but it only takes a few\n> defectors to start relaying and mining full RBF txs to spoil zeroconf\n> for everyone -- so even if it were desirable to maintain it forever,\n> it's probably not actually possible to maintain it indefinitely.\n>\n> If so, that leaves the choice between (2) and (3). You might argue\n> that there's a 4th option: ignore the problem and think about it later;\n> but to me that seems like it will just eventually result in outcome (3).\n>\n>\n> At least a few people are already running full RBF relay nodes [2] [3]\n> [4], and there's a report that non-signalling RBF txs are now getting\n> mined [5] when they weren't a few months ago [6]. I wasn't able to\n> confirm the latter to my satisfaction: looking at mempool.observer, the\n> non-RBF signalling conflicting txs don't seem to have been consistently\n> paying a higher feerate, so I couldn't rule out the possibility that\n> the difference might just be due to inconsistent relaying.\n>\n> [2] https://twitter.com/murchandamus/status/1552488955328831492\n> [3] https://twitter.com/LukeDashjr/status/977211607947317254\n> [4]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n> [5]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n> [6]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020592.html\n>\n> It seems to me that the best approach for implementing (3) would be\n> to change the default for -mempoolfullrbf to true immediately, which\n> is both what Knots has been doing for years, and what #26305 proposes\n> [7].  So from seeing what people are actually *doing*, I could easily\n> be convinced that (3) is the goal people are actually working towards.\n>\n> [7] https://github.com/bitcoin/bitcoin/pull/26305\n>\n> But if (3) *is* what we're really trying to do, I think it's a bit\n> disingenuous to assume that that effort will fail, and tell people that\n> nothing's going to change on mainnet in the near future [8] [9] [10]\n> [11]. If pools are starting to allow replacements of txs that didn't\n> signal according to BIP 125 and mine blocks including those replacements,\n> then it's true that zero-conf apps are in much more immediate danger\n> than they were a month ago, and as far as I can see, we shouldn't be\n> pretending otherwise.\n>\n> [8] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n> [9] https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1276682043\n> [10]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/020981.html\n> [11]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021006.html\n>\n> Personally, I prefer an approach like (2) -- commit to doing something\n> first, give people time to prepare for it, and then do it, and outside\n> of Knots, I don't think there's been any clear commitment to deprecating\n> zeroconf txs up until now. But what we're currently doing is suboptimal\n> for that in two ways:\n>\n>  - there's no real commitment that the change will actually happen\n>  - even if it does, there's no indication when that will be\n>  - it's not easy to test your apps against the new world order, because\n>    it's not well supported on either testnet or signet, being disabled\n>    by default on both those networks\n>\n> Dario suggested an approach [12] that seems like it would resolve all\n> these issues:\n>\n> ] This could be one such proposal:\n> ] 1. We activate [..] full-RBF on testnet now.\n> ] 2. We commit now (in the code) to a block height in the future at\n> ]    which [..] full-RBF will activate on mainnet.\n>\n> (I've delted the words \"opt-in\" and \"opt-out\" from the quote above,\n> because they didn't make sense to me)\n>\n> [12]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021007.html\n>\n> I've made up a patch along these lines [13]; it's easy to use a timestamp\n> rather than a block height, so I've arbitrarily picked 1st May (slightly\n> over 6 months away) as the changeover time. If people are willing to\n> give zeroconf businesses some time to adapt, including something along\n> those lines in 24.0 seems a better approach to me:\n>\n>  * it gives a clear deadline for businesses to adapt, so that they don't\n>    defer it and suddenly complain \"oh no, we didn't think you were\n>    serious, please give us more time\" later\n>\n>  * it gives plenty(?) of time to update your code and test it, as well\n>    as teach customers and customer support about the new behaviour\n>\n>  * when the deadline hits, presumably plenty of nodes and miners will\n>    immediately start supporting the new behaviour on mainnet, so that\n>    protocols can quickly start relying on that method of tx pinning no\n>    longer being applicable\n>\n>  * nodes on signet and testnet will quickly adopt the new behaviour,\n>    well before it's available on mainnet, making testing easier\n>\n> [13] https://github.com/bitcoin/bitcoin/pull/26323\n>\n> To me, this seems like a good way of achieving what I said previously:\n>\n> > If we're trying to socialise the idea that zeroconf deprecation is\n> > happening and that your business now has a real deadline for migrating\n> > away from accepting unconfirmed txs if the risk of being defrauded\n> > concerns you, then enabling experimentation on test nets and not touching\n> > mainnet until a later release seems fairly fine to me -- similar to\n> > activating soft forks on test nets prior to activating it on mainnet.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/1123fc5d/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-18T07:00:45",
                "message_text_only": "On Mon, Oct 17, 2022 at 05:41:48PM -0400, Antoine Riard via bitcoin-dev wrote:\n> >  1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n> >     payments indefinitely\n> >  2) Draw a line in the sand now, but give people who are currently\n> >     accepting unconfirmed txs time to update their software and business\n> >     model\n> >  3) Encourage mainnet miners and relay nodes to support unconditional\n> >     RBF immediately, no matter how much that increases the risk to\n> >     existing businesses that are still accepting unconfirmed txs\n> To give more context, the initial approach of enabling full RBF through\n> #25353 + #25600 wasn't making the assumption the enablement itself would\n> reach agreement of the economic majority or unanimity. \n\nFull RBF doesn't need a majority or unanimity to have an impact; it needs\nadoption by perhaps 10% of hashrate (so a low fee tx at the bottom of\na 10MvB mempool can be replaced before being mined naturally), and some\nway of finding a working path to relay txs to that hashrate.\n\nHaving a majority of nodes/hashrate support it makes the upsides better,\nbut doesn't change the downsides to the people who are relying on it\nnot being available.\n\n> Without denying that such equilibrium would be unstable, it was designed to\n> remove the responsibility of the Core project itself to \"draw a hard line\"\n> on the subject.\n\nRemoving responsibility from core developers seems like it's very much\noptimising for the wrong thing to me.\n\nI mean, I guess I can understand wanting to reduce that responsibility\nfor maintainers of the github repo, even if for no other reason than to\navoid frivolous lawsuits, but where do you expect people to find better\nadvice about what things are a good/bad idea if core devs as a whole\nare avoiding that responsibility?\n\nCore devs are supposedly top technical experts at bitcoin -- which means\nthey're the ones that should have the best understanding of all the\nimplications of policy changes like this. Is opt-in RBF only fine? If\nyou look at the network today, it sure seems like it; it takes a pretty\ngood technical understanding to figure out what problems it has, and\nan even better one to figure out whether those problems can be solved\nwhile keeping an opt-in RBF regime, or if full RBF is needed.\n\nAt that point, the technical experts *should* be coming up with a\nspecific recommendation, and, personally, I think that's exactly what\nhappened with [0] [1] and [2].\n\n[0] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n[1] https://github.com/bitcoin/bitcoin/pull/25353\n[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n\nThat did draw hard line in the sand: it said \"hey, opt-in RBF had a good\nrun, but it's time to switch over to full RBF, for these reasons\".\n\nIt's a bit disappointing that the people that's a problem for didn't\nengage earlier -- though looking back, I guess there wasn't all that\nmuch effort made to reach out, either. There were two mentions in the\noptech newsletter [3] [4] but it wasn't called out as an \"action item\"\n(maybe those aren't a thing anymore), so it may have been pretty missable,\nespecially given RBF has been discussed on and off for so long. And the\nimpression I got from the PR review club discussion more seemed like\ndevs making assumptions about businesses rather than having talked to\nthem (eg \"[I] think there are fewer and fewer businesses who absolutely\ncannot survive without relying on zeroconf. Or at least hope so\").\n\n[3] https://bitcoinops.org/en/newsletters/2022/06/22/\n[4] https://bitcoinops.org/en/newsletters/2022/07/13/\n\nIf we're happy to not get feedback until we start doing rcs, that's fine;\nbut if we want to say \"oops, we're into release candidates, you should\nhave something earlier, it's too late now\", that's a pretty closed-off\nway of doing things.\n\nAnd I mean: all this is only about drawing a line in *sand*; if people\nthink core devs are wrong, they can still let that line blow away in\nthe wind, by running different software, configuring core differently,\npatching core, or whatever else.\n\n> Moreover, relying on node operators turning on the setting\n> provides a smoother approach offering time to zero-conf services to react\n> in consequence.\n\nI don't think that's remotely true: take a look at taproot activation:\nit took two months between releasing code that supported signalling and\nhaving 98% of hashrate signalling; with 40% of blocks signalling within\nthe first two weeks.\n\n> So the current path definitely belongs more to a 3) approach.\n\n> >  3) Encourage mainnet miners and relay nodes to support unconditional\n> >     RBF immediately, no matter how much that increases the risk to\n> >     existing businesses that are still accepting unconfirmed txs\n\nYes, that's how it appears to me, too. It's not my preference (giving\npeople clear warning of changes seems much better to me), but I can\ncertainly live with it.\n\nBut if the line in the sand is \"we're doing this, no matter how much that\nincreases the risk to existing businesses that weren't expecting it\" then\nit seems *very* disingenuous not to make those risks very clear so that\npeople who weren't expecting it actually take action to avoid those risks.\n\nThat is, it seems to me that Dario was exactly right in titling this\nthread \"Zero-conf apps in immediate danger\", and our co-developers who\nare dismissing the risk by saying things along the lines of \"probably\nnothing will change anytime soon\" are exactly wrong.\n\n(More generally, that's similar to one of the things I've hated\nwatching in mainstream economics over the past few years: \"doing this\nwill cause massive inflation\" \"no it won't, there's no inflation risk\"\n\"oops, inflation magically appeared, how did that happen? oh well, too\nbad, we have to live with it now\". This looks pretty similar to me: \"do\nsomething risky, deny the risk, make sure nobody can hold us accountable\nwhen the risk eventuates later\" so it makes me really uncomfortable)\n\n> While this\n> way cannot be denied to be a zero-risk deployment for business accepting\n> unconfirmed transactions, it should be weighed in face of multi-party\n> contracting protocols encumbering an annoying pinning vector.\n\nSure; that's a fine reason to draw the line in the sand. But it's not\na good reason to have it happen immediately, rather than giving people\ntime to react, and it's not a good reason to understate the risk of\nit happening now. Maybe there are good reasons for either or both of\nthose, though?\n\n> Since Dario's mail, I think we have learnt new data points, a) on the long\n> term full RBF to align miner incentives is acknowledged and b) a clear\n> timeline based on e.g a block height is favored over the pollination\n> deployment.\n\nUsing the passive voice there doesn't seem helpful. Who learnt these\nthings? You, I and Dario all seem to agree with (a), but John Carvalho\ncertainly appears not to, for instance. I'm not sure who agrees with\n(b) -- I know I do, and I think Dario does; but multiple people seem\nopposed to the clear timeline offered in #26323, and your #26305 seems\nmore likely to encourage a \"pollination\" approach rather than discourage\nit (\"oh, this will be the default option for 25.0, might as well enable\nit now like all the cool kids are\").\n\nFor what it's worth, my guess is that releasing core with full rbf\nsupport and having you and Murch and others advocating for people to\ntry it out, will mean that full RBF is usable on mainnet within two\nor three months, supported by perhaps 5%-20% hashpower, but probably\nstill requiring special effort to actually find a peer that can relay\nfull rbf txs to that hashpower (probably doing an addnode, despite the\nprivacy implications). Even if that happens, I'm not super confident\nthat it would mean people would actively steal from zeroconf businesses\nin any volume, though. It's not something I'd risk happening to me,\nbut accepting zeroconf from strangers isn't something I'd risk anyway.\n\nSlowing that down from January-ish to May seems like it ought to be a\nbig win for anyone who has been doing zeroconf, and having it be easy\nto find a path to miners when it is supported seems like a big win even\ngiven a cost of a few months delay.\n\nOTOH, if we're really not expecting full rbf to be available for many\nmonths, then I would have expected the \"disable this for mainnet,\nreconsider after the release\" PR (#26287) to have gone ahead already.\n\n> Tie-breaking between\n> both, I believe I would favor something like #26323 though only post 24.0\n> to avoid introducing a bikeshedding precedent in terms of release process,\n\nDoing something like #26323 only after 24.0 is out does nothing to\nmitigate whatever immediate risk there is to bitcoin businesses/users...\n\nAnd if the choice is between \"bikeshedding\" and \"merge a PR, then ignore\nfeedback that it's harmful\", I'd much rather the bikeshedding. What's\nthe point of having rcs if you're going to ignore negative feedback?\n\nI mean, if you think the feedback is wrong, that's different: maybe we\nshouldn't care that zeroconf apps are in immediate danger, and maybe\nbitcoin would be better if any that don't adapt immediately all die\nhorribly as a lesson to others not to make similarly bad assumptions.\n\nBut saying \"we don't want them to be in danger\" and also refusing to do\nanything to avoid it?\n\nCheers,\naj"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-19T03:01:12",
                "message_text_only": "> Full RBF doesn't need a majority or unanimity to have an impact; it needs\n> adoption by perhaps 10% of hashrate (so a low fee tx at the bottom of\n> a 10MvB mempool can be replaced before being mined naturally), and some\n> way of finding a working path to relay txs to that hashrate.\n\nYes, this has been the crux of the conceptual discussion in #25600.\n\n> I mean, I guess I can understand wanting to reduce that responsibility\n> for maintainers of the github repo, even if for no other reason than to\n> avoid frivolous lawsuits, but where do you expect people to find better\n> advice about what things are a good/bad idea if core devs as a whole\n> are avoiding that responsibility?\n>\n> Core devs are supposedly top technical experts at bitcoin -- which means\n> they're the ones that should have the best understanding of all the\n> implications of policy changes like this. Is opt-in RBF only fine? If\n> you look at the network today, it sure seems like it; it takes a pretty\n> good technical understanding to figure out what problems it has, and\n> an even better one to figure out whether those problems can be solved\n> while keeping an opt-in RBF regime, or if full RBF is needed.\n\nIn the present case, I don't think there is a real concern of a frivolous\nor half-baked lawsuit. My concern is rather the pretension to omniscience\nthat we would adopt as Core devs w.r.t policy changes, as far from being a\nmore closed, hermetic system like the p2p stack, it's interfacing with the\noperations of a number of Bitcoin applications and second-layer contracting\nprotocols. As of today, I think this is still a relatively short process to\nanalyze the implications of any policy changes on the major Bitcoin\napplications\nflows and L2s of the day (i.e mainly Lightning and coinjoins). I'm not sure\nthis statement will stay true in a future with a growing fauna of L2s (i.e\nvaults, DLC-over-channel, peerswaps, etc), each presenting unique\ncharacteristics.\n\nHow do we minimize the odds of policy-based disruptions for current Bitcoin\nsoftwares and users ? I don't have strong ideas, though I wish for the Core\nproject to adopt a more open-ended and smooth approach to release\ncontext-rich policy changes. I aimed with #25353 and #25600 to experiment\nwith such a smoother approach advocated for (rather than the last year\nproposal of turning on by default full-rbf, that was a wrong and missing\ncontext). I hope at least one good outcome of this gradual process has been\nto give time to Dario to publish a thoughtful standpoint for 0conf\noperators, of which at least I learnt a few interesting elements on the UX\nof such applications.\n\n> It's a bit disappointing that the people that's a problem for didn't\n> engage earlier -- though looking back, I guess there wasn't all that\n> much effort made to reach out, either. There were two mentions in the\n> optech newsletter [3] [4] but it wasn't called out as an \"action item\"\n> (maybe those aren't a thing anymore), so it may have been pretty missable,\n> especially given RBF has been discussed on and off for so long. And the\n> impression I got from the PR review club discussion more seemed like\n> devs making assumptions about businesses rather than having talked to\n> them (eg \"[I] think there are fewer and fewer businesses who absolutely\n> cannot survive without relying on zeroconf. Or at least hope so\").\n\nYeah, I'm still valuing the mailing list as a kind of \"broadcast-all\"\ncommunication channel towards all the community stakeholders, though this\nis the perspective of a developer and I'm not sure business/services\noperators have the same communication habits. There is definitely a\nreflection to hold, if we, as Core devs, we should follow a better\ncommunication standard when we propose significant policy changes. And go\nthe full-tour of Reddit AMA, podcasts and newsletters as suggested in my\nreply to Dario. It's hard to know if lack of vocal reactions on the mailing\nlist or to the publication of optech newsletter signifies a lack of\nopposition, a lack of negatively impacted users or lack of interest from\nthe wider community. Maybe we should have a formalized, bulletpoints -based\nfor future policy changes, with clear time buffers and actions items, I\ndon't know.\n\n> If we're happy to not get feedback until we start doing rcs, that's fine;\n> but if we want to say \"oops, we're into release candidates, you should\n> have something earlier, it's too late now\", that's a pretty closed-off\n> way of doing things.\n>\n> And I mean: all this is only about drawing a line in *sand*; if people\n> think core devs are wrong, they can still let that line blow away in\n> the wind, by running different software, configuring core differently,\n> patching core, or whatever else.\n\nIn the present case, it's more a lack of feedback showing up until we start\ndoing rcs, rather than a pretty closed-off way of doing things. That we\nshould amend expected and already-merged changes in the function of\nfeedback, I'm all for it in principle. The hard question is the set of\ndecision heuristics to converge on to qualify such feedback as worthy to\nreact on. Again in this case, we're doing some risk arbitrage (which I\nreally dislike as a situation) between 0conf applications and multi-party\nfunding flows of contracting protocols. Correcting our release process\nisn't free of implications as we're removing the risk burden on some class\nof use-case to pour it on a second class, in my opinion. Moreover, assuming\nwe have to bind to reasonable communication standards which is an open\nquestion, I'm also worried we would also normalize the publication of very\nlate feedback from community stakeholders.\n\n> I don't think that's remotely true: take a look at taproot activation:\n> it took two months between releasing code that supported signalling and\n> having 98% of hashrate signalling; with 40% of blocks signalling within\n> the first two weeks.\n\nFirst, without more visibility brought back on the 0confs operations\nnecessary to adapt their operations, two months might be considered as\nenough. 8 weeks is sensibly the release schedule followed by few\nopen-source projects in the ecosystem. Second, the communication machine\nbehind softforks activation sounds to be far more fine-tuned, or at least\ngather spontaneously community self-coordination than policy changes, and\nit would be reasonable to expect things to be slower with policy changes.\nHowever, I would agree you can have a quick adoption a day from another\nwith one single well-crafted meme buzzing on Twitter. Social phenomenas\ndon't offer the same degree of predictability than system engineering. How\nwe cope up with that, as core devs, I don't know.\n\n> But if the line in the sand is \"we're doing this, no matter how much that\n> increases the risk to existing businesses that weren't expecting it\" then\n> it seems *very* disingenuous not to make those risks very clear so that\n> people who weren't expecting it actually take action to avoid those risks.\n\nI'm not sure if it has been established clearly, though as I announced on\nIRC two weeks ago, Dario reached out to me offline before publishing his\nmail. My recommendation to him have been immediately to adjoin 0confs\nservices examples impacted, if possible with numbers on users affected and\nevaluation of engineering and operational effort if would request to adapt\ntheir use-cases, and inviting to publish on this venue, as business\noperators might not be used to with open-source process (I can disclose the\ncorrespondence if requested and with Dario approval).\n\nGoal was to collect the maximum of data points in our community\ndecision-making process about full-rbf. Now this doesn't relieve us of\nfinding a common ground on what should be a minimal bar to accept those\npoints, how to value those data\npoints, if we should take operators on their raw numbers or request the\npublication of \"light\" proofs like on-chain transactions, lightning\ninvoices (everyone in business would take the happy measure showing the\nmost active users possible). The question of what signals we should\ncollect, and how we process them is a hard question in a decentralized and\ntrust-minimized process like the Bitcoin development one, from my\nperspective. I don't have strong ideas there.\n\nThough speaking for myself, and not for other contributors, I've raised the\nwarnings about potential impacts of full-rbfs in both my June 2021 [0] and\nJune 2022 [1] mails, so I find the qualification of disingenuous is a bit\nungrounded. Overall, I would remind all that it's better to keep patience\nin face of complex changes in Core, rather than to fall quickly in a blame\nascription position.\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n\n(I don't deny \"blame-and-reward\" assignments can be worthy a posteriori,\nonce we're out of the \"hot\" discussion phase, especially to introspect on\nhow we can improve our engineering process, though in the middle of a\ndiscussion... I don't know, it sounds premature and noisy).\n\n> (More generally, that's similar to one of the things I've hated\n> watching in mainstream economics over the past few years: \"doing this\n> will cause massive inflation\" \"no it won't, there's no inflation risk\"\n> \"oops, inflation magically appeared, how did that happen? oh well, too\n> bad, we have to live with it now\". This looks pretty similar to me: \"do\n> something risky, deny the risk, make sure nobody can hold us accountable\n> when the risk eventuates later\" so it makes me really uncomfortable)\n\nI can share the sentiment about mainstream economics and the way\nrisk-management impacts large-range of human beings is completely shrug\non... Though again in the present case, I think it would be more productive\nto describe what engineering\nneeds or standards expectations of you are not fulfilled rather than to\nfallback on the pure expression of an uncomfortableness and how as a\ncommunity of contributors we could improve on that. Though to object,\nspeaking of risk appreciation, not hardening the funding phase of\nmulti-party funding protocols also lets the door open to DoS attacks by\ndeanonymizing attackers targeting things like coinjoin.\n\n> Sure; that's a fine reason to draw the line in the sand. But it's not\n> a good reason to have it happen immediately, rather than giving people\n> time to react, and it's not a good reason to understate the risk of\n> it happening now. Maybe there are good reasons for either or both of\n> those, though?\n\nI agree. I would like to observe that \"reasonable time to react\" and\n\"adequate risk statement\" is more an art than a science.\n\n> Using the passive voice there doesn't seem helpful. Who learnt these\n> things? You, I and Dario all seem to agree with (a), but John Carvalho\n> certainly appears not to, for instance. I'm not sure who agrees with\n> (b) -- I know I do, and I think Dario does; but multiple people seem\n> opposed to the clear timeline offered in #26323, and your #26305 seems\n> more likely to encourage a \"pollination\" approach rather than discourage\n> it (\"oh, this will be the default option for 25.0, might as well enable\n> it now like all the cool kids are\").\n\nAbout John Carvalho disagreeing about full-rbf, I think he voiced a concern\nduring the summer on one of the PR introducing a full-rbf setting and I did\ninvite to voice his concerns on the ML, invitation stayed without follow-up\nuntil the recent days [2] [3]. I would have loved to spend time back then\narguing on the full-rbf and miners incentives compatibility.\n\n[2] https://github.com/bitcoin/bitcoin/pull/25373#issuecomment-1163422654\n[3] https://github.com/bitcoin/bitcoin/pull/25373#issuecomment-1163815017\n\nI know we all have busy agendas and a short timeline to react to all the\nchanges happening in the Bitcoin ecosystem... I think I replied to John\nCarvalho answer on this thread, inviting him to develop his argumentation\nfurther and I'm staying available to discuss with any full-rbf opponents,\nin a calm and respectful fashion [4].\n\n[4]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021027.html\n\n> For what it's worth, my guess is that releasing core with full rbf\n> support and having you and Murch and others advocating for people to\n> try it out, will mean that full RBF is usable on mainnet within two\n> or three months, supported by perhaps 5%-20% hashpower, but probably\n> still requiring special effort to actually find a peer that can relay\n> full rbf txs to that hashpower (probably doing an addnode, despite the\n> privacy implications). Even if that happens, I'm not super confident\n> that it would mean people would actively steal from zeroconf businesses\n> in any volume, though. It's not something I'd risk happening to me,\n> but accepting zeroconf from strangers isn't something I'd risk anyway.\n\nYeah I mean this could have been a forward process before Dario published\nhis thoughts. Achieving 5%-20% hashpower and full-rbf relay paths would\nhave assumed landing #25600 _and_ actually reach out to few mining pools to\ninform them about the potential economic benefits. Now, I think the best\nprocess is to keep listening to more feedback from the community, lay out\nall the deployment options in code we have done and think more before\ncommitting to something.\n\n> And if the choice is between \"bikeshedding\" and \"merge a PR, then ignore\n> feedback that it's harmful\", I'd much rather the bikeshedding. What's\n> the point of having rcs if you're going to ignore negative feedback?\n\nI think this might be the point where I could say we're diverging. In\nprinciple, I agree we should listen to negative feedback raising harmful\ndisruptions risks for users and services. The more open, practical question\nto me is more how we collect, qualify and sanitize such negative feedback\nin a way which is acceptable for the community at large. Giving concrete\nbounds to the immediate dangers in a consensual way, and asserting this\ndanger results from a lack of communication of the Core project, I'm still\nwondering on those subjects. And note again, I didn't deny the option 3)\napproach as you laid out was zero-risk for 0conf operators.\n\nAll that said, if we think as a project we should offer a \"zero-risk\"\nprocess towards 0conf operators w.r.t full-rbf, at the detriment of the\nrisk encumbered by contracting protocols, I think it can be wise to\nresurrect #26287.\n\nBest,\nAntoine\n\nLe mar. 18 oct. 2022 \u00e0 03:00, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Mon, Oct 17, 2022 at 05:41:48PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > >  1) Continue supporting and encouraging accepting unconfirmed\n> \"on-chain\"\n> > >     payments indefinitely\n> > >  2) Draw a line in the sand now, but give people who are currently\n> > >     accepting unconfirmed txs time to update their software and\n> business\n> > >     model\n> > >  3) Encourage mainnet miners and relay nodes to support unconditional\n> > >     RBF immediately, no matter how much that increases the risk to\n> > >     existing businesses that are still accepting unconfirmed txs\n> > To give more context, the initial approach of enabling full RBF through\n> > #25353 + #25600 wasn't making the assumption the enablement itself would\n> > reach agreement of the economic majority or unanimity.\n>\n> Full RBF doesn't need a majority or unanimity to have an impact; it needs\n> adoption by perhaps 10% of hashrate (so a low fee tx at the bottom of\n> a 10MvB mempool can be replaced before being mined naturally), and some\n> way of finding a working path to relay txs to that hashrate.\n>\n> Having a majority of nodes/hashrate support it makes the upsides better,\n> but doesn't change the downsides to the people who are relying on it\n> not being available.\n>\n> > Without denying that such equilibrium would be unstable, it was designed\n> to\n> > remove the responsibility of the Core project itself to \"draw a hard\n> line\"\n> > on the subject.\n>\n> Removing responsibility from core developers seems like it's very much\n> optimising for the wrong thing to me.\n>\n> I mean, I guess I can understand wanting to reduce that responsibility\n> for maintainers of the github repo, even if for no other reason than to\n> avoid frivolous lawsuits, but where do you expect people to find better\n> advice about what things are a good/bad idea if core devs as a whole\n> are avoiding that responsibility?\n>\n> Core devs are supposedly top technical experts at bitcoin -- which means\n> they're the ones that should have the best understanding of all the\n> implications of policy changes like this. Is opt-in RBF only fine? If\n> you look at the network today, it sure seems like it; it takes a pretty\n> good technical understanding to figure out what problems it has, and\n> an even better one to figure out whether those problems can be solved\n> while keeping an opt-in RBF regime, or if full RBF is needed.\n>\n> At that point, the technical experts *should* be coming up with a\n> specific recommendation, and, personally, I think that's exactly what\n> happened with [0] [1] and [2].\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> [1] https://github.com/bitcoin/bitcoin/pull/25353\n> [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n>\n> That did draw hard line in the sand: it said \"hey, opt-in RBF had a good\n> run, but it's time to switch over to full RBF, for these reasons\".\n>\n> It's a bit disappointing that the people that's a problem for didn't\n> engage earlier -- though looking back, I guess there wasn't all that\n> much effort made to reach out, either. There were two mentions in the\n> optech newsletter [3] [4] but it wasn't called out as an \"action item\"\n> (maybe those aren't a thing anymore), so it may have been pretty missable,\n> especially given RBF has been discussed on and off for so long. And the\n> impression I got from the PR review club discussion more seemed like\n> devs making assumptions about businesses rather than having talked to\n> them (eg \"[I] think there are fewer and fewer businesses who absolutely\n> cannot survive without relying on zeroconf. Or at least hope so\").\n>\n> [3] https://bitcoinops.org/en/newsletters/2022/06/22/\n> [4] https://bitcoinops.org/en/newsletters/2022/07/13/\n>\n> If we're happy to not get feedback until we start doing rcs, that's fine;\n> but if we want to say \"oops, we're into release candidates, you should\n> have something earlier, it's too late now\", that's a pretty closed-off\n> way of doing things.\n>\n> And I mean: all this is only about drawing a line in *sand*; if people\n> think core devs are wrong, they can still let that line blow away in\n> the wind, by running different software, configuring core differently,\n> patching core, or whatever else.\n>\n> > Moreover, relying on node operators turning on the setting\n> > provides a smoother approach offering time to zero-conf services to react\n> > in consequence.\n>\n> I don't think that's remotely true: take a look at taproot activation:\n> it took two months between releasing code that supported signalling and\n> having 98% of hashrate signalling; with 40% of blocks signalling within\n> the first two weeks.\n>\n> > So the current path definitely belongs more to a 3) approach.\n>\n> > >  3) Encourage mainnet miners and relay nodes to support unconditional\n> > >     RBF immediately, no matter how much that increases the risk to\n> > >     existing businesses that are still accepting unconfirmed txs\n>\n> Yes, that's how it appears to me, too. It's not my preference (giving\n> people clear warning of changes seems much better to me), but I can\n> certainly live with it.\n>\n> But if the line in the sand is \"we're doing this, no matter how much that\n> increases the risk to existing businesses that weren't expecting it\" then\n> it seems *very* disingenuous not to make those risks very clear so that\n> people who weren't expecting it actually take action to avoid those risks.\n>\n> That is, it seems to me that Dario was exactly right in titling this\n> thread \"Zero-conf apps in immediate danger\", and our co-developers who\n> are dismissing the risk by saying things along the lines of \"probably\n> nothing will change anytime soon\" are exactly wrong.\n>\n> (More generally, that's similar to one of the things I've hated\n> watching in mainstream economics over the past few years: \"doing this\n> will cause massive inflation\" \"no it won't, there's no inflation risk\"\n> \"oops, inflation magically appeared, how did that happen? oh well, too\n> bad, we have to live with it now\". This looks pretty similar to me: \"do\n> something risky, deny the risk, make sure nobody can hold us accountable\n> when the risk eventuates later\" so it makes me really uncomfortable)\n>\n> > While this\n> > way cannot be denied to be a zero-risk deployment for business accepting\n> > unconfirmed transactions, it should be weighed in face of multi-party\n> > contracting protocols encumbering an annoying pinning vector.\n>\n> Sure; that's a fine reason to draw the line in the sand. But it's not\n> a good reason to have it happen immediately, rather than giving people\n> time to react, and it's not a good reason to understate the risk of\n> it happening now. Maybe there are good reasons for either or both of\n> those, though?\n>\n> > Since Dario's mail, I think we have learnt new data points, a) on the\n> long\n> > term full RBF to align miner incentives is acknowledged and b) a clear\n> > timeline based on e.g a block height is favored over the pollination\n> > deployment.\n>\n> Using the passive voice there doesn't seem helpful. Who learnt these\n> things? You, I and Dario all seem to agree with (a), but John Carvalho\n> certainly appears not to, for instance. I'm not sure who agrees with\n> (b) -- I know I do, and I think Dario does; but multiple people seem\n> opposed to the clear timeline offered in #26323, and your #26305 seems\n> more likely to encourage a \"pollination\" approach rather than discourage\n> it (\"oh, this will be the default option for 25.0, might as well enable\n> it now like all the cool kids are\").\n>\n> For what it's worth, my guess is that releasing core with full rbf\n> support and having you and Murch and others advocating for people to\n> try it out, will mean that full RBF is usable on mainnet within two\n> or three months, supported by perhaps 5%-20% hashpower, but probably\n> still requiring special effort to actually find a peer that can relay\n> full rbf txs to that hashpower (probably doing an addnode, despite the\n> privacy implications). Even if that happens, I'm not super confident\n> that it would mean people would actively steal from zeroconf businesses\n> in any volume, though. It's not something I'd risk happening to me,\n> but accepting zeroconf from strangers isn't something I'd risk anyway.\n>\n> Slowing that down from January-ish to May seems like it ought to be a\n> big win for anyone who has been doing zeroconf, and having it be easy\n> to find a path to miners when it is supported seems like a big win even\n> given a cost of a few months delay.\n>\n> OTOH, if we're really not expecting full rbf to be available for many\n> months, then I would have expected the \"disable this for mainnet,\n> reconsider after the release\" PR (#26287) to have gone ahead already.\n>\n> > Tie-breaking between\n> > both, I believe I would favor something like #26323 though only post 24.0\n> > to avoid introducing a bikeshedding precedent in terms of release\n> process,\n>\n> Doing something like #26323 only after 24.0 is out does nothing to\n> mitigate whatever immediate risk there is to bitcoin businesses/users...\n>\n> And if the choice is between \"bikeshedding\" and \"merge a PR, then ignore\n> feedback that it's harmful\", I'd much rather the bikeshedding. What's\n> the point of having rcs if you're going to ignore negative feedback?\n>\n> I mean, if you think the feedback is wrong, that's different: maybe we\n> shouldn't care that zeroconf apps are in immediate danger, and maybe\n> bitcoin would be better if any that don't adapt immediately all die\n> horribly as a lesson to others not to make similarly bad assumptions.\n>\n> But saying \"we don't want them to be in danger\" and also refusing to do\n> anything to avoid it?\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/f492c8c2/attachment-0001.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-19T03:17:51",
                "message_text_only": "Hi aj,\n\n> I mean, I guess I can understand wanting to reduce that responsibility\n> for maintainers of the github repo, even if for no other reason than to\n> avoid frivolous lawsuits, but where do you expect people to find better\n> advice about what things are a good/bad idea if core devs as a whole\n> are avoiding that responsibility?\n\nBitcoin Core contributors and maintainers should provide the options, recommendations etc. about mempool policies. If these policies are kept for users to change based on their needs, why force anything or change defaults ignoring feedback?\n\n> Core devs are supposedly top technical experts at bitcoin -- which means\n> they're the ones that should have the best understanding of all the\n> implications of policy changes like this.\n\nWhy even provide options for users to change RBF policy in that case? Option to disable was already [removed][1] ignoring NACKs and MarcoFalke prefers users try the [workaround][2] if there is ever a need to disable it. Are we going to remove all the options to switch RBF policies in future because fullrbf has been suggested by leading technical experts? Is there a possibility of experts going wrong and has it ever happened in past?\n\n> It's a bit disappointing that the people that's a problem for didn't\n> engage earlier -- though looking back, I guess there wasn't all that\n> much effort made to reach out, either.\n\nTo be fair, John Carvalho did [comment][3] about this in a pull request although it was wrong PR and never going to be merged.\n\n> And I mean: all this is only about drawing a line in sand; if people\n> think core devs are wrong, they can still let that line blow away in\n> the wind, by running different software, configuring core differently,\n> patching core, or whatever else.\n\nI think this is the best option for users at this point. Keep running older versions of Core and use Knots or other implementations until technical experts in core repository, other bitcoin projects and users are on the same page.\n\n> And the\n> impression I got from the PR review club discussion more seemed like\n> devs making assumptions about businesses rather than having talked to\n> them (eg \"[I] think there are fewer and fewer businesses who absolutely\n> cannot survive without relying on zeroconf. Or at least hope so\").\n\nEven I noticed this since I don't recall the developers of the 3 main coinjoin implementations that are claimed to be impacted by opt-in RBF making any remarks.\n\n[1]: https://github.com/bitcoin/bitcoin/pull/16171\n[2]: https://github.com/bitcoin/bitcoin/pull/25373#issuecomment-1157846575\n[3]: https://github.com/bitcoin/bitcoin/pull/25373#issuecomment-1163422654\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Tuesday, October 18th, 2022 at 12:30 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On Mon, Oct 17, 2022 at 05:41:48PM -0400, Antoine Riard via bitcoin-dev wrote:\n> \n> > > 1) Continue supporting and encouraging accepting unconfirmed \"on-chain\"\n> > > payments indefinitely\n> > > 2) Draw a line in the sand now, but give people who are currently\n> > > accepting unconfirmed txs time to update their software and business\n> > > model\n> > > 3) Encourage mainnet miners and relay nodes to support unconditional\n> > > RBF immediately, no matter how much that increases the risk to\n> > > existing businesses that are still accepting unconfirmed txs\n> > > To give more context, the initial approach of enabling full RBF through\n> > > #25353 + #25600 wasn't making the assumption the enablement itself would\n> > > reach agreement of the economic majority or unanimity.\n> \n> \n> Full RBF doesn't need a majority or unanimity to have an impact; it needs\n> adoption by perhaps 10% of hashrate (so a low fee tx at the bottom of\n> a 10MvB mempool can be replaced before being mined naturally), and some\n> way of finding a working path to relay txs to that hashrate.\n> \n> Having a majority of nodes/hashrate support it makes the upsides better,\n> but doesn't change the downsides to the people who are relying on it\n> not being available.\n> \n> > Without denying that such equilibrium would be unstable, it was designed to\n> > remove the responsibility of the Core project itself to \"draw a hard line\"\n> > on the subject.\n> \n> \n> Removing responsibility from core developers seems like it's very much\n> optimising for the wrong thing to me.\n> \n> I mean, I guess I can understand wanting to reduce that responsibility\n> for maintainers of the github repo, even if for no other reason than to\n> avoid frivolous lawsuits, but where do you expect people to find better\n> advice about what things are a good/bad idea if core devs as a whole\n> are avoiding that responsibility?\n> \n> Core devs are supposedly top technical experts at bitcoin -- which means\n> they're the ones that should have the best understanding of all the\n> implications of policy changes like this. Is opt-in RBF only fine? If\n> you look at the network today, it sure seems like it; it takes a pretty\n> good technical understanding to figure out what problems it has, and\n> an even better one to figure out whether those problems can be solved\n> while keeping an opt-in RBF regime, or if full RBF is needed.\n> \n> At that point, the technical experts should be coming up with a\n> specific recommendation, and, personally, I think that's exactly what\n> happened with [0] [1] and [2].\n> \n> [0] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> [1] https://github.com/bitcoin/bitcoin/pull/25353\n> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n> \n> That did draw hard line in the sand: it said \"hey, opt-in RBF had a good\n> run, but it's time to switch over to full RBF, for these reasons\".\n> \n> It's a bit disappointing that the people that's a problem for didn't\n> engage earlier -- though looking back, I guess there wasn't all that\n> much effort made to reach out, either. There were two mentions in the\n> optech newsletter [3] [4] but it wasn't called out as an \"action item\"\n> (maybe those aren't a thing anymore), so it may have been pretty missable,\n> especially given RBF has been discussed on and off for so long. And the\n> impression I got from the PR review club discussion more seemed like\n> devs making assumptions about businesses rather than having talked to\n> them (eg \"[I] think there are fewer and fewer businesses who absolutely\n> cannot survive without relying on zeroconf. Or at least hope so\").\n> \n> [3] https://bitcoinops.org/en/newsletters/2022/06/22/\n> [4] https://bitcoinops.org/en/newsletters/2022/07/13/\n> \n> If we're happy to not get feedback until we start doing rcs, that's fine;\n> but if we want to say \"oops, we're into release candidates, you should\n> have something earlier, it's too late now\", that's a pretty closed-off\n> way of doing things.\n> \n> And I mean: all this is only about drawing a line in sand; if people\n> think core devs are wrong, they can still let that line blow away in\n> the wind, by running different software, configuring core differently,\n> patching core, or whatever else.\n> \n> > Moreover, relying on node operators turning on the setting\n> > provides a smoother approach offering time to zero-conf services to react\n> > in consequence.\n> \n> \n> I don't think that's remotely true: take a look at taproot activation:\n> it took two months between releasing code that supported signalling and\n> having 98% of hashrate signalling; with 40% of blocks signalling within\n> the first two weeks.\n> \n> > So the current path definitely belongs more to a 3) approach.\n> \n> > > 3) Encourage mainnet miners and relay nodes to support unconditional\n> > > RBF immediately, no matter how much that increases the risk to\n> > > existing businesses that are still accepting unconfirmed txs\n> \n> \n> Yes, that's how it appears to me, too. It's not my preference (giving\n> people clear warning of changes seems much better to me), but I can\n> certainly live with it.\n> \n> But if the line in the sand is \"we're doing this, no matter how much that\n> increases the risk to existing businesses that weren't expecting it\" then\n> it seems very disingenuous not to make those risks very clear so that\n> people who weren't expecting it actually take action to avoid those risks.\n> \n> That is, it seems to me that Dario was exactly right in titling this\n> thread \"Zero-conf apps in immediate danger\", and our co-developers who\n> are dismissing the risk by saying things along the lines of \"probably\n> nothing will change anytime soon\" are exactly wrong.\n> \n> (More generally, that's similar to one of the things I've hated\n> watching in mainstream economics over the past few years: \"doing this\n> will cause massive inflation\" \"no it won't, there's no inflation risk\"\n> \"oops, inflation magically appeared, how did that happen? oh well, too\n> bad, we have to live with it now\". This looks pretty similar to me: \"do\n> something risky, deny the risk, make sure nobody can hold us accountable\n> when the risk eventuates later\" so it makes me really uncomfortable)\n> \n> > While this\n> > way cannot be denied to be a zero-risk deployment for business accepting\n> > unconfirmed transactions, it should be weighed in face of multi-party\n> > contracting protocols encumbering an annoying pinning vector.\n> \n> \n> Sure; that's a fine reason to draw the line in the sand. But it's not\n> a good reason to have it happen immediately, rather than giving people\n> time to react, and it's not a good reason to understate the risk of\n> it happening now. Maybe there are good reasons for either or both of\n> those, though?\n> \n> > Since Dario's mail, I think we have learnt new data points, a) on the long\n> > term full RBF to align miner incentives is acknowledged and b) a clear\n> > timeline based on e.g a block height is favored over the pollination\n> > deployment.\n> \n> \n> Using the passive voice there doesn't seem helpful. Who learnt these\n> things? You, I and Dario all seem to agree with (a), but John Carvalho\n> certainly appears not to, for instance. I'm not sure who agrees with\n> (b) -- I know I do, and I think Dario does; but multiple people seem\n> opposed to the clear timeline offered in #26323, and your #26305 seems\n> more likely to encourage a \"pollination\" approach rather than discourage\n> it (\"oh, this will be the default option for 25.0, might as well enable\n> it now like all the cool kids are\").\n> \n> For what it's worth, my guess is that releasing core with full rbf\n> support and having you and Murch and others advocating for people to\n> try it out, will mean that full RBF is usable on mainnet within two\n> or three months, supported by perhaps 5%-20% hashpower, but probably\n> still requiring special effort to actually find a peer that can relay\n> full rbf txs to that hashpower (probably doing an addnode, despite the\n> privacy implications). Even if that happens, I'm not super confident\n> that it would mean people would actively steal from zeroconf businesses\n> in any volume, though. It's not something I'd risk happening to me,\n> but accepting zeroconf from strangers isn't something I'd risk anyway.\n> \n> Slowing that down from January-ish to May seems like it ought to be a\n> big win for anyone who has been doing zeroconf, and having it be easy\n> to find a path to miners when it is supported seems like a big win even\n> given a cost of a few months delay.\n> \n> OTOH, if we're really not expecting full rbf to be available for many\n> months, then I would have expected the \"disable this for mainnet,\n> reconsider after the release\" PR (#26287) to have gone ahead already.\n> \n> > Tie-breaking between\n> > both, I believe I would favor something like #26323 though only post 24.0\n> > to avoid introducing a bikeshedding precedent in terms of release process,\n> \n> \n> Doing something like #26323 only after 24.0 is out does nothing to\n> mitigate whatever immediate risk there is to bitcoin businesses/users...\n> \n> And if the choice is between \"bikeshedding\" and \"merge a PR, then ignore\n> feedback that it's harmful\", I'd much rather the bikeshedding. What's\n> the point of having rcs if you're going to ignore negative feedback?\n> \n> I mean, if you think the feedback is wrong, that's different: maybe we\n> shouldn't care that zeroconf apps are in immediate danger, and maybe\n> bitcoin would be better if any that don't adapt immediately all die\n> horribly as a lesson to others not to make similarly bad assumptions.\n> \n> But saying \"we don't want them to be in danger\" and also refusing to do\n> anything to avoid it?\n> \n> Cheers,\n> aj\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T22:08:17",
                "message_text_only": "On Wed, Oct 19, 2022 at 03:17:51AM +0000, alicexbt via bitcoin-dev wrote:\n> > And the\n> > impression I got from the PR review club discussion more seemed like\n> > devs making assumptions about businesses rather than having talked to\n> > them (eg \"[I] think there are fewer and fewer businesses who absolutely\n> > cannot survive without relying on zeroconf. Or at least hope so\").\n> \n> Even I noticed this since I don't recall the developers of the 3 main coinjoin implementations that are claimed to be impacted by opt-in RBF making any remarks.\n\nFYI I personally asked Max Hillebrand from Wasabi about full-rbf last night.\nHe gave me permission to republish our conversation:\n\n    > Hey, I wanted to know if you had any comments on full-rbf re: wasabi?\n\n    Doesn't really affect us, afaik\n    The cj doesn't signal rbf right now\n    And I guess it's a DoS vector if any input double spent will be relayed after successful signing\n    But we have way bigger / cheaper DoS vectors that don't get \"exploited\"\n    So probably doesn't matter\n    Wasabi client handles replacements / reorgs gracefully, so should be alright\n    We don't yet \"use\" rbf in the sense of fee bumping tx, but we should / will eventually\n\nI haven't asked Joinmarket yet. But the impact on their implementation should\nbe very similar.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/f687b805/attachment-0001.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T23:18:16",
                "message_text_only": "On Tue, Oct 18, 2022 at 05:00:45PM +1000, Anthony Towns via bitcoin-dev wrote:\n> For what it's worth, my guess is that releasing core with full rbf\n> support and having you and Murch and others advocating for people to\n> try it out, will mean that full RBF is usable on mainnet within two\n> or three months, supported by perhaps 5%-20% hashpower, but probably\n> still requiring special effort to actually find a peer that can relay\n> full rbf txs to that hashpower (probably doing an addnode, despite the\n> privacy implications). Even if that happens, I'm not super confident\n> that it would mean people would actively steal from zeroconf businesses\n> in any volume, though. It's not something I'd risk happening to me,\n> but accepting zeroconf from strangers isn't something I'd risk anyway.\n\nFWIW I'm not aware of any zeroconf accepting businesses where exploiting double\nspends can be done without significant legal risk. Bitrefill has significant\nlegal risk, because pretty much everything you buy with Bitrefill can be traced\nto your real world identity. ATMs have less risk. But I haven't seen an ATM\nthat accepts BTC without a confirmation in many years. Nor have I found a\nnon-KYC/AML in-person currency exchange service that would accept funds without a\nconfirmation (yes, I've had to wait 30 mins to get my cash before!). And all\nthe anonymous crypto-exchange websites like FixedFloat require a confirmation.\n\nI have found AML/KYC in-person currency exchange services that would accept\nzero conf. But of course, they had sufficient details on me to just call the\npolice if I double-spent them.\n\nIn practice, there are very few people who are actually affected by zeroconf\ngoing away.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/3fd904e1/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2022-10-07T20:56:21",
                "message_text_only": "On Friday 07 October 2022 16:20:49 Dario Sneidermanis via bitcoin-dev wrote:\n> At the time, we understood we had at least a year from the initial opt-in\n> deployment until opt-out was deployed, giving us enough time to adapt Muun\n> to the new policies.\n\nPolicies are a per-node decision, and cannot be relied on in general.\nFull RBF has been the default in Bitcoin Knots for years, and de facto viable \nfor use on the network even longer.\n\n> However, when reviewing the 24.0 release candidate just \n> a few days ago, we realized that zero-conf apps (like Muun) must\n> *immediately turn off* their zero-conf features.\n\nRBF deals with UNconfirmed transactions, not zero-confirmed (Lightning).\n\n> I understand this wasn't the intention when designing the opt-in deployment\n> mechanism. Given this new information, do you see a path where we can delay\n> the opt-in deployment and find a safer way to deploy full-RBF?\n\nFull RBF has been available for users on an opt-in basis since at least 2013, \nlong before BIP 125 was even conceived of.\n\n> We call zero-conf applications to entities that accept on-chain payments\n> from\n> *untrusted parties* and will sometimes deliver the paid-for product or\n> service\n> without waiting for the transaction to be included in a block.\n\nThis is unsafe period. RBF does not make it any less unsafe.\n\n> All of these applications are receiving incoming on-chain transactions for\n> which\n> they don't control the inputs, and performing a risk analysis to decide\n> whether\n> they are ok with accepting the payment without confirmation.\n\nThis is nothing but a false sense of security.\n\nLuke"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-08T20:47:52",
                "message_text_only": "Hi Dario,\n\nThere aren't any risks with latest release of bitcoin core. However its not just munn or other things mentioned, even other bitcoin projects could be affected if [#25600][1] is merged.\n\nAnyway I cannot comment anymore, neither in the PR or repository. I tried my best. Peter Todd has ACKed it and it would affect his favorite coinjoin implementation that works with governments.\n\nReplacement policies are a per-node decision as Luke Dashjr said and projects should build upon it.\n\n[1]: https://github.com/bitcoin/bitcoin/pull/25600\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n\n------- Original Message -------\nOn Friday, October 7th, 2022 at 9:50 PM, Dario Sneidermanis via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello list,\n>\n> I'm Dario, from Muun wallet, a mobile non-custodial bitcoin wallet. For the past\n> few days we've been reviewing the latest bitcoin core release candidate, and we\n> found some troubling facts related to the opt-in full-RBF deployment.\n>\n> We first learned about the opt-in full-RBF proposal last June when it was\n> announced on the mailing list. Closing the gap between the protocol's relay\n> policies and the miner incentives is inevitable, so it was a welcomed addition.\n> Furthermore, allowing transaction replacements that remove the opt-in RBF flag\n> was deeply problematic.\n>\n> At the time, we understood we had at least a year from the initial opt-in\n> deployment until opt-out was deployed, giving us enough time to adapt Muun to\n> the new policies. However, when reviewing the 24.0 release candidate just a few\n> days ago, we realized that zero-conf apps (like Muun) must *immediately turn\n> off* their zero-conf features.\n>\n> I understand this wasn't the intention when designing the opt-in deployment\n> mechanism. Given this new information, do you see a path where we can delay the\n> opt-in deployment and find a safer way to deploy full-RBF?\n>\n> It'd be great for this deployment to be a success so that we can continue fixing\n> the remaining relay policy problems, such as package relay and the RBF rules.\n> Maybe we could go straight to an opt-out deployment locked by code at a certain\n> height in the future to give time to everyone and, at the same time, avoid a\n> huge mempool divergence event?\n>\n> Below is our analysis of how zero-conf apps break with opt-in full-RBF. I hope\n> it helps.\n>\n> Cheers,\n> Dario\n>\n> # How do zero-conf apps work\n>\n> While the workings and trade-offs of zero-conf applications might be known by\n> many in this list, it's useful to define precisely how they work to understand\n> how they break.\n>\n> We call zero-conf applications to entities that accept on-chain payments from\n> *untrusted parties* and will sometimes deliver the paid-for product or service\n> without waiting for the transaction to be included in a block.\n>\n> Some examples of zero-conf apps:\n>\n> - Muun's submarine swaps for outgoing lightning payments\n> - Bitrefill's on-chain payments for gift cards and phone top-ups\n> - Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at least\n> the two biggest bitcoin ATM manufacturers support this: Genesis Coin and\n> General Byte)\n>\n> All of these applications are receiving incoming on-chain transactions for which\n> they don't control the inputs, and performing a risk analysis to decide whether\n> they are ok with accepting the payment without confirmation.\n>\n> In practice, this works because once the bitcoin P2P network has fully\n> propagated a non-RBF transaction, you need the collaboration of a miner to\n> replace it, which isn't easy to get today. Even though many of the biggest\n> miners offer off-band transaction broadcasting services, they currently won't\n> process conflicting transactions.\n>\n> Roughly, the risk analysis goes like this:\n>\n> 1. if an incoming transaction is RBF (direct or inherited)\n> --> too risky, wait for 1 conf (or more) since it can be replaced at any time\n> 2. if the payment is for an amount greater than X\n> --> too risky, wait for 1 conf (or more), since the amount is worthy of a\n> sophisticated attacker\n> 3. wait for full(ish) propagation of the incoming transaction\n> 4. if there's no double-spend attempt\n> --> accept 0-conf\n>\n> As with any other risk analysis, there's always a false-negative detection rate,\n> leading to an expected loss, which the zero-conf app should be willing to bear.\n> Notice that the expected loss is tunable via the amount X in the above analysis.\n>\n> # Why are zero-conf apps not protected with an opt-in deployment\n>\n> Full-RBF adoption works on three different layers:\n>\n> - The transaction application layer\n> - The transaction relaying layer\n> - The transaction mining layer\n>\n> If an application wants to replace with full-RBF an *outgoing* transaction, it\n> will need:\n>\n> - An upgraded node that opted into full-RBF, from which it can broadcast the\n> replacement transaction\n> - A connected component of upgraded nodes that opted into full-RBF, that can\n> relay the replacement transaction\n> - A miner in that connected component with an upgraded node that opted into\n> full-RBF, that can mine the replacement transaction\n>\n> However, an application cannot control whether a replacement to an *incoming*\n> transaction is relayed via full-RBF. As soon as a single application can\n> generate replacements easily via full-RBF, all other applications have to assume\n> that any incoming transaction from an untrusted party might be replaced via\n> full-RBF. That is, for the application layer this is a forced upgrade.\n>\n> As soon as an unsophisticated attacker can use opt-in full-RBF, the risk\n> analysis performed by zero-conf applications stops working because the\n> transactions to analyze are all incoming transactions from untrusted parties.\n> Since some wallets already implement cancel functionality for opt-in RBF\n> transactions, enabling the same functionality for every transaction wouldn't\n> require much work, making canceling any unconfirmed transaction a one-click\n> experience. After this, the security model of zero-conf applications goes from\n> \"susceptible to attacks from miners\" to \"anyone can perform an attack, with an\n> easy-to-use interface\".\n>\n> That is, the opt-in deployment of full-RBF doesn't protect zero-conf\n> applications from having to turn off their zero-conf features very soon after\n> the initial deployment. All mitigations are mostly ineffective against\n> untrusted parties.\n>\n> # Other things we have to fix\n>\n> While it's clear how full-RBF breaks zero-conf applications, other more subtle\n> things break in *many* wallets (Muun included). If given the opportunity, we\n> would like to fix them before deployment. One could argue that these things\n> were already broken, but they get considerably worse as the network adopts\n> full-RBF (even with an opt-in deployment), so we should fix them.\n>\n> ## Mental model for unconfirmed incoming transactions\n>\n> Many wallets with support for on-chain payments (Muun included) show incoming\n> external transactions in some way to their users before they confirm. This is a\n> common practice because not showing them leads users to worry that their money\n> disappeared (exchanges doing this is the #1 issue we have to deal with in our\n> customer support channels).\n>\n> With full-RBF, wallets should make it extremely clear to users that unconfirmed\n> funds are not theirs (yet). Otherwise, protocol-unaware users that are\n> transacting on-chain with untrusted parties can be easily scammed if they don't\n> know they have to wait for a confirmation. Eg. in Argentina, it's pretty common\n> to meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n>\n> ## Block explorers as payment receipts\n>\n> Most wallets with support for on-chain payments (Muun included) use the\n> transaction view of a block explorer as a shareable payment receipt. The sender\n> of an on-chain transaction usually shares this link with the receiver to let\n> them know they made a payment. Protocol-unaware receivers sometimes take this\n> link as proof of payment.\n>\n> Most explorers currently don't track payment replacements and, more importantly,\n> don't warn users that unconfirmed funds are not theirs (yet). With full-RBF,\n> wallets should either stop relying on explorers for this functionality or wait\n> for them to support it explicitly.\n>\n> # Impact at Muun\n>\n> Work to transition Muun from using zero-conf submarine swaps to using payment\n> channels is ongoing, but we are still several months away from being production\n> ready. This means we would have to turn off outgoing lightning payments for\n> +100k monthly active users, which is a good chunk of all users making\n> non-custodial lightning payments today.\n>\n> Furthermore, the more subtle fixes imply non-trivial amounts of product work\n> that we cannot reasonably deploy before they start affecting users.\n>\n> While I cannot talk for other applications, there are many impacted in one way\n> or another, and none of the ones I checked with were aware of this change, or\n> its implications.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221008/1ee7b850/attachment-0001.html>"
            },
            {
                "author": "linuxfoundation.cndm1 at dralias.com",
                "date": "2022-10-13T16:07:19",
                "message_text_only": "> - Bitrefill's on-chain payments for gift cards and phone top-ups\n\nBitrefill already supports lightning, so for them it would be easy to\nsolve by displaying the lightning transfer by default and only show\nthe on-chain payment as a fallback. Currently the on-chain payment at\nBitrefill and other similar providers is really a drop-down where you\nselect your wallet and then they display a tutorial to you on how to\ncreate the on-chain transaction (fee rate, RBF flag, etc). I don't\nhave insights into Bitrefill, but one might suspect that encouraging a\nlightning payment might be a win-win situation for them and their\nusers.\n\nIt would be interesting to know if there are any obstacles that\nBitrefill and other services face, or if they don't agree that\nlightning is an improvement over accepting unconfirmed on-chain\ntransactions from untrusted parties.\n\n> - Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at least\n\nI haven't tried them yet, but I suspect they could benefit in a\nsimilar by showing lightning transfers more prominently. Moreover, any\nUX improvement they can offer to users that intentionally or\naccidentally selected RBF opt-in, will also benefit users once fullrbf\nis widespread. To give an example, ATMs could immediately give out a\nvoucher for the cash amount that can be redeemed as soon as the\ntransaction is confirmed on-chain, to allow (untrusted) users to leave\nthe ATM and go for a walk in the meantime.\n\n> With full-RBF, wallets should make it extremely clear to users that unconfirmed\n> funds are not theirs (yet). Otherwise, protocol-unaware users that are\n> transacting on-chain with untrusted parties can be easily scammed if they don't\n> know they have to wait for a confirmation. Eg. in Argentina, it's pretty common\n> to meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n\nThis is easy to solve, because a wallet can simply display all\nunconfirmed transactions as if they signalled for RBF. Your suggested\nsolution to \"activate\" fullrbf at a specific block height might be\ncounter productive, because educating users that unconfirmed\ntransactions are unsafe takes longer than a single block. So the\nearlier users are educated that unconfirmed transactions from\nuntrusted parties are unsafe, the better.\n\n> # Impact at Muun\n>\n> Work to transition Muun from using zero-conf submarine swaps to using payment\n> channels is ongoing, but we are still several months away from being production\n> ready. This means we would have to turn off outgoing lightning payments for\n> +100k monthly active users, which is a good chunk of all users making\n> non-custodial lightning payments today.\n\nIt would be unfortunate for those users, but I think that the risk\nexists today. Relay of fullrbf transactions works reasonable well\nalready, unless you get unlucky with your selected peers. The only\nmissing piece is a few percent of hashrate that will accept fullrbf\nreplacement transactions. While this will certainly happen if a\nBitcoin Core release ships with the flag *on* by default, it still may\nhappen at any time even if Bitcoin Core doesn't ship with the flag at\nall.\n\nBest,\ncndm1"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-14T02:44:04",
                "message_text_only": "Hi cndm1,\n\n> Bitrefill already supports lightning, so for them it would be easy to\n> solve by displaying the lightning transfer by default and only show\n> the on-chain payment as a fallback. Currently the on-chain payment at\n> Bitrefill and other similar providers is really a drop-down where you\n> select your wallet and then they display a tutorial to you on how to\n> create the on-chain transaction (fee rate, RBF flag, etc). I don't\n> have insights into Bitrefill, but one might suspect that encouraging a\n> lightning payment might be a win-win situation for them and their\n> users.\n\nLightning is only used for 4% payments compared to 32% on-chain payments according to a [tweet][1] from Jan 2022 by Sergej Kotliar and stats are similar based on the slides shared in a [presentation][2] in Pizza Day Prague 2022.\n\nBy EUR:\n\nonchain - 30%\nlightning - 5%\n\nBy unique users:\n\nonchain - 40%\nlightning - 9%\n\n> Relay of fullrbf transactions works reasonable well\n> already, unless you get unlucky with your selected peers. The only\n> missing piece is a few percent of hashrate that will accept fullrbf\n> replacement transactions. \n\nI don't believe relay of fullrbf transactions works well right now. The missing piece you mentioned is important and a real need for all full node users to try fullrbf.\n\n> While this will certainly happen if a\n> Bitcoin Core release ships with the flag on by default, it still may\n> happen at any time even if Bitcoin Core doesn't ship with the flag at\n> all.\n\nChanging default at this moment does not make sense as v24.0 could give some insights about usage of fullrbf and we could wait for a few months before changing default for users that run latest version of bitcoin core.\n\nI will quote Antoine Riard's comment from PR [#25353][3]:\n\n\"_I know I've advocated in the past to turn RBF support by default in the past. Though after gathering a lot of feedbacks, this approach of offering the policy flexiblity to the interested users only and favoring a full-rbf gradual deployment sounds better to me. As a follow-up, if we add p2p logic to connect to few \"full-rbf\" service-bit signaling peers and recommend to the ~17000 LN nodes operators, likely (hopefully!) running bitcoind as a backend, that should be okay to guarantee a good propagation to miners (and yes reaching out to few mining pools ops to explain the income increase brought by full-rbf). Unless we observe a significant impact on compact blocks reconstruction, personally I'm really fine waiting another multi-years development cycle before to propose a default change, or even let opt-in forever the default as it is._\"\n\n\"_Once again, the proposed change is only targeting educated users aiming to deploy full RBF for their application specific needs. If the majority of Bitcoin users is not interested, that's okay. It's a policy rule, not a consensus one._\"\n\nAlthough Antoine has opened another [pull request][4] to make fullrbf default a few hours ago, so I am not sure what is the new motivation or discussion that I am missing.\n\n[1]: https://twitter.com/ziggamon/status/1481307334068641795\n[2]: https://youtu.be/bkjEcSmZKfc?t=463\n[3]: https://github.com/bitcoin/bitcoin/pull/25353\n[4]: https://github.com/bitcoin/bitcoin/pull/26305\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Thursday, October 13th, 2022 at 9:37 PM, linuxfoundation.cndm1--- via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> > - Bitrefill's on-chain payments for gift cards and phone top-ups\n> \n> \n> Bitrefill already supports lightning, so for them it would be easy to\n> solve by displaying the lightning transfer by default and only show\n> the on-chain payment as a fallback. Currently the on-chain payment at\n> Bitrefill and other similar providers is really a drop-down where you\n> select your wallet and then they display a tutorial to you on how to\n> create the on-chain transaction (fee rate, RBF flag, etc). I don't\n> have insights into Bitrefill, but one might suspect that encouraging a\n> lightning payment might be a win-win situation for them and their\n> users.\n> \n> It would be interesting to know if there are any obstacles that\n> Bitrefill and other services face, or if they don't agree that\n> lightning is an improvement over accepting unconfirmed on-chain\n> transactions from untrusted parties.\n> \n> > - Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at least\n> \n> \n> I haven't tried them yet, but I suspect they could benefit in a\n> similar by showing lightning transfers more prominently. Moreover, any\n> UX improvement they can offer to users that intentionally or\n> accidentally selected RBF opt-in, will also benefit users once fullrbf\n> is widespread. To give an example, ATMs could immediately give out a\n> voucher for the cash amount that can be redeemed as soon as the\n> transaction is confirmed on-chain, to allow (untrusted) users to leave\n> the ATM and go for a walk in the meantime.\n> \n> > With full-RBF, wallets should make it extremely clear to users that unconfirmed\n> > funds are not theirs (yet). Otherwise, protocol-unaware users that are\n> > transacting on-chain with untrusted parties can be easily scammed if they don't\n> > know they have to wait for a confirmation. Eg. in Argentina, it's pretty common\n> > to meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n> \n> \n> This is easy to solve, because a wallet can simply display all\n> unconfirmed transactions as if they signalled for RBF. Your suggested\n> solution to \"activate\" fullrbf at a specific block height might be\n> counter productive, because educating users that unconfirmed\n> transactions are unsafe takes longer than a single block. So the\n> earlier users are educated that unconfirmed transactions from\n> untrusted parties are unsafe, the better.\n> \n> > # Impact at Muun\n> > \n> > Work to transition Muun from using zero-conf submarine swaps to using payment\n> > channels is ongoing, but we are still several months away from being production\n> > ready. This means we would have to turn off outgoing lightning payments for\n> > +100k monthly active users, which is a good chunk of all users making\n> > non-custodial lightning payments today.\n> \n> \n> It would be unfortunate for those users, but I think that the risk\n> exists today. Relay of fullrbf transactions works reasonable well\n> already, unless you get unlucky with your selected peers. The only\n> missing piece is a few percent of hashrate that will accept fullrbf\n> replacement transactions. While this will certainly happen if a\n> Bitcoin Core release ships with the flag on by default, it still may\n> happen at any time even if Bitcoin Core doesn't ship with the flag at\n> all.\n> \n> Best,\n> cndm1\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-14T15:02:25",
                "message_text_only": "On Fri, Oct 14, 2022 at 02:44:04AM +0000, alicexbt via bitcoin-dev wrote:\n> > Relay of fullrbf transactions works reasonable well\n> > already, unless you get unlucky with your selected peers. The only\n> > missing piece is a few percent of hashrate that will accept fullrbf\n> > replacement transactions. \n> \n> I don't believe relay of fullrbf transactions works well right now. The missing piece you mentioned is important and a real need for all full node users to try fullrbf.\n\nRelay of full-rbf transactions works well right now precisely because a few\nimplementations exist of preferential rbf peering. I'm personally running four\nnodes with it enabled, two using my own custom patches, and another two using\nariad's patch:\n\nhttps://github.com/bitcoin/bitcoin/pull/25600\n\nI haven't seen a lot of non-opt-in doublespends get mined. But I have seen a\nfew now via my Alice OTS calendar. This can of course increase dramatically as\nminers turn on full-rbf.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221014/7d612ef5/attachment.sig>"
            },
            {
                "author": "John Carvalho",
                "date": "2022-10-14T10:03:21",
                "message_text_only": "In support of Dario's concern, I feel like there is a degree of gaslighting\nhappening with the advancement of RBF somehow being okay, while merchants\nwanting to manage their own 0conf risk better being not okay.\n\nThe argument against 0conf acceptance seems to be \"miners can facilitate\ndoublespends anyway, and are incentivized to do so if the fees are higher\"\nas this is just how Bitcoin works.\n\nBut RBF proponents seem to be taking what is actually a much rarer, and\nless useful, use case of replacing txns that lowball feerates, or actually\nundoing/doublespending previously signed payments... and threaten the use\ncase of onchain bitcoin being useful at the point-of-sale for merchants and\nconsumers.\n\nI can tell you right now where this leads. It leads to miners, merchants\nand consumers creating alternative fee mechanisms and trusted/exclusive\nmempools where first-seen txns are respected.\n\nThe truth is that doublespending is not a certain process, and in many\ncommercial situations, too risky to attempt without real-world consequences.\n\n0conf payment acceptance comes with highly *manageable* risks, which means\nthat if best practices and methods are used by merchants, and *gasp*\nadvanced by engineers with better tools and specs, that we can have fast\nand valuable commercial payments with merchants that meet user\nexpectations. In fact, we may even be able to do so with less complexity\nthan Lightning and with similar results and overhead...\n\nThat said, we are (myself and a group of builders and merchants) moving\nforward with demonstrating, protecting, and advancing this use case,\nto contrast the trend of making the mempool less predictable and easier to\nreplace.\n\nRBF causes more problems than it resolves, and if your argument is that\n0conf was never safe, then mine is that RBF was never needed. We should not\npretend that the mempool is enforceable for either cause, and should\nrespect that incentives will always prevail eventually.\n\nTo me, use cases for spending Bitcoin are more important to protect than\nfeatures for pretending you can enforce mempool behaviors or pretending you\ncan reliably provide replacement features.\n\nIf anyone is interested in research, specs, and tools and assisting our\ngroup, you can contact me directly, or join the public chat at\nhttps://t.me/bitcoinandlightningspecs\n\nThanks,\n\n--\nJohn Carvalho\nCEO, Synonym.to <http://synonym.to/>\n\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221014/d5ebbd52/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-14T15:04:56",
                "message_text_only": "On Fri, Oct 14, 2022 at 12:03:21PM +0200, John Carvalho via bitcoin-dev wrote:\n> In support of Dario's concern, I feel like there is a degree of gaslighting\n> happening with the advancement of RBF somehow being okay, while merchants\n> wanting to manage their own 0conf risk better being not okay.\n\nThe way merchants try to manage 0conf risk is quite harmful to Bitcoin.\nConnecting to large numbers of nodes to try to risk-manage propagation _is_ an\nattack, albeit a mild one. Everyone doing that is very harmful; only a few\nmerchants being able to do it is very unfair/centralized.\n\n...and of course, in the past this has lead to merchants trying to make deals\nwith miners directly, even going as far as to suggest reorging out\ndouble-spends. I don't need to explain why that is obviously extremely harmful.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221014/7127d8c2/attachment.sig>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-10-14T16:28:49",
                "message_text_only": "Also, lightning works fine and is readily available in convenient mobile\napps used by millions of people, or in .   So the need for a 0conf has been\nmitigated by other solutions for fast payments with no need for a trust\nrelationship.  And for people that don't like mobile risks, core lightning\nand other solutions are now easily installed and configured for use in fast\npayments.\n\nsome references:\n\nhttps://muun.com/ (easy!)\nhttps://github.com/ElementsProject/lightning (reference, works well with\ncore)\nhttps://lightning.network/ (more info)\n\n\nOn Fri, Oct 14, 2022 at 11:11 AM Peter Todd via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Fri, Oct 14, 2022 at 12:03:21PM +0200, John Carvalho via bitcoin-dev\n> wrote:\n> > In support of Dario's concern, I feel like there is a degree of\n> gaslighting\n> > happening with the advancement of RBF somehow being okay, while merchants\n> > wanting to manage their own 0conf risk better being not okay.\n>\n> The way merchants try to manage 0conf risk is quite harmful to Bitcoin.\n> Connecting to large numbers of nodes to try to risk-manage propagation\n> _is_ an\n> attack, albeit a mild one. Everyone doing that is very harmful; only a few\n> merchants being able to do it is very unfair/centralized.\n>\n> ...and of course, in the past this has lead to merchants trying to make\n> deals\n> with miners directly, even going as far as to suggest reorging out\n> double-spends. I don't need to explain why that is obviously extremely\n> harmful.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221014/3341dfbc/attachment-0001.html>"
            },
            {
                "author": "John Carvalho",
                "date": "2022-10-15T04:08:15",
                "message_text_only": "Erik, I am fully aware of Lightning and have a been a proponent and builder\nof it since it was launched, including getting Bitfinex to support LN,\nbuilding a RN LDK implementation in our upcoming app, etc, but frankly LN\nhas nowhere near the adoption of onchain payments for commerce, and LN\ncomplexity, reliability, maintenance and overhead are real obstacles for\nmerchants.\n\nOne of your links is to Muun, who started this thread!\n\nThere is no practicality in a merchant saying they accept bitcoin, but not\nonchain, or in having many checkout and customer service versions for many\nbitcoin payment methods.\n\nMerchants accepting base layer bitcoin is one if the most important types\nof adoption there is.\n\n-John\n\nOn Fri, Oct 14, 2022 at 6:29 PM Erik Aronesty <erik at q32.com> wrote:\n\n> Also, lightning works fine and is readily available in convenient mobile\n> apps used by millions of people, or in .   So the need for a 0conf has been\n> mitigated by other solutions for fast payments with no need for a trust\n> relationship.  And for people that don't like mobile risks, core lightning\n> and other solutions are now easily installed and configured for use in fast\n> payments.\n>\n> some references:\n>\n> https://muun.com/ (easy!)\n> https://github.com/ElementsProject/lightning (reference, works well with\n> core)\n> https://lightning.network/ (more info)\n>\n>\n> On Fri, Oct 14, 2022 at 11:11 AM Peter Todd via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Fri, Oct 14, 2022 at 12:03:21PM +0200, John Carvalho via bitcoin-dev\n>> wrote:\n>> > In support of Dario's concern, I feel like there is a degree of\n>> gaslighting\n>> > happening with the advancement of RBF somehow being okay, while\n>> merchants\n>> > wanting to manage their own 0conf risk better being not okay.\n>>\n>> The way merchants try to manage 0conf risk is quite harmful to Bitcoin.\n>> Connecting to large numbers of nodes to try to risk-manage propagation\n>> _is_ an\n>> attack, albeit a mild one. Everyone doing that is very harmful; only a few\n>> merchants being able to do it is very unfair/centralized.\n>>\n>> ...and of course, in the past this has lead to merchants trying to make\n>> deals\n>> with miners directly, even going as far as to suggest reorging out\n>> double-spends. I don't need to explain why that is obviously extremely\n>> harmful.\n>>\n>> --\n>> https://petertodd.org 'peter'[:-1]@petertodd.org\n>>\n> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> --\n--\nJohn Carvalho\nCEO, Synonym.to <http://synonym.to/>\n\nSchedule: https://calendly.com/bitcoinerrorlog\nChat: https://t.me/bitcoinerrorlog\nSocial: https://twitter.com/bitcoinerrorlog\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221015/ff6d390f/attachment-0001.html>"
            },
            {
                "author": "John Carvalho",
                "date": "2022-10-15T04:20:55",
                "message_text_only": "Peter,\n\nYour argument is totally hypocritical and loses when comparing quantities.\n\nEnforcing RBF is observably more \"harmful to Bitcoin\" (whatever that\nmeans...) when it tries to \"risk-manage propagation\" of replacements, as\nthere more Bitcoiners that want to mutually utilize 0conf than users that\nwant to replace transactions.\n\nSpending bitcoin is a use case, so replacing txns reduces utility and makes\ncommitments less certain.\n\nNo one here arguing for 0conf is suggesting reorgs, so please do not\nsensationalize with claims of reorgs or \"harm.\"\n\nTake note that it is RBF proponents that have changed Bitcoin code and seek\nto continue to change Bitcoin, RBF that seeks to reduce commercial utility\n-- but 0conf proponents are not asking for changes to Bitcoin, not\nsuggesting soft or hard forks, etc. We are asking you to stop breaking\nthings by adding features for minority speculative interests.\n\n-John\n\nOn Fri, Oct 14, 2022 at 5:04 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Oct 14, 2022 at 12:03:21PM +0200, John Carvalho via bitcoin-dev\n> wrote:\n> > In support of Dario's concern, I feel like there is a degree of\n> gaslighting\n> > happening with the advancement of RBF somehow being okay, while merchants\n> > wanting to manage their own 0conf risk better being not okay.\n>\n> The way merchants try to manage 0conf risk is quite harmful to Bitcoin.\n> Connecting to large numbers of nodes to try to risk-manage propagation\n> _is_ an\n> attack, albeit a mild one. Everyone doing that is very harmful; only a few\n> merchants being able to do it is very unfair/centralized.\n>\n> ...and of course, in the past this has lead to merchants trying to make\n> deals\n> with miners directly, even going as far as to suggest reorging out\n> double-spends. I don't need to explain why that is obviously extremely\n> harmful.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-- \n--\nJohn Carvalho\nCEO, Synonym.to <http://synonym.to/>\n\nSchedule: https://calendly.com/bitcoinerrorlog\nChat: https://t.me/bitcoinerrorlog\nSocial: https://twitter.com/bitcoinerrorlog\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221015/e01898e5/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-17T20:31:50",
                "message_text_only": "Hi Dario,\n\nSorry for the latency in reply to the reaction about the full-rbf setting\nI've initially pushed in 0.24, TABConf week has been a busy one.\n\n>From my understanding, there is no disagreement from Muun wallet about the\ngradual deployment of full-rbf by Bitcoin Core nodes, this is more a\nquestion of timeline to allow the zero-conf apps ecosystem to do the\noverhaul required.\n\nTo recall, my initial motivation to deprecate opt-in RBF over the whole\nnetwork is to mitigate a low-cost and easy DoS vector affecting the funding\nphase of multi-party contracting protocols:\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\nAs of current, upcoming Bitcoin Core 0.24 release, a `mempoolfullrbf`\nsetting is introduced defaulting to false. This option allows a node to\naccept transaction replace-by-fee without requiring replaceability\nsignaling. If we assume a reasonable social inertia among Bitcoin Core node\noperators, full-rbf transaction-relay paths should be rare. To palliate to\nthis concern, the introduction of a temporary `NODE_FULL_RBF` service bit\nand automated preferential peering is proposed with:\n\nhttps://github.com/bitcoin/bitcoin/pull/25600\n\nThis PR doesn't make the assumption that full-rbf is wished by the majority\nof the network of node operators and rather favors an opt-in full-rbf\ndeployment. The existence of few full-rbf transaction-relay paths and\nmining hashrate is sufficient to achieve mitigation of the DoS vector.\n\nAs #25600 boosts the deployment of full-rbf transaction-relay paths, and\ninduces a side-effect of a weakening of zero-conf apps, I can understand\nthis is not the approach offering the more visibility and predictability to\nzero-conf operators.\n\nSince then two more approaches have been proposed, a 1st one turning on by\ndefault `mempoolsetting`, at best to land in 25.0, i.e ~6 months now\nfollowing the usual Core release schedule:\n\nhttps://github.com/bitcoin/bitcoin/pull/26305\n\nA 2nd one making full-rbf by default at a flag day target, 1st May 2023,\naimed to land in 0.24, and as such giving a clear time point to zero-conf\nnode operators now.\n\nA third option proposed has been to withdraw `mempoolfullrbf` setting for\n0.24, now withdrawn by its author:\n\nhttps://github.com/bitcoin/bitcoin/pull/26287\n\nWhile in theory, the release process about new policy changes should stay\nflexible to correct the unforeseen impacts of policy changes, in the\npresent case the implications on zero-conf services have been raised early\non when the changes were brought in Bitcoin Core, i.e 4 months ago.\nCommunication has been posted on this venue to invite zero-conf node\noperators to express concerns at that time:\n\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n\nOn a procedural point, I think this is a reasonable standard, navigating in\nan area where there are not that many precedents about the deprecation of a\nCore policy rule.\n\nAsking to the wider community of zero-conf node operators, among all the\napproaches, what has the most likes and what other decision-making factors\nshould be considered. It is especially interesting if a 6 month time buffer\nfrom now is sufficient for the zero-conf applications to upgrade, and if\nnot what are the concrete engineering or operational bottlenecks.\n\nBest,\nAntoine\n\nLe ven. 7 oct. 2022 \u00e0 12:43, Dario Sneidermanis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hello list,\n>\n> I'm Dario, from Muun wallet, a mobile non-custodial bitcoin wallet. For\n> the past\n> few days we've been reviewing the latest bitcoin core release candidate,\n> and we\n> found some troubling facts related to the opt-in full-RBF deployment.\n>\n> We first learned about the opt-in full-RBF proposal last June when it was\n> announced on the mailing list. Closing the gap between the protocol's relay\n> policies and the miner incentives is inevitable, so it was a welcomed\n> addition.\n> Furthermore, allowing transaction replacements that remove the opt-in RBF\n> flag\n> was deeply problematic.\n>\n> At the time, we understood we had at least a year from the initial opt-in\n> deployment until opt-out was deployed, giving us enough time to adapt Muun\n> to\n> the new policies. However, when reviewing the 24.0 release candidate just\n> a few\n> days ago, we realized that zero-conf apps (like Muun) must *immediately\n> turn\n> off* their zero-conf features.\n>\n> I understand this wasn't the intention when designing the opt-in deployment\n> mechanism. Given this new information, do you see a path where we can\n> delay the\n> opt-in deployment and find a safer way to deploy full-RBF?\n>\n> It'd be great for this deployment to be a success so that we can continue\n> fixing\n> the remaining relay policy problems, such as package relay and the RBF\n> rules.\n> Maybe we could go straight to an opt-out deployment locked by code at a\n> certain\n> height in the future to give time to everyone and, at the same time, avoid\n> a\n> huge mempool divergence event?\n>\n> Below is our analysis of how zero-conf apps break with opt-in full-RBF. I\n> hope\n> it helps.\n>\n> Cheers,\n> Dario\n>\n>\n> # How do zero-conf apps work\n>\n> While the workings and trade-offs of zero-conf applications might be known\n> by\n> many in this list, it's useful to define precisely how they work to\n> understand\n> how they break.\n>\n> We call zero-conf applications to entities that accept on-chain payments\n> from\n> *untrusted parties* and will sometimes deliver the paid-for product or\n> service\n> without waiting for the transaction to be included in a block.\n>\n> Some examples of zero-conf apps:\n>\n> - Muun's submarine swaps for outgoing lightning payments\n> - Bitrefill's on-chain payments for gift cards and phone top-ups\n> - Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at\n> least\n>   the two biggest bitcoin ATM manufacturers support this: Genesis Coin and\n>   General Byte)\n>\n> All of these applications are receiving incoming on-chain transactions for\n> which\n> they don't control the inputs, and performing a risk analysis to decide\n> whether\n> they are ok with accepting the payment without confirmation.\n>\n> In practice, this works because once the bitcoin P2P network has fully\n> propagated a non-RBF transaction, you need the collaboration of a miner to\n> replace it, which isn't easy to get today. Even though many of the biggest\n> miners offer off-band transaction broadcasting services, they currently\n> won't\n> process conflicting transactions.\n>\n> Roughly, the risk analysis goes like this:\n>\n> 1. if an incoming transaction is RBF (direct or inherited)\n>    --> too risky, wait for 1 conf (or more) since it can be replaced at\n> any time\n> 2. if the payment is for an amount greater than X\n>    --> too risky, wait for 1 conf (or more), since the amount is worthy of\n> a\n>        sophisticated attacker\n> 3. wait for full(ish) propagation of the incoming transaction\n> 4. if there's no double-spend attempt\n>    --> accept 0-conf\n>\n> As with any other risk analysis, there's always a false-negative detection\n> rate,\n> leading to an expected loss, which the zero-conf app should be willing to\n> bear.\n> Notice that the expected loss is tunable via the amount X in the above\n> analysis.\n>\n>\n> # Why are zero-conf apps not protected with an opt-in deployment\n>\n> Full-RBF adoption works on three different layers:\n>\n> - The transaction application layer\n> - The transaction relaying layer\n> - The transaction mining layer\n>\n> If an application wants to replace with full-RBF an *outgoing*\n> transaction, it\n> will need:\n>\n> - An upgraded node that opted into full-RBF, from which it can broadcast\n> the\n>   replacement transaction\n> - A connected component of upgraded nodes that opted into full-RBF, that\n> can\n>   relay the replacement transaction\n> - A miner in that connected component with an upgraded node that opted into\n>   full-RBF, that can mine the replacement transaction\n>\n> However, an application cannot control whether a replacement to an\n> *incoming*\n> transaction is relayed via full-RBF. As soon as a single application can\n> generate replacements easily via full-RBF, all other applications have to\n> assume\n> that any incoming transaction from an untrusted party might be replaced via\n> full-RBF. That is, for the application layer this is a forced upgrade.\n>\n> As soon as an unsophisticated attacker can use opt-in full-RBF, the risk\n> analysis performed by zero-conf applications stops working because the\n> transactions to analyze are all incoming transactions from untrusted\n> parties.\n> Since some wallets already implement cancel functionality for opt-in RBF\n> transactions, enabling the same functionality for every transaction\n> wouldn't\n> require much work, making canceling any unconfirmed transaction a one-click\n> experience. After this, the security model of zero-conf applications goes\n> from\n> \"susceptible to attacks from miners\" to \"anyone can perform an attack,\n> with an\n> easy-to-use interface\".\n>\n> That is, the opt-in deployment of full-RBF doesn't protect zero-conf\n> applications from having to turn off their zero-conf features very soon\n> after\n> the initial deployment. All mitigations are mostly ineffective against\n> untrusted parties.\n>\n>\n> # Other things we have to fix\n>\n> While it's clear how full-RBF breaks zero-conf applications, other more\n> subtle\n> things break in *many* wallets (Muun included). If given the opportunity,\n> we\n> would like to fix them before deployment. One could argue that these things\n> were already broken, but they get considerably worse as the network adopts\n> full-RBF (even with an opt-in deployment), so we should fix them.\n>\n> ## Mental model for unconfirmed incoming transactions\n>\n> Many wallets with support for on-chain payments (Muun included) show\n> incoming\n> external transactions in some way to their users before they confirm. This\n> is a\n> common practice because not showing them leads users to worry that their\n> money\n> disappeared (exchanges doing this is the #1 issue we have to deal with in\n> our\n> customer support channels).\n>\n> With full-RBF, wallets should make it extremely clear to users that\n> unconfirmed\n> funds are not theirs (yet). Otherwise, protocol-unaware users that are\n> transacting on-chain with untrusted parties can be easily scammed if they\n> don't\n> know they have to wait for a confirmation. Eg. in Argentina, it's pretty\n> common\n> to meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n>\n> ## Block explorers as payment receipts\n>\n> Most wallets with support for on-chain payments (Muun included) use the\n> transaction view of a block explorer as a shareable payment receipt. The\n> sender\n> of an on-chain transaction usually shares this link with the receiver to\n> let\n> them know they made a payment. Protocol-unaware receivers sometimes take\n> this\n> link as proof of payment.\n>\n> Most explorers currently don't track payment replacements and, more\n> importantly,\n> don't warn users that unconfirmed funds are not theirs (yet). With\n> full-RBF,\n> wallets should either stop relying on explorers for this functionality or\n> wait\n> for them to support it explicitly.\n>\n>\n> # Impact at Muun\n>\n> Work to transition Muun from using zero-conf submarine swaps to using\n> payment\n> channels is ongoing, but we are still several months away from being\n> production\n> ready. This means we would have to turn off outgoing lightning payments for\n> +100k monthly active users, which is a good chunk of all users making\n> non-custodial lightning payments today.\n>\n> Furthermore, the more subtle fixes imply non-trivial amounts of product\n> work\n> that we cannot reasonably deploy before they start affecting users.\n>\n> While I cannot talk for other applications, there are many impacted in one\n> way\n> or another, and none of the ones I checked with were aware of this change,\n> or\n> its implications.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/e8c44e70/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-17T22:14:52",
                "message_text_only": "Hi John,\n\nI hear your worry about RBF issuing concerns for 0conf acceptance\nmerchants. I don't think it has been denied in the first communication of\nthis opt-in rbf proposal back in June. Merchants/0confs builders have been\ninvited to bring voices to the surface at that time [0]. So this new\nfull-RBF proposal has at least tried to bind to best communication\nstandards towards the community at large. If you think about more community\nvenues (Reddit, podcast, newsletter, ...) that developers may weigh in when\nproposing Core policy changes, we can improve for next time.\n\nAbout the kernel of the concern I understand, I think the whole discussion\nwould benefit from clarifications in precising zero-conf security bounds.\nRelying only on first-seen and lack of RBF as a solo ground to estimate the\nsafety of an incoming transaction isn't that robust in a distributed system\nlike the p2p network. However, building management risks framework on top,\nas additional security layers sound a far more compelling approach from a\ndeveloper perspective. A year ago, when I initially proposed full-rbf, I\nnoted a few ideas that could be implemented such as double-spend monitoring\nor staked reputation to enhance zero-conf security [1]. For sure, there is\na wide solution space to explore and build on to improve the 0conf flows,\nand it would marginally benefit LN, as we have now zero-conf channels [2].\n\nThat said, saying RBF causes more problems than it resolves sounds hard to\nhold as a line from my perspective. As LN security relies on a reactive\nmodel, where time-sensitive transactions must be included before a given\nheight to ensure funds safety, the ability to replace-by-fee previous bids\nand have them propagating well on the network is fundamental. While I think\nthis is correct to say that today 0conf might be still a more significant\neconomic traffic than Lightning, the bitcoin user of tomorrow is likely to\nexpect both 0conf and Lightning, without caring that much about the\nquibbles of the security mechanisms backing them.\n\nOverall, RBF is far from being a \"black-and-white\" thing, dependending of\nthe perspective you're coming from, and thanks to everyone for patience in\nthis discussion.\n\nBest,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020557.html\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html\n[2] https://github.com/lightning/bolts/pull/910\n\nLe ven. 7 oct. 2022 \u00e0 12:43, Dario Sneidermanis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hello list,\n>\n> I'm Dario, from Muun wallet, a mobile non-custodial bitcoin wallet. For\n> the past\n> few days we've been reviewing the latest bitcoin core release candidate,\n> and we\n> found some troubling facts related to the opt-in full-RBF deployment.\n>\n> We first learned about the opt-in full-RBF proposal last June when it was\n> announced on the mailing list. Closing the gap between the protocol's relay\n> policies and the miner incentives is inevitable, so it was a welcomed\n> addition.\n> Furthermore, allowing transaction replacements that remove the opt-in RBF\n> flag\n> was deeply problematic.\n>\n> At the time, we understood we had at least a year from the initial opt-in\n> deployment until opt-out was deployed, giving us enough time to adapt Muun\n> to\n> the new policies. However, when reviewing the 24.0 release candidate just\n> a few\n> days ago, we realized that zero-conf apps (like Muun) must *immediately\n> turn\n> off* their zero-conf features.\n>\n> I understand this wasn't the intention when designing the opt-in deployment\n> mechanism. Given this new information, do you see a path where we can\n> delay the\n> opt-in deployment and find a safer way to deploy full-RBF?\n>\n> It'd be great for this deployment to be a success so that we can continue\n> fixing\n> the remaining relay policy problems, such as package relay and the RBF\n> rules.\n> Maybe we could go straight to an opt-out deployment locked by code at a\n> certain\n> height in the future to give time to everyone and, at the same time, avoid\n> a\n> huge mempool divergence event?\n>\n> Below is our analysis of how zero-conf apps break with opt-in full-RBF. I\n> hope\n> it helps.\n>\n> Cheers,\n> Dario\n>\n>\n> # How do zero-conf apps work\n>\n> While the workings and trade-offs of zero-conf applications might be known\n> by\n> many in this list, it's useful to define precisely how they work to\n> understand\n> how they break.\n>\n> We call zero-conf applications to entities that accept on-chain payments\n> from\n> *untrusted parties* and will sometimes deliver the paid-for product or\n> service\n> without waiting for the transaction to be included in a block.\n>\n> Some examples of zero-conf apps:\n>\n> - Muun's submarine swaps for outgoing lightning payments\n> - Bitrefill's on-chain payments for gift cards and phone top-ups\n> - Many bitcoin ATMs' on-chain deposits for selling bitcoin for cash (at\n> least\n>   the two biggest bitcoin ATM manufacturers support this: Genesis Coin and\n>   General Byte)\n>\n> All of these applications are receiving incoming on-chain transactions for\n> which\n> they don't control the inputs, and performing a risk analysis to decide\n> whether\n> they are ok with accepting the payment without confirmation.\n>\n> In practice, this works because once the bitcoin P2P network has fully\n> propagated a non-RBF transaction, you need the collaboration of a miner to\n> replace it, which isn't easy to get today. Even though many of the biggest\n> miners offer off-band transaction broadcasting services, they currently\n> won't\n> process conflicting transactions.\n>\n> Roughly, the risk analysis goes like this:\n>\n> 1. if an incoming transaction is RBF (direct or inherited)\n>    --> too risky, wait for 1 conf (or more) since it can be replaced at\n> any time\n> 2. if the payment is for an amount greater than X\n>    --> too risky, wait for 1 conf (or more), since the amount is worthy of\n> a\n>        sophisticated attacker\n> 3. wait for full(ish) propagation of the incoming transaction\n> 4. if there's no double-spend attempt\n>    --> accept 0-conf\n>\n> As with any other risk analysis, there's always a false-negative detection\n> rate,\n> leading to an expected loss, which the zero-conf app should be willing to\n> bear.\n> Notice that the expected loss is tunable via the amount X in the above\n> analysis.\n>\n>\n> # Why are zero-conf apps not protected with an opt-in deployment\n>\n> Full-RBF adoption works on three different layers:\n>\n> - The transaction application layer\n> - The transaction relaying layer\n> - The transaction mining layer\n>\n> If an application wants to replace with full-RBF an *outgoing*\n> transaction, it\n> will need:\n>\n> - An upgraded node that opted into full-RBF, from which it can broadcast\n> the\n>   replacement transaction\n> - A connected component of upgraded nodes that opted into full-RBF, that\n> can\n>   relay the replacement transaction\n> - A miner in that connected component with an upgraded node that opted into\n>   full-RBF, that can mine the replacement transaction\n>\n> However, an application cannot control whether a replacement to an\n> *incoming*\n> transaction is relayed via full-RBF. As soon as a single application can\n> generate replacements easily via full-RBF, all other applications have to\n> assume\n> that any incoming transaction from an untrusted party might be replaced via\n> full-RBF. That is, for the application layer this is a forced upgrade.\n>\n> As soon as an unsophisticated attacker can use opt-in full-RBF, the risk\n> analysis performed by zero-conf applications stops working because the\n> transactions to analyze are all incoming transactions from untrusted\n> parties.\n> Since some wallets already implement cancel functionality for opt-in RBF\n> transactions, enabling the same functionality for every transaction\n> wouldn't\n> require much work, making canceling any unconfirmed transaction a one-click\n> experience. After this, the security model of zero-conf applications goes\n> from\n> \"susceptible to attacks from miners\" to \"anyone can perform an attack,\n> with an\n> easy-to-use interface\".\n>\n> That is, the opt-in deployment of full-RBF doesn't protect zero-conf\n> applications from having to turn off their zero-conf features very soon\n> after\n> the initial deployment. All mitigations are mostly ineffective against\n> untrusted parties.\n>\n>\n> # Other things we have to fix\n>\n> While it's clear how full-RBF breaks zero-conf applications, other more\n> subtle\n> things break in *many* wallets (Muun included). If given the opportunity,\n> we\n> would like to fix them before deployment. One could argue that these things\n> were already broken, but they get considerably worse as the network adopts\n> full-RBF (even with an opt-in deployment), so we should fix them.\n>\n> ## Mental model for unconfirmed incoming transactions\n>\n> Many wallets with support for on-chain payments (Muun included) show\n> incoming\n> external transactions in some way to their users before they confirm. This\n> is a\n> common practice because not showing them leads users to worry that their\n> money\n> disappeared (exchanges doing this is the #1 issue we have to deal with in\n> our\n> customer support channels).\n>\n> With full-RBF, wallets should make it extremely clear to users that\n> unconfirmed\n> funds are not theirs (yet). Otherwise, protocol-unaware users that are\n> transacting on-chain with untrusted parties can be easily scammed if they\n> don't\n> know they have to wait for a confirmation. Eg. in Argentina, it's pretty\n> common\n> to meet someone in person to buy bitcoin P2P for cash, even for newcomers.\n>\n> ## Block explorers as payment receipts\n>\n> Most wallets with support for on-chain payments (Muun included) use the\n> transaction view of a block explorer as a shareable payment receipt. The\n> sender\n> of an on-chain transaction usually shares this link with the receiver to\n> let\n> them know they made a payment. Protocol-unaware receivers sometimes take\n> this\n> link as proof of payment.\n>\n> Most explorers currently don't track payment replacements and, more\n> importantly,\n> don't warn users that unconfirmed funds are not theirs (yet). With\n> full-RBF,\n> wallets should either stop relying on explorers for this functionality or\n> wait\n> for them to support it explicitly.\n>\n>\n> # Impact at Muun\n>\n> Work to transition Muun from using zero-conf submarine swaps to using\n> payment\n> channels is ongoing, but we are still several months away from being\n> production\n> ready. This means we would have to turn off outgoing lightning payments for\n> +100k monthly active users, which is a good chunk of all users making\n> non-custodial lightning payments today.\n>\n> Furthermore, the more subtle fixes imply non-trivial amounts of product\n> work\n> that we cannot reasonably deploy before they start affecting users.\n>\n> While I cannot talk for other applications, there are many impacted in one\n> way\n> or another, and none of the ones I checked with were aware of this change,\n> or\n> its implications.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/28add9f9/attachment.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-19T14:29:57",
                "message_text_only": "Hi all,\n\nChiming in on this thread as I feel like the real dangers of RBF as default\npolicy aren't sufficiently elaborated here. It's not only about the\nzero-conf (I'll get to that) but there is an even bigger danger called the\namerican call option, which risks endangering the entirety of BIP21 \"Scan\nthis QR code with your wallet to buy this product\" model that I believe\nwe've all come to appreciate. Specifically, in a scenario with high\nvolatility and many transactions in the mempools (which is where RBF would\ncome in handy), a user can make a low-fee transaction and then wait for\nhours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\nup, user can cancel his transaction and make a new - cheaper one. The\nbiggest risk in accepting bitcoin payments is in fact not zeroconf risk\n(it's actually quite easily managed), it's FX risk as the merchant must\ncommit to a certain BTCUSD rate ahead of time for a purchase. Over time\nsome transactions lose money to FX and others earn money - that evens out\nin the end. But if there is an _easily accessible in the wallet_ feature to\n\"cancel transaction\" that means it will eventually get systematically\nabused. A risk of X% loss on many payments that's easy to systematically\nabuse is more scary than a rare risk of losing 100% of one occasional\npayment. It's already possible to execute this form of abuse with opt-in\nRBF, which may lead to us at some point refusing those payments (even with\nconfirmation) or cumbersome UX to work around it, such as crediting the\nbitcoin to a custodial account.\n\nTo compare zeroconf risk with FX risk: I think we've had one incident in 8\nyears of operation where a user successfully fooled our server to accept a\npayment that in the end didn't confirm. To successfully fool (non-RBF)\nzeroconf one needs to have access to mining infrastructure and probability\nof success is the % of hash rate controlled. This is simply due to the fact\nthat the network currently won't propagage the replacement transaction to\nthe miner, which is what's being discussed here. American call option risk\nwould however be available to 100% of all users, needs nothing beyond the\nwallet app, and has no cost to the user - only upside.\n\nBitrefill currently processes 1500-2000 onchain payments every day. For us,\na world where bitcoin becomes de facto RBF by default, means that we would\nlikely turn off the BIP21 model for onchain payments, instruct Bitcoin\nusers to use Lightning or deposit onchain BTC to a custodial account that\nwe have.\nThis option is however not available for your typical\nBTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\nfrom other merchants or payment providers how they see this new behavior\nand how they would counteract it.\n\nCurrently Lightning is somewhere around 15% of our total bitcoin payments.\nThis is very much not nothing, and all of us here want Lightning to grow,\nbut I think it warrants a serious discussion on whether we want Lightning\nadoption to go to 100% by means of disabling on-chain commerce. For me\npersonally it would be an easier discussion to have when Lightning is at\n80%+ of all bitcoin transactions. Currently far too many bitcoin users\nsimply don't have access to Lightning, and of those that do and hold their\nown keys Muun is the biggest wallet per our data, not least due to their\nease-of-use which is under threat per the OP. It's hard to assess how many\nusers would switch to Lightning in such a scenario, the communication\naround it would be hard. My intuition says that the majority of the current\n85% of bitcoin users that pay onchain would just not use bitcoin anymore,\nprobably shift to an alt. The benefits of Lightning are many and obvious,\nwe don't need to limit onchain to make Lightning more appealing. As an\nanecdote, we did experiment with defaulting to bech32 addresses some years\nback. The result was that simply users of the wallets that weren't able to\npay to bech32 didn't complete the purchase, no support ticket or anything,\njust \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\nimplemented a wallet selector to allow modern wallets to pay to bech32\nwhile other wallets can pay to P2SH. This type of thing  is clunky, and\nrequires a certain level of scale to be able to do, we certainly wouldn't\nhave had the manpower for that when we were starting out. This why I'm\ncautious about introducing more such clunkiness vectors as they are\ncentralizing factors.\n\nI'm well aware of the reason for this policy being suggested and the\npotential pinning attack vector for LN and other smart contracts, but I\nthink these two risks/costs need to be weighed against eachother first and\nthoroughly discussed because the costs are non-trivial on both sides.\n\nSidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\nAfter interacting with users during high-fee periods I've come to not\nappreciate RBF as a solution to that issue. Most users (80% or so) simply\ndon't have access to that functionality, because their wallet doesn't\nsupport it, or they use a custodial (exchange) wallet etc. Of those that\nhave the feature - only the power users understand how RBF works, and\nexplaining how to do RBF to a non-power-user is just too complex, for the\nsame reason why it's complex for wallets to make sensible non-power-user UI\naround it. Current equilibrium is that mostly only power users have access\nto RBF and they know how to handle it, so things are somewhat working. But\nrolling this out to the broad market is something else and would likely\ncause more confusion.\nCPFP is somewhat more viable but also not perfect as it would require lots\nof edge case code to handle abuse vectors: What if users abuse a generous\nCPFP policy to unstuck past transactions or consolidate large wallets. Best\nis for CPFP to be done on the wallet side, not the merchant side, but there\ntoo are the same UX issues as with RBF.\nIn the end a risk-based approach to decide on which payments are\nnon-trivial to reverse is the easiest, taking account user experience and\nsuch. Remember that in the fiat world card payments have up to 5%\nchargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n1 in a million\" accepted transactions successfully reversed. These days we\nhave very few support issues related to bitcoin payments. The few that do\ncome in are due to accidental RBF users venting frustration about waiting\nfor their tx to confirm.\n\"In theory, theory and practice are the same. In practice, they are not\"\n\nAll the best,\nSergej Kotliar\nCEO Bitrefill.com\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/cda936ac/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-10-19T14:45:44",
                "message_text_only": "> Currently Lightning is somewhere around 15% of our total bitcoin\npayments. This is very much not nothing, and all of us here want Lightning\nto grow, but I think it warrants a serious discussion on whether we want\nLightning adoption to go to 100% by means of disabling on-chain commerce.\n\nIs this about disabling \"on-chain instant commerce\"?\n\n - Waiting for confirmation on-chain before shipping a product won't\nchange, normally it's 15 minutes or so.  This doesn't change that.\n\n - An easy way to cancel/rbf a transaction doesn't exist - like you said,\nthere's no UX for this now, and I don't anticipate one being broadly used\nexcept by inter-exchange transfers, etc.\n\nSo what does this change?\n\n - In the rare event that an RBF transaction is received where the fee\nlevel means confirmation times will be slow a merchant will have to wait\nvery long for at least 1 confirmation, the merchant should alert the user\nthat the transaction may take longer than the BTC FX rate guarantee window,\nand may require additional funds if FX rates change.\n\n - Users with wallets that support RBF can now be encouraged to accelerate\nthe tx, with help and advice depending on their wallet, in order to lock in\nthe FX rates\n\n - 0 conf is still viable strategy for releasing an order, as long as fees\nare very high, and it's very likely to be included in the next block.\n More fee analysis is needed to validate 0 conf and mitigate risks, but now\nit is, at least, more \"honest\" to the true risks.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/2a1058ab/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-19T15:43:28",
                "message_text_only": "If they do this to you, and the delta is substantial, can't you sweep all\nsuch abusers with a cpfp transaction replacing their package and giving you\nthe original txn?\n\nOn Wed, Oct 19, 2022, 7:33 AM Sergej Kotliar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Chiming in on this thread as I feel like the real dangers of RBF as\n> default policy aren't sufficiently elaborated here. It's not only about the\n> zero-conf (I'll get to that) but there is an even bigger danger called the\n> american call option, which risks endangering the entirety of BIP21 \"Scan\n> this QR code with your wallet to buy this product\" model that I believe\n> we've all come to appreciate. Specifically, in a scenario with high\n> volatility and many transactions in the mempools (which is where RBF would\n> come in handy), a user can make a low-fee transaction and then wait for\n> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n> up, user can cancel his transaction and make a new - cheaper one. The\n> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> (it's actually quite easily managed), it's FX risk as the merchant must\n> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> some transactions lose money to FX and others earn money - that evens out\n> in the end. But if there is an _easily accessible in the wallet_ feature to\n> \"cancel transaction\" that means it will eventually get systematically\n> abused. A risk of X% loss on many payments that's easy to systematically\n> abuse is more scary than a rare risk of losing 100% of one occasional\n> payment. It's already possible to execute this form of abuse with opt-in\n> RBF, which may lead to us at some point refusing those payments (even with\n> confirmation) or cumbersome UX to work around it, such as crediting the\n> bitcoin to a custodial account.\n>\n> To compare zeroconf risk with FX risk: I think we've had one incident in 8\n> years of operation where a user successfully fooled our server to accept a\n> payment that in the end didn't confirm. To successfully fool (non-RBF)\n> zeroconf one needs to have access to mining infrastructure and probability\n> of success is the % of hash rate controlled. This is simply due to the fact\n> that the network currently won't propagage the replacement transaction to\n> the miner, which is what's being discussed here. American call option risk\n> would however be available to 100% of all users, needs nothing beyond the\n> wallet app, and has no cost to the user - only upside.\n>\n> Bitrefill currently processes 1500-2000 onchain payments every day. For\n> us, a world where bitcoin becomes de facto RBF by default, means that we\n> would likely turn off the BIP21 model for onchain payments, instruct\n> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n> account that we have.\n> This option is however not available for your typical\n> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n> from other merchants or payment providers how they see this new behavior\n> and how they would counteract it.\n>\n> Currently Lightning is somewhere around 15% of our total bitcoin payments.\n> This is very much not nothing, and all of us here want Lightning to grow,\n> but I think it warrants a serious discussion on whether we want Lightning\n> adoption to go to 100% by means of disabling on-chain commerce. For me\n> personally it would be an easier discussion to have when Lightning is at\n> 80%+ of all bitcoin transactions. Currently far too many bitcoin users\n> simply don't have access to Lightning, and of those that do and hold their\n> own keys Muun is the biggest wallet per our data, not least due to their\n> ease-of-use which is under threat per the OP. It's hard to assess how many\n> users would switch to Lightning in such a scenario, the communication\n> around it would be hard. My intuition says that the majority of the current\n> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n> probably shift to an alt. The benefits of Lightning are many and obvious,\n> we don't need to limit onchain to make Lightning more appealing. As an\n> anecdote, we did experiment with defaulting to bech32 addresses some years\n> back. The result was that simply users of the wallets that weren't able to\n> pay to bech32 didn't complete the purchase, no support ticket or anything,\n> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n> implemented a wallet selector to allow modern wallets to pay to bech32\n> while other wallets can pay to P2SH. This type of thing  is clunky, and\n> requires a certain level of scale to be able to do, we certainly wouldn't\n> have had the manpower for that when we were starting out. This why I'm\n> cautious about introducing more such clunkiness vectors as they are\n> centralizing factors.\n>\n> I'm well aware of the reason for this policy being suggested and the\n> potential pinning attack vector for LN and other smart contracts, but I\n> think these two risks/costs need to be weighed against eachother first and\n> thoroughly discussed because the costs are non-trivial on both sides.\n>\n> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n> After interacting with users during high-fee periods I've come to not\n> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n> don't have access to that functionality, because their wallet doesn't\n> support it, or they use a custodial (exchange) wallet etc. Of those that\n> have the feature - only the power users understand how RBF works, and\n> explaining how to do RBF to a non-power-user is just too complex, for the\n> same reason why it's complex for wallets to make sensible non-power-user UI\n> around it. Current equilibrium is that mostly only power users have access\n> to RBF and they know how to handle it, so things are somewhat working. But\n> rolling this out to the broad market is something else and would likely\n> cause more confusion.\n> CPFP is somewhat more viable but also not perfect as it would require lots\n> of edge case code to handle abuse vectors: What if users abuse a generous\n> CPFP policy to unstuck past transactions or consolidate large wallets. Best\n> is for CPFP to be done on the wallet side, not the merchant side, but there\n> too are the same UX issues as with RBF.\n> In the end a risk-based approach to decide on which payments are\n> non-trivial to reverse is the easiest, taking account user experience and\n> such. Remember that in the fiat world card payments have up to 5%\n> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n> 1 in a million\" accepted transactions successfully reversed. These days we\n> have very few support issues related to bitcoin payments. The few that do\n> come in are due to accidental RBF users venting frustration about waiting\n> for their tx to confirm.\n> \"In theory, theory and practice are the same. In practice, they are not\"\n>\n> All the best,\n> Sergej Kotliar\n> CEO Bitrefill.com\n>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/bb48f09b/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-19T15:51:41",
                "message_text_only": "Isn't the extreme of this that the merchant tries to lock in gains on the\nupswing via CPFP, and users on the downswing, both doing scorched earth,\ntossing the delta to fees?\n\nSeems like a MAD situation?\n\nOn Wed, Oct 19, 2022 at 11:44 AM Jeremy Rubin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> If they do this to you, and the delta is substantial, can't you sweep all\n> such abusers with a cpfp transaction replacing their package and giving you\n> the original txn?\n>\n> On Wed, Oct 19, 2022, 7:33 AM Sergej Kotliar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> Chiming in on this thread as I feel like the real dangers of RBF as\n>> default policy aren't sufficiently elaborated here. It's not only about the\n>> zero-conf (I'll get to that) but there is an even bigger danger called the\n>> american call option, which risks endangering the entirety of BIP21 \"Scan\n>> this QR code with your wallet to buy this product\" model that I believe\n>> we've all come to appreciate. Specifically, in a scenario with high\n>> volatility and many transactions in the mempools (which is where RBF would\n>> come in handy), a user can make a low-fee transaction and then wait for\n>> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n>> up, user can cancel his transaction and make a new - cheaper one. The\n>> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>> (it's actually quite easily managed), it's FX risk as the merchant must\n>> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>> some transactions lose money to FX and others earn money - that evens out\n>> in the end. But if there is an _easily accessible in the wallet_ feature to\n>> \"cancel transaction\" that means it will eventually get systematically\n>> abused. A risk of X% loss on many payments that's easy to systematically\n>> abuse is more scary than a rare risk of losing 100% of one occasional\n>> payment. It's already possible to execute this form of abuse with opt-in\n>> RBF, which may lead to us at some point refusing those payments (even with\n>> confirmation) or cumbersome UX to work around it, such as crediting the\n>> bitcoin to a custodial account.\n>>\n>> To compare zeroconf risk with FX risk: I think we've had one incident in\n>> 8 years of operation where a user successfully fooled our server to accept\n>> a payment that in the end didn't confirm. To successfully fool (non-RBF)\n>> zeroconf one needs to have access to mining infrastructure and probability\n>> of success is the % of hash rate controlled. This is simply due to the fact\n>> that the network currently won't propagage the replacement transaction to\n>> the miner, which is what's being discussed here. American call option risk\n>> would however be available to 100% of all users, needs nothing beyond the\n>> wallet app, and has no cost to the user - only upside.\n>>\n>> Bitrefill currently processes 1500-2000 onchain payments every day. For\n>> us, a world where bitcoin becomes de facto RBF by default, means that we\n>> would likely turn off the BIP21 model for onchain payments, instruct\n>> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n>> account that we have.\n>> This option is however not available for your typical\n>> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n>> from other merchants or payment providers how they see this new behavior\n>> and how they would counteract it.\n>>\n>> Currently Lightning is somewhere around 15% of our total bitcoin\n>> payments. This is very much not nothing, and all of us here want Lightning\n>> to grow, but I think it warrants a serious discussion on whether we want\n>> Lightning adoption to go to 100% by means of disabling on-chain commerce.\n>> For me personally it would be an easier discussion to have when Lightning\n>> is at 80%+ of all bitcoin transactions. Currently far too many bitcoin\n>> users simply don't have access to Lightning, and of those that do and hold\n>> their own keys Muun is the biggest wallet per our data, not least due to\n>> their ease-of-use which is under threat per the OP. It's hard to assess how\n>> many users would switch to Lightning in such a scenario, the communication\n>> around it would be hard. My intuition says that the majority of the current\n>> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n>> probably shift to an alt. The benefits of Lightning are many and obvious,\n>> we don't need to limit onchain to make Lightning more appealing. As an\n>> anecdote, we did experiment with defaulting to bech32 addresses some years\n>> back. The result was that simply users of the wallets that weren't able to\n>> pay to bech32 didn't complete the purchase, no support ticket or anything,\n>> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n>> implemented a wallet selector to allow modern wallets to pay to bech32\n>> while other wallets can pay to P2SH. This type of thing  is clunky, and\n>> requires a certain level of scale to be able to do, we certainly wouldn't\n>> have had the manpower for that when we were starting out. This why I'm\n>> cautious about introducing more such clunkiness vectors as they are\n>> centralizing factors.\n>>\n>> I'm well aware of the reason for this policy being suggested and the\n>> potential pinning attack vector for LN and other smart contracts, but I\n>> think these two risks/costs need to be weighed against eachother first and\n>> thoroughly discussed because the costs are non-trivial on both sides.\n>>\n>> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>> After interacting with users during high-fee periods I've come to not\n>> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n>> don't have access to that functionality, because their wallet doesn't\n>> support it, or they use a custodial (exchange) wallet etc. Of those that\n>> have the feature - only the power users understand how RBF works, and\n>> explaining how to do RBF to a non-power-user is just too complex, for the\n>> same reason why it's complex for wallets to make sensible non-power-user UI\n>> around it. Current equilibrium is that mostly only power users have access\n>> to RBF and they know how to handle it, so things are somewhat working. But\n>> rolling this out to the broad market is something else and would likely\n>> cause more confusion.\n>> CPFP is somewhat more viable but also not perfect as it would require\n>> lots of edge case code to handle abuse vectors: What if users abuse a\n>> generous CPFP policy to unstuck past transactions or consolidate large\n>> wallets. Best is for CPFP to be done on the wallet side, not the merchant\n>> side, but there too are the same UX issues as with RBF.\n>> In the end a risk-based approach to decide on which payments are\n>> non-trivial to reverse is the easiest, taking account user experience and\n>> such. Remember that in the fiat world card payments have up to 5%\n>> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n>> 1 in a million\" accepted transactions successfully reversed. These days we\n>> have very few support issues related to bitcoin payments. The few that do\n>> come in are due to accidental RBF users venting frustration about waiting\n>> for their tx to confirm.\n>> \"In theory, theory and practice are the same. In practice, they are not\"\n>>\n>> All the best,\n>> Sergej Kotliar\n>> CEO Bitrefill.com\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/b5acb142/attachment-0001.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-19T16:04:30",
                "message_text_only": "It's an interesting idea, presumably it would work w the new package relay.\nScorched earth bidding war is definitely fine to deter this type of abuse.\nNeed to consider it more thoroughly from all sides tho. CPFP on the server\nside generally has a couple of downsides:\n* Requires a hot wallet to receive bitcoin\n* an entity that is reliably known to do CPFP can be abused by people\nlooking to consolidate utxos, which can be quite costly. Might be solvable\nwith a set of conditionals, and bad UX for abusers is less of a concern :)\n\nWill follow up after more deliberation, thanks!\n\n\nOn Wed, 19 Oct 2022 at 17:43, Jeremy Rubin <jeremy.l.rubin at gmail.com> wrote:\n\n> If they do this to you, and the delta is substantial, can't you sweep all\n> such abusers with a cpfp transaction replacing their package and giving you\n> the original txn?\n>\n> On Wed, Oct 19, 2022, 7:33 AM Sergej Kotliar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi all,\n>>\n>> Chiming in on this thread as I feel like the real dangers of RBF as\n>> default policy aren't sufficiently elaborated here. It's not only about the\n>> zero-conf (I'll get to that) but there is an even bigger danger called the\n>> american call option, which risks endangering the entirety of BIP21 \"Scan\n>> this QR code with your wallet to buy this product\" model that I believe\n>> we've all come to appreciate. Specifically, in a scenario with high\n>> volatility and many transactions in the mempools (which is where RBF would\n>> come in handy), a user can make a low-fee transaction and then wait for\n>> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n>> up, user can cancel his transaction and make a new - cheaper one. The\n>> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>> (it's actually quite easily managed), it's FX risk as the merchant must\n>> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>> some transactions lose money to FX and others earn money - that evens out\n>> in the end. But if there is an _easily accessible in the wallet_ feature to\n>> \"cancel transaction\" that means it will eventually get systematically\n>> abused. A risk of X% loss on many payments that's easy to systematically\n>> abuse is more scary than a rare risk of losing 100% of one occasional\n>> payment. It's already possible to execute this form of abuse with opt-in\n>> RBF, which may lead to us at some point refusing those payments (even with\n>> confirmation) or cumbersome UX to work around it, such as crediting the\n>> bitcoin to a custodial account.\n>>\n>> To compare zeroconf risk with FX risk: I think we've had one incident in\n>> 8 years of operation where a user successfully fooled our server to accept\n>> a payment that in the end didn't confirm. To successfully fool (non-RBF)\n>> zeroconf one needs to have access to mining infrastructure and probability\n>> of success is the % of hash rate controlled. This is simply due to the fact\n>> that the network currently won't propagage the replacement transaction to\n>> the miner, which is what's being discussed here. American call option risk\n>> would however be available to 100% of all users, needs nothing beyond the\n>> wallet app, and has no cost to the user - only upside.\n>>\n>> Bitrefill currently processes 1500-2000 onchain payments every day. For\n>> us, a world where bitcoin becomes de facto RBF by default, means that we\n>> would likely turn off the BIP21 model for onchain payments, instruct\n>> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n>> account that we have.\n>> This option is however not available for your typical\n>> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n>> from other merchants or payment providers how they see this new behavior\n>> and how they would counteract it.\n>>\n>> Currently Lightning is somewhere around 15% of our total bitcoin\n>> payments. This is very much not nothing, and all of us here want Lightning\n>> to grow, but I think it warrants a serious discussion on whether we want\n>> Lightning adoption to go to 100% by means of disabling on-chain commerce.\n>> For me personally it would be an easier discussion to have when Lightning\n>> is at 80%+ of all bitcoin transactions. Currently far too many bitcoin\n>> users simply don't have access to Lightning, and of those that do and hold\n>> their own keys Muun is the biggest wallet per our data, not least due to\n>> their ease-of-use which is under threat per the OP. It's hard to assess how\n>> many users would switch to Lightning in such a scenario, the communication\n>> around it would be hard. My intuition says that the majority of the current\n>> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n>> probably shift to an alt. The benefits of Lightning are many and obvious,\n>> we don't need to limit onchain to make Lightning more appealing. As an\n>> anecdote, we did experiment with defaulting to bech32 addresses some years\n>> back. The result was that simply users of the wallets that weren't able to\n>> pay to bech32 didn't complete the purchase, no support ticket or anything,\n>> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n>> implemented a wallet selector to allow modern wallets to pay to bech32\n>> while other wallets can pay to P2SH. This type of thing  is clunky, and\n>> requires a certain level of scale to be able to do, we certainly wouldn't\n>> have had the manpower for that when we were starting out. This why I'm\n>> cautious about introducing more such clunkiness vectors as they are\n>> centralizing factors.\n>>\n>> I'm well aware of the reason for this policy being suggested and the\n>> potential pinning attack vector for LN and other smart contracts, but I\n>> think these two risks/costs need to be weighed against eachother first and\n>> thoroughly discussed because the costs are non-trivial on both sides.\n>>\n>> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>> After interacting with users during high-fee periods I've come to not\n>> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n>> don't have access to that functionality, because their wallet doesn't\n>> support it, or they use a custodial (exchange) wallet etc. Of those that\n>> have the feature - only the power users understand how RBF works, and\n>> explaining how to do RBF to a non-power-user is just too complex, for the\n>> same reason why it's complex for wallets to make sensible non-power-user UI\n>> around it. Current equilibrium is that mostly only power users have access\n>> to RBF and they know how to handle it, so things are somewhat working. But\n>> rolling this out to the broad market is something else and would likely\n>> cause more confusion.\n>> CPFP is somewhat more viable but also not perfect as it would require\n>> lots of edge case code to handle abuse vectors: What if users abuse a\n>> generous CPFP policy to unstuck past transactions or consolidate large\n>> wallets. Best is for CPFP to be done on the wallet side, not the merchant\n>> side, but there too are the same UX issues as with RBF.\n>> In the end a risk-based approach to decide on which payments are\n>> non-trivial to reverse is the easiest, taking account user experience and\n>> such. Remember that in the fiat world card payments have up to 5%\n>> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n>> 1 in a million\" accepted transactions successfully reversed. These days we\n>> have very few support issues related to bitcoin payments. The few that do\n>> come in are due to accidental RBF users venting frustration about waiting\n>> for their tx to confirm.\n>> \"In theory, theory and practice are the same. In practice, they are not\"\n>>\n>> All the best,\n>> Sergej Kotliar\n>> CEO Bitrefill.com\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/5f136073/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-19T16:08:19",
                "message_text_only": "Another downside is that the sender may not opt into a non-pinnable future\nformat like \"V3 transactions\", making CPFP difficult. They may spend a lot\nof fees to do this however, so maybe we're really reaching here.\n\nOn Wed, Oct 19, 2022 at 12:07 PM Sergej Kotliar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> It's an interesting idea, presumably it would work w the new package relay.\n> Scorched earth bidding war is definitely fine to deter this type of abuse.\n> Need to consider it more thoroughly from all sides tho. CPFP on the server\n> side generally has a couple of downsides:\n> * Requires a hot wallet to receive bitcoin\n> * an entity that is reliably known to do CPFP can be abused by people\n> looking to consolidate utxos, which can be quite costly. Might be solvable\n> with a set of conditionals, and bad UX for abusers is less of a concern :)\n>\n> Will follow up after more deliberation, thanks!\n>\n>\n> On Wed, 19 Oct 2022 at 17:43, Jeremy Rubin <jeremy.l.rubin at gmail.com>\n> wrote:\n>\n>> If they do this to you, and the delta is substantial, can't you sweep all\n>> such abusers with a cpfp transaction replacing their package and giving you\n>> the original txn?\n>>\n>> On Wed, Oct 19, 2022, 7:33 AM Sergej Kotliar via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi all,\n>>>\n>>> Chiming in on this thread as I feel like the real dangers of RBF as\n>>> default policy aren't sufficiently elaborated here. It's not only about the\n>>> zero-conf (I'll get to that) but there is an even bigger danger called the\n>>> american call option, which risks endangering the entirety of BIP21 \"Scan\n>>> this QR code with your wallet to buy this product\" model that I believe\n>>> we've all come to appreciate. Specifically, in a scenario with high\n>>> volatility and many transactions in the mempools (which is where RBF would\n>>> come in handy), a user can make a low-fee transaction and then wait for\n>>> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n>>> up, user can cancel his transaction and make a new - cheaper one. The\n>>> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>>> (it's actually quite easily managed), it's FX risk as the merchant must\n>>> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>>> some transactions lose money to FX and others earn money - that evens out\n>>> in the end. But if there is an _easily accessible in the wallet_ feature to\n>>> \"cancel transaction\" that means it will eventually get systematically\n>>> abused. A risk of X% loss on many payments that's easy to systematically\n>>> abuse is more scary than a rare risk of losing 100% of one occasional\n>>> payment. It's already possible to execute this form of abuse with opt-in\n>>> RBF, which may lead to us at some point refusing those payments (even with\n>>> confirmation) or cumbersome UX to work around it, such as crediting the\n>>> bitcoin to a custodial account.\n>>>\n>>> To compare zeroconf risk with FX risk: I think we've had one incident in\n>>> 8 years of operation where a user successfully fooled our server to accept\n>>> a payment that in the end didn't confirm. To successfully fool (non-RBF)\n>>> zeroconf one needs to have access to mining infrastructure and probability\n>>> of success is the % of hash rate controlled. This is simply due to the fact\n>>> that the network currently won't propagage the replacement transaction to\n>>> the miner, which is what's being discussed here. American call option risk\n>>> would however be available to 100% of all users, needs nothing beyond the\n>>> wallet app, and has no cost to the user - only upside.\n>>>\n>>> Bitrefill currently processes 1500-2000 onchain payments every day. For\n>>> us, a world where bitcoin becomes de facto RBF by default, means that we\n>>> would likely turn off the BIP21 model for onchain payments, instruct\n>>> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n>>> account that we have.\n>>> This option is however not available for your typical\n>>> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n>>> from other merchants or payment providers how they see this new behavior\n>>> and how they would counteract it.\n>>>\n>>> Currently Lightning is somewhere around 15% of our total bitcoin\n>>> payments. This is very much not nothing, and all of us here want Lightning\n>>> to grow, but I think it warrants a serious discussion on whether we want\n>>> Lightning adoption to go to 100% by means of disabling on-chain commerce.\n>>> For me personally it would be an easier discussion to have when Lightning\n>>> is at 80%+ of all bitcoin transactions. Currently far too many bitcoin\n>>> users simply don't have access to Lightning, and of those that do and hold\n>>> their own keys Muun is the biggest wallet per our data, not least due to\n>>> their ease-of-use which is under threat per the OP. It's hard to assess how\n>>> many users would switch to Lightning in such a scenario, the communication\n>>> around it would be hard. My intuition says that the majority of the current\n>>> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n>>> probably shift to an alt. The benefits of Lightning are many and obvious,\n>>> we don't need to limit onchain to make Lightning more appealing. As an\n>>> anecdote, we did experiment with defaulting to bech32 addresses some years\n>>> back. The result was that simply users of the wallets that weren't able to\n>>> pay to bech32 didn't complete the purchase, no support ticket or anything,\n>>> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n>>> implemented a wallet selector to allow modern wallets to pay to bech32\n>>> while other wallets can pay to P2SH. This type of thing  is clunky, and\n>>> requires a certain level of scale to be able to do, we certainly wouldn't\n>>> have had the manpower for that when we were starting out. This why I'm\n>>> cautious about introducing more such clunkiness vectors as they are\n>>> centralizing factors.\n>>>\n>>> I'm well aware of the reason for this policy being suggested and the\n>>> potential pinning attack vector for LN and other smart contracts, but I\n>>> think these two risks/costs need to be weighed against eachother first and\n>>> thoroughly discussed because the costs are non-trivial on both sides.\n>>>\n>>> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>>> After interacting with users during high-fee periods I've come to not\n>>> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n>>> don't have access to that functionality, because their wallet doesn't\n>>> support it, or they use a custodial (exchange) wallet etc. Of those that\n>>> have the feature - only the power users understand how RBF works, and\n>>> explaining how to do RBF to a non-power-user is just too complex, for the\n>>> same reason why it's complex for wallets to make sensible non-power-user UI\n>>> around it. Current equilibrium is that mostly only power users have access\n>>> to RBF and they know how to handle it, so things are somewhat working. But\n>>> rolling this out to the broad market is something else and would likely\n>>> cause more confusion.\n>>> CPFP is somewhat more viable but also not perfect as it would require\n>>> lots of edge case code to handle abuse vectors: What if users abuse a\n>>> generous CPFP policy to unstuck past transactions or consolidate large\n>>> wallets. Best is for CPFP to be done on the wallet side, not the merchant\n>>> side, but there too are the same UX issues as with RBF.\n>>> In the end a risk-based approach to decide on which payments are\n>>> non-trivial to reverse is the easiest, taking account user experience and\n>>> such. Remember that in the fiat world card payments have up to 5%\n>>> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n>>> 1 in a million\" accepted transactions successfully reversed. These days we\n>>> have very few support issues related to bitcoin payments. The few that do\n>>> come in are due to accidental RBF users venting frustration about waiting\n>>> for their tx to confirm.\n>>> \"In theory, theory and practice are the same. In practice, they are not\"\n>>>\n>>> All the best,\n>>> Sergej Kotliar\n>>> CEO Bitrefill.com\n>>>\n>>>\n>>> --\n>>>\n>>> Sergej Kotliar\n>>>\n>>> CEO\n>>>\n>>>\n>>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>>\n>>>\n>>> www.bitrefill.com\n>>>\n>>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>>> <https://www.bitrefill.com/blog/> | Angellist\n>>> <https://angel.co/bitrefill>\n>>>\n>>>\n>>> --\n>>>\n>>> Sergej Kotliar\n>>>\n>>> CEO\n>>>\n>>>\n>>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>>\n>>>\n>>> www.bitrefill.com\n>>>\n>>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>>> <https://www.bitrefill.com/blog/> | Angellist\n>>> <https://angel.co/bitrefill>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/f0fed178/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-20T01:37:25",
                "message_text_only": "Hi Sergej,\n\nThanks for the insightful posting, especially highlighting the FX risk\nwhich was far from being evident on my side!\n\nI don't know in details the security architecture of Bitrefill zeroconf\nacceptance system, though from what I suppose there is at least a set of\nfull-nodes well-connected across the p2p network, on top of which some\nmempools reconciliation is exercised\nand zeroconf candidate sanitize against. While I believe this is a far-more\nrobust deployment against double-spend attempts, there is still the ability\nfor a sophisticated attacker to \"taint\" miner mempools, and from then\npartition judiciously the transaction-relay network to game such\ndistributed mempool monitoring system. There is also the possibility of an\nattacker using some \"divide-and-conquer\" transaction broadcast algorithm to\nmap Bitrefill monitoring point, though as far as I'm aware such algorithm\nhas not been discussed. I agree with all of that, easier said than done.\n\n(Which let me think that such distributed mempool monitoring system should\nbe provide some enhanced security even in a full-rbf world, that they would\nrequire far more resources than the average node from the p2p network as a\nwhole might be a counter-argument for their social acceptance, however I'm\nalso thinking that a robust Lightning infrastructure of the future might\nrequire multiple mempool/transaction-relay endpoints, at least to reduce\ncross-layer mapping links, though conversation for another day...).\n\nAbout the FX risk itself, this is far from being isolated from 0conf, as\nLightning payments themselves might still have a time lapse between the\nissuance of invoices and the settlement of the HTLC at the payee endpoint.\nIn fact this volatility concern is endured by anyone using Bitcoin\nregularly in interface with the fiats worlds, i.e everyone excepted the\nlong-term store of wealth crowd. From a merchant perspective, effectively,\nthe options to cover themselves against this risk are simple. One could\ntake positions directly in traditional financial derivatives, like doing\nparticipants in international trades, though it would require an educated\nmanpower on the merchant side. Or leveraging some stablecoins derivatives\nsystem, coming with its own technical complexity and social trust hazards.\nAnother direction would be to clearly define the responsibility between\nmerchants or users, on whom is the FX risk. If it's on users, they should\nbe the one RBFing/CPFPing to increase the merchant address output, beyond\nthe fact \"dynamic pricing\" would be a weird UX, it would require liveliness\nfrom the wallets until block confirmation (introducing here many\nrequirements of a LN wallet). If it's on the merchants, they could be the\nones CPFPing thanks to package relay, though it would come again with some\nengineering complexity and overhead blockspace cost (and the first version\nof package relay likely won't enable CPFP batching for concerns of\npotential bandwidth/CPU DoS).\n\nOn the efficacy of RBF, I understand the current approach of assuming\n\"manual\" RBFing by power users ill UX thinking. I hope in the future to\nhave automatic fee-bumping implemented by user wallets, where a fee-bumping\nbudget and a confirmation preference are pre-defined for all payments, and\nthe fee-bumping logic \"simply\" enforcing the user policy, ideally based on\nhistorical mempool data. True fact: we don't have such logic in consumer\nwallets today. Or at least only rudimentary in the backend of LN\nimplementations, and only for time-sensitive on-chain claims for now (or at\nleast speaking for LDK). If we take the history of browsers as a\ncomparison, while we might be out of the Lynx-style phase of wallets, we\nmight still be more in the late Netscape kind of thing than something like\nChrome today. In other words, there are many directions for improvements\nfor users' wallets.\n\nAll that said, I learn to converge that as a community we would be better\noff to weigh deeper the risks/costs between 0confs applications and\ncontracting protocols in light of full-rbf.\n\nBest,\nAntoine\n\nLe mer. 19 oct. 2022 \u00e0 10:33, Sergej Kotliar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hi all,\n>\n> Chiming in on this thread as I feel like the real dangers of RBF as\n> default policy aren't sufficiently elaborated here. It's not only about the\n> zero-conf (I'll get to that) but there is an even bigger danger called the\n> american call option, which risks endangering the entirety of BIP21 \"Scan\n> this QR code with your wallet to buy this product\" model that I believe\n> we've all come to appreciate. Specifically, in a scenario with high\n> volatility and many transactions in the mempools (which is where RBF would\n> come in handy), a user can make a low-fee transaction and then wait for\n> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n> up, user can cancel his transaction and make a new - cheaper one. The\n> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> (it's actually quite easily managed), it's FX risk as the merchant must\n> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> some transactions lose money to FX and others earn money - that evens out\n> in the end. But if there is an _easily accessible in the wallet_ feature to\n> \"cancel transaction\" that means it will eventually get systematically\n> abused. A risk of X% loss on many payments that's easy to systematically\n> abuse is more scary than a rare risk of losing 100% of one occasional\n> payment. It's already possible to execute this form of abuse with opt-in\n> RBF, which may lead to us at some point refusing those payments (even with\n> confirmation) or cumbersome UX to work around it, such as crediting the\n> bitcoin to a custodial account.\n>\n> To compare zeroconf risk with FX risk: I think we've had one incident in 8\n> years of operation where a user successfully fooled our server to accept a\n> payment that in the end didn't confirm. To successfully fool (non-RBF)\n> zeroconf one needs to have access to mining infrastructure and probability\n> of success is the % of hash rate controlled. This is simply due to the fact\n> that the network currently won't propagage the replacement transaction to\n> the miner, which is what's being discussed here. American call option risk\n> would however be available to 100% of all users, needs nothing beyond the\n> wallet app, and has no cost to the user - only upside.\n>\n> Bitrefill currently processes 1500-2000 onchain payments every day. For\n> us, a world where bitcoin becomes de facto RBF by default, means that we\n> would likely turn off the BIP21 model for onchain payments, instruct\n> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n> account that we have.\n> This option is however not available for your typical\n> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n> from other merchants or payment providers how they see this new behavior\n> and how they would counteract it.\n>\n> Currently Lightning is somewhere around 15% of our total bitcoin payments.\n> This is very much not nothing, and all of us here want Lightning to grow,\n> but I think it warrants a serious discussion on whether we want Lightning\n> adoption to go to 100% by means of disabling on-chain commerce. For me\n> personally it would be an easier discussion to have when Lightning is at\n> 80%+ of all bitcoin transactions. Currently far too many bitcoin users\n> simply don't have access to Lightning, and of those that do and hold their\n> own keys Muun is the biggest wallet per our data, not least due to their\n> ease-of-use which is under threat per the OP. It's hard to assess how many\n> users would switch to Lightning in such a scenario, the communication\n> around it would be hard. My intuition says that the majority of the current\n> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n> probably shift to an alt. The benefits of Lightning are many and obvious,\n> we don't need to limit onchain to make Lightning more appealing. As an\n> anecdote, we did experiment with defaulting to bech32 addresses some years\n> back. The result was that simply users of the wallets that weren't able to\n> pay to bech32 didn't complete the purchase, no support ticket or anything,\n> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n> implemented a wallet selector to allow modern wallets to pay to bech32\n> while other wallets can pay to P2SH. This type of thing  is clunky, and\n> requires a certain level of scale to be able to do, we certainly wouldn't\n> have had the manpower for that when we were starting out. This why I'm\n> cautious about introducing more such clunkiness vectors as they are\n> centralizing factors.\n>\n> I'm well aware of the reason for this policy being suggested and the\n> potential pinning attack vector for LN and other smart contracts, but I\n> think these two risks/costs need to be weighed against eachother first and\n> thoroughly discussed because the costs are non-trivial on both sides.\n>\n> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n> After interacting with users during high-fee periods I've come to not\n> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n> don't have access to that functionality, because their wallet doesn't\n> support it, or they use a custodial (exchange) wallet etc. Of those that\n> have the feature - only the power users understand how RBF works, and\n> explaining how to do RBF to a non-power-user is just too complex, for the\n> same reason why it's complex for wallets to make sensible non-power-user UI\n> around it. Current equilibrium is that mostly only power users have access\n> to RBF and they know how to handle it, so things are somewhat working. But\n> rolling this out to the broad market is something else and would likely\n> cause more confusion.\n> CPFP is somewhat more viable but also not perfect as it would require lots\n> of edge case code to handle abuse vectors: What if users abuse a generous\n> CPFP policy to unstuck past transactions or consolidate large wallets. Best\n> is for CPFP to be done on the wallet side, not the merchant side, but there\n> too are the same UX issues as with RBF.\n> In the end a risk-based approach to decide on which payments are\n> non-trivial to reverse is the easiest, taking account user experience and\n> such. Remember that in the fiat world card payments have up to 5%\n> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n> 1 in a million\" accepted transactions successfully reversed. These days we\n> have very few support issues related to bitcoin payments. The few that do\n> come in are due to accidental RBF users venting frustration about waiting\n> for their tx to confirm.\n> \"In theory, theory and practice are the same. In practice, they are not\"\n>\n> All the best,\n> Sergej Kotliar\n> CEO Bitrefill.com\n>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/5d40738b/attachment-0001.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-20T14:11:48",
                "message_text_only": "On Thu, 20 Oct 2022 at 03:37, Antoine Riard <antoine.riard at gmail.com> wrote:\n\n> Hi Sergej,\n>\n> Thanks for the insightful posting, especially highlighting the FX risk\n> which was far from being evident on my side!\n>\n> I don't know in details the security architecture of Bitrefill zeroconf\n> acceptance system, though from what I suppose there is at least a set of\n> full-nodes well-connected across the p2p network, on top of which some\n> mempools reconciliation is exercised\n> and zeroconf candidate sanitize against. While I believe this is a\n> far-more robust deployment against double-spend attempts, there is still\n> the ability for a sophisticated attacker to \"taint\" miner mempools, and\n> from then partition judiciously the transaction-relay network to game such\n> distributed mempool monitoring system. There is also the possibility of an\n> attacker using some \"divide-and-conquer\" transaction broadcast algorithm to\n> map Bitrefill monitoring point, though as far as I'm aware such algorithm\n> has not been discussed. I agree with all of that, easier said than done.\n>\n\nThere is a long list of countermeasures that can be built to reduce these\nattacks, but to be frank we've only implemented a small subset of these and\nnot had any issues, so even a lower level of security is more than fine\ntoday to have basically zero abuse. If issues arise we could implement more\nof the countermeasures as appropriate to the abuse that has happened in the\nwild.\n\n\n> On the efficacy of RBF, I understand the current approach of assuming\n> \"manual\" RBFing by power users ill UX thinking. I hope in the future to\n> have automatic fee-bumping implemented by user wallets, where a fee-bumping\n> budget and a confirmation preference are pre-defined for all payments, and\n> the fee-bumping logic \"simply\" enforcing the user policy, ideally based on\n> historical mempool data. True fact: we don't have such logic in consumer\n> wallets today.\n>\n\nIn deed. And the vast majority of bitcoin users don't even have access to\nany RBF functionality today, so we're not even seeing gradual development\nof these things yet. I think this fact needs to be taken into account when\ndesigning breaking changes to bitcoin policy. Had these things been in\nplace and widely used the conversation would have been much easier.\n\nFundamentally, my view is that all the UX problems related to RBF alone are\nsufficient of an issue to hold off on rolling out these upgrades for the\nforeseeable future and think of other ways of solving the pinning issue and\nother issues w the current policy. Might be that it's just a fundamental\ngoal conflict that different people want different behavior but I remain\noptimistic for creative solutions from both sides. UX issues are soft as\nopposed to theoretical attack vectors which are hard and binary, we need\nfind a way to weigh \"even though it doesn't happen it can theoretically be\nhacked\" against \"many users find it confusing and stressful\" which is not a\ntrivial assessment to do.\n\nAll that said, I learn to converge that as a community we would be better\n> off to weigh deeper the risks/costs between 0confs applications and\n> contracting protocols in light of full-rbf.\n>\n\nIn deed. And as you wrote in a different message, I agree that it's\nunfortunate that there isn't more interaction between the mailing list and\nservices and companies using this stuff day-to-day. Not that it's anyone's\nfault in particular, let's try from all sides to find more ways to create\nmore interaction on these topics. I've pinged a few colleagues that work on\npayments in the space and hope they will chime in more in this forum!\n\nAll the best,\nSergej\n\n\n> Le mer. 19 oct. 2022 \u00e0 10:33, Sergej Kotliar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Hi all,\n>>\n>> Chiming in on this thread as I feel like the real dangers of RBF as\n>> default policy aren't sufficiently elaborated here. It's not only about the\n>> zero-conf (I'll get to that) but there is an even bigger danger called the\n>> american call option, which risks endangering the entirety of BIP21 \"Scan\n>> this QR code with your wallet to buy this product\" model that I believe\n>> we've all come to appreciate. Specifically, in a scenario with high\n>> volatility and many transactions in the mempools (which is where RBF would\n>> come in handy), a user can make a low-fee transaction and then wait for\n>> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n>> up, user can cancel his transaction and make a new - cheaper one. The\n>> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>> (it's actually quite easily managed), it's FX risk as the merchant must\n>> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>> some transactions lose money to FX and others earn money - that evens out\n>> in the end. But if there is an _easily accessible in the wallet_ feature to\n>> \"cancel transaction\" that means it will eventually get systematically\n>> abused. A risk of X% loss on many payments that's easy to systematically\n>> abuse is more scary than a rare risk of losing 100% of one occasional\n>> payment. It's already possible to execute this form of abuse with opt-in\n>> RBF, which may lead to us at some point refusing those payments (even with\n>> confirmation) or cumbersome UX to work around it, such as crediting the\n>> bitcoin to a custodial account.\n>>\n>> To compare zeroconf risk with FX risk: I think we've had one incident in\n>> 8 years of operation where a user successfully fooled our server to accept\n>> a payment that in the end didn't confirm. To successfully fool (non-RBF)\n>> zeroconf one needs to have access to mining infrastructure and probability\n>> of success is the % of hash rate controlled. This is simply due to the fact\n>> that the network currently won't propagage the replacement transaction to\n>> the miner, which is what's being discussed here. American call option risk\n>> would however be available to 100% of all users, needs nothing beyond the\n>> wallet app, and has no cost to the user - only upside.\n>>\n>> Bitrefill currently processes 1500-2000 onchain payments every day. For\n>> us, a world where bitcoin becomes de facto RBF by default, means that we\n>> would likely turn off the BIP21 model for onchain payments, instruct\n>> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n>> account that we have.\n>> This option is however not available for your typical\n>> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n>> from other merchants or payment providers how they see this new behavior\n>> and how they would counteract it.\n>>\n>> Currently Lightning is somewhere around 15% of our total bitcoin\n>> payments. This is very much not nothing, and all of us here want Lightning\n>> to grow, but I think it warrants a serious discussion on whether we want\n>> Lightning adoption to go to 100% by means of disabling on-chain commerce.\n>> For me personally it would be an easier discussion to have when Lightning\n>> is at 80%+ of all bitcoin transactions. Currently far too many bitcoin\n>> users simply don't have access to Lightning, and of those that do and hold\n>> their own keys Muun is the biggest wallet per our data, not least due to\n>> their ease-of-use which is under threat per the OP. It's hard to assess how\n>> many users would switch to Lightning in such a scenario, the communication\n>> around it would be hard. My intuition says that the majority of the current\n>> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n>> probably shift to an alt. The benefits of Lightning are many and obvious,\n>> we don't need to limit onchain to make Lightning more appealing. As an\n>> anecdote, we did experiment with defaulting to bech32 addresses some years\n>> back. The result was that simply users of the wallets that weren't able to\n>> pay to bech32 didn't complete the purchase, no support ticket or anything,\n>> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n>> implemented a wallet selector to allow modern wallets to pay to bech32\n>> while other wallets can pay to P2SH. This type of thing  is clunky, and\n>> requires a certain level of scale to be able to do, we certainly wouldn't\n>> have had the manpower for that when we were starting out. This why I'm\n>> cautious about introducing more such clunkiness vectors as they are\n>> centralizing factors.\n>>\n>> I'm well aware of the reason for this policy being suggested and the\n>> potential pinning attack vector for LN and other smart contracts, but I\n>> think these two risks/costs need to be weighed against eachother first and\n>> thoroughly discussed because the costs are non-trivial on both sides.\n>>\n>> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>> After interacting with users during high-fee periods I've come to not\n>> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n>> don't have access to that functionality, because their wallet doesn't\n>> support it, or they use a custodial (exchange) wallet etc. Of those that\n>> have the feature - only the power users understand how RBF works, and\n>> explaining how to do RBF to a non-power-user is just too complex, for the\n>> same reason why it's complex for wallets to make sensible non-power-user UI\n>> around it. Current equilibrium is that mostly only power users have access\n>> to RBF and they know how to handle it, so things are somewhat working. But\n>> rolling this out to the broad market is something else and would likely\n>> cause more confusion.\n>> CPFP is somewhat more viable but also not perfect as it would require\n>> lots of edge case code to handle abuse vectors: What if users abuse a\n>> generous CPFP policy to unstuck past transactions or consolidate large\n>> wallets. Best is for CPFP to be done on the wallet side, not the merchant\n>> side, but there too are the same UX issues as with RBF.\n>> In the end a risk-based approach to decide on which payments are\n>> non-trivial to reverse is the easiest, taking account user experience and\n>> such. Remember that in the fiat world card payments have up to 5%\n>> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n>> 1 in a million\" accepted transactions successfully reversed. These days we\n>> have very few support issues related to bitcoin payments. The few that do\n>> come in are due to accidental RBF users venting frustration about waiting\n>> for their tx to confirm.\n>> \"In theory, theory and practice are the same. In practice, they are not\"\n>>\n>> All the best,\n>> Sergej Kotliar\n>> CEO Bitrefill.com\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/dd90d5ad/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-21T01:04:24",
                "message_text_only": "> There is a long list of countermeasures that can be built to reduce these\n> attacks, but to be frank we've only implemented a small subset of these\nand\n> not had any issues, so even a lower level of security is more than fine\n> today to have basically zero abuse. If issues arise we could implement\nmore\n> of the countermeasures as appropriate to the abuse that has happened in\nthe\n> wild.\n\n>From reading one of your other mail, apparently 60% of Bitrefill payments\nare non-rbfable on-chain transactions and as such fine for zeroconf. What\nI'm wondering is, in case of a wide majority of the full-nodes supporting\nfull-rbf, if any incoming transaction traffic could be risk-managed\nwell-enough thanks to some additional countermeasures to be\nzeroconf-acceptable ?\n\nWe can be technically creative here. One could think of some overlay\nmonitoring between zeroconf merchants, where mempooldiffs are exchanged to\nobserve if any acceptance candidate is double-spent inside some other\nparticipant's mempool. Of course, the reconciliation rate would need to be\npretty high to still ensure an \"instant payment\" UX, though the bandwidth\noverhead should be okay as we assume full-node enterprise hosts. I don't\nthink such functionality would be used by any full-node, it might leverage\np2p extensions but it would be some differentiated services on top of the\nusual messages. This is just an idea, and the concrete 0conf acceptance\nflow problem needs to be better specified.\n\n> Fundamentally, my view is that all the UX problems related to RBF alone\nare\n> sufficient of an issue to hold off on rolling out these upgrades for the\n> foreseeable future and think of other ways of solving the pinning issue\nand\n> other issues w the current policy. Might be that it's just a fundamental\n> goal conflict that different people want different behavior but I remain\n> optimistic for creative solutions from both sides. UX issues are soft as\n> opposed to theoretical attack vectors which are hard and binary, we need\n> find a way to weigh \"even though it doesn't happen it can theoretically be\n> hacked\" against \"many users find it confusing and stressful\" which is not\na\n> trivial assessment to do.\n\nSeriously, solving the pinning issues for contracting protocols already\nbusy few of the most brilliant bitcoin developers almost full-time. If we\nhad straightforward and backward compatible with all classes of current\nBitcoin applications, we would go for it. Of course, it doesn't mean we\nshould close the problem of space exploration, and if someone can come up\nwith solutions offering equivalent trade-offs, I'm all to listen. This is\nstill an open question if we would have to allow a subset of transactions\nto be full-rbf, to fully achieve the semantics of v3 transactions, or at\nleast if we would like to protect currently open Lightning channels. Hard\nproblems here.\n\nWhile I'm hearing the uncertainty of an easy assessment weighting between\nfavoring UX issues or solving hard theoretical attacks, those latter\nconcerns I've been serious enough among the Lightning development community\nto take it as one of the top engineering issues among all those last years.\n>From my experience, pentesting in a \"black-box\" fashion of some subset of\nLN vulnerabilities, they turn out as really practical after a few days of\nhacking if you know where to hit. Moreover, it should be underscored that\nthe attacker incentive model between targeting a 0conf merchant like\nBitrefill and a sizable Lightning infrastructure is a bit different. On one\nside, you will pocket free gift cards that are likely traceable to\nreal-world identities, or cancellable by calling out the issuers. On the\nother side, you get a stack of free satoshis, easily fungible among all\nother coins. As such, we might foresee far more exploitations against LN,\nonce the network has caught up in terms of volume and stakes to compare\nwith the most advanced Defi smart contract platforms in the wider\ncryptocurrencies ecosystem, attracting today sophisticated attackers. Or at\nleast, I'm worried by such an outcome playing out for LN if we're too slow\non rolling out mitigations...\n\nAll that said, from my perspective upgrading mempool policy doesn't seem\nincompatible with a parallel effort to improve the UX problems of RBF, by\nautomatic fee-bumping logic in a transparent way for the end-users. Like\nyou said, we should be all optimistic on creative solutions, and\ncommunicate better between merchants and devs on the problem space.\n\nLooking forward to having more interactions on these topics in the future!\n\nBest,\nAntoine\n\nLe jeu. 20 oct. 2022 \u00e0 10:12, Sergej Kotliar <sergej at bitrefill.com> a\n\u00e9crit :\n\n>\n>\n> On Thu, 20 Oct 2022 at 03:37, Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi Sergej,\n>>\n>> Thanks for the insightful posting, especially highlighting the FX risk\n>> which was far from being evident on my side!\n>>\n>> I don't know in details the security architecture of Bitrefill zeroconf\n>> acceptance system, though from what I suppose there is at least a set of\n>> full-nodes well-connected across the p2p network, on top of which some\n>> mempools reconciliation is exercised\n>> and zeroconf candidate sanitize against. While I believe this is a\n>> far-more robust deployment against double-spend attempts, there is still\n>> the ability for a sophisticated attacker to \"taint\" miner mempools, and\n>> from then partition judiciously the transaction-relay network to game such\n>> distributed mempool monitoring system. There is also the possibility of an\n>> attacker using some \"divide-and-conquer\" transaction broadcast algorithm to\n>> map Bitrefill monitoring point, though as far as I'm aware such algorithm\n>> has not been discussed. I agree with all of that, easier said than done.\n>>\n>\n> There is a long list of countermeasures that can be built to reduce these\n> attacks, but to be frank we've only implemented a small subset of these and\n> not had any issues, so even a lower level of security is more than fine\n> today to have basically zero abuse. If issues arise we could implement more\n> of the countermeasures as appropriate to the abuse that has happened in the\n> wild.\n>\n>\n>> On the efficacy of RBF, I understand the current approach of assuming\n>> \"manual\" RBFing by power users ill UX thinking. I hope in the future to\n>> have automatic fee-bumping implemented by user wallets, where a fee-bumping\n>> budget and a confirmation preference are pre-defined for all payments, and\n>> the fee-bumping logic \"simply\" enforcing the user policy, ideally based on\n>> historical mempool data. True fact: we don't have such logic in consumer\n>> wallets today.\n>>\n>\n> In deed. And the vast majority of bitcoin users don't even have access to\n> any RBF functionality today, so we're not even seeing gradual development\n> of these things yet. I think this fact needs to be taken into account when\n> designing breaking changes to bitcoin policy. Had these things been in\n> place and widely used the conversation would have been much easier.\n>\n> Fundamentally, my view is that all the UX problems related to RBF alone\n> are sufficient of an issue to hold off on rolling out these upgrades for\n> the foreseeable future and think of other ways of solving the pinning issue\n> and other issues w the current policy. Might be that it's just a\n> fundamental goal conflict that different people want different behavior but\n> I remain optimistic for creative solutions from both sides. UX issues are\n> soft as opposed to theoretical attack vectors which are hard and binary, we\n> need find a way to weigh \"even though it doesn't happen it can\n> theoretically be hacked\" against \"many users find it confusing and\n> stressful\" which is not a trivial assessment to do.\n>\n> All that said, I learn to converge that as a community we would be better\n>> off to weigh deeper the risks/costs between 0confs applications and\n>> contracting protocols in light of full-rbf.\n>>\n>\n> In deed. And as you wrote in a different message, I agree that it's\n> unfortunate that there isn't more interaction between the mailing list and\n> services and companies using this stuff day-to-day. Not that it's anyone's\n> fault in particular, let's try from all sides to find more ways to create\n> more interaction on these topics. I've pinged a few colleagues that work on\n> payments in the space and hope they will chime in more in this forum!\n>\n> All the best,\n> Sergej\n>\n>\n>> Le mer. 19 oct. 2022 \u00e0 10:33, Sergej Kotliar via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>>\n>>> Hi all,\n>>>\n>>> Chiming in on this thread as I feel like the real dangers of RBF as\n>>> default policy aren't sufficiently elaborated here. It's not only about the\n>>> zero-conf (I'll get to that) but there is an even bigger danger called the\n>>> american call option, which risks endangering the entirety of BIP21 \"Scan\n>>> this QR code with your wallet to buy this product\" model that I believe\n>>> we've all come to appreciate. Specifically, in a scenario with high\n>>> volatility and many transactions in the mempools (which is where RBF would\n>>> come in handy), a user can make a low-fee transaction and then wait for\n>>> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n>>> up, user can cancel his transaction and make a new - cheaper one. The\n>>> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>>> (it's actually quite easily managed), it's FX risk as the merchant must\n>>> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>>> some transactions lose money to FX and others earn money - that evens out\n>>> in the end. But if there is an _easily accessible in the wallet_ feature to\n>>> \"cancel transaction\" that means it will eventually get systematically\n>>> abused. A risk of X% loss on many payments that's easy to systematically\n>>> abuse is more scary than a rare risk of losing 100% of one occasional\n>>> payment. It's already possible to execute this form of abuse with opt-in\n>>> RBF, which may lead to us at some point refusing those payments (even with\n>>> confirmation) or cumbersome UX to work around it, such as crediting the\n>>> bitcoin to a custodial account.\n>>>\n>>> To compare zeroconf risk with FX risk: I think we've had one incident in\n>>> 8 years of operation where a user successfully fooled our server to accept\n>>> a payment that in the end didn't confirm. To successfully fool (non-RBF)\n>>> zeroconf one needs to have access to mining infrastructure and probability\n>>> of success is the % of hash rate controlled. This is simply due to the fact\n>>> that the network currently won't propagage the replacement transaction to\n>>> the miner, which is what's being discussed here. American call option risk\n>>> would however be available to 100% of all users, needs nothing beyond the\n>>> wallet app, and has no cost to the user - only upside.\n>>>\n>>> Bitrefill currently processes 1500-2000 onchain payments every day. For\n>>> us, a world where bitcoin becomes de facto RBF by default, means that we\n>>> would likely turn off the BIP21 model for onchain payments, instruct\n>>> Bitcoin users to use Lightning or deposit onchain BTC to a custodial\n>>> account that we have.\n>>> This option is however not available for your typical\n>>> BTCPayServer/CoinGate/Bitpay/IBEX/OpenNode et al. Would be great to hear\n>>> from other merchants or payment providers how they see this new behavior\n>>> and how they would counteract it.\n>>>\n>>> Currently Lightning is somewhere around 15% of our total bitcoin\n>>> payments. This is very much not nothing, and all of us here want Lightning\n>>> to grow, but I think it warrants a serious discussion on whether we want\n>>> Lightning adoption to go to 100% by means of disabling on-chain commerce.\n>>> For me personally it would be an easier discussion to have when Lightning\n>>> is at 80%+ of all bitcoin transactions. Currently far too many bitcoin\n>>> users simply don't have access to Lightning, and of those that do and hold\n>>> their own keys Muun is the biggest wallet per our data, not least due to\n>>> their ease-of-use which is under threat per the OP. It's hard to assess how\n>>> many users would switch to Lightning in such a scenario, the communication\n>>> around it would be hard. My intuition says that the majority of the current\n>>> 85% of bitcoin users that pay onchain would just not use bitcoin anymore,\n>>> probably shift to an alt. The benefits of Lightning are many and obvious,\n>>> we don't need to limit onchain to make Lightning more appealing. As an\n>>> anecdote, we did experiment with defaulting to bech32 addresses some years\n>>> back. The result was that simply users of the wallets that weren't able to\n>>> pay to bech32 didn't complete the purchase, no support ticket or anything,\n>>> just \"it didn't work \ud83e\udd37\u200d\u2642\ufe0f\" and user moved on. We rolled it back, and later\n>>> implemented a wallet selector to allow modern wallets to pay to bech32\n>>> while other wallets can pay to P2SH. This type of thing  is clunky, and\n>>> requires a certain level of scale to be able to do, we certainly wouldn't\n>>> have had the manpower for that when we were starting out. This why I'm\n>>> cautious about introducing more such clunkiness vectors as they are\n>>> centralizing factors.\n>>>\n>>> I'm well aware of the reason for this policy being suggested and the\n>>> potential pinning attack vector for LN and other smart contracts, but I\n>>> think these two risks/costs need to be weighed against eachother first and\n>>> thoroughly discussed because the costs are non-trivial on both sides.\n>>>\n>>> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>>> After interacting with users during high-fee periods I've come to not\n>>> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n>>> don't have access to that functionality, because their wallet doesn't\n>>> support it, or they use a custodial (exchange) wallet etc. Of those that\n>>> have the feature - only the power users understand how RBF works, and\n>>> explaining how to do RBF to a non-power-user is just too complex, for the\n>>> same reason why it's complex for wallets to make sensible non-power-user UI\n>>> around it. Current equilibrium is that mostly only power users have access\n>>> to RBF and they know how to handle it, so things are somewhat working. But\n>>> rolling this out to the broad market is something else and would likely\n>>> cause more confusion.\n>>> CPFP is somewhat more viable but also not perfect as it would require\n>>> lots of edge case code to handle abuse vectors: What if users abuse a\n>>> generous CPFP policy to unstuck past transactions or consolidate large\n>>> wallets. Best is for CPFP to be done on the wallet side, not the merchant\n>>> side, but there too are the same UX issues as with RBF.\n>>> In the end a risk-based approach to decide on which payments are\n>>> non-trivial to reverse is the easiest, taking account user experience and\n>>> such. Remember that in the fiat world card payments have up to 5%\n>>> chargebacks, whereas we in zero-conf bitcoin land we deal with \"fewer than\n>>> 1 in a million\" accepted transactions successfully reversed. These days we\n>>> have very few support issues related to bitcoin payments. The few that do\n>>> come in are due to accidental RBF users venting frustration about waiting\n>>> for their tx to confirm.\n>>> \"In theory, theory and practice are the same. In practice, they are not\"\n>>>\n>>> All the best,\n>>> Sergej Kotliar\n>>> CEO Bitrefill.com\n>>>\n>>>\n>>> --\n>>>\n>>> Sergej Kotliar\n>>>\n>>> CEO\n>>>\n>>>\n>>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>>\n>>>\n>>> www.bitrefill.com\n>>>\n>>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>>> <https://www.bitrefill.com/blog/> | Angellist\n>>> <https://angel.co/bitrefill>\n>>>\n>>>\n>>> --\n>>>\n>>> Sergej Kotliar\n>>>\n>>> CEO\n>>>\n>>>\n>>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>>\n>>>\n>>> www.bitrefill.com\n>>>\n>>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>>> <https://www.bitrefill.com/blog/> | Angellist\n>>> <https://angel.co/bitrefill>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/70f554fa/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T04:05:33",
                "message_text_only": "On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev wrote:\n> Hi all,\n> \n> Chiming in on this thread as I feel like the real dangers of RBF as default\n> policy aren't sufficiently elaborated here. It's not only about the\n> zero-conf (I'll get to that) but there is an even bigger danger called the\n> american call option, which risks endangering the entirety of BIP21 \"Scan\n> this QR code with your wallet to buy this product\" model that I believe\n> we've all come to appreciate. Specifically, in a scenario with high\n> volatility and many transactions in the mempools (which is where RBF would\n> come in handy), a user can make a low-fee transaction and then wait for\n> hours, days or even longer, and see whether BTCUSD moves. If BTCUSD moves\n> up, user can cancel his transaction and make a new - cheaper one. The\n\nI just checked this, and Bitrefill accepts transactions with RBF enabled.\n\n> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> (it's actually quite easily managed), it's FX risk as the merchant must\n> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> some transactions lose money to FX and others earn money - that evens out\n> in the end. But if there is an _easily accessible in the wallet_ feature to\n> \"cancel transaction\" that means it will eventually get systematically\n\n...and I checked this with Electrum on Android, which has a handy \"Cancel\nTransaction\" feature in the UI to easily cancel a payment. Which I did. You\nshould have a pending payment from this email, and unsurprisingly I don't have\nmy gift card. :)\n\nThe ship has already sailed on this. I'd suggest accepting Lightning, which\ndrastically shortens the time window involved.\n\nFWIW, fixedfloat.com already deals with this call option risk by charging a\nhigher fee (1% vs 0.5%) for conversions where the exact destination amount has\nbeen locked in; the default is for the exact destination amount to be picked at\nthe moment of confirmation.\n\n> abused. A risk of X% loss on many payments that's easy to systematically\n> Bitrefill currently processes 1500-2000 onchain payments every day. For us,\n> a world where bitcoin becomes de facto RBF by default, means that we would\n\nElectrum is RBF by default. So does Green Wallet, and many other wallets,  as\nwell as many exchanges. Most of those wallets/exchanges don't even have a way\nto send a transaction without RBF. This ship has sailed.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/1496e29c/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-21T19:35:24",
                "message_text_only": "On Thu, Oct 20, 2022 at 12:05:33AM -0400, Peter Todd wrote:\n> ...and I checked this with Electrum on Android, which has a handy \"Cancel\n> Transaction\" feature in the UI to easily cancel a payment. Which I did. You\n> should have a pending payment from this email, and unsurprisingly I don't have\n> my gift card. :)\n\nFYI I asked around and in addition to Electrum, BlueWallet, Simple Bitcoin\nWallet, and Specter Wallet all implement tx cancelation. Probably more.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/8b2bd524/attachment.sig>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-20T07:22:34",
                "message_text_only": "On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev wrote:\n> The\n> biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> (it's actually quite easily managed),\n\nYou mean \"it's quite easily managed, provided the transaction doesn't\nopt-in to rbf\", right? At least, that's what I understood you saying last\ntime; ie that if the tx signals rbf, then you just don't do zeroconf no\nmatter what other trustworthy signals you might see:\n\n  https://twitter.com/ziggamon/status/1435863691816275970\n\n(rbf txs seem to have increased from 22% then to 29% now)\n\n> it's FX risk as the merchant must\n> commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> some transactions lose money to FX and others earn money - that evens out\n> in the end.\n\n> But if there is an _easily accessible in the wallet_ feature to\n> \"cancel transaction\" that means it will eventually get systematically\n> abused. A risk of X% loss on many payments that's easy to systematically\n> abuse is more scary than a rare risk of losing 100% of one occasional\n> payment. It's already possible to execute this form of abuse with opt-in\n> RBF,\n\nIf someone's going to systematically exploit your store via this\nmechanism, it seems like they'd just find a single wallet with a good\nUX for opt-in RBF and lowballing fees, and go to town -- not something\nwhere opt-in rbf vs fullrbf policies make any difference at all? \n\nIt's not like existing wallets that don't let you set RBF will suddenly\nget a good UX for replacing transactions just because they'd be relayed\nif they did, is it?\n\n> To successfully fool (non-RBF)\n> zeroconf one needs to have access to mining infrastructure and probability\n> of success is the % of hash rate controlled.\n\nI thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\ntwo conflicting txs in advance, one paying the merchant, one paying\nyourself, connect to many peers, relay the one paying the merchant to\nthe merchant, and the other to everyone else.\n\nI'm just basing this off Peter Todd's stuff from years ago:\n\nhttps://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n\nhttps://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n\n> Currently Lightning is somewhere around 15% of our total bitcoin payments.\n\nSo, based on last year's numbers, presumably that makes your bitcoin\npayments break down as something like:\n\n   5% txs are on-chain and seem shady and are excluded from zeroconf\n  15% txs are lightning\n  20% txs are on-chain but signal rbf and are excluded from zeroconf\n  60% txs are on-chain and seem fine for zeroconf\n\n> This is very much not nothing, and all of us here want Lightning to grow,\n> but I think it warrants a serious discussion on whether we want Lightning\n> adoption to go to 100% by means of disabling on-chain commerce.\n\nIf the numbers above were accurate, this would just mean you'd go from 60%\nzeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n\n> For me\n> personally it would be an easier discussion to have when Lightning is at\n> 80%+ of all bitcoin transactions.\n\nCan you extrapolate from the numbers you've seen to estimate when that\nmight be, given current trends? Or perhaps when fine-for-zeroconf txs\ndrop to 20%, since opt-in-RBF txs and considered-unsafe txs would still\nwork the same in a fullrbf world.\n\n> The benefits of Lightning are many and obvious,\n> we don't need to limit onchain to make Lightning more appealing. \n\nTo be fair, I think making lightning (and coinjoins) work better is\nexactly what inspired this -- not as a \"make on-chain worse so we look\nbetter in comparison\", but as a \"making lightning work well is a bunch\nof hard problems, here's the next thing we need in order to beat the\nnext problem\".\n\n> Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n> After interacting with users during high-fee periods I've come to not\n> appreciate RBF as a solution to that issue. Most users (80% or so) simply\n> don't have access to that functionality, because their wallet doesn't\n> support it, or they use a custodial (exchange) wallet etc. Of those that\n> have the feature - only the power users understand how RBF works, and\n> explaining how to do RBF to a non-power-user is just too complex, for the\n> same reason why it's complex for wallets to make sensible non-power-user UI\n> around it. Current equilibrium is that mostly only power users have access\n> to RBF and they know how to handle it, so things are somewhat working. But\n> rolling this out to the broad market is something else and would likely\n> cause more confusion.\n> CPFP is somewhat more viable but also not perfect as it would require lots\n> of edge case code to handle abuse vectors: What if users abuse a generous\n> CPFP policy to unstuck past transactions or consolidate large wallets. Best\n> is for CPFP to be done on the wallet side, not the merchant side, but there\n> too are the same UX issues as with RBF.\n\nI think if you're ruling out both merchants and users being able to add\nfees to a tx to get it to confirm, then you're going to lose either way.\nTxs will either expire because they've been stuck for more than a week,\nand be vulnerable to replacement at that point anyway, or they'll be\ndropped from mempools because they've filled up and they were the lowest\nfee tx, and be vulnerable to replacement for that reason. In the expiry\ncase, the merchant can rebroadcast the original transaction to keep it\nalive, perhaps with a good chance of beating an attacker to the punch,\nbut in the full mempool case, you could only do that if you were also\nCPFPing it, which you already ruled out.\n\nCheers,\naj"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-20T12:37:53",
                "message_text_only": "On Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n> wrote:\n> > The\n> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> > (it's actually quite easily managed),\n>\n> You mean \"it's quite easily managed, provided the transaction doesn't\n> opt-in to rbf\", right? At least, that's what I understood you saying last\n> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n> matter what other trustworthy signals you might see:\n>\n>   https://twitter.com/ziggamon/status/1435863691816275970\n>\n> (rbf txs seem to have increased from 22% then to 29% now)\n>\n\nYeah. Our share of RBF is a bit lower than that as many RBF transactions\nare something other than consumer purchases, and most consumer purchases\ncan't do RBF\n\n\n> > it's FX risk as the merchant must\n> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> > some transactions lose money to FX and others earn money - that evens out\n> > in the end.\n>\n> > But if there is an _easily accessible in the wallet_ feature to\n> > \"cancel transaction\" that means it will eventually get systematically\n> > abused. A risk of X% loss on many payments that's easy to systematically\n> > abuse is more scary than a rare risk of losing 100% of one occasional\n> > payment. It's already possible to execute this form of abuse with opt-in\n> > RBF,\n>\n> If someone's going to systematically exploit your store via this\n> mechanism, it seems like they'd just find a single wallet with a good\n> UX for opt-in RBF and lowballing fees, and go to town -- not something\n> where opt-in rbf vs fullrbf policies make any difference at all?\n>\n\nSort of. But yes once this starts being abused systemically we will have to\ndo something else w RBF payments, such as crediting the amount in BTC to a\ncustodial account. But this option isn't available to your normal payment\nprocessor type business.\n\nAlso worth keeping in mind that sometimes \"opportunity makes the thief\".\nCurrently only power-user wallet have that feature and their market share\nis relatively small, mainly electrum stands out. But if this is available\nto all users everywhere then it will start being abused and we'll have to\nthen direct all payments to custodial account, or some other convoluted\nsolution.\n\n\n> It's not like existing wallets that don't let you set RBF will suddenly\n> get a good UX for replacing transactions just because they'd be relayed\n> if they did, is it?\n>\n> > To successfully fool (non-RBF)\n> > zeroconf one needs to have access to mining infrastructure and\n> probability\n> > of success is the % of hash rate controlled.\n>\n> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n> two conflicting txs in advance, one paying the merchant, one paying\n> yourself, connect to many peers, relay the one paying the merchant to\n> the merchant, and the other to everyone else.\n>\n> I'm just basing this off Peter Todd's stuff from years ago:\n>\n>\n> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>\n>\n> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>\n>\n\nYeah, I know the list still rehashes a single incident from 10 years ago to\ndeclare the entire practice as unsafe, and ignores real-world data that of\nthe last million transactions we had zero cases of this successfully\nabusing us.\n\n\n> > Currently Lightning is somewhere around 15% of our total bitcoin\n> payments.\n>\n> So, based on last year's numbers, presumably that makes your bitcoin\n> payments break down as something like:\n>\n>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>   15% txs are lightning\n>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>   60% txs are on-chain and seem fine for zeroconf\n>\n\nNumbers are right. Shady is too strong a word, it's mostly transactions\nwith very low fee, or high purchase amount, or many dependent unconfirmed\ntransactions, stuff like that. In some cases we do a human assessment of\nthe support ticket and often just pass them through.\n\n\n> > This is very much not nothing, and all of us here want Lightning to grow,\n> > but I think it warrants a serious discussion on whether we want Lightning\n> > adoption to go to 100% by means of disabling on-chain commerce.\n>\n> If the numbers above were accurate, this would just mean you'd go from 60%\n> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>\n\nPoint is that RBF transactions are unsafe even when waiting for a\nconfirmation, which Peter Todd trivially proved in the reply next to this.\nThe reliable solution is to reject all RBF payments and direct those users\nto custodial accounts. There are other variants to solve this with varying\ndegree of convolutedness. RBF is a strictly worse UX as proven by anyone\naccepting bitcoin payments at scale.\n\n\n> > For me\n> > personally it would be an easier discussion to have when Lightning is at\n> > 80%+ of all bitcoin transactions.\n>\n> Can you extrapolate from the numbers you've seen to estimate when that\n> might be, given current trends?\n>\n\nNot sure, it might be exponential growth, and the next 60% of Lightning\ngrowth happen faster than the first 15%. Hard to tell. But we're likely\ntalking years here..\n\n\n>\n> > The benefits of Lightning are many and obvious,\n> > we don't need to limit onchain to make Lightning more appealing.\n>\n> To be fair, I think making lightning (and coinjoins) work better is\n> exactly what inspired this -- not as a \"make on-chain worse so we look\n> better in comparison\", but as a \"making lightning work well is a bunch\n> of hard problems, here's the next thing we need in order to beat the\n> next problem\".\n>\n\nIn deed. The fact that the largest non-custodial Lightning wallet started\nthis thread should be an indicator that despite these intentions the\nsolution harms more than it fixes.\nTransactions being evicted from mempool is solved by requiring a minimum\nfee rate, which we do and now seems to have become a standard practice.\nTheoretically we can imagine them being evicted anyway but now we're\nseveral theoreticals deep again when discussing something that will cause\nmassive problems right away. In emergency situations CPFP and similar can\nof course be done manually in special circumstances.\n\nCheers\nSergej\n\n\nOn Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n> wrote:\n> > The\n> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n> > (it's actually quite easily managed),\n>\n> You mean \"it's quite easily managed, provided the transaction doesn't\n> opt-in to rbf\", right? At least, that's what I understood you saying last\n> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n> matter what other trustworthy signals you might see:\n>\n>   https://twitter.com/ziggamon/status/1435863691816275970\n>\n> (rbf txs seem to have increased from 22% then to 29% now)\n>\n> > it's FX risk as the merchant must\n> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n> > some transactions lose money to FX and others earn money - that evens out\n> > in the end.\n>\n> > But if there is an _easily accessible in the wallet_ feature to\n> > \"cancel transaction\" that means it will eventually get systematically\n> > abused. A risk of X% loss on many payments that's easy to systematically\n> > abuse is more scary than a rare risk of losing 100% of one occasional\n> > payment. It's already possible to execute this form of abuse with opt-in\n> > RBF,\n>\n> If someone's going to systematically exploit your store via this\n> mechanism, it seems like they'd just find a single wallet with a good\n> UX for opt-in RBF and lowballing fees, and go to town -- not something\n> where opt-in rbf vs fullrbf policies make any difference at all?\n>\n> It's not like existing wallets that don't let you set RBF will suddenly\n> get a good UX for replacing transactions just because they'd be relayed\n> if they did, is it?\n>\n> > To successfully fool (non-RBF)\n> > zeroconf one needs to have access to mining infrastructure and\n> probability\n> > of success is the % of hash rate controlled.\n>\n> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n> two conflicting txs in advance, one paying the merchant, one paying\n> yourself, connect to many peers, relay the one paying the merchant to\n> the merchant, and the other to everyone else.\n>\n> I'm just basing this off Peter Todd's stuff from years ago:\n>\n>\n> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>\n>\n> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>\n> > Currently Lightning is somewhere around 15% of our total bitcoin\n> payments.\n>\n> So, based on last year's numbers, presumably that makes your bitcoin\n> payments break down as something like:\n>\n>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>   15% txs are lightning\n>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>   60% txs are on-chain and seem fine for zeroconf\n>\n> > This is very much not nothing, and all of us here want Lightning to grow,\n> > but I think it warrants a serious discussion on whether we want Lightning\n> > adoption to go to 100% by means of disabling on-chain commerce.\n>\n> If the numbers above were accurate, this would just mean you'd go from 60%\n> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>\n> > For me\n> > personally it would be an easier discussion to have when Lightning is at\n> > 80%+ of all bitcoin transactions.\n>\n> Can you extrapolate from the numbers you've seen to estimate when that\n> might be, given current trends? Or perhaps when fine-for-zeroconf txs\n> drop to 20%, since opt-in-RBF txs and considered-unsafe txs would still\n> work the same in a fullrbf world.\n>\n> > The benefits of Lightning are many and obvious,\n> > we don't need to limit onchain to make Lightning more appealing.\n>\n> To be fair, I think making lightning (and coinjoins) work better is\n> exactly what inspired this -- not as a \"make on-chain worse so we look\n> better in comparison\", but as a \"making lightning work well is a bunch\n> of hard problems, here's the next thing we need in order to beat the\n> next problem\".\n>\n> > Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n> > After interacting with users during high-fee periods I've come to not\n> > appreciate RBF as a solution to that issue. Most users (80% or so) simply\n> > don't have access to that functionality, because their wallet doesn't\n> > support it, or they use a custodial (exchange) wallet etc. Of those that\n> > have the feature - only the power users understand how RBF works, and\n> > explaining how to do RBF to a non-power-user is just too complex, for the\n> > same reason why it's complex for wallets to make sensible non-power-user\n> UI\n> > around it. Current equilibrium is that mostly only power users have\n> access\n> > to RBF and they know how to handle it, so things are somewhat working.\n> But\n> > rolling this out to the broad market is something else and would likely\n> > cause more confusion.\n> > CPFP is somewhat more viable but also not perfect as it would require\n> lots\n> > of edge case code to handle abuse vectors: What if users abuse a generous\n> > CPFP policy to unstuck past transactions or consolidate large wallets.\n> Best\n> > is for CPFP to be done on the wallet side, not the merchant side, but\n> there\n> > too are the same UX issues as with RBF.\n>\n> I think if you're ruling out both merchants and users being able to add\n> fees to a tx to get it to confirm, then you're going to lose either way.\n> Txs will either expire because they've been stuck for more than a week,\n> and be vulnerable to replacement at that point anyway, or they'll be\n> dropped from mempools because they've filled up and they were the lowest\n> fee tx, and be vulnerable to replacement for that reason. In the expiry\n> case, the merchant can rebroadcast the original transaction to keep it\n> alive, perhaps with a good chance of beating an attacker to the punch,\n> but in the full mempool case, you could only do that if you were also\n> CPFPing it, which you already ruled out.\n>\n> Cheers,\n> aj\n>\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/5072b274/attachment-0001.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2022-10-20T14:14:14",
                "message_text_only": "Hi,\n\nThere is a reasonable tradeoff one can make to get eventual settlement\nassurance prior to confirmation: lock up the funds with a counterparty in a\n2-of-2 multisig with a timelock back to the owner. As long as the timelock\nhas not expired and the recipients trust the counterparty not to sign\ndouble spends, transactions that are spent from this multisig can be\nconsidered instant. In cases where the counterparty and the recipient are\nthe same person, this solution is trustless. Since merchant purchases tend\nto be low-value, the counterparty risk (facilitating double spends) seems\nacceptable. GreenAddress provided such a service in 2015 or so, but the\nidea got abandoned.\n\nPersonally, I find this solution much more tenable than relying on spurious\nnetwork assumptions about what will be propagated and mined.\n\nBest regards,\nRuben\n\n\n\nOn Thu, Oct 20, 2022 at 2:44 PM Sergej Kotliar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n>\n>> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n>> wrote:\n>> > The\n>> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>> > (it's actually quite easily managed),\n>>\n>> You mean \"it's quite easily managed, provided the transaction doesn't\n>> opt-in to rbf\", right? At least, that's what I understood you saying last\n>> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n>> matter what other trustworthy signals you might see:\n>>\n>>   https://twitter.com/ziggamon/status/1435863691816275970\n>>\n>> (rbf txs seem to have increased from 22% then to 29% now)\n>>\n>\n> Yeah. Our share of RBF is a bit lower than that as many RBF transactions\n> are something other than consumer purchases, and most consumer purchases\n> can't do RBF\n>\n>\n>> > it's FX risk as the merchant must\n>> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>> > some transactions lose money to FX and others earn money - that evens\n>> out\n>> > in the end.\n>>\n>> > But if there is an _easily accessible in the wallet_ feature to\n>> > \"cancel transaction\" that means it will eventually get systematically\n>> > abused. A risk of X% loss on many payments that's easy to systematically\n>> > abuse is more scary than a rare risk of losing 100% of one occasional\n>> > payment. It's already possible to execute this form of abuse with opt-in\n>> > RBF,\n>>\n>> If someone's going to systematically exploit your store via this\n>> mechanism, it seems like they'd just find a single wallet with a good\n>> UX for opt-in RBF and lowballing fees, and go to town -- not something\n>> where opt-in rbf vs fullrbf policies make any difference at all?\n>>\n>\n> Sort of. But yes once this starts being abused systemically we will have\n> to do something else w RBF payments, such as crediting the amount in BTC to\n> a custodial account. But this option isn't available to your normal payment\n> processor type business.\n>\n> Also worth keeping in mind that sometimes \"opportunity makes the thief\".\n> Currently only power-user wallet have that feature and their market share\n> is relatively small, mainly electrum stands out. But if this is available\n> to all users everywhere then it will start being abused and we'll have to\n> then direct all payments to custodial account, or some other convoluted\n> solution.\n>\n>\n>> It's not like existing wallets that don't let you set RBF will suddenly\n>> get a good UX for replacing transactions just because they'd be relayed\n>> if they did, is it?\n>>\n>> > To successfully fool (non-RBF)\n>> > zeroconf one needs to have access to mining infrastructure and\n>> probability\n>> > of success is the % of hash rate controlled.\n>>\n>> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n>> two conflicting txs in advance, one paying the merchant, one paying\n>> yourself, connect to many peers, relay the one paying the merchant to\n>> the merchant, and the other to everyone else.\n>>\n>> I'm just basing this off Peter Todd's stuff from years ago:\n>>\n>>\n>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>\n>>\n>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>\n>>\n>\n> Yeah, I know the list still rehashes a single incident from 10 years ago\n> to declare the entire practice as unsafe, and ignores real-world data that\n> of the last million transactions we had zero cases of this successfully\n> abusing us.\n>\n>\n>> > Currently Lightning is somewhere around 15% of our total bitcoin\n>> payments.\n>>\n>> So, based on last year's numbers, presumably that makes your bitcoin\n>> payments break down as something like:\n>>\n>>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>   15% txs are lightning\n>>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>   60% txs are on-chain and seem fine for zeroconf\n>>\n>\n> Numbers are right. Shady is too strong a word, it's mostly transactions\n> with very low fee, or high purchase amount, or many dependent unconfirmed\n> transactions, stuff like that. In some cases we do a human assessment of\n> the support ticket and often just pass them through.\n>\n>\n>> > This is very much not nothing, and all of us here want Lightning to\n>> grow,\n>> > but I think it warrants a serious discussion on whether we want\n>> Lightning\n>> > adoption to go to 100% by means of disabling on-chain commerce.\n>>\n>> If the numbers above were accurate, this would just mean you'd go from 60%\n>> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>>\n>\n> Point is that RBF transactions are unsafe even when waiting for a\n> confirmation, which Peter Todd trivially proved in the reply next to this.\n> The reliable solution is to reject all RBF payments and direct those users\n> to custodial accounts. There are other variants to solve this with varying\n> degree of convolutedness. RBF is a strictly worse UX as proven by anyone\n> accepting bitcoin payments at scale.\n>\n>\n>> > For me\n>> > personally it would be an easier discussion to have when Lightning is at\n>> > 80%+ of all bitcoin transactions.\n>>\n>> Can you extrapolate from the numbers you've seen to estimate when that\n>> might be, given current trends?\n>>\n>\n> Not sure, it might be exponential growth, and the next 60% of Lightning\n> growth happen faster than the first 15%. Hard to tell. But we're likely\n> talking years here..\n>\n>\n>>\n>> > The benefits of Lightning are many and obvious,\n>> > we don't need to limit onchain to make Lightning more appealing.\n>>\n>> To be fair, I think making lightning (and coinjoins) work better is\n>> exactly what inspired this -- not as a \"make on-chain worse so we look\n>> better in comparison\", but as a \"making lightning work well is a bunch\n>> of hard problems, here's the next thing we need in order to beat the\n>> next problem\".\n>>\n>\n> In deed. The fact that the largest non-custodial Lightning wallet started\n> this thread should be an indicator that despite these intentions the\n> solution harms more than it fixes.\n> Transactions being evicted from mempool is solved by requiring a minimum\n> fee rate, which we do and now seems to have become a standard practice.\n> Theoretically we can imagine them being evicted anyway but now we're\n> several theoreticals deep again when discussing something that will cause\n> massive problems right away. In emergency situations CPFP and similar can\n> of course be done manually in special circumstances.\n>\n> Cheers\n> Sergej\n>\n>\n> On Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n>\n>> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n>> wrote:\n>> > The\n>> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>> > (it's actually quite easily managed),\n>>\n>> You mean \"it's quite easily managed, provided the transaction doesn't\n>> opt-in to rbf\", right? At least, that's what I understood you saying last\n>> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n>> matter what other trustworthy signals you might see:\n>>\n>>   https://twitter.com/ziggamon/status/1435863691816275970\n>>\n>> (rbf txs seem to have increased from 22% then to 29% now)\n>>\n>> > it's FX risk as the merchant must\n>> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>> > some transactions lose money to FX and others earn money - that evens\n>> out\n>> > in the end.\n>>\n>> > But if there is an _easily accessible in the wallet_ feature to\n>> > \"cancel transaction\" that means it will eventually get systematically\n>> > abused. A risk of X% loss on many payments that's easy to systematically\n>> > abuse is more scary than a rare risk of losing 100% of one occasional\n>> > payment. It's already possible to execute this form of abuse with opt-in\n>> > RBF,\n>>\n>> If someone's going to systematically exploit your store via this\n>> mechanism, it seems like they'd just find a single wallet with a good\n>> UX for opt-in RBF and lowballing fees, and go to town -- not something\n>> where opt-in rbf vs fullrbf policies make any difference at all?\n>>\n>> It's not like existing wallets that don't let you set RBF will suddenly\n>> get a good UX for replacing transactions just because they'd be relayed\n>> if they did, is it?\n>>\n>> > To successfully fool (non-RBF)\n>> > zeroconf one needs to have access to mining infrastructure and\n>> probability\n>> > of success is the % of hash rate controlled.\n>>\n>> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n>> two conflicting txs in advance, one paying the merchant, one paying\n>> yourself, connect to many peers, relay the one paying the merchant to\n>> the merchant, and the other to everyone else.\n>>\n>> I'm just basing this off Peter Todd's stuff from years ago:\n>>\n>>\n>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>\n>>\n>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>\n>> > Currently Lightning is somewhere around 15% of our total bitcoin\n>> payments.\n>>\n>> So, based on last year's numbers, presumably that makes your bitcoin\n>> payments break down as something like:\n>>\n>>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>   15% txs are lightning\n>>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>   60% txs are on-chain and seem fine for zeroconf\n>>\n>> > This is very much not nothing, and all of us here want Lightning to\n>> grow,\n>> > but I think it warrants a serious discussion on whether we want\n>> Lightning\n>> > adoption to go to 100% by means of disabling on-chain commerce.\n>>\n>> If the numbers above were accurate, this would just mean you'd go from 60%\n>> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>>\n>> > For me\n>> > personally it would be an easier discussion to have when Lightning is at\n>> > 80%+ of all bitcoin transactions.\n>>\n>> Can you extrapolate from the numbers you've seen to estimate when that\n>> might be, given current trends? Or perhaps when fine-for-zeroconf txs\n>> drop to 20%, since opt-in-RBF txs and considered-unsafe txs would still\n>> work the same in a fullrbf world.\n>>\n>> > The benefits of Lightning are many and obvious,\n>> > we don't need to limit onchain to make Lightning more appealing.\n>>\n>> To be fair, I think making lightning (and coinjoins) work better is\n>> exactly what inspired this -- not as a \"make on-chain worse so we look\n>> better in comparison\", but as a \"making lightning work well is a bunch\n>> of hard problems, here's the next thing we need in order to beat the\n>> next problem\".\n>>\n>> > Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>> > After interacting with users during high-fee periods I've come to not\n>> > appreciate RBF as a solution to that issue. Most users (80% or so)\n>> simply\n>> > don't have access to that functionality, because their wallet doesn't\n>> > support it, or they use a custodial (exchange) wallet etc. Of those that\n>> > have the feature - only the power users understand how RBF works, and\n>> > explaining how to do RBF to a non-power-user is just too complex, for\n>> the\n>> > same reason why it's complex for wallets to make sensible\n>> non-power-user UI\n>> > around it. Current equilibrium is that mostly only power users have\n>> access\n>> > to RBF and they know how to handle it, so things are somewhat working.\n>> But\n>> > rolling this out to the broad market is something else and would likely\n>> > cause more confusion.\n>> > CPFP is somewhat more viable but also not perfect as it would require\n>> lots\n>> > of edge case code to handle abuse vectors: What if users abuse a\n>> generous\n>> > CPFP policy to unstuck past transactions or consolidate large wallets.\n>> Best\n>> > is for CPFP to be done on the wallet side, not the merchant side, but\n>> there\n>> > too are the same UX issues as with RBF.\n>>\n>> I think if you're ruling out both merchants and users being able to add\n>> fees to a tx to get it to confirm, then you're going to lose either way.\n>> Txs will either expire because they've been stuck for more than a week,\n>> and be vulnerable to replacement at that point anyway, or they'll be\n>> dropped from mempools because they've filled up and they were the lowest\n>> fee tx, and be vulnerable to replacement for that reason. In the expiry\n>> case, the merchant can rebroadcast the original transaction to keep it\n>> alive, perhaps with a good chance of beating an attacker to the punch,\n>> but in the full mempool case, you could only do that if you were also\n>> CPFPing it, which you already ruled out.\n>>\n>> Cheers,\n>> aj\n>>\n>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/29536c80/attachment-0001.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-20T14:17:23",
                "message_text_only": "It's a good idea in theory, the issue is that most wallets and services\nbitcoin users use today to send bitcoin don't use solutions to that. So we\nend up with \"you need to use X wallet to buy stuff\", which is equivalent to\n\"you need to use a Lightning wallet to buy stuff\"\n\nOn Thu, 20 Oct 2022 at 16:14, Ruben Somsen <rsomsen at gmail.com> wrote:\n\n> Hi,\n>\n> There is a reasonable tradeoff one can make to get eventual settlement\n> assurance prior to confirmation: lock up the funds with a counterparty in a\n> 2-of-2 multisig with a timelock back to the owner. As long as the timelock\n> has not expired and the recipients trust the counterparty not to sign\n> double spends, transactions that are spent from this multisig can be\n> considered instant. In cases where the counterparty and the recipient are\n> the same person, this solution is trustless. Since merchant purchases tend\n> to be low-value, the counterparty risk (facilitating double spends) seems\n> acceptable. GreenAddress provided such a service in 2015 or so, but the\n> idea got abandoned.\n>\n> Personally, I find this solution much more tenable than relying on\n> spurious network assumptions about what will be propagated and mined.\n>\n> Best regards,\n> Ruben\n>\n>\n>\n> On Thu, Oct 20, 2022 at 2:44 PM Sergej Kotliar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n>>\n>>> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n>>> wrote:\n>>> > The\n>>> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>>> > (it's actually quite easily managed),\n>>>\n>>> You mean \"it's quite easily managed, provided the transaction doesn't\n>>> opt-in to rbf\", right? At least, that's what I understood you saying last\n>>> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n>>> matter what other trustworthy signals you might see:\n>>>\n>>>   https://twitter.com/ziggamon/status/1435863691816275970\n>>>\n>>> (rbf txs seem to have increased from 22% then to 29% now)\n>>>\n>>\n>> Yeah. Our share of RBF is a bit lower than that as many RBF transactions\n>> are something other than consumer purchases, and most consumer purchases\n>> can't do RBF\n>>\n>>\n>>> > it's FX risk as the merchant must\n>>> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>>> > some transactions lose money to FX and others earn money - that evens\n>>> out\n>>> > in the end.\n>>>\n>>> > But if there is an _easily accessible in the wallet_ feature to\n>>> > \"cancel transaction\" that means it will eventually get systematically\n>>> > abused. A risk of X% loss on many payments that's easy to\n>>> systematically\n>>> > abuse is more scary than a rare risk of losing 100% of one occasional\n>>> > payment. It's already possible to execute this form of abuse with\n>>> opt-in\n>>> > RBF,\n>>>\n>>> If someone's going to systematically exploit your store via this\n>>> mechanism, it seems like they'd just find a single wallet with a good\n>>> UX for opt-in RBF and lowballing fees, and go to town -- not something\n>>> where opt-in rbf vs fullrbf policies make any difference at all?\n>>>\n>>\n>> Sort of. But yes once this starts being abused systemically we will have\n>> to do something else w RBF payments, such as crediting the amount in BTC to\n>> a custodial account. But this option isn't available to your normal payment\n>> processor type business.\n>>\n>> Also worth keeping in mind that sometimes \"opportunity makes the thief\".\n>> Currently only power-user wallet have that feature and their market share\n>> is relatively small, mainly electrum stands out. But if this is available\n>> to all users everywhere then it will start being abused and we'll have to\n>> then direct all payments to custodial account, or some other convoluted\n>> solution.\n>>\n>>\n>>> It's not like existing wallets that don't let you set RBF will suddenly\n>>> get a good UX for replacing transactions just because they'd be relayed\n>>> if they did, is it?\n>>>\n>>> > To successfully fool (non-RBF)\n>>> > zeroconf one needs to have access to mining infrastructure and\n>>> probability\n>>> > of success is the % of hash rate controlled.\n>>>\n>>> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n>>> two conflicting txs in advance, one paying the merchant, one paying\n>>> yourself, connect to many peers, relay the one paying the merchant to\n>>> the merchant, and the other to everyone else.\n>>>\n>>> I'm just basing this off Peter Todd's stuff from years ago:\n>>>\n>>>\n>>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>>\n>>>\n>>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>>\n>>>\n>>\n>> Yeah, I know the list still rehashes a single incident from 10 years ago\n>> to declare the entire practice as unsafe, and ignores real-world data that\n>> of the last million transactions we had zero cases of this successfully\n>> abusing us.\n>>\n>>\n>>> > Currently Lightning is somewhere around 15% of our total bitcoin\n>>> payments.\n>>>\n>>> So, based on last year's numbers, presumably that makes your bitcoin\n>>> payments break down as something like:\n>>>\n>>>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>>   15% txs are lightning\n>>>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>>   60% txs are on-chain and seem fine for zeroconf\n>>>\n>>\n>> Numbers are right. Shady is too strong a word, it's mostly transactions\n>> with very low fee, or high purchase amount, or many dependent unconfirmed\n>> transactions, stuff like that. In some cases we do a human assessment of\n>> the support ticket and often just pass them through.\n>>\n>>\n>>> > This is very much not nothing, and all of us here want Lightning to\n>>> grow,\n>>> > but I think it warrants a serious discussion on whether we want\n>>> Lightning\n>>> > adoption to go to 100% by means of disabling on-chain commerce.\n>>>\n>>> If the numbers above were accurate, this would just mean you'd go from\n>>> 60%\n>>> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>>>\n>>\n>> Point is that RBF transactions are unsafe even when waiting for a\n>> confirmation, which Peter Todd trivially proved in the reply next to this.\n>> The reliable solution is to reject all RBF payments and direct those users\n>> to custodial accounts. There are other variants to solve this with varying\n>> degree of convolutedness. RBF is a strictly worse UX as proven by anyone\n>> accepting bitcoin payments at scale.\n>>\n>>\n>>> > For me\n>>> > personally it would be an easier discussion to have when Lightning is\n>>> at\n>>> > 80%+ of all bitcoin transactions.\n>>>\n>>> Can you extrapolate from the numbers you've seen to estimate when that\n>>> might be, given current trends?\n>>>\n>>\n>> Not sure, it might be exponential growth, and the next 60% of Lightning\n>> growth happen faster than the first 15%. Hard to tell. But we're likely\n>> talking years here..\n>>\n>>\n>>>\n>>> > The benefits of Lightning are many and obvious,\n>>> > we don't need to limit onchain to make Lightning more appealing.\n>>>\n>>> To be fair, I think making lightning (and coinjoins) work better is\n>>> exactly what inspired this -- not as a \"make on-chain worse so we look\n>>> better in comparison\", but as a \"making lightning work well is a bunch\n>>> of hard problems, here's the next thing we need in order to beat the\n>>> next problem\".\n>>>\n>>\n>> In deed. The fact that the largest non-custodial Lightning wallet started\n>> this thread should be an indicator that despite these intentions the\n>> solution harms more than it fixes.\n>> Transactions being evicted from mempool is solved by requiring a minimum\n>> fee rate, which we do and now seems to have become a standard practice.\n>> Theoretically we can imagine them being evicted anyway but now we're\n>> several theoreticals deep again when discussing something that will cause\n>> massive problems right away. In emergency situations CPFP and similar can\n>> of course be done manually in special circumstances.\n>>\n>> Cheers\n>> Sergej\n>>\n>>\n>> On Thu, 20 Oct 2022 at 09:22, Anthony Towns <aj at erisian.com.au> wrote:\n>>\n>>> On Wed, Oct 19, 2022 at 04:29:57PM +0200, Sergej Kotliar via bitcoin-dev\n>>> wrote:\n>>> > The\n>>> > biggest risk in accepting bitcoin payments is in fact not zeroconf risk\n>>> > (it's actually quite easily managed),\n>>>\n>>> You mean \"it's quite easily managed, provided the transaction doesn't\n>>> opt-in to rbf\", right? At least, that's what I understood you saying last\n>>> time; ie that if the tx signals rbf, then you just don't do zeroconf no\n>>> matter what other trustworthy signals you might see:\n>>>\n>>>   https://twitter.com/ziggamon/status/1435863691816275970\n>>>\n>>> (rbf txs seem to have increased from 22% then to 29% now)\n>>>\n>>> > it's FX risk as the merchant must\n>>> > commit to a certain BTCUSD rate ahead of time for a purchase. Over time\n>>> > some transactions lose money to FX and others earn money - that evens\n>>> out\n>>> > in the end.\n>>>\n>>> > But if there is an _easily accessible in the wallet_ feature to\n>>> > \"cancel transaction\" that means it will eventually get systematically\n>>> > abused. A risk of X% loss on many payments that's easy to\n>>> systematically\n>>> > abuse is more scary than a rare risk of losing 100% of one occasional\n>>> > payment. It's already possible to execute this form of abuse with\n>>> opt-in\n>>> > RBF,\n>>>\n>>> If someone's going to systematically exploit your store via this\n>>> mechanism, it seems like they'd just find a single wallet with a good\n>>> UX for opt-in RBF and lowballing fees, and go to town -- not something\n>>> where opt-in rbf vs fullrbf policies make any difference at all?\n>>>\n>>> It's not like existing wallets that don't let you set RBF will suddenly\n>>> get a good UX for replacing transactions just because they'd be relayed\n>>> if they did, is it?\n>>>\n>>> > To successfully fool (non-RBF)\n>>> > zeroconf one needs to have access to mining infrastructure and\n>>> probability\n>>> > of success is the % of hash rate controlled.\n>>>\n>>> I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n>>> two conflicting txs in advance, one paying the merchant, one paying\n>>> yourself, connect to many peers, relay the one paying the merchant to\n>>> the merchant, and the other to everyone else.\n>>>\n>>> I'm just basing this off Peter Todd's stuff from years ago:\n>>>\n>>>\n>>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>>\n>>>\n>>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>>\n>>> > Currently Lightning is somewhere around 15% of our total bitcoin\n>>> payments.\n>>>\n>>> So, based on last year's numbers, presumably that makes your bitcoin\n>>> payments break down as something like:\n>>>\n>>>    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>>   15% txs are lightning\n>>>   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>>   60% txs are on-chain and seem fine for zeroconf\n>>>\n>>> > This is very much not nothing, and all of us here want Lightning to\n>>> grow,\n>>> > but I think it warrants a serious discussion on whether we want\n>>> Lightning\n>>> > adoption to go to 100% by means of disabling on-chain commerce.\n>>>\n>>> If the numbers above were accurate, this would just mean you'd go from\n>>> 60%\n>>> zeroconf/25% not-zeroconf to 85% not-zeroconf; wouldn't be 0% on-chain.\n>>>\n>>> > For me\n>>> > personally it would be an easier discussion to have when Lightning is\n>>> at\n>>> > 80%+ of all bitcoin transactions.\n>>>\n>>> Can you extrapolate from the numbers you've seen to estimate when that\n>>> might be, given current trends? Or perhaps when fine-for-zeroconf txs\n>>> drop to 20%, since opt-in-RBF txs and considered-unsafe txs would still\n>>> work the same in a fullrbf world.\n>>>\n>>> > The benefits of Lightning are many and obvious,\n>>> > we don't need to limit onchain to make Lightning more appealing.\n>>>\n>>> To be fair, I think making lightning (and coinjoins) work better is\n>>> exactly what inspired this -- not as a \"make on-chain worse so we look\n>>> better in comparison\", but as a \"making lightning work well is a bunch\n>>> of hard problems, here's the next thing we need in order to beat the\n>>> next problem\".\n>>>\n>>> > Sidenote: On the efficacy of RBF to \"unstuck\" stuck transactions\n>>> > After interacting with users during high-fee periods I've come to not\n>>> > appreciate RBF as a solution to that issue. Most users (80% or so)\n>>> simply\n>>> > don't have access to that functionality, because their wallet doesn't\n>>> > support it, or they use a custodial (exchange) wallet etc. Of those\n>>> that\n>>> > have the feature - only the power users understand how RBF works, and\n>>> > explaining how to do RBF to a non-power-user is just too complex, for\n>>> the\n>>> > same reason why it's complex for wallets to make sensible\n>>> non-power-user UI\n>>> > around it. Current equilibrium is that mostly only power users have\n>>> access\n>>> > to RBF and they know how to handle it, so things are somewhat working.\n>>> But\n>>> > rolling this out to the broad market is something else and would likely\n>>> > cause more confusion.\n>>> > CPFP is somewhat more viable but also not perfect as it would require\n>>> lots\n>>> > of edge case code to handle abuse vectors: What if users abuse a\n>>> generous\n>>> > CPFP policy to unstuck past transactions or consolidate large wallets.\n>>> Best\n>>> > is for CPFP to be done on the wallet side, not the merchant side, but\n>>> there\n>>> > too are the same UX issues as with RBF.\n>>>\n>>> I think if you're ruling out both merchants and users being able to add\n>>> fees to a tx to get it to confirm, then you're going to lose either way.\n>>> Txs will either expire because they've been stuck for more than a week,\n>>> and be vulnerable to replacement at that point anyway, or they'll be\n>>> dropped from mempools because they've filled up and they were the lowest\n>>> fee tx, and be vulnerable to replacement for that reason. In the expiry\n>>> case, the merchant can rebroadcast the original transaction to keep it\n>>> alive, perhaps with a good chance of beating an attacker to the punch,\n>>> but in the full mempool case, you could only do that if you were also\n>>> CPFPing it, which you already ruled out.\n>>>\n>>> Cheers,\n>>> aj\n>>>\n>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/0cf792bd/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-20T19:58:41",
                "message_text_only": "On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev wrote:\n> > If someone's going to systematically exploit your store via this\n> > mechanism, it seems like they'd just find a single wallet with a good\n> > UX for opt-in RBF and lowballing fees, and go to town -- not something\n> > where opt-in rbf vs fullrbf policies make any difference at all?\n> Sort of. But yes once this starts being abused systemically we will have to\n> do something else w RBF payments, such as crediting the amount in BTC to a\n> custodial account. But this option isn't available to your normal payment\n> processor type business.\n\nSo, what I'm hearing is:\n\n * lightning works great, but is still pretty small\n * zeroconf works great for txs that opt-out of RBF\n * opt-in RBF is a pain for two reasons:\n    - people don't like that it's not treated as zeroconf\n    - the risk of fiat/BTC exchange rate changes between\n      now and when the tx actually confirms is worrying\n      even if it hasn't caused real problems yet\n\n(Please correct me if that's too far wrong)\n\nMaybe it would be productive to explore this opt-in RBF part a bit\nmore? ie, see if \"we\" can come up with better answers to some question\nalong the lines of:\n\n \"how can we make on-chain payments for goods priced in fiat work well\n  for payees that opt-in to RBF?\"\n\nThat seems like the sort of thing that's better solved by a collaboration\nbetween wallet devs and merchant devs (and protocol devs?), rather than\njust one or the other?\n\nIs that something that we could talk about here? Or maybe it's better\ndone via an optech workgroup or something?\n\nIf \"we'll credit your account in BTC, then work out the USD coversion\nand deduct that for your purchase, then you can do whatever you like\nwith any remaining BTC from your on-chain payment\" is the idea, maybe we\nshould just roll with that design, but make it more decentralised: have\nthe initial payment setup a lightning channel between the customer and\nthe merchant with the BTC (so it's not custodial), but do some magic to\nallow USD amounts to be transferred over it (Taro? something oracle based\nso that both parties are confident a fair exchange rate will be used?).\n\nMaybe that particular idea is naive, but having an actual problem to\nsolve seems more constructive than just saying \"we want rbf\" \"but we\nwant zeroconf\" all the time?\n\n(Ideally the lightning channels above would be dual funded so they could\nbe used for routing more generally; but then dual funded channels are\none of the things that get broken by lack of full rbf)\n\n> > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to create\n> > two conflicting txs in advance, one paying the merchant, one paying\n> > yourself, connect to many peers, relay the one paying the merchant to\n> > the merchant, and the other to everyone else.\n> > I'm just basing this off Peter Todd's stuff from years ago:\n> > https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n> > https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n> Yeah, I know the list still rehashes a single incident from 10 years ago to\n> declare the entire practice as unsafe, and ignores real-world data that of\n> the last million transactions we had zero cases of this successfully\n> abusing us.\n\nI mean, the avenue above isn't easy to exploit -- you have to identify\nthe merchant's node so that they get the bad tx, and you have to connect\nto many peers so that your preferred tx propogates to miners first --\nand probably more importantly, it's relatively easy to detect -- if the\nmerchant has a few passive nodes that the attacker doesn't know about\nit, and uses those to watch for attempted doublespends while it tries\nto ensure the real tx has propogated widely. So it doesn't surprise me\nat all that it's not often attempted, and even less often successful.\n\n> > > Currently Lightning is somewhere around 15% of our total bitcoin\n> > > payments.\n> > So, based on last year's numbers, presumably that makes your bitcoin\n> > payments break down as something like:\n> >    5% txs are on-chain and seem shady and are excluded from zeroconf\n> >   15% txs are lightning\n> >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n> >   60% txs are on-chain and seem fine for zeroconf\n> Numbers are right. Shady is too strong a word,\n\nHeh, fair enough.\n\nSo the above suggests 25% of payments already get a sub-par experience,\ncompared to what you'd like them to have (which sucks, but if you're\ntrying to reinvent both money and payments, maybe isn't surprising). And\ngoing full rbf would bump that from 25% to 85%, which would be pretty\nterrible.\n\n> RBF is a strictly worse UX as proven by anyone\n> accepting bitcoin payments at scale.\n\nSo let's make it better? Building bitcoin businesses on the lie that\nunconfirmed txs are safe and won't be replaced is going to bite us\neventually; focussing on trying to push that back indefinitely is just\ngoing to make everyone less prepared when it eventually happens.\n\n> > > For me\n> > > personally it would be an easier discussion to have when Lightning is at\n> > > 80%+ of all bitcoin transactions.\n> > Can you extrapolate from the numbers you've seen to estimate when that\n> > might be, given current trends?\n> Not sure, it might be exponential growth, and the next 60% of Lightning\n> growth happen faster than the first 15%. Hard to tell. But we're likely\n> talking years here..\n\nOkay? Two years is very different from 50 years, and at the moment there's\nnot really any data, so people are just going to go with their gut...\n\nIf it were growing in line with lightning capacity in BTC, per\nbitcoinvisuals.com/ln-capacity; then 15% now would have grown from\nperhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\ngetting from 15% to 80% would then be about 8 years. \n\nPresumably that's a laughably terrible model, of course. But if we had\nsome actual numbers where we can watch the progress, it might be a lot\neasier to be patient about waiting for lightning adoption to hit 80%\nor whatever, and focus on productive things in the meantime?\n\nCheers,\naj"
            },
            {
                "author": "David A. Harding",
                "date": "2022-10-20T21:05:36",
                "message_text_only": "On 2022-10-20 09:58, Anthony Towns via bitcoin-dev wrote:\n> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via \n> bitcoin-dev wrote:\n>> AJ previously wrote:\n>> > presumably that makes your bitcoin\n>> > payments break down as something like:\n>> >    5% txs are on-chain and seem shady and are excluded from zeroconf\n>> >   15% txs are lightning\n>> >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>> >   60% txs are on-chain and seem fine for zeroconf\n>> Numbers are right. [...]\n> \n> [...]\n> \n> So the above suggests 25% of payments already get a sub-par experience \n> [...]\n> going full rbf would bump that from 25% to 85%, which would be pretty\n> terrible.\n\nIs it worth considering incremental steps between opt-in only (BIP125) \nand replace anything full RBF?  For example, in addition to opt-in RBF \nrules, treat any transaction with a txid ending in `0x1` as replacable?  \nI assume 1/16th (6.25%) of transactions would match that pattern (some \nof which already opt-in to RBF, so the net effect would be smaller).  \nThis would have the following advantages:\n\n1. We could see if miners are willing to enable unsignaled RBF at all\n\n2. We could gather more evidence on how the change affects zeroconf \nbusinesses and everyday users, hopefully without requiring they make \nimmediate and huge changes\n\n3. Any wallet authors that oppose unsignaled RBF can opt-out by grinding \ntheir txids, at least until full RBF is accomplished\n\n4. We can increase the percentage of transactions subject to unsignaled \nRBF in later releases of Bitcoin Core, steadily moving the system \ntowards full RBF without any sudden leaps (assuming nobody builds a \nsuccessful relay and mining network with less restrictive replacement \nrules)\n\nI don't think this directly helps solve the problems with non-replacable \ntransactions suffered by contract protocols since any adversary can \nopt-out of this scheme by grinding their txid, but I do think there's an \nadvantage in transitioning slowly when people are still depending on \nprevious behaviors.\n\nThanks,\n\n-Dave"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-20T21:07:07",
                "message_text_only": "> If it were growing in line with lightning capacity in BTC, per\nbitcoinvisuals.com/ln-capacity; then 15% now would have grown from\nperhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\ngetting from 15% to 80% would then be about 8 years.\n\nI'd caution against any metrics-based approach like this, unless it's\nsimply used for ballparking potential adoption curves to set a a timeframe\npeople can live with.\n\nA large number of coins/users sit on custodial rails and this would\nessentially encumber protocol developers to those KYC/AML institutions. If\nBinance decides to never support Lightning in favor of BNC-wrapped BTC,\nshould this be an issue at all for reasoning about a path forward?\n\nHoping to be wrong,\nGreg\n\n\n\nOn Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev\n> wrote:\n> > > If someone's going to systematically exploit your store via this\n> > > mechanism, it seems like they'd just find a single wallet with a good\n> > > UX for opt-in RBF and lowballing fees, and go to town -- not something\n> > > where opt-in rbf vs fullrbf policies make any difference at all?\n> > Sort of. But yes once this starts being abused systemically we will have\n> to\n> > do something else w RBF payments, such as crediting the amount in BTC to\n> a\n> > custodial account. But this option isn't available to your normal payment\n> > processor type business.\n>\n> So, what I'm hearing is:\n>\n>  * lightning works great, but is still pretty small\n>  * zeroconf works great for txs that opt-out of RBF\n>  * opt-in RBF is a pain for two reasons:\n>     - people don't like that it's not treated as zeroconf\n>     - the risk of fiat/BTC exchange rate changes between\n>       now and when the tx actually confirms is worrying\n>       even if it hasn't caused real problems yet\n>\n> (Please correct me if that's too far wrong)\n>\n> Maybe it would be productive to explore this opt-in RBF part a bit\n> more? ie, see if \"we\" can come up with better answers to some question\n> along the lines of:\n>\n>  \"how can we make on-chain payments for goods priced in fiat work well\n>   for payees that opt-in to RBF?\"\n>\n> That seems like the sort of thing that's better solved by a collaboration\n> between wallet devs and merchant devs (and protocol devs?), rather than\n> just one or the other?\n>\n> Is that something that we could talk about here? Or maybe it's better\n> done via an optech workgroup or something?\n>\n> If \"we'll credit your account in BTC, then work out the USD coversion\n> and deduct that for your purchase, then you can do whatever you like\n> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n> should just roll with that design, but make it more decentralised: have\n> the initial payment setup a lightning channel between the customer and\n> the merchant with the BTC (so it's not custodial), but do some magic to\n> allow USD amounts to be transferred over it (Taro? something oracle based\n> so that both parties are confident a fair exchange rate will be used?).\n>\n> Maybe that particular idea is naive, but having an actual problem to\n> solve seems more constructive than just saying \"we want rbf\" \"but we\n> want zeroconf\" all the time?\n>\n> (Ideally the lightning channels above would be dual funded so they could\n> be used for routing more generally; but then dual funded channels are\n> one of the things that get broken by lack of full rbf)\n>\n> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n> create\n> > > two conflicting txs in advance, one paying the merchant, one paying\n> > > yourself, connect to many peers, relay the one paying the merchant to\n> > > the merchant, and the other to everyone else.\n> > > I'm just basing this off Peter Todd's stuff from years ago:\n> > >\n> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n> > >\n> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n> > Yeah, I know the list still rehashes a single incident from 10 years ago\n> to\n> > declare the entire practice as unsafe, and ignores real-world data that\n> of\n> > the last million transactions we had zero cases of this successfully\n> > abusing us.\n>\n> I mean, the avenue above isn't easy to exploit -- you have to identify\n> the merchant's node so that they get the bad tx, and you have to connect\n> to many peers so that your preferred tx propogates to miners first --\n> and probably more importantly, it's relatively easy to detect -- if the\n> merchant has a few passive nodes that the attacker doesn't know about\n> it, and uses those to watch for attempted doublespends while it tries\n> to ensure the real tx has propogated widely. So it doesn't surprise me\n> at all that it's not often attempted, and even less often successful.\n>\n> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n> > > > payments.\n> > > So, based on last year's numbers, presumably that makes your bitcoin\n> > > payments break down as something like:\n> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n> > >   15% txs are lightning\n> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n> > >   60% txs are on-chain and seem fine for zeroconf\n> > Numbers are right. Shady is too strong a word,\n>\n> Heh, fair enough.\n>\n> So the above suggests 25% of payments already get a sub-par experience,\n> compared to what you'd like them to have (which sucks, but if you're\n> trying to reinvent both money and payments, maybe isn't surprising). And\n> going full rbf would bump that from 25% to 85%, which would be pretty\n> terrible.\n>\n> > RBF is a strictly worse UX as proven by anyone\n> > accepting bitcoin payments at scale.\n>\n> So let's make it better? Building bitcoin businesses on the lie that\n> unconfirmed txs are safe and won't be replaced is going to bite us\n> eventually; focussing on trying to push that back indefinitely is just\n> going to make everyone less prepared when it eventually happens.\n>\n> > > > For me\n> > > > personally it would be an easier discussion to have when Lightning\n> is at\n> > > > 80%+ of all bitcoin transactions.\n> > > Can you extrapolate from the numbers you've seen to estimate when that\n> > > might be, given current trends?\n> > Not sure, it might be exponential growth, and the next 60% of Lightning\n> > growth happen faster than the first 15%. Hard to tell. But we're likely\n> > talking years here..\n>\n> Okay? Two years is very different from 50 years, and at the moment there's\n> not really any data, so people are just going to go with their gut...\n>\n> If it were growing in line with lightning capacity in BTC, per\n> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n> getting from 15% to 80% would then be about 8 years.\n>\n> Presumably that's a laughably terrible model, of course. But if we had\n> some actual numbers where we can watch the progress, it might be a lot\n> easier to be patient about waiting for lightning adoption to hit 80%\n> or whatever, and focus on productive things in the meantime?\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/038cc6c8/attachment.html>"
            },
            {
                "author": "Eloy",
                "date": "2022-10-20T22:02:13",
                "message_text_only": "There is obviously an alternative approach to the issue.\n\nIf we like opt-in RBF and would like to keep opt out RBF 0CONF working, we could add another option to punish those nodes that replace transactions. That is, a miner that publishes a block with a NO RBF, that is replaced (that is easy to check for a full node) could stop propagation of that block (so it have less chances to win). That would make the network decide when it is the time to deploy RBF.\n\nIt seems obvious for me that most devs prefer full RBF to force users to use centralized stuff (that is why the full RBF option is there already on core), but just wanted to make that clear that there is always a way to enforce a policy (read to keep zero conf working).\n\nRegards.\n\nEl 20 de octubre de 2022 18:07:07 ART, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> escribi\u00f3:\n>> If it were growing in line with lightning capacity in BTC, per\n>bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>getting from 15% to 80% would then be about 8 years.\n>\n>I'd caution against any metrics-based approach like this, unless it's\n>simply used for ballparking potential adoption curves to set a a timeframe\n>people can live with.\n>\n>A large number of coins/users sit on custodial rails and this would\n>essentially encumber protocol developers to those KYC/AML institutions. If\n>Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n>should this be an issue at all for reasoning about a path forward?\n>\n>Hoping to be wrong,\n>Greg\n>\n>\n>\n>On Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\n>bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev\n>> wrote:\n>> > > If someone's going to systematically exploit your store via this\n>> > > mechanism, it seems like they'd just find a single wallet with a good\n>> > > UX for opt-in RBF and lowballing fees, and go to town -- not something\n>> > > where opt-in rbf vs fullrbf policies make any difference at all?\n>> > Sort of. But yes once this starts being abused systemically we will have\n>> to\n>> > do something else w RBF payments, such as crediting the amount in BTC to\n>> a\n>> > custodial account. But this option isn't available to your normal payment\n>> > processor type business.\n>>\n>> So, what I'm hearing is:\n>>\n>>  * lightning works great, but is still pretty small\n>>  * zeroconf works great for txs that opt-out of RBF\n>>  * opt-in RBF is a pain for two reasons:\n>>     - people don't like that it's not treated as zeroconf\n>>     - the risk of fiat/BTC exchange rate changes between\n>>       now and when the tx actually confirms is worrying\n>>       even if it hasn't caused real problems yet\n>>\n>> (Please correct me if that's too far wrong)\n>>\n>> Maybe it would be productive to explore this opt-in RBF part a bit\n>> more? ie, see if \"we\" can come up with better answers to some question\n>> along the lines of:\n>>\n>>  \"how can we make on-chain payments for goods priced in fiat work well\n>>   for payees that opt-in to RBF?\"\n>>\n>> That seems like the sort of thing that's better solved by a collaboration\n>> between wallet devs and merchant devs (and protocol devs?), rather than\n>> just one or the other?\n>>\n>> Is that something that we could talk about here? Or maybe it's better\n>> done via an optech workgroup or something?\n>>\n>> If \"we'll credit your account in BTC, then work out the USD coversion\n>> and deduct that for your purchase, then you can do whatever you like\n>> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n>> should just roll with that design, but make it more decentralised: have\n>> the initial payment setup a lightning channel between the customer and\n>> the merchant with the BTC (so it's not custodial), but do some magic to\n>> allow USD amounts to be transferred over it (Taro? something oracle based\n>> so that both parties are confident a fair exchange rate will be used?).\n>>\n>> Maybe that particular idea is naive, but having an actual problem to\n>> solve seems more constructive than just saying \"we want rbf\" \"but we\n>> want zeroconf\" all the time?\n>>\n>> (Ideally the lightning channels above would be dual funded so they could\n>> be used for routing more generally; but then dual funded channels are\n>> one of the things that get broken by lack of full rbf)\n>>\n>> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n>> create\n>> > > two conflicting txs in advance, one paying the merchant, one paying\n>> > > yourself, connect to many peers, relay the one paying the merchant to\n>> > > the merchant, and the other to everyone else.\n>> > > I'm just basing this off Peter Todd's stuff from years ago:\n>> > >\n>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>> > >\n>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>> > Yeah, I know the list still rehashes a single incident from 10 years ago\n>> to\n>> > declare the entire practice as unsafe, and ignores real-world data that\n>> of\n>> > the last million transactions we had zero cases of this successfully\n>> > abusing us.\n>>\n>> I mean, the avenue above isn't easy to exploit -- you have to identify\n>> the merchant's node so that they get the bad tx, and you have to connect\n>> to many peers so that your preferred tx propogates to miners first --\n>> and probably more importantly, it's relatively easy to detect -- if the\n>> merchant has a few passive nodes that the attacker doesn't know about\n>> it, and uses those to watch for attempted doublespends while it tries\n>> to ensure the real tx has propogated widely. So it doesn't surprise me\n>> at all that it's not often attempted, and even less often successful.\n>>\n>> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n>> > > > payments.\n>> > > So, based on last year's numbers, presumably that makes your bitcoin\n>> > > payments break down as something like:\n>> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n>> > >   15% txs are lightning\n>> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>> > >   60% txs are on-chain and seem fine for zeroconf\n>> > Numbers are right. Shady is too strong a word,\n>>\n>> Heh, fair enough.\n>>\n>> So the above suggests 25% of payments already get a sub-par experience,\n>> compared to what you'd like them to have (which sucks, but if you're\n>> trying to reinvent both money and payments, maybe isn't surprising). And\n>> going full rbf would bump that from 25% to 85%, which would be pretty\n>> terrible.\n>>\n>> > RBF is a strictly worse UX as proven by anyone\n>> > accepting bitcoin payments at scale.\n>>\n>> So let's make it better? Building bitcoin businesses on the lie that\n>> unconfirmed txs are safe and won't be replaced is going to bite us\n>> eventually; focussing on trying to push that back indefinitely is just\n>> going to make everyone less prepared when it eventually happens.\n>>\n>> > > > For me\n>> > > > personally it would be an easier discussion to have when Lightning\n>> is at\n>> > > > 80%+ of all bitcoin transactions.\n>> > > Can you extrapolate from the numbers you've seen to estimate when that\n>> > > might be, given current trends?\n>> > Not sure, it might be exponential growth, and the next 60% of Lightning\n>> > growth happen faster than the first 15%. Hard to tell. But we're likely\n>> > talking years here..\n>>\n>> Okay? Two years is very different from 50 years, and at the moment there's\n>> not really any data, so people are just going to go with their gut...\n>>\n>> If it were growing in line with lightning capacity in BTC, per\n>> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>> getting from 15% to 80% would then be about 8 years.\n>>\n>> Presumably that's a laughably terrible model, of course. But if we had\n>> some actual numbers where we can watch the progress, it might be a lot\n>> easier to be patient about waiting for lightning adoption to hit 80%\n>> or whatever, and focus on productive things in the meantime?\n>>\n>> Cheers,\n>> aj\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n\n-- \nEnviado desde mi dispositivo Android con K-9 Mail. Por favor, disculpa mi brevedad.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/454a5455/attachment.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-21T12:02:24",
                "message_text_only": "On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> A large number of coins/users sit on custodial rails and this would\n> essentially encumber protocol developers to those KYC/AML institutions. If\n> Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n> should this be an issue at all for reasoning about a path forward?\n>\n\nThis is a big question here, with the caveat that it's not just binance but\nin fact the majority of wallets and services that people use with bitcoin\ntoday.\nBut the question remains as you phrased: At which point do we break\nbackwards compatibility? Another analogy would be to have sunset the old\nP2PKH addresses during rollout of Segwit - it would certainly have led to\nSegwit getting rolled out faster. The rbf change actually breaks more\nthings than that, takes more effort to address than just implementing a new\naddress format. Previously in the Bitcoin Core process we've chosen to keep\nbackwards compatibility and only roll out opt-in changes with broad\nconsensus over them, with the default behavior being to not roll out\nchanges that are controversial. At which point it's time to back away from\nthat - I honestly don't know. There is probably such a point, and we should\nmaybe have some kind of discussion around that topic on a higher level,\njust as you phrased it, and I'll paraphrase:\nIf a majority of bitcoin wallets and services continue using legacy\npatterns and features, preventing progress, at which point do we want to\nbreak compatibility with them?\n\nBest,\nSergej\n\n\nOn Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev\n>> wrote:\n>> > > If someone's going to systematically exploit your store via this\n>> > > mechanism, it seems like they'd just find a single wallet with a good\n>> > > UX for opt-in RBF and lowballing fees, and go to town -- not something\n>> > > where opt-in rbf vs fullrbf policies make any difference at all?\n>> > Sort of. But yes once this starts being abused systemically we will\n>> have to\n>> > do something else w RBF payments, such as crediting the amount in BTC\n>> to a\n>> > custodial account. But this option isn't available to your normal\n>> payment\n>> > processor type business.\n>>\n>> So, what I'm hearing is:\n>>\n>>  * lightning works great, but is still pretty small\n>>  * zeroconf works great for txs that opt-out of RBF\n>>  * opt-in RBF is a pain for two reasons:\n>>     - people don't like that it's not treated as zeroconf\n>>     - the risk of fiat/BTC exchange rate changes between\n>>       now and when the tx actually confirms is worrying\n>>       even if it hasn't caused real problems yet\n>>\n>> (Please correct me if that's too far wrong)\n>>\n>> Maybe it would be productive to explore this opt-in RBF part a bit\n>> more? ie, see if \"we\" can come up with better answers to some question\n>> along the lines of:\n>>\n>>  \"how can we make on-chain payments for goods priced in fiat work well\n>>   for payees that opt-in to RBF?\"\n>>\n>> That seems like the sort of thing that's better solved by a collaboration\n>> between wallet devs and merchant devs (and protocol devs?), rather than\n>> just one or the other?\n>>\n>> Is that something that we could talk about here? Or maybe it's better\n>> done via an optech workgroup or something?\n>>\n>> If \"we'll credit your account in BTC, then work out the USD coversion\n>> and deduct that for your purchase, then you can do whatever you like\n>> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n>> should just roll with that design, but make it more decentralised: have\n>> the initial payment setup a lightning channel between the customer and\n>> the merchant with the BTC (so it's not custodial), but do some magic to\n>> allow USD amounts to be transferred over it (Taro? something oracle based\n>> so that both parties are confident a fair exchange rate will be used?).\n>>\n>> Maybe that particular idea is naive, but having an actual problem to\n>> solve seems more constructive than just saying \"we want rbf\" \"but we\n>> want zeroconf\" all the time?\n>>\n>> (Ideally the lightning channels above would be dual funded so they could\n>> be used for routing more generally; but then dual funded channels are\n>> one of the things that get broken by lack of full rbf)\n>>\n>> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n>> create\n>> > > two conflicting txs in advance, one paying the merchant, one paying\n>> > > yourself, connect to many peers, relay the one paying the merchant to\n>> > > the merchant, and the other to everyone else.\n>> > > I'm just basing this off Peter Todd's stuff from years ago:\n>> > >\n>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>> > >\n>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>> > Yeah, I know the list still rehashes a single incident from 10 years\n>> ago to\n>> > declare the entire practice as unsafe, and ignores real-world data that\n>> of\n>> > the last million transactions we had zero cases of this successfully\n>> > abusing us.\n>>\n>> I mean, the avenue above isn't easy to exploit -- you have to identify\n>> the merchant's node so that they get the bad tx, and you have to connect\n>> to many peers so that your preferred tx propogates to miners first --\n>> and probably more importantly, it's relatively easy to detect -- if the\n>> merchant has a few passive nodes that the attacker doesn't know about\n>> it, and uses those to watch for attempted doublespends while it tries\n>> to ensure the real tx has propogated widely. So it doesn't surprise me\n>> at all that it's not often attempted, and even less often successful.\n>>\n>> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n>> > > > payments.\n>> > > So, based on last year's numbers, presumably that makes your bitcoin\n>> > > payments break down as something like:\n>> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n>> > >   15% txs are lightning\n>> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>> > >   60% txs are on-chain and seem fine for zeroconf\n>> > Numbers are right. Shady is too strong a word,\n>>\n>> Heh, fair enough.\n>>\n>> So the above suggests 25% of payments already get a sub-par experience,\n>> compared to what you'd like them to have (which sucks, but if you're\n>> trying to reinvent both money and payments, maybe isn't surprising). And\n>> going full rbf would bump that from 25% to 85%, which would be pretty\n>> terrible.\n>>\n>> > RBF is a strictly worse UX as proven by anyone\n>> > accepting bitcoin payments at scale.\n>>\n>> So let's make it better? Building bitcoin businesses on the lie that\n>> unconfirmed txs are safe and won't be replaced is going to bite us\n>> eventually; focussing on trying to push that back indefinitely is just\n>> going to make everyone less prepared when it eventually happens.\n>>\n>> > > > For me\n>> > > > personally it would be an easier discussion to have when Lightning\n>> is at\n>> > > > 80%+ of all bitcoin transactions.\n>> > > Can you extrapolate from the numbers you've seen to estimate when that\n>> > > might be, given current trends?\n>> > Not sure, it might be exponential growth, and the next 60% of Lightning\n>> > growth happen faster than the first 15%. Hard to tell. But we're likely\n>> > talking years here..\n>>\n>> Okay? Two years is very different from 50 years, and at the moment there's\n>> not really any data, so people are just going to go with their gut...\n>>\n>> If it were growing in line with lightning capacity in BTC, per\n>> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>> getting from 15% to 80% would then be about 8 years.\n>>\n>> Presumably that's a laughably terrible model, of course. But if we had\n>> some actual numbers where we can watch the progress, it might be a lot\n>> easier to be patient about waiting for lightning adoption to hit 80%\n>> or whatever, and focus on productive things in the meantime?\n>>\n>> Cheers,\n>> aj\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/8abe76aa/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-21T14:01:01",
                "message_text_only": "Full-rbf is an odd duck, because while it is not a consensus issue, it does\naffect a large % of transactions made by wallets already, contrary to most\npolicy changes. We have a status quo that is understandable, but\nunfortunately long-term incentive incompatible.\n\nIt's also a UX issue, not a safety issue for retail wallet users(except\nMuun, who have given a clear timeline). Clearly considerations would be\nvery different otherwise, but retail wallets by and large do not consider\n0-conf as a valid deposit, or at least put up some warning symbols to that\neffect.\n\nCan only speak for myself, but I am looking for a concrete timeframe from\n0-conf stakeholders. I have no preference for any particular time frame, as\nlong as it can be agreed upon in the near-ish future. This keeps the\ntransition technically speaking very simple, and removes uncertainty from\ndecision making going forward.\n\nTo make a follow-on consensus analogy, I am in the BIP8\nlock-on-timeout=true camp for full rbf. If metrics arise that shows we're\nready early, great. If not, I still want to avoid having this discussion\nagain in N+ years.\n\nCheers,\nGreg\n\nOn Fri, Oct 21, 2022 at 8:02 AM Sergej Kotliar <sergej at bitrefill.com> wrote:\n\n> On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n>\n>> A large number of coins/users sit on custodial rails and this would\n>> essentially encumber protocol developers to those KYC/AML institutions. If\n>> Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n>> should this be an issue at all for reasoning about a path forward?\n>>\n>\n> This is a big question here, with the caveat that it's not just binance\n> but in fact the majority of wallets and services that people use with\n> bitcoin today.\n> But the question remains as you phrased: At which point do we break\n> backwards compatibility? Another analogy would be to have sunset the old\n> P2PKH addresses during rollout of Segwit - it would certainly have led to\n> Segwit getting rolled out faster. The rbf change actually breaks more\n> things than that, takes more effort to address than just implementing a new\n> address format. Previously in the Bitcoin Core process we've chosen to keep\n> backwards compatibility and only roll out opt-in changes with broad\n> consensus over them, with the default behavior being to not roll out\n> changes that are controversial. At which point it's time to back away from\n> that - I honestly don't know. There is probably such a point, and we should\n> maybe have some kind of discussion around that topic on a higher level,\n> just as you phrased it, and I'll paraphrase:\n> If a majority of bitcoin wallets and services continue using legacy\n> patterns and features, preventing progress, at which point do we want to\n> break compatibility with them?\n>\n> Best,\n> Sergej\n>\n>\n> On Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev\n>>> wrote:\n>>> > > If someone's going to systematically exploit your store via this\n>>> > > mechanism, it seems like they'd just find a single wallet with a good\n>>> > > UX for opt-in RBF and lowballing fees, and go to town -- not\n>>> something\n>>> > > where opt-in rbf vs fullrbf policies make any difference at all?\n>>> > Sort of. But yes once this starts being abused systemically we will\n>>> have to\n>>> > do something else w RBF payments, such as crediting the amount in BTC\n>>> to a\n>>> > custodial account. But this option isn't available to your normal\n>>> payment\n>>> > processor type business.\n>>>\n>>> So, what I'm hearing is:\n>>>\n>>>  * lightning works great, but is still pretty small\n>>>  * zeroconf works great for txs that opt-out of RBF\n>>>  * opt-in RBF is a pain for two reasons:\n>>>     - people don't like that it's not treated as zeroconf\n>>>     - the risk of fiat/BTC exchange rate changes between\n>>>       now and when the tx actually confirms is worrying\n>>>       even if it hasn't caused real problems yet\n>>>\n>>> (Please correct me if that's too far wrong)\n>>>\n>>> Maybe it would be productive to explore this opt-in RBF part a bit\n>>> more? ie, see if \"we\" can come up with better answers to some question\n>>> along the lines of:\n>>>\n>>>  \"how can we make on-chain payments for goods priced in fiat work well\n>>>   for payees that opt-in to RBF?\"\n>>>\n>>> That seems like the sort of thing that's better solved by a collaboration\n>>> between wallet devs and merchant devs (and protocol devs?), rather than\n>>> just one or the other?\n>>>\n>>> Is that something that we could talk about here? Or maybe it's better\n>>> done via an optech workgroup or something?\n>>>\n>>> If \"we'll credit your account in BTC, then work out the USD coversion\n>>> and deduct that for your purchase, then you can do whatever you like\n>>> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n>>> should just roll with that design, but make it more decentralised: have\n>>> the initial payment setup a lightning channel between the customer and\n>>> the merchant with the BTC (so it's not custodial), but do some magic to\n>>> allow USD amounts to be transferred over it (Taro? something oracle based\n>>> so that both parties are confident a fair exchange rate will be used?).\n>>>\n>>> Maybe that particular idea is naive, but having an actual problem to\n>>> solve seems more constructive than just saying \"we want rbf\" \"but we\n>>> want zeroconf\" all the time?\n>>>\n>>> (Ideally the lightning channels above would be dual funded so they could\n>>> be used for routing more generally; but then dual funded channels are\n>>> one of the things that get broken by lack of full rbf)\n>>>\n>>> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n>>> create\n>>> > > two conflicting txs in advance, one paying the merchant, one paying\n>>> > > yourself, connect to many peers, relay the one paying the merchant to\n>>> > > the merchant, and the other to everyone else.\n>>> > > I'm just basing this off Peter Todd's stuff from years ago:\n>>> > >\n>>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>> > >\n>>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>> > Yeah, I know the list still rehashes a single incident from 10 years\n>>> ago to\n>>> > declare the entire practice as unsafe, and ignores real-world data\n>>> that of\n>>> > the last million transactions we had zero cases of this successfully\n>>> > abusing us.\n>>>\n>>> I mean, the avenue above isn't easy to exploit -- you have to identify\n>>> the merchant's node so that they get the bad tx, and you have to connect\n>>> to many peers so that your preferred tx propogates to miners first --\n>>> and probably more importantly, it's relatively easy to detect -- if the\n>>> merchant has a few passive nodes that the attacker doesn't know about\n>>> it, and uses those to watch for attempted doublespends while it tries\n>>> to ensure the real tx has propogated widely. So it doesn't surprise me\n>>> at all that it's not often attempted, and even less often successful.\n>>>\n>>> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n>>> > > > payments.\n>>> > > So, based on last year's numbers, presumably that makes your bitcoin\n>>> > > payments break down as something like:\n>>> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>> > >   15% txs are lightning\n>>> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>> > >   60% txs are on-chain and seem fine for zeroconf\n>>> > Numbers are right. Shady is too strong a word,\n>>>\n>>> Heh, fair enough.\n>>>\n>>> So the above suggests 25% of payments already get a sub-par experience,\n>>> compared to what you'd like them to have (which sucks, but if you're\n>>> trying to reinvent both money and payments, maybe isn't surprising). And\n>>> going full rbf would bump that from 25% to 85%, which would be pretty\n>>> terrible.\n>>>\n>>> > RBF is a strictly worse UX as proven by anyone\n>>> > accepting bitcoin payments at scale.\n>>>\n>>> So let's make it better? Building bitcoin businesses on the lie that\n>>> unconfirmed txs are safe and won't be replaced is going to bite us\n>>> eventually; focussing on trying to push that back indefinitely is just\n>>> going to make everyone less prepared when it eventually happens.\n>>>\n>>> > > > For me\n>>> > > > personally it would be an easier discussion to have when Lightning\n>>> is at\n>>> > > > 80%+ of all bitcoin transactions.\n>>> > > Can you extrapolate from the numbers you've seen to estimate when\n>>> that\n>>> > > might be, given current trends?\n>>> > Not sure, it might be exponential growth, and the next 60% of Lightning\n>>> > growth happen faster than the first 15%. Hard to tell. But we're likely\n>>> > talking years here..\n>>>\n>>> Okay? Two years is very different from 50 years, and at the moment\n>>> there's\n>>> not really any data, so people are just going to go with their gut...\n>>>\n>>> If it were growing in line with lightning capacity in BTC, per\n>>> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>>> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>>> getting from 15% to 80% would then be about 8 years.\n>>>\n>>> Presumably that's a laughably terrible model, of course. But if we had\n>>> some actual numbers where we can watch the progress, it might be a lot\n>>> easier to be patient about waiting for lightning adoption to hit 80%\n>>> or whatever, and focus on productive things in the meantime?\n>>>\n>>> Cheers,\n>>> aj\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/ee43dfba/attachment-0001.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-21T14:19:32",
                "message_text_only": "On Fri, 21 Oct 2022 at 16:01, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> Full-rbf is an odd duck, because while it is not a consensus issue, it\n> does affect a large % of transactions made by wallets already, contrary to\n> most policy changes.\n>\n\nYeah, there are several policy features that are not consensus related but\nend up de facto setting rules for how bitcoin behaves. Minrelayfee being\nanother, and probably other examples out there that I don't know of.\n\n\n> It's also a UX issue, not a safety issue for retail wallet users(except\n> Muun, who have given a clear timeline). Clearly considerations would be\n> very different otherwise, but retail wallets by and large do not consider\n> 0-conf as a valid deposit, or at least put up some warning symbols to that\n> effect.\n>\n> Can only speak for myself, but I am looking for a concrete timeframe from\n> 0-conf stakeholders. I have no preference for any particular time frame, as\n> long as it can be agreed upon in the near-ish future. This keeps the\n> transition technically speaking very simple, and removes uncertainty from\n> decision making going forward.\n>\n\nIt's hard to give a timeframe because it's not clear what the path forward\nfor these stakeholders is. Most of what I've heard in this channel is\nthings like \"just use Lightning\" but that's contradicted by user data. So\nthe action becomes \"stop accepting payments onchain\" which isn't really a\ntimeframe type issue, it will hurt whenever it happens. Maybe a thorough\ndiscussion for a way forward would be useful here. Jeremy Rubin suggested\nan interesting idea for using CPFP to force a transaction to complete.\nWe'll evaluate it and see if it works in the wild for zero-conf of RBF\ntoday and report findings, need to evaluate from several angles first\nincentives-wise. There might also be other solutions.\n\nI'd also ask if there might also be other solutions for solving the pinning\nissue as well if we dig deep into it? Perhaps there are those with\ntradeoffs, but those tradeoffs being less significant than the tradeoffs of\nrbf policy?\n\n\nBest,\nSergej\n\n>\n> On Fri, Oct 21, 2022 at 8:02 AM Sergej Kotliar <sergej at bitrefill.com>\n> wrote:\n>\n>> On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n>>\n>>> A large number of coins/users sit on custodial rails and this would\n>>> essentially encumber protocol developers to those KYC/AML institutions. If\n>>> Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n>>> should this be an issue at all for reasoning about a path forward?\n>>>\n>>\n>> This is a big question here, with the caveat that it's not just binance\n>> but in fact the majority of wallets and services that people use with\n>> bitcoin today.\n>> But the question remains as you phrased: At which point do we break\n>> backwards compatibility? Another analogy would be to have sunset the old\n>> P2PKH addresses during rollout of Segwit - it would certainly have led to\n>> Segwit getting rolled out faster. The rbf change actually breaks more\n>> things than that, takes more effort to address than just implementing a new\n>> address format. Previously in the Bitcoin Core process we've chosen to keep\n>> backwards compatibility and only roll out opt-in changes with broad\n>> consensus over them, with the default behavior being to not roll out\n>> changes that are controversial. At which point it's time to back away from\n>> that - I honestly don't know. There is probably such a point, and we should\n>> maybe have some kind of discussion around that topic on a higher level,\n>> just as you phrased it, and I'll paraphrase:\n>> If a majority of bitcoin wallets and services continue using legacy\n>> patterns and features, preventing progress, at which point do we want to\n>> break compatibility with them?\n>>\n>> Best,\n>> Sergej\n>>\n>>\n>> On Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via\n>>>> bitcoin-dev wrote:\n>>>> > > If someone's going to systematically exploit your store via this\n>>>> > > mechanism, it seems like they'd just find a single wallet with a\n>>>> good\n>>>> > > UX for opt-in RBF and lowballing fees, and go to town -- not\n>>>> something\n>>>> > > where opt-in rbf vs fullrbf policies make any difference at all?\n>>>> > Sort of. But yes once this starts being abused systemically we will\n>>>> have to\n>>>> > do something else w RBF payments, such as crediting the amount in BTC\n>>>> to a\n>>>> > custodial account. But this option isn't available to your normal\n>>>> payment\n>>>> > processor type business.\n>>>>\n>>>> So, what I'm hearing is:\n>>>>\n>>>>  * lightning works great, but is still pretty small\n>>>>  * zeroconf works great for txs that opt-out of RBF\n>>>>  * opt-in RBF is a pain for two reasons:\n>>>>     - people don't like that it's not treated as zeroconf\n>>>>     - the risk of fiat/BTC exchange rate changes between\n>>>>       now and when the tx actually confirms is worrying\n>>>>       even if it hasn't caused real problems yet\n>>>>\n>>>> (Please correct me if that's too far wrong)\n>>>>\n>>>> Maybe it would be productive to explore this opt-in RBF part a bit\n>>>> more? ie, see if \"we\" can come up with better answers to some question\n>>>> along the lines of:\n>>>>\n>>>>  \"how can we make on-chain payments for goods priced in fiat work well\n>>>>   for payees that opt-in to RBF?\"\n>>>>\n>>>> That seems like the sort of thing that's better solved by a\n>>>> collaboration\n>>>> between wallet devs and merchant devs (and protocol devs?), rather than\n>>>> just one or the other?\n>>>>\n>>>> Is that something that we could talk about here? Or maybe it's better\n>>>> done via an optech workgroup or something?\n>>>>\n>>>> If \"we'll credit your account in BTC, then work out the USD coversion\n>>>> and deduct that for your purchase, then you can do whatever you like\n>>>> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n>>>> should just roll with that design, but make it more decentralised: have\n>>>> the initial payment setup a lightning channel between the customer and\n>>>> the merchant with the BTC (so it's not custodial), but do some magic to\n>>>> allow USD amounts to be transferred over it (Taro? something oracle\n>>>> based\n>>>> so that both parties are confident a fair exchange rate will be used?).\n>>>>\n>>>> Maybe that particular idea is naive, but having an actual problem to\n>>>> solve seems more constructive than just saying \"we want rbf\" \"but we\n>>>> want zeroconf\" all the time?\n>>>>\n>>>> (Ideally the lightning channels above would be dual funded so they could\n>>>> be used for routing more generally; but then dual funded channels are\n>>>> one of the things that get broken by lack of full rbf)\n>>>>\n>>>> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n>>>> create\n>>>> > > two conflicting txs in advance, one paying the merchant, one paying\n>>>> > > yourself, connect to many peers, relay the one paying the merchant\n>>>> to\n>>>> > > the merchant, and the other to everyone else.\n>>>> > > I'm just basing this off Peter Todd's stuff from years ago:\n>>>> > >\n>>>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>>> > >\n>>>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>>> > Yeah, I know the list still rehashes a single incident from 10 years\n>>>> ago to\n>>>> > declare the entire practice as unsafe, and ignores real-world data\n>>>> that of\n>>>> > the last million transactions we had zero cases of this successfully\n>>>> > abusing us.\n>>>>\n>>>> I mean, the avenue above isn't easy to exploit -- you have to identify\n>>>> the merchant's node so that they get the bad tx, and you have to connect\n>>>> to many peers so that your preferred tx propogates to miners first --\n>>>> and probably more importantly, it's relatively easy to detect -- if the\n>>>> merchant has a few passive nodes that the attacker doesn't know about\n>>>> it, and uses those to watch for attempted doublespends while it tries\n>>>> to ensure the real tx has propogated widely. So it doesn't surprise me\n>>>> at all that it's not often attempted, and even less often successful.\n>>>>\n>>>> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n>>>> > > > payments.\n>>>> > > So, based on last year's numbers, presumably that makes your bitcoin\n>>>> > > payments break down as something like:\n>>>> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n>>>> > >   15% txs are lightning\n>>>> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n>>>> > >   60% txs are on-chain and seem fine for zeroconf\n>>>> > Numbers are right. Shady is too strong a word,\n>>>>\n>>>> Heh, fair enough.\n>>>>\n>>>> So the above suggests 25% of payments already get a sub-par experience,\n>>>> compared to what you'd like them to have (which sucks, but if you're\n>>>> trying to reinvent both money and payments, maybe isn't surprising). And\n>>>> going full rbf would bump that from 25% to 85%, which would be pretty\n>>>> terrible.\n>>>>\n>>>> > RBF is a strictly worse UX as proven by anyone\n>>>> > accepting bitcoin payments at scale.\n>>>>\n>>>> So let's make it better? Building bitcoin businesses on the lie that\n>>>> unconfirmed txs are safe and won't be replaced is going to bite us\n>>>> eventually; focussing on trying to push that back indefinitely is just\n>>>> going to make everyone less prepared when it eventually happens.\n>>>>\n>>>> > > > For me\n>>>> > > > personally it would be an easier discussion to have when\n>>>> Lightning is at\n>>>> > > > 80%+ of all bitcoin transactions.\n>>>> > > Can you extrapolate from the numbers you've seen to estimate when\n>>>> that\n>>>> > > might be, given current trends?\n>>>> > Not sure, it might be exponential growth, and the next 60% of\n>>>> Lightning\n>>>> > growth happen faster than the first 15%. Hard to tell. But we're\n>>>> likely\n>>>> > talking years here..\n>>>>\n>>>> Okay? Two years is very different from 50 years, and at the moment\n>>>> there's\n>>>> not really any data, so people are just going to go with their gut...\n>>>>\n>>>> If it were growing in line with lightning capacity in BTC, per\n>>>> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>>>> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>>>> getting from 15% to 80% would then be about 8 years.\n>>>>\n>>>> Presumably that's a laughably terrible model, of course. But if we had\n>>>> some actual numbers where we can watch the progress, it might be a lot\n>>>> easier to be patient about waiting for lightning adoption to hit 80%\n>>>> or whatever, and focus on productive things in the meantime?\n>>>>\n>>>> Cheers,\n>>>> aj\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>\n>>\n>> --\n>>\n>> Sergej Kotliar\n>>\n>> CEO\n>>\n>>\n>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>\n>>\n>> www.bitrefill.com\n>>\n>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>> <https://www.bitrefill.com/blog/> | Angellist\n>> <https://angel.co/bitrefill>\n>>\n>\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/58c472a7/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-21T14:47:50",
                "message_text_only": "> Yeah, there are several policy features that are not consensus related\nbut end up de facto setting rules for how bitcoin behaves.\n\nYes, it's status quo so wallets \"just know\" not to do them. The fact that\nthe status quo would be changing is important, in that it may degrade UX\nfor 0-conf deposits. If bip125 was full rbf, the status quo would be the\nother way around, but here we are.\n\n> need to evaluate from several angles first incentives-wise\n\nRight, if people have put their heads together and found a few\npossibilities, we should explore the possibilities. CPFP would be an\ninteresting one used to lock in FX risk, or at least make the\ndouble-spender over-pay to exploit the delta, especially for larger\namounts/new users with no track record.\n\n> I'd also ask if there might also be other solutions for solving the\npinning issue as well if we dig deep into it? Perhaps there are those with\ntradeoffs, but those tradeoffs being less significant than the tradeoffs of\nrbf policy?\n\nThere's been a lot of work on crafting an opt-in policy that blunts the\nedges of pinning attacks, and I think we've gotten to the point where it\ncan be said if you opt into this scheme: \"If I have a required key in every\ntransaction input script, I can safely and efficiently fee bump the\ntransaction\" through a mixture of RBF/CPFP, depending on structure.\n\nPlease see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021036.html\nand issues linked in that e-mail, if you're interested in the set of policy\nchanges required to get there. Note that these would still all be opt-in.\n\nThis unfortunately rules out any \"coinjoin\" like scenario, including\ndual-funding lightning channels(which is close to landing finally). The\ngood news is that those cases seem to not have theft risk, just normal DoS\nrisk of funds being stuck for potentially weeks. It would also rule out\nanything like coinpools, or other advanced constructs that don't actually\nexist yet.\n\nMaybe the above proposals make RBF'ing super reliable compared to today,\nand that changes the calculus for wallet authors, but this is still a ways\nout as these are still early proposals.\n\n> it will hurt whenever it happens\n\nYes it's a risk that this never gets satisfactorily resolved, which is why\nI was mentioning a potentially long \"timeout\" being decided in the near-ish\nfuture. Let's gather what we can, start building aspirationally towards\nthat, and try to not beat this horse again.\n\nGreg\n\nOn Fri, Oct 21, 2022 at 10:19 AM Sergej Kotliar <sergej at bitrefill.com>\nwrote:\n\n>\n>\n> On Fri, 21 Oct 2022 at 16:01, Greg Sanders <gsanders87 at gmail.com> wrote:\n>\n>> Full-rbf is an odd duck, because while it is not a consensus issue, it\n>> does affect a large % of transactions made by wallets already, contrary to\n>> most policy changes.\n>>\n>\n> Yeah, there are several policy features that are not consensus related but\n> end up de facto setting rules for how bitcoin behaves. Minrelayfee being\n> another, and probably other examples out there that I don't know of.\n>\n>\n>> It's also a UX issue, not a safety issue for retail wallet users(except\n>> Muun, who have given a clear timeline). Clearly considerations would be\n>> very different otherwise, but retail wallets by and large do not consider\n>> 0-conf as a valid deposit, or at least put up some warning symbols to that\n>> effect.\n>>\n>> Can only speak for myself, but I am looking for a concrete timeframe from\n>> 0-conf stakeholders. I have no preference for any particular time frame, as\n>> long as it can be agreed upon in the near-ish future. This keeps the\n>> transition technically speaking very simple, and removes uncertainty from\n>> decision making going forward.\n>>\n>\n> It's hard to give a timeframe because it's not clear what the path forward\n> for these stakeholders is. Most of what I've heard in this channel is\n> things like \"just use Lightning\" but that's contradicted by user data. So\n> the action becomes \"stop accepting payments onchain\" which isn't really a\n> timeframe type issue, it will hurt whenever it happens. Maybe a thorough\n> discussion for a way forward would be useful here. Jeremy Rubin suggested\n> an interesting idea for using CPFP to force a transaction to complete.\n> We'll evaluate it and see if it works in the wild for zero-conf of RBF\n> today and report findings, need to evaluate from several angles first\n> incentives-wise. There might also be other solutions.\n>\n> I'd also ask if there might also be other solutions for solving the\n> pinning issue as well if we dig deep into it? Perhaps there are those with\n> tradeoffs, but those tradeoffs being less significant than the tradeoffs of\n> rbf policy?\n>\n>\n> Best,\n> Sergej\n>\n>>\n>> On Fri, Oct 21, 2022 at 8:02 AM Sergej Kotliar <sergej at bitrefill.com>\n>> wrote:\n>>\n>>> On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n>>>\n>>>> A large number of coins/users sit on custodial rails and this would\n>>>> essentially encumber protocol developers to those KYC/AML institutions. If\n>>>> Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n>>>> should this be an issue at all for reasoning about a path forward?\n>>>>\n>>>\n>>> This is a big question here, with the caveat that it's not just binance\n>>> but in fact the majority of wallets and services that people use with\n>>> bitcoin today.\n>>> But the question remains as you phrased: At which point do we break\n>>> backwards compatibility? Another analogy would be to have sunset the old\n>>> P2PKH addresses during rollout of Segwit - it would certainly have led to\n>>> Segwit getting rolled out faster. The rbf change actually breaks more\n>>> things than that, takes more effort to address than just implementing a new\n>>> address format. Previously in the Bitcoin Core process we've chosen to keep\n>>> backwards compatibility and only roll out opt-in changes with broad\n>>> consensus over them, with the default behavior being to not roll out\n>>> changes that are controversial. At which point it's time to back away from\n>>> that - I honestly don't know. There is probably such a point, and we should\n>>> maybe have some kind of discussion around that topic on a higher level,\n>>> just as you phrased it, and I'll paraphrase:\n>>> If a majority of bitcoin wallets and services continue using legacy\n>>> patterns and features, preventing progress, at which point do we want to\n>>> break compatibility with them?\n>>>\n>>> Best,\n>>> Sergej\n>>>\n>>>\n>>> On Thu, Oct 20, 2022 at 3:59 PM Anthony Towns via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via\n>>>>> bitcoin-dev wrote:\n>>>>> > > If someone's going to systematically exploit your store via this\n>>>>> > > mechanism, it seems like they'd just find a single wallet with a\n>>>>> good\n>>>>> > > UX for opt-in RBF and lowballing fees, and go to town -- not\n>>>>> something\n>>>>> > > where opt-in rbf vs fullrbf policies make any difference at all?\n>>>>> > Sort of. But yes once this starts being abused systemically we will\n>>>>> have to\n>>>>> > do something else w RBF payments, such as crediting the amount in\n>>>>> BTC to a\n>>>>> > custodial account. But this option isn't available to your normal\n>>>>> payment\n>>>>> > processor type business.\n>>>>>\n>>>>> So, what I'm hearing is:\n>>>>>\n>>>>>  * lightning works great, but is still pretty small\n>>>>>  * zeroconf works great for txs that opt-out of RBF\n>>>>>  * opt-in RBF is a pain for two reasons:\n>>>>>     - people don't like that it's not treated as zeroconf\n>>>>>     - the risk of fiat/BTC exchange rate changes between\n>>>>>       now and when the tx actually confirms is worrying\n>>>>>       even if it hasn't caused real problems yet\n>>>>>\n>>>>> (Please correct me if that's too far wrong)\n>>>>>\n>>>>> Maybe it would be productive to explore this opt-in RBF part a bit\n>>>>> more? ie, see if \"we\" can come up with better answers to some question\n>>>>> along the lines of:\n>>>>>\n>>>>>  \"how can we make on-chain payments for goods priced in fiat work well\n>>>>>   for payees that opt-in to RBF?\"\n>>>>>\n>>>>> That seems like the sort of thing that's better solved by a\n>>>>> collaboration\n>>>>> between wallet devs and merchant devs (and protocol devs?), rather than\n>>>>> just one or the other?\n>>>>>\n>>>>> Is that something that we could talk about here? Or maybe it's better\n>>>>> done via an optech workgroup or something?\n>>>>>\n>>>>> If \"we'll credit your account in BTC, then work out the USD coversion\n>>>>> and deduct that for your purchase, then you can do whatever you like\n>>>>> with any remaining BTC from your on-chain payment\" is the idea, maybe\n>>>>> we\n>>>>> should just roll with that design, but make it more decentralised: have\n>>>>> the initial payment setup a lightning channel between the customer and\n>>>>> the merchant with the BTC (so it's not custodial), but do some magic to\n>>>>> allow USD amounts to be transferred over it (Taro? something oracle\n>>>>> based\n>>>>> so that both parties are confident a fair exchange rate will be used?).\n>>>>>\n>>>>> Maybe that particular idea is naive, but having an actual problem to\n>>>>> solve seems more constructive than just saying \"we want rbf\" \"but we\n>>>>> want zeroconf\" all the time?\n>>>>>\n>>>>> (Ideally the lightning channels above would be dual funded so they\n>>>>> could\n>>>>> be used for routing more generally; but then dual funded channels are\n>>>>> one of the things that get broken by lack of full rbf)\n>>>>>\n>>>>> > > I thought the \"normal\" avenue for fooling non-RBF zeroconf was to\n>>>>> create\n>>>>> > > two conflicting txs in advance, one paying the merchant, one paying\n>>>>> > > yourself, connect to many peers, relay the one paying the merchant\n>>>>> to\n>>>>> > > the merchant, and the other to everyone else.\n>>>>> > > I'm just basing this off Peter Todd's stuff from years ago:\n>>>>> > >\n>>>>> https://np.reddit.com/r/Bitcoin/comments/40ejy8/peter_todd_with_my_doublespendpy_tool_with/cytlhh0/\n>>>>> > >\n>>>>> https://github.com/petertodd/replace-by-fee-tools/blob/master/doublespend.py\n>>>>> > Yeah, I know the list still rehashes a single incident from 10 years\n>>>>> ago to\n>>>>> > declare the entire practice as unsafe, and ignores real-world data\n>>>>> that of\n>>>>> > the last million transactions we had zero cases of this successfully\n>>>>> > abusing us.\n>>>>>\n>>>>> I mean, the avenue above isn't easy to exploit -- you have to identify\n>>>>> the merchant's node so that they get the bad tx, and you have to\n>>>>> connect\n>>>>> to many peers so that your preferred tx propogates to miners first --\n>>>>> and probably more importantly, it's relatively easy to detect -- if the\n>>>>> merchant has a few passive nodes that the attacker doesn't know about\n>>>>> it, and uses those to watch for attempted doublespends while it tries\n>>>>> to ensure the real tx has propogated widely. So it doesn't surprise me\n>>>>> at all that it's not often attempted, and even less often successful.\n>>>>>\n>>>>> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n>>>>> > > > payments.\n>>>>> > > So, based on last year's numbers, presumably that makes your\n>>>>> bitcoin\n>>>>> > > payments break down as something like:\n>>>>> > >    5% txs are on-chain and seem shady and are excluded from\n>>>>> zeroconf\n>>>>> > >   15% txs are lightning\n>>>>> > >   20% txs are on-chain but signal rbf and are excluded from\n>>>>> zeroconf\n>>>>> > >   60% txs are on-chain and seem fine for zeroconf\n>>>>> > Numbers are right. Shady is too strong a word,\n>>>>>\n>>>>> Heh, fair enough.\n>>>>>\n>>>>> So the above suggests 25% of payments already get a sub-par experience,\n>>>>> compared to what you'd like them to have (which sucks, but if you're\n>>>>> trying to reinvent both money and payments, maybe isn't surprising).\n>>>>> And\n>>>>> going full rbf would bump that from 25% to 85%, which would be pretty\n>>>>> terrible.\n>>>>>\n>>>>> > RBF is a strictly worse UX as proven by anyone\n>>>>> > accepting bitcoin payments at scale.\n>>>>>\n>>>>> So let's make it better? Building bitcoin businesses on the lie that\n>>>>> unconfirmed txs are safe and won't be replaced is going to bite us\n>>>>> eventually; focussing on trying to push that back indefinitely is just\n>>>>> going to make everyone less prepared when it eventually happens.\n>>>>>\n>>>>> > > > For me\n>>>>> > > > personally it would be an easier discussion to have when\n>>>>> Lightning is at\n>>>>> > > > 80%+ of all bitcoin transactions.\n>>>>> > > Can you extrapolate from the numbers you've seen to estimate when\n>>>>> that\n>>>>> > > might be, given current trends?\n>>>>> > Not sure, it might be exponential growth, and the next 60% of\n>>>>> Lightning\n>>>>> > growth happen faster than the first 15%. Hard to tell. But we're\n>>>>> likely\n>>>>> > talking years here..\n>>>>>\n>>>>> Okay? Two years is very different from 50 years, and at the moment\n>>>>> there's\n>>>>> not really any data, so people are just going to go with their gut...\n>>>>>\n>>>>> If it were growing in line with lightning capacity in BTC, per\n>>>>> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n>>>>> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n>>>>> getting from 15% to 80% would then be about 8 years.\n>>>>>\n>>>>> Presumably that's a laughably terrible model, of course. But if we had\n>>>>> some actual numbers where we can watch the progress, it might be a lot\n>>>>> easier to be patient about waiting for lightning adoption to hit 80%\n>>>>> or whatever, and focus on productive things in the meantime?\n>>>>>\n>>>>> Cheers,\n>>>>> aj\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>\n>>>\n>>> --\n>>>\n>>> Sergej Kotliar\n>>>\n>>> CEO\n>>>\n>>>\n>>> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>>>\n>>>\n>>> www.bitrefill.com\n>>>\n>>> Twitter <https://www.twitter.com/bitrefill> | Blog\n>>> <https://www.bitrefill.com/blog/> | Angellist\n>>> <https://angel.co/bitrefill>\n>>>\n>>\n>\n> --\n>\n> Sergej Kotliar\n>\n> CEO\n>\n>\n> Twitter: @ziggamon <https://twitter.com/ziggamon>\n>\n>\n> www.bitrefill.com\n>\n> Twitter <https://www.twitter.com/bitrefill> | Blog\n> <https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/710aba0e/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-21T19:43:33",
                "message_text_only": "On Fri, Oct 21, 2022 at 02:02:24PM +0200, Sergej Kotliar via bitcoin-dev wrote:\n> On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n> \n> > A large number of coins/users sit on custodial rails and this would\n> > essentially encumber protocol developers to those KYC/AML institutions. If\n> > Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n> > should this be an issue at all for reasoning about a path forward?\n> >\n> \n> This is a big question here, with the caveat that it's not just binance but\n> in fact the majority of wallets and services that people use with bitcoin\n> today.\n> But the question remains as you phrased: At which point do we break\n> backwards compatibility? Another analogy would be to have sunset the old\n> P2PKH addresses during rollout of Segwit - it would certainly have led to\n> Segwit getting rolled out faster. The rbf change actually breaks more\n> things than that, takes more effort to address than just implementing a new\n> address format. Previously in the Bitcoin Core process we've chosen to keep\n\nRBF certainly does not break more things than depreciating an entire address\nstandard. P2PKH addresses are still used by old wallets, and it's often not\nworth the risk to upgrade to new software for old coins kept offline by\nordinary users. I personally have used P2PKH addresses in the past few months.\n\nZeroconf on the other hand has never worked reliably, so you can't even claim\nit's a \"supported feature\". And the fact is, it breaks all the time because\nevery time miners change their acceptance rules - eg with new releases - we\nbreak it every single time we do a new release with different you can easily\nexploit zeroconf.\n\nFrankly, the fact that we didn't widely implement full-rbf sooner is quite\nunfortunate, as Bitrefill, Muun, etc. should have never been using it in the\nfirst place.\n\n> If a majority of bitcoin wallets and services continue using legacy\n> patterns and features, preventing progress, at which point do we want to\n> break compatibility with them?\n\nIt's clearly false to claim that the \"majority of bitcoin wallets and services\"\nare using zeroconf. A tiny minority are attempting to use it, with the vast\nmajority of previous users having given up on it.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/6901395e/attachment.sig>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-24T07:55:59",
                "message_text_only": "On Fri, 21 Oct 2022 at 21:43, Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Oct 21, 2022 at 02:02:24PM +0200, Sergej Kotliar via bitcoin-dev\n> wrote:\n> > On Thu, 20 Oct 2022 at 23:07, Greg Sanders <gsanders87 at gmail.com> wrote:\n> >\n> > > A large number of coins/users sit on custodial rails and this would\n> > > essentially encumber protocol developers to those KYC/AML\n> institutions. If\n> > > Binance decides to never support Lightning in favor of BNC-wrapped BTC,\n> > > should this be an issue at all for reasoning about a path forward?\n> > >\n> >\n> > This is a big question here, with the caveat that it's not just binance\n> but\n> > in fact the majority of wallets and services that people use with bitcoin\n> > today.\n> > But the question remains as you phrased: At which point do we break\n> > backwards compatibility? Another analogy would be to have sunset the old\n> > P2PKH addresses during rollout of Segwit - it would certainly have led to\n> > Segwit getting rolled out faster. The rbf change actually breaks more\n> > things than that, takes more effort to address than just implementing a\n> new\n> > address format. Previously in the Bitcoin Core process we've chosen to\n> keep\n>\n> RBF certainly does not break more things than depreciating an entire\n> address\n> standard. P2PKH addresses are still used by old wallets, and it's often not\n> worth the risk to upgrade to new software for old coins kept offline by\n> ordinary users. I personally have used P2PKH addresses in the past few\n> months.\n>\n> Zeroconf on the other hand has never worked reliably, so you can't even\n> claim\n> it's a \"supported feature\". And the fact is, it breaks all the time because\n> every time miners change their acceptance rules - eg with new releases - we\n> break it every single time we do a new release with different you can\n> easily\n> exploit zeroconf.\n>\n\nHaven't heard of any release breaking zeroconf. I would absolutely say it's\nworking reliably.\n\n\n> Frankly, the fact that we didn't widely implement full-rbf sooner is quite\n> unfortunate, as Bitrefill, Muun, etc. should have never been using it in\n> the\n> first place.\n>\n\nYou make it sound like we're the odd ones out when it's in fact ~every\nservice that lets you buy stuff with bitcoin. It's just that we're the only\nones raising voices on the mailing list so far. On the contrary side, can\nyou name one service that lets you buy stuff with bitcoin that doesn't rely\non zeroconf? Maybe with the caveat that it should have some level of scale\nand an audience not consisting of only power users.\n\n\n> > If a majority of bitcoin wallets and services continue using legacy\n> > patterns and features, preventing progress, at which point do we want to\n> > break compatibility with them?\n>\n> It's clearly false to claim that the \"majority of bitcoin wallets and\n> services\"\n> are using zeroconf. A tiny minority are attempting to use it, with the vast\n> majority of previous users having given up on it.\n>\n\nI didn't claim that. But it's definitely true that the vast majority of\nwallets and services do not allow users to do RBF. This is easy to validate\nas the list of wallets with RBF support is short), the list of exchanges\nwith RBF support is zero.\nhttps://transactionfee.info/charts/transactions-signaling-explicit-rbf/\n29% of txs signal RBF, meaning 71% do not. And let's be honest, it's not\nlike the majority of those were given a choice and chose not to, for the\nmajority their wallet just doesn't support RBF.\n\n\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221024/3af758f1/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T22:13:15",
                "message_text_only": "On Fri, Oct 21, 2022 at 05:58:41AM +1000, Anthony Towns via bitcoin-dev wrote:\n> On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev wrote:\n> > > If someone's going to systematically exploit your store via this\n> > > mechanism, it seems like they'd just find a single wallet with a good\n> > > UX for opt-in RBF and lowballing fees, and go to town -- not something\n> > > where opt-in rbf vs fullrbf policies make any difference at all?\n> > Sort of. But yes once this starts being abused systemically we will have to\n> > do something else w RBF payments, such as crediting the amount in BTC to a\n> > custodial account. But this option isn't available to your normal payment\n> > processor type business.\n> \n> So, what I'm hearing is:\n> \n>  * lightning works great, but is still pretty small\n>  * zeroconf works great for txs that opt-out of RBF\n\nIt's important to note that the businesses that say \"zeroconf works great\" for\nthem, appear to be achieving that by sybil attacking the network to measure\npropagation. That's not sustainable nor decentralized, as only a small number\nof companies can do that without causing a lot of harm to Bitcoin by using up\ninbound slots. We've gone through this before with \"zeroconf guarantee\"\nservices, and the end result is not good.\n\nIt's in our interests to make sure those companies stop doing that, and no new\ncompanies start.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/0edeef01/attachment.sig>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-21T09:34:17",
                "message_text_only": "This is factually incorrect and not required for us to do what we do.\n\nOn Fri, 21 Oct 2022 at 00:13, Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Oct 21, 2022 at 05:58:41AM +1000, Anthony Towns via bitcoin-dev\n> wrote:\n> > On Thu, Oct 20, 2022 at 02:37:53PM +0200, Sergej Kotliar via bitcoin-dev\n> wrote:\n> > > > If someone's going to systematically exploit your store via this\n> > > > mechanism, it seems like they'd just find a single wallet with a good\n> > > > UX for opt-in RBF and lowballing fees, and go to town -- not\n> something\n> > > > where opt-in rbf vs fullrbf policies make any difference at all?\n> > > Sort of. But yes once this starts being abused systemically we will\n> have to\n> > > do something else w RBF payments, such as crediting the amount in BTC\n> to a\n> > > custodial account. But this option isn't available to your normal\n> payment\n> > > processor type business.\n> >\n> > So, what I'm hearing is:\n> >\n> >  * lightning works great, but is still pretty small\n> >  * zeroconf works great for txs that opt-out of RBF\n>\n> It's important to note that the businesses that say \"zeroconf works great\"\n> for\n> them, appear to be achieving that by sybil attacking the network to measure\n> propagation. That's not sustainable nor decentralized, as only a small\n> number\n> of companies can do that without causing a lot of harm to Bitcoin by using\n> up\n> inbound slots. We've gone through this before with \"zeroconf guarantee\"\n> services, and the end result is not good.\n>\n> It's in our interests to make sure those companies stop doing that, and no\n> new\n> companies start.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/8043e767/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-21T19:33:46",
                "message_text_only": "On Fri, Oct 21, 2022 at 11:34:17AM +0200, Sergej Kotliar wrote:\n> This is factually incorrect and not required for us to do what we do.\n\nSo how do you detect people sending conflicting transactions?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/c4a3af47/attachment.sig>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-24T07:45:13",
                "message_text_only": "There are many countermeasures that can be done, we've only implemented a\nsubset of them as more haven't been needed.\n\nMainly we wait some time to make sure any conflicting transaction has time\nto propagate on the network. We have well connected nodes with basic\nredundancy.\nWhen they are available we sometimes use external block explorers for\ncertain nice-to-have enhancements, but it's absolutely not required for\nzeroconf as they are frequently down.\n\nI can of course only speak to our custom-built setup, presumably everyone\nwho accepts payments with bitcoin uses something similar. Regardless, let's\nmaybe not go as far as to say that anyone who accepts payments with bitcoin\nis attacking bitcoin ;)\n\nOn Fri, 21 Oct 2022 at 21:33, Peter Todd <pete at petertodd.org> wrote:\n\n> On Fri, Oct 21, 2022 at 11:34:17AM +0200, Sergej Kotliar wrote:\n> > This is factually incorrect and not required for us to do what we do.\n>\n> So how do you detect people sending conflicting transactions?\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221024/0d2b48c5/attachment-0001.html>"
            },
            {
                "author": "Sergej Kotliar",
                "date": "2022-10-21T11:56:51",
                "message_text_only": "On Thu, 20 Oct 2022 at 21:58, Anthony Towns <aj at erisian.com.au> wrote:\n\n> So, what I'm hearing is:\n>\n>  * lightning works great, but is still pretty small\n>  * zeroconf works great for txs that opt-out of RBF\n>  * opt-in RBF is a pain for two reasons:\n>     - people don't like that it's not treated as zeroconf\n>     - the risk of fiat/BTC exchange rate changes between\n>       now and when the tx actually confirms is worrying\n>       even if it hasn't caused real problems yet\n>\n> This is about right yes\n\n\n> Maybe it would be productive to explore this opt-in RBF part a bit\n> more? ie, see if \"we\" can come up with better answers to some question\n> along the lines of:\n>\n>  \"how can we make on-chain payments for goods priced in fiat work well\n>   for payees that opt-in to RBF?\"\n>\n> That seems like the sort of thing that's better solved by a collaboration\n> between wallet devs and merchant devs (and protocol devs?), rather than\n> just one or the other?\n>\n> Is that something that we could talk about here? Or maybe it's better\n> done via an optech workgroup or something?\n>\n\nAgreed, more work is needed in the regard and we're happy to participate in\nany efforts to make things better. It's not like we _want_ to be against\nthe core dev roadmap :)\n\n\n> If \"we'll credit your account in BTC, then work out the USD coversion\n> and deduct that for your purchase, then you can do whatever you like\n> with any remaining BTC from your on-chain payment\" is the idea, maybe we\n> should just roll with that design, but make it more decentralised: have\n> the initial payment setup a lightning channel between the customer and\n> the merchant with the BTC (so it's not custodial), but do some magic to\n> allow USD amounts to be transferred over it (Taro? something oracle based\n> so that both parties are confident a fair exchange rate will be used?).\n>\n> Maybe that particular idea is naive, but having an actual problem to\n> solve seems more constructive than just saying \"we want rbf\" \"but we\n> want zeroconf\" all the time?\n>\n\nDon't think it would solve any of the issues even if the above could\ntechnically work, which it can't, simply because wallets that can only do\ndump onchain payments are unlikely to be able to implement a scheme like\nthis.\n\n\n> > > > Currently Lightning is somewhere around 15% of our total bitcoin\n> > > > payments.\n> > > So, based on last year's numbers, presumably that makes your bitcoin\n> > > payments break down as something like:\n> > >    5% txs are on-chain and seem shady and are excluded from zeroconf\n> > >   15% txs are lightning\n> > >   20% txs are on-chain but signal rbf and are excluded from zeroconf\n> > >   60% txs are on-chain and seem fine for zeroconf\n> > Numbers are right. Shady is too strong a word,\n>\n> Heh, fair enough.\n>\n> So the above suggests 25% of payments already get a sub-par experience,\n> compared to what you'd like them to have (which sucks, but if you're\n> trying to reinvent both money and payments, maybe isn't surprising). And\n> going full rbf would bump that from 25% to 85%, which would be pretty\n> terrible.\n>\n> > RBF is a strictly worse UX as proven by anyone\n> > accepting bitcoin payments at scale.\n>\n> So let's make it better? Building bitcoin businesses on the lie that\n> unconfirmed txs are safe and won't be replaced is going to bite us\n> eventually; focussing on trying to push that back indefinitely is just\n> going to make everyone less prepared when it eventually happens.\n>\n\nSure. The question is if we \"make it better\" first or if we standardize on\nthat which works worse first.\n\n\n> > > > For me\n> > > > personally it would be an easier discussion to have when Lightning\n> is at\n> > > > 80%+ of all bitcoin transactions.\n> > > Can you extrapolate from the numbers you've seen to estimate when that\n> > > might be, given current trends?\n> > Not sure, it might be exponential growth, and the next 60% of Lightning\n> > growth happen faster than the first 15%. Hard to tell. But we're likely\n> > talking years here..\n>\n> Okay? Two years is very different from 50 years, and at the moment there's\n> not really any data, so people are just going to go with their gut...\n>\n> If it were growing in line with lightning capacity in BTC, per\n> bitcoinvisuals.com/ln-capacity; then 15% now would have grown from\n> perhaps 4% in May 2021, so perhaps 8% per year. With linear growth,\n> getting from 15% to 80% would then be about 8 years.\n>\n\nThis math doesn't work. Capacity is a bad metric for activity, something we\nunfortunately imported from the ETH world's TVL. Liquid has the same number\nof btc on it as Lightning, but we probably all know there are several\norders of magnitude of difference in terms of usage.\n\nThere is another type of linear math that can but done but it's\nsignificantly more gloomy: Over the past 3 years the share of bitcoin\npayments among services has dropped from ~90%+ to below 50%. These figures\nare similar across Bitrefill, Living Room of Satoshi, CoinCards, Bitpay\nwhich is all the sources I know that have published stats on this. If we\nassume this trend continues at that pace we might be at a point where\npayments on Bitcoin are irrelevant, especially onchain, and there isn't\nmuch left to argue over. I don't think that's going to happen tho, this\nmath probably also doesn't work for the same reasons, and we will work hard\nfor it to not happen. Fundamentally the issue of legacy support for bitcoin\nthings remains, and the ossification that happened on bitcoin things around\nthe 2015 level of UX. Solving that issue has proven to be a very tricky\nsubject, that we spend lots of energy on, but yet without overwhelming\nsuccess.\n\nBest,\nSergej\n\n\n-- \n\nSergej Kotliar\n\nCEO\n\n\nTwitter: @ziggamon <https://twitter.com/ziggamon>\n\n\nwww.bitrefill.com\n\nTwitter <https://www.twitter.com/bitrefill> | Blog\n<https://www.bitrefill.com/blog/> | Angellist <https://angel.co/bitrefill>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/9b76400a/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2022-10-23T19:20:41",
                "message_text_only": "On 2022-10-19 04:29, Sergej Kotliar via bitcoin-dev wrote:\n> The biggest risk\n> in accepting bitcoin payments is in fact not zeroconf risk (it's\n> actually quite easily managed), it's FX risk as the merchant must\n> commit to a certain BTCUSD rate ahead of time for a purchase. Over\n> time some transactions lose money to FX and others earn money - that\n> evens out in the end. But if there is an _easily accessible in the\n> wallet_ feature to \"cancel transaction\" that means it will eventually\n> get systematically abused.\n\nOne way to address this risk is by turning it into a certainty.  If the \nprice of BTC increases between when the invoice is generated and when a \ntransaction is included in a block, give the customer a future purchase \ncredit equal in value to the difference between the price they paid and \nthe value of the purchase at confirmation time.  Now there's no benefit \nto the customer from canceling their transaction.\n\nOf course, this means that the merchant will always either break even or \nlose money on the exchange rate part of the transaction and will need to \nraise their prices accordingly.  I can see how that would be unappealing \nto implement, but it seems better to me to address the incentive \nincompatibility you've raised rather than hope no large miners ever \nstart performing full RBF.  Plus, maybe the future credit feature is \nsomething customers would like: I know I've been sad several times when \nthe exchange rate changed significantly while I was waiting for one of \nmy transactions to confirm.\n\nThe above mitigation is also compatible with LN payments.  For example, \na merchant today might issue an LN invoice that expires in 10 minutes.  \nThe customer can wait for most of that time to elapse to see how the \nexchange rate changes before deciding to pay, obtaining the same \nAmerican call option.  If they are instead offered a future purchase \ncredit for any gains, the customer doesn't suffer any opportunity cost \nby paying immediately.  (With LN, it might be possible to have a better \nUX for this by either refunding any excess or (if using something like \nOriginal AMP or PTLCs) not claiming any parts of the payment which are \nin excess.)\n\n-Dave"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-23T20:51:16",
                "message_text_only": "Hi Dave,\n\n> One way to address this risk is by turning it into a certainty.  If the \nprice of BTC increases between when the invoice is generated and when a \ntransaction is included in a block, give the customer a future purchase \ncredit equal in value to the difference between the price they paid and \nthe value of the purchase at confirmation time.  Now there's no benefit \nto the customer from canceling their transaction.\n\nThere are several methods to approach this issue, one of which is by using multiple exchanges from different countries as there are always possibilities for arbitrage. Example:\n\nThe user purchases a gift card on Bitrefill for 0.01 BTC, and then Bitrefill cash it out at one of the three exchanges where the price of bitcoin is 19000, 19100, or 19500. However, price used for gift card payment was average of all 3. This should never be solved at protocol level as speculation of price is irrelevant when making RBF policy default in bitcoin core.\n\nThere are different types of businesses that accept bitcoin payments and its good for bitcoin. However, everyone has their own way to deal with the issues. Example:\n\nIn a website for booking flights, you may cancel a user's ticket if they couldn't make a payment within a certain amount of time and confirmations. I'm not sure how gift cards operate, but they are used for carding, fraud etc. frequently.\n\nIts important to give priority to bitcoin projects that could improve demand for block space even if opening and closing channels. I would [quote][0] something from a pull request by Michael Folkson although I do not agree with everything he writes:\n\n\"I don't believe in added code (complexity) for issues that can be resolved in alternative repos and through communication with the ecosystem.\"\n\nThings that could help improve business for companies that accept bitcoin payments could be done in other ways. Zero conf is old school but we can try new ways and do partnerships with more organizations (outside North America and Europe). I work for an exchange as developer although CTO won't write an email and CEO don't want to spam the mailing list with non technical things. I request on their behalf that we consider all businesses and some are not even aware of fullRBF. Example: Lolli or Gosats\n\nTL;DR\n\nFull RBF should be tried and if default is an issue, devs should convince some nodes and miners or agree on one of the pull requests. I prefer [AJ's pull request][1] because it gives time for review and testing. It is important to test as many websites, apps, projects etc. as possible before making something default and also consider the percent of usage.\n\n[0]: https://github.com/bitcoin/bitcoin/pull/26323#issuecomment-1280742475\n[1]: https://github.com/bitcoin/bitcoin/pull/26323\n\n\n/dev/fd0\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Monday, October 24th, 2022 at 12:50 AM, David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> On 2022-10-19 04:29, Sergej Kotliar via bitcoin-dev wrote:\n> \n> > The biggest risk\n> > in accepting bitcoin payments is in fact not zeroconf risk (it's\n> > actually quite easily managed), it's FX risk as the merchant must\n> > commit to a certain BTCUSD rate ahead of time for a purchase. Over\n> > time some transactions lose money to FX and others earn money - that\n> > evens out in the end. But if there is an easily accessible in the\n> > wallet feature to \"cancel transaction\" that means it will eventually\n> > get systematically abused.\n> \n> \n> One way to address this risk is by turning it into a certainty. If the\n> price of BTC increases between when the invoice is generated and when a\n> transaction is included in a block, give the customer a future purchase\n> credit equal in value to the difference between the price they paid and\n> the value of the purchase at confirmation time. Now there's no benefit\n> to the customer from canceling their transaction.\n> \n> Of course, this means that the merchant will always either break even or\n> lose money on the exchange rate part of the transaction and will need to\n> raise their prices accordingly. I can see how that would be unappealing\n> to implement, but it seems better to me to address the incentive\n> incompatibility you've raised rather than hope no large miners ever\n> start performing full RBF. Plus, maybe the future credit feature is\n> something customers would like: I know I've been sad several times when\n> the exchange rate changed significantly while I was waiting for one of\n> my transactions to confirm.\n> \n> The above mitigation is also compatible with LN payments. For example,\n> a merchant today might issue an LN invoice that expires in 10 minutes.\n> The customer can wait for most of that time to elapse to see how the\n> exchange rate changes before deciding to pay, obtaining the same\n> American call option. If they are instead offered a future purchase\n> credit for any gains, the customer doesn't suffer any opportunity cost\n> by paying immediately. (With LN, it might be possible to have a better\n> UX for this by either refunding any excess or (if using something like\n> Original AMP or PTLCs) not claiming any parts of the payment which are\n> in excess.)\n> \n> -Dave\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "Zero-conf apps in immediate danger",
            "categories": [
                "bitcoin-dev",
                "Opt-in full-RBF"
            ],
            "authors": [
                "linuxfoundation.cndm1 at dralias.com",
                "Antoine Riard",
                "David A. Harding",
                "Anthony Towns",
                "Eloy",
                "John Carvalho",
                "Peter Todd",
                "Sergej Kotliar",
                "alicexbt",
                "Luke Dashjr",
                "Erik Aronesty",
                "Pieter Wuille",
                "Dario Sneidermanis",
                "Jeremy Rubin",
                "Ruben Somsen",
                "Greg Sanders"
            ],
            "messages_count": 61,
            "total_messages_chars_count": 402894
        }
    },
    {
        "title": "[bitcoin-dev] Refreshed BIP324",
        "thread_messages": [
            {
                "author": "Dhruv M",
                "date": "2022-10-08T12:59:58",
                "message_text_only": "Hi all,\n\nWe have refreshed the proposal for BIP324, a new bitcoin P2P protocol\nfeaturing opportunistic encryption, a mild bandwidth reduction, and the\nability\nto negotiate upgrades before exchanging application messages. We'd like\nto invite community members to review the BIP[1] and the related Bitcoin\nCore\ncode[2].\n\nThe proposal has a rich history[3]. The big changes since the last public\nappearance[4] are:\n\n* Elligator-swift encoding for the pubkeys in the ECDH exchange to\nobtain a pseudorandom bytestream\n* x-only ECDH secret derivation\n* Transport versioning that allows for upgradability\n* Trafic shapability using decoy packets and a shapable handshake\n* Complete rewrite of the BIP text\n\nWe look forward to your review and comments.\n\n-Dhruv, Tim and Pieter\n\n\n[1] BIP Pull Request: https://github.com/bitcoin/bips/pull/1378\n\n[2] All historical and current PRs: https://bip324.com/sections/code-review/\n\n[3] https://bip324.com/sections/bip-review/\n\n[4] https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489"
            },
            {
                "author": "Pieter Wuille",
                "date": "2022-10-26T16:39:02",
                "message_text_only": "Hi all,\n\nOn Saturday, October 8th, 2022 at 8:59 AM, Dhruv M <dhruv at bip324.com> wrote:\n\n> We have refreshed the proposal for BIP324, a new bitcoin P2P protocol\n> featuring opportunistic encryption, a mild bandwidth reduction, and the\n> ability\n> to negotiate upgrades before exchanging application messages. We'd like\n> to invite community members to review the BIP[1] and the related Bitcoin\n> Core\n> code[2].\n\nOne open question we have regarding BIP324's design is how to deal with the\ncoordination of assigning the message type IDs.\n\nFor context, the current BIP324 draft introduces a notion of 1-byte message\ntype IDs, which take the place of the 12-byte command strings (in a backward\ncompatible way; it's still possible to send full strings). This offers a\nmild bandwidth reduction (3 bytes per message overall), especially since many\nmessages on the network are fairly small.\n\nHowever, it obviously raises the question of how the mapping table between the\n1-byte IDs and the commands they represent should be maintained:\n\n1. The most straightforward solution is using the BIP process as-is: let BIP324\n   introduce a fixed initial table, and future BIPs which introduce new\n   messages can introduce new mapping entries for it. In theory, this is no\n   worse than the current coordination difficulty about command strings, but\n   in practice the risk of collisions due to competing proposals is of course\n   significantly larger with 1-byte IDs vs. 12-byte strings.\n\n2. An alternative approach is not using 1-byte IDs but slightly longer ones;\n   for example 3-byte IDs, each consisting of a 2-byte BIP number and a 1-byte\n   message index introduced by that BIP, at the cost of a smaller bandwidth\n   improvement. This significantly reduces collision risks, but doesn't remove\n   the coordination process concerns entirely (e.g. revisions changing what a\n   BIP introduces need to be taken into account and probably still mean BIPs\n   need to explicitly list which assignments they introduce).\n\n3. Yet another possibility is not having a fixed table at all, and negotiate\n   the mapping dynamically. E.g. either side could send a message at\n   connection time with an explicit table of entries \"when I send byte X, I\n   mean command Y\".\n\n4. Lastly, the whole feature could just be dropped from BIP324 (sticking with\n   command strings), and left for a follow-up (or independent) protocol\n   improvement. Since arguably this is purely an application-layer concern and\n   not a transport-layer one, it could even be added as an optional feature to\n   the (pre-BIP324) protocol today. That would however very likely mean that\n   BIP324 if adopted as-is isn't actually an (albeit small) bandwidth\n   reduction compared to today, and forego a possibility to fix a fairly\n   gratuitous inefficiency in the protocol from day one.\n\nOur idea is to start out with approach (1), with a mapping table effectively\nmanaged by the BIP process directly, but if and when collisions become a\nconcern (maybe due to many parallel proposals, maybe because the number of\nmessages just grows too big), switch to approach (3), possibly even\ndifferentially (the sent mappings are just additions/overwrites of the\nBIP-defined table mappings, rather than a full mapping).\n\nThat said, we're not all that convinced this is the best approach, and feel\nthis more a community/process question than a technical one, so it would be\ngood to see more opinions on the topic.\n\nCheers,\n\n-- \nDhruv, Pieter, Tim"
            },
            {
                "author": "Vasil Dimov",
                "date": "2022-10-27T07:28:38",
                "message_text_only": "On Wed, Oct 26, 2022 at 16:39:02 +0000, Pieter Wuille via bitcoin-dev wrote:\n[...]\n> Our idea is to start out with approach (1)\n[...]\n> That said, we're not all that convinced this is the best approach, and feel\n> this more a community/process question than a technical one, so it would be\n> good to see more opinions on the topic.\n[...]\n\nIt all makes perfect sense to me.\n\n-- \nVasil Dimov\ngro.DSBeerF at dv\n%\nIf 10 years from now, when you are doing something quick\nand dirty, you suddenly visualize that I am looking over your\nshoulders and say to yourself, \"Dijkstra would not have liked this\",\nwell that would be enough immortality for me.\n                -- Edsger W. Dijkstra\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 1528 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/0e241562/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Refreshed BIP324",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Pieter Wuille",
                "Vasil Dimov",
                "Dhruv M"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5460
        }
    },
    {
        "title": "[bitcoin-dev] What has the Taproot Annex ever done for us ?",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2022-10-10T06:11:47",
                "message_text_only": "Hi,\n\nRecent advances in the development of Eltoo Lightning channels have\nenvisioned the usage of the Taproot annex as a transaction endpoint where\nto store specific protocol payload. [0] Further, during the past years,\nsome use-cases such as SIGHASH_GROUP/SIGHASH_BUNDLE have been proposed that\nwould require an extension of transaction fields. [1]. While there is\nalready the nSequence field serving as an endpoint for enforcement of new\nconsensus\nsemantics, the 32 bits of space doesn't allow multiple semantics to be\nenforced on a transaction in a composable way. [2]\n\nThe Taproot softfork paved the way by introducing the annex, a tagged\nelement part of any SegWit v1 spends: \"a reserved space for future\nextensions\".\n\nThis proposal introduces a Type-Length-Value format for the annex field,\nmotivated by its backward-compatibility and parsing straightforwardness.\n\nThere are a WIP implementation and a BIP available:\nhttps://github.com/bitcoin-inquisition/bitcoin/pull/9\nhttps://github.com/bitcoin/bips/pull/1381\n\nFor now, the proposal is minimal, seeking feedback in the TLV format is an\ninteresting direction. More advanced design questions are also open, like\nwhat policy/consensus rules should be envisioned to prevent DoS of any kind\nand how to make the annex field accessible to Script programmers (e.g\nPUSH_ANNEX_RECORD).\n\nFew use-cases could be served by the annex.\n\nPer-input lock-time: as of today absolute timelocks are enforced at the\ntransaction level preventing aggregation of timelocked inputs by a\nnon-coordinating set of signers.\n\nCommitment to historical block hash: signing the block hash could prevent a\ntransaction to be replayed or fee snipped in case of persistent forks.\n\nGroup of inputs/outputs: a group of input-outputs could be bundled and\nsigned together to enable non-interactive fee-bumping batching of off-chain\nprotocols.\n\nVectors of scriptPubkeys/amounts: within an off-chain protocol, a set of\nsigners can commit a priori to individual withdrawal ability, of which the\naggregation is enforced by the Script interpreter. [3]\n\nThe described use-cases are more whiteboard ideas than anything. It would\nbe interesting to dig in the archives of the ML and other Bitcoin research\nvenues, if there are forgotten requests of transaction fields extensions.\n>From my perspective, I would say there are years of R&D work, before the\nannex can be considered ready for activation.\n\nDetailing the annex format now could harmonize its usage by application\nonly leveraging policy-only enforcement of the field, without having\nulterior consensus validation nullifying or interfering with the use.\n\nCheers,\nAntoine\n\n[0]\nhttps://github.com/instagibbs/bolts/blob/eltoo_draft/XX-eltoo-transactions.md\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html\n[2] https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\n[3]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019926.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221010/10ea2c36/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "What has the Taproot Annex ever done for us ?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3136
        }
    },
    {
        "title": "[bitcoin-dev] Minor DoS vulnerability in BIP144 lack of tx witness data size limit",
        "thread_messages": [
            {
                "author": "Loki Verloren",
                "date": "2022-10-11T05:42:40",
                "message_text_only": "The recent 998 of 999 multisig segwit transaction highlights a problem with BIP144. As the solution applied for btcd shows, effectively a single transaction witness can be the same as the maximum block size.\n11000 bytes may not be so unreasonable but now there is a special case with a block over 33k worth of witness data.\n\nA concrete limit should be set on the maximum size of a transaction witness, and this should be discussed in a more general sense about total transaction sizes.\n\nIn the absence of a specification, it becomes impossible to properly implement and the status quo devolves to the actual implementation in the bitcoin core repository code.\n\nI think the weight calculation should escalate exponentially to discourage putting transactions like this on the chain. The price was equivalent to about $5 to do this.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/05dcf239/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: publickey - loki at cybriq.systems - 0x7BC3C653.asc\nType: application/pgp-keys\nSize: 653 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/05dcf239/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 249 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/05dcf239/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-11T13:06:37",
                "message_text_only": "There are a number of issues with adding arbitrary size restrictions to\nconsensus(I personally think it's additional complexity for negative gain),\nbut most of all this may resolve in burned coins.\n\nOn Tue, Oct 11, 2022 at 6:22 AM Loki Verloren via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> The recent 998 of 999 multisig segwit transaction highlights a problem\n> with BIP144. As the solution applied for btcd shows, effectively a single\n> transaction witness can be the same as the maximum block size.\n>\n> 11000 bytes may not be so unreasonable but now there is a special case\n> with a block over 33k worth of witness data.\n>\n> A concrete limit should be set on the maximum size of a transaction\n> witness, and this should be discussed in a more general sense about total\n> transaction sizes.\n>\n> In the absence of a specification, it becomes impossible to properly\n> implement and the status quo devolves to the actual implementation in the\n> bitcoin core repository code.\n>\n> I think the weight calculation should escalate exponentially to discourage\n> putting transactions like this on the chain. The price was equivalent to\n> about $5 to do this.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/7e9f32ea/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Minor DoS vulnerability in BIP144 lack of tx witness data size limit",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Loki Verloren",
                "Greg Sanders"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3152
        }
    },
    {
        "title": "[bitcoin-dev] Silent Payment v4 (coinjoin support added)",
        "thread_messages": [
            {
                "author": "woltx",
                "date": "2022-10-11T07:02:47",
                "message_text_only": "Silent Payment v4 (coinjoin support added)\n\nChanges:\n\n. Silent payments now use all inputs to create transactions. Previously, they only used the first input. This change increases privacy and makes silent payments compatible with coinjoin.\n\n. `getspaddress` RPC renamed to `getsilentaddress` for clarity\n\n. Added support for silent payment in PSBT via `walletcreatefundedpsbt` RPC.\n\n. Added a new index scheme (which stores the sum of input public keys for each transaction). The previous index `bitcoin/signet/indexes/silentpaymentindex` should be removed as it is no longer compatible with this new version.\n\nFor reviewers:\n\nNow, silent payments use the scheme `hash(i1*X + i2*X + i3*X + ...)*G + X == hash(x*(I1+I2+I3+...))*G + X`, as described here: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n\nAs inputs can be Taproot, this introduced a new issue as `bitcoin-core/secp256k1` does not support x-only public key sum (perhaps due to missing prefix byte).\n\nI opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y. This is the solution being used by the current silent payment implementation.\nTutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/0d3b9f46/attachment.html>"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-12T09:04:35",
                "message_text_only": "Hi\u00a0woltx,\n\nThanks for working on silent payments improving it in each version.\n\n1) All inputs being used sounds good although I do not understand how it would benefit coinjoin.\n2) New RPC command name is better.\n\n> I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y. \n\nNot sure about the concerns expressed by Andrew Poelstra in the pull request related to rogue-key attacks.\n\n> Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875\n> \"warnings\": \"This address is not a new identity. It is a re-use of an existing identity with a different label.\"\n\nI could not understand the warning in the output for `getsilentaddress` RPC when used with a label.\n\n/dev/fd0\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Tuesday, October 11th, 2022 at 12:32 PM, woltx via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n\n> Silent Payment v4 (coinjoin support added)\n> Changes:\n> \n> . Silent payments now use all inputs to create transactions. Previously, they only used the first input. This change increases privacy and makes silent payments compatible with coinjoin.\n> \n> . `getspaddress` RPC renamed to `getsilentaddress` for clarity\n> \n> . Added support for silent payment in PSBT via `walletcreatefundedpsbt` RPC.\n> \n> . Added a new index scheme (which stores the sum of input public keys for each transaction). The previous index `bitcoin/signet/indexes/silentpaymentindex` should be removed as it is no longer compatible with this new version.\n> \n> For reviewers:\n> \n> Now, silent payments use the scheme `hash(i1*X + i2*X + i3*X + ...)*G + X == hash(x*(I1+I2+I3+...))*G + X`, as described here: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n> \n> As inputs can be Taproot, this introduced a new issue as `bitcoin-core/secp256k1` does not support x-only public key sum (perhaps due to missing prefix byte).\n> \n> I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y. This is the solution being used by the current silent payment implementation.\n> \n> Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875"
            },
            {
                "author": "woltx",
                "date": "2022-10-23T07:00:07",
                "message_text_only": "Hi /dev/fd0\n\nI haven't accessed ML for a while.\n\n1) All inputs being used sounds good although I do not understand how it would benefit coinjoin.\n\nUsing all inputs, it becomes possible to use SP addresses in coinjoins as long as all participants agree.\nMore information:\nhttps://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n\n2) Not sure about the concerns expressed by Andrew Poelstra in the pull request related to rogue-key attacks.\n\nI think Andrew Poelstra is referring to a multi-party scheme.\nThis is not the case with the Silent Payments scheme, which only relies on transaction data, which is publicly available on the blockchain.\n\n3) I could not understand the warning in the output for `getsilentaddress` RPC when used with a label.\n\nThis warning was suggested by Aur\u00e8le Oul\u00e8s in https://github.com/bitcoin/bitcoin/pull/24897#issuecomment-1276160738 and the reason was a discussion in PR about users thinking that each address would come from a different key and not the same key.\n\n\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Wednesday, October 12th, 2022 at 6:04 AM, alicexbt <alicexbt at protonmail.com> wrote:\n\n\n> Hi woltx,\n> \n> Thanks for working on silent payments improving it in each version.\n> \n> 1) All inputs being used sounds good although I do not understand how it would benefit coinjoin.\n> 2) New RPC command name is better.\n> \n> > I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y.\n> \n> \n> Not sure about the concerns expressed by Andrew Poelstra in the pull request related to rogue-key attacks.\n> \n> > Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875\n> > \"warnings\": \"This address is not a new identity. It is a re-use of an existing identity with a different label.\"\n> \n> \n> I could not understand the warning in the output for `getsilentaddress` RPC when used with a label.\n> \n> /dev/fd0\n> \n> Sent with Proton Mail secure email.\n> \n> \n> ------- Original Message -------\n> On Tuesday, October 11th, 2022 at 12:32 PM, woltx via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> \n> \n> \n> > Silent Payment v4 (coinjoin support added)\n> > Changes:\n> > \n> > . Silent payments now use all inputs to create transactions. Previously, they only used the first input. This change increases privacy and makes silent payments compatible with coinjoin.\n> > \n> > . `getspaddress` RPC renamed to `getsilentaddress` for clarity\n> > \n> > . Added support for silent payment in PSBT via `walletcreatefundedpsbt` RPC.\n> > \n> > . Added a new index scheme (which stores the sum of input public keys for each transaction). The previous index `bitcoin/signet/indexes/silentpaymentindex` should be removed as it is no longer compatible with this new version.\n> > \n> > For reviewers:\n> > \n> > Now, silent payments use the scheme `hash(i1*X + i2*X + i3*X + ...)*G + X == hash(x*(I1+I2+I3+...))*G + X`, as described here: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n> > \n> > As inputs can be Taproot, this introduced a new issue as `bitcoin-core/secp256k1` does not support x-only public key sum (perhaps due to missing prefix byte).\n> > \n> > I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y. This is the solution being used by the current silent payment implementation.\n> > \n> > Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875"
            },
            {
                "author": "alicexbt",
                "date": "2022-10-23T20:54:26",
                "message_text_only": "Hi woltx,\n\nThanks for the response.\n\n> Using all inputs, it becomes possible to use SP addresses in coinjoins as long as all participants agree.\n> More information:\n> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n\nUsing new addresses and SP address would be same in my opinion in coinjoin.\n\n> I think Andrew Poelstra is referring to a multi-party scheme.\n> This is not the case with the Silent Payments scheme, which only relies on transaction data, which is publicly available on the blockchain.\n\nSounds good.\n\n> This warning was suggested by Aur\u00e8le Oul\u00e8s in https://github.com/bitcoin/bitcoin/pull/24897#issuecomment-1276160738 and the reason was a discussion in PR about users thinking that each address would come from a different key and not the same key.\n\nIt makes sense although could be rephrased.\n\n/dev/fd0\n\n\nSent with Proton Mail secure email.\n\n------- Original Message -------\nOn Sunday, October 23rd, 2022 at 12:30 PM, woltx <woltx at protonmail.com> wrote:\n\n\n> Hi /dev/fd0\n> \n> I haven't accessed ML for a while.\n> \n> 1) All inputs being used sounds good although I do not understand how it would benefit coinjoin.\n> \n> Using all inputs, it becomes possible to use SP addresses in coinjoins as long as all participants agree.\n> More information:\n> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n> \n> 2) Not sure about the concerns expressed by Andrew Poelstra in the pull request related to rogue-key attacks.\n> \n> I think Andrew Poelstra is referring to a multi-party scheme.\n> This is not the case with the Silent Payments scheme, which only relies on transaction data, which is publicly available on the blockchain.\n> \n> 3) I could not understand the warning in the output for `getsilentaddress` RPC when used with a label.\n> \n> This warning was suggested by Aur\u00e8le Oul\u00e8s in https://github.com/bitcoin/bitcoin/pull/24897#issuecomment-1276160738 and the reason was a discussion in PR about users thinking that each address would come from a different key and not the same key.\n> \n> \n> \n> \n> Sent with Proton Mail secure email.\n> \n> \n> ------- Original Message -------\n> On Wednesday, October 12th, 2022 at 6:04 AM, alicexbt alicexbt at protonmail.com wrote:\n> \n> \n> \n> > Hi woltx,\n> > \n> > Thanks for working on silent payments improving it in each version.\n> > \n> > 1) All inputs being used sounds good although I do not understand how it would benefit coinjoin.\n> > 2) New RPC command name is better.\n> > \n> > > I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y.\n> > \n> > Not sure about the concerns expressed by Andrew Poelstra in the pull request related to rogue-key attacks.\n> > \n> > > Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875\n> > > \"warnings\": \"This address is not a new identity. It is a re-use of an existing identity with a different label.\"\n> > \n> > I could not understand the warning in the output for `getsilentaddress` RPC when used with a label.\n> > \n> > /dev/fd0\n> > \n> > Sent with Proton Mail secure email.\n> > \n> > ------- Original Message -------\n> > On Tuesday, October 11th, 2022 at 12:32 PM, woltx via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n> > \n> > > Silent Payment v4 (coinjoin support added)\n> > > Changes:\n> > > \n> > > . Silent payments now use all inputs to create transactions. Previously, they only used the first input. This change increases privacy and makes silent payments compatible with coinjoin.\n> > > \n> > > . `getspaddress` RPC renamed to `getsilentaddress` for clarity\n> > > \n> > > . Added support for silent payment in PSBT via `walletcreatefundedpsbt` RPC.\n> > > \n> > > . Added a new index scheme (which stores the sum of input public keys for each transaction). The previous index `bitcoin/signet/indexes/silentpaymentindex` should be removed as it is no longer compatible with this new version.\n> > > \n> > > For reviewers:\n> > > \n> > > Now, silent payments use the scheme `hash(i1*X + i2*X + i3*X + ...)*G + X == hash(x*(I1+I2+I3+...))*G + X`, as described here: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8#variant-using-all-inputs\n> > > \n> > > As inputs can be Taproot, this introduced a new issue as `bitcoin-core/secp256k1` does not support x-only public key sum (perhaps due to missing prefix byte).\n> > > \n> > > I opened a new PR (#1143) to add a function to convert from x-only to compressed public key with even y. This is the solution being used by the current silent payment implementation.\n> > > \n> > > Tutorial updated: https://gist.github.com/w0xlt/c81277ae8677b6c0d3dd073893210875"
            }
        ],
        "thread_summary": {
            "title": "Silent Payment v4 (coinjoin support added)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "woltx",
                "alicexbt"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 11918
        }
    },
    {
        "title": "[bitcoin-dev] Relaxing minimum non-witness transaction size policy restriction",
        "thread_messages": [
            {
                "author": "Greg Sanders",
                "date": "2022-10-11T12:50:07",
                "message_text_only": "Hello fellow Bitcoiners,\n\nAfter looking at some fairly exotic possible transaction types, I ran into\nthe current policy limit requiring transactions to be 85 non-witness\nserialized bytes. This was introduced as a covert fix to policy fix\nfor CVE-2017-12842. Later the real motivation was revealed, but the\n\"reasonable\" constant chosen was not.\n\nI'd like to propose relaxing this to effectively the value BlueMatt\nproposed in the Great Consensus Cleanup: 65 non-witness bytes. This would\nallow a single input, single output transaction with 4 bytes of OP_RETURN\npadding, rather than padding out 21 bytes to get to p2wpkh size.\n\nThe alternative would be to also allow anything below 64 non-witness bytes,\nbut this seems fraught with footguns for a few bytes gain.\n\nThe PR is here with more relevant background and alternatives included in\nthe thread:\nhttps://github.com/bitcoin/bitcoin/pull/26265\n\nPlease let us know if there's a fundamental issue with this approach, or\nany other feedback.\n\nBest,\nGreg\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/709d9a5c/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-11T13:14:54",
                "message_text_only": "Propagation of these kinds of transactions will be hampered until <merge\nversion in core> becomes 10%+ of the network or so, like any other policy\nrelaxation.\n\nOn Tue, Oct 11, 2022 at 9:08 AM KING JAMES HRMH <willtech at live.com.au>\nwrote:\n\n> I am reading between the lines, wouldn't that mean an older client like\n> v0.18 may not be able to receive a transaction from a newer client if it\n> has to validate 85 non-witness serialized bytes? If so we should not\n> concern but retain the backward compatibility especially since this was for\n> a vulnerability? I have not checked to code to see what it does.\n>\n> KING JAMES HRMH\n>\n> Get Outlook for Android <https://aka.ms/AAb9ysg>\n> ------------------------------\n> *From:* bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on\n> behalf of Greg Sanders via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org>\n> *Sent:* Tuesday, October 11, 2022 11:50:07 PM\n> *To:* Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n> *Subject:* [bitcoin-dev] Relaxing minimum non-witness transaction size\n> policy restriction\n>\n> Hello fellow Bitcoiners,\n>\n> After looking at some fairly exotic possible transaction types, I ran into\n> the current policy limit requiring transactions to be 85 non-witness\n> serialized bytes. This was introduced as a covert fix to policy fix\n> for CVE-2017-12842. Later the real motivation was revealed, but the\n> \"reasonable\" constant chosen was not.\n>\n> I'd like to propose relaxing this to effectively the value BlueMatt\n> proposed in the Great Consensus Cleanup: 65 non-witness bytes. This would\n> allow a single input, single output transaction with 4 bytes of OP_RETURN\n> padding, rather than padding out 21 bytes to get to p2wpkh size.\n>\n> The alternative would be to also allow anything below 64 non-witness\n> bytes, but this seems fraught with footguns for a few bytes gain.\n>\n> The PR is here with more relevant background and alternatives included in\n> the thread:\n> https://github.com/bitcoin/bitcoin/pull/26265\n>\n> Please let us know if there's a fundamental issue with this approach, or\n> any other feedback.\n>\n> Best,\n> Greg\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221011/cc28626e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T23:21:01",
                "message_text_only": "On Tue, Oct 11, 2022 at 08:50:07AM -0400, Greg Sanders via bitcoin-dev wrote:\n> Hello fellow Bitcoiners,\n> \n> After looking at some fairly exotic possible transaction types, I ran into\n> the current policy limit requiring transactions to be 85 non-witness\n> serialized bytes. This was introduced as a covert fix to policy fix\n> for CVE-2017-12842. Later the real motivation was revealed, but the\n> \"reasonable\" constant chosen was not.\n> \n> I'd like to propose relaxing this to effectively the value BlueMatt\n> proposed in the Great Consensus Cleanup: 65 non-witness bytes. This would\n> allow a single input, single output transaction with 4 bytes of OP_RETURN\n> padding, rather than padding out 21 bytes to get to p2wpkh size.\n> \n> The alternative would be to also allow anything below 64 non-witness bytes,\n> but this seems fraught with footguns for a few bytes gain.\n\nWhat footguns exactly? Spending a single input to OP_RETURN with no payload is\na valid use to get rid of dust in the UTXO set.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/4925cd7e/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-21T00:07:54",
                "message_text_only": "I don't doubt the use case(it's why I opened the issue!). I didn't want the\nproposal to die in case people found it odd that 61, 62, 63, but not 64\nbytes ended up being broadcast able.\n\nPerhaps this is not an issue, especially since this isn't a consensus\nchange like the Great Consensus Cleanup. Willing to change my proposal and\nPR if people have no strong objections.\n\nGreg\n\nOn Thu, Oct 20, 2022, 7:21 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Tue, Oct 11, 2022 at 08:50:07AM -0400, Greg Sanders via bitcoin-dev\n> wrote:\n> > Hello fellow Bitcoiners,\n> >\n> > After looking at some fairly exotic possible transaction types, I ran\n> into\n> > the current policy limit requiring transactions to be 85 non-witness\n> > serialized bytes. This was introduced as a covert fix to policy fix\n> > for CVE-2017-12842. Later the real motivation was revealed, but the\n> > \"reasonable\" constant chosen was not.\n> >\n> > I'd like to propose relaxing this to effectively the value BlueMatt\n> > proposed in the Great Consensus Cleanup: 65 non-witness bytes. This would\n> > allow a single input, single output transaction with 4 bytes of OP_RETURN\n> > padding, rather than padding out 21 bytes to get to p2wpkh size.\n> >\n> > The alternative would be to also allow anything below 64 non-witness\n> bytes,\n> > but this seems fraught with footguns for a few bytes gain.\n>\n> What footguns exactly? Spending a single input to OP_RETURN with no\n> payload is\n> a valid use to get rid of dust in the UTXO set.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/681a1206/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-21T00:13:15",
                "message_text_only": "On Thu, Oct 20, 2022 at 08:07:54PM -0400, Greg Sanders wrote:\n> I don't doubt the use case(it's why I opened the issue!). I didn't want the\n> proposal to die in case people found it odd that 61, 62, 63, but not 64\n> bytes ended up being broadcast able.\n> \n> Perhaps this is not an issue, especially since this isn't a consensus\n> change like the Great Consensus Cleanup. Willing to change my proposal and\n> PR if people have no strong objections.\n\nI think it's fine if we only restrict 64 bytes. We have a specific reason to do\nthat and it's ok if we just tell people that. Only fairly-technical use-cases\nare affected anyway.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/0a4893a0/attachment.sig>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-26T19:09:38",
                "message_text_only": "As there has been some feedback to the same effect, I've opened a competing\nPR for separate evaluation here:\nhttps://github.com/bitcoin/bitcoin/pull/26398\n\nPlease give feedback if anyone has any.\n\nOn Thu, Oct 20, 2022 at 8:13 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Thu, Oct 20, 2022 at 08:07:54PM -0400, Greg Sanders wrote:\n> > I don't doubt the use case(it's why I opened the issue!). I didn't want\n> the\n> > proposal to die in case people found it odd that 61, 62, 63, but not 64\n> > bytes ended up being broadcast able.\n> >\n> > Perhaps this is not an issue, especially since this isn't a consensus\n> > change like the Great Consensus Cleanup. Willing to change my proposal\n> and\n> > PR if people have no strong objections.\n>\n> I think it's fine if we only restrict 64 bytes. We have a specific reason\n> to do\n> that and it's ok if we just tell people that. Only fairly-technical\n> use-cases\n> are affected anyway.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221026/a50dab98/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Relaxing minimum non-witness transaction size policy restriction",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "Greg Sanders"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 8676
        }
    },
    {
        "title": "[bitcoin-dev] Validity Rollups on Bitcoin",
        "thread_messages": [
            {
                "author": "John Light",
                "date": "2022-10-11T15:40:52",
                "message_text_only": "Hi all,\n\nToday I am publishing \"Validity Rollups on Bitcoin\", a report I produced as part of the Human Rights Foundation's ZK-Rollup Research Fellowship.\n\nHere's the preface:\n\n> Ever since Satoshi Nakamoto first publicly announced bitcoin, its supporters, critics, and skeptics alike have questioned how the protocol would scale as usage increases over time. This question is more important than ever today, as blocks are increasingly full or close to full of transactions. So-called \"Layer 2\" (L2) protocols such as the Lightning Network have been deployed to take some transaction volume \"offchain\" but even Lightning needs to use\u00a0_some_\u00a0bitcoin block space. It's clear that as bitcoin is adopted by more and more of the world's population (human and machine alike!) more block space will be needed. Another thread of inquiry concerns whether bitcoin's limited scripting capabilities help or hinder its value as electronic cash. Researchers and inventors have shown that the electronic cash transactions first made possible by bitcoin could be given new form by improving transaction privacy, supporting new types of smart contracts, and even creating entirely new blockchain-based assets.\n> \n> One of the results of the decade-plus research into scaling and expanding the capabilities of blockchains such as bitcoin is the invention of the validity rollup. Given the observed benefits that validity rollups have for the blockchains that have already implemented them, attention now turns to the question of whether they would be beneficial for bitcoin and existing bitcoin L2 protocols such as Lightning, too. We explore this question by examining validity rollups from several angles, including their history, how they work on a technical level, how they could be built on bitcoin, and what the benefits, costs, and risks of building them on bitcoin might be. We conclude that validity rollups have the potential to improve the scalability, privacy, and programmability of bitcoin without sacrificing bitcoin's core values or functionality as a peer-to-peer electronic cash system. Given the \"trustless\" nature of validity rollups as cryptographically-secured extensions of their parent chain, and given bitcoin's status as the most secure settlement layer, one could even say these protocols are a\u00a0_perfect match_\u00a0for one another.\n\nYou can find the full report here:\n\nhttps://bitcoinrollups.org\n\nHappy to receive any comments and answer any questions the bitcoin dev community may have about the report!\n\nBest regards,\nJohn Light"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-12T13:28:22",
                "message_text_only": "Thanks for the writeup John,\n\nIs there a one page cheat sheet of \"asks\" for transaction\nintrospection/OP_ZKP(?) and their uses both separately and together for\ndifferent rollup architectures?\n\nOn Tue, Oct 11, 2022 at 11:52 AM John Light via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi all,\n>\n> Today I am publishing \"Validity Rollups on Bitcoin\", a report I produced\n> as part of the Human Rights Foundation's ZK-Rollup Research Fellowship.\n>\n> Here's the preface:\n>\n> > Ever since Satoshi Nakamoto first publicly announced bitcoin, its\n> supporters, critics, and skeptics alike have questioned how the protocol\n> would scale as usage increases over time. This question is more important\n> than ever today, as blocks are increasingly full or close to full of\n> transactions. So-called \"Layer 2\" (L2) protocols such as the Lightning\n> Network have been deployed to take some transaction volume \"offchain\" but\n> even Lightning needs to use _some_ bitcoin block space. It's clear that as\n> bitcoin is adopted by more and more of the world's population (human and\n> machine alike!) more block space will be needed. Another thread of inquiry\n> concerns whether bitcoin's limited scripting capabilities help or hinder\n> its value as electronic cash. Researchers and inventors have shown that the\n> electronic cash transactions first made possible by bitcoin could be given\n> new form by improving transaction privacy, supporting new types of smart\n> contracts, and even creating entirely new blockchain-based assets.\n> >\n> > One of the results of the decade-plus research into scaling and\n> expanding the capabilities of blockchains such as bitcoin is the invention\n> of the validity rollup. Given the observed benefits that validity rollups\n> have for the blockchains that have already implemented them, attention now\n> turns to the question of whether they would be beneficial for bitcoin and\n> existing bitcoin L2 protocols such as Lightning, too. We explore this\n> question by examining validity rollups from several angles, including their\n> history, how they work on a technical level, how they could be built on\n> bitcoin, and what the benefits, costs, and risks of building them on\n> bitcoin might be. We conclude that validity rollups have the potential to\n> improve the scalability, privacy, and programmability of bitcoin without\n> sacrificing bitcoin's core values or functionality as a peer-to-peer\n> electronic cash system. Given the \"trustless\" nature of validity rollups as\n> cryptographically-secured extensions of their parent chain, and given\n> bitcoin's status as the most secure settlement layer, one could even say\n> these protocols are a _perfect match_ for one another.\n>\n> You can find the full report here:\n>\n> https://bitcoinrollups.org\n>\n> Happy to receive any comments and answer any questions the bitcoin dev\n> community may have about the report!\n>\n> Best regards,\n> John Light\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221012/4a38abb5/attachment.html>"
            },
            {
                "author": "John Light",
                "date": "2022-10-12T15:40:10",
                "message_text_only": "On Wed, Oct 12, 2022, at 9:28 AM, Greg Sanders wrote:\n> Is there a one page cheat sheet of \"asks\" for transaction \n> introspection/OP_ZKP(?) and their uses both separately and together for \n> different rollup architectures?\n\nWe do not have this yet. Trey Del Bonis wrote a more detailed technical post about how those components would be used in a validity rollup, which was cited in my report and can be found here:\nhttps://tr3y.io/articles/crypto/bitcoin-zk-rollups.html\n\nBut it'll take more research and design work to suss out those details you asked for and put them into a nice cheatsheet. I like this idea though!"
            }
        ],
        "thread_summary": {
            "title": "Validity Rollups on Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Greg Sanders",
                "John Light"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6451
        }
    },
    {
        "title": "[bitcoin-dev] Wallet Fingerprinting with nLocktime and nVersion",
        "thread_messages": [
            {
                "author": "alicexbt",
                "date": "2022-10-12T08:54:42",
                "message_text_only": "Hi Bitcoin Developers,\n\nI did some research about nLocktime and nVersion used by some open source Bitcoin wallets. I have written a [blog post][0] co-authored with 'nothingmuch' and this is the first post for the privacy focused blog 'consent':\n\nMost wallets use nVersion 2. nLocktime for Bitcoin Core, Knots, Electrum, Sparrow and Specter is nearest block height. However, nLocktime for Bitcoin Core/Knots is zero by default if the transaction is created manually using RPC commands like createpsbt\u200b or createrawtransaction\u200b. Peter Todd had implemented nLocktime based on anti-fee sniping in [#2340][1] and [#24128][2] implements BIP 326 sequence based anti-fee-snipe for taproot inputs.\n'0xb10c' has written about wallet [fingerprinting with fee rate][3]. However, nLocktime and nVersion are also important. There may be other factors that might help if a fingerprint matches more than one wallet. Andrew Chow has build a [tool][4] to check if a transaction was created using Bitcoin Core or Electrum.\n\n### Why is wallet fingerprinting important?\n\nConsider the following scenario: Alice is spying on Bob and Carol. She suspects one of them is participating in an activity based on a transaction, but she cannot confirm it. She recognizes that one of the wallets that claims to improve privacy was used for these transactions and examines the nVersion and nLocktime. This makes it simpler to identify Bob, who used Wasabi wallet for the transaction with version 1 and nLocktime 0.\n\n### How to fix it?\n\nIf more wallets have the same nVersion and nLocktime, it will be difficult to identify the wallets used for a transaction. nLocktime could be any nearest block height however version needs to be 2 as most of the wallets use it and it is used for transactions that follow new consensus rules.\n\nPlease let me know if something incorrect is mentioned or anything important missing about wallet fingerprinting with nLocktime and nVersion.\n\n### Acknowledgements\n\n- achow101\n- 0xb10c\n- nothingmuch- RedGrittyBrick\n\n[0]: https://consentonchain.github.io/blog/posts/fingerprinting/\n[1]: https://github.com/bitcoin/bitcoin/pull/2340\n[2]: https://github.com/bitcoin/bitcoin/pull/24128\n[3]: https://b10c.me/observations/03-blockchaincom-recommendations/\n[4]: https://github.com/achow101/wallet-fingerprinting\n\n/dev/fd0\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221012/8205a831/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Wallet Fingerprinting with nLocktime and nVersion",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "alicexbt"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2557
        }
    },
    {
        "title": "[bitcoin-dev] Does Bitcoin require or have an honest majority or a rational one? (re rbf)",
        "thread_messages": [
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-16T17:35:54",
                "message_text_only": "The Bitcoin white paper says:\n\nThe proof-of-work also solves the problem of determining representation in\nmajority decision\nmaking. If the majority were based on one-IP-address-one-vote, it could be\nsubverted by anyone\nable to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote.\nThe majority\ndecision is represented by the longest chain, which has the greatest\nproof-of-work effort invested\nin it. If a majority of CPU power is controlled by honest nodes, the honest\nchain will grow the\nfastest and outpace any competing chains. To modify a past block, an\nattacker would have to\nredo the proof-of-work of the block and all blocks after it and then catch\nup with and surpass the\nwork of the honest nodes. We will show later that the probability of a\nslower attacker catching up\ndiminishes exponentially as subsequent blocks are added.\n\n\nThis, Satoshi (who doesn't really matter anyways I guess?) claimed that for\nBitcoin to function properly you need a majority honest nodes.\n\nThere are multiple behaviors one can describe as honest, and economically\nrational or optimizing is not necessarily rational.\n\nFor example, if I run a shop that takes rain checks, but I sell an item to\na higher bidder who didn't have a hold on the item, that is not honest, but\nit may be selfish profit maximizing.\n\nSatoshi said an honest majority is required for the chain to be extended.\nHonest is not really defined though. Honesty, in my definition, is that you\nfollow a pre specified rule, rational or not.\n\nIt seems a lot of the RBF controversy is that Protocol developers have\naspired to make the honest behavior also be the rational behavior. This is\nmaybe a good idea because, in theory, if the honest behavior is rational\nthen we can make a weaker assumption of selfishness maximizing a parameter.\n\nHowever, Satoshi did not particularly bound what aspects of honesty are\nimportant for the network, because there isn't a spec defining exactly what\nis honest or not. And also as soon as people are honest, you can rely on\nthat assumption for good effect.\n\nAnd sometimes, defining an honest behavior can be creating a higher utility\nsystem because most people are \"law abiding citizens\" who might not be\nshort term rational. For example, one might expect that miners would be\ninterested in making sure lightning closes are \"accurate\" because\nincreasing the utility of lightning is good for Bitcoin, even if it is\nirrational.\n\nIt seems that the NoRBF crowd want to rely on an honest majority assumption\nwhere the honest behavior is not doing replacement if not requested. This\nis really not much different than trying to close lightning channels \"the\nright way\".\n\nHowever, where it may be different, is that even in the presence of honest\nmajority, the safety of 0conf isn't assured given the potential of race\nconditions in the mempool. Therefore it's not clear to me that 0conf\nworking well is something you can drive from the Honest Majority Assumption\n(where honest includes first seen).\n\n\nOverall, it might be nice to more tightly document what bitcoins\nassumptions are in practice and what those assumptions do in terms of\nproperties of Bitcoin, as well as pathways to weakening the assumptions\nwithout compromising the behaviors users expect the network to have.  An\n\"extended white paper\" if you will.\n\n\n It's somewhat clear to me that we shouldn't weaken assumptions that only\nseem local to one subsystem of Bitcoin if they end up destabilizing another\nsystem. In particular, things that decrease \"transaction utility\" for end\nusers decrease the demand for transactions which hurts the fee market's\nlonger term viability, even if we feel good about making an honest policy\nassumption into a self interested policy assumption.\n\nA last reflection is that Bitcoin is specified with an honest majority\nassumption, but also has a rational dishonest minority assumption over both\nendogenous (rewards) and exogenous (electricity) costs. Satoshi did not\nsuggest, at least as I read it, that Bitcoin works with an rational\nmajority assumption. (If anyone thinks these three are similar properties\nyou can make some trivial counterexamples)\n\n\nCheers,\n\nJeremy\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221016/6f92ed4a/attachment.html>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-16T19:03:51",
                "message_text_only": "> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n\nIt's interesting that Nash Equilibrium isn't mentioned here.  Since each \nminer has the option to either contribute to the longest chain or not, \neven if the miners know what strategy the other miners will use, they \nstill wouldn't change their decision to contribute to the majority.\n\n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that is\n> not honest, but it may be selfish profit maximizing.\n\nIt would be honest if the store policy said ahead of time they are \nallowed to sell rain checks for more in such an occurrence.  Although \nthis is a good example of the difference between honest and rational.  I \nthink this means it's not a Nash Equilibrium if we needed to rely on the \nstore owner to be honest.\n\n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or not.\n\nMy take is that \"rational\" is probably a better word than honest.  In \nterms of a Nash Equilibrium, each participant is simply trying to \nmaximize their outcome and honesty doesn't matter (only that \nparticipants are rational).\n\n> It seems a lot of the RBF controversy is that Protocol developers have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n\nI'm curious, can RBF can be described by a Nash Equilibrium?  If yes, \nthen it also shouldn't matter if participants are honest?\n\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n\nWhite paper 1.1 :D\n\n> A last reflection is that Bitcoin is specified with an honest majority\n> assumption, but also has a rational dishonest minority assumption over\n> both endogenous (rewards) and exogenous (electricity) costs. Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n\nMy take is the opposite unless I'm missing something.  Participants are \nalways incentivized to choose the rational solution (Not to waste \nelectricity on a minority chain).\n\nCheers,\n-Yancy\n\nOn 2022-10-16 19:35, Jeremy Rubin via bitcoin-dev wrote:\n\n> The Bitcoin white paper says:\n> \n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n> \n> This, Satoshi (who doesn't really matter anyways I guess?) claimed\n> that for Bitcoin to function properly you need a majority honest\n> nodes.\n> \n> There are multiple behaviors one can describe as honest, and\n> economically rational or optimizing is not necessarily rational.\n> \n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that is\n> not honest, but it may be selfish profit maximizing.\n> \n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or not.\n> \n> It seems a lot of the RBF controversy is that Protocol developers have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n> \n> However, Satoshi did not particularly bound what aspects of honesty\n> are important for the network, because there isn't a spec defining\n> exactly what is honest or not. And also as soon as people are honest,\n> you can rely on that assumption for good effect.\n> \n> And sometimes, defining an honest behavior can be creating a higher\n> utility system because most people are \"law abiding citizens\" who\n> might not be short term rational. For example, one might expect that\n> miners would be interested in making sure lightning closes are\n> \"accurate\" because increasing the utility of lightning is good for\n> Bitcoin, even if it is irrational.\n> \n> It seems that the NoRBF crowd want to rely on an honest majority\n> assumption where the honest behavior is not doing replacement if not\n> requested. This is really not much different than trying to close\n> lightning channels \"the right way\".\n> \n> However, where it may be different, is that even in the presence of\n> honest majority, the safety of 0conf isn't assured given the potential\n> of race conditions in the mempool. Therefore it's not clear to me that\n> 0conf working well is something you can drive from the Honest Majority\n> Assumption (where honest includes first seen).\n> \n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n> \n> It's somewhat clear to me that we shouldn't weaken assumptions that\n> only seem local to one subsystem of Bitcoin if they end up\n> destabilizing another system. In particular, things that decrease\n> \"transaction utility\" for end users decrease the demand for\n> transactions which hurts the fee market's longer term viability, even\n> if we feel good about making an honest policy assumption into a self\n> interested policy assumption.\n> \n> A last reflection is that Bitcoin is specified with an honest majority\n> assumption, but also has a rational dishonest minority assumption over\n> both endogenous (rewards) and exogenous (electricity) costs. Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n> \n> Cheers,\n> \n> Jeremy\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221016/ade1e6a6/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-17T19:10:18",
                "message_text_only": "Building on the most work chain is perhaps not rational in many normal\ncircumstances that can come up today under the stated reference strategy:\n\n1) Take highest paying transactions that fit\n2) Mine on tips\n\nE.g., suppose:\n\nBlock N: Fees = 10, reward = 1\n\nMempool: Fees = 2\n\nMining block N+1 with the mempool leads to reward 2+1 = 3, reorging leads\nto reward of up to 10 + 1 + c, (c < 2, where c is the extra transactions\nthat fit). Assume instead your reward is 8, leaving 3+c on the table.\n\nIf you assume all other miners are tip miners, and there are two\nconflicting tips, they should pick the one with the more profit for them,\nwhich is the new one you made as a non-tip miner since you \"shared\" some\nfee.\n\nYou aren't particularly more likely to remine block N or N+1, before\nsomeone builds on it, as opposed to deeper reorgs (which require larger\nincentive).\n\n\nHowever, as many have pointed out, perhaps not following the simple \"honest\ntip mining\" strategy is bad for bitcoin, so maybe we should expect it not\nto happen often? Or other strategies to emerge around selecting\ntransactions so that the next M blocks have a similar fee profile, as\nopposed to picking greedily for the next block.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\n\nOn Sun, Oct 16, 2022 at 3:03 PM <email at yancy.lol> wrote:\n\n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n>\n>\n> It's interesting that Nash Equilibrium isn't mentioned here.  Since each\n> miner has the option to either contribute to the longest chain or not, even\n> if the miners know what strategy the other miners will use, they still\n> wouldn't change their decision to contribute to the majority.\n>\n>\n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that is\n> not honest, but it may be selfish profit maximizing.\n>\n>\n> It would be honest if the store policy said ahead of time they are allowed\n> to sell rain checks for more in such an occurrence.  Although this is a\n> good example of the difference between honest and rational.  I think this\n> means it's not a Nash Equilibrium if we needed to rely on the store owner\n> to be honest.\n>\n>\n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or not.\n>\n>\n> My take is that \"rational\" is probably a better word than honest.  In\n> terms of a Nash Equilibrium, each participant is simply trying to maximize\n> their outcome and honesty doesn't matter (only that participants are\n> rational).\n>\n>\n> It seems a lot of the RBF controversy is that Protocol developers have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n>\n>\n> I'm curious, can RBF can be described by a Nash Equilibrium?  If yes, then\n> it also shouldn't matter if participants are honest?\n>\n>\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n>\n>\n> White paper 1.1 :D\n>\n>\n> A last reflection is that Bitcoin is specified with an honest majority\n> assumption, but also has a rational dishonest minority assumption over\n> both endogenous (rewards) and exogenous (electricity) costs. Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n>\n>\n> My take is the opposite unless I'm missing something.  Participants are\n> always incentivized to choose the rational solution (Not to waste\n> electricity on a minority chain).\n>\n> Cheers,\n> -Yancy\n>\n> On 2022-10-16 19:35, Jeremy Rubin via bitcoin-dev wrote:\n>\n> The Bitcoin white paper says:\n>\n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n>\n> This, Satoshi (who doesn't really matter anyways I guess?) claimed\n> that for Bitcoin to function properly you need a majority honest\n> nodes.\n>\n> There are multiple behaviors one can describe as honest, and\n> economically rational or optimizing is not necessarily rational.\n>\n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that is\n> not honest, but it may be selfish profit maximizing.\n>\n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or not.\n>\n> It seems a lot of the RBF controversy is that Protocol developers have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n>\n> However, Satoshi did not particularly bound what aspects of honesty\n> are important for the network, because there isn't a spec defining\n> exactly what is honest or not. And also as soon as people are honest,\n> you can rely on that assumption for good effect.\n>\n> And sometimes, defining an honest behavior can be creating a higher\n> utility system because most people are \"law abiding citizens\" who\n> might not be short term rational. For example, one might expect that\n> miners would be interested in making sure lightning closes are\n> \"accurate\" because increasing the utility of lightning is good for\n> Bitcoin, even if it is irrational.\n>\n> It seems that the NoRBF crowd want to rely on an honest majority\n> assumption where the honest behavior is not doing replacement if not\n> requested. This is really not much different than trying to close\n> lightning channels \"the right way\".\n>\n> However, where it may be different, is that even in the presence of\n> honest majority, the safety of 0conf isn't assured given the potential\n> of race conditions in the mempool. Therefore it's not clear to me that\n> 0conf working well is something you can drive from the Honest Majority\n> Assumption (where honest includes first seen).\n>\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n>\n>  It's somewhat clear to me that we shouldn't weaken assumptions that\n> only seem local to one subsystem of Bitcoin if they end up\n> destabilizing another system. In particular, things that decrease\n> \"transaction utility\" for end users decrease the demand for\n> transactions which hurts the fee market's longer term viability, even\n> if we feel good about making an honest policy assumption into a self\n> interested policy assumption.\n>\n> A last reflection is that Bitcoin is specified with an honest majority\n> assumption, but also has a rational dishonest minority assumption over\n> both endogenous (rewards) and exogenous (electricity) costs. Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n>\n> Cheers,\n>\n> Jeremy\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/16a24252/attachment-0001.html>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-17T22:31:39",
                "message_text_only": "Hi Jeremy,\n\nThanks for the reply. I do find the semantics of mempool and block org \ninteresting (although there's a lot on the topic I don't know).\n\n> E.g., suppose:\n> \n> Block N: Fees = 10, reward = 1\n> \n> Mempool: Fees = 2\n> \n> Mining block N+1 with the mempool leads to reward 2+1 = 3, reorging\n> leads to reward of up to 10 + 1 + c, (c < 2, where c is the extra\n> transactions that fit).\n\nIf I'm reading this correctly, Block N was already mined, but the miner \nwho mined block N+1 repacks the transactions from block N because they \nhave more to gain.  Wouldn't such a situation be resolved in the same \nway as two miners who find a block at a similar time? E.g the network \nwill choose depending on when block N+2 is created.\n\n> Assume instead your reward is 8, leaving 3+c on the table.\n\nMining block N+1 with the mempool leads to reward 2+8 = 10, reorging \nleads to 10 + 8 + c?  Wouldn't that leave 8+c?\n\n> If you assume all other miners are tip miners, and there are two\n> conflicting tips, they should pick the one with the more profit for\n> them, which is the new one you made as a non-tip miner since you\n> \"shared\" some fee.\n\nI'm curious how the \"fee sharing\" would be organized.  To see if I \nunderstand, You're asking what would happen if one of the two miners \nincentives (bribes in this case) the next miner (block N+1) to choose \none of the competing tip miners?\n\n> You aren't particularly more likely to remine block N or N+1, before\n> someone builds on it, as opposed to deeper reorgs (which require\n> larger incentive).\n\nAgree.\n\n> However, as many have pointed out, perhaps not following the simple\n> \"honest tip mining\" strategy is bad for bitcoin, so maybe we should\n> expect it not to happen often?\n\nThe idea that people won't do something because it's \"bad for Bitcoin\" \ndoesn't fit an adversarial model.  Even in the above examples (which I \nthink wouldn't expect to happen often), I would argue the network still \nconforms to a Nash Equilibrium without requiring trust.  Although It's \nmostly speculation without some empirical data.\n\nCheers,\n-Yancy\n\nOn 2022-10-17 21:10, Jeremy Rubin wrote:\n\n> Building on the most work chain is perhaps not rational in many normal\n> circumstances that can come up today under the stated reference\n> strategy:\n> \n> 1) Take highest paying transactions that fit\n> 2) Mine on tips\n> \n> E.g., suppose:\n> \n> Block N: Fees = 10, reward = 1\n> \n> Mempool: Fees = 2\n> \n> Mining block N+1 with the mempool leads to reward 2+1 = 3, reorging\n> leads to reward of up to 10 + 1 + c, (c < 2, where c is the extra\n> transactions that fit). Assume instead your reward is 8, leaving 3+c\n> on the table.\n> \n> If you assume all other miners are tip miners, and there are two\n> conflicting tips, they should pick the one with the more profit for\n> them, which is the new one you made as a non-tip miner since you\n> \"shared\" some fee.\n> \n> You aren't particularly more likely to remine block N or N+1, before\n> someone builds on it, as opposed to deeper reorgs (which require\n> larger incentive).\n> \n> However, as many have pointed out, perhaps not following the simple\n> \"honest tip mining\" strategy is bad for bitcoin, so maybe we should\n> expect it not to happen often? Or other strategies to emerge around\n> selecting transactions so that the next M blocks have a similar fee\n> profile, as opposed to picking greedily for the next block.\n> \n> --\n> @JeremyRubin [1 [1]]\n> \n> On Sun, Oct 16, 2022 at 3:03 PM <email at yancy.lol> wrote:\n> \n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the\n> greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes,\n> the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block,\n> an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and\n> then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability\n> of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n> It's interesting that Nash Equilibrium isn't mentioned here.  Since\n> each miner has the option to either contribute to the longest chain\n> or not, even if the miners know what strategy the other miners will\n> use, they still wouldn't change their decision to contribute to the\n> majority.\n> \n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that\n> is\n> not honest, but it may be selfish profit maximizing.\n> It would be honest if the store policy said ahead of time they are\n> allowed to sell rain checks for more in such an occurrence.\n> Although this is a good example of the difference between honest and\n> rational.  I think this means it's not a Nash Equilibrium if we\n> needed to rely on the store owner to be honest.\n> \n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or\n> not.\n> My take is that \"rational\" is probably a better word than honest.\n> In terms of a Nash Equilibrium, each participant is simply trying to\n> maximize their outcome and honesty doesn't matter (only that\n> participants are rational).\n> \n> It seems a lot of the RBF controversy is that Protocol developers\n> have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest\n> behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n> I'm curious, can RBF can be described by a Nash Equilibrium?  If\n> yes, then it also shouldn't matter if participants are honest?\n> \n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms\n> of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n> White paper 1.1 :D\n> \n> A last reflection is that Bitcoin is specified with an honest\n> majority\n> assumption, but also has a rational dishonest minority assumption\n> over\n> both endogenous (rewards) and exogenous (electricity) costs.\n> Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n> My take is the opposite unless I'm missing something.  Participants\n> are always incentivized to choose the rational solution (Not to\n> waste electricity on a minority chain).\n> \n> Cheers,\n> -Yancy\n> \n> On 2022-10-16 19:35, Jeremy Rubin via bitcoin-dev wrote:\n> \n> The Bitcoin white paper says:\n> \n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the\n> greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes,\n> the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block,\n> an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and\n> then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability\n> of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n> \n> This, Satoshi (who doesn't really matter anyways I guess?) claimed\n> that for Bitcoin to function properly you need a majority honest\n> nodes.\n> \n> There are multiple behaviors one can describe as honest, and\n> economically rational or optimizing is not necessarily rational.\n> \n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that\n> is\n> not honest, but it may be selfish profit maximizing.\n> \n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or\n> not.\n> \n> It seems a lot of the RBF controversy is that Protocol developers\n> have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest\n> behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n> \n> However, Satoshi did not particularly bound what aspects of\n> honesty\n> are important for the network, because there isn't a spec defining\n> exactly what is honest or not. And also as soon as people are\n> honest,\n> you can rely on that assumption for good effect.\n> \n> And sometimes, defining an honest behavior can be creating a\n> higher\n> utility system because most people are \"law abiding citizens\" who\n> might not be short term rational. For example, one might expect\n> that\n> miners would be interested in making sure lightning closes are\n> \"accurate\" because increasing the utility of lightning is good for\n> Bitcoin, even if it is irrational.\n> \n> It seems that the NoRBF crowd want to rely on an honest majority\n> assumption where the honest behavior is not doing replacement if\n> not\n> requested. This is really not much different than trying to close\n> lightning channels \"the right way\".\n> \n> However, where it may be different, is that even in the presence\n> of\n> honest majority, the safety of 0conf isn't assured given the\n> potential\n> of race conditions in the mempool. Therefore it's not clear to me\n> that\n> 0conf working well is something you can drive from the Honest\n> Majority\n> Assumption (where honest includes first seen).\n> \n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms\n> of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n> \n> It's somewhat clear to me that we shouldn't weaken assumptions\n> that\n> only seem local to one subsystem of Bitcoin if they end up\n> destabilizing another system. In particular, things that decrease\n> \"transaction utility\" for end users decrease the demand for\n> transactions which hurts the fee market's longer term viability,\n> even\n> if we feel good about making an honest policy assumption into a\n> self\n> interested policy assumption.\n> \n> A last reflection is that Bitcoin is specified with an honest\n> majority\n> assumption, but also has a rational dishonest minority assumption\n> over\n> both endogenous (rewards) and exogenous (electricity) costs.\n> Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n> \n> Cheers,\n> \n> Jeremy\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/227ec446/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-18T03:34:08",
                "message_text_only": "I think a diagram might help a little...\n\n[image: image.png]\n\n(diagram contains below text, which should be sufficient to reimagine it\nfor the unsighted)\n\n\n\n\nGiven you observe events in the following order:\n\n\n   1.\n\n   Tx A\n   2.\n\n   Tx B\n   3.\n\n   Red Block\n   4.\n\n   Tx C\n   5.\n\n   Tx D\n   6.\n\n   Tx E\n   7.\n\n   Tx F\n\n\nWhich block would you most want to attempt to mine at times 1..=7?\n\n\nBlock W\n\nSubsidy: 1\n\nFee: 10\n\nTxs: A, B\n\nHeight N\n\nPrev V\n\n\nBlock X\n\nSubsidy: 1\n\nFee: 2\n\nTxs: C, D\n\nHeight N+1\n\nPrev W\n\nBlock Y\n\nSubsidy: 1\n\nFee: 12\n\nTxs: A, B, C, D\n\nHeight N\n\nPrev V\n\nSubsidy: 1\n\nFee: 1\n\nTxs: E, F\n\nHeight N+1\n\nPrev Y\n\nBlock Z\n\nSubsidy: 1\n\nFee: 6\n\nTxs: A, D\n\nHeight N\n\nPrev V\n\nSubsidy: 1\n\nFee: 6\n\nTxs: B, C\n\nHeight N+1\n\nPrev Z\n\n\nI'd argue that Y, Z, W (re-mining it with different coinbase) all beat X.\nAnd that most likely, something like Z is most incentive compatible for\nminers, but supremely bad UX for users \"pay more to wait more?? What kind\nof society is this\". Anti-fee sniping exists to decrease likelihood of this\ncircumstance, but is not sufficient in general to solve it.\n\n\n> The idea that people won't do something because it's \"bad for Bitcoin\"\n> doesn't fit an adversarial model.  Even in the above examples (which I\n> think wouldn't expect to happen often), I would argue the network still\n> conforms to a Nash Equilibrium without requiring trust.  Although It's\n> mostly speculation without some empirical data.\n\n\nquote the whitepaper:\n\n> The steps to run the network are as follows:\n> 1)  New transactions are broadcast to all nodes.\n> 2)  Each node collects new transactions into a block.\n> 3)  Each node works on finding a difficult proof-of-work for its block.\n> 4)  When a node finds a proof-of-work, it broadcasts the block to all\n> nodes.\n> 5)  Nodes accept the block only if all transactions in it are valid and\n> not already spent.\n> 6)  Nodes express their acceptance of the block by working on creating the\n> next block in the\n> chain, using the hash of the accepted block as the previous hash.\n> Nodes always consider the longest chain to be the correct one and will\n> keep working on extending it. If two nodes broadcast different versions of\n> the next block simultaneously, some nodes may receive one or the other\n> first. In that case, they work on the first one they received, but save the\n> other branch in case it becomes longer. The tie will be broken when the\n> next proof- of-work is found and one branch becomes longer; the nodes that\n> were working on the other branch will then switch to the longer one.\n\n\nThe idea that bitcoin should work in an adversarial, stepwise selfishly\ninterested model is nice. But I think that it is critical to keep in mind\nthat is an *aspiration*, and very likely not the reality of the network\ntoday, which depends on people caring about other things exogenous to\nsimplified game descriptions (like price increasing or rather not\ndecreasing, long term hardware investments, etc).\n\nIf you note the later whitepaper language:\n\nBy convention, the first transaction in a block is a special transaction\n> that starts a new coin owned by the creator of the block. This adds an\n> incentive for nodes to support the network, and provides a way to initially\n> distribute coins into circulation, since there is no central authority to\n> issue them. The steady addition of a constant of amount of new coins is\n> analogous to gold miners expending resources to add gold to circulation. In\n> our case, it is CPU time and electricity that is expended.\n\n\n\n> The incentive may help encourage nodes to stay honest. If a greedy\n> attacker is able to assemble more CPU power than all the honest nodes, he\n> would have to choose between using it to defraud people by stealing back\n> his payments, or using it to generate new coins. He ought to find it more\n> profitable to play by the rules, such rules that favour him with more new\n> coins than everyone else combined, than to undermine the system and the\n> validity of his own wealth.\n\n\nIt is clear that the incentive is there to help encourage honest miners to\njoin at all, and to encourage nodes of hidden phenotype \"Greedy\" to prefer\nhonest behavior, improving network convergence, but not to make the network\nfunctional if all players are phenotype Greedy. Satoshi still expected, in\nhis analysis, an honest majority.\n\n\n\n\nSide Bar:\n\nWhat Satoshi said doesn't really matter in one sense. The protocol is what\nit is, not what somebody described it as more than a decade ago.\n\nHowever, what *is* important about what Satoshi wrote is that it is sort of\nthe \"social contract\" of what Bitcoin is that we can all sort of minimally\nagree to. This makes it clear, when we try to describe Bitcoin with\ndiffering assumptions than in the whitepaper, what the changes are and why\nwe think the system might support those claims. But if we can't prove the\nnew description sound, such as showing tip mining to be rational in a fully\nadversarial model, it doesn't mean Bitcoin doesn't work as promised, since\nall that was promised originally is functioning under an honest majority.\nCaveat Emptor!\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\n\nOn Mon, Oct 17, 2022 at 6:31 PM <email at yancy.lol> wrote:\n\n> Hi Jeremy,\n>\n> Thanks for the reply. I do find the semantics of mempool and block org\n> interesting (although there's a lot on the topic I don't know).\n>\n>\n> E.g., suppose:\n>\n> Block N: Fees = 10, reward = 1\n>\n> Mempool: Fees = 2\n>\n> Mining block N+1 with the mempool leads to reward 2+1 = 3, reorging\n> leads to reward of up to 10 + 1 + c, (c < 2, where c is the extra\n> transactions that fit).\n>\n> If I'm reading this correctly, Block N was already mined, but the miner\n> who mined block N+1 repacks the transactions from block N because they have\n> more to gain.  Wouldn't such a situation be resolved in the same way as two\n> miners who find a block at a similar time? E.g the network will choose\n> depending on when block N+2 is created.\n>\n>\n> Assume instead your reward is 8, leaving 3+c on the table.\n>\n> Mining block N+1 with the mempool leads to reward 2+8 = 10, reorging leads\n> to 10 + 8 + c?  Wouldn't that leave 8+c?\n>\n>\n> If you assume all other miners are tip miners, and there are two\n> conflicting tips, they should pick the one with the more profit for\n> them, which is the new one you made as a non-tip miner since you\n> \"shared\" some fee.\n>\n> I'm curious how the \"fee sharing\" would be organized.  To see if I\n> understand, You're asking what would happen if one of the two miners\n> incentives (bribes in this case) the next miner (block N+1) to choose one\n> of the competing tip miners?\n>\n>\n> You aren't particularly more likely to remine block N or N+1, before\n> someone builds on it, as opposed to deeper reorgs (which require\n> larger incentive).\n>\n> Agree.\n>\n>\n> However, as many have pointed out, perhaps not following the simple\n> \"honest tip mining\" strategy is bad for bitcoin, so maybe we should\n> expect it not to happen often?\n>\n> The idea that people won't do something because it's \"bad for Bitcoin\"\n> doesn't fit an adversarial model.  Even in the above examples (which I\n> think wouldn't expect to happen often), I would argue the network still\n> conforms to a Nash Equilibrium without requiring trust.  Although It's\n> mostly speculation without some empirical data.\n>\n> Cheers,\n> -Yancy\n>\n> On 2022-10-17 21:10, Jeremy Rubin wrote:\n>\n> Building on the most work chain is perhaps not rational in many normal\n> circumstances that can come up today under the stated reference\n> strategy:\n>\n> 1) Take highest paying transactions that fit\n> 2) Mine on tips\n>\n> E.g., suppose:\n>\n> Block N: Fees = 10, reward = 1\n>\n> Mempool: Fees = 2\n>\n> Mining block N+1 with the mempool leads to reward 2+1 = 3, reorging\n> leads to reward of up to 10 + 1 + c, (c < 2, where c is the extra\n> transactions that fit). Assume instead your reward is 8, leaving 3+c\n> on the table.\n>\n> If you assume all other miners are tip miners, and there are two\n> conflicting tips, they should pick the one with the more profit for\n> them, which is the new one you made as a non-tip miner since you\n> \"shared\" some fee.\n>\n> You aren't particularly more likely to remine block N or N+1, before\n> someone builds on it, as opposed to deeper reorgs (which require\n> larger incentive).\n>\n> However, as many have pointed out, perhaps not following the simple\n> \"honest tip mining\" strategy is bad for bitcoin, so maybe we should\n> expect it not to happen often? Or other strategies to emerge around\n> selecting transactions so that the next M blocks have a similar fee\n> profile, as opposed to picking greedily for the next block.\n>\n> --\n> @JeremyRubin [1 <https://twitter.com/JeremyRubin>]\n>\n> On Sun, Oct 16, 2022 at 3:03 PM <email at yancy.lol> wrote:\n>\n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the\n> greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes,\n> the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block,\n> an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and\n> then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability\n> of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n>\n>\n> It's interesting that Nash Equilibrium isn't mentioned here.  Since\n> each miner has the option to either contribute to the longest chain\n> or not, even if the miners know what strategy the other miners will\n> use, they still wouldn't change their decision to contribute to the\n> majority.\n>\n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that\n> is\n> not honest, but it may be selfish profit maximizing.\n>\n>\n> It would be honest if the store policy said ahead of time they are\n> allowed to sell rain checks for more in such an occurrence.\n> Although this is a good example of the difference between honest and\n> rational.  I think this means it's not a Nash Equilibrium if we\n> needed to rely on the store owner to be honest.\n>\n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or\n> not.\n>\n>\n> My take is that \"rational\" is probably a better word than honest.\n> In terms of a Nash Equilibrium, each participant is simply trying to\n> maximize their outcome and honesty doesn't matter (only that\n> participants are rational).\n>\n> It seems a lot of the RBF controversy is that Protocol developers\n> have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest\n> behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n>\n>\n> I'm curious, can RBF can be described by a Nash Equilibrium?  If\n> yes, then it also shouldn't matter if participants are honest?\n>\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms\n> of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n>\n>\n> White paper 1.1 :D\n>\n> A last reflection is that Bitcoin is specified with an honest\n> majority\n> assumption, but also has a rational dishonest minority assumption\n> over\n> both endogenous (rewards) and exogenous (electricity) costs.\n> Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n>\n>\n> My take is the opposite unless I'm missing something.  Participants\n> are always incentivized to choose the rational solution (Not to\n> waste electricity on a minority chain).\n>\n> Cheers,\n> -Yancy\n>\n> On 2022-10-16 19:35, Jeremy Rubin via bitcoin-dev wrote:\n>\n> The Bitcoin white paper says:\n>\n> The proof-of-work also solves the problem of determining\n> representation in majority decision\n> making. If the majority were based on one-IP-address-one-vote, it\n> could be subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially\n> one-CPU-one-vote. The majority\n> decision is represented by the longest chain, which has the\n> greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes,\n> the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block,\n> an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and\n> then\n> catch up with and surpass the\n> work of the honest nodes. We will show later that the probability\n> of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n>\n> This, Satoshi (who doesn't really matter anyways I guess?) claimed\n> that for Bitcoin to function properly you need a majority honest\n> nodes.\n>\n> There are multiple behaviors one can describe as honest, and\n> economically rational or optimizing is not necessarily rational.\n>\n> For example, if I run a shop that takes rain checks, but I sell an\n> item to a higher bidder who didn't have a hold on the item, that\n> is\n> not honest, but it may be selfish profit maximizing.\n>\n> Satoshi said an honest majority is required for the chain to be\n> extended. Honest is not really defined though. Honesty, in my\n> definition, is that you follow a pre specified rule, rational or\n> not.\n>\n> It seems a lot of the RBF controversy is that Protocol developers\n> have\n> aspired to make the honest behavior also be the rational behavior.\n> This is maybe a good idea because, in theory, if the honest\n> behavior\n> is rational then we can make a weaker assumption of selfishness\n> maximizing a parameter.\n>\n> However, Satoshi did not particularly bound what aspects of\n> honesty\n> are important for the network, because there isn't a spec defining\n> exactly what is honest or not. And also as soon as people are\n> honest,\n> you can rely on that assumption for good effect.\n>\n> And sometimes, defining an honest behavior can be creating a\n> higher\n> utility system because most people are \"law abiding citizens\" who\n> might not be short term rational. For example, one might expect\n> that\n> miners would be interested in making sure lightning closes are\n> \"accurate\" because increasing the utility of lightning is good for\n> Bitcoin, even if it is irrational.\n>\n> It seems that the NoRBF crowd want to rely on an honest majority\n> assumption where the honest behavior is not doing replacement if\n> not\n> requested. This is really not much different than trying to close\n> lightning channels \"the right way\".\n>\n> However, where it may be different, is that even in the presence\n> of\n> honest majority, the safety of 0conf isn't assured given the\n> potential\n> of race conditions in the mempool. Therefore it's not clear to me\n> that\n> 0conf working well is something you can drive from the Honest\n> Majority\n> Assumption (where honest includes first seen).\n>\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms\n> of\n> properties of Bitcoin, as well as pathways to weakening the\n> assumptions without compromising the behaviors users expect the\n> network to have.  An \"extended white paper\" if you will.\n>\n> It's somewhat clear to me that we shouldn't weaken assumptions\n> that\n> only seem local to one subsystem of Bitcoin if they end up\n> destabilizing another system. In particular, things that decrease\n> \"transaction utility\" for end users decrease the demand for\n> transactions which hurts the fee market's longer term viability,\n> even\n> if we feel good about making an honest policy assumption into a\n> self\n> interested policy assumption.\n>\n> A last reflection is that Bitcoin is specified with an honest\n> majority\n> assumption, but also has a rational dishonest minority assumption\n> over\n> both endogenous (rewards) and exogenous (electricity) costs.\n> Satoshi\n> did not suggest, at least as I read it, that Bitcoin works with an\n> rational majority assumption. (If anyone thinks these three are\n> similar properties you can make some trivial counterexamples)\n>\n> Cheers,\n>\n> Jeremy\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n>\n> Links:\n> ------\n> [1] https://twitter.com/JeremyRubin\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/933da5ee/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image.png\nType: image/png\nSize: 653415 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/933da5ee/attachment-0001.png>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2022-10-18T14:30:26",
                "message_text_only": "On Tue, Oct 18, 2022 at 9:07 AM Jeremy Rubin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n>\n> However, what *is* important about what Satoshi wrote is that it is sort\n> of the \"social contract\" of what Bitcoin is that we can all sort of\n> minimally agree to. This makes it clear, when we try to describe Bitcoin\n> with differing assumptions than in the whitepaper, what the changes are and\n> why we think the system might support those claims. But if we can't prove\n> the new description sound, such as showing tip mining to be rational in a\n> fully adversarial model, it doesn't mean Bitcoin doesn't work as promised,\n> since all that was promised originally is functioning under an honest\n> majority. Caveat Emptor!\n>\n\nI still think it is misguided to think that the \"honest\" (i.e. rule\nfollowing) majority is to just be accepted as an axiom and if it is\nviolated, well, then sorry.  The rules need to be incentive compatible for\nthe system to be functional.  The honest majority is only considered an\nassumption because even if following the rules were clearly the 100%\ndominant strategy, this doesn't prove that the majority is honest, since\nmathematics cannot say what is happening in the real world at any given\ntime.  Still, we must have a reason to think that the majority would be\nhonest, and that reasoning should come from an argument that the rule set\nis incentive compatible.\n\nThe stability of mining, i.e. the incentives to mine on the most work\nchain, is actually a huge concern, especially in a future low subsidy\nenvironment.  There is actually much fretting about this issue, and rightly\nso.  We don't actually know that Bitcoin can function in a low subsidy\nenvironment because we have never tested it.  Bitcoin could still end up a\nfailure if that doesn't work out.  My current understanding/guess is that\nwith a \"thick mempool\" (that is lots of transactions without large gaps in\nfee rates between them) and/or miners rationally leaving behind\ntransactions to encourage mining on their block (after all it is in a\nminer's own interest not to have their block orphaned), that mining will be\nstable.  But I don't know this for sure, and we cannot know with certainty\nthat we are going to have a \"thick mempool\" when it is needed.\n\nIt is most certainly the case that one can construct situations where not\nmining on the tip is going to be the prefered strategy.  But even if that\nhappens on occasion, it's not like the protocol immediately collapses,\nbecause mining off the tip is indistinguishable from being a high latency\nminer who simply didn't receive the most work block in time.  So it is more\nof a question of how rare does it need to be, and what can we do to reduce\nthe chances of such situations arising (e.g. updating our mining policy to\nleave some transactions out based on current (and anticipated) mempool\nconditions, or (for a sufficiently capitalized miner) leave an explicit,\nANYONECANSPEND transaction output as a tip for the next miner to build upon\nmined blocks.)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/e2142e1a/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-18T16:27:26",
                "message_text_only": "I think the issue with\n\nI still think it is misguided to think that the \"honest\" (i.e. rule\n> following) majority is to just be accepted as an axiom and if it is\n> violated, well, then sorry.  The rules need to be incentive compatible for\n> the system to be functional.  The honest majority is only considered an\n> assumption because even if following the rules were clearly the 100%\n> dominant strategy, this doesn't prove that the majority is honest, since\n> mathematics cannot say what is happening in the real world at any given\n> time.  Still, we must have a reason to think that the majority would be\n> honest, and that reasoning should come from an argument that the rule set\n> is incentive compatible.\n\n\nepistemically is that even within the game that you prove the dominant\nstrategy, you can't be certain that you've captured (except maybe through\nclever use of exogenous parameters, which reduces to the same thing as %\nhonest) the actual incentives of all players. For example, you would need\nto capture the existence of large hegemonic governments defending their\nlegacy currencies by attacking bitcoin.\n\n\nI think we may be talking past each other if it is a concern / valuable\nexercise to decrease the assumptions that Bitcoin rests on to make it more\nsecure than it is as defined in the whitepaper. That's an exercise of\ntremendous value. I think my point is that those things are aspirational\n(aspirations that perhaps we should absolutely achieve?) but to the extent\nthat we need to fix things like the fee market, selfish mining, mind the\ngap, etc, those are modifying Bitcoin to be secure (or more fair is perhaps\nanother way to look at it) in the presence of deviations from a\nhypothesized \"incentive compatible Bitcoin\", which is a different thing\nthat \"whitepaper bitcoin\". I think that I largely fall in the camp -- as\nevidenced by some past conversations I won't rehash -- that all of Bitcoin\nshould be incentive compatible and we should fix it if not. But from those\nconversations I also learned that there are large swaths of the community\nwho don't share that value, or only share it up to a point, and do feel\ncomfortable resting on honest majority assumptions at one layer of the\nstack or another. And I think that prior / axiom is a pretty central one to\ndebug or comprehend when dealing with, as is happening now, a fight over\nsomething that seems obviously not incentive compatible.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\n\nOn Tue, Oct 18, 2022 at 10:30 AM Russell O'Connor <roconnor at blockstream.com>\nwrote:\n\n> On Tue, Oct 18, 2022 at 9:07 AM Jeremy Rubin via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>>\n>> However, what *is* important about what Satoshi wrote is that it is sort\n>> of the \"social contract\" of what Bitcoin is that we can all sort of\n>> minimally agree to. This makes it clear, when we try to describe Bitcoin\n>> with differing assumptions than in the whitepaper, what the changes are and\n>> why we think the system might support those claims. But if we can't prove\n>> the new description sound, such as showing tip mining to be rational in a\n>> fully adversarial model, it doesn't mean Bitcoin doesn't work as promised,\n>> since all that was promised originally is functioning under an honest\n>> majority. Caveat Emptor!\n>>\n>\n> I still think it is misguided to think that the \"honest\" (i.e. rule\n> following) majority is to just be accepted as an axiom and if it is\n> violated, well, then sorry.  The rules need to be incentive compatible for\n> the system to be functional.  The honest majority is only considered an\n> assumption because even if following the rules were clearly the 100%\n> dominant strategy, this doesn't prove that the majority is honest, since\n> mathematics cannot say what is happening in the real world at any given\n> time.  Still, we must have a reason to think that the majority would be\n> honest, and that reasoning should come from an argument that the rule set\n> is incentive compatible.\n>\n> The stability of mining, i.e. the incentives to mine on the most work\n> chain, is actually a huge concern, especially in a future low subsidy\n> environment.  There is actually much fretting about this issue, and rightly\n> so.  We don't actually know that Bitcoin can function in a low subsidy\n> environment because we have never tested it.  Bitcoin could still end up a\n> failure if that doesn't work out.  My current understanding/guess is that\n> with a \"thick mempool\" (that is lots of transactions without large gaps in\n> fee rates between them) and/or miners rationally leaving behind\n> transactions to encourage mining on their block (after all it is in a\n> miner's own interest not to have their block orphaned), that mining will be\n> stable.  But I don't know this for sure, and we cannot know with certainty\n> that we are going to have a \"thick mempool\" when it is needed.\n>\n> It is most certainly the case that one can construct situations where not\n> mining on the tip is going to be the prefered strategy.  But even if that\n> happens on occasion, it's not like the protocol immediately collapses,\n> because mining off the tip is indistinguishable from being a high latency\n> miner who simply didn't receive the most work block in time.  So it is more\n> of a question of how rare does it need to be, and what can we do to reduce\n> the chances of such situations arising (e.g. updating our mining policy to\n> leave some transactions out based on current (and anticipated) mempool\n> conditions, or (for a sufficiently capitalized miner) leave an explicit,\n> ANYONECANSPEND transaction output as a tip for the next miner to build upon\n> mined blocks.)\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/1bf55b7e/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-10-18T17:33:15",
                "message_text_only": "not sure if this is helpful, but when i'm code reviewing a change to an\nexisting, functioning and very complex system, i rarely go back to \"first\nprinciples\" to analyze that change independently, and instead try to decide\nif it's better or worse than what we have now\n\nyou can introduce a new feature, for example, that has a bunch of\nnoncritical bugs, especially in ux, and then you can weigh in on whether\nits better to get it out now for the people that need it, or bikeshed ux\nfor another 2 releases\n\ni'm often a fan of the former\n\nif someone proposes a change to bitcoin, we should probably review it as\n\"better or worse than what we have\", rather than \"has perfectly aligned\nincentives promoting honest behavior even among selfish actors\"\n\nwe know bitcoin functions now with a complex series of incentives,\nespecially regarding node operators\n\nin other words, does the change \"improve what we have\" is a better bar than\n\"stands on its own\"\n\nin that way the system can slowly improve over time, rather than be stuck\n\n\nOn Tue, Oct 18, 2022 at 12:28 PM Jeremy Rubin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I think the issue with\n>\n> I still think it is misguided to think that the \"honest\" (i.e. rule\n>> following) majority is to just be accepted as an axiom and if it is\n>> violated, well, then sorry.  The rules need to be incentive compatible for\n>> the system to be functional.  The honest majority is only considered an\n>> assumption because even if following the rules were clearly the 100%\n>> dominant strategy, this doesn't prove that the majority is honest, since\n>> mathematics cannot say what is happening in the real world at any given\n>> time.  Still, we must have a reason to think that the majority would be\n>> honest, and that reasoning should come from an argument that the rule set\n>> is incentive compatible.\n>\n>\n> epistemically is that even within the game that you prove the dominant\n> strategy, you can't be certain that you've captured (except maybe through\n> clever use of exogenous parameters, which reduces to the same thing as %\n> honest) the actual incentives of all players. For example, you would need\n> to capture the existence of large hegemonic governments defending their\n> legacy currencies by attacking bitcoin.\n>\n>\n> I think we may be talking past each other if it is a concern / valuable\n> exercise to decrease the assumptions that Bitcoin rests on to make it more\n> secure than it is as defined in the whitepaper. That's an exercise of\n> tremendous value. I think my point is that those things are aspirational\n> (aspirations that perhaps we should absolutely achieve?) but to the extent\n> that we need to fix things like the fee market, selfish mining, mind the\n> gap, etc, those are modifying Bitcoin to be secure (or more fair is perhaps\n> another way to look at it) in the presence of deviations from a\n> hypothesized \"incentive compatible Bitcoin\", which is a different thing\n> that \"whitepaper bitcoin\". I think that I largely fall in the camp -- as\n> evidenced by some past conversations I won't rehash -- that all of Bitcoin\n> should be incentive compatible and we should fix it if not. But from those\n> conversations I also learned that there are large swaths of the community\n> who don't share that value, or only share it up to a point, and do feel\n> comfortable resting on honest majority assumptions at one layer of the\n> stack or another. And I think that prior / axiom is a pretty central one to\n> debug or comprehend when dealing with, as is happening now, a fight over\n> something that seems obviously not incentive compatible.\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n>\n>\n> On Tue, Oct 18, 2022 at 10:30 AM Russell O'Connor <\n> roconnor at blockstream.com> wrote:\n>\n>> On Tue, Oct 18, 2022 at 9:07 AM Jeremy Rubin via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>>\n>>> However, what *is* important about what Satoshi wrote is that it is sort\n>>> of the \"social contract\" of what Bitcoin is that we can all sort of\n>>> minimally agree to. This makes it clear, when we try to describe Bitcoin\n>>> with differing assumptions than in the whitepaper, what the changes are and\n>>> why we think the system might support those claims. But if we can't prove\n>>> the new description sound, such as showing tip mining to be rational in a\n>>> fully adversarial model, it doesn't mean Bitcoin doesn't work as promised,\n>>> since all that was promised originally is functioning under an honest\n>>> majority. Caveat Emptor!\n>>>\n>>\n>> I still think it is misguided to think that the \"honest\" (i.e. rule\n>> following) majority is to just be accepted as an axiom and if it is\n>> violated, well, then sorry.  The rules need to be incentive compatible for\n>> the system to be functional.  The honest majority is only considered an\n>> assumption because even if following the rules were clearly the 100%\n>> dominant strategy, this doesn't prove that the majority is honest, since\n>> mathematics cannot say what is happening in the real world at any given\n>> time.  Still, we must have a reason to think that the majority would be\n>> honest, and that reasoning should come from an argument that the rule set\n>> is incentive compatible.\n>>\n>> The stability of mining, i.e. the incentives to mine on the most work\n>> chain, is actually a huge concern, especially in a future low subsidy\n>> environment.  There is actually much fretting about this issue, and rightly\n>> so.  We don't actually know that Bitcoin can function in a low subsidy\n>> environment because we have never tested it.  Bitcoin could still end up a\n>> failure if that doesn't work out.  My current understanding/guess is that\n>> with a \"thick mempool\" (that is lots of transactions without large gaps in\n>> fee rates between them) and/or miners rationally leaving behind\n>> transactions to encourage mining on their block (after all it is in a\n>> miner's own interest not to have their block orphaned), that mining will be\n>> stable.  But I don't know this for sure, and we cannot know with certainty\n>> that we are going to have a \"thick mempool\" when it is needed.\n>>\n>> It is most certainly the case that one can construct situations where not\n>> mining on the tip is going to be the prefered strategy.  But even if that\n>> happens on occasion, it's not like the protocol immediately collapses,\n>> because mining off the tip is indistinguishable from being a high latency\n>> miner who simply didn't receive the most work block in time.  So it is more\n>> of a question of how rare does it need to be, and what can we do to reduce\n>> the chances of such situations arising (e.g. updating our mining policy to\n>> leave some transactions out based on current (and anticipated) mempool\n>> conditions, or (for a sufficiently capitalized miner) leave an explicit,\n>> ANYONECANSPEND transaction output as a tip for the next miner to build upon\n>> mined blocks.)\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/8fbccf61/attachment.html>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-18T18:57:17",
                "message_text_only": "> not sure if this is helpful, but when i'm code reviewing a change to\n> an existing, functioning and very complex system, i rarely go back to\n> \"first principles\" to analyze that change independently, and instead\n> try to decide if it's better or worse than what we have now\n\nI agree that it's important to not be too dogmatic, which includes \nSatoshi and the white paper. It's fun to look back and read to try to \nfind inspiration, although, it seems to me, a lot has been learned since \nthen.  And a lot will be learned in the future.  I was thinking to \nmyself, what if in the distant future, quantum entanglement could be \nused to update all nodes simultaneously across any distance in space? \nHow cool would that be?  How might that change from the original vision? \n  Well, if we ever get that far, I'm sure Satoshi could not have planned \nfor that, or maybe they could have.. :)\n\nOn 2022-10-18 19:33, Erik Aronesty via bitcoin-dev wrote:\n\n> not sure if this is helpful, but when i'm code reviewing a change to\n> an existing, functioning and very complex system, i rarely go back to\n> \"first principles\" to analyze that change independently, and instead\n> try to decide if it's better or worse than what we have now\n> \n> you can introduce a new feature, for example, that has a bunch of\n> noncritical bugs, especially in ux, and then you can weigh in on\n> whether its better to get it out now for the people that need it, or\n> bikeshed ux for another 2 releases\n> \n> i'm often a fan of the former\n> \n> if someone proposes a change to bitcoin, we should probably review it\n> as \"better or worse than what we have\", rather than \"has perfectly\n> aligned incentives promoting honest behavior even among selfish\n> actors\"\n> \n> we know bitcoin functions now with a complex series of incentives,\n> especially regarding node operators\n> \n> in other words, does the change \"improve what we have\" is a better bar\n> than \"stands on its own\"\n> \n> in that way the system can slowly improve over time, rather than be\n> stuck\n> \n> On Tue, Oct 18, 2022 at 12:28 PM Jeremy Rubin via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> I think the issue with\n> \n> I still think it is misguided to think that the \"honest\" (i.e.\n> rule following) majority is to just be accepted as an axiom and if\n> it is violated, well, then sorry.  The rules need to be incentive\n> compatible for the system to be functional.  The honest majority\n> is only considered an assumption because even if following the\n> rules were clearly the 100% dominant strategy, this doesn't prove\n> that the majority is honest, since mathematics cannot say what is\n> happening in the real world at any given time.  Still, we must\n> have a reason to think that the majority would be honest, and that\n> reasoning should come from an argument that the rule set is\n> incentive compatible.\n> epistemically is that even within the game that you prove the\n> dominant strategy, you can't be certain that you've captured (except\n> maybe through clever use of exogenous parameters, which reduces to\n> the same thing as % honest) the actual incentives of all players.\n> For example, you would need to capture the existence of large\n> hegemonic governments defending their legacy currencies by attacking\n> bitcoin.\n> \n> I think we may be talking past each other if it is a concern /\n> valuable exercise to decrease the assumptions that Bitcoin rests on\n> to make it more secure than it is as defined in the whitepaper.\n> That's an exercise of tremendous value. I think my point is that\n> those things are aspirational (aspirations that perhaps we should\n> absolutely achieve?) but to the extent that we need to fix things\n> like the fee market, selfish mining, mind the gap, etc, those are\n> modifying Bitcoin to be secure (or more fair is perhaps another way\n> to look at it) in the presence of deviations from a hypothesized\n> \"incentive compatible Bitcoin\", which is a different thing that\n> \"whitepaper bitcoin\". I think that I largely fall in the camp -- as\n> evidenced by some past conversations I won't rehash -- that all of\n> Bitcoin should be incentive compatible and we should fix it if not.\n> But from those conversations I also learned that there are large\n> swaths of the community who don't share that value, or only share it\n> up to a point, and do feel comfortable resting on honest majority\n> assumptions at one layer of the stack or another. And I think that\n> prior / axiom is a pretty central one to debug or comprehend when\n> dealing with, as is happening now, a fight over something that seems\n> obviously not incentive compatible.\n> \n> --\n> @JeremyRubin [1 [1]]\n> \n> On Tue, Oct 18, 2022 at 10:30 AM Russell O'Connor\n> <roconnor at blockstream.com> wrote:\n> \n> On Tue, Oct 18, 2022 at 9:07 AM Jeremy Rubin via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> However, what *is* important about what Satoshi wrote is that it is\n> sort of the \"social contract\" of what Bitcoin is that we can all\n> sort of minimally agree to. This makes it clear, when we try to\n> describe Bitcoin with differing assumptions than in the whitepaper,\n> what the changes are and why we think the system might support those\n> claims. But if we can't prove the new description sound, such as\n> showing tip mining to be rational in a fully adversarial model, it\n> doesn't mean Bitcoin doesn't work as promised, since all that was\n> promised originally is functioning under an honest majority. Caveat\n> Emptor!\n> \n> I still think it is misguided to think that the \"honest\" (i.e. rule\n> following) majority is to just be accepted as an axiom and if it is\n> violated, well, then sorry.  The rules need to be incentive\n> compatible for the system to be functional.  The honest majority is\n> only considered an assumption because even if following the rules\n> were clearly the 100% dominant strategy, this doesn't prove that the\n> majority is honest, since mathematics cannot say what is happening\n> in the real world at any given time.  Still, we must have a reason\n> to think that the majority would be honest, and that reasoning\n> should come from an argument that the rule set is incentive\n> compatible.\n> \n> The stability of mining, i.e. the incentives to mine on the most\n> work chain, is actually a huge concern, especially in a future low\n> subsidy environment.  There is actually much fretting about this\n> issue, and rightly so.  We don't actually know that Bitcoin can\n> function in a low subsidy environment because we have never tested\n> it.  Bitcoin could still end up a failure if that doesn't work out.\n> My current understanding/guess is that with a \"thick mempool\" (that\n> is lots of transactions without large gaps in fee rates between\n> them) and/or miners rationally leaving behind transactions to\n> encourage mining on their block (after all it is in a miner's own\n> interest not to have their block orphaned), that mining will be\n> stable.  But I don't know this for sure, and we cannot know with\n> certainty that we are going to have a \"thick mempool\" when it is\n> needed.\n> \n> It is most certainly the case that one can construct situations\n> where not mining on the tip is going to be the prefered strategy.\n> But even if that happens on occasion, it's not like the protocol\n> immediately collapses, because mining off the tip is\n> indistinguishable from being a high latency miner who simply didn't\n> receive the most work block in time.  So it is more of a question of\n> how rare does it need to be, and what can we do to reduce the\n> chances of such situations arising (e.g. updating our mining policy\n> to leave some transactions out based on current (and anticipated)\n> mempool conditions, or (for a sufficiently capitalized miner) leave\n> an explicit, ANYONECANSPEND transaction output as a tip for the next\n> miner to build upon mined blocks.)\n   _______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/f5b13a12/attachment.html>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-20T19:21:58",
                "message_text_only": "I had one other idea on the topic.  Namely, in the last section \n\"calculation\", Satoshi talks more about what he/she/they consider to be \nbad actors.  The idea that someone is not doing \"tip mining\" does not \nmean they are dishonest.\n\n> We consider the scenario of an attacker trying to generate an alternate \n> chain faster than the honest\n> chain. Even if this is accomplished, it does not throw the system open \n> to arbitrary changes, such\n> as creating value out of thin air or taking money that never belonged \n> to the attacker. Nodes are\n> not going to accept an invalid transaction as payment, and honest nodes \n> will never accept a block\n> containing them. An attacker can only try to change one of his own \n> transactions to take back\n> money he recently spent.\n\nIt seems to me that there's a distinction in the game theoretics between \n\"not tip mining\" and actively being a bad actor (changing a past \ntransaction signed by yourself).\n\nI rewrote the \"AttackerSuccessProbability\" C function in Rust for fun:\nhttps://github.com/yancyribbens/attacker-success-probability-rust\n\nCheers,\n-Yancy\n\nOn 2022-10-18 18:27, Jeremy Rubin via bitcoin-dev wrote:\n\n> I think the issue with\n> \n>> I still think it is misguided to think that the \"honest\" (i.e. rule\n>> following) majority is to just be accepted as an axiom and if it is\n>> violated, well, then sorry.  The rules need to be incentive\n>> compatible for the system to be functional.  The honest majority is\n>> only considered an assumption because even if following the rules\n>> were clearly the 100% dominant strategy, this doesn't prove that the\n>> majority is honest, since mathematics cannot say what is happening\n>> in the real world at any given time.  Still, we must have a reason\n>> to think that the majority would be honest, and that reasoning\n>> should come from an argument that the rule set is incentive\n>> compatible.\n> \n> epistemically is that even within the game that you prove the dominant\n> strategy, you can't be certain that you've captured (except maybe\n> through clever use of exogenous parameters, which reduces to the same\n> thing as % honest) the actual incentives of all players. For example,\n> you would need to capture the existence of large hegemonic governments\n> defending their legacy currencies by attacking bitcoin.\n> \n> I think we may be talking past each other if it is a concern /\n> valuable exercise to decrease the assumptions that Bitcoin rests on to\n> make it more secure than it is as defined in the whitepaper. That's an\n> exercise of tremendous value. I think my point is that those things\n> are aspirational (aspirations that perhaps we should absolutely\n> achieve?) but to the extent that we need to fix things like the fee\n> market, selfish mining, mind the gap, etc, those are modifying Bitcoin\n> to be secure (or more fair is perhaps another way to look at it) in\n> the presence of deviations from a hypothesized \"incentive compatible\n> Bitcoin\", which is a different thing that \"whitepaper bitcoin\". I\n> think that I largely fall in the camp -- as evidenced by some past\n> conversations I won't rehash -- that all of Bitcoin should be\n> incentive compatible and we should fix it if not. But from those\n> conversations I also learned that there are large swaths of the\n> community who don't share that value, or only share it up to a point,\n> and do feel comfortable resting on honest majority assumptions at one\n> layer of the stack or another. And I think that prior / axiom is a\n> pretty central one to debug or comprehend when dealing with, as is\n> happening now, a fight over something that seems obviously not\n> incentive compatible.\n> \n> --\n> @JeremyRubin [1 [1]]\n> \n> On Tue, Oct 18, 2022 at 10:30 AM Russell O'Connor\n> <roconnor at blockstream.com> wrote:\n> \n> On Tue, Oct 18, 2022 at 9:07 AM Jeremy Rubin via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> However, what *is* important about what Satoshi wrote is that it\n> is sort of the \"social contract\" of what Bitcoin is that we can\n> all sort of minimally agree to. This makes it clear, when we try\n> to describe Bitcoin with differing assumptions than in the\n> whitepaper, what the changes are and why we think the system might\n> support those claims. But if we can't prove the new description\n> sound, such as showing tip mining to be rational in a fully\n> adversarial model, it doesn't mean Bitcoin doesn't work as\n> promised, since all that was promised originally is functioning\n> under an honest majority. Caveat Emptor!\n> I still think it is misguided to think that the \"honest\" (i.e. rule\n> following) majority is to just be accepted as an axiom and if it is\n> violated, well, then sorry.  The rules need to be incentive\n> compatible for the system to be functional.  The honest majority is\n> only considered an assumption because even if following the rules\n> were clearly the 100% dominant strategy, this doesn't prove that the\n> majority is honest, since mathematics cannot say what is happening\n> in the real world at any given time.  Still, we must have a reason\n> to think that the majority would be honest, and that reasoning\n> should come from an argument that the rule set is incentive\n> compatible.\n> \n> The stability of mining, i.e. the incentives to mine on the most\n> work chain, is actually a huge concern, especially in a future low\n> subsidy environment.  There is actually much fretting about this\n> issue, and rightly so.  We don't actually know that Bitcoin can\n> function in a low subsidy environment because we have never tested\n> it.  Bitcoin could still end up a failure if that doesn't work out.\n> My current understanding/guess is that with a \"thick mempool\" (that\n> is lots of transactions without large gaps in fee rates between\n> them) and/or miners rationally leaving behind transactions to\n> encourage mining on their block (after all it is in a miner's own\n> interest not to have their block orphaned), that mining will be\n> stable.  But I don't know this for sure, and we cannot know with\n> certainty that we are going to have a \"thick mempool\" when it is\n> needed.\n> \n> It is most certainly the case that one can construct situations\n> where not mining on the tip is going to be the prefered strategy.\n> But even if that happens on occasion, it's not like the protocol\n> immediately collapses, because mining off the tip is\n> indistinguishable from being a high latency miner who simply didn't\n> receive the most work block in time.  So it is more of a question of\n> how rare does it need to be, and what can we do to reduce the\n> chances of such situations arising (e.g. updating our mining policy\n> to leave some transactions out based on current (and anticipated)\n> mempool conditions, or (for a sufficiently capitalized miner) leave\n> an explicit, ANYONECANSPEND transaction output as a tip for the next\n> miner to build upon mined blocks.)\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\nLinks:\n------\n[1] https://twitter.com/JeremyRubin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/d96658cc/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T22:19:38",
                "message_text_only": "On Tue, Oct 18, 2022 at 10:30:26AM -0400, Russell O'Connor via bitcoin-dev wrote:\n> It is most certainly the case that one can construct situations where not\n> mining on the tip is going to be the prefered strategy.  But even if that\n> happens on occasion, it's not like the protocol immediately collapses,\n> because mining off the tip is indistinguishable from being a high latency\n> miner who simply didn't receive the most work block in time.  So it is more\n\nI don't believe that's a good argument.\n\nA sufficiently large high latency miner who doesn't receive the most work block\nin time would cause huge disruptions to the network, potentially causing other\nminers to be unprofitable. I even gave a talk on this a few years back, on how\nif Bitcoin mining in space becomes profitable, it'll cause enormous problems\ndue to the slow speed of light.\n\n> of a question of how rare does it need to be, and what can we do to reduce\n> the chances of such situations arising (e.g. updating our mining policy to\n> leave some transactions out based on current (and anticipated) mempool\n> conditions, or (for a sufficiently capitalized miner) leave an explicit,\n> ANYONECANSPEND transaction output as a tip for the next miner to build upon\n> mined blocks.)\n\n...at which point the large miners are likely to be significantly more\nprofitable than small miners, because they can collect more fees. That's a\ndisaster.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/274e40af/attachment.sig>"
            },
            {
                "author": "Russell O'Connor",
                "date": "2022-10-17T15:51:17",
                "message_text_only": ">From my limited academic interactions, people generally take the \"honest\"\nto mean following the rules (regardless of how bad it is for you to follow\nthose rules).  This has in turn led to some blockchain designs based on\ntheir own absurd set of rules, and simply waiving away their issues by\nstipulating their own honest majority or supermajority requirement.  For\nexample, a proof of stake blockchain might require as a rule that users\nsecurely delete their signing keys after a period of time, and prove their\nblockchain secure under these rules.  They then argue that so long as the\n\"honest\" majority follows this rule, then there is no risk of\nreorganization.  If enough users don't delete their signing keys, well\ntheir honest majority assumption is violated, so anything goes.\n\nThe thing is that it is most certainly in each user's interest to *not*\ndelete their signing keys.   Each user has strictly more power and options\navailable by keeping their keys and not deleting them.  This rule violation\nis undetectable, at least until it is too late and a coalition decides to\ntry to collaborate for a reorg to their advantage.\n\nIt is not reasonable to build a distributed pseudonymous system built on\narbitrary rules and then simply define your system to be secure by fiat.\nUsers need an incentive to follow the rules of the system or it just won't\nwork.  In particular, the rules ought to form a Nash Equilibrium, and this\nis violated by, for example, a requirement that users delete their signing\nkeys.  If Bitcoin relied on users acting against their own interest to\nfunction, I doubt Bitcoin would be in operation today.  Certainly I would\nhave no interest in it.\n\nWhile it doesn't really matter, I do believe Satoshi was also aware that\nthe rules cannot just be arbitrary, with no incentive to follow them.\nAfter all, he did note that it was designed to be in the miner's self\ninterest to build upon the longest (most work) chain, even if that point\nended up being rather involved.  That is to say, I don't think that an\n\"honest\" (i.e rule following) majority is meant to be taken as an\nassumption, rather it is something that ought to be a consequence of the\ndesign.\n\nAnyhow, the above is simply a comment on \"honest majority\", and I'm not\ntrying to make a specific claim about RBF here, though I do have my\nopinions and I do see how it is related.\n\nOn Sun, Oct 16, 2022 at 1:36 PM Jeremy Rubin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> The Bitcoin white paper says:\n>\n> The proof-of-work also solves the problem of determining representation in\n> majority decision\n> making. If the majority were based on one-IP-address-one-vote, it could be\n> subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote.\n> The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the\n> honest chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then catch\n> up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n>\n>\n> This, Satoshi (who doesn't really matter anyways I guess?) claimed that\n> for Bitcoin to function properly you need a majority honest nodes.\n>\n> There are multiple behaviors one can describe as honest, and economically\n> rational or optimizing is not necessarily rational.\n>\n> For example, if I run a shop that takes rain checks, but I sell an item to\n> a higher bidder who didn't have a hold on the item, that is not honest, but\n> it may be selfish profit maximizing.\n>\n> Satoshi said an honest majority is required for the chain to be extended.\n> Honest is not really defined though. Honesty, in my definition, is that you\n> follow a pre specified rule, rational or not.\n>\n> It seems a lot of the RBF controversy is that Protocol developers have\n> aspired to make the honest behavior also be the rational behavior. This is\n> maybe a good idea because, in theory, if the honest behavior is rational\n> then we can make a weaker assumption of selfishness maximizing a parameter.\n>\n> However, Satoshi did not particularly bound what aspects of honesty are\n> important for the network, because there isn't a spec defining exactly what\n> is honest or not. And also as soon as people are honest, you can rely on\n> that assumption for good effect.\n>\n> And sometimes, defining an honest behavior can be creating a higher\n> utility system because most people are \"law abiding citizens\" who might not\n> be short term rational. For example, one might expect that miners would be\n> interested in making sure lightning closes are \"accurate\" because\n> increasing the utility of lightning is good for Bitcoin, even if it is\n> irrational.\n>\n> It seems that the NoRBF crowd want to rely on an honest majority\n> assumption where the honest behavior is not doing replacement if not\n> requested. This is really not much different than trying to close lightning\n> channels \"the right way\".\n>\n> However, where it may be different, is that even in the presence of honest\n> majority, the safety of 0conf isn't assured given the potential of race\n> conditions in the mempool. Therefore it's not clear to me that 0conf\n> working well is something you can drive from the Honest Majority Assumption\n> (where honest includes first seen).\n>\n>\n> Overall, it might be nice to more tightly document what bitcoins\n> assumptions are in practice and what those assumptions do in terms of\n> properties of Bitcoin, as well as pathways to weakening the assumptions\n> without compromising the behaviors users expect the network to have.  An\n> \"extended white paper\" if you will.\n>\n>\n>  It's somewhat clear to me that we shouldn't weaken assumptions that only\n> seem local to one subsystem of Bitcoin if they end up destabilizing another\n> system. In particular, things that decrease \"transaction utility\" for end\n> users decrease the demand for transactions which hurts the fee market's\n> longer term viability, even if we feel good about making an honest policy\n> assumption into a self interested policy assumption.\n>\n> A last reflection is that Bitcoin is specified with an honest majority\n> assumption, but also has a rational dishonest minority assumption over both\n> endogenous (rewards) and exogenous (electricity) costs. Satoshi did not\n> suggest, at least as I read it, that Bitcoin works with an rational\n> majority assumption. (If anyone thinks these three are similar properties\n> you can make some trivial counterexamples)\n>\n>\n> Cheers,\n>\n> Jeremy\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/cf650127/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-17T19:02:01",
                "message_text_only": "Good points, Russell.\n\nI think maybe for that particular property, one can partition the types of\nrules one can put into the \"honest rules\" without compromising the system.\n\nFor example, your \"keys deleted\" property is one that is surely bad, but it\ncan be broken down into a many different buckets, such as:\n\n1) Many Keys deleted one time at the start, all parties seem to have an\nexogenous interest in not having the keys, as well as an endogenous one\n(e.g., trusted setup ceremonies for ZCash, all parties seem to love\nprivacy, but also if anyone thinks you have your key maybe they rubber hose\nyou)\n2) Keys should be deleted, but only \"in play\" for some amount of time\n(Bitcoin NG maybe, statechains after the coin does a withdrawal, PoS with\ncheckpoints)\n3) \"Keys\" should be deleted, but can only cause mild or local harms /\nresolvable (Lightning, both eltoo and traditional, old transactions are\n\"Keys\")\n4) Keys must be deleted for all time (proof of work if done as leader\nelection\n\nIn particular, I think the honest behavior assumptions are OK as long as\nthey are reasonably time bounded and observable. For example, in\ntransaction selection, assuming \"honest behavior\" may be acceptable because\nif the property is not true, it doesn't fundamentally brick the system or\ncause mass outage, but it does cause an annoyance and is observable.\nFurther, agents may have a rationalization for following the honest policy\neven above their pointwise interest in profit maximizing, if they think it\nmakes their overall participation more valuable. This is because it is an\ninfinite game and not finite, the most effective strategies aren't always\ndoing to be next-step profit maximizing (for those new to these concepts,\nhttp://www.econ.uiuc.edu/~hrtdmrt2/Teaching/GT_2015_19/L12.pdf is a decent\nprimer). The example of deleting keys is interesting, because you don't\nneed to make your defection observable. But for transaction selection, it\nabsolutely is.\n\n\nUltimately, I think the reason why (some) systems do the cop-out of \"honest\nmajority rules\" --> \"secure outcome\" is because of a belief that there is\nan \"existential unknown proof\" that there is an infinite game that can be\ndescribed where this should be the dominant strategy for all players,\nwhether defined or not. However, one must be incredibly careful with such\nassumptions of an unknown existential game to which that is the dominant\nstrategy to not abuse them to ex-falso-quod-libet themselves into a corner\n(Bertrand Russel is the Pope) if such a game does not actually exist. It's\nobviously much better to actually prove the incentive compatibility against\nan explicit game with explicitly stated assumptions for this reason (can\ninclude exogenous details like \"wanting number-go-up\", \"have a 5 year\nhardware investment\", or \"belief that 0conf working required for adoption\").\n\nI (somewhat) suspect that things like the 0Conf safety assumptions are in\nthis category where one must be careful, because I think there might not be\na game where they are secure, so it leads to being able to prove false. But\nI also understand why others might think such a game would exist, so\ntherein the debate.\n\nBest,\n\nJeremy\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\n\nOn Mon, Oct 17, 2022 at 11:51 AM Russell O'Connor <roconnor at blockstream.com>\nwrote:\n\n> From my limited academic interactions, people generally take the \"honest\"\n> to mean following the rules (regardless of how bad it is for you to follow\n> those rules).  This has in turn led to some blockchain designs based on\n> their own absurd set of rules, and simply waiving away their issues by\n> stipulating their own honest majority or supermajority requirement.  For\n> example, a proof of stake blockchain might require as a rule that users\n> securely delete their signing keys after a period of time, and prove their\n> blockchain secure under these rules.  They then argue that so long as the\n> \"honest\" majority follows this rule, then there is no risk of\n> reorganization.  If enough users don't delete their signing keys, well\n> their honest majority assumption is violated, so anything goes.\n>\n> The thing is that it is most certainly in each user's interest to *not*\n> delete their signing keys.   Each user has strictly more power and options\n> available by keeping their keys and not deleting them.  This rule violation\n> is undetectable, at least until it is too late and a coalition decides to\n> try to collaborate for a reorg to their advantage.\n>\n> It is not reasonable to build a distributed pseudonymous system built on\n> arbitrary rules and then simply define your system to be secure by fiat.\n> Users need an incentive to follow the rules of the system or it just won't\n> work.  In particular, the rules ought to form a Nash Equilibrium, and this\n> is violated by, for example, a requirement that users delete their signing\n> keys.  If Bitcoin relied on users acting against their own interest to\n> function, I doubt Bitcoin would be in operation today.  Certainly I would\n> have no interest in it.\n>\n> While it doesn't really matter, I do believe Satoshi was also aware that\n> the rules cannot just be arbitrary, with no incentive to follow them.\n> After all, he did note that it was designed to be in the miner's self\n> interest to build upon the longest (most work) chain, even if that point\n> ended up being rather involved.  That is to say, I don't think that an\n> \"honest\" (i.e rule following) majority is meant to be taken as an\n> assumption, rather it is something that ought to be a consequence of the\n> design.\n>\n> Anyhow, the above is simply a comment on \"honest majority\", and I'm not\n> trying to make a specific claim about RBF here, though I do have my\n> opinions and I do see how it is related.\n>\n> On Sun, Oct 16, 2022 at 1:36 PM Jeremy Rubin via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> The Bitcoin white paper says:\n>>\n>> The proof-of-work also solves the problem of determining representation\n>> in majority decision\n>> making. If the majority were based on one-IP-address-one-vote, it could\n>> be subverted by anyone\n>> able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote.\n>> The majority\n>> decision is represented by the longest chain, which has the greatest\n>> proof-of-work effort invested\n>> in it. If a majority of CPU power is controlled by honest nodes, the\n>> honest chain will grow the\n>> fastest and outpace any competing chains. To modify a past block, an\n>> attacker would have to\n>> redo the proof-of-work of the block and all blocks after it and then\n>> catch up with and surpass the\n>> work of the honest nodes. We will show later that the probability of a\n>> slower attacker catching up\n>> diminishes exponentially as subsequent blocks are added.\n>>\n>>\n>> This, Satoshi (who doesn't really matter anyways I guess?) claimed that\n>> for Bitcoin to function properly you need a majority honest nodes.\n>>\n>> There are multiple behaviors one can describe as honest, and economically\n>> rational or optimizing is not necessarily rational.\n>>\n>> For example, if I run a shop that takes rain checks, but I sell an item\n>> to a higher bidder who didn't have a hold on the item, that is not honest,\n>> but it may be selfish profit maximizing.\n>>\n>> Satoshi said an honest majority is required for the chain to be extended.\n>> Honest is not really defined though. Honesty, in my definition, is that you\n>> follow a pre specified rule, rational or not.\n>>\n>> It seems a lot of the RBF controversy is that Protocol developers have\n>> aspired to make the honest behavior also be the rational behavior. This is\n>> maybe a good idea because, in theory, if the honest behavior is rational\n>> then we can make a weaker assumption of selfishness maximizing a parameter.\n>>\n>> However, Satoshi did not particularly bound what aspects of honesty are\n>> important for the network, because there isn't a spec defining exactly what\n>> is honest or not. And also as soon as people are honest, you can rely on\n>> that assumption for good effect.\n>>\n>> And sometimes, defining an honest behavior can be creating a higher\n>> utility system because most people are \"law abiding citizens\" who might not\n>> be short term rational. For example, one might expect that miners would be\n>> interested in making sure lightning closes are \"accurate\" because\n>> increasing the utility of lightning is good for Bitcoin, even if it is\n>> irrational.\n>>\n>> It seems that the NoRBF crowd want to rely on an honest majority\n>> assumption where the honest behavior is not doing replacement if not\n>> requested. This is really not much different than trying to close lightning\n>> channels \"the right way\".\n>>\n>> However, where it may be different, is that even in the presence of\n>> honest majority, the safety of 0conf isn't assured given the potential of\n>> race conditions in the mempool. Therefore it's not clear to me that 0conf\n>> working well is something you can drive from the Honest Majority Assumption\n>> (where honest includes first seen).\n>>\n>>\n>> Overall, it might be nice to more tightly document what bitcoins\n>> assumptions are in practice and what those assumptions do in terms of\n>> properties of Bitcoin, as well as pathways to weakening the assumptions\n>> without compromising the behaviors users expect the network to have.  An\n>> \"extended white paper\" if you will.\n>>\n>>\n>>  It's somewhat clear to me that we shouldn't weaken assumptions that only\n>> seem local to one subsystem of Bitcoin if they end up destabilizing another\n>> system. In particular, things that decrease \"transaction utility\" for end\n>> users decrease the demand for transactions which hurts the fee market's\n>> longer term viability, even if we feel good about making an honest policy\n>> assumption into a self interested policy assumption.\n>>\n>> A last reflection is that Bitcoin is specified with an honest majority\n>> assumption, but also has a rational dishonest minority assumption over both\n>> endogenous (rewards) and exogenous (electricity) costs. Satoshi did not\n>> suggest, at least as I read it, that Bitcoin works with an rational\n>> majority assumption. (If anyone thinks these three are similar properties\n>> you can make some trivial counterexamples)\n>>\n>>\n>> Cheers,\n>>\n>> Jeremy\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/f921db8a/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T22:28:16",
                "message_text_only": "On Sun, Oct 16, 2022 at 01:35:54PM -0400, Jeremy Rubin via bitcoin-dev wrote:\n> The Bitcoin white paper says:\n> \n> The proof-of-work also solves the problem of determining representation in\n> majority decision\n> making. If the majority were based on one-IP-address-one-vote, it could be\n> subverted by anyone\n> able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote.\n> The majority\n> decision is represented by the longest chain, which has the greatest\n> proof-of-work effort invested\n> in it. If a majority of CPU power is controlled by honest nodes, the honest\n> chain will grow the\n> fastest and outpace any competing chains. To modify a past block, an\n> attacker would have to\n> redo the proof-of-work of the block and all blocks after it and then catch\n> up with and surpass the\n> work of the honest nodes. We will show later that the probability of a\n> slower attacker catching up\n> diminishes exponentially as subsequent blocks are added.\n> \n> \n> This, Satoshi (who doesn't really matter anyways I guess?) claimed that for\n> Bitcoin to function properly you need a majority honest nodes.\n\nSatoshi also made a very fundamental mistake: the whitepaper and initial\nBitcoin release chooses the *longest* chain, rather than the most work chain.\nLongest chain is totally broken.\n\nWhat Satoshi said in the whitepaper is completely irrelevant and quoting it in\ncircumstances like this is IMO misleading.\n\n\nAnyway, obviously we should always try to make systems that work properly with\nan economically rational majority, rather than the much more risky honest\nmajority. Economically rational is a better security guarantee. And whenever\npossible we should go even further, using the standard computationally\ninfeasible guarantees (as seen in our EC signature schems), or even,\nmathematically impossible (1+1=2).\n\nIt's notable how in ethereum land, their smart contract schemes have lead to\nsignificant effort in economically rational MEV optimization, at a significant\ncost to decentralization (eg majority of blocks are now OFAC compliant).\nThere's no reason why Bitcoin should be fundamentally any different in the long\nrun.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/cb50a6df/attachment.sig>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-20T23:54:00",
                "message_text_only": "The difference between honest majority and longest chain is that the\nlongest chain bug was something acknowledged by Satoshi & patched\nhttps://github.com/bitcoin/bitcoin/commit/40cd0369419323f8d7385950e20342e998c994e1#diff-623e3fd6da1a45222eeec71496747b31R420\n.\n\n\nOTOH, we have more explicit references that the honest majority really\nshould be thought of as good guys vs bad guys... e.g.\n>\n> Thanks for bringing up that point.\n> I didn't really make that statement as strong as I could have. The\n> requirement is that the good guys collectively have more CPU power than any\n> single attacker.\n> There would be many smaller zombie farms that are not big enough to\n> overpower the network, and they could still make money by generating\n> bitcoins. The smaller farms are then the \"honest nodes\". (I need a better\n> term than \"honest\") The more smaller farms resort to generating bitcoins,\n> the higher the bar gets to overpower the network, making larger farms also\n> too small to overpower it so that they may as well generate bitcoins too.\n> According to the \"long tail\" theory, the small, medium and merely large\n> farms put together should add up to a lot more than the biggest zombie farm.\n> Even if a bad guy does overpower the network, it's not like he's instantly\n> rich. All he can accomplish is to take back money he himself spent, like\n> bouncing a check. To exploit it, he would have to buy something from a\n> merchant, wait till it ships, then overpower the network and try to take\n> his money back. I don't think he could make as much money trying to pull a\n> carding scheme like that as he could by generating bitcoins. With a zombie\n> farm that big, he could generate more bitcoins than everyone else combined.\n> The Bitcoin network might actually reduce spam by diverting zombie farms\n> to generating bitcoins instead.\n> Satoshi Nakamoto\n\n\n\nThere is clearly a notion that Satoshi categorizes good guys / bad guys as\npeople interested in double spending and people who aren't.\n\nSure, Satoshi's writings don't *really* matter in the context of what\nBitcoin is / can be, and I've acknowledged that repeatedly. For you to call\nit misleading is more misleading than for me to quote from it!\n\nThere's a reason I'm citing it. To not read the original source material\nthat pulled the community together is to make one ignorant around why there\nis resistance to something like RBF. This is because there are still\nelements of the community who expect the rules that good-phenotype node\noperators run to be the ones maximally friendly to resolving transactions\non the first seen basis, so that there aren't double spends. This is a view\nwhich you can directly derive from these early writings around what one\nshould expect of node operators.\n\nThe burden rests on the community, who has undertaken a project to adopt a\ndifferent security model from the original \"social contract\" generated by\nthe early writings of Satoshi, to demonstrate why damaging one group's\nreliance interest on a property derived from the honest majority assumption\nis justified.\n\nI do think the case can be fairly made for full RBF, but if you don't grok\nthe above maybe you won't have as much empathy for people who built a\nbusiness around particular aspects of the Bitcoin network that they feel\nare now being changed. They have every right to be mad about that and make\ndisagreements known and argue for why we should preserve these properties.\nAs someone who wants for Bitcoin to be a system which doesn't arbitrarily\nchange rules based on the whims of others, I think it important that we can\nsteelman and provide strong cases for why our actions might be in the\nwrong, so that we make sure our justifications are not only well-justified,\nbut that we can communicate them clearly to all participants in a global\nvalue network.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n\n\nOn Thu, Oct 20, 2022 at 3:28 PM Peter Todd <pete at petertodd.org> wrote:\n\n> On Sun, Oct 16, 2022 at 01:35:54PM -0400, Jeremy Rubin via bitcoin-dev\n> wrote:\n> > The Bitcoin white paper says:\n> >\n> > The proof-of-work also solves the problem of determining representation\n> in\n> > majority decision\n> > making. If the majority were based on one-IP-address-one-vote, it could\n> be\n> > subverted by anyone\n> > able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote.\n> > The majority\n> > decision is represented by the longest chain, which has the greatest\n> > proof-of-work effort invested\n> > in it. If a majority of CPU power is controlled by honest nodes, the\n> honest\n> > chain will grow the\n> > fastest and outpace any competing chains. To modify a past block, an\n> > attacker would have to\n> > redo the proof-of-work of the block and all blocks after it and then\n> catch\n> > up with and surpass the\n> > work of the honest nodes. We will show later that the probability of a\n> > slower attacker catching up\n> > diminishes exponentially as subsequent blocks are added.\n> >\n> >\n> > This, Satoshi (who doesn't really matter anyways I guess?) claimed that\n> for\n> > Bitcoin to function properly you need a majority honest nodes.\n>\n> Satoshi also made a very fundamental mistake: the whitepaper and initial\n> Bitcoin release chooses the *longest* chain, rather than the most work\n> chain.\n> Longest chain is totally broken.\n>\n> What Satoshi said in the whitepaper is completely irrelevant and quoting\n> it in\n> circumstances like this is IMO misleading.\n>\n>\n> Anyway, obviously we should always try to make systems that work properly\n> with\n> an economically rational majority, rather than the much more risky honest\n> majority. Economically rational is a better security guarantee. And\n> whenever\n> possible we should go even further, using the standard computationally\n> infeasible guarantees (as seen in our EC signature schems), or even,\n> mathematically impossible (1+1=2).\n>\n> It's notable how in ethereum land, their smart contract schemes have lead\n> to\n> significant effort in economically rational MEV optimization, at a\n> significant\n> cost to decentralization (eg majority of blocks are now OFAC compliant).\n> There's no reason why Bitcoin should be fundamentally any different in the\n> long\n> run.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/b8f57a36/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-21T00:26:14",
                "message_text_only": "On Thu, Oct 20, 2022 at 04:54:00PM -0700, Jeremy Rubin wrote:\n> The difference between honest majority and longest chain is that the\n> longest chain bug was something acknowledged by Satoshi & patched\n> https://github.com/bitcoin/bitcoin/commit/40cd0369419323f8d7385950e20342e998c994e1#diff-623e3fd6da1a45222eeec71496747b31R420\n> .\n> \n> \n> OTOH, we have more explicit references that the honest majority really\n> should be thought of as good guys vs bad guys... e.g.\n\nThe point is Satoshi got a lot of very fundamental stuff wrong. Bringing up\nwhat Satoshi wrote now, almost 14 years later, misleads less-technical readers\ninto thinking our understanding of Bitcoin is still based on that early,\nincorrect, understanding.\n\nIncidentally, you realize that it was _Satoshi_ who added RBF to Bitcoin with\nnSequence replacements. My contribution was to fix that obviously broken design\nwith fee-based RBF (with nSequence a transaction could be replaced up to 4\nbillion times, using essentially unlimited P2P bandwidth; it was a terrible\nidea).\n\n> I do think the case can be fairly made for full RBF, but if you don't grok\n> the above maybe you won't have as much empathy for people who built a\n> business around particular aspects of the Bitcoin network that they feel\n> are now being changed. They have every right to be mad about that and make\n> disagreements known and argue for why we should preserve these properties.\n\nThose people run mild sybil attacks on the network in their efforts to\n\"mitigate risk\" by monitoring propagation; fundamentally doing so is\ncentralizing and unfair, as only a small number of companies can do that\nwithout DoS attacking the P2P network. It's pretty obvious that reliance to\nzeroconf is harmful to Bitcoin, and people trying to do that have repeatedly\ntaken big losses when their risk mitigations turned out to not work. Their only\nright to be mad comes from the 1st Ammendment.\n\n> As someone who wants for Bitcoin to be a system which doesn't arbitrarily\n> change rules based on the whims of others, I think it important that we can\n> steelman and provide strong cases for why our actions might be in the\n> wrong, so that we make sure our justifications are not only well-justified,\n> but that we can communicate them clearly to all participants in a global\n> value network.\n\n...and the easiest way to avoid Bitcoin being a system that doesn't arbitrarily\nchange rules, is to rely on economically rational rules that aren't likely to\nchange!\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/1f1af04a/attachment.sig>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-21T08:47:19",
                "message_text_only": "> ...and the easiest way to avoid Bitcoin being a system that doesn't \n> arbitrarily\n> change rules, is to rely on economically rational rules that aren't \n> likely to\n> change!\n\nYes, I think many people on this thread have been making the same point. \n  This is the basis of the Nash Equilibrium, from what I remember.\n\n> This, Satoshi (who doesn't really matter anyways I guess?)\n\nIt doesn't seem to me Satoshi was classically trained in CS else maybe \nhe/she/they might have referenced the Nash Equilibrium.  Looking at some \nof the other references, including a statistics book titled \"An \nIntroduction to Probability Theory and its Applications\" from 1957 makes \nme think this Satoshi person was closer in training and practice to a \nmathematician.\n\nCheers,\n-Yancy\n\nOn 2022-10-21 02:26, Peter Todd via bitcoin-dev wrote:\n\n> On Thu, Oct 20, 2022 at 04:54:00PM -0700, Jeremy Rubin wrote:\n> \n>> The difference between honest majority and longest chain is that the\n>> longest chain bug was something acknowledged by Satoshi & patched\n>> https://github.com/bitcoin/bitcoin/commit/40cd0369419323f8d7385950e20342e998c994e1#diff-623e3fd6da1a45222eeec71496747b31R420\n>> .\n>> \n>> OTOH, we have more explicit references that the honest majority really\n>> should be thought of as good guys vs bad guys... e.g.\n> \n> The point is Satoshi got a lot of very fundamental stuff wrong. \n> Bringing up\n> what Satoshi wrote now, almost 14 years later, misleads less-technical \n> readers\n> into thinking our understanding of Bitcoin is still based on that \n> early,\n> incorrect, understanding.\n> \n> Incidentally, you realize that it was _Satoshi_ who added RBF to \n> Bitcoin with\n> nSequence replacements. My contribution was to fix that obviously \n> broken design\n> with fee-based RBF (with nSequence a transaction could be replaced up \n> to 4\n> billion times, using essentially unlimited P2P bandwidth; it was a \n> terrible\n> idea).\n> \n>> I do think the case can be fairly made for full RBF, but if you don't \n>> grok\n>> the above maybe you won't have as much empathy for people who built a\n>> business around particular aspects of the Bitcoin network that they \n>> feel\n>> are now being changed. They have every right to be mad about that and \n>> make\n>> disagreements known and argue for why we should preserve these \n>> properties.\n> \n> Those people run mild sybil attacks on the network in their efforts to\n> \"mitigate risk\" by monitoring propagation; fundamentally doing so is\n> centralizing and unfair, as only a small number of companies can do \n> that\n> without DoS attacking the P2P network. It's pretty obvious that \n> reliance to\n> zeroconf is harmful to Bitcoin, and people trying to do that have \n> repeatedly\n> taken big losses when their risk mitigations turned out to not work. \n> Their only\n> right to be mad comes from the 1st Ammendment.\n> \n>> As someone who wants for Bitcoin to be a system which doesn't \n>> arbitrarily\n>> change rules based on the whims of others, I think it important that \n>> we can\n>> steelman and provide strong cases for why our actions might be in the\n>> wrong, so that we make sure our justifications are not only \n>> well-justified,\n>> but that we can communicate them clearly to all participants in a \n>> global\n>> value network.\n> \n> ...and the easiest way to avoid Bitcoin being a system that doesn't \n> arbitrarily\n> change rules, is to rely on economically rational rules that aren't \n> likely to\n> change!\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/3dff1bad/attachment-0001.html>"
            },
            {
                "author": "S kang",
                "date": "2022-10-21T13:17:07",
                "message_text_only": "Hello respected parties of the bitcoin network,\n\nThe point, as put forward by Jeremy is, economic rationality sometimes leads to breaking the \u2019social contract\u2019 set earlier in history.\n\nBeyond its implications to RBF discussion, following economic rationality, rather than trying to uphold the social contract(honesty), may lead to hijacking of the network. Few examples: Development/Mining might follow the economic rational path of supporting whatever the blockchains winning in the market are doing (supporting smart contracts, or becoming a privacy chain, etc.) even at the price of giving up peer to peer payment system (the meme infinity/21m maybe the opposite of issuing multiple coins). A centralized third party may acquire the market sentiment to motivate this direction or influence miners/bitcoin dev to follow their roadmap, which seems beneficial to individuals until the extreme case where the core use-case is needed to secure themselves.\n\nThe main issue it seems is consensus(pow-based-vote or market sentiment driven improvements) cannot be vetoed by an individual(minority is not quite the right term, since it is opposite of majority, vs consensus). They can only exit at that point(, as the 'ship sails').\n\nMy point is \u2018purity\u2019 about Satoshi's vision(a cringe term at this point, but it means nothing more than the original \u2019social contract\u2019 here) should be aspired to (while not considering Satoshi's word as given truth, as pointed out by the bugs) & all \u2018improvements\u2019 must NOT be entertained. On the other hand, as pointed out by Peter & Yancy, it may be practically impossible to do anything better than economic rationality. (A corollary, is that attacks described might have already happened and thus current audience might be \u2018unable to grok\u2019 as explained by Jeremy.)\n\nThanks for your time, mindshare & bearing my lack of academic quality.\n\n- S Kang\n\n\n> On Oct 21, 2022, at 1:47 AM, yancy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> ...and the easiest way to avoid Bitcoin being a system that doesn't arbitrarily\n>> change rules, is to rely on economically rational rules that aren't likely to\n>> change!\n>  \n> Yes, I think many people on this thread have been making the same point.  This is the basis of the Nash Equilibrium, from what I remember.\n>  \n>> This, Satoshi (who doesn't really matter anyways I guess?)\n> \n>  \n> It doesn't seem to me Satoshi was classically trained in CS else maybe he/she/they might have referenced the Nash Equilibrium.  Looking at some of the other references, including a statistics book titled \"An Introduction to Probability Theory and its Applications\" from 1957 makes me think this Satoshi person was closer in training and practice to a mathematician.\n>  \n> Cheers,\n> -Yancy\n>  \n> On 2022-10-21 02:26, Peter Todd via bitcoin-dev wrote:\n>> \n>> On Thu, Oct 20, 2022 at 04:54:00PM -0700, Jeremy Rubin wrote:\n>>> \n>>> The difference between honest majority and longest chain is that the\n>>> longest chain bug was something acknowledged by Satoshi & patched\n>>> https://github.com/bitcoin/bitcoin/commit/40cd0369419323f8d7385950e20342e998c994e1#diff-623e3fd6da1a45222eeec71496747b31R420 <https://github.com/bitcoin/bitcoin/commit/40cd0369419323f8d7385950e20342e998c994e1#diff-623e3fd6da1a45222eeec71496747b31R420>\n>>> .\n>>> \n>>> \n>>> OTOH, we have more explicit references that the honest majority really\n>>> should be thought of as good guys vs bad guys... e.g.\n>> \n>> The point is Satoshi got a lot of very fundamental stuff wrong. Bringing up\n>> what Satoshi wrote now, almost 14 years later, misleads less-technical readers\n>> into thinking our understanding of Bitcoin is still based on that early,\n>> incorrect, understanding.\n>> \n>> Incidentally, you realize that it was _Satoshi_ who added RBF to Bitcoin with\n>> nSequence replacements. My contribution was to fix that obviously broken design\n>> with fee-based RBF (with nSequence a transaction could be replaced up to 4\n>> billion times, using essentially unlimited P2P bandwidth; it was a terrible\n>> idea).\n>> \n>>> I do think the case can be fairly made for full RBF, but if you don't grok\n>>> the above maybe you won't have as much empathy for people who built a\n>>> business around particular aspects of the Bitcoin network that they feel\n>>> are now being changed. They have every right to be mad about that and make\n>>> disagreements known and argue for why we should preserve these properties.\n>> \n>> Those people run mild sybil attacks on the network in their efforts to\n>> \"mitigate risk\" by monitoring propagation; fundamentally doing so is\n>> centralizing and unfair, as only a small number of companies can do that\n>> without DoS attacking the P2P network. It's pretty obvious that reliance to\n>> zeroconf is harmful to Bitcoin, and people trying to do that have repeatedly\n>> taken big losses when their risk mitigations turned out to not work. Their only\n>> right to be mad comes from the 1st Ammendment.\n>> \n>>> As someone who wants for Bitcoin to be a system which doesn't arbitrarily\n>>> change rules based on the whims of others, I think it important that we can\n>>> steelman and provide strong cases for why our actions might be in the\n>>> wrong, so that we make sure our justifications are not only well-justified,\n>>> but that we can communicate them clearly to all participants in a global\n>>> value network.\n>> \n>> ...and the easiest way to avoid Bitcoin being a system that doesn't arbitrarily\n>> change rules, is to rely on economically rational rules that aren't likely to\n>> change!\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>_______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/720957bf/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Does Bitcoin require or have an honest majority or a rational one? (re rbf)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "S kang",
                "Peter Todd",
                "email at yancy.lol",
                "Russell O'Connor",
                "Erik Aronesty",
                "Jeremy Rubin"
            ],
            "messages_count": 18,
            "total_messages_chars_count": 125142
        }
    },
    {
        "title": "[bitcoin-dev] Does Bitcoin require or have an honest majority or a rational one? (re rbf) (Jeremy Rubin)",
        "thread_messages": [
            {
                "author": "John Carvalho",
                "date": "2022-10-17T06:23:20",
                "message_text_only": "Simply, 0conf acceptance can be monitored and enforced by the merchant and\nexposure to doublespends can be both mitigated and limited in size per\nblock. It is less expensive to be double-spent occasionally than to have a\ndelayed checkout experience. Responsible 0conf acceptance is both rational\nand trusting.\n\nRBF assurances are optionally enforced by miners, and can be assisted by\nnode mempool policies. It is not reliable to expect replaceable payments to\nbe enforced in a system designed to enforce integrity of payments. RBF is\nboth irrational and trusting.\n\nRBF is a whim of a feature where engineers made the mistake of thinking a\nhack that basically incentivizes rollbacks and uncertainty might be useful\nbecause we can pretend Bitcoin has an undo button, and we can pretend to\ngame the fee market by low-balling rates until txns get in.\n\nNow RBF just kinda haunts us as the establishment keeps baking it deeper\nand deeper into Bitcoin, despite almost no one using it, and despite it\nhaving negative consequences on more popular use cases.\n\nMiners serve full nodes. What is more likely, a node set that prefers\nblocks with replaced txns, or a node set that rejects blocks with replaced\ntxns?\n\n\n--\nJohn Carvalho\nCEO, Synonym.to <http://synonym.to/>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221017/9685b7ad/attachment.html>"
            },
            {
                "author": "Murch",
                "date": "2022-10-18T13:40:00",
                "message_text_only": "Hello John,\n\nOn 17.10.22 02:23, John Carvalho via bitcoin-dev wrote:\n> Simply, 0conf acceptance can be monitored and enforced by the merchant and exposure to doublespends can be both mitigated and limited in size per block. It is less expensive to be double-spent occasionally than to have a delayed checkout experience. Responsible 0conf acceptance is both rational and trusting.\n\n29% of all transactions explicitly signal replaceability (see \nhttps://transactionfee.info/charts/transactions-signaling-explicit-rbf/), trend \nrising. If ignoring risk is an acceptable approach now, why would it no \nlonger work when the remaining 71% of transactions also became subject \nto replaceability?\n\nOn 17.10.22 02:23, John Carvalho via bitcoin-dev wrote:\n> Now RBF just kinda haunts us as the establishment keeps baking it deeper and deeper into Bitcoin, despite almost no one using it, and despite it having negative consequences on more popular use cases.\n\nHow can RBF at the same time be hardly used as well as an incalculable risk?\n\nFact of the matter is that one can neither rely on having seen all \ntransactions that miners are considering for their block templates, nor \nthat a replacement be received by the miners before the original is \npicked into a block.\nWe're between seats: first-seen is an unstable gentlemen's agreement, \ninevitable to fail eventually once a few defect. Meanwhile propping up \nthe illusion of \"reliable payment promises\" is hampering price discovery \nof blockspace and complicating protocol development. By converging on \nthe inevitable outcome and facilitating replaceability for all \ntransactions, we can rip off the band-aid rather than suffer uncertainty \nindefinitely\u2014even if it requires some to honestly reassess their \nbusiness approach in light of the natural modus operandi of Bitcoin's \ngossip system.\n\nCheers,\nMurch\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: OpenPGP_0xACFDB93A9175DCAB_and_old_rev.asc\nType: application/pgp-keys\nSize: 119298 bytes\nDesc: OpenPGP public key\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/3d7170ac/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: OpenPGP_signature\nType: application/pgp-signature\nSize: 833 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/3d7170ac/attachment-0001.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-20T22:52:03",
                "message_text_only": "On Mon, Oct 17, 2022 at 08:23:20AM +0200, John Carvalho via bitcoin-dev wrote:\n> Simply, 0conf acceptance can be monitored and enforced by the merchant and\n> exposure to doublespends can be both mitigated and limited in size per\n> block. It is less expensive to be double-spent occasionally than to have a\n> delayed checkout experience. Responsible 0conf acceptance is both rational\n> and trusting.\n> \n> RBF assurances are optionally enforced by miners, and can be assisted by\n> node mempool policies. It is not reliable to expect replaceable payments to\n> be enforced in a system designed to enforce integrity of payments. RBF is\n> both irrational and trusting.\n\nMy OpenTimestamps calendars all use RBF for optimal fee discovery. The fact is,\nabout 95% of OTS transactions mined are replacements rather than originals. I\nalso took a quick look, and found examples of replacements mined by Foundry\nUSA, AntPool, F2Pool, Binance Pool, ViaBTC, SlushPool, Luxor, MARA Pool, and\nPoolin. That's at least 97.21% of all hashing power supporting opt-in RBF.\n\nAre you claiming that almost all hashing power is irrational?\n\n> RBF is a whim of a feature where engineers made the mistake of thinking a\n> hack that basically incentivizes rollbacks and uncertainty might be useful\n> because we can pretend Bitcoin has an undo button, and we can pretend to\n> game the fee market by low-balling rates until txns get in.\n\nElectrum *literally* has an undo button, implemented with RBF. I've used it a\nhalf dozen times, and it's worked every time.\n\n> Miners serve full nodes. What is more likely, a node set that prefers\n> blocks with replaced txns, or a node set that rejects blocks with replaced\n> txns?\n\nHas anyone _ever_ implemented a node that rejects blocks containing\ndouble-spends? I don't believe the code to reject such blocks even exists. Note\nthat it should: that's a terrible idea that could lead to sever consensus\nproblems.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/fd9a372f/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Does Bitcoin require or have an honest majority or a rational one? (re rbf) (Jeremy Rubin)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Peter Todd",
                "John Carvalho",
                "Murch"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6146
        }
    },
    {
        "title": "[bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF against package limit pinning",
        "thread_messages": [
            {
                "author": "Greg Sanders",
                "date": "2022-10-18T13:52:46",
                "message_text_only": "Hello Everyone,\n\nFollowing up on the \"V3 Transaction\" discussion here\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n, I would like to elaborate a bit further on some potential follow-on work\nthat would make pinning severely constrained in many setups].\n\nV3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\nsome constraints[0]. This means that when a replacement is to be made and\npropagated, it costs the expected amount of fees to do so. This is a great\nstart. What's left in this subset of pinning is *package limit* pinning. In\nother words, a fee-paying transaction cannot enter the mempool due to the\nexisting mempool package it is being added to already being too large in\ncount or vsize.\n\nZooming into the V3 simplified scenario for sake of discussion, though this\nproblem exists in general today:\n\nV3 transactions restrict the package limit of a V3 package to one parent\nand one child. If the parent transaction includes two outputs which can be\nimmediately spent by separate parties, this allows one party to disallow a\nspend from the other. In Gloria's proposal for ln-penalty, this is worked\naround by reducing the number of anchors per commitment transaction to 1,\nand each version of the commitment transaction has a unique party's key on\nit. The honest participant can spend their version with their anchor and\npackage RBF the other commitment transaction safely.\n\nWhat if there's only one version of the commitment transaction, such as in\nother protocols like duplex payment channels, eltoo? What about multi party\npayments?\n\nIn the package RBF proposal, if the parent transaction is identical to an\nexisting transaction in the mempool, the parent will be detected and\nremoved from the package proposal. You are then left with a single V3 child\ntransaction, which is then proposed for entry into the mempool. In the case\nof another parent output already being spent, this is simply rejected,\nregardless of feerate of the new child.\n\nI have two proposed solutions, of which I strongly prefer the latter:\n\n1) Expand a carveout for \"sibling eviction\", where if the new child is\npaying \"enough\" to bump spends from the same parent, it knocks its sibling\nout of the mempool and takes the one child slot. This would solve it, but\nis a new eviction paradigm that would need to be carefully worked through.\n\n2) Ephemeral Anchors (my real policy-only proposal)\n\nEphemeral Anchors is a term which means an output is watermarked as an\noutput that MUST be spent in a V3 package. We mark this anchor by being the\nbare script `OP_TRUE` and of course make these outputs standard to relay\nand spend with empty witness data.\n\nAlso as a simplifying assumption, we require the parent transaction with\nsuch an output to be 0-fee. This makes mempool reasoning simpler in case\nthe child-spend is somehow evicted, guaranteeing the parent will be as well.\n\nImplications:\n\na) If the ephemeral anchor MUST be spent, we can allow *any* value, even\ndust, even 0, without worrying about bloating the utxo set. We relax this\npolicy for maximum smart contract flexibility and specification simplicity..\n\nb) Since this anchor MUST be spent, any spending of other outputs in the\nsame parent transaction MUST directly double-spend prior spends of the\nephemeral anchor. This causes the 1 block CSV timelock on outputs to be\nremoved in these situations. This greatly magnifies composability of smart\ncontracts, as now we can do things like safely splice directly into new\nchannels, into statechains, your custodial wallet account, your cold\nwallet, wherever, without requiring other wallets to support arbitrary\nscripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\ncompatible to begin with...\n\nc) *Anyone* can bump the transaction, without any transaction key material.\nThis is essentially achieving Jeremy's Transaction Sponsors (\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\nproposal without consensus changes. As long as someone gets a fully signed\nparent, they can execute a bump with minimal wallet tooling. If a\ntransaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n\nd) Lightning Carve-out(\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\nis superseded by this logic, as we are not restricted to two immediately\nspendable output scenarios. In its place, robust multi-party fee bumping is\npossible.\n\ne) This also benefits more traditional wallet scenarios, as change outputs\ncan no longer be pinned, and RBF/CPFP becomes robust. Payees in simple\nspends cannot pin you. Batched payouts become a lot less painful. This was\none of the motivating use cases that created the term \u201cpinning\u201d in the\nfirst place(\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\neven if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n\nOpen Question(s):\n\n\n   1.\n\n   If we allow non-zero value in ephemeral outputs, does this open up a MEV\n   we are worried about? Wallets should toss all the value directly to fees,\n   and add their own additional fees on top, otherwise miners have incentive\n   to make the smallest utxo burn transaction to claim those funds. They just\n   confirmed your parent transaction anyways, so do we care?\n   2.\n\n   SIGHASH_GROUP like constructs would allow uncommitted ephemeral anchors\n   to be added at spend time, depending on spending requirements.\n   SIGHASH_SINGLE already allows this.\n\n\n\n\nHopefully this gives people something to consider as we move forward in\nthinking about mempool design within the constraints we have today.\n\n\nGreg\n\n0: With V3 transactions where you have \"veto power\" over all the inputs in\nthat transaction. Therefore something like ANYONECANPAY is still broken. We\nneed a more complex solution, which I\u2019m punting for the sake of progress.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/76bfb957/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-19T00:33:13",
                "message_text_only": "Hi Greg,\n\nThanks for proposing forward the \"ephemeral anchors\" policy change.\n\n> In Gloria's proposal for ln-penalty, this is worked\n> around by reducing the number of anchors per commitment transaction to 1,\n> and each version of the commitment transaction has a unique party's key on\n> it. The honest participant can spend their version with their anchor and\n> package RBF the other commitment transaction safely.\n\nIIRC, here I think we also need _package relay_ in strict addition of\n_package RBF_, otherwise if your Lightning transactions are still relayed\nand accepted one by one, your version of the commitment transaction won't\nsucceed to replace the other counterparties's commitments sleeping in\nnetwork mempools. The presence of a remote anchor output on the\ncounterparty commitment still offers an ability to fee-bump, albeit in\npractice more a lucky shot as you might have partitioned network mempools\nbetween your local commitment and the remote commitment disputing the spend\nof the same funding UTXO.\n\n> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n> out of the mempool and takes the one child slot. This would solve it, but\n> is a new eviction paradigm that would need to be carefully worked through.\n\nNote, I wonder about the robustness of such a \"sibling eviction\" mechanism\nin the context of multi-party construction. E.g, a batching payout, where\nthe participants are competing to each other in a blind way, as they do\nwant their CPFPs paying back to them to confirm first, enforcing their\nindividual liquidity preferences. I would think it might artificially lead\nthe participants to overbid far beyond the top mempool block fees.\n\n>  If we allow non-zero value in ephemeral outputs, does this open up a MEV\n>  we are worried about? Wallets should toss all the value directly to fees,\n>  and add their own additional fees on top, otherwise miners have incentive\n>  to make the smallest utxo burn transaction to claim those funds. They\njust\n>  confirmed your parent transaction anyways, so do we care?\n\nIf we allow non-zero value in ephemeral outputs, I think we're slightly\nmodifying the incentives games of the channels counterparties, in the sense\nif you have a link Alice-Bob, Bob could circular loop a bunch of dust\noffered HTLC deduced from Alice balance and committed as fees in the\nephemeral output value, then break the channel on-chain to pocket in the\ntrimmed value sum (in the limit of your Lightning implementation dust\nexposure). Note, this is already possible today if your counterparty is a\nminer however iiuc the proposal, here we're lowering the bar.\n\n>  SIGHASH_GROUP like constructs would allow uncommitted ephemeral anchors\n>  to be added at spend time, depending on spending requirements.\n>  SIGHASH_SINGLE already allows this.\n\nNote, with SIGHASH_GROUP, you're still allowed to aggregate in a single\nbundle multiple ln-penalty commitments or eltoo settlement transactions,\nwith only one fee-bumping output. It's a cool space performance trick, but\na) I think this is still more a whiteboard idea than a sound proposal and\nb) sounds more a long-term, low-hanging fruit optimization of blockspace\nconsumption.\n\nBest,\nAntoine\n\nLe mar. 18 oct. 2022 \u00e0 09:53, Greg Sanders via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hello Everyone,\n>\n> Following up on the \"V3 Transaction\" discussion here\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n> , I would like to elaborate a bit further on some potential follow-on work\n> that would make pinning severely constrained in many setups].\n>\n> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n> some constraints[0]. This means that when a replacement is to be made and\n> propagated, it costs the expected amount of fees to do so. This is a great\n> start. What's left in this subset of pinning is *package limit* pinning. In\n> other words, a fee-paying transaction cannot enter the mempool due to the\n> existing mempool package it is being added to already being too large in\n> count or vsize.\n>\n> Zooming into the V3 simplified scenario for sake of discussion, though\n> this problem exists in general today:\n>\n> V3 transactions restrict the package limit of a V3 package to one parent\n> and one child. If the parent transaction includes two outputs which can be\n> immediately spent by separate parties, this allows one party to disallow a\n> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n> around by reducing the number of anchors per commitment transaction to 1,\n> and each version of the commitment transaction has a unique party's key on\n> it. The honest participant can spend their version with their anchor and\n> package RBF the other commitment transaction safely.\n>\n> What if there's only one version of the commitment transaction, such as in\n> other protocols like duplex payment channels, eltoo? What about multi party\n> payments?\n>\n> In the package RBF proposal, if the parent transaction is identical to an\n> existing transaction in the mempool, the parent will be detected and\n> removed from the package proposal. You are then left with a single V3 child\n> transaction, which is then proposed for entry into the mempool. In the case\n> of another parent output already being spent, this is simply rejected,\n> regardless of feerate of the new child.\n>\n> I have two proposed solutions, of which I strongly prefer the latter:\n>\n> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n> out of the mempool and takes the one child slot. This would solve it, but\n> is a new eviction paradigm that would need to be carefully worked through.\n>\n> 2) Ephemeral Anchors (my real policy-only proposal)\n>\n> Ephemeral Anchors is a term which means an output is watermarked as an\n> output that MUST be spent in a V3 package. We mark this anchor by being the\n> bare script `OP_TRUE` and of course make these outputs standard to relay\n> and spend with empty witness data.\n>\n> Also as a simplifying assumption, we require the parent transaction with\n> such an output to be 0-fee. This makes mempool reasoning simpler in case\n> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>\n> Implications:\n>\n> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n> dust, even 0, without worrying about bloating the utxo set. We relax this\n> policy for maximum smart contract flexibility and specification simplicity..\n>\n> b) Since this anchor MUST be spent, any spending of other outputs in the\n> same parent transaction MUST directly double-spend prior spends of the\n> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n> removed in these situations. This greatly magnifies composability of smart\n> contracts, as now we can do things like safely splice directly into new\n> channels, into statechains, your custodial wallet account, your cold\n> wallet, wherever, without requiring other wallets to support arbitrary\n> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n> compatible to begin with...\n>\n> c) *Anyone* can bump the transaction, without any transaction key\n> material. This is essentially achieving Jeremy's Transaction Sponsors (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n> proposal without consensus changes. As long as someone gets a fully signed\n> parent, they can execute a bump with minimal wallet tooling. If a\n> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>\n> d) Lightning Carve-out(\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n> is superseded by this logic, as we are not restricted to two immediately\n> spendable output scenarios. In its place, robust multi-party fee bumping is\n> possible.\n>\n> e) This also benefits more traditional wallet scenarios, as change outputs\n> can no longer be pinned, and RBF/CPFP becomes robust. Payees in simple\n> spends cannot pin you. Batched payouts become a lot less painful. This was\n> one of the motivating use cases that created the term \u201cpinning\u201d in the\n> first place(\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>\n> Open Question(s):\n>\n>\n>    1.\n>\n>    If we allow non-zero value in ephemeral outputs, does this open up a\n>    MEV we are worried about? Wallets should toss all the value directly to\n>    fees, and add their own additional fees on top, otherwise miners have\n>    incentive to make the smallest utxo burn transaction to claim those funds.\n>    They just confirmed your parent transaction anyways, so do we care?\n>    2.\n>\n>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>    anchors to be added at spend time, depending on spending requirements.\n>    SIGHASH_SINGLE already allows this.\n>\n>\n>\n>\n> Hopefully this gives people something to consider as we move forward in\n> thinking about mempool design within the constraints we have today.\n>\n>\n> Greg\n>\n> 0: With V3 transactions where you have \"veto power\" over all the inputs in\n> that transaction. Therefore something like ANYONECANPAY is still broken. We\n> need a more complex solution, which I\u2019m punting for the sake of progress.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/c9493266/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-19T13:22:08",
                "message_text_only": "> IIRC, here I think we also need _package relay_ in strict addition of\n_package RBF_,\n\nYes, sorry if that wasn't clear. Package Relay -> Package RBF -> V3 ->\nEphemeral Anchors\n\n> If we allow non-zero value in ephemeral outputs, I think we're slightly\nmodifying the incentives games of the channels counterparties, in the sense\nif you have a link Alice-Bob, Bob could circular loop a bunch of dust\noffered HTLC deduced from Alice balance and committed as fees in the\nephemeral output value, then break the channel on-chain to pocket in the\ntrimmed value sum (in the limit of your Lightning implementation dust\nexposure). Note, this is already possible today if your counterparty is a\nminer however iiuc the proposal, here we're lowering the bar.\n\nMaybe the 0-fee parent requirement creates too much downstream protocol\ncomplexity. Perhaps each node software can choose its own strategy for\nremoving the parent when the child is evicted. For example, a node software\ncould completely ignore the parent tx fee in the presence of an ephemeral\nanchor. In other words, the trimmed value can go to fee, but the fee is\neffectively ignored from mempool inclusion standpoint.\n\nWe already toss things with dust even though it's \"incentive incompatible\";\nit's no worse?\n\nAs an entertaining aside, h/t to AJ who found this old thread that proposed\nan OP_TRUE, 0-fee parent idea, but 4 years behind in our understanding of\npinning. All the usual suspects chiming in:\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-May/015931.html\n\nGreat minds, etc.\n\nGreg\n\nOn Tue, Oct 18, 2022 at 8:33 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Greg,\n>\n> Thanks for proposing forward the \"ephemeral anchors\" policy change.\n>\n> > In Gloria's proposal for ln-penalty, this is worked\n> > around by reducing the number of anchors per commitment transaction to 1,\n> > and each version of the commitment transaction has a unique party's key\n> on\n> > it. The honest participant can spend their version with their anchor and\n> > package RBF the other commitment transaction safely.\n>\n> IIRC, here I think we also need _package relay_ in strict addition of\n> _package RBF_, otherwise if your Lightning transactions are still relayed\n> and accepted one by one, your version of the commitment transaction won't\n> succeed to replace the other counterparties's commitments sleeping in\n> network mempools. The presence of a remote anchor output on the\n> counterparty commitment still offers an ability to fee-bump, albeit in\n> practice more a lucky shot as you might have partitioned network mempools\n> between your local commitment and the remote commitment disputing the spend\n> of the same funding UTXO.\n>\n> > 1) Expand a carveout for \"sibling eviction\", where if the new child is\n> > paying \"enough\" to bump spends from the same parent, it knocks its\n> sibling\n> > out of the mempool and takes the one child slot. This would solve it, but\n> > is a new eviction paradigm that would need to be carefully worked\n> through.\n>\n> Note, I wonder about the robustness of such a \"sibling eviction\" mechanism\n> in the context of multi-party construction. E.g, a batching payout, where\n> the participants are competing to each other in a blind way, as they do\n> want their CPFPs paying back to them to confirm first, enforcing their\n> individual liquidity preferences. I would think it might artificially lead\n> the participants to overbid far beyond the top mempool block fees.\n>\n> >  If we allow non-zero value in ephemeral outputs, does this open up a MEV\n> >  we are worried about? Wallets should toss all the value directly to\n> fees,\n> >  and add their own additional fees on top, otherwise miners have\n> incentive\n> >  to make the smallest utxo burn transaction to claim those funds. They\n> just\n> >  confirmed your parent transaction anyways, so do we care?\n>\n> If we allow non-zero value in ephemeral outputs, I think we're slightly\n> modifying the incentives games of the channels counterparties, in the sense\n> if you have a link Alice-Bob, Bob could circular loop a bunch of dust\n> offered HTLC deduced from Alice balance and committed as fees in the\n> ephemeral output value, then break the channel on-chain to pocket in the\n> trimmed value sum (in the limit of your Lightning implementation dust\n> exposure). Note, this is already possible today if your counterparty is a\n> miner however iiuc the proposal, here we're lowering the bar.\n>\n> >  SIGHASH_GROUP like constructs would allow uncommitted ephemeral anchors\n> >  to be added at spend time, depending on spending requirements.\n> >  SIGHASH_SINGLE already allows this.\n>\n> Note, with SIGHASH_GROUP, you're still allowed to aggregate in a single\n> bundle multiple ln-penalty commitments or eltoo settlement transactions,\n> with only one fee-bumping output. It's a cool space performance trick, but\n> a) I think this is still more a whiteboard idea than a sound proposal and\n> b) sounds more a long-term, low-hanging fruit optimization of blockspace\n> consumption.\n>\n> Best,\n> Antoine\n>\n> Le mar. 18 oct. 2022 \u00e0 09:53, Greg Sanders via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Hello Everyone,\n>>\n>> Following up on the \"V3 Transaction\" discussion here\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>> , I would like to elaborate a bit further on some potential follow-on work\n>> that would make pinning severely constrained in many setups].\n>>\n>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n>> some constraints[0]. This means that when a replacement is to be made and\n>> propagated, it costs the expected amount of fees to do so. This is a great\n>> start. What's left in this subset of pinning is *package limit* pinning. In\n>> other words, a fee-paying transaction cannot enter the mempool due to the\n>> existing mempool package it is being added to already being too large in\n>> count or vsize.\n>>\n>> Zooming into the V3 simplified scenario for sake of discussion, though\n>> this problem exists in general today:\n>>\n>> V3 transactions restrict the package limit of a V3 package to one parent\n>> and one child. If the parent transaction includes two outputs which can be\n>> immediately spent by separate parties, this allows one party to disallow a\n>> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n>> around by reducing the number of anchors per commitment transaction to 1,\n>> and each version of the commitment transaction has a unique party's key on\n>> it. The honest participant can spend their version with their anchor and\n>> package RBF the other commitment transaction safely.\n>>\n>> What if there's only one version of the commitment transaction, such as\n>> in other protocols like duplex payment channels, eltoo? What about multi\n>> party payments?\n>>\n>> In the package RBF proposal, if the parent transaction is identical to an\n>> existing transaction in the mempool, the parent will be detected and\n>> removed from the package proposal. You are then left with a single V3 child\n>> transaction, which is then proposed for entry into the mempool. In the case\n>> of another parent output already being spent, this is simply rejected,\n>> regardless of feerate of the new child.\n>>\n>> I have two proposed solutions, of which I strongly prefer the latter:\n>>\n>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>> out of the mempool and takes the one child slot. This would solve it, but\n>> is a new eviction paradigm that would need to be carefully worked through.\n>>\n>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>\n>> Ephemeral Anchors is a term which means an output is watermarked as an\n>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>> and spend with empty witness data.\n>>\n>> Also as a simplifying assumption, we require the parent transaction with\n>> such an output to be 0-fee. This makes mempool reasoning simpler in case\n>> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>>\n>> Implications:\n>>\n>> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n>> dust, even 0, without worrying about bloating the utxo set. We relax this\n>> policy for maximum smart contract flexibility and specification simplicity..\n>>\n>> b) Since this anchor MUST be spent, any spending of other outputs in the\n>> same parent transaction MUST directly double-spend prior spends of the\n>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>> removed in these situations. This greatly magnifies composability of smart\n>> contracts, as now we can do things like safely splice directly into new\n>> channels, into statechains, your custodial wallet account, your cold\n>> wallet, wherever, without requiring other wallets to support arbitrary\n>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>> compatible to begin with...\n>>\n>> c) *Anyone* can bump the transaction, without any transaction key\n>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>> proposal without consensus changes. As long as someone gets a fully signed\n>> parent, they can execute a bump with minimal wallet tooling. If a\n>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>\n>> d) Lightning Carve-out(\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>> is superseded by this logic, as we are not restricted to two immediately\n>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>> possible.\n>>\n>> e) This also benefits more traditional wallet scenarios, as change\n>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>> the first place(\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>\n>> Open Question(s):\n>>\n>>\n>>    1.\n>>\n>>    If we allow non-zero value in ephemeral outputs, does this open up a\n>>    MEV we are worried about? Wallets should toss all the value directly to\n>>    fees, and add their own additional fees on top, otherwise miners have\n>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>    They just confirmed your parent transaction anyways, so do we care?\n>>    2.\n>>\n>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>    anchors to be added at spend time, depending on spending requirements.\n>>    SIGHASH_SINGLE already allows this.\n>>\n>>\n>>\n>>\n>> Hopefully this gives people something to consider as we move forward in\n>> thinking about mempool design within the constraints we have today.\n>>\n>>\n>> Greg\n>>\n>> 0: With V3 transactions where you have \"veto power\" over all the inputs\n>> in that transaction. Therefore something like ANYONECANPAY is still broken.\n>> We need a more complex solution, which I\u2019m punting for the sake of progress.\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/fdad0207/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Ephemeral Anchors: Fixing V3 Package RBF against package limit pinning",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard",
                "Greg Sanders"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 27671
        }
    },
    {
        "title": "[bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning",
        "thread_messages": [
            {
                "author": "Arik Sosman",
                "date": "2022-10-18T15:33:32",
                "message_text_only": "Hi Greg,\n\nThank you very much for sharing your proposal!\n\nI think there's one thing about the second part of your proposal that I'm missing. Specifically, assuming the scenario of a v3 transaction with three outputs, A, B, and the ephemeral anchor OP_TRUE. If a child transaction spends A and OP_TRUE, does that effectively mark output B as unspendable once the child gets confirmed? If so, isn't the implication therefore that to safely spend a transaction with an ephemeral anchor, all outputs must be spent? Thanks!\n\nBest,\nArik\n\nOn Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n> Hello Everyone,\n> \n> \n> Following up on the \"V3 Transaction\" discussion here https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html , I would like to elaborate a bit further on some potential follow-on work that would make pinning severely constrained in many setups].\n> \n> \n> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under some constraints[0]. This means that when a replacement is to be made and propagated, it costs the expected amount of fees to do so. This is a great start. What's left in this subset of pinning is *package limit* pinning. In other words, a fee-paying transaction cannot enter the mempool due to the existing mempool package it is being added to already being too large in count or vsize.\n> \n> \n> Zooming into the V3 simplified scenario for sake of discussion, though this problem exists in general today:\n> \n> \n> V3 transactions restrict the package limit of a V3 package to one parent and one child. If the parent transaction includes two outputs which can be immediately spent by separate parties, this allows one party to disallow a spend from the other. In Gloria's proposal for ln-penalty, this is worked around by reducing the number of anchors per commitment transaction to 1, and each version of the commitment transaction has a unique party's key on it. The honest participant can spend their version with their anchor and package RBF the other commitment transaction safely.\n> \n> \n> What if there's only one version of the commitment transaction, such as in other protocols like duplex payment channels, eltoo? What about multi party payments?\n> \n> \n> In the package RBF proposal, if the parent transaction is identical to an existing transaction in the mempool, the parent will be detected and removed from the package proposal. You are then left with a single V3 child transaction, which is then proposed for entry into the mempool. In the case of another parent output already being spent, this is simply rejected, regardless of feerate of the new child.\n> \n> \n> I have two proposed solutions, of which I strongly prefer the latter:\n> \n> \n> 1) Expand a carveout for \"sibling eviction\", where if the new child is paying \"enough\" to bump spends from the same parent, it knocks its sibling out of the mempool and takes the one child slot. This would solve it, but is a new eviction paradigm that would need to be carefully worked through.\n> \n> \n> 2) Ephemeral Anchors (my real policy-only proposal)\n> \n> \n> Ephemeral Anchors is a term which means an output is watermarked as an output that MUST be spent in a V3 package. We mark this anchor by being the bare script `OP_TRUE` and of course make these outputs standard to relay and spend with empty witness data.\n> \n> \n> Also as a simplifying assumption, we require the parent transaction with such an output to be 0-fee. This makes mempool reasoning simpler in case the child-spend is somehow evicted, guaranteeing the parent will be as well.\n> \n> \n> Implications:\n> \n> \n> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even dust, even 0, without worrying about bloating the utxo set. We relax this policy for maximum smart contract flexibility and specification simplicity..\n> \n> \n> b) Since this anchor MUST be spent, any spending of other outputs in the same parent transaction MUST directly double-spend prior spends of the ephemeral anchor. This causes the 1 block CSV timelock on outputs to be removed in these situations. This greatly magnifies composability of smart contracts, as now we can do things like safely splice directly into new channels, into statechains, your custodial wallet account, your cold wallet, wherever, without requiring other wallets to support arbitrary scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript compatible to begin with...\n> \n> \n> c) *Anyone* can bump the transaction, without any transaction key material. This is essentially achieving Jeremy's Transaction Sponsors (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html) proposal without consensus changes. As long as someone gets a fully signed parent, they can execute a bump with minimal wallet tooling. If a transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n> \n> \n> d) Lightning Carve-out(https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)  is superseded by this logic, as we are not restricted to two immediately spendable output scenarios. In its place, robust multi-party fee bumping is possible.\n> \n> \n> e) This also benefits more traditional wallet scenarios, as change outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in simple spends cannot pin you. Batched payouts become a lot less painful. This was one of the motivating use cases that created the term \u201cpinning\u201d in the first place(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html), even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n> \n> \n> Open Question(s):\n> \n> \n>  1. If we allow non-zero value in ephemeral outputs, does this open up a MEV we are worried about? Wallets should toss all the value directly to fees, and add their own additional fees on top, otherwise miners have incentive to make the smallest utxo burn transaction to claim those funds. They just confirmed your parent transaction anyways, so do we care?\n> \n>  2. SIGHASH_GROUP like constructs would allow uncommitted ephemeral anchors to be added at spend time, depending on spending requirements. SIGHASH_SINGLE already allows this.\n> \n> \n> \n> \n> Hopefully this gives people something to consider as we move forward in thinking about mempool design within the constraints we have today.\n> \n> \n> \n> Greg\n> \n> \n> 0: With V3 transactions where you have \"veto power\" over all the inputs in that transaction. Therefore something like ANYONECANPAY is still broken. We need a more complex solution, which I\u2019m punting for the sake of progress.\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> \n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/ea08e7c8/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-18T15:51:30",
                "message_text_only": "> does that effectively mark output B as unspendable once the child gets\nconfirmed?\n\nNot at all. It's a normal spend like before, since the parent has been\nconfirmed. It's completely unrestricted, not being bound to any\nV3/ephemeral anchor restrictions on size, version, etc.\n\nOn Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Greg,\n>\n> Thank you very much for sharing your proposal!\n>\n> I think there's one thing about the second part of your proposal that I'm\n> missing. Specifically, assuming the scenario of a v3 transaction with three\n> outputs, A, B, and the ephemeral anchor OP_TRUE. If a child transaction\n> spends A and OP_TRUE, does that effectively mark output B as unspendable\n> once the child gets confirmed? If so, isn't the implication therefore that\n> to safely spend a transaction with an ephemeral anchor, all outputs must be\n> spent? Thanks!\n>\n> Best,\n> Arik\n>\n> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>\n> Hello Everyone,\n>\n> Following up on the \"V3 Transaction\" discussion here\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n> , I would like to elaborate a bit further on some potential follow-on work\n> that would make pinning severely constrained in many setups].\n>\n> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n> some constraints[0]. This means that when a replacement is to be made and\n> propagated, it costs the expected amount of fees to do so. This is a great\n> start. What's left in this subset of pinning is *package limit* pinning. In\n> other words, a fee-paying transaction cannot enter the mempool due to the\n> existing mempool package it is being added to already being too large in\n> count or vsize.\n>\n> Zooming into the V3 simplified scenario for sake of discussion, though\n> this problem exists in general today:\n>\n> V3 transactions restrict the package limit of a V3 package to one parent\n> and one child. If the parent transaction includes two outputs which can be\n> immediately spent by separate parties, this allows one party to disallow a\n> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n> around by reducing the number of anchors per commitment transaction to 1,\n> and each version of the commitment transaction has a unique party's key on\n> it. The honest participant can spend their version with their anchor and\n> package RBF the other commitment transaction safely.\n>\n> What if there's only one version of the commitment transaction, such as in\n> other protocols like duplex payment channels, eltoo? What about multi party\n> payments?\n>\n> In the package RBF proposal, if the parent transaction is identical to an\n> existing transaction in the mempool, the parent will be detected and\n> removed from the package proposal. You are then left with a single V3 child\n> transaction, which is then proposed for entry into the mempool. In the case\n> of another parent output already being spent, this is simply rejected,\n> regardless of feerate of the new child.\n>\n> I have two proposed solutions, of which I strongly prefer the latter:\n>\n> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n> out of the mempool and takes the one child slot. This would solve it, but\n> is a new eviction paradigm that would need to be carefully worked through.\n>\n> 2) Ephemeral Anchors (my real policy-only proposal)\n>\n> Ephemeral Anchors is a term which means an output is watermarked as an\n> output that MUST be spent in a V3 package. We mark this anchor by being the\n> bare script `OP_TRUE` and of course make these outputs standard to relay\n> and spend with empty witness data.\n>\n> Also as a simplifying assumption, we require the parent transaction with\n> such an output to be 0-fee. This makes mempool reasoning simpler in case\n> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>\n> Implications:\n>\n> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n> dust, even 0, without worrying about bloating the utxo set. We relax this\n> policy for maximum smart contract flexibility and specification simplicity..\n>\n> b) Since this anchor MUST be spent, any spending of other outputs in the\n> same parent transaction MUST directly double-spend prior spends of the\n> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n> removed in these situations. This greatly magnifies composability of smart\n> contracts, as now we can do things like safely splice directly into new\n> channels, into statechains, your custodial wallet account, your cold\n> wallet, wherever, without requiring other wallets to support arbitrary\n> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n> compatible to begin with...\n>\n> c) *Anyone* can bump the transaction, without any transaction key\n> material. This is essentially achieving Jeremy's Transaction Sponsors (\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n> proposal without consensus changes. As long as someone gets a fully signed\n> parent, they can execute a bump with minimal wallet tooling. If a\n> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>\n> d) Lightning Carve-out(\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n> is superseded by this logic, as we are not restricted to two immediately\n> spendable output scenarios. In its place, robust multi-party fee bumping is\n> possible.\n>\n> e) This also benefits more traditional wallet scenarios, as change outputs\n> can no longer be pinned, and RBF/CPFP becomes robust. Payees in simple\n> spends cannot pin you. Batched payouts become a lot less painful. This was\n> one of the motivating use cases that created the term \u201cpinning\u201d in the\n> first place(\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>\n> Open Question(s):\n>\n>\n>    1.\n>\n>    If we allow non-zero value in ephemeral outputs, does this open up a\n>    MEV we are worried about? Wallets should toss all the value directly to\n>    fees, and add their own additional fees on top, otherwise miners have\n>    incentive to make the smallest utxo burn transaction to claim those funds.\n>    They just confirmed your parent transaction anyways, so do we care?\n>    2.\n>\n>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>    anchors to be added at spend time, depending on spending requirements.\n>    SIGHASH_SINGLE already allows this.\n>\n>\n>\n>\n> Hopefully this gives people something to consider as we move forward in\n> thinking about mempool design within the constraints we have today.\n>\n>\n> Greg\n>\n> 0: With V3 transactions where you have \"veto power\" over all the inputs in\n> that transaction. Therefore something like ANYONECANPAY is still broken. We\n> need a more complex solution, which I\u2019m punting for the sake of progress.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/37eafd3d/attachment-0001.html>"
            },
            {
                "author": "Jeremy Rubin",
                "date": "2022-10-18T16:41:19",
                "message_text_only": "Excellent proposal and I agree it does capture much of the spirit of\nsponsors w.r.t. how they might be used for V3 protocols.\n\nThe only drawbacks I see is they don't work for lower tx version contracts,\nso there's still something to be desired there, and that the requirement to\nsweep the output must be incentive compatible for the miner, or else they\nwon't enforce it (pass the buck onto the future bitcoiners). The Ephemeral\nUTXO concept can be a consensus rule (see\nhttps://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate UTXO\")\nwe add later on in lieu of managing them by incentive, so maybe it's a\ncleanup one can punt.\n\nOne question I have is if V3 is designed for lightning, and this is\ndesigned for lightning, is there any sense in requiring these outputs for\nv3? That might help with e.g. anonymity set, as well as potentially keep\nthe v3 surface smaller.\n\nOn Tue, Oct 18, 2022 at 11:51 AM Greg Sanders via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > does that effectively mark output B as unspendable once the child gets\n> confirmed?\n>\n> Not at all. It's a normal spend like before, since the parent has been\n> confirmed. It's completely unrestricted, not being bound to any\n> V3/ephemeral anchor restrictions on size, version, etc.\n>\n> On Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Greg,\n>>\n>> Thank you very much for sharing your proposal!\n>>\n>> I think there's one thing about the second part of your proposal that I'm\n>> missing. Specifically, assuming the scenario of a v3 transaction with three\n>> outputs, A, B, and the ephemeral anchor OP_TRUE. If a child transaction\n>> spends A and OP_TRUE, does that effectively mark output B as unspendable\n>> once the child gets confirmed? If so, isn't the implication therefore that\n>> to safely spend a transaction with an ephemeral anchor, all outputs must be\n>> spent? Thanks!\n>>\n>> Best,\n>> Arik\n>>\n>> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>>\n>> Hello Everyone,\n>>\n>> Following up on the \"V3 Transaction\" discussion here\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>> , I would like to elaborate a bit further on some potential follow-on work\n>> that would make pinning severely constrained in many setups].\n>>\n>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n>> some constraints[0]. This means that when a replacement is to be made and\n>> propagated, it costs the expected amount of fees to do so. This is a great\n>> start. What's left in this subset of pinning is *package limit* pinning. In\n>> other words, a fee-paying transaction cannot enter the mempool due to the\n>> existing mempool package it is being added to already being too large in\n>> count or vsize.\n>>\n>> Zooming into the V3 simplified scenario for sake of discussion, though\n>> this problem exists in general today:\n>>\n>> V3 transactions restrict the package limit of a V3 package to one parent\n>> and one child. If the parent transaction includes two outputs which can be\n>> immediately spent by separate parties, this allows one party to disallow a\n>> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n>> around by reducing the number of anchors per commitment transaction to 1,\n>> and each version of the commitment transaction has a unique party's key on\n>> it. The honest participant can spend their version with their anchor and\n>> package RBF the other commitment transaction safely.\n>>\n>> What if there's only one version of the commitment transaction, such as\n>> in other protocols like duplex payment channels, eltoo? What about multi\n>> party payments?\n>>\n>> In the package RBF proposal, if the parent transaction is identical to an\n>> existing transaction in the mempool, the parent will be detected and\n>> removed from the package proposal. You are then left with a single V3 child\n>> transaction, which is then proposed for entry into the mempool. In the case\n>> of another parent output already being spent, this is simply rejected,\n>> regardless of feerate of the new child.\n>>\n>> I have two proposed solutions, of which I strongly prefer the latter:\n>>\n>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>> out of the mempool and takes the one child slot. This would solve it, but\n>> is a new eviction paradigm that would need to be carefully worked through.\n>>\n>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>\n>> Ephemeral Anchors is a term which means an output is watermarked as an\n>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>> and spend with empty witness data.\n>>\n>> Also as a simplifying assumption, we require the parent transaction with\n>> such an output to be 0-fee. This makes mempool reasoning simpler in case\n>> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>>\n>> Implications:\n>>\n>> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n>> dust, even 0, without worrying about bloating the utxo set. We relax this\n>> policy for maximum smart contract flexibility and specification simplicity..\n>>\n>> b) Since this anchor MUST be spent, any spending of other outputs in the\n>> same parent transaction MUST directly double-spend prior spends of the\n>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>> removed in these situations. This greatly magnifies composability of smart\n>> contracts, as now we can do things like safely splice directly into new\n>> channels, into statechains, your custodial wallet account, your cold\n>> wallet, wherever, without requiring other wallets to support arbitrary\n>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>> compatible to begin with...\n>>\n>> c) *Anyone* can bump the transaction, without any transaction key\n>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>> proposal without consensus changes. As long as someone gets a fully signed\n>> parent, they can execute a bump with minimal wallet tooling. If a\n>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>\n>> d) Lightning Carve-out(\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>> is superseded by this logic, as we are not restricted to two immediately\n>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>> possible.\n>>\n>> e) This also benefits more traditional wallet scenarios, as change\n>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>> the first place(\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>\n>> Open Question(s):\n>>\n>>\n>>    1.\n>>\n>>    If we allow non-zero value in ephemeral outputs, does this open up a\n>>    MEV we are worried about? Wallets should toss all the value directly to\n>>    fees, and add their own additional fees on top, otherwise miners have\n>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>    They just confirmed your parent transaction anyways, so do we care?\n>>    2.\n>>\n>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>    anchors to be added at spend time, depending on spending requirements.\n>>    SIGHASH_SINGLE already allows this.\n>>\n>>\n>>\n>>\n>> Hopefully this gives people something to consider as we move forward in\n>> thinking about mempool design within the constraints we have today.\n>>\n>>\n>> Greg\n>>\n>> 0: With V3 transactions where you have \"veto power\" over all the inputs\n>> in that transaction. Therefore something like ANYONECANPAY is still broken.\n>> We need a more complex solution, which I\u2019m punting for the sake of progress.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/dc64cf8c/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-18T18:18:45",
                "message_text_only": "> (see https://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate\nUTXO\")\n\nI think I remember you trying to explain this to me a long time ago. Thanks\nfor the callback!\n\n> One question I have is if V3 is designed for lightning, and this is\ndesigned for lightning, is there any sense in requiring these outputs for\nv3? That might help with e.g. anonymity set, as well as potentially keep\nthe v3 surface smaller.\n\nThe fingerprinting angle is yet another thing to consider. There are\ndefinitely uses of V3 that do not require ephemeral anchors, and you can\nsave a healthy amount of bytes not requiring them. I think in the cases\nwhere RBF of the parent is possible, at least.\n\nf.e., I think V3 alone makes splicing robust even in the presence of\nexternal inputs, since the commitment tx(s) can (package) RBF the splice at\nany point. V3 may have enough value-add by itself where the additional\nbytes and inability to opt out of \"transaction sponsor\" style bumps may be\nundesirable.\n\nLastly this would tie deployments of these improvements together. Something\nto consider.\n\nCheers,\nGreg\n\nOn Tue, Oct 18, 2022 at 12:41 PM Jeremy Rubin <j at rubin.io> wrote:\n\n> Excellent proposal and I agree it does capture much of the spirit of\n> sponsors w.r.t. how they might be used for V3 protocols.\n>\n> The only drawbacks I see is they don't work for lower tx version\n> contracts, so there's still something to be desired there, and that the\n> requirement to sweep the output must be incentive compatible for the miner,\n> or else they won't enforce it (pass the buck onto the future bitcoiners).\n> The Ephemeral UTXO concept can be a consensus rule (see\n> https://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate UTXO\")\n> we add later on in lieu of managing them by incentive, so maybe it's a\n> cleanup one can punt.\n>\n> One question I have is if V3 is designed for lightning, and this is\n> designed for lightning, is there any sense in requiring these outputs for\n> v3? That might help with e.g. anonymity set, as well as potentially keep\n> the v3 surface smaller.\n>\n> On Tue, Oct 18, 2022 at 11:51 AM Greg Sanders via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> > does that effectively mark output B as unspendable once the child gets\n>> confirmed?\n>>\n>> Not at all. It's a normal spend like before, since the parent has been\n>> confirmed. It's completely unrestricted, not being bound to any\n>> V3/ephemeral anchor restrictions on size, version, etc.\n>>\n>> On Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Greg,\n>>>\n>>> Thank you very much for sharing your proposal!\n>>>\n>>> I think there's one thing about the second part of your proposal that\n>>> I'm missing. Specifically, assuming the scenario of a v3 transaction with\n>>> three outputs, A, B, and the ephemeral anchor OP_TRUE. If a child\n>>> transaction spends A and OP_TRUE, does that effectively mark output B as\n>>> unspendable once the child gets confirmed? If so, isn't the implication\n>>> therefore that to safely spend a transaction with an ephemeral anchor, all\n>>> outputs must be spent? Thanks!\n>>>\n>>> Best,\n>>> Arik\n>>>\n>>> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>>>\n>>> Hello Everyone,\n>>>\n>>> Following up on the \"V3 Transaction\" discussion here\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>>> , I would like to elaborate a bit further on some potential follow-on work\n>>> that would make pinning severely constrained in many setups].\n>>>\n>>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n>>> some constraints[0]. This means that when a replacement is to be made and\n>>> propagated, it costs the expected amount of fees to do so. This is a great\n>>> start. What's left in this subset of pinning is *package limit* pinning. In\n>>> other words, a fee-paying transaction cannot enter the mempool due to the\n>>> existing mempool package it is being added to already being too large in\n>>> count or vsize.\n>>>\n>>> Zooming into the V3 simplified scenario for sake of discussion, though\n>>> this problem exists in general today:\n>>>\n>>> V3 transactions restrict the package limit of a V3 package to one parent\n>>> and one child. If the parent transaction includes two outputs which can be\n>>> immediately spent by separate parties, this allows one party to disallow a\n>>> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n>>> around by reducing the number of anchors per commitment transaction to 1,\n>>> and each version of the commitment transaction has a unique party's key on\n>>> it. The honest participant can spend their version with their anchor and\n>>> package RBF the other commitment transaction safely.\n>>>\n>>> What if there's only one version of the commitment transaction, such as\n>>> in other protocols like duplex payment channels, eltoo? What about multi\n>>> party payments?\n>>>\n>>> In the package RBF proposal, if the parent transaction is identical to\n>>> an existing transaction in the mempool, the parent will be detected and\n>>> removed from the package proposal. You are then left with a single V3 child\n>>> transaction, which is then proposed for entry into the mempool. In the case\n>>> of another parent output already being spent, this is simply rejected,\n>>> regardless of feerate of the new child.\n>>>\n>>> I have two proposed solutions, of which I strongly prefer the latter:\n>>>\n>>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>>> out of the mempool and takes the one child slot. This would solve it, but\n>>> is a new eviction paradigm that would need to be carefully worked through.\n>>>\n>>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>>\n>>> Ephemeral Anchors is a term which means an output is watermarked as an\n>>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>>> and spend with empty witness data.\n>>>\n>>> Also as a simplifying assumption, we require the parent transaction with\n>>> such an output to be 0-fee. This makes mempool reasoning simpler in case\n>>> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>>>\n>>> Implications:\n>>>\n>>> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n>>> dust, even 0, without worrying about bloating the utxo set. We relax this\n>>> policy for maximum smart contract flexibility and specification simplicity..\n>>>\n>>> b) Since this anchor MUST be spent, any spending of other outputs in the\n>>> same parent transaction MUST directly double-spend prior spends of the\n>>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>>> removed in these situations. This greatly magnifies composability of smart\n>>> contracts, as now we can do things like safely splice directly into new\n>>> channels, into statechains, your custodial wallet account, your cold\n>>> wallet, wherever, without requiring other wallets to support arbitrary\n>>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>>> compatible to begin with...\n>>>\n>>> c) *Anyone* can bump the transaction, without any transaction key\n>>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>>> proposal without consensus changes. As long as someone gets a fully signed\n>>> parent, they can execute a bump with minimal wallet tooling. If a\n>>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>>\n>>> d) Lightning Carve-out(\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>>> is superseded by this logic, as we are not restricted to two immediately\n>>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>>> possible.\n>>>\n>>> e) This also benefits more traditional wallet scenarios, as change\n>>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>>> the first place(\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>>\n>>> Open Question(s):\n>>>\n>>>\n>>>    1.\n>>>\n>>>    If we allow non-zero value in ephemeral outputs, does this open up a\n>>>    MEV we are worried about? Wallets should toss all the value directly to\n>>>    fees, and add their own additional fees on top, otherwise miners have\n>>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>>    They just confirmed your parent transaction anyways, so do we care?\n>>>    2.\n>>>\n>>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>>    anchors to be added at spend time, depending on spending requirements.\n>>>    SIGHASH_SINGLE already allows this.\n>>>\n>>>\n>>>\n>>>\n>>> Hopefully this gives people something to consider as we move forward in\n>>> thinking about mempool design within the constraints we have today.\n>>>\n>>>\n>>> Greg\n>>>\n>>> 0: With V3 transactions where you have \"veto power\" over all the inputs\n>>> in that transaction. Therefore something like ANYONECANPAY is still broken.\n>>> We need a more complex solution, which I\u2019m punting for the sake of progress.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/97874e94/attachment-0001.html>"
            },
            {
                "author": "James O'Beirne",
                "date": "2022-10-19T15:11:57",
                "message_text_only": "I'm also very happy to see this proposal, since it gets us closer to having\na mechanism that allows the contribution to feerate in an \"unauthenticated\"\nway, which seems to be a very helpful feature for vaults and other\ncontracting protocols.\n\nOne possible advantage of the sponsors interface -- and I'm curious for\nyour input here Greg -- is that with sponsors, assuming we relaxed the \"one\nsponsor per sponsoree\" constraint, multiple uncoordinated parties can\ncollaboratively bump a tx's feerate. A simple example would be a batch\nwithdrawal from an exchange could be created with a low feerate, and then\nmultiple users with a vested interest of expedited confirmation could all\n\"chip in\" to raise the feerate with multiple sponsor transactions.\n\nHaving a single ephemeral output seems to create a situation where a single\nUTXO has to shoulder the burden of CPFPing a package. Is there some way we\ncould (possibly later) amend the ephemeral anchor interface to allow for\nthis kind of collaborative sponsoring? Could you maybe see \"chained\"\nephemeral anchors that would allow this?\n\n\nOn Tue, Oct 18, 2022 at 12:52 PM Jeremy Rubin via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Excellent proposal and I agree it does capture much of the spirit of\n> sponsors w.r.t. how they might be used for V3 protocols.\n>\n> The only drawbacks I see is they don't work for lower tx version\n> contracts, so there's still something to be desired there, and that the\n> requirement to sweep the output must be incentive compatible for the miner,\n> or else they won't enforce it (pass the buck onto the future bitcoiners).\n> The Ephemeral UTXO concept can be a consensus rule (see\n> https://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate UTXO\")\n> we add later on in lieu of managing them by incentive, so maybe it's a\n> cleanup one can punt.\n>\n> One question I have is if V3 is designed for lightning, and this is\n> designed for lightning, is there any sense in requiring these outputs for\n> v3? That might help with e.g. anonymity set, as well as potentially keep\n> the v3 surface smaller.\n>\n> On Tue, Oct 18, 2022 at 11:51 AM Greg Sanders via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> > does that effectively mark output B as unspendable once the child gets\n>> confirmed?\n>>\n>> Not at all. It's a normal spend like before, since the parent has been\n>> confirmed. It's completely unrestricted, not being bound to any\n>> V3/ephemeral anchor restrictions on size, version, etc.\n>>\n>> On Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hi Greg,\n>>>\n>>> Thank you very much for sharing your proposal!\n>>>\n>>> I think there's one thing about the second part of your proposal that\n>>> I'm missing. Specifically, assuming the scenario of a v3 transaction with\n>>> three outputs, A, B, and the ephemeral anchor OP_TRUE. If a child\n>>> transaction spends A and OP_TRUE, does that effectively mark output B as\n>>> unspendable once the child gets confirmed? If so, isn't the implication\n>>> therefore that to safely spend a transaction with an ephemeral anchor, all\n>>> outputs must be spent? Thanks!\n>>>\n>>> Best,\n>>> Arik\n>>>\n>>> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>>>\n>>> Hello Everyone,\n>>>\n>>> Following up on the \"V3 Transaction\" discussion here\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>>> , I would like to elaborate a bit further on some potential follow-on work\n>>> that would make pinning severely constrained in many setups].\n>>>\n>>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks under\n>>> some constraints[0]. This means that when a replacement is to be made and\n>>> propagated, it costs the expected amount of fees to do so. This is a great\n>>> start. What's left in this subset of pinning is *package limit* pinning. In\n>>> other words, a fee-paying transaction cannot enter the mempool due to the\n>>> existing mempool package it is being added to already being too large in\n>>> count or vsize.\n>>>\n>>> Zooming into the V3 simplified scenario for sake of discussion, though\n>>> this problem exists in general today:\n>>>\n>>> V3 transactions restrict the package limit of a V3 package to one parent\n>>> and one child. If the parent transaction includes two outputs which can be\n>>> immediately spent by separate parties, this allows one party to disallow a\n>>> spend from the other. In Gloria's proposal for ln-penalty, this is worked\n>>> around by reducing the number of anchors per commitment transaction to 1,\n>>> and each version of the commitment transaction has a unique party's key on\n>>> it. The honest participant can spend their version with their anchor and\n>>> package RBF the other commitment transaction safely.\n>>>\n>>> What if there's only one version of the commitment transaction, such as\n>>> in other protocols like duplex payment channels, eltoo? What about multi\n>>> party payments?\n>>>\n>>> In the package RBF proposal, if the parent transaction is identical to\n>>> an existing transaction in the mempool, the parent will be detected and\n>>> removed from the package proposal. You are then left with a single V3 child\n>>> transaction, which is then proposed for entry into the mempool. In the case\n>>> of another parent output already being spent, this is simply rejected,\n>>> regardless of feerate of the new child.\n>>>\n>>> I have two proposed solutions, of which I strongly prefer the latter:\n>>>\n>>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>>> out of the mempool and takes the one child slot. This would solve it, but\n>>> is a new eviction paradigm that would need to be carefully worked through.\n>>>\n>>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>>\n>>> Ephemeral Anchors is a term which means an output is watermarked as an\n>>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>>> and spend with empty witness data.\n>>>\n>>> Also as a simplifying assumption, we require the parent transaction with\n>>> such an output to be 0-fee. This makes mempool reasoning simpler in case\n>>> the child-spend is somehow evicted, guaranteeing the parent will be as well.\n>>>\n>>> Implications:\n>>>\n>>> a) If the ephemeral anchor MUST be spent, we can allow *any* value, even\n>>> dust, even 0, without worrying about bloating the utxo set. We relax this\n>>> policy for maximum smart contract flexibility and specification simplicity..\n>>>\n>>> b) Since this anchor MUST be spent, any spending of other outputs in the\n>>> same parent transaction MUST directly double-spend prior spends of the\n>>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>>> removed in these situations. This greatly magnifies composability of smart\n>>> contracts, as now we can do things like safely splice directly into new\n>>> channels, into statechains, your custodial wallet account, your cold\n>>> wallet, wherever, without requiring other wallets to support arbitrary\n>>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>>> compatible to begin with...\n>>>\n>>> c) *Anyone* can bump the transaction, without any transaction key\n>>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>>> proposal without consensus changes. As long as someone gets a fully signed\n>>> parent, they can execute a bump with minimal wallet tooling. If a\n>>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>>\n>>> d) Lightning Carve-out(\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>>> is superseded by this logic, as we are not restricted to two immediately\n>>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>>> possible.\n>>>\n>>> e) This also benefits more traditional wallet scenarios, as change\n>>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>>> the first place(\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>>\n>>> Open Question(s):\n>>>\n>>>\n>>>    1.\n>>>\n>>>    If we allow non-zero value in ephemeral outputs, does this open up a\n>>>    MEV we are worried about? Wallets should toss all the value directly to\n>>>    fees, and add their own additional fees on top, otherwise miners have\n>>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>>    They just confirmed your parent transaction anyways, so do we care?\n>>>    2.\n>>>\n>>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>>    anchors to be added at spend time, depending on spending requirements.\n>>>    SIGHASH_SINGLE already allows this.\n>>>\n>>>\n>>>\n>>>\n>>> Hopefully this gives people something to consider as we move forward in\n>>> thinking about mempool design within the constraints we have today.\n>>>\n>>>\n>>> Greg\n>>>\n>>> 0: With V3 transactions where you have \"veto power\" over all the inputs\n>>> in that transaction. Therefore something like ANYONECANPAY is still broken.\n>>> We need a more complex solution, which I\u2019m punting for the sake of progress.\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/f955444d/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-20T13:42:26",
                "message_text_only": "So it doesn't look like I'm ignoring a good question:\n\nNo solid noninteractive ideas, unless we get some very flexible sighash\nsoftfork. Interactively, I think you can get collaborative fee bumps under\nthe current consensus regime and ephemeral anchors. The child will just be\nbuilt with inputs from different people.\n\nOn Wed, Oct 19, 2022 at 11:12 AM James O'Beirne <james.obeirne at gmail.com>\nwrote:\n\n> I'm also very happy to see this proposal, since it gets us closer to\n> having a mechanism that allows the contribution to feerate in an\n> \"unauthenticated\" way, which seems to be a very helpful feature for vaults\n> and other contracting protocols.\n>\n> One possible advantage of the sponsors interface -- and I'm curious for\n> your input here Greg -- is that with sponsors, assuming we relaxed the \"one\n> sponsor per sponsoree\" constraint, multiple uncoordinated parties can\n> collaboratively bump a tx's feerate. A simple example would be a batch\n> withdrawal from an exchange could be created with a low feerate, and then\n> multiple users with a vested interest of expedited confirmation could all\n> \"chip in\" to raise the feerate with multiple sponsor transactions.\n>\n> Having a single ephemeral output seems to create a situation where a\n> single UTXO has to shoulder the burden of CPFPing a package. Is there some\n> way we could (possibly later) amend the ephemeral anchor interface to allow\n> for this kind of collaborative sponsoring? Could you maybe see \"chained\"\n> ephemeral anchors that would allow this?\n>\n>\n> On Tue, Oct 18, 2022 at 12:52 PM Jeremy Rubin via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Excellent proposal and I agree it does capture much of the spirit of\n>> sponsors w.r.t. how they might be used for V3 protocols.\n>>\n>> The only drawbacks I see is they don't work for lower tx version\n>> contracts, so there's still something to be desired there, and that the\n>> requirement to sweep the output must be incentive compatible for the miner,\n>> or else they won't enforce it (pass the buck onto the future bitcoiners).\n>> The Ephemeral UTXO concept can be a consensus rule (see\n>> https://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate\n>> UTXO\") we add later on in lieu of managing them by incentive, so maybe it's\n>> a cleanup one can punt.\n>>\n>> One question I have is if V3 is designed for lightning, and this is\n>> designed for lightning, is there any sense in requiring these outputs for\n>> v3? That might help with e.g. anonymity set, as well as potentially keep\n>> the v3 surface smaller.\n>>\n>> On Tue, Oct 18, 2022 at 11:51 AM Greg Sanders via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> > does that effectively mark output B as unspendable once the child gets\n>>> confirmed?\n>>>\n>>> Not at all. It's a normal spend like before, since the parent has been\n>>> confirmed. It's completely unrestricted, not being bound to any\n>>> V3/ephemeral anchor restrictions on size, version, etc.\n>>>\n>>> On Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Hi Greg,\n>>>>\n>>>> Thank you very much for sharing your proposal!\n>>>>\n>>>> I think there's one thing about the second part of your proposal that\n>>>> I'm missing. Specifically, assuming the scenario of a v3 transaction with\n>>>> three outputs, A, B, and the ephemeral anchor OP_TRUE. If a child\n>>>> transaction spends A and OP_TRUE, does that effectively mark output B as\n>>>> unspendable once the child gets confirmed? If so, isn't the implication\n>>>> therefore that to safely spend a transaction with an ephemeral anchor, all\n>>>> outputs must be spent? Thanks!\n>>>>\n>>>> Best,\n>>>> Arik\n>>>>\n>>>> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>>>>\n>>>> Hello Everyone,\n>>>>\n>>>> Following up on the \"V3 Transaction\" discussion here\n>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>>>> , I would like to elaborate a bit further on some potential follow-on work\n>>>> that would make pinning severely constrained in many setups].\n>>>>\n>>>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks\n>>>> under some constraints[0]. This means that when a replacement is to be made\n>>>> and propagated, it costs the expected amount of fees to do so. This is a\n>>>> great start. What's left in this subset of pinning is *package limit*\n>>>> pinning. In other words, a fee-paying transaction cannot enter the mempool\n>>>> due to the existing mempool package it is being added to already being too\n>>>> large in count or vsize.\n>>>>\n>>>> Zooming into the V3 simplified scenario for sake of discussion, though\n>>>> this problem exists in general today:\n>>>>\n>>>> V3 transactions restrict the package limit of a V3 package to one\n>>>> parent and one child. If the parent transaction includes two outputs which\n>>>> can be immediately spent by separate parties, this allows one party to\n>>>> disallow a spend from the other. In Gloria's proposal for ln-penalty, this\n>>>> is worked around by reducing the number of anchors per commitment\n>>>> transaction to 1, and each version of the commitment transaction has a\n>>>> unique party's key on it. The honest participant can spend their version\n>>>> with their anchor and package RBF the other commitment transaction safely.\n>>>>\n>>>> What if there's only one version of the commitment transaction, such as\n>>>> in other protocols like duplex payment channels, eltoo? What about multi\n>>>> party payments?\n>>>>\n>>>> In the package RBF proposal, if the parent transaction is identical to\n>>>> an existing transaction in the mempool, the parent will be detected and\n>>>> removed from the package proposal. You are then left with a single V3 child\n>>>> transaction, which is then proposed for entry into the mempool. In the case\n>>>> of another parent output already being spent, this is simply rejected,\n>>>> regardless of feerate of the new child.\n>>>>\n>>>> I have two proposed solutions, of which I strongly prefer the latter:\n>>>>\n>>>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>>>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>>>> out of the mempool and takes the one child slot. This would solve it, but\n>>>> is a new eviction paradigm that would need to be carefully worked through.\n>>>>\n>>>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>>>\n>>>> Ephemeral Anchors is a term which means an output is watermarked as an\n>>>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>>>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>>>> and spend with empty witness data.\n>>>>\n>>>> Also as a simplifying assumption, we require the parent transaction\n>>>> with such an output to be 0-fee. This makes mempool reasoning simpler in\n>>>> case the child-spend is somehow evicted, guaranteeing the parent will be as\n>>>> well.\n>>>>\n>>>> Implications:\n>>>>\n>>>> a) If the ephemeral anchor MUST be spent, we can allow *any* value,\n>>>> even dust, even 0, without worrying about bloating the utxo set. We relax\n>>>> this policy for maximum smart contract flexibility and specification\n>>>> simplicity..\n>>>>\n>>>> b) Since this anchor MUST be spent, any spending of other outputs in\n>>>> the same parent transaction MUST directly double-spend prior spends of the\n>>>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>>>> removed in these situations. This greatly magnifies composability of smart\n>>>> contracts, as now we can do things like safely splice directly into new\n>>>> channels, into statechains, your custodial wallet account, your cold\n>>>> wallet, wherever, without requiring other wallets to support arbitrary\n>>>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>>>> compatible to begin with...\n>>>>\n>>>> c) *Anyone* can bump the transaction, without any transaction key\n>>>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>>>> proposal without consensus changes. As long as someone gets a fully signed\n>>>> parent, they can execute a bump with minimal wallet tooling. If a\n>>>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>>>\n>>>> d) Lightning Carve-out(\n>>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>>>> is superseded by this logic, as we are not restricted to two immediately\n>>>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>>>> possible.\n>>>>\n>>>> e) This also benefits more traditional wallet scenarios, as change\n>>>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>>>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>>>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>>>> the first place(\n>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>>>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>>>\n>>>> Open Question(s):\n>>>>\n>>>>\n>>>>    1.\n>>>>\n>>>>    If we allow non-zero value in ephemeral outputs, does this open up\n>>>>    a MEV we are worried about? Wallets should toss all the value directly to\n>>>>    fees, and add their own additional fees on top, otherwise miners have\n>>>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>>>    They just confirmed your parent transaction anyways, so do we care?\n>>>>    2.\n>>>>\n>>>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>>>    anchors to be added at spend time, depending on spending requirements.\n>>>>    SIGHASH_SINGLE already allows this.\n>>>>\n>>>>\n>>>>\n>>>>\n>>>> Hopefully this gives people something to consider as we move forward in\n>>>> thinking about mempool design within the constraints we have today.\n>>>>\n>>>>\n>>>> Greg\n>>>>\n>>>> 0: With V3 transactions where you have \"veto power\" over all the inputs\n>>>> in that transaction. Therefore something like ANYONECANPAY is still broken.\n>>>> We need a more complex solution, which I\u2019m punting for the sake of progress.\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/010d0c60/attachment-0001.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2022-10-27T09:37:01",
                "message_text_only": "Hi, Greg.\n\nI find this proposal super interesting, and IIUC something that seems\nfairly \"safe\" to allow (assuming V3).\n\nFor LN having the commitment transaction pay a non-zero fee is a cause for\na lot of complexity in the channel state machine. Something like this would\nremove a lot of edge cases and add more flexibility around adding HTLCs.\n\nThanks!\n\n- Johan\n\nOn Thu, Oct 20, 2022 at 3:42 PM Greg Sanders via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> So it doesn't look like I'm ignoring a good question:\n>\n> No solid noninteractive ideas, unless we get some very flexible sighash\n> softfork. Interactively, I think you can get collaborative fee bumps under\n> the current consensus regime and ephemeral anchors. The child will just be\n> built with inputs from different people.\n>\n> On Wed, Oct 19, 2022 at 11:12 AM James O'Beirne <james.obeirne at gmail.com>\n> wrote:\n>\n>> I'm also very happy to see this proposal, since it gets us closer to\n>> having a mechanism that allows the contribution to feerate in an\n>> \"unauthenticated\" way, which seems to be a very helpful feature for vaults\n>> and other contracting protocols.\n>>\n>> One possible advantage of the sponsors interface -- and I'm curious for\n>> your input here Greg -- is that with sponsors, assuming we relaxed the \"one\n>> sponsor per sponsoree\" constraint, multiple uncoordinated parties can\n>> collaboratively bump a tx's feerate. A simple example would be a batch\n>> withdrawal from an exchange could be created with a low feerate, and then\n>> multiple users with a vested interest of expedited confirmation could all\n>> \"chip in\" to raise the feerate with multiple sponsor transactions.\n>>\n>> Having a single ephemeral output seems to create a situation where a\n>> single UTXO has to shoulder the burden of CPFPing a package. Is there some\n>> way we could (possibly later) amend the ephemeral anchor interface to allow\n>> for this kind of collaborative sponsoring? Could you maybe see \"chained\"\n>> ephemeral anchors that would allow this?\n>>\n>>\n>> On Tue, Oct 18, 2022 at 12:52 PM Jeremy Rubin via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Excellent proposal and I agree it does capture much of the spirit of\n>>> sponsors w.r.t. how they might be used for V3 protocols.\n>>>\n>>> The only drawbacks I see is they don't work for lower tx version\n>>> contracts, so there's still something to be desired there, and that the\n>>> requirement to sweep the output must be incentive compatible for the miner,\n>>> or else they won't enforce it (pass the buck onto the future bitcoiners).\n>>> The Ephemeral UTXO concept can be a consensus rule (see\n>>> https://rubin.io/public/pdfs/multi-txn-contracts.pdf \"Intermediate\n>>> UTXO\") we add later on in lieu of managing them by incentive, so maybe it's\n>>> a cleanup one can punt.\n>>>\n>>> One question I have is if V3 is designed for lightning, and this is\n>>> designed for lightning, is there any sense in requiring these outputs for\n>>> v3? That might help with e.g. anonymity set, as well as potentially keep\n>>> the v3 surface smaller.\n>>>\n>>> On Tue, Oct 18, 2022 at 11:51 AM Greg Sanders via bitcoin-dev <\n>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> > does that effectively mark output B as unspendable once the child\n>>>> gets confirmed?\n>>>>\n>>>> Not at all. It's a normal spend like before, since the parent has been\n>>>> confirmed. It's completely unrestricted, not being bound to any\n>>>> V3/ephemeral anchor restrictions on size, version, etc.\n>>>>\n>>>> On Tue, Oct 18, 2022 at 11:47 AM Arik Sosman via bitcoin-dev <\n>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>>\n>>>>> Hi Greg,\n>>>>>\n>>>>> Thank you very much for sharing your proposal!\n>>>>>\n>>>>> I think there's one thing about the second part of your proposal that\n>>>>> I'm missing. Specifically, assuming the scenario of a v3 transaction with\n>>>>> three outputs, A, B, and the ephemeral anchor OP_TRUE. If a child\n>>>>> transaction spends A and OP_TRUE, does that effectively mark output B as\n>>>>> unspendable once the child gets confirmed? If so, isn't the implication\n>>>>> therefore that to safely spend a transaction with an ephemeral anchor, all\n>>>>> outputs must be spent? Thanks!\n>>>>>\n>>>>> Best,\n>>>>> Arik\n>>>>>\n>>>>> On Tue, Oct 18, 2022, at 6:52 AM, Greg Sanders via bitcoin-dev wrote:\n>>>>>\n>>>>> Hello Everyone,\n>>>>>\n>>>>> Following up on the \"V3 Transaction\" discussion here\n>>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>>>>> , I would like to elaborate a bit further on some potential follow-on work\n>>>>> that would make pinning severely constrained in many setups].\n>>>>>\n>>>>> V3 transactions may solve bip125 rule#3 and rule#5 pinning attacks\n>>>>> under some constraints[0]. This means that when a replacement is to be made\n>>>>> and propagated, it costs the expected amount of fees to do so. This is a\n>>>>> great start. What's left in this subset of pinning is *package limit*\n>>>>> pinning. In other words, a fee-paying transaction cannot enter the mempool\n>>>>> due to the existing mempool package it is being added to already being too\n>>>>> large in count or vsize.\n>>>>>\n>>>>> Zooming into the V3 simplified scenario for sake of discussion, though\n>>>>> this problem exists in general today:\n>>>>>\n>>>>> V3 transactions restrict the package limit of a V3 package to one\n>>>>> parent and one child. If the parent transaction includes two outputs which\n>>>>> can be immediately spent by separate parties, this allows one party to\n>>>>> disallow a spend from the other. In Gloria's proposal for ln-penalty, this\n>>>>> is worked around by reducing the number of anchors per commitment\n>>>>> transaction to 1, and each version of the commitment transaction has a\n>>>>> unique party's key on it. The honest participant can spend their version\n>>>>> with their anchor and package RBF the other commitment transaction safely.\n>>>>>\n>>>>> What if there's only one version of the commitment transaction, such\n>>>>> as in other protocols like duplex payment channels, eltoo? What about multi\n>>>>> party payments?\n>>>>>\n>>>>> In the package RBF proposal, if the parent transaction is identical to\n>>>>> an existing transaction in the mempool, the parent will be detected and\n>>>>> removed from the package proposal. You are then left with a single V3 child\n>>>>> transaction, which is then proposed for entry into the mempool. In the case\n>>>>> of another parent output already being spent, this is simply rejected,\n>>>>> regardless of feerate of the new child.\n>>>>>\n>>>>> I have two proposed solutions, of which I strongly prefer the latter:\n>>>>>\n>>>>> 1) Expand a carveout for \"sibling eviction\", where if the new child is\n>>>>> paying \"enough\" to bump spends from the same parent, it knocks its sibling\n>>>>> out of the mempool and takes the one child slot. This would solve it, but\n>>>>> is a new eviction paradigm that would need to be carefully worked through.\n>>>>>\n>>>>> 2) Ephemeral Anchors (my real policy-only proposal)\n>>>>>\n>>>>> Ephemeral Anchors is a term which means an output is watermarked as an\n>>>>> output that MUST be spent in a V3 package. We mark this anchor by being the\n>>>>> bare script `OP_TRUE` and of course make these outputs standard to relay\n>>>>> and spend with empty witness data.\n>>>>>\n>>>>> Also as a simplifying assumption, we require the parent transaction\n>>>>> with such an output to be 0-fee. This makes mempool reasoning simpler in\n>>>>> case the child-spend is somehow evicted, guaranteeing the parent will be as\n>>>>> well.\n>>>>>\n>>>>> Implications:\n>>>>>\n>>>>> a) If the ephemeral anchor MUST be spent, we can allow *any* value,\n>>>>> even dust, even 0, without worrying about bloating the utxo set. We relax\n>>>>> this policy for maximum smart contract flexibility and specification\n>>>>> simplicity..\n>>>>>\n>>>>> b) Since this anchor MUST be spent, any spending of other outputs in\n>>>>> the same parent transaction MUST directly double-spend prior spends of the\n>>>>> ephemeral anchor. This causes the 1 block CSV timelock on outputs to be\n>>>>> removed in these situations. This greatly magnifies composability of smart\n>>>>> contracts, as now we can do things like safely splice directly into new\n>>>>> channels, into statechains, your custodial wallet account, your cold\n>>>>> wallet, wherever, without requiring other wallets to support arbitrary\n>>>>> scripts. Also it hurts that 1 CSV time locked scripts may not be miniscript\n>>>>> compatible to begin with...\n>>>>>\n>>>>> c) *Anyone* can bump the transaction, without any transaction key\n>>>>> material. This is essentially achieving Jeremy's Transaction Sponsors (\n>>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html)\n>>>>> proposal without consensus changes. As long as someone gets a fully signed\n>>>>> parent, they can execute a bump with minimal wallet tooling. If a\n>>>>> transaction author doesn\u2019t want a \u201csponsor\u201d, do not include the output.\n>>>>>\n>>>>> d) Lightning Carve-out(\n>>>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002240.html)\n>>>>> is superseded by this logic, as we are not restricted to two immediately\n>>>>> spendable output scenarios. In its place, robust multi-party fee bumping is\n>>>>> possible.\n>>>>>\n>>>>> e) This also benefits more traditional wallet scenarios, as change\n>>>>> outputs can no longer be pinned, and RBF/CPFP becomes robust. Payees in\n>>>>> simple spends cannot pin you. Batched payouts become a lot less painful.\n>>>>> This was one of the motivating use cases that created the term \u201cpinning\u201d in\n>>>>> the first place(\n>>>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015717.html),\n>>>>> even if LN/L2 discussion has largely overtaken it due to HTLC theft risks.\n>>>>>\n>>>>> Open Question(s):\n>>>>>\n>>>>>\n>>>>>    1.\n>>>>>\n>>>>>    If we allow non-zero value in ephemeral outputs, does this open up\n>>>>>    a MEV we are worried about? Wallets should toss all the value directly to\n>>>>>    fees, and add their own additional fees on top, otherwise miners have\n>>>>>    incentive to make the smallest utxo burn transaction to claim those funds.\n>>>>>    They just confirmed your parent transaction anyways, so do we care?\n>>>>>    2.\n>>>>>\n>>>>>    SIGHASH_GROUP like constructs would allow uncommitted ephemeral\n>>>>>    anchors to be added at spend time, depending on spending requirements.\n>>>>>    SIGHASH_SINGLE already allows this.\n>>>>>\n>>>>>\n>>>>>\n>>>>>\n>>>>> Hopefully this gives people something to consider as we move forward\n>>>>> in thinking about mempool design within the constraints we have today.\n>>>>>\n>>>>>\n>>>>> Greg\n>>>>>\n>>>>> 0: With V3 transactions where you have \"veto power\" over all the\n>>>>> inputs in that transaction. Therefore something like ANYONECANPAY is still\n>>>>> broken. We need a more complex solution, which I\u2019m punting for the sake of\n>>>>> progress.\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>>>\n>>>>> _______________________________________________\n>>>>> bitcoin-dev mailing list\n>>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/c66de0f3/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Ephemeral Anchors: Fixing V3 Package RBF againstpackage limit pinning",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Arik Sosman",
                "Johan Tor\u00e5s Halseth",
                "Jeremy Rubin",
                "James O'Beirne",
                "Greg Sanders"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 68108
        }
    },
    {
        "title": "[bitcoin-dev] [Lightning-dev] Taro: A Taproot Asset Representation Overlay",
        "thread_messages": [
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2022-10-19T02:40:13",
                "message_text_only": "Hi Hiroki,\n\n(inserting the bitcoin-dev mailing list as this question is mainly\nconcerning on-chain interaction)\n\nThanks for taking the time to really dig into things!\n\n> When trying to verify the provenance of a given UTXO, it is necessary to\n> verify the state transitions of all transaction graphs without gaps from\n> the genesis transaction of the asset to the current location\n\n> It is necessary to prove and verify that \u201cthe UTXO has not changed\u201d at\n> that point.\n\nCorrect!\n\n> As far as I can see, the specs don't mention it.\n\nYou're correct that today the main BIP draft focuses mainly on transfers [1]\nto specify how exactly an asset moves from one output to another. The\nrequirement that a \"no-op\" state transition also be created/verified is an\nimplicit assumption in the current spec that we aim to remedy. The current\nalpha code [2] is a bit ahead of the spec, but we aim to start to catch up\nthe spec, and also begin to add test vectors now that we have a working\nimplementation.\n\n> The proofs for directly proving that a UTXO has not changed are its\n> inclusion proof in the input asset tree and its inclusion and\n> non-inclusion proofs in each of the output asset trees\n\nCorrect, the set of inclusion and non-inclusion proofs necessary for a valid\nstate transition are currently documented in `bip-taro-proof-file.md` [3].\nWe've also made a few updates to the proof file format to properly include a\nfield for the inclusion proof of a split asset's _root_ asset. This allows\nverifiers to properly verify the authenticity of the split (root is in the\ntransaction, uniquely, which commits to the split, which has a proof\nanchored in that spit root).\n\n> Instead, it's better to set a constraint that no part of the asset tree\n> except the explicitly changed UTXOs should change, and verify that.\n\nInteresting, so rather than present/maintain a distinct state transition for\neach asset unaffected, you propose that instead we present a _single_ proof\nfor all non-modified assets that shows that a sub-tree/branch is unchanged?\nThat's a very cool idea.\n\nGenerally we have a lot of low hanging fruits re optimizing the proof file\nformat itself. As an example, all assets in a tree will share the same\nBitcoin-level proof prefix (merkle proof and block header of the anchor\ntransaction), but the spec/implementation will currently duplicate those\nvalues several times over for each asset. If we go down another level, then\nthe main inclusion proof for an asset ID tree is also duplicated for each\nasset sharing that asset ID.\n\nRestating things a bit: right now proofs are oriented from the PoV of an\nasset leaf in question. Instead, if we zoom out a bit and orient them at the\n_taproot output_ level, then we can remove a lot of redundant data in the\ncurrent proof format, then sort of \"prune\" the output level proof to\ngenerate a proof for a single leaf.\n\n-- Laolu\n\n[1]:\nhttps://github.com/Roasbeef/bips/blob/bip-taro/bip-taro.mediawiki#asset-transfers\n[2]: https://github.com/lightninglabs/taro\n[3]:\nhttps://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-proof-file.mediawiki#specification\n\nOn Fri, Oct 7, 2022 at 2:33 AM Hiroki Gondo <hiroki.gondo at nayuta.co> wrote:\n\n> Hi Laolu,\n>\n> I've read Taro's specs, but I'm afraid there's not enough verification of\n> the provenance of the asset UTXOs.\n>\n> When trying to verify the provenance of a given UTXO, it is necessary to\n> verify the state transitions of all transaction graphs without gaps from\n> the genesis transaction of the asset to the current location. At some point\n> in the transaction, the target UTXO itself may not change (only changes to\n> other assets or other UTXOs in the asset tree). It is necessary to prove\n> and verify that \u201cthe UTXO has not changed\u201d at that point. As far as I can\n> see, the specs don't mention it.\n>\n> Without this validation, asset inflation (double spending) is possible. In\n> a transaction, there is a UTXO in the input asset tree. If this UTXO does\n> not change in this transaction, it will remain in the output asset tree.\n> However, if a full copy of this UTXO is illicitly created in the asset tree\n> of another output, the asset will be inflated (even duplicating the lowest\n> MS-SMT entirely). Both UTXOs will arbitrarily claim to be the same as the\n> input UTXO.\n>\n> The proofs for directly proving that a UTXO has not changed are its\n> inclusion proof in the input asset tree and its inclusion and non-inclusion\n> proofs in each of the output asset trees. However, generating these proofs\n> for every unchanging UTXO present in the input asset tree when a\n> transaction occurs may not be very practical. Instead, it's better to set a\n> constraint that no part of the asset tree except the explicitly changed\n> UTXOs should change, and verify that.\n>\n> Please let me know if I'm wrong or have overlooked any specs. Also, let me\n> know if there's anything about this that hasn't been mentioned in the specs\n> yet.\n>\n> \u2013\n> Hiroki Gondo\n>\n>\n> 2022\u5e744\u67086\u65e5(\u6c34) 0:06 Olaoluwa Osuntokun <laolu32 at gmail.com>:\n>\n>> Hi y'all,\n>>\n>> I'm excited to publicly publish a new protocol I've been working on over\n>> the\n>> past few months: Taro. Taro is a Taproot Asset Representation Overlay\n>> which\n>> allows the issuance of normal and also collectible assets on the main\n>> Bitcoin\n>> chain. Taro uses the Taproot script tree to commit extra asset structured\n>> meta\n>> data based on a hybrid merkle tree I call a Merkle Sum Sparse Merkle Tree\n>> or\n>> MS-SMT. An MS-SMT combined the properties of a merkle sum tree, with a\n>> sparse\n>> merkle tree, enabling things like easily verifiable asset supply proofs\n>> and\n>> also efficient proofs of non existence (eg: you prove to me you're no\n>> longer\n>> committing to the 1-of-1 holographic beefzard card during our swap). Taro\n>> asset\n>> transfers are then embedded in a virtual/overlay transaction graph which\n>> uses a\n>> chain of asset witnesses to provably track the transfer of assets across\n>> taproot outputs. Taro also has a scripting system, which allows for\n>> programmatic unlocking/transfer of assets. In the first version, the\n>> scripting\n>> system is actually a recursive instance of the Bitcoin Script Taproot VM,\n>> meaning anything that can be expressed in the latest version of Script\n>> can be\n>> expressed in the Taro scripting system. Future versions of the scripting\n>> system\n>> can introduce new functionality on the Taro layer, like covenants or other\n>> updates.\n>>\n>> The Taro design also supports integration with the Lightning Network\n>> (BOLTs) as\n>> the scripting system can be used to emulate the existing HTLC structure,\n>> which\n>> allows for multi-hop transfers of Taro assets. Rather than modify the\n>> internal\n>> network, the protocol proposes to instead only recognize \"assets at the\n>> edges\",\n>> which means that only the sender+receiver actually need to know about and\n>> validate the assets. This deployment route means that we don't need to\n>> build up\n>> an entirely new network and liquidity for each asset. Instead, all asset\n>> transfers will utilize the Bitcoin backbone of the Lightning Network,\n>> which\n>> means that the internal routers just see Bitcoin transfers as normal, and\n>> don't\n>> even know about assets at the edges. As a result, increased demand for\n>> transfers of these assets as the edges (say like a USD stablecoin), which\n>> in\n>> will turn generate increased demand of LN capacity, result in more\n>> transfers, and\n>> also more routing revenue for the Bitcoin backbone nodes.\n>>\n>> The set of BIPs are a multi-part suite, with the following breakdown:\n>>  * The main Taro protocol:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro.mediawiki\n>>  * The MS-SMT structure:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-ms-smt.mediawiki\n>>  * The Taro VM:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-vm.mediawiki\n>>  * The Taro address format:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-addr.mediawiki\n>>  * The Taro Universe concept:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-universe.mediawiki\n>>  * The Taro flat file proof format:\n>> https://github.com/Roasbeef/bips/blob/bip-taro/bip-taro-proof-file.mediawiki\n>>\n>> Rather than post them all in line (as the text wouldn't fit in the\n>> allowed size\n>> limit), all the BIPs can be found above.\n>>\n>> -- Laolu\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/4881098f/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Taro: A Taproot Asset Representation Overlay",
            "categories": [
                "bitcoin-dev",
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8732
        }
    },
    {
        "title": "[bitcoin-dev] Batch validation of CHECKMULTISIG using an extra hint field",
        "thread_messages": [
            {
                "author": "Mark Friedenbach",
                "date": "2022-10-19T03:51:42",
                "message_text_only": "When Satoshi wrote the first version of bitcoin, s/he made what was almost certainly an unintentional mistake. A bug in the original CHECKMULTISIG implementation caused an extra item to be popped off the stack upon completion. This extra value is not used in any way, and has no consensus meaning. Since this value is often provided in the witness, it unfortunately provides a malleability vector as anybody can change the extra/dummy value in the signature without invalidating a transaction. In legacy scripts NULLDUMMY is a policy rule that states this value must be zero, and this was made a consensus rule for segwit scripts.\n\nThis isn\u2019t the only problem with CHECKMULTISIG. For both ECDSA and Schnorr signatures, batch validation could enable an approximate 2x speedup, especially during the initial block download phase. However the CHECKMULTISIG algorithm, as written, seemingly precludes batch validation for threshold signatures as it attempts to validate the list of signatures with the list of pubkeys, in order, dropping an unused pubkey only when a signature validation fails. As an example, the following script\n\n    [2 C B A 3 CHECKMULTISIG]\n\nCould be satisfied by the following witness:\n\n    [0 c a]\n\nWhere \u201ca\u201d is a signature for pubkey A, and \u201cc\u201d a signature for pubkey C. During validation, the signature a is checked using pubkey A, which is successful, so the internal algorithm increments the signature pointer AND the pubkey pointer to the next elements in the respective lists, removing both from future consideration. Next the signature c is checked with pubkey B, which fails, so only the pubkey pointer is incremented. Finally signature c is checked with pubkey C, which passes. Since 2 signatures passed and this is equal to the specified threshold, the opcode evaluates as true. All inputs (including the dummy 0 value) are popped from the stack.\n\nThe algorithm cannot batch validate these signatures because for any partial threshold it doesn\u2019t know which signatures map to which pubkeys.\n\nNot long after segwit was released for activation, making the NULLDUMMY rule consensus for segwit scripts, the observation was made by Luke-Jr on IRC[1] that this new rule was actually suboptimal. Satoshi\u2019s mistake gave us an extra parameter to CHECKMULTISIG, and it was entirely within our means to use this parameter to convey extra information to the CHECKMULTISIG algorithm, and thereby enable batch validation of threshold signatures using this opcode.\n\nThe idea is simple: instead of requiring that the final parameter on the stack be zero, require instead that it be a minimally-encoded bitmap specifying which keys are used, or alternatively, which are not used and must therefore be skipped. Before attempting validation, ensure for a k-of-n threshold only k bits are set in the bitfield indicating the used pubkeys (or n-k bits set indicating the keys to skip). The updated CHECKMULTISIG algorithm is as follows: when attempting to validate a signature with a pubkey, first check the associated bit in the bitfield to see if the pubkey is used. If the bitfield indicates that the pubkey is NOT used, then skip it without even attempting validation. The only signature validations which are attempted are those which the bitfield indicates ought to pass. This is a soft-fork as any validator operating under the original rules (which ignore the \u201cdummy\u201d bitfield) would still arrive at the correct pubkey-signature mapping through trial and error.\n\nAside: If you wanted to hyper-optimize, you could use a binomial encoding of the bitmask hint field, given that the n-choose-k threshold is already known. Or you could forego encoding the k threshold entirely and infer it from the number of set bits. However in either case the number of bytes saved is negligible compared to the overall size of a multisig script and witness, and there\u2019d be a significant tradeoff in usability. Such optimization is probably not worth it.\n\nIf you\u2019d rather see this in terms of code, there\u2019s an implementation of this that I coded up in 2019 and deployed to a non-bitcoin platform:\n\nhttps://github.com/tradecraftio/tradecraft/commit/339dafc0be37ae5465290b22d204da4f37c6e261\n\nUnfortunately this observation was made too late to be incorporated into segwit, but future versions of script could absolutely use the hint-field trick to enable batch validation of CHECKMULTISIG scripts. So you can imagine my surprise when reviewing the Taproot/Tapscript BIPs I saw that CHECKMULTISIG was disabled for Tapscript, and the justification given in the footnotes is that CHECKMULTISIG is not compatible with batch validation! Talking with a few other developers including Luke-Jr, it has become clear that this solution to the CHECKMULTISIG batch validation problem had been completely forgotten and did not come up during Tapscript review. I\u2019m posting this now because I don\u2019t want the trick to be lost again.\n\nKind regards,\nMark Friedenbach\n\nPS: One could make the argument that threshold signatures are implementable with the new CHECKSIGADD opcode, so why bother? For example, the above 2-of-3 threshold could be implemented in Tapscript as:\n\n    [OP_0 A CHECKSIGADD B CHECKSIGADD C CHECKSIGADD 2 EQUAL]\n\nHowever (1) this requires six opcodes in addition to the pubkey pushes, instead of just 3, and the number of wasted opcodes scales linearly with the size of the threshold; and (2) the intent is less clear. Because the intent is not encoded directly in the program in the form of an explicit threshold but rather inferred from the program structure, there is a higher likelihood of making a mistake. Particularly for more advanced scripts than this.\n\nOne could also argue that there is no need for explicit k-of-n thresholds now that we have Schnorr signatures, as MuSig-like key aggregation schemes can be used instead. In many cases this is true, and doing key aggregation can result in smaller scripts with more private spend pathways. However there remain many use cases where for whatever reason interactive signing is not possible, due to signatures being pre-calculated and shared with third parties, for example, and therefore explicit thresholds must be used instead. For such applications a batch-validation friendly CHECKMULTISIG would be useful.\n\n[1] I believe it was Luke-Jr, and in 2016 or 2017, probably in #bitcoin-wizards. I don\u2019t have logs to check, however.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221018/92295aa7/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2022-10-20T22:02:51",
                "message_text_only": "Good morning Mark,\n\n> The idea is simple: instead of requiring that the final parameter on the stack be zero, require instead that it be a minimally-encoded bitmap specifying which keys are used, or alternatively, which are not used and must therefore be skipped. Before attempting validation, ensure for a k-of-n threshold only k bits are set in the bitfield indicating the used pubkeys (or n-k bits set indicating the keys to skip). The updated CHECKMULTISIG algorithm is as follows: when attempting to validate a signature with a pubkey, first check the associated bit in the bitfield to see if the pubkey is used. If the bitfield indicates that the pubkey is NOT used, then skip it without even attempting validation. The only signature validations which are attempted are those which the bitfield indicates ought to pass. This is a soft-fork as any validator operating under the original rules (which ignore the \u201cdummy\u201d bitfield) would still arrive at the correct pubkey-signature mapping through trial and error.\n\nThat certainly seems like a lost optimization opportunity.\n\nThough if the NULLDATA requirement is already a consensus rule then this is no longer a softfork, existing validators would explicitly check it is zero?\n\n> One could also argue that there is no need for explicit k-of-n thresholds now that we have Schnorr signatures, as MuSig-like key aggregation schemes can be used instead. In many cases this is true, and doing key aggregation can result in smaller scripts with more private spend pathways. However there remain many use cases where for whatever reason interactive signing is not possible, due to signatures being pre-calculated and shared with third parties, for example, and therefore explicit thresholds must be used instead. For such applications a batch-validation friendly CHECKMULTISIG would be useful.\n\nAs I understand it, MuSig aggregation works on n-of-n only.\n\nThere is an alternative named FROST recently, that supports k-of-n, however, MuSig aggregation works on pre-existing keypairs, and if you know the public keys, you can aggregate the public keys without requiring participation with the privkey owners.\n\nFor FROST, there is a Verifiable Secret Sharing process which requires participation of the n signer set.\nMy understanding is that it cannot use *just* pre-existing keys, the privkey owners will, after the setup ritual, need to store additional data (tweaks to apply on their key depending on who the k are, if my vague understanding is accurate).\nThe requirement of having a setup ritual (which does not require trust but does require saving extra data) to implement k-of-n for k < n is another reason some protocol or other might want to use explicit `OP_CHECKMULTISIG`.\n\n(I do have to warn that my knowledge of FROST is hazy at best and the above might be wildly inaccurate.)\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Batch validation of CHECKMULTISIG using an extra hint field",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Mark Friedenbach"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 9425
        }
    },
    {
        "title": "[bitcoin-dev] brickchain",
        "thread_messages": [
            {
                "author": "mm-studios",
                "date": "2022-10-19T09:04:50",
                "message_text_only": "Hi Bitcoin devs,\nI'd like to share an idea of a method to increase throughput in the bitcoin network.\n\nCurrently, a miner produce blocks with a limited capacity of transactions that ultimately limits the global settlement throughput to a reduced number of tx/s.\n\nBig-blockers proposed the removal of limits but this didn't come with undesirable effects that have been widely discussed and rejected.\n\nThe main feature we wanted to preserve is 'small blocks', providing 'better network effects' I won't focus on them.\n\nThe problem with small blocks is that, once a block is filled transactions, they are kept back in the mempool, waiting for their turn in future blocks.\n\nThe following changes in the protocol aim to let all transactions go in the current block, while keeping the block size small. It requires changes in the PoW algorithm.\n\nCurrently, the PoW algorithm consists on finding a valid hash for the block. Its validity is determined by comparing the numeric value of the block hash with a protocol-defined value difficulty.\n\nOnce a miner finds a nonce for the block that satisfies the condition the new block becomes valid and can be propagated. All nodes would update their blockchains with it. (assuming no conflict resolution (orphan blocks, ...) for clarity).\n\nThis process is meant to happen every 10 minutes in average.\n\nWith this background information (we all already know) I go on to describe the idea:\n\nLet's allow a miner to include transactions until the block is filled, let's call this structure (coining a new term 'Brick'), B0. [brick=block that doesn't meet the difficulty rule and is filled of tx to its full capacity]\nSince PoW hashing is continuously active, Brick B0 would have a nonce corresponding to a minimum numeric value of its hash found until it got filled.\n\nFully filled brick B0, with a hash that doesn't meet the difficulty rule, would be broadcasted and nodes would have it on in a separate fork as usual.\n\nAt this point, instead of discarding transactions, our miner would start working on a new brick B1, linked with B0 as usual.\n\nNodes would allow incoming regular blocks and bricks with hashes that don't satisfy the difficulty rule, provided the brick is fully filled of transactions. Bricks not fully filled would be rejected as invalid to prevent spam (except if constitutes the last brick of a brickchain, explained below).\n\nLet's assume that 10 minutes have elapsed and our miner is in a state where N bricks have been produced and the accumulated PoW calculated using mathematics (every brick contains a 'minimum hash found', when a series of 'minimum hashes' is computationally equivalent to the network difficulty is then the full 'brickchain' is valid as a Block.\n\nThis calculus shall be better defined, but I hope that this idea can serve as a seed to a BIP, or otherwise deemed absurd, which might be possible and I'd be delighted to discover why a scheme like this wouldn't work.\n\nIf it finally worked, it could completely flush mempools, keep transactions fees low and increase throughput without an increase in the block size that would raise other concerns related to propagation.\n\nThank you.\nI look forward to your responses.\n\n--\nMarcos Mayorgahttps://twitter.com/KatlasC\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/928d0cde/attachment-0001.html>"
            },
            {
                "author": "angus",
                "date": "2022-10-19T13:40:35",
                "message_text_only": "> Let's allow a miner to include transactions until the block is filled, let's call this structure (coining a new term 'Brick'), B0. [brick=block that doesn't meet the difficulty rule and is filled of tx to its full capacity]\n> Since PoW hashing is continuously active, Brick B0 would have a nonce corresponding to a minimum numeric value of its hash found until it got filled.\n\n\nSo, if I'm understanding right, this amounts to \"reduce difficulty required for a block ('brick') to be valid if the mempool contains more than 1 block's worth of transactions so we get transactions confirmed faster\" using 'bricks' as short-lived sidechains that get merged into blocks?\n\nThis would have the same fundamental problem as just making the max blocksize bigger - it increases the rate of growth of storage required for a full node, because you're allowing blocks/bricks to be created faster, so there will be more confirmed transactions to store in a given time window than under current Bitcoin rules.\n\nBitcoin doesn't take the size of the mempool into account when adjusting the difficulty because the time-between-blocks is 'more important' than avoiding congestion where transactions take ages to get into a block. The fee mechanism in part allows users to decide how urgently they want their tx to get confirmed, and high fees when there is congestion also disincentivises others from transacting at all, which helps arrest mempool growth.\n\nI'd imagine we'd also see a 'highway widening' effect with this kind of proposal - if you increase the tx volume Bitcoin can settle in a given time, that will quickly be used up by more people transacting until we're back at a congested state again.\n\n> Fully filled brick B0, with a hash that doesn't meet the difficulty rule, would be broadcasted and nodes would have it on in a separate fork as usual.\n\n\nHow do we know if the hash the miner does find for a brick was their 'best effort' and they're not just being lazy? There's an element of luck in the best hash a miner can find, sometimes it takes a long time to meet the difficulty requirement and sometimes it happens almost at instantly.\n\nHow would we know how 'busy' the mempool was at the time a brick from months or years ago was mined?\n\nNodes have to be able to run through the entire history of the blockchain and check everything is valid. They have to do this using only the previous blocks they've already validated - they won't have historical snapshots of the mempool (they'll build and mutate a UTXO set, but that's different). Transactions don't contain a 'created-at' time that you could compare to the block's creation time (and if they did, you probably couldn't trust it).\n\nWith the current system, Nodes can calculate what the difficulty should be for every block based on those previous blocks' times and difficulties - but how would you know an old brick was valid if its difficulty was low but at the time the mempool was busy, vs. getting a fraudulent brick that is actually invalid because there isn't enough work in it? You can't solve this by adding some mempoolsize field to bricks, as you'd have to blindly trust miners not to lie about them.\n\nIf we can't be (fairly) certain that a miner put a minimum amount of work into finding a hash, then you lose all the strengths of PoW.\n\nIf you weaken the difficulty requirement which is there so that mining blocks is hard so that it is very hard to intentionally fork the chain, re-mine previous blocks, overtake the other fork, and get the network to re-org onto your chain - then there's no Proof of work undergirding consensus in the ledger's state.\n\nSecondly, where does the block reward go? Do brick miners get a fraction of the reward proportionate to the fraction of the difficulty they got to? Later when bricks become part of a block, who gets the block reward for that complete block? Who gets the fees? No miner is going to bother mining a merge-bricks-into-block block if the reward isn't the same or better than just mining a regular block, but each miner of the bricks in it would also want a reward. But, we can't give them both a block reward as that'd increase Bitcoin's issuance rate, which might be the only thing people are more strongly opposed to than increasing the blocksize! xD\n\n> At this point, instead of discarding transactions, our miner would start working on a new brick B1, linked with B0 as usual.\n> \n\n> Nodes would allow incoming regular blocks and bricks with hashes that don't satisfy the difficulty rule, provided the brick is fully filled of transactions. Bricks not fully filled would be rejected as invalid to prevent spam (except if constitutes the last brick of a brickchain, explained below).\n> \n\n> Let's assume that 10 minutes have elapsed and our miner is in a state where N bricks have been produced and the accumulated PoW calculated using mathematics (every brick contains a 'minimum hash found', when a series of 'minimum hashes' is computationally equivalent to the network difficulty is then the full 'brickchain' is valid as a Block.\n\n\nBut the brick sidechain has to become part of the main blockchain - and as you've got N bricks in the time that there should be 1 block, and each brick is a full block, it feels like this is just a convoluted way to increase the blocksize? Every transaction has to be in the ledger somewhere to be confirmed, so even if the block itself is small and stored references to the bricks, Nodes are going to have to use storage to keep all those full bricks.\n\nIt also seems that you'd have to require the bricks sidechain to always be merged into the next actual block - it wouldn't work if the brick chain could keep growing and at the same time the actual blockchain advances (because there'd be risks of double-spends where one tx is in the brick chain and the other in the new block). Which I think further makes this feel like a roundabout way of increasing the blocksize\n\nDespite my critique, this was interesting to think about - and hopefully this is useful (and hopefully I've not seriously misunderstood or said something dumb)\n\nAngus\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/3c06b968/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 249 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/3c06b968/attachment.sig>"
            },
            {
                "author": "mm-studios",
                "date": "2022-10-19T22:47:43",
                "message_text_only": "------- Original Message -------\nOn Wednesday, October 19th, 2022 at 2:40 PM, angus <angus at toaster.cc> wrote:\n\n>> Let's allow a miner to include transactions until the block is filled, let's call this structure (coining a new term 'Brick'), B0. [brick=block that doesn't meet the difficulty rule and is filled of tx to its full capacity]\n>> Since PoW hashing is continuously active, Brick B0 would have a nonce corresponding to a minimum numeric value of its hash found until it got filled.\n>\n> So, if I'm understanding right, this amounts to \"reduce difficulty required for a block ('brick') to be valid if the mempool contains more than 1 block's worth of transactions so we get transactions confirmed faster\" using 'bricks' as short-lived sidechains that get merged into blocks?\n\nThey wouldn't get confirmed faster.\nImagine a regular Big Block (BB) could be re-structured as a brickchain\nBB = B0 <- B1 <- ... <- Bn (Block = chain of bricks)\n\nOnly B0 contains the coinbase transaction.\n\nBi are streamed from miner to nodes as they are produced.\nThe node creates a separate fork on B0 arrival, and on arrival of the last B1 treats the whole brickchain as they now treat a 1 Block: Either accept it or reject it as as a whole. (like is the complete block had just arrived entirely. (In reality it has arrived as a stream of bricks).\nBefore the brickchain is complete the node does nothing special, just validate each brick on arrival and wait for the next.\n\n> This would have the same fundamental problem as just making the max blocksize bigger - it increases the rate of growth of storage required for a full node, because you're allowing blocks/bricks to be created faster, so there will be more confirmed transactions to store in a given time window than under current Bitcoin rules.\n\nYes, the data transmitted over the network is bigger, because we are intentionally increasing the throughput, instead of delaying tx in the mempool.\nThis is a potential howto in case there was an intention of speeding up L1.\nThe unavoidable price of speed in tx/s is bandwidth and volume of data to process.\nThe point is to do it without making bigger blocks.\n\n> Bitcoin doesn't take the size of the mempool into account when adjusting the difficulty because the time-between-blocks is 'more important' than avoiding congestion where transactions take ages to get into a block. The fee mechanism in part allows users to decide how urgently they want their tx to get confirmed, and high fees when there is congestion also disincentivises others from transacting at all, which helps arrest mempool growth.\n\nstreaming bricks instead of delivering a big block can be considered a way of reducing congestion. This is valid at any scale.\nE.g. 1 Mb block delivered at once every 10 minutes versus a stream of 10 100Kib-brick delivered 1 per minute\n\n> I'd imagine we'd also see a 'highway widening' effect with this kind of proposal - if you increase the tx volume Bitcoin can settle in a given time, that will quickly be used up by more people transacting until we're back at a congested state again.\n>\n>> Fully filled brick B0, with a hash that doesn't meet the difficulty rule, would be broadcasted and nodes would have it on in a separate fork as usual.\n\ncongestion can alweays happen with enough workload.\nA system able to determine its workload can regulate it (keeping tx in the mempool to temporarily aliviate).\n\nThe congestion counter-measure remains in essence the same.\n\n> How do we know if the hash the miner does find for a brick was their 'best effort' and they're not just being lazy? There's an element of luck in the best hash a miner can find, sometimes it takes a long time to meet the difficulty requirement and sometimes it happens almost at instantly.\n\na lazy miner will produce a longer brickchain because they would have greater hashes than a more powerful miner. A more competitive miner will deliver the complete brickchain faster and hence its half-way through brickchain will be discarded.\nIt is exactly like the current system and a lazy miner.\n\n> How would we know how 'busy' the mempool was at the time a brick from months or years ago was mined?\n\nI dont understand the question, but i guess it is the same answer replacing bricks for blocks\n\n> Nodes have to be able to run through the entire history of the blockchain and check everything is valid. They have to do this using only the previous blocks they've already validated - they won't have historical snapshots of the mempool (they'll build and mutate a UTXO set, but that's different). Transactions don't contain a 'created-at' time that you could compare to the block's creation time (and if they did, you probably couldn't trust it).\n\nWhy does this question apply to the concept of bricks and not to the concept of block?\n\nI see a resulting blockchain would be a chain of blocks and bricks:\nBi = Block at height i\nbi = brick at height i\n\nChain of blocks and bricks:\nB1 <- B2 < b3,1 <- b3,2 <- b3,3 <- B4 <- B5 <- b6,1 <- b6,2 <- B7 ...\n--------------------------- -----------------\nequivalent to B3 eq to B6\n\n> With the current system, Nodes can calculate what the difficulty should be for every block based on those previous blocks' times and difficulties - but how would you know an old brick was valid if its difficulty was low but at the time the mempool was busy, vs. getting a fraudulent brick that is actually invalid because there isn't enough work in it? You can't solve this by adding some mempoolsize field to bricks, as you'd have to blindly trust miners not to lie about them.\n\nThe moment a non fully brick arrives to a node it is considered a complete brickchain and would be treated as a block.\n\nyou start working on a brick it can't be filled, you find the mempool empty or want to send it for any reason. It constitutes a valid brickchain because it has 1 brick with only the last brick not completely filled, the rest of previous bricks (0 in this corner case) are fully filled.\n\n> If we can't be (fairly) certain that a miner put a minimum amount of work into finding a hash, then you lose all the strengths of PoW.\n\nThe PoW is still working the same because al the brickchain is accepted or rejected by a miner in an atomic way (i.e. as a block, with an aggregated PoW that must beat other possible blocks to stay in the longest chain).\n\n> If you weaken the difficulty requirement which is there so that mining blocks is hard so that it is very hard to intentionally fork the chain, re-mine previous blocks, overtake the other fork, and get the network to re-org onto your chain - then there's no Proof of work undergirding consensus in the ledger's state.\n\nif the brickchain is treated as an indivisible structure once is fully received there is no difference with the strengtt of blocks.\nThe technique doesn't weaken, it spreads in time, but every 10 minutes the amount of energy invested in the whole brickchain is what counts.\n\n> Secondly, where does the block reward go? Do brick miners get a fraction of the reward proportionate to the fraction of the difficulty they got to? Later when bricks become part of a block, who gets the block reward for that complete block? Who gets the fees? No miner is going to bother mining a merge-bricks-into-block block if the reward isn't the same or better than just mining a regular block, but each miner of the bricks in it would also want a reward. But, we can't give them both a block reward as that'd increase Bitcoin's issuance rate, which might be the only thing people are more strongly opposed to than increasing the blocksize! xD\n\nthe coinbase tx can go in the first brick. (only in one brick of the brickchain)\n\nSince 1 brickchain it is treated as 1 block, the coinbase tx can be the first one in the first brick.\n\nreward only happens when the block is buried in the blockchain.\nIn the same way, reward happens when the complete brickchain is buried in the block/brickchain.\n\n>> At this point, instead of discarding transactions, our miner would start working on a new brick B1, linked with B0 as usual.\n>>\n>> Nodes would allow incoming regular blocks and bricks with hashes that don't satisfy the difficulty rule, provided the brick is fully filled of transactions. Bricks not fully filled would be rejected as invalid to prevent spam (except if constitutes the last brick of a brickchain, explained below).\n>>\n>> Let's assume that 10 minutes have elapsed and our miner is in a state where N bricks have been produced and the accumulated PoW calculated using mathematics (every brick contains a 'minimum hash found', when a series of 'minimum hashes' is computationally equivalent to the network difficulty is then the full 'brickchain' is valid as a Block.\n>\n> But the brick sidechain has to become part of the main blockchain - and as you've got N bricks in the time that there should be 1 block, and each brick is a full block, it feels like this is just a convoluted way to increase the blocksize? Every transaction has to be in the ledger somewhere to be confirmed, so even if the block itself is small and stored references to the bricks, Nodes are going to have to use storage to keep all those full bricks.\n\nexcept that bigblocks are, as i mentioned earlier, sent at once.\n\nwhile this model is more like streaming a block (spread the data in time)\n\n> It also seems that you'd have to require the bricks sidechain to always be merged into the next actual block - it wouldn't work if the brick chain could keep growing and at the same time the actual blockchain advances (because there'd be risks of double-spends where one tx is in the brick chain and the other in the new block). Which I think further makes this feel like a roundabout way of increasing the blocksize\n\nnot merged,\n\nthe brickchain would be appended to the previous (block or brickchain) of the main chain (I don't know how to call it now lol)\n\n> Despite my critique, this was interesting to think about - and hopefully this is useful (and hopefully I've not seriously misunderstood or said something dumb)\n\nThanks for your considerations. I am defending the idea in real time.\nperhaps in one of those I am caught in a impossibility, until then, let's try to find the catch, it it exists. : )\n\nMarcos\n\n> Angus\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/1258d3d8/attachment-0001.html>"
            },
            {
                "author": "Bryan Bishop",
                "date": "2022-10-19T13:54:11",
                "message_text_only": "Hi,\n\nOn Wed, Oct 19, 2022 at 6:34 AM mm-studios via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Fully filled brick B0, with a hash that doesn't meet the difficulty rule,\n> would be broadcasted and nodes would have it on in a separate fork as usual.\n>\n\nCheck out the previous \"weak block\" proposals:\nhttps://diyhpl.us/~bryan/irc/bitcoin/weak-blocks-links.2016-05-09.txt\n\n- Bryan\nhttps://twitter.com/kanzure\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/9ba51851/attachment.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2022-10-19T14:24:48",
                "message_text_only": "> currently, a miner produce blocks with a limited capacity of transactions\nthat ultimately limits the global settlement throughput to a reduced number\nof tx/s.\n\nreduced settlement speed is a desirable feature and isn't something we need\nto fix\n\nthe focus should be on layer 2 protocols that allow the ability to hold &\ntransfer, uncommitted transactions as pools / joins, so that layer 1's\ndecentralization and incentives can remain undisturbed\n\nprotocols like mweb, for example\n\n\n\n\nOn Wed, Oct 19, 2022 at 7:34 AM mm-studios via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi Bitcoin devs,\n> I'd like to share an idea of a method to increase throughput in the\n> bitcoin network.\n>\n> Currently, a miner produce blocks with a limited capacity of transactions\n> that ultimately limits the global settlement throughput to a reduced number\n> of tx/s.\n>\n> Big-blockers proposed the removal of limits but this didn't come with\n> undesirable effects that have been widely discussed and rejected.\n>\n> The main feature we wanted to preserve is 'small blocks', providing\n> 'better network effects' I won't focus on them.\n>\n> The problem with small blocks is that, once a block is filled\n> transactions, they are kept back in the mempool, waiting for their turn in\n> future blocks.\n>\n> The following changes in the protocol aim to let all transactions go in\n> the current block, while keeping the block size small. It requires changes\n> in the PoW algorithm.\n>\n> Currently, the PoW algorithm consists on finding a valid hash for the\n> block. Its validity is determined by comparing the numeric value of the\n> block hash with a protocol-defined value difficulty.\n>\n> Once a miner finds a nonce for the block that satisfies the condition the\n> new block becomes valid and can be propagated. All nodes would update their\n> blockchains with it. (assuming no conflict resolution (orphan blocks, ...)\n> for clarity).\n>\n> This process is meant to happen every 10 minutes in average.\n>\n> With this background information (we all already know) I go on to describe\n> the idea:\n>\n> Let's allow a miner to include transactions until the block is filled,\n> let's call this structure (coining a new term 'Brick'), B0. [brick=block\n> that doesn't meet the difficulty rule and is filled of tx to its full\n> capacity]\n> Since PoW hashing is continuously active, Brick B0 would have a nonce\n> corresponding to a minimum numeric value of its hash found until it got\n> filled.\n>\n> Fully filled brick B0, with a hash that doesn't meet the difficulty rule,\n> would be broadcasted and nodes would have it on in a separate fork as usual.\n>\n> At this point, instead of discarding transactions, our miner would start\n> working on a new brick B1, linked with B0 as usual.\n>\n> Nodes would allow incoming regular blocks and bricks with hashes that\n> don't satisfy the difficulty rule, provided the brick is fully filled of\n> transactions. Bricks not fully filled would be rejected as invalid to\n> prevent spam (except if constitutes the last brick of a brickchain,\n> explained below).\n>\n> Let's assume that 10 minutes have elapsed and our miner is in a state\n> where N bricks have been produced and the accumulated PoW calculated using\n> mathematics (every brick contains a 'minimum hash found', when a series of\n> 'minimum hashes' is computationally equivalent to the network difficulty is\n> then the full 'brickchain' is valid as a Block.\n>\n> This calculus shall be better defined, but I hope that this idea can serve\n> as a seed to a BIP, or otherwise deemed absurd, which might be possible and\n> I'd be delighted to discover why a scheme like this wouldn't work.\n>\n> If it finally worked, it could completely flush mempools, keep\n> transactions fees low and increase throughput without an increase in the\n> block size that would raise other concerns related to propagation.\n>\n> Thank you.\n> I look forward to your responses.\n>\n> --\n> Marcos Mayorga\n> https://twitter.com/KatlasC\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/8928d1f7/attachment-0001.html>"
            },
            {
                "author": "mm-studios",
                "date": "2022-10-19T16:03:45",
                "message_text_only": "Thanks all for your responses.\nso is it a no-go is because \"reduced settlement speed is a desirable feature\"?\n\nI don';t know what weights more in this consideration:\nA) to not increase the workload of full-nodes, being \"less difficult to operate\" and hence reduce the chance of some of them giving up which would lead to a negative centralization effect. (a bit cumbersome reasoning in my opinion, given the competitive nature of PoW itself, which introduce an accepted centralization, forcing some miners to give up). In this case the fact is accepted because is decentralized enough.\nB) to not undermine L2 systems like LN.\n\nin any case it is a major no-go reason, if there is not intention to speed up L1.\nThanks\nM\n\n------- Original Message -------\nOn Wednesday, October 19th, 2022 at 3:24 PM, Erik Aronesty <erik at q32.com> wrote:\n\n>> currently, a miner produce blocks with a limited capacity of transactions that ultimately limits the global settlement throughput to a reduced number of tx/s.\n>\n> reduced settlement speed is a desirable feature and isn't something we need to fix\n>\n> the focus should be on layer 2 protocols that allow the ability to hold & transfer, uncommitted transactions as pools / joins, so that layer 1's decentralization and incentives can remain undisturbed\n>\n> protocols like mweb, for example\n>\n> On Wed, Oct 19, 2022 at 7:34 AM mm-studios via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Bitcoin devs,\n>> I'd like to share an idea of a method to increase throughput in the bitcoin network.\n>>\n>> Currently, a miner produce blocks with a limited capacity of transactions that ultimately limits the global settlement throughput to a reduced number of tx/s.\n>>\n>> Big-blockers proposed the removal of limits but this didn't come with undesirable effects that have been widely discussed and rejected.\n>>\n>> The main feature we wanted to preserve is 'small blocks', providing 'better network effects' I won't focus on them.\n>>\n>> The problem with small blocks is that, once a block is filled transactions, they are kept back in the mempool, waiting for their turn in future blocks.\n>>\n>> The following changes in the protocol aim to let all transactions go in the current block, while keeping the block size small. It requires changes in the PoW algorithm.\n>>\n>> Currently, the PoW algorithm consists on finding a valid hash for the block. Its validity is determined by comparing the numeric value of the block hash with a protocol-defined value difficulty.\n>>\n>> Once a miner finds a nonce for the block that satisfies the condition the new block becomes valid and can be propagated. All nodes would update their blockchains with it. (assuming no conflict resolution (orphan blocks, ...) for clarity).\n>>\n>> This process is meant to happen every 10 minutes in average.\n>>\n>> With this background information (we all already know) I go on to describe the idea:\n>>\n>> Let's allow a miner to include transactions until the block is filled, let's call this structure (coining a new term 'Brick'), B0. [brick=block that doesn't meet the difficulty rule and is filled of tx to its full capacity]\n>> Since PoW hashing is continuously active, Brick B0 would have a nonce corresponding to a minimum numeric value of its hash found until it got filled.\n>>\n>> Fully filled brick B0, with a hash that doesn't meet the difficulty rule, would be broadcasted and nodes would have it on in a separate fork as usual.\n>>\n>> At this point, instead of discarding transactions, our miner would start working on a new brick B1, linked with B0 as usual.\n>>\n>> Nodes would allow incoming regular blocks and bricks with hashes that don't satisfy the difficulty rule, provided the brick is fully filled of transactions. Bricks not fully filled would be rejected as invalid to prevent spam (except if constitutes the last brick of a brickchain, explained below).\n>>\n>> Let's assume that 10 minutes have elapsed and our miner is in a state where N bricks have been produced and the accumulated PoW calculated using mathematics (every brick contains a 'minimum hash found', when a series of 'minimum hashes' is computationally equivalent to the network difficulty is then the full 'brickchain' is valid as a Block.\n>>\n>> This calculus shall be better defined, but I hope that this idea can serve as a seed to a BIP, or otherwise deemed absurd, which might be possible and I'd be delighted to discover why a scheme like this wouldn't work.\n>>\n>> If it finally worked, it could completely flush mempools, keep transactions fees low and increase throughput without an increase in the block size that would raise other concerns related to propagation.\n>>\n>> Thank you.\n>> I look forward to your responses.\n>>\n>> --\n>> Marcos Mayorgahttps://twitter.com/KatlasC\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/af9160f1/attachment.html>"
            },
            {
                "author": "G. Andrew Stone",
                "date": "2022-10-19T21:34:43",
                "message_text_only": "Consider that a miner can also produce transactions.  So every miner would\nproduce spam tx to fill their bricks at the minimum allowed difficulty to\nreap the brick coinbase reward.\n\nYou might quickly respond with a modification that changes or eliminates\nthe brick coinbase reward, but perhaps that exact reward and the major\nnegative consequence of miners creating spam tx needs careful thought.\n\nSee \"bobtail\" for a weak block proposal that produces a more consistent\ndiscovery time, and \"tailstorm\" for a proposal that uses the content of\nthose weak blocks as commitment to what transactions miners are working on\n(which will allow more trustworthy (but still not foolproof) use of\ntransactions before confirmation)... neither of which have a snowball's\nchance in hell (along with any other hard forking change) of being put into\nbitcoin :-).\n\nAndrew\n\nOn Wed, Oct 19, 2022 at 12:05 PM mm-studios via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks all for your responses.\n> so is it a no-go is because \"reduced settlement speed is a desirable\n> feature\"?\n>\n> I don';t know what weights more in this consideration:\n> A) to not increase the workload of full-nodes, being \"less difficult to\n> operate\" and hence reduce the chance of some of them giving up which would\n> lead to a negative centralization effect. (a bit cumbersome reasoning in my\n> opinion, given the competitive nature of PoW itself, which introduce an\n> accepted centralization, forcing some miners to give up). In this case the\n> fact is accepted because is decentralized enough.\n> B) to not undermine L2 systems like LN.\n>\n> in any case it is a major no-go reason, if there is not intention to speed\n> up L1.\n> Thanks\n> M\n> ------- Original Message -------\n> On Wednesday, October 19th, 2022 at 3:24 PM, Erik Aronesty <erik at q32.com>\n> wrote:\n>\n> > currently, a miner produce blocks with a limited capacity of\n> transactions that ultimately limits the global settlement throughput to a\n> reduced number of tx/s.\n>\n> reduced settlement speed is a desirable feature and isn't something we\n> need to fix\n>\n> the focus should be on layer 2 protocols that allow the ability to hold &\n> transfer, uncommitted transactions as pools / joins, so that layer 1's\n> decentralization and incentives can remain undisturbed\n>\n> protocols like mweb, for example\n>\n>\n>\n>\n> On Wed, Oct 19, 2022 at 7:34 AM mm-studios via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hi Bitcoin devs,\n>> I'd like to share an idea of a method to increase throughput in the\n>> bitcoin network.\n>>\n>> Currently, a miner produce blocks with a limited capacity of transactions\n>> that ultimately limits the global settlement throughput to a reduced number\n>> of tx/s.\n>>\n>> Big-blockers proposed the removal of limits but this didn't come with\n>> undesirable effects that have been widely discussed and rejected.\n>>\n>> The main feature we wanted to preserve is 'small blocks', providing\n>> 'better network effects' I won't focus on them.\n>>\n>> The problem with small blocks is that, once a block is filled\n>> transactions, they are kept back in the mempool, waiting for their turn in\n>> future blocks.\n>>\n>> The following changes in the protocol aim to let all transactions go in\n>> the current block, while keeping the block size small. It requires changes\n>> in the PoW algorithm.\n>>\n>> Currently, the PoW algorithm consists on finding a valid hash for the\n>> block. Its validity is determined by comparing the numeric value of the\n>> block hash with a protocol-defined value difficulty.\n>>\n>> Once a miner finds a nonce for the block that satisfies the condition the\n>> new block becomes valid and can be propagated. All nodes would update their\n>> blockchains with it. (assuming no conflict resolution (orphan blocks, ...)\n>> for clarity).\n>>\n>> This process is meant to happen every 10 minutes in average.\n>>\n>> With this background information (we all already know) I go on to\n>> describe the idea:\n>>\n>> Let's allow a miner to include transactions until the block is filled,\n>> let's call this structure (coining a new term 'Brick'), B0. [brick=block\n>> that doesn't meet the difficulty rule and is filled of tx to its full\n>> capacity]\n>> Since PoW hashing is continuously active, Brick B0 would have a nonce\n>> corresponding to a minimum numeric value of its hash found until it got\n>> filled.\n>>\n>> Fully filled brick B0, with a hash that doesn't meet the difficulty rule,\n>> would be broadcasted and nodes would have it on in a separate fork as usual.\n>>\n>> At this point, instead of discarding transactions, our miner would start\n>> working on a new brick B1, linked with B0 as usual.\n>>\n>> Nodes would allow incoming regular blocks and bricks with hashes that\n>> don't satisfy the difficulty rule, provided the brick is fully filled of\n>> transactions. Bricks not fully filled would be rejected as invalid to\n>> prevent spam (except if constitutes the last brick of a brickchain,\n>> explained below).\n>>\n>> Let's assume that 10 minutes have elapsed and our miner is in a state\n>> where N bricks have been produced and the accumulated PoW calculated using\n>> mathematics (every brick contains a 'minimum hash found', when a series of\n>> 'minimum hashes' is computationally equivalent to the network difficulty is\n>> then the full 'brickchain' is valid as a Block.\n>>\n>> This calculus shall be better defined, but I hope that this idea can\n>> serve as a seed to a BIP, or otherwise deemed absurd, which might be\n>> possible and I'd be delighted to discover why a scheme like this wouldn't\n>> work.\n>>\n>> If it finally worked, it could completely flush mempools, keep\n>> transactions fees low and increase throughput without an increase in the\n>> block size that would raise other concerns related to propagation.\n>>\n>> Thank you.\n>> I look forward to your responses.\n>>\n>> --\n>> Marcos Mayorga\n>> https://twitter.com/KatlasC\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/335c8792/attachment.html>"
            },
            {
                "author": "mm-studios",
                "date": "2022-10-19T22:53:54",
                "message_text_only": "------- Original Message -------\nOn Wednesday, October 19th, 2022 at 10:34 PM, G. Andrew Stone <g.andrew.stone at gmail.com> wrote:\n\n> Consider that a miner can also produce transactions. So every miner would produce spam tx to fill their bricks at the minimum allowed difficulty to reap the brick coinbase reward.\n\nexcept that, as I explained in a prev email, bricks don't contain reward. They are meaningless unless they form a complete brickchain with an accumulated difficulty that is equivalent to current block difficulty.\n\n> You might quickly respond with a modification that changes or eliminates the brick coinbase reward, but perhaps that exact reward and the major negative consequence of miners creating spam tx needs careful thought.\n\nsince 1 block is equivalent to a brickchain, there exist only 1 coinbase tx\nand since the brickchain is treated atomically as a whole, it follows the same processing as a block.\nThe only observable difference (and the reason of augmentating throughput) in the wire is that the information has been transmitted in streaming (decomposed block spaced in time)\n\n> See \"bobtail\" for a weak block proposal that produces a more consistent discovery time, and \"tailstorm\" for a proposal that uses the content of those weak blocks as commitment to what transactions miners are working on (which will allow more trustworthy (but still not foolproof) use of transactions before confirmation)... neither of which have a snowball's chance in hell (along with any other hard forking change) of being put into bitcoin :-).\n\nthanks\nMarcos\n\n> Andrew\n>\n> On Wed, Oct 19, 2022 at 12:05 PM mm-studios via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Thanks all for your responses.\n>> so is it a no-go is because \"reduced settlement speed is a desirable feature\"?\n>>\n>> I don';t know what weights more in this consideration:\n>> A) to not increase the workload of full-nodes, being \"less difficult to operate\" and hence reduce the chance of some of them giving up which would lead to a negative centralization effect. (a bit cumbersome reasoning in my opinion, given the competitive nature of PoW itself, which introduce an accepted centralization, forcing some miners to give up). In this case the fact is accepted because is decentralized enough.\n>> B) to not undermine L2 systems like LN.\n>>\n>> in any case it is a major no-go reason, if there is not intention to speed up L1.\n>> Thanks\n>> M\n>>\n>> ------- Original Message -------\n>> On Wednesday, October 19th, 2022 at 3:24 PM, Erik Aronesty <erik at q32.com> wrote:\n>>\n>>>> currently, a miner produce blocks with a limited capacity of transactions that ultimately limits the global settlement throughput to a reduced number of tx/s.\n>>>\n>>> reduced settlement speed is a desirable feature and isn't something we need to fix\n>>>\n>>> the focus should be on layer 2 protocols that allow the ability to hold & transfer, uncommitted transactions as pools / joins, so that layer 1's decentralization and incentives can remain undisturbed\n>>>\n>>> protocols like mweb, for example\n>>>\n>>> On Wed, Oct 19, 2022 at 7:34 AM mm-studios via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>>> Hi Bitcoin devs,\n>>>> I'd like to share an idea of a method to increase throughput in the bitcoin network.\n>>>>\n>>>> Currently, a miner produce blocks with a limited capacity of transactions that ultimately limits the global settlement throughput to a reduced number of tx/s.\n>>>>\n>>>> Big-blockers proposed the removal of limits but this didn't come with undesirable effects that have been widely discussed and rejected.\n>>>>\n>>>> The main feature we wanted to preserve is 'small blocks', providing 'better network effects' I won't focus on them.\n>>>>\n>>>> The problem with small blocks is that, once a block is filled transactions, they are kept back in the mempool, waiting for their turn in future blocks.\n>>>>\n>>>> The following changes in the protocol aim to let all transactions go in the current block, while keeping the block size small. It requires changes in the PoW algorithm.\n>>>>\n>>>> Currently, the PoW algorithm consists on finding a valid hash for the block. Its validity is determined by comparing the numeric value of the block hash with a protocol-defined value difficulty.\n>>>>\n>>>> Once a miner finds a nonce for the block that satisfies the condition the new block becomes valid and can be propagated. All nodes would update their blockchains with it. (assuming no conflict resolution (orphan blocks, ...) for clarity).\n>>>>\n>>>> This process is meant to happen every 10 minutes in average.\n>>>>\n>>>> With this background information (we all already know) I go on to describe the idea:\n>>>>\n>>>> Let's allow a miner to include transactions until the block is filled, let's call this structure (coining a new term 'Brick'), B0. [brick=block that doesn't meet the difficulty rule and is filled of tx to its full capacity]\n>>>> Since PoW hashing is continuously active, Brick B0 would have a nonce corresponding to a minimum numeric value of its hash found until it got filled.\n>>>>\n>>>> Fully filled brick B0, with a hash that doesn't meet the difficulty rule, would be broadcasted and nodes would have it on in a separate fork as usual.\n>>>>\n>>>> At this point, instead of discarding transactions, our miner would start working on a new brick B1, linked with B0 as usual.\n>>>>\n>>>> Nodes would allow incoming regular blocks and bricks with hashes that don't satisfy the difficulty rule, provided the brick is fully filled of transactions. Bricks not fully filled would be rejected as invalid to prevent spam (except if constitutes the last brick of a brickchain, explained below).\n>>>>\n>>>> Let's assume that 10 minutes have elapsed and our miner is in a state where N bricks have been produced and the accumulated PoW calculated using mathematics (every brick contains a 'minimum hash found', when a series of 'minimum hashes' is computationally equivalent to the network difficulty is then the full 'brickchain' is valid as a Block.\n>>>>\n>>>> This calculus shall be better defined, but I hope that this idea can serve as a seed to a BIP, or otherwise deemed absurd, which might be possible and I'd be delighted to discover why a scheme like this wouldn't work.\n>>>>\n>>>> If it finally worked, it could completely flush mempools, keep transactions fees low and increase throughput without an increase in the block size that would raise other concerns related to propagation.\n>>>>\n>>>> Thank you.\n>>>> I look forward to your responses.\n>>>>\n>>>> --\n>>>> Marcos Mayorgahttps://twitter.com/KatlasC\n>>>>\n>>>> _______________________________________________\n>>>> bitcoin-dev mailing list\n>>>> bitcoin-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221019/ed48ee46/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "brickchain",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "mm-studios",
                "Bryan Bishop",
                "angus",
                "Erik Aronesty",
                "G. Andrew Stone"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 44189
        }
    },
    {
        "title": "[bitcoin-dev] Analysis of full-RBF deployment methods",
        "thread_messages": [
            {
                "author": "Dario Sneidermanis",
                "date": "2022-10-20T16:51:24",
                "message_text_only": "Hello list,\n\nGiven that the release of 24.0 is upon us and there is little time to make a\ncomplex decision regarding the deployment method of full-RBF, we've\ndocumented\nthe different alternatives and their trade-offs. I hope this helps get to\nthe\nbest possible deployment!\n\nGist: https://gist.github.com/esneider/4eb16fcd959cb8c6b657c314442801ee\n\n# Current deployment options\n\n1. Antoine's PR #26305: leave 24.0 as is, and merge opt-out in 25.0 or\nlater.\n2. Marco's PR #26287: revert opt-in full-RBF in 24.0, and give more time to\n   figure out what's next.\n3. Marco's PR #26287 + Antoine's PR #26305: revert opt-in full-RBF in 24.0,\nand\n   merge opt-out in 25.0 or later.\n4. Marco's PR #26287 + Anthony's PR #26323 (just the date commitment):\nrevert\n   opt-in full-RBF in 24.0, and commit in 25.0 or later to a later date for\n   opt-out activation.\n5. Anthony's PR #26323: revert opt-in full-RBF in 24.0, and commit in 24.0\nto a\n   later date for opt-out activation.\n\nNotice that once full-RBF is fully deployed, having a config option to\ndisable\nit is mostly a foot gun: you will only hurt yourself by missing some\ntransactions. Maybe options 4 and 5 could remove the flag altogether\ninstead of\nmaking it opt-out.\n\nThere are a few more options, but I don't think they would reasonably have\nany\nconsensus, so I trimmed them down to make it easier to process.\n\n\n# Dimensions of analysis\n\n1. Zero-conf apps immediately affected\n\n    If we leave the flag for full-rbf in 24.0, zero-conf apps could be\n    immediately affected. More specifically, as Anthony explained much more\n    clearly [0], they would be in danger as soon as a relatively big mining\n    pool operator enables the full-RBF flag.\n\n    It turns out that the class of apps that could be immediately affected\n(ie.\n    apps that were directly or indirectly relying on the first-seen policy\nin an\n    adversarial setting) is larger than zero-conf apps, as exposed by Sergej\n    [1]. Namely, the apps committing to an exchange rate before on-chain\nfunds\n    are sent/finalized would start offering a free(ish) american call\noption.\n\n2. Predictable deployment date\n\n    Committing to an activation date for full-rbf on the social layer (eg.\n    \"we'll merge the opt-out flag in 25.0\") has the benefit of being\nflexible in\n    the event of new data points but becomes less predictable (both for\n    applications and for full-rbf proponents).\n\n    Committing to an activation date for full-rbf on the code has the\nbenefit\n    that once node operators start deploying the code, the date is set in\nstone,\n    and we can reason about when full-RBF will be fully deployed and usable.\n\n3. Code complexity\n\n    Handling the commitment to a date in the code introduces further code\n    complexity. In particular, it's a deployment mechanism that, as far as I\n    know, hasn't been tried before, so we should be careful.\n\n4. Smooth deployment\n\n    Full-RBF deployment has two distinct phases when analyzing the adoption\nin\n    the transaction relaying layer. First, there will be multiple disjoint\n    connected components of full-RBF nodes. Eventually, we'll get to a\n    single(ish) connected component of full-RBF nodes.\n\n    The first deployment phase is a bit chaotic and difficult to reason\nabout:\n    nobody can rely on full-RBF actually working; if it coincides with a\n    high-fees scenario, we'll get a big mempool divergence event, causing\nmany\n    other issues and unreliability in the relaying and application layers.\n\n    I'm calling smooth deployment to a deployment that minimizes the first\n    phase, eg. by activating full-RBF simultaneously in as many\n    transaction-relaying nodes as possible.\n\n5. Time to figure out the right deployment\n\n    Figuring out the right deployment method and timeline to activate\nfull-rbf\n    might be more time-consuming than what we are willing to wait for the\nstable\n    release of 24.0. Decoupling the protection to zero-conf apps from\nchoosing a\n    deployment method and an activation date for opt-out might be a good\nidea.\n\nI'm probably forgetting some dimensions here, but it may be enough to grasp\nthe\ntrade-offs between the different approaches.\n\n\n# Comparison\n\nGist:\nhttps://gist.github.com/esneider/4eb16fcd959cb8c6b657c314442801ee#comparison\n\n# Timeline for full-RBF activation\n\nIf we make some UX trade-offs, Muun can be production ready with the\nrequired\nchanges in 6 months. Having more time to avoid those trade-offs would be\npreferable, but we can manage.\n\nThe larger application ecosystem may need a bit more time since they might\nnot\nhave the advantage of having been working on the required changes for a\nwhile\nalready. Ideally, there should be enough time to reach out to affected\napplications and let them make time to understand the impact, design\nsolutions,\nimplement them, and deploy them.\n\nFinally, if a smooth deployment (as previously defined) is desired, we can\nlock\nan activation date in the code and give relaying nodes enough time to\nupgrade\nbefore activation. Assuming that the adoption of future releases remains\nsimilar\nto previous ones [2], one release cycle should get us to 22% adoption, two\nrelease cycles to 61% adoption, and three release cycles to 79% adoption.\nAssuming a uniform adoption distribution, the probability of an 8-connection\nrelaying node not being connected to any full-RBF node after one release\ncycle\nwill be 0.14. After two cycles, it will be 0.00054, and after three cycles,\nit\nwill be 0.0000038. Looking at these numbers, it would seem that a single\nrelease\ncycle will be too little time, but two release cycles may be enough.\n\nCheers,\nDario\n\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021031.html\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021056.html\n[2] https://luke.dashjr.org/programs/bitcoin/files/charts/software.html\n[Marco's PR #26287] https://github.com/bitcoin/bitcoin/pull/26287\n[Antoine's PR #26305] https://github.com/bitcoin/bitcoin/pull/26305\n[Anthony's PR #26323] https://github.com/bitcoin/bitcoin/pull/26323\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/d44995aa/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-21T01:50:30",
                "message_text_only": "Hi Dario,\n\nThanks for this analysis of full-RBF deployment methods!\n\nThe subject was widely discussed at today Bitcoin Core IRC meetings:\nhttps://gnusha.org/bitcoin-core-dev/2022-10-20.log\n\nPersonally, I still think deferring full-rbf deployment, while it sounds\nreasonable to let existing services and applications adapt their software\nand business models, doesn't come risk-free for the contracting protocols\nand multi-party applications affected by the pinning DoS vector. Deferring\nad vitam aeternam left them exposed to disruptions when their traffic\nvolume would start to be significant. While those use-cases\n(splicing/dual-channels/collaborative constructions) were mostly vaporware\na year ago when I raised the issue, it turns out they have become a far\nmore tangible reality today. Beyond the 3 coinjoins services\n(Wasabi/Joinmarket/Whirlpool), we have new things like ln-vortex, or\nPhoenix wallet and some LDK users planning to use dual-funded soon.\n\nI'm fully aware we still have community stakeholders opposing full-rbf on\nprinciple, I think this is highly valuable to exchange more perspectives on\nthe subject, hopefully to harmonize understandings, and work altogether on\ncreative solutions to accommodate as many use-cases as we can, in a\ncompatible way.\n\nI don't know what the best full-rbf deployment method is, though one\noffering clear visibility and predictability to node operators, with a flag\nday activation like #26323 sounds like a reasonable one. As you said, I\nbelieve 6 months from now is far too short, maybe something like 12 months\nor 16 months (or more ?) is adequate. At least I fully rejoin on the risk\nof merchants centralization if we favor a timeline only favoring entities\nwith sufficient manpower.\n\nI'm still looking forward to having more forums and communication channels\nbetween business/services operators and protocol developers, it sounds like\nfunctional responsibilities between protocol and application layers could\nbe better clarified. However, I don't know if it should be the\nresponsibility of developers to solve every operational risk encumbered by\na Bitcoin business, like FX risk. I don't deny the interdependency between\nnetwork policy rules and business risk, I'm just saying Bitcoin protocol\ndevelopers have already heavily loaded engineering priorities between\nsolving the half of dozen of Lightning vulnerabilities, working on the next\nconsensus changes or reviewing modularity refactoring of Bitcoin Core to\nextend the feature set in a soft way (among tons of other examples).\n\nAll speaking for myself, looking forward to having more perspective\nexpressed!\n\nBest,\nAntoine\n\nLe jeu. 20 oct. 2022 \u00e0 12:56, Dario Sneidermanis via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hello list,\n>\n> Given that the release of 24.0 is upon us and there is little time to make\n> a\n> complex decision regarding the deployment method of full-RBF, we've\n> documented\n> the different alternatives and their trade-offs. I hope this helps get to\n> the\n> best possible deployment!\n>\n> Gist: https://gist.github.com/esneider/4eb16fcd959cb8c6b657c314442801ee\n>\n> # Current deployment options\n>\n> 1. Antoine's PR #26305: leave 24.0 as is, and merge opt-out in 25.0 or\n> later.\n> 2. Marco's PR #26287: revert opt-in full-RBF in 24.0, and give more time to\n>    figure out what's next.\n> 3. Marco's PR #26287 + Antoine's PR #26305: revert opt-in full-RBF in\n> 24.0, and\n>    merge opt-out in 25.0 or later.\n> 4. Marco's PR #26287 + Anthony's PR #26323 (just the date commitment):\n> revert\n>    opt-in full-RBF in 24.0, and commit in 25.0 or later to a later date for\n>    opt-out activation.\n> 5. Anthony's PR #26323: revert opt-in full-RBF in 24.0, and commit in 24.0\n> to a\n>    later date for opt-out activation.\n>\n> Notice that once full-RBF is fully deployed, having a config option to\n> disable\n> it is mostly a foot gun: you will only hurt yourself by missing some\n> transactions. Maybe options 4 and 5 could remove the flag altogether\n> instead of\n> making it opt-out.\n>\n> There are a few more options, but I don't think they would reasonably have\n> any\n> consensus, so I trimmed them down to make it easier to process.\n>\n>\n> # Dimensions of analysis\n>\n> 1. Zero-conf apps immediately affected\n>\n>     If we leave the flag for full-rbf in 24.0, zero-conf apps could be\n>     immediately affected. More specifically, as Anthony explained much more\n>     clearly [0], they would be in danger as soon as a relatively big mining\n>     pool operator enables the full-RBF flag.\n>\n>     It turns out that the class of apps that could be immediately affected\n> (ie.\n>     apps that were directly or indirectly relying on the first-seen policy\n> in an\n>     adversarial setting) is larger than zero-conf apps, as exposed by\n> Sergej\n>     [1]. Namely, the apps committing to an exchange rate before on-chain\n> funds\n>     are sent/finalized would start offering a free(ish) american call\n> option.\n>\n> 2. Predictable deployment date\n>\n>     Committing to an activation date for full-rbf on the social layer (eg.\n>     \"we'll merge the opt-out flag in 25.0\") has the benefit of being\n> flexible in\n>     the event of new data points but becomes less predictable (both for\n>     applications and for full-rbf proponents).\n>\n>     Committing to an activation date for full-rbf on the code has the\n> benefit\n>     that once node operators start deploying the code, the date is set in\n> stone,\n>     and we can reason about when full-RBF will be fully deployed and\n> usable.\n>\n> 3. Code complexity\n>\n>     Handling the commitment to a date in the code introduces further code\n>     complexity. In particular, it's a deployment mechanism that, as far as\n> I\n>     know, hasn't been tried before, so we should be careful.\n>\n> 4. Smooth deployment\n>\n>     Full-RBF deployment has two distinct phases when analyzing the\n> adoption in\n>     the transaction relaying layer. First, there will be multiple disjoint\n>     connected components of full-RBF nodes. Eventually, we'll get to a\n>     single(ish) connected component of full-RBF nodes.\n>\n>     The first deployment phase is a bit chaotic and difficult to reason\n> about:\n>     nobody can rely on full-RBF actually working; if it coincides with a\n>     high-fees scenario, we'll get a big mempool divergence event, causing\n> many\n>     other issues and unreliability in the relaying and application layers.\n>\n>     I'm calling smooth deployment to a deployment that minimizes the first\n>     phase, eg. by activating full-RBF simultaneously in as many\n>     transaction-relaying nodes as possible.\n>\n> 5. Time to figure out the right deployment\n>\n>     Figuring out the right deployment method and timeline to activate\n> full-rbf\n>     might be more time-consuming than what we are willing to wait for the\n> stable\n>     release of 24.0. Decoupling the protection to zero-conf apps from\n> choosing a\n>     deployment method and an activation date for opt-out might be a good\n> idea.\n>\n> I'm probably forgetting some dimensions here, but it may be enough to\n> grasp the\n> trade-offs between the different approaches.\n>\n>\n> # Comparison\n>\n> Gist:\n> https://gist.github.com/esneider/4eb16fcd959cb8c6b657c314442801ee#comparison\n>\n> # Timeline for full-RBF activation\n>\n> If we make some UX trade-offs, Muun can be production ready with the\n> required\n> changes in 6 months. Having more time to avoid those trade-offs would be\n> preferable, but we can manage.\n>\n> The larger application ecosystem may need a bit more time since they might\n> not\n> have the advantage of having been working on the required changes for a\n> while\n> already. Ideally, there should be enough time to reach out to affected\n> applications and let them make time to understand the impact, design\n> solutions,\n> implement them, and deploy them.\n>\n> Finally, if a smooth deployment (as previously defined) is desired, we can\n> lock\n> an activation date in the code and give relaying nodes enough time to\n> upgrade\n> before activation. Assuming that the adoption of future releases remains\n> similar\n> to previous ones [2], one release cycle should get us to 22% adoption, two\n> release cycles to 61% adoption, and three release cycles to 79% adoption.\n> Assuming a uniform adoption distribution, the probability of an\n> 8-connection\n> relaying node not being connected to any full-RBF node after one release\n> cycle\n> will be 0.14. After two cycles, it will be 0.00054, and after three\n> cycles, it\n> will be 0.0000038. Looking at these numbers, it would seem that a single\n> release\n> cycle will be too little time, but two release cycles may be enough.\n>\n> Cheers,\n> Dario\n>\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021031.html\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021056.html\n> [2] https://luke.dashjr.org/programs/bitcoin/files/charts/software.html\n> [Marco's PR #26287] https://github.com/bitcoin/bitcoin/pull/26287\n> [Antoine's PR #26305] https://github.com/bitcoin/bitcoin/pull/26305\n> [Anthony's PR #26323] https://github.com/bitcoin/bitcoin/pull/26323\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221020/ccca834d/attachment.html>"
            },
            {
                "author": "Dario Sneidermanis",
                "date": "2022-10-21T21:13:41",
                "message_text_only": "Hello Antoine,\n\nThanks for taking the time to answer every email with detailed analysis! I\ncan\nsee it's a lot of work. I'll answer inline.\n\nOn Thu, Oct 20, 2022 at 10:50 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n> Personally, I still think deferring full-rbf deployment, while it sounds\n> reasonable to let existing services and applications adapt their software\nand\n> business models, doesn't come risk-free for the contracting protocols and\n> multi-party applications affected by the pinning DoS vector. Deferring ad\n> vitam aeternam left them exposed to disruptions when their traffic volume\n> would start to be significant. While those use-cases\n> (splicing/dual-channels/collaborative constructions) were mostly\nvaporware a\n> year ago when I raised the issue, it turns out they have become a far more\n> tangible reality today. Beyond the 3 coinjoins services\n> (Wasabi/Joinmarket/Whirlpool), we have new things like ln-vortex, or\nPhoenix\n> wallet and some LDK users planning to use dual-funded soon.\n\nTo solve the attack you described in [0], collaborative transaction\nprotocols\n(such as dual-funded channels) need a *reliable* way to replace\ntransactions.\nOtherwise, protocol parties using full-RBF may see replacements succeed in\ntheir\nown mempool, only to find out they weren't relayed to a miner once it's too\nlate\n(ie. once the replacement that won is mined).\n\nI'm calling a full-RBF deployment reliable to the point at which any\nfull-RBF-enabled node can broadcast a replacement and get it relayed all\nthe way\nto a miner in a reliable manner (ie. with high-enough probability).\n\nEven if we deployed opt-out (or mandatory!) full-RBF now and miners adopted\nit\nimmediately, it would take almost a year (assuming normal deployment times)\nfor\nit to be sufficiently deployed in the relaying layer to be considered\nreliable.\nAn opt-in full-RBF deployment, as currently proposed (ie. without #25600),\nhas\nvery little chance of getting us nowhere near that kind of adoption.\n\nNotice that #26323 (option 5 in the OP) has the advantage of getting us to a\nreliable full-RBF network the fastest (in particular, much faster than the\ncurrent opt-in deployment) while not threatening zero-conf applications\nuntil\nthe activation time. That is, #26323 gives us a way in which we don't need\nto\nchoose between the security of one use case versus the other. We can have\nboth.\n\n> I'm still looking forward to having more forums and communication channels\n> between business/services operators and protocol developers, it sounds\nlike\n> functional responsibilities between protocol and application layers could\nbe\n> better clarified. However, I don't know if it should be the\nresponsibility of\n> developers to solve every operational risk encumbered by a Bitcoin\nbusiness,\n> like FX risk. I don't deny the interdependency between network policy\nrules\n> and business risk, I'm just saying Bitcoin protocol developers have\nalready\n> heavily loaded engineering priorities between solving the half of dozen of\n> Lightning vulnerabilities, working on the next consensus changes or\nreviewing\n> modularity refactoring of Bitcoin Core to extend the feature set in a\nsoft way\n> (among tons of other examples).\n\nI don't think asking for a predictable deployment timeline for a change that\nwould put some applications at increased risk could be described as\nburdening\nthe developers with solving every operational risk. This deployment method\ncomparison's goal was precisely to soften the burden on core devs.\n\nCheers,\nDario\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221021/09da7c46/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-23T23:10:16",
                "message_text_only": "Hi Dario,\n\nThanks for providing more thoughts to the discussion!\n\n> Notice that #26323 (option 5 in the OP) has the advantage of getting us\nto a\n> reliable full-RBF network the fastest (in particular, much faster than the\n> current opt-in deployment) while not threatening zero-conf applications\n> until\n> the activation time. That is, #26323 gives us a way in which we don't need\n> to\n> choose between the security of one use case versus the other. We can have\n> both.\n\nFor sure, contracting protocols and multi-party applications exposed by the\nlack of full-rbf are still young overall, though as they attract more\nvolume they're also likely to become honeypots for any competing services\nproviders interested to hijack economic traffic (kinda the same concern\nthan channel jamming...) At the same time, we still have 0confs services\nmore exposed by full-rbf, a bit stuck between Scylla and Charybdis.\n\nAs commented on #26323, I'm personally fine with this approach, and I fully\nopine that providing a clear and predictable time point to 0confs operators\nis very valuable. Even more, I think May 1st 2023, is a bit too early,\n10-12 months sounds more reasonable.\n\nAt the same time, I believe it's the opinion of a few developers and other\nBitcoin service operators that the Core project is taking too much\nresponsibility in taking for the network by shipping full-rbf=true.\n\n(Really I'm 50/50 between those 2 opinions, as I'm the author of both\n#26305 and #25600 and concept ACK on #26323, and any process forward would\nsounds good to me)\n\n> I don't think asking for a predictable deployment timeline for a change\nthat\n> would put some applications at increased risk could be described as\n> burdening\n> the developers with solving every operational risk. This deployment method\n> comparison's goal was precisely to soften the burden on core devs.\n\nI can understand the confusion here. As it has been discussed on your\noriginal thread, from my comprehension, the idea has been raised of a\noptech working group or something to build collaboration between wallet\ndevs, merchant devs and protocol devs around \"Bitcoin payment\" issues like\nFX risk, additional layers of security for 0confs, RBF and CPFP, etc [0].\nWhile again, I reassert that such a multi-stakeholder forum could be really\nfruitful for the ecosystem at large, I don't know if it should be a\nprerequisite that we solve all the potential payment issues before\nproceeding with full-rbf deployment. However I'm keeping aware about the\ninterdependency between full-rbf and operational, legal and business issues\nthat one encounters running a Bitcoin merchant/service, not easy to make\neverything works I can guess.\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021076.html\n\nBest,\nAntoine\n\nLe ven. 21 oct. 2022 \u00e0 17:13, Dario Sneidermanis <dario at muun.com> a \u00e9crit :\n\n> Hello Antoine,\n>\n> Thanks for taking the time to answer every email with detailed analysis! I\n> can\n> see it's a lot of work. I'll answer inline.\n>\n> On Thu, Oct 20, 2022 at 10:50 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n> > Personally, I still think deferring full-rbf deployment, while it sounds\n> > reasonable to let existing services and applications adapt their\n> software and\n> > business models, doesn't come risk-free for the contracting protocols and\n> > multi-party applications affected by the pinning DoS vector. Deferring ad\n> > vitam aeternam left them exposed to disruptions when their traffic volume\n> > would start to be significant. While those use-cases\n> > (splicing/dual-channels/collaborative constructions) were mostly\n> vaporware a\n> > year ago when I raised the issue, it turns out they have become a far\n> more\n> > tangible reality today. Beyond the 3 coinjoins services\n> > (Wasabi/Joinmarket/Whirlpool), we have new things like ln-vortex, or\n> Phoenix\n> > wallet and some LDK users planning to use dual-funded soon.\n>\n> To solve the attack you described in [0], collaborative transaction\n> protocols\n> (such as dual-funded channels) need a *reliable* way to replace\n> transactions.\n> Otherwise, protocol parties using full-RBF may see replacements succeed in\n> their\n> own mempool, only to find out they weren't relayed to a miner once it's\n> too late\n> (ie. once the replacement that won is mined).\n>\n> I'm calling a full-RBF deployment reliable to the point at which any\n> full-RBF-enabled node can broadcast a replacement and get it relayed all\n> the way\n> to a miner in a reliable manner (ie. with high-enough probability).\n>\n> Even if we deployed opt-out (or mandatory!) full-RBF now and miners\n> adopted it\n> immediately, it would take almost a year (assuming normal deployment\n> times) for\n> it to be sufficiently deployed in the relaying layer to be considered\n> reliable.\n> An opt-in full-RBF deployment, as currently proposed (ie. without #25600),\n> has\n> very little chance of getting us nowhere near that kind of adoption.\n>\n> Notice that #26323 (option 5 in the OP) has the advantage of getting us to\n> a\n> reliable full-RBF network the fastest (in particular, much faster than the\n> current opt-in deployment) while not threatening zero-conf applications\n> until\n> the activation time. That is, #26323 gives us a way in which we don't need\n> to\n> choose between the security of one use case versus the other. We can have\n> both.\n>\n> > I'm still looking forward to having more forums and communication\n> channels\n> > between business/services operators and protocol developers, it sounds\n> like\n> > functional responsibilities between protocol and application layers\n> could be\n> > better clarified. However, I don't know if it should be the\n> responsibility of\n> > developers to solve every operational risk encumbered by a Bitcoin\n> business,\n> > like FX risk. I don't deny the interdependency between network policy\n> rules\n> > and business risk, I'm just saying Bitcoin protocol developers have\n> already\n> > heavily loaded engineering priorities between solving the half of dozen\n> of\n> > Lightning vulnerabilities, working on the next consensus changes or\n> reviewing\n> > modularity refactoring of Bitcoin Core to extend the feature set in a\n> soft way\n> > (among tons of other examples).\n>\n> I don't think asking for a predictable deployment timeline for a change\n> that\n> would put some applications at increased risk could be described as\n> burdening\n> the developers with solving every operational risk. This deployment method\n> comparison's goal was precisely to soften the burden on core devs.\n>\n> Cheers,\n> Dario\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221023/ad01768f/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Analysis of full-RBF deployment methods",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Dario Sneidermanis",
                "Antoine Riard"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 26310
        }
    },
    {
        "title": "[bitcoin-dev] On mempool policy consistency",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2022-10-26T23:52:10",
                "message_text_only": "Hi *,\n\nTLDR: Yes, this post is too long, and there's no TLDR. If it's any\nconsolation, it took longer to write than it does to read?\n\nOn Tue, Jun 15, 2021 at 12:55:14PM -0400, Antoine Riard via bitcoin-dev wrote:\n> Subject: Re: [bitcoin-dev] Proposal: Full-RBF in Bitcoin Core 24.0\n> I'm writing to propose deprecation of opt-in RBF in favor of full-RBF\n\n> If there is ecosystem agreement on switching to full-RBF, but 0.24 sounds\n> too early, let's defer it to 0.25 or 0.26. I don't think Core has a\n> consistent deprecation process w.r.t to policy rules heavily relied-on by\n> Bitcoin users, if we do so let sets a precedent satisfying as many folks as\n> we can.\n\nOne precedent that seems to be being set here, which to me seems fairly\nnovel for bitcoin core, is that we're about to start supporting and\nencouraging nodes to have meaningfully different mempool policies. From\nwhat I've seen, the baseline expectation has always been that while\ncertainly mempools can and will differ, policies will be largely the same:\n\n  Firstly, there is no \"the mempool\". There is no global mempool. Rather\n  each node maintains its own mempool and accepts and rejects transaction\n  to that mempool using their own internal policies. Most nodes have\n  the same policies, but due to different start times, relay delays,\n  and other factors, not every node has the same mempool, although they\n  may be very similar.\n\n  - https://bitcoin.stackexchange.com/questions/98585/how-to-find-if-two-transactions-in-mempool-are-conflicting\n\nUp until now, the differences between node policies supported by different\nnodes running core have been quite small, with essentially the following\noptions available:\n\n -minrelaytxfee, -maxmempool - changes the lowest fee rate you'll accept\n\n -mempoolexpiry - how long to keep txs in the mempool\n\n -datacarrier - reject txs creating OP_RETURN outputs\n\n -datacarriersize - maximum size of OP_RETURN data\n\n -permitbaremultisig - prevent relay of bare multisig\n\n -bytespersigop - changes how SIGOP accounting works for relay and\n mining prioritisation\n\nas well as these, marked as \"debug only\" options (only shown with\n-help-debug):\n\n -incrementalrelayfee - make it easier/harder to spam txs by only\n slightly bumping the fee; marked as a \"debug only\" option\n\n -dustrelayfee - make it easier/harder to create uneconomic utxos;\n marked as a \"debug only\" option\n\n -limit{descendant,ancestor}{count,size} - changes how large the\n transaction chains can be; marked as a \"debug only\" option\n\nand in theory, but not available on mainnet:\n\n -acceptnonstdtxn - relay/mine non standard transactions\n\nThere's also the \"prioritisetransaction\" rpc, which can cause you to keep\na low feerate transaction in your mempool longer than you might otherwise.\n\nI think that -minrelaytxfee, -maxmempool and -mempoolexpiry are the only\nones of those options commonly set, and those only rarely result in any\ndifferences in the txs at the top of the mempool.\n\nThere are also quite a few parameters that aren't even runtime\nconfigurable:\n\n - MAX_STANDARD_TX_WEIGHT\n - MIN_STANDARD_TX_NONWITNESS_SIZE (see also #26265)\n - MAX_P2SH_SIGOPS (see also #26348)\n - MAX_STANDARD_TX_SIGOPS_COST\n - MAX_STANDARD_P2WSH_STACK_ITEMS\n - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE\n - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE\n - MAX_STANDARD_P2WSH_SCRIPT_SIZE\n - MAX_STANDARD_SCRIPTSIG_SIZE\n - EXTRA_DESCENDANT_TX_SIZE_LIMIT\n - MAX_REPLACEMENT_CANDIDATES\n\nAnd other plausible options aren't configurable even at compile time\n-- eg, core doesn't implement BIP 125's inherited signalling rule so\nthere's no way to enable it; core doesn't allow opting out of BIP 125\nrule 3 ratchet on absolute fee; core doesn't allow CPFP carveout with\nmore than 1 ancestor; core doesn't allow opting out of LOW_S checks\n(even via -acceptnonstdtxn); etc.\n\nWe also naturally have different mempool policies between different\nreleases: eg, expansions of policy, such as allowing OP_RETURN or\nexpanding it from 40 to 80 bytes or new soft forks where old nodes won't\nrelay transactions that use the new; and also occassional restrictions\nin policy, such as the LOW_S requirement.\n\n\nWhile supporting and encouraging different mempool polices might be new\nfor core, it's not new for knots: knots changes some of these defaults\n(-permitbaremultisig defaults to false, -datacarriersize is reduced to\n42), allows the use of -acceptnonstdtxn on mainnet, and introduces new\noptions including -spkreuse and -mempoolreplacement (giving the latter\nfull rbf behaviour by default). Knots also includes a `-corepolicy`\noption to make it easy to get a configuration matching core's defaults.\n\n\nI think gmaxwell's take from Feb 2015 (in the context of how restrictive\npolicy on OP_RETURN data should be) was a reasonable description for\ncore's approach up until now:\n\n  There is also a matter of driving competent design rather than lazy\n  first thing that works. E.g. In stealth addresses the early proposals\n  use highly inefficient single ECDH point per output instead of simply\n  pooling them. Network behavior is one of the few bits of friction\n  driving good technical design rather than \"move fast, break things, and\n  force everyone else onto my way of doing thing rather than discussing\n  the design in public\". No one wants to be an outright gatekeeper,\n  but the network is a shared resource and it's perfectly reasonable\n  node behavior to be stingy about the perpetual storage impact of the\n  transactions they're willing to process, especially when it comes to\n  neutral technical criteria like the amount of network irrelevant data\n  stuffed in transactions.\n\n  There is also a very clear pattern we've seen in the past where\n  people take anything the system lets them do as strong evidence that\n  they have a irrevocable right to use the system in that way, and that\n  their only responsibility-- and if their usage harms the system it's\n  the responsibility of the system to not permit it. [...\n  ...] For mitigating these risks it's optimal if transactions\n  seem as uniform and indistinguishable as reasonably possible.\n\n  - https://github.com/bitcoin/bitcoin/pull/5286#issuecomment-72564175\n\nPerhaps see also sdaftuar in Nov 2015,\n\n  To me the most important question is, is priority something that miners\n  want to use?\n\n  If a non-negligible amount of hashpower intends to use it in their\n  transaction selection, then I think it makes sense for nodes to use it\n  too, because it's generally helpful to have your mempool predict the\n  UTXO as much as possible, and for nodes to be able to have reasonable\n  fee and priority estimates (which won't happen unless they track the\n  priority transactions somehow -- I'm presuming that miners run with\n  much bigger mempools than regular nodes).\n\n  If the answer is no, then that's fine and I don't see a reason to push\n  in this direction. I sort of assumed there was enough hashpower mining\n  with priority, since last time I checked estimatepriority was still\n  giving meaningful results for low-ish blockheights, but I haven't done\n  any kind of real analysis.\n\n  - https://github.com/bitcoin/bitcoin/pull/6992#issuecomment-155969455\n\nor in June 2019,\n\n  What this PR is proposing is to get rid of a command-line option that is\n  (a) a footgun for users and (b) does not reflect what I believe to be\n  the understanding most users have, which is that [X txs] are expected\n  to propagate well on the network.\n\n  ..\n\n  I don't think this rises to the level that Luke is concerned about,\n  namely a prelude to forcing a common relay policy on all nodes. In\n  particular I do agree it makes sense that we offer some ways of\n  customizing policy parameters (eg the mempool size, min relay fee,\n  etc). Instead, I think the justification for this change is that we\n  should not support behaviors we think are harmful to the ecosystem\n  overall and have no legitimate use-case, and we should eliminate ways\n  that users might inadvertently shoot themselves in the foot.\n\n  - https://github.com/bitcoin/bitcoin/pull/16171#issuecomment-500393271\n\n(or see discussion in https://github.com/bitcoin/bitcoin/pull/7219)\n\nI don't mean to imply the above are saying \"there's one way to do\nthings and it's this way\", or that the old way of doing things should\nnecessarily be the way we keep doing things. Just that previously core\nhas tended towards designing a single policy that works as well as it\ncan for everyone and the ecosystem as a whole. (I'm also not saying that\nfullrbf can't work well for everyone or the ecosystem as a whole)\n\n\nBy contrast, I think the most common response to pushback against the\nfull rbf option has been along the lines of \"it's just an option, we\ndon't want to force people\", eg:\n\n  Blaming the default false -mempoolfullrbf option for a full RBF network\n  would be holding Bitcoin Core developers responsible for the decisions\n  of individual node operators and miners. I don't think having the\n  option (again, default false) can directly cause a full RBF network,\n  and likewise, I don't think removing this option removes the \"risk\"\n  of a full RBF network.\n   - glozow\n     https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274949400\n\n  NACK. This is a default false option.\n   - achow101\n     https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n\n  Erecting artificial barriers to prevent or make it difficult for users\n  to do what they want to do, is not appropriate behaviour.\n   - luke-jr\n     https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1290721905\n\n  I'm in general against removing options.\n   - instagibbs\n     https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1292030700\n\nI think this differs from what core has done in the past, in that\npreviously we've tried to ensure a new policy is good for everyone (or as\nnearly as it can be), and then enabled it as soon as it's implemented.\nAny options that have been added have either been to control resource\nusage in ways that don't significantly effect tx propagation, to\nallow people to revert to the old behaviour when the new behaviour is\ncontroversial (eg the -mempoolreplacement=0 option from 0.12 to 0.18),\nand to make it easier to test/debug the implementation.\n\nGiving people a new relay behaviour they can opt-in to when we aren't\nconfident enough to turn on by default doesn't match the approach I've\nseen core take in the past.\n\n\nIf this is going to be an ongoing shift in how core sees relay/mempool\npolicy, I think that's significant and worth paying attention to.\n\nI don't think it's necessary to have that shift to roll out full rbf.\nThe other approach would be either:\n\n * set -mempoolfullrbf=true as the default for 24.0, and just have the\n   command line param there in case people want to do a\n   \"UserRejectedMempoolPolicy\" campaign to get everyone to opt-out\n\n * revert it for now because we don't think mainnet is ready for fullrbf\n   yet, and introduce it as default true for 25.0 or 26.0 or 27.0 or\n   to activate at some scheduled date in that timeframe (potentially\n   backporting it to previous releases to help with adoption too,\n   whatever). same effect as the previous option, just with a bit more\n   advanced notice and time to prepare\n\nI don't think anyone's proposed the first (which I interpret as \"most of\nus don't think mainnet is ready for fullrbf today\"), but the comments\nabove are all pushback by people arguing against (the first step of)\nthe second approach, and they seem to be winning the day.\n\nIt's also possible that this is something of a one time thing: full rbf\nhas been controversial for ages, but widely liked by devs, and other\nattempts (eg making it available in knots) haven't actually achieved\nmuch of a result in practice. So maybe this is just a special case and\nnot a precedent, and when people propose other default false options,\nthere will be substantially more resistance to them being merged,\ndespite all the talk about users having options that's going on right now.\n\n\nAssuming it is the change of direction it appears to be -- and all of\nthe above is really just justification for that assumption -- then like\nI said, I think it's worth seriously considering what it means for people\nto choose their own relay/mempool policies and for you to expect to have\ndifferent mempool policies to many or most of your potential peers.\n\n\nOne thing maybe worth noting is that is that you can still only choose\nyour policy from options that people write code for -- if it wasn't\nsomething you could get by running knots or compiling a rejected PR\nyourself, it won't magically become more possible now.  Presumably it\nwould mean that once a PR is written, it might get better review (rather\nthan being dismissed as not suitable for everyone), and there would be\nless maintenance burden than if it had to be manually rebased every\nrelease, though (or at least the maintenance burden would be shared\nacross everyone working on the codebase).\n\n\nThe second thing is that whatever your relay policy is, you still\nneed a path all the way to miners through nodes that will accept your\ntransaction at every step. If you're making your mempool more restrictive\n(eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\nyou're making life more difficult for people who do create those sorts\nof txs); but if you want a more permissive policy (package relay,\nversion-3-rbf, full-rbf), you might need to do some work.\n\nThe cutoff for that is probably something like \"do 30% of listening\nnodes have a compatible policy\"? If they do, then you'll have about a\n95% chance of having at least one of your outbound peers accept your tx,\njust by random chance. If erlay allows increasing your outbound count to\n12 connections instead of 8; that might reduce down to needing just 20%\nof listening nodes (~93%).\n\nBut for cases where less than 30% (20%) of network supports your preferred\npolicy, you probably need to do something cleverer.\n\nOne approach is to set a service bit and preferentially peer with other\nnodes that advertise that service bit; knots does the first half of this\nfor fullrbf, and both halves have been proposed for core in #25600.\nPreferential peering was previously done for the segwit deployment,\nthough in that case it was necessary not just for tx propogation but\nalso for ensuring block propogation, making it effectively a consensus\ncritical issue.\n\nAnother approach is having a separate relay network -- eg, lightning nodes\nalready have a gossip network, and might want to help their own ecosystem\nby ensuring unilateral channel closes and justice transactions are quickly\nrelayed. Using their own gossip network to relay the transaction around,\nand each lightning node adding it to their local bitcoind's mempool and\nallowing it to propogate (or not) from there as normal, would also be a\nway of allowing transactions to propogate well. It does mean that miners\nwould either need to also participate in lightning gossip directly, or\nthat miners would need to connect to *many* peers to be confident of\nseeing those transactions (eg, if only 2% of the network would see a\ntx, you'd need to make 228 connections to have a 99% chance of seeing\nthe tx). You can't currently do something like this, because all the\nrelay policies are also applied when adding txs to the mempool via RPC,\nand there's no convenient way to remove txs from the mempool.\n\nA case where something like that might occur is in preventing L2\ntransactions from pinning attacks -- so you might have a high-fee,\nlow-feerate transaction that's been widely propogated, sitting in the\nbottom of people's mempools, and you want to replace it with a smaller,\nhigher-feerate transaction, but don't want to pay a higher absolute fee,\nand are thus blocked by BIP 125 rule 3. Perhaps 98% of the network is\nunwilling to deviate from BIP 125 rule 3 for you; because that would\nmake it easy for random griefers to spam their mempool with large txs\nthen delete them while only paying a small fee; but your L2 peers may be\nable to decode your replacement transaction and be sure that you aren't\ngoing to spam them, and thus will happily relay it.\n\n>From a technical point-of-view, that's largely fine; the downside is it\nincreases the centralisation pressure on mining: whether that's by having\nto connect to substantially more nodes, or having to parse through more\nspam, you can't just run your mining operation off a standard install\nof bitcoin core anymore, but need to actively opt-in to find all the\nweird unusual ways people are sending transactions around in order to\nactually collect as much in fees as your competitors are.\n\nThat's probably moderately bad for privacy as well -- if lightning or\ncoinjoins need special relay rules that most nodes haven't opted into,\nit's potentially easy to use that to find the bitcoin nodes on the\nnetwork that are participating in those protocols, and from there to\neither identify the operator, or run a DoS attack to make it hard for you\nto keep doing what you want. Obviously if you're setting a service bit to\nget better routing, you've given up that privacy already. Likewise if the\ngovernment or random vandals are opposed to bitcoin mining, and miners\nhave to have special configuration on their nodes that distinguish them\nfrom regular users, then perhaps that makes it easier to find or shut\ndown their operations.\n\nThere are a few efficiencies to be gained from similar mempool policies as\nwell: more reliable compact block reconstruction (if you're not missing\nany transactions, you avoid a round-trip) and presumably more efficient\nset reconstruction with erlay. You'll also waste less bandwidth sending\ntransactions that the other node is only going to reject. Both those\ndepend on how many transactions are going to rely on unusual mempool\npolicies in the first place though.\n\nariard wrote:\n\n  I know I've advocated in the past to turn RBF support by default in\n  the past. Though after gathering a lot of feedbacks, this approach\n  of offering the policy flexiblity to the interested users only and\n  favoring a full-rbf gradual deployment sounds better to me.\n\n  - https://github.com/bitcoin/bitcoin/pull/25353#issuecomment-1157137026\n\nI guess all the above leads me to think that gradual deployments of\nmempool policies are likely the worse approach: even when they're not\nhurting anyone, it makes them hard to use during the gradual phase,\nand getting around that comes with worrying compromises on privacy and\ncentralisation; and when they are problematic for some, the indeterminate\nnature of a gradual deployment means it's hard to plan for when that\nrisk is going to eventuate.\n\n\nTheoretically, one way to recover the good parts of core deciding on\nwhat's good for the network might be for people outside of core to\nrecommend a mempool configuration; then core can just have an option\nto make that easy, similar to \"-std=c++17\" for a C++ compiler, and much\nthe same as knots' \"-corepolicy\" option.\n\nPresuming anyone actually wants to take on that job, and listen to the\nconcerns of zeroconf businesses, lightning and coinjoin devs, miners, etc;\nand can come up with something that keeps most of them happy, and that\n70% or 90% of the network ends up just following those recommendations\nbecause it's easy, it works, and it's recommended by all the apps they\nwant to use, then that could work great:\n\n * miners don't need to do anything special, so there's no new\n   mining centralisation pressure\n * miners and users don't reveal what they're doing with bitcoin by the way\n   they configure their nodes, so there's no privacy problems\n * devs can be fairly confident in how they have to design their apps\n   in order to get their transactions to most hashpower\n * devs don't have to add new p2p layers to make it happen\n * at least there's someone to talk to when you're trying to figure out\n   how to make some new project possible when it's inhibited by current\n   relay policies and you don't have to try to convince everyone to\n   upgrade on your own\n * core devs just provide options, and don't have to worry about being\n   seen as gatekeepers\n\nThe \"downside\" in that scenario is that users/dev aren't making much\nactual use of all the choices core is offering by making different\noptions available; but the upside is that that choice is at least readily\navailable should whoever is coming up with these policy become out of\nstep with what people actually want.\n\nOne thing that might make an approach like that difficult is that core\nhas historically been happy to remove options that don't seem useful\nanymore: eg the ability to turn of BIP 125 support (#16171), and priority\ntransactions (#9602). Perhaps that's fine if you're trying to actively\ncraft a single mempool/relay policy that's good enough for almost everyone\n(after all, it makes the code simpler and more efficient, and reduces\nthe number of footguns); all you're doing is leaving a minority of people\nwho want weird things to run a fork, and that's going to happen anyway.\n\nBut if people are following policy developed outside of core, core\nmight well disagree with them and decide \"no that's a stupid policy,\nno one should do that\" and remove some feature that others thing should\ncontinue to be normal. Beyond the examples above, there's already talk of\nremoving the ability to disable fullrbf support in #26305, for instance.\nIf that happens, then the people maintaining the policy will instead\nend up maintaining an entire fork of bitcoin core, and all we've done\nis transition to people running software from a different repo, and a\ndifferent set of maintainers.\n\nIf we're really going to a world where core's eager to add new options,\nand reluctant to remove them, at least if anyone at all finds them\ninteresting, that's presumably a non-issue, though.\n\nCheers,\naj"
            },
            {
                "author": "John Carvalho",
                "date": "2022-10-27T09:56:45",
                "message_text_only": "Anthony,\n\nI took the time to read your whole post. Despite a diplomatic tone, I find\nyour takeaways from all your references to remain conveniently biased for\nprotecting the plan of RBF via passive aggression.\n\nYou show multiple examples where, when I read them, I assume the next thing\nyou will say will be \"so we really should stop trying to impose optional\nfeatures, particularly when they affect existing use cases\" but instead you\npersist.\n\nThe problem is that RBF has already been an option for years, and anyone\nthat wants to use it can. Any escalation in Bitcoin Core code to support it\nmore deeply, or by default, is basically an unfair advantage to force the\nmarket to do what it already has decided not to.\n\nIf wallets want to default to RBF, they can already do so, as evidenced by\nGreen Wallet (which I stopped using because it breaks the UX at Bitrefill).\n\nInstead of Core devs admitting RBF is a minority use case, you seem to be\nproposing that the market should now be obligated to prove it can defeat\nRBF in a stronger form if it really wants to prove other use cases. This is\noppressive, dark-pattern design. We all know that Core has little ability\nto sense the market, and the market has little ability to express itself to\nCore. The idea that the market can always downvote or defeat a feature or\nnew complexity proposal is idealistic and unrealistic.\n\nSuperficial features should be decided at the surface (app level) not in\nthe protocol or node.\n\nThe default answer to ALL proposals is \"No.\" Changes need to win market\nacceptance, not get special access through Core devs baking them deeper and\ndeeper into the protocol and policies until everyone is forced into a new\ndesign.\n\nAs I mentioned before, this behavior, if we are lucky, will result in more\nmempool types, more implementations, and a more-difficult to modify\nprotocol, but ALL feature changes, default settings that make decisions for\nusers, and even all scaling changes, are speculative risks with\nunpredictable outcomes.\n\nI urge the culture of Core to respect these dynamics and become much more\nconservative with proposing change. Please focus on efficiencies, bugs,\ncleanup, reducing overhead, etc.\n\nThe current RBF movement feels like Core is strong-arming and shoe-horning\nin a change that the market is not actually asking for. It is okay to leave\nthings as they are. It is okay if RBF remains a niche feature. It is not\nokay for a small group of RBF-interested engineers to make commercial\nBitcoin use cases worse.\n\nLet us realize the Bitcoin we already have. We already have a largely\nunexplored canvas of taproot, lightning, UX, etc.\n\nI expect the things I do with Bitcoin today to work FOREVER.\n\n--\nJohn Carvalho\nCEO, Synonym.to <http://synonym.to/>\n\n\n\n> Date: Thu, 27 Oct 2022 09:52:10 +1000\n> From: Anthony Towns <aj at erisian.com.au>\n> To: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>\n> Subject: [bitcoin-dev] On mempool policy consistency\n> Message-ID: <Y1nIKjQC3DkiSGyw at erisian.com.au>\n> Content-Type: text/plain; charset=us-ascii\n>\n> Hi *,\n>\n> TLDR: Yes, this post is too long, and there's no TLDR. If it's any\n> consolation, it took longer to write than it does to read?\n>\n> On Tue, Jun 15, 2021 at 12:55:14PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > Subject: Re: [bitcoin-dev] Proposal: Full-RBF in Bitcoin Core 24.0\n> > I'm writing to propose deprecation of opt-in RBF in favor of full-RBF\n>\n> > If there is ecosystem agreement on switching to full-RBF, but 0.24 sounds\n> > too early, let's defer it to 0.25 or 0.26. I don't think Core has a\n> > consistent deprecation process w.r.t to policy rules heavily relied-on by\n> > Bitcoin users, if we do so let sets a precedent satisfying as many folks\n> as\n> > we can.\n>\n> One precedent that seems to be being set here, which to me seems fairly\n> novel for bitcoin core, is that we're about to start supporting and\n> encouraging nodes to have meaningfully different mempool policies. From\n> what I've seen, the baseline expectation has always been that while\n> certainly mempools can and will differ, policies will be largely the same:\n>\n>   Firstly, there is no \"the mempool\". There is no global mempool. Rather\n>   each node maintains its own mempool and accepts and rejects transaction\n>   to that mempool using their own internal policies. Most nodes have\n>   the same policies, but due to different start times, relay delays,\n>   and other factors, not every node has the same mempool, although they\n>   may be very similar.\n>\n>   -\n> https://bitcoin.stackexchange.com/questions/98585/how-to-find-if-two-transactions-in-mempool-are-conflicting\n>\n> Up until now, the differences between node policies supported by different\n> nodes running core have been quite small, with essentially the following\n> options available:\n>\n>  -minrelaytxfee, -maxmempool - changes the lowest fee rate you'll accept\n>\n>  -mempoolexpiry - how long to keep txs in the mempool\n>\n>  -datacarrier - reject txs creating OP_RETURN outputs\n>\n>  -datacarriersize - maximum size of OP_RETURN data\n>\n>  -permitbaremultisig - prevent relay of bare multisig\n>\n>  -bytespersigop - changes how SIGOP accounting works for relay and\n>  mining prioritisation\n>\n> as well as these, marked as \"debug only\" options (only shown with\n> -help-debug):\n>\n>  -incrementalrelayfee - make it easier/harder to spam txs by only\n>  slightly bumping the fee; marked as a \"debug only\" option\n>\n>  -dustrelayfee - make it easier/harder to create uneconomic utxos;\n>  marked as a \"debug only\" option\n>\n>  -limit{descendant,ancestor}{count,size} - changes how large the\n>  transaction chains can be; marked as a \"debug only\" option\n>\n> and in theory, but not available on mainnet:\n>\n>  -acceptnonstdtxn - relay/mine non standard transactions\n>\n> There's also the \"prioritisetransaction\" rpc, which can cause you to keep\n> a low feerate transaction in your mempool longer than you might otherwise.\n>\n> I think that -minrelaytxfee, -maxmempool and -mempoolexpiry are the only\n> ones of those options commonly set, and those only rarely result in any\n> differences in the txs at the top of the mempool.\n>\n> There are also quite a few parameters that aren't even runtime\n> configurable:\n>\n>  - MAX_STANDARD_TX_WEIGHT\n>  - MIN_STANDARD_TX_NONWITNESS_SIZE (see also #26265)\n>  - MAX_P2SH_SIGOPS (see also #26348)\n>  - MAX_STANDARD_TX_SIGOPS_COST\n>  - MAX_STANDARD_P2WSH_STACK_ITEMS\n>  - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE\n>  - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE\n>  - MAX_STANDARD_P2WSH_SCRIPT_SIZE\n>  - MAX_STANDARD_SCRIPTSIG_SIZE\n>  - EXTRA_DESCENDANT_TX_SIZE_LIMIT\n>  - MAX_REPLACEMENT_CANDIDATES\n>\n> And other plausible options aren't configurable even at compile time\n> -- eg, core doesn't implement BIP 125's inherited signalling rule so\n> there's no way to enable it; core doesn't allow opting out of BIP 125\n> rule 3 ratchet on absolute fee; core doesn't allow CPFP carveout with\n> more than 1 ancestor; core doesn't allow opting out of LOW_S checks\n> (even via -acceptnonstdtxn); etc.\n>\n> We also naturally have different mempool policies between different\n> releases: eg, expansions of policy, such as allowing OP_RETURN or\n> expanding it from 40 to 80 bytes or new soft forks where old nodes won't\n> relay transactions that use the new; and also occassional restrictions\n> in policy, such as the LOW_S requirement.\n>\n>\n> While supporting and encouraging different mempool polices might be new\n> for core, it's not new for knots: knots changes some of these defaults\n> (-permitbaremultisig defaults to false, -datacarriersize is reduced to\n> 42), allows the use of -acceptnonstdtxn on mainnet, and introduces new\n> options including -spkreuse and -mempoolreplacement (giving the latter\n> full rbf behaviour by default). Knots also includes a `-corepolicy`\n> option to make it easy to get a configuration matching core's defaults.\n>\n>\n> I think gmaxwell's take from Feb 2015 (in the context of how restrictive\n> policy on OP_RETURN data should be) was a reasonable description for\n> core's approach up until now:\n>\n>   There is also a matter of driving competent design rather than lazy\n>   first thing that works. E.g. In stealth addresses the early proposals\n>   use highly inefficient single ECDH point per output instead of simply\n>   pooling them. Network behavior is one of the few bits of friction\n>   driving good technical design rather than \"move fast, break things, and\n>   force everyone else onto my way of doing thing rather than discussing\n>   the design in public\". No one wants to be an outright gatekeeper,\n>   but the network is a shared resource and it's perfectly reasonable\n>   node behavior to be stingy about the perpetual storage impact of the\n>   transactions they're willing to process, especially when it comes to\n>   neutral technical criteria like the amount of network irrelevant data\n>   stuffed in transactions.\n>\n>   There is also a very clear pattern we've seen in the past where\n>   people take anything the system lets them do as strong evidence that\n>   they have a irrevocable right to use the system in that way, and that\n>   their only responsibility-- and if their usage harms the system it's\n>   the responsibility of the system to not permit it. [...\n>   ...] For mitigating these risks it's optimal if transactions\n>   seem as uniform and indistinguishable as reasonably possible.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/5286#issuecomment-72564175\n>\n> Perhaps see also sdaftuar in Nov 2015,\n>\n>   To me the most important question is, is priority something that miners\n>   want to use?\n>\n>   If a non-negligible amount of hashpower intends to use it in their\n>   transaction selection, then I think it makes sense for nodes to use it\n>   too, because it's generally helpful to have your mempool predict the\n>   UTXO as much as possible, and for nodes to be able to have reasonable\n>   fee and priority estimates (which won't happen unless they track the\n>   priority transactions somehow -- I'm presuming that miners run with\n>   much bigger mempools than regular nodes).\n>\n>   If the answer is no, then that's fine and I don't see a reason to push\n>   in this direction. I sort of assumed there was enough hashpower mining\n>   with priority, since last time I checked estimatepriority was still\n>   giving meaningful results for low-ish blockheights, but I haven't done\n>   any kind of real analysis.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/6992#issuecomment-155969455\n>\n> or in June 2019,\n>\n>   What this PR is proposing is to get rid of a command-line option that is\n>   (a) a footgun for users and (b) does not reflect what I believe to be\n>   the understanding most users have, which is that [X txs] are expected\n>   to propagate well on the network.\n>\n>   ..\n>\n>   I don't think this rises to the level that Luke is concerned about,\n>   namely a prelude to forcing a common relay policy on all nodes. In\n>   particular I do agree it makes sense that we offer some ways of\n>   customizing policy parameters (eg the mempool size, min relay fee,\n>   etc). Instead, I think the justification for this change is that we\n>   should not support behaviors we think are harmful to the ecosystem\n>   overall and have no legitimate use-case, and we should eliminate ways\n>   that users might inadvertently shoot themselves in the foot.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/16171#issuecomment-500393271\n>\n> (or see discussion in https://github.com/bitcoin/bitcoin/pull/7219)\n>\n> I don't mean to imply the above are saying \"there's one way to do\n> things and it's this way\", or that the old way of doing things should\n> necessarily be the way we keep doing things. Just that previously core\n> has tended towards designing a single policy that works as well as it\n> can for everyone and the ecosystem as a whole. (I'm also not saying that\n> fullrbf can't work well for everyone or the ecosystem as a whole)\n>\n>\n> By contrast, I think the most common response to pushback against the\n> full rbf option has been along the lines of \"it's just an option, we\n> don't want to force people\", eg:\n>\n>   Blaming the default false -mempoolfullrbf option for a full RBF network\n>   would be holding Bitcoin Core developers responsible for the decisions\n>   of individual node operators and miners. I don't think having the\n>   option (again, default false) can directly cause a full RBF network,\n>   and likewise, I don't think removing this option removes the \"risk\"\n>   of a full RBF network.\n>    - glozow\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274949400\n>\n>   NACK. This is a default false option.\n>    - achow101\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n>\n>   Erecting artificial barriers to prevent or make it difficult for users\n>   to do what they want to do, is not appropriate behaviour.\n>    - luke-jr\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1290721905\n>\n>   I'm in general against removing options.\n>    - instagibbs\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1292030700\n>\n> I think this differs from what core has done in the past, in that\n> previously we've tried to ensure a new policy is good for everyone (or as\n> nearly as it can be), and then enabled it as soon as it's implemented.\n> Any options that have been added have either been to control resource\n> usage in ways that don't significantly effect tx propagation, to\n> allow people to revert to the old behaviour when the new behaviour is\n> controversial (eg the -mempoolreplacement=0 option from 0.12 to 0.18),\n> and to make it easier to test/debug the implementation.\n>\n> Giving people a new relay behaviour they can opt-in to when we aren't\n> confident enough to turn on by default doesn't match the approach I've\n> seen core take in the past.\n>\n>\n> If this is going to be an ongoing shift in how core sees relay/mempool\n> policy, I think that's significant and worth paying attention to.\n>\n> I don't think it's necessary to have that shift to roll out full rbf.\n> The other approach would be either:\n>\n>  * set -mempoolfullrbf=true as the default for 24.0, and just have the\n>    command line param there in case people want to do a\n>    \"UserRejectedMempoolPolicy\" campaign to get everyone to opt-out\n>\n>  * revert it for now because we don't think mainnet is ready for fullrbf\n>    yet, and introduce it as default true for 25.0 or 26.0 or 27.0 or\n>    to activate at some scheduled date in that timeframe (potentially\n>    backporting it to previous releases to help with adoption too,\n>    whatever). same effect as the previous option, just with a bit more\n>    advanced notice and time to prepare\n>\n> I don't think anyone's proposed the first (which I interpret as \"most of\n> us don't think mainnet is ready for fullrbf today\"), but the comments\n> above are all pushback by people arguing against (the first step of)\n> the second approach, and they seem to be winning the day.\n>\n> It's also possible that this is something of a one time thing: full rbf\n> has been controversial for ages, but widely liked by devs, and other\n> attempts (eg making it available in knots) haven't actually achieved\n> much of a result in practice. So maybe this is just a special case and\n> not a precedent, and when people propose other default false options,\n> there will be substantially more resistance to them being merged,\n> despite all the talk about users having options that's going on right now.\n>\n>\n> Assuming it is the change of direction it appears to be -- and all of\n> the above is really just justification for that assumption -- then like\n> I said, I think it's worth seriously considering what it means for people\n> to choose their own relay/mempool policies and for you to expect to have\n> different mempool policies to many or most of your potential peers.\n>\n>\n> One thing maybe worth noting is that is that you can still only choose\n> your policy from options that people write code for -- if it wasn't\n> something you could get by running knots or compiling a rejected PR\n> yourself, it won't magically become more possible now.  Presumably it\n> would mean that once a PR is written, it might get better review (rather\n> than being dismissed as not suitable for everyone), and there would be\n> less maintenance burden than if it had to be manually rebased every\n> release, though (or at least the maintenance burden would be shared\n> across everyone working on the codebase).\n>\n>\n> The second thing is that whatever your relay policy is, you still\n> need a path all the way to miners through nodes that will accept your\n> transaction at every step. If you're making your mempool more restrictive\n> (eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\n> you're making life more difficult for people who do create those sorts\n> of txs); but if you want a more permissive policy (package relay,\n> version-3-rbf, full-rbf), you might need to do some work.\n>\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your tx,\n> just by random chance. If erlay allows increasing your outbound count to\n> 12 connections instead of 8; that might reduce down to needing just 20%\n> of listening nodes (~93%).\n>\n> But for cases where less than 30% (20%) of network supports your preferred\n> policy, you probably need to do something cleverer.\n>\n> One approach is to set a service bit and preferentially peer with other\n> nodes that advertise that service bit; knots does the first half of this\n> for fullrbf, and both halves have been proposed for core in #25600.\n> Preferential peering was previously done for the segwit deployment,\n> though in that case it was necessary not just for tx propogation but\n> also for ensuring block propogation, making it effectively a consensus\n> critical issue.\n>\n> Another approach is having a separate relay network -- eg, lightning nodes\n> already have a gossip network, and might want to help their own ecosystem\n> by ensuring unilateral channel closes and justice transactions are quickly\n> relayed. Using their own gossip network to relay the transaction around,\n> and each lightning node adding it to their local bitcoind's mempool and\n> allowing it to propogate (or not) from there as normal, would also be a\n> way of allowing transactions to propogate well. It does mean that miners\n> would either need to also participate in lightning gossip directly, or\n> that miners would need to connect to *many* peers to be confident of\n> seeing those transactions (eg, if only 2% of the network would see a\n> tx, you'd need to make 228 connections to have a 99% chance of seeing\n> the tx). You can't currently do something like this, because all the\n> relay policies are also applied when adding txs to the mempool via RPC,\n> and there's no convenient way to remove txs from the mempool.\n>\n> A case where something like that might occur is in preventing L2\n> transactions from pinning attacks -- so you might have a high-fee,\n> low-feerate transaction that's been widely propogated, sitting in the\n> bottom of people's mempools, and you want to replace it with a smaller,\n> higher-feerate transaction, but don't want to pay a higher absolute fee,\n> and are thus blocked by BIP 125 rule 3. Perhaps 98% of the network is\n> unwilling to deviate from BIP 125 rule 3 for you; because that would\n> make it easy for random griefers to spam their mempool with large txs\n> then delete them while only paying a small fee; but your L2 peers may be\n> able to decode your replacement transaction and be sure that you aren't\n> going to spam them, and thus will happily relay it.\n>\n> >From a technical point-of-view, that's largely fine; the downside is it\n> increases the centralisation pressure on mining: whether that's by having\n> to connect to substantially more nodes, or having to parse through more\n> spam, you can't just run your mining operation off a standard install\n> of bitcoin core anymore, but need to actively opt-in to find all the\n> weird unusual ways people are sending transactions around in order to\n> actually collect as much in fees as your competitors are.\n>\n> That's probably moderately bad for privacy as well -- if lightning or\n> coinjoins need special relay rules that most nodes haven't opted into,\n> it's potentially easy to use that to find the bitcoin nodes on the\n> network that are participating in those protocols, and from there to\n> either identify the operator, or run a DoS attack to make it hard for you\n> to keep doing what you want. Obviously if you're setting a service bit to\n> get better routing, you've given up that privacy already. Likewise if the\n> government or random vandals are opposed to bitcoin mining, and miners\n> have to have special configuration on their nodes that distinguish them\n> from regular users, then perhaps that makes it easier to find or shut\n> down their operations.\n>\n> There are a few efficiencies to be gained from similar mempool policies as\n> well: more reliable compact block reconstruction (if you're not missing\n> any transactions, you avoid a round-trip) and presumably more efficient\n> set reconstruction with erlay. You'll also waste less bandwidth sending\n> transactions that the other node is only going to reject. Both those\n> depend on how many transactions are going to rely on unusual mempool\n> policies in the first place though.\n>\n> ariard wrote:\n>\n>   I know I've advocated in the past to turn RBF support by default in\n>   the past. Though after gathering a lot of feedbacks, this approach\n>   of offering the policy flexiblity to the interested users only and\n>   favoring a full-rbf gradual deployment sounds better to me.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/25353#issuecomment-1157137026\n>\n> I guess all the above leads me to think that gradual deployments of\n> mempool policies are likely the worse approach: even when they're not\n> hurting anyone, it makes them hard to use during the gradual phase,\n> and getting around that comes with worrying compromises on privacy and\n> centralisation; and when they are problematic for some, the indeterminate\n> nature of a gradual deployment means it's hard to plan for when that\n> risk is going to eventuate.\n>\n>\n> Theoretically, one way to recover the good parts of core deciding on\n> what's good for the network might be for people outside of core to\n> recommend a mempool configuration; then core can just have an option\n> to make that easy, similar to \"-std=c++17\" for a C++ compiler, and much\n> the same as knots' \"-corepolicy\" option.\n>\n> Presuming anyone actually wants to take on that job, and listen to the\n> concerns of zeroconf businesses, lightning and coinjoin devs, miners, etc;\n> and can come up with something that keeps most of them happy, and that\n> 70% or 90% of the network ends up just following those recommendations\n> because it's easy, it works, and it's recommended by all the apps they\n> want to use, then that could work great:\n>\n>  * miners don't need to do anything special, so there's no new\n>    mining centralisation pressure\n>  * miners and users don't reveal what they're doing with bitcoin by the way\n>    they configure their nodes, so there's no privacy problems\n>  * devs can be fairly confident in how they have to design their apps\n>    in order to get their transactions to most hashpower\n>  * devs don't have to add new p2p layers to make it happen\n>  * at least there's someone to talk to when you're trying to figure out\n>    how to make some new project possible when it's inhibited by current\n>    relay policies and you don't have to try to convince everyone to\n>    upgrade on your own\n>  * core devs just provide options, and don't have to worry about being\n>    seen as gatekeepers\n>\n> The \"downside\" in that scenario is that users/dev aren't making much\n> actual use of all the choices core is offering by making different\n> options available; but the upside is that that choice is at least readily\n> available should whoever is coming up with these policy become out of\n> step with what people actually want.\n>\n> One thing that might make an approach like that difficult is that core\n> has historically been happy to remove options that don't seem useful\n> anymore: eg the ability to turn of BIP 125 support (#16171), and priority\n> transactions (#9602). Perhaps that's fine if you're trying to actively\n> craft a single mempool/relay policy that's good enough for almost everyone\n> (after all, it makes the code simpler and more efficient, and reduces\n> the number of footguns); all you're doing is leaving a minority of people\n> who want weird things to run a fork, and that's going to happen anyway.\n>\n> But if people are following policy developed outside of core, core\n> might well disagree with them and decide \"no that's a stupid policy,\n> no one should do that\" and remove some feature that others thing should\n> continue to be normal. Beyond the examples above, there's already talk of\n> removing the ability to disable fullrbf support in #26305, for instance.\n> If that happens, then the people maintaining the policy will instead\n> end up maintaining an entire fork of bitcoin core, and all we've done\n> is transition to people running software from a different repo, and a\n> different set of maintainers.\n>\n> If we're really going to a world where core's eager to add new options,\n> and reluctant to remove them, at least if anyone at all finds them\n> interesting, that's presumably a non-issue, though.\n>\n> Cheers,\n> aj\n>\n>\n> ------------------------------\n>\n> Subject: Digest Footer\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n>\n> ------------------------------\n>\n> End of bitcoin-dev Digest, Vol 89, Issue 77\n> *******************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/1585a093/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-27T17:21:53",
                "message_text_only": "On Thu, Oct 27, 2022 at 11:56:45AM +0200, John Carvalho via bitcoin-dev wrote:\n> I took the time to read your whole post. Despite a diplomatic tone, I find\n> your takeaways from all your references to remain conveniently biased for\n> protecting the plan of RBF\n\nYes, I am heavily biased against zeroconf: there's no way I'd personally\nbe willing to trust it for my own incoming funds, no matter how much\nevidence you show me that it's safe in practice. Show me a million\ntransactions where every single one worked fine, and I'm still going to\nassume that the payment going to me is going to be the one that makes\nthe error rate tick up from 0% to 0.0001%. That's okay; just because I\nwouldn't do something, doesn't mean other people shouldn't.\n\nIt does mean I'm not going to be a particularly good advocate for zeroconf\nthough. I mean, I might still be a fine advocate for giving people time\nto react, making it clear what's going on, finding ways that might make\neveryone happy, or just digging it to random technical details; but,\nfor me, I'm more interested in a world where chargebacks are impossible,\nnot where we just make the best of what was possible with technology\nfrom five or ten years ago.\n\nBut that's fine: it just means that people, like yourself, who will\ntolerate the risks of zeroconf, should be involved in the discussion.\n\n> You show multiple examples where, when I read them, I assume the next thing\n> you will say will be \"so we really should stop trying to impose optional\n> features, particularly when they affect existing use cases\" but instead you\n> persist.\n\nSure, that's natural: you read a sign saying \"you can have any ice cream\nyou want for 5c\" and think \"Awesome, who wouldn't want cheap chocolate\nice cream!!\" and see me going for a Golden Gaytime and think \"wtf dude\".\nDifferent strokes.\n\nFor me, I see the gmaxwell github comment I quoted saying:\n\n  There is also a matter of driving competent design rather than lazy\n  first thing that works.\n\nand think \"yeah, okay, maybe we should be working harder to push lightning\nadoption, rather than letting people stick with wallet UX from 2015\"\nand have altcoins take over >50% of payment volume.\n\nLikewise,\n\n  There is also a very clear pattern we've seen in the past where\n  people take anything the system lets them do as strong evidence that\n  they have a irrevocable right to use the system in that way, and that\n  their only responsibility-- and if their usage harms the system it's\n  the responsibility of the system to not permit it.\n\nseems a pretty good match against your claim \"I expect the things I do\nwith Bitcoin today to work FOREVER.\" Better to nip that thinking in the\nbud; and even if the best time to do that was years ago, the second best\ntime to do it is still now.\n\nBy contrast, from the same post, I'd guess you're focussing on:\n\n  Network behavior is one of the few bits of friction\n  driving good technical design rather than \"move fast, break things, and\n  force everyone else onto my way of doing thing rather than discussing\n  the design in public\".\n\nand thinking \"yeah, move fast, break things, force everyone else --\nthat's exactly what's going on here, and shouldn't be\".\n\nBut that's also okay: even when there is common ground to be found,\nsometimes it requires actual work to get people who start from different\nviews to get there.\n\n> The problem is that RBF has already been an option for years, and anyone\n> that wants to use it can.\n\nIs that true? Antoine claims [1] that opt-in RBF isn't enough to avoid\na DoS issue when utxos are jointly funded by untrusting partners, and,\naiui, that's the main motivation for addressing this now.\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\nThe scenario he describes is: A, B, C create a tx:\n\n  inputs: A1, B1, C1 [opts in to RBF]\n  fees: normal\n  outputs:\n    [lightning channel, DLC, etc, who knows]\n\nthey all analyse the tx, and agree it looks great; however just before\npublishing it, A spams the network with an alternative tx, double\nspending her input:\n\n  inputs: A1 [does not opt in to RBF]\n  fees: low\n  outputs: A\n\nIf A gets the timing right, that's bad for B and C because they've\npopulated their mempool with the 1st transaction, while everyone else\nsees the 2nd one instead; and neither tx will replace the other. B and\nC can't know that they should just cancel their transaction, eg:\n\n  inputs: B1, C1 [opts in to RBF]\n  fees: 50% above normal\n  outputs:\n    [smaller channel, refund, whatever]\n\nand might instead waste time trying to fee bump the tx to get it mined,\nor similar.\n\nWhat should folks wanting to do coinjoins/dualfunding/dlcs/etc do to\nsolve that problem if they have only opt-in RBF available?\n\nIf you're right that opt-in RBF is enough, that question has a good\nanswer. I don't believe anyone's presented an answer to it in the 17\nmonths since Antoine raised the concern.\n\n> passive aggression\n> escalation\n> unfair advantage\n> oppressive, dark-pattern design\n> strong-arming and shoe-horning\n\nDo you really think any of that was helping your cause?\n\nCheers,\naj"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2022-10-27T17:35:28",
                "message_text_only": "I have more to say on this broader topic, but since you've brought up this\nparticular example I think it's worth commenting:\n\nOn Thu, Oct 27, 2022 at 1:23 PM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Is that true? Antoine claims [1] that opt-in RBF isn't enough to avoid\n> a DoS issue when utxos are jointly funded by untrusting partners, and,\n> aiui, that's the main motivation for addressing this now.\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> The scenario he describes is: A, B, C create a tx:\n>\n>   inputs: A1, B1, C1 [opts in to RBF]\n>   fees: normal\n>   outputs:\n>     [lightning channel, DLC, etc, who knows]\n>\n> they all analyse the tx, and agree it looks great; however just before\n> publishing it, A spams the network with an alternative tx, double\n> spending her input:\n>\n>   inputs: A1 [does not opt in to RBF]\n>   fees: low\n>   outputs: A\n>\n> If A gets the timing right, that's bad for B and C because they've\n> populated their mempool with the 1st transaction, while everyone else\n> sees the 2nd one instead; and neither tx will replace the other. B and\n> C can't know that they should just cancel their transaction, eg:\n>\n>   inputs: B1, C1 [opts in to RBF]\n>   fees: 50% above normal\n>   outputs:\n>     [smaller channel, refund, whatever]\n>\n> and might instead waste time trying to fee bump the tx to get it mined,\n> or similar.\n>\n> What should folks wanting to do coinjoins/dualfunding/dlcs/etc do to\n> solve that problem if they have only opt-in RBF available?\n>\n\nI think this is not a real example of a DoS vector that is available\nbecause we support non-rbf signaling transactions. Even in a world where\nall transactions are replaceable, person A could double-spend their input\nin a way that is annoying for B and C.  For instance, the double-spend\ncould be low-feerate and large, and effectively pin any attempt to replace\nit.  Or it could be higher feerate and confirm and B/C have to start all\nover.  Or, A could stall things in the signing phase and B/C have to figure\nout when to give up on the channel with A.\n\nSo I find this example to be unconvincing.  Are there any other examples\nwhere having a non-replacement policy for some transactions causes problems\nfor protocols people are trying to build?\n\nThanks,\nSuhas\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/511dc909/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-27T17:44:43",
                "message_text_only": "> For instance, the double-spend could be low-feerate and large, and\neffectively pin any attempt to replace it.\n\nYes, this is the biggest hole left. You *could* replace it with RBF when\nbefore you simply could not, so perhaps the pinning door is slightly\nsmaller in scenarios where going feerates are significantly higher than min.\n\n> Or it could be higher feerate and confirm and B/C have to start all over.\n\nCoinjoins have \"blame rounds\" exactly for this. Ruling out the above hole\nwhere you don't want to pay the 100kvb rule#3 penalty, you can kick the\ngriefer out. Without replacement, you likely can not.\n\n> Or, A could stall things in the signing phase and B/C have to figure out\nwhen to give up on the channel with A.\n\nAgain, blame rounds solve this.\n\nSo to recap, it makes it *possible* to over-bid your griefer, vs simply not\nable to and have funds tied up for weeks(or guess you're being pinned and\ndouble-spend your input, which again looks blame-worthy).\n\nProperly replacing rule#3 would give these protocols higher assurances, but\nthis is where we're at now.\n\nOn Thu, Oct 27, 2022 at 1:35 PM Suhas Daftuar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I have more to say on this broader topic, but since you've brought up this\n> particular example I think it's worth commenting:\n>\n> On Thu, Oct 27, 2022 at 1:23 PM Anthony Towns via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Is that true? Antoine claims [1] that opt-in RBF isn't enough to avoid\n>> a DoS issue when utxos are jointly funded by untrusting partners, and,\n>> aiui, that's the main motivation for addressing this now.\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>\n>> The scenario he describes is: A, B, C create a tx:\n>>\n>>   inputs: A1, B1, C1 [opts in to RBF]\n>>   fees: normal\n>>   outputs:\n>>     [lightning channel, DLC, etc, who knows]\n>>\n>> they all analyse the tx, and agree it looks great; however just before\n>> publishing it, A spams the network with an alternative tx, double\n>> spending her input:\n>>\n>>   inputs: A1 [does not opt in to RBF]\n>>   fees: low\n>>   outputs: A\n>>\n>> If A gets the timing right, that's bad for B and C because they've\n>> populated their mempool with the 1st transaction, while everyone else\n>> sees the 2nd one instead; and neither tx will replace the other. B and\n>> C can't know that they should just cancel their transaction, eg:\n>>\n>>   inputs: B1, C1 [opts in to RBF]\n>>   fees: 50% above normal\n>>   outputs:\n>>     [smaller channel, refund, whatever]\n>>\n>> and might instead waste time trying to fee bump the tx to get it mined,\n>> or similar.\n>>\n>> What should folks wanting to do coinjoins/dualfunding/dlcs/etc do to\n>> solve that problem if they have only opt-in RBF available?\n>>\n>\n> I think this is not a real example of a DoS vector that is available\n> because we support non-rbf signaling transactions. Even in a world where\n> all transactions are replaceable, person A could double-spend their input\n> in a way that is annoying for B and C.  For instance, the double-spend\n> could be low-feerate and large, and effectively pin any attempt to replace\n> it.  Or it could be higher feerate and confirm and B/C have to start all\n> over.  Or, A could stall things in the signing phase and B/C have to figure\n> out when to give up on the channel with A.\n>\n> So I find this example to be unconvincing.  Are there any other examples\n> where having a non-replacement policy for some transactions causes problems\n> for protocols people are trying to build?\n>\n> Thanks,\n> Suhas\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/2af6e755/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-27T19:00:13",
                "message_text_only": "During off-channel discussion, Suhas made a great point that even with\nfullrbf, you can get stuck by bip125 rule#5 pinning if an adversary\ncontrols a number of inputs(4 with default mempool settings).\n\nImplication being, while we can mitigate rule#3 damage potentially with\nfullrbf, we cannot actually make promises about mempool entry beyond quite\nsmall transaction sizes. Adversary has to make 100 transactions, 4 chains\nof 25, but it achieves the original pin.\n\nOn Thu, Oct 27, 2022 at 1:44 PM Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> > For instance, the double-spend could be low-feerate and large, and\n> effectively pin any attempt to replace it.\n>\n> Yes, this is the biggest hole left. You *could* replace it with RBF when\n> before you simply could not, so perhaps the pinning door is slightly\n> smaller in scenarios where going feerates are significantly higher than min.\n>\n> > Or it could be higher feerate and confirm and B/C have to start all over.\n>\n> Coinjoins have \"blame rounds\" exactly for this. Ruling out the above hole\n> where you don't want to pay the 100kvb rule#3 penalty, you can kick the\n> griefer out. Without replacement, you likely can not.\n>\n> > Or, A could stall things in the signing phase and B/C have to figure out\n> when to give up on the channel with A.\n>\n> Again, blame rounds solve this.\n>\n> So to recap, it makes it *possible* to over-bid your griefer, vs simply\n> not able to and have funds tied up for weeks(or guess you're being pinned\n> and double-spend your input, which again looks blame-worthy).\n>\n> Properly replacing rule#3 would give these protocols higher assurances,\n> but this is where we're at now.\n>\n> On Thu, Oct 27, 2022 at 1:35 PM Suhas Daftuar via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I have more to say on this broader topic, but since you've brought up\n>> this particular example I think it's worth commenting:\n>>\n>> On Thu, Oct 27, 2022 at 1:23 PM Anthony Towns via bitcoin-dev <\n>> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Is that true? Antoine claims [1] that opt-in RBF isn't enough to avoid\n>>> a DoS issue when utxos are jointly funded by untrusting partners, and,\n>>> aiui, that's the main motivation for addressing this now.\n>>>\n>>> [1]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>>>\n>>> The scenario he describes is: A, B, C create a tx:\n>>>\n>>>   inputs: A1, B1, C1 [opts in to RBF]\n>>>   fees: normal\n>>>   outputs:\n>>>     [lightning channel, DLC, etc, who knows]\n>>>\n>>> they all analyse the tx, and agree it looks great; however just before\n>>> publishing it, A spams the network with an alternative tx, double\n>>> spending her input:\n>>>\n>>>   inputs: A1 [does not opt in to RBF]\n>>>   fees: low\n>>>   outputs: A\n>>>\n>>> If A gets the timing right, that's bad for B and C because they've\n>>> populated their mempool with the 1st transaction, while everyone else\n>>> sees the 2nd one instead; and neither tx will replace the other. B and\n>>> C can't know that they should just cancel their transaction, eg:\n>>>\n>>>   inputs: B1, C1 [opts in to RBF]\n>>>   fees: 50% above normal\n>>>   outputs:\n>>>     [smaller channel, refund, whatever]\n>>>\n>>> and might instead waste time trying to fee bump the tx to get it mined,\n>>> or similar.\n>>>\n>>> What should folks wanting to do coinjoins/dualfunding/dlcs/etc do to\n>>> solve that problem if they have only opt-in RBF available?\n>>>\n>>\n>> I think this is not a real example of a DoS vector that is available\n>> because we support non-rbf signaling transactions. Even in a world where\n>> all transactions are replaceable, person A could double-spend their input\n>> in a way that is annoying for B and C.  For instance, the double-spend\n>> could be low-feerate and large, and effectively pin any attempt to replace\n>> it.  Or it could be higher feerate and confirm and B/C have to start all\n>> over.  Or, A could stall things in the signing phase and B/C have to figure\n>> out when to give up on the channel with A.\n>>\n>> So I find this example to be unconvincing.  Are there any other examples\n>> where having a non-replacement policy for some transactions causes problems\n>> for protocols people are trying to build?\n>>\n>> Thanks,\n>> Suhas\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/bd6fd919/attachment-0001.html>"
            },
            {
                "author": "Gloria Zhao",
                "date": "2022-10-27T12:36:47",
                "message_text_only": "Hi AJ,\n\nNot going to comment on what Bitcoin Core's philosophy on mempol policy is\nor should be. I want to note that I think this:\n\n> It's also possible that this is something of a one time thing: full rbf\n> has been controversial for ages, but widely liked by devs, and other\n> attempts (eg making it available in knots) haven't actually achieved\n> much of a result in practice. So maybe this is just a special case\n\nis true.\n\n> The second thing is that whatever your relay policy is, you still\n> need a path all the way to miners through nodes that will accept your\n> transaction at every step. If you're making your mempool more restrictive\n> (eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\n> you're making life more difficult for people who do create those sorts\n> of txs); but if you want a more permissive policy (package relay,\n> version-3-rbf, full-rbf), you might need to do some work.\n\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your tx,\n> just by random chance.\n\nYes, in most cases, whether Bitcoin Core is restricting or loosening\npolicy, the user in question is fine as long as they have a path from their\nnode to a miner that will accept it. This is the case for something like\n-datacarriersize if the use case is putting stuff into OP_RETURN outputs,\nor if they're LN and using CPFP carveout, v3, package relay, etc. But\nreplacement is not only a question of \"will my transaction propagate\" but\nalso, \"will someone else's transaction propagate, invalidating mine\" or, in\nother words, \"can I prevent someone else's transaction from propagating.\" A\nzeroconf user relies on there *not* being a path from someone else's full\nRBF node to a full RBF miner. This is why I think RBF is so controversial\nin general, why -mempoolfullrbf on someone else's node is considered more\nsignificant than another policy option, and why full RBF shouldn't be\ncompared with something like datacarriersize. I don't think past patterns\ncan be easily applied here, and I don't think this necessarily shows a\ndifferent \"direction\" in thinking about mempool policy in general.\n\nBest,\nGloria\n\nOn Thu, Oct 27, 2022 at 12:52 AM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi *,\n>\n> TLDR: Yes, this post is too long, and there's no TLDR. If it's any\n> consolation, it took longer to write than it does to read?\n>\n> On Tue, Jun 15, 2021 at 12:55:14PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > Subject: Re: [bitcoin-dev] Proposal: Full-RBF in Bitcoin Core 24.0\n> > I'm writing to propose deprecation of opt-in RBF in favor of full-RBF\n>\n> > If there is ecosystem agreement on switching to full-RBF, but 0.24 sounds\n> > too early, let's defer it to 0.25 or 0.26. I don't think Core has a\n> > consistent deprecation process w.r.t to policy rules heavily relied-on by\n> > Bitcoin users, if we do so let sets a precedent satisfying as many folks\n> as\n> > we can.\n>\n> One precedent that seems to be being set here, which to me seems fairly\n> novel for bitcoin core, is that we're about to start supporting and\n> encouraging nodes to have meaningfully different mempool policies. From\n> what I've seen, the baseline expectation has always been that while\n> certainly mempools can and will differ, policies will be largely the same:\n>\n>   Firstly, there is no \"the mempool\". There is no global mempool. Rather\n>   each node maintains its own mempool and accepts and rejects transaction\n>   to that mempool using their own internal policies. Most nodes have\n>   the same policies, but due to different start times, relay delays,\n>   and other factors, not every node has the same mempool, although they\n>   may be very similar.\n>\n>   -\n> https://bitcoin.stackexchange.com/questions/98585/how-to-find-if-two-transactions-in-mempool-are-conflicting\n>\n> Up until now, the differences between node policies supported by different\n> nodes running core have been quite small, with essentially the following\n> options available:\n>\n>  -minrelaytxfee, -maxmempool - changes the lowest fee rate you'll accept\n>\n>  -mempoolexpiry - how long to keep txs in the mempool\n>\n>  -datacarrier - reject txs creating OP_RETURN outputs\n>\n>  -datacarriersize - maximum size of OP_RETURN data\n>\n>  -permitbaremultisig - prevent relay of bare multisig\n>\n>  -bytespersigop - changes how SIGOP accounting works for relay and\n>  mining prioritisation\n>\n> as well as these, marked as \"debug only\" options (only shown with\n> -help-debug):\n>\n>  -incrementalrelayfee - make it easier/harder to spam txs by only\n>  slightly bumping the fee; marked as a \"debug only\" option\n>\n>  -dustrelayfee - make it easier/harder to create uneconomic utxos;\n>  marked as a \"debug only\" option\n>\n>  -limit{descendant,ancestor}{count,size} - changes how large the\n>  transaction chains can be; marked as a \"debug only\" option\n>\n> and in theory, but not available on mainnet:\n>\n>  -acceptnonstdtxn - relay/mine non standard transactions\n>\n> There's also the \"prioritisetransaction\" rpc, which can cause you to keep\n> a low feerate transaction in your mempool longer than you might otherwise.\n>\n> I think that -minrelaytxfee, -maxmempool and -mempoolexpiry are the only\n> ones of those options commonly set, and those only rarely result in any\n> differences in the txs at the top of the mempool.\n>\n> There are also quite a few parameters that aren't even runtime\n> configurable:\n>\n>  - MAX_STANDARD_TX_WEIGHT\n>  - MIN_STANDARD_TX_NONWITNESS_SIZE (see also #26265)\n>  - MAX_P2SH_SIGOPS (see also #26348)\n>  - MAX_STANDARD_TX_SIGOPS_COST\n>  - MAX_STANDARD_P2WSH_STACK_ITEMS\n>  - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE\n>  - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE\n>  - MAX_STANDARD_P2WSH_SCRIPT_SIZE\n>  - MAX_STANDARD_SCRIPTSIG_SIZE\n>  - EXTRA_DESCENDANT_TX_SIZE_LIMIT\n>  - MAX_REPLACEMENT_CANDIDATES\n>\n> And other plausible options aren't configurable even at compile time\n> -- eg, core doesn't implement BIP 125's inherited signalling rule so\n> there's no way to enable it; core doesn't allow opting out of BIP 125\n> rule 3 ratchet on absolute fee; core doesn't allow CPFP carveout with\n> more than 1 ancestor; core doesn't allow opting out of LOW_S checks\n> (even via -acceptnonstdtxn); etc.\n>\n> We also naturally have different mempool policies between different\n> releases: eg, expansions of policy, such as allowing OP_RETURN or\n> expanding it from 40 to 80 bytes or new soft forks where old nodes won't\n> relay transactions that use the new; and also occassional restrictions\n> in policy, such as the LOW_S requirement.\n>\n>\n> While supporting and encouraging different mempool polices might be new\n> for core, it's not new for knots: knots changes some of these defaults\n> (-permitbaremultisig defaults to false, -datacarriersize is reduced to\n> 42), allows the use of -acceptnonstdtxn on mainnet, and introduces new\n> options including -spkreuse and -mempoolreplacement (giving the latter\n> full rbf behaviour by default). Knots also includes a `-corepolicy`\n> option to make it easy to get a configuration matching core's defaults.\n>\n>\n> I think gmaxwell's take from Feb 2015 (in the context of how restrictive\n> policy on OP_RETURN data should be) was a reasonable description for\n> core's approach up until now:\n>\n>   There is also a matter of driving competent design rather than lazy\n>   first thing that works. E.g. In stealth addresses the early proposals\n>   use highly inefficient single ECDH point per output instead of simply\n>   pooling them. Network behavior is one of the few bits of friction\n>   driving good technical design rather than \"move fast, break things, and\n>   force everyone else onto my way of doing thing rather than discussing\n>   the design in public\". No one wants to be an outright gatekeeper,\n>   but the network is a shared resource and it's perfectly reasonable\n>   node behavior to be stingy about the perpetual storage impact of the\n>   transactions they're willing to process, especially when it comes to\n>   neutral technical criteria like the amount of network irrelevant data\n>   stuffed in transactions.\n>\n>   There is also a very clear pattern we've seen in the past where\n>   people take anything the system lets them do as strong evidence that\n>   they have a irrevocable right to use the system in that way, and that\n>   their only responsibility-- and if their usage harms the system it's\n>   the responsibility of the system to not permit it. [...\n>   ...] For mitigating these risks it's optimal if transactions\n>   seem as uniform and indistinguishable as reasonably possible.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/5286#issuecomment-72564175\n>\n> Perhaps see also sdaftuar in Nov 2015,\n>\n>   To me the most important question is, is priority something that miners\n>   want to use?\n>\n>   If a non-negligible amount of hashpower intends to use it in their\n>   transaction selection, then I think it makes sense for nodes to use it\n>   too, because it's generally helpful to have your mempool predict the\n>   UTXO as much as possible, and for nodes to be able to have reasonable\n>   fee and priority estimates (which won't happen unless they track the\n>   priority transactions somehow -- I'm presuming that miners run with\n>   much bigger mempools than regular nodes).\n>\n>   If the answer is no, then that's fine and I don't see a reason to push\n>   in this direction. I sort of assumed there was enough hashpower mining\n>   with priority, since last time I checked estimatepriority was still\n>   giving meaningful results for low-ish blockheights, but I haven't done\n>   any kind of real analysis.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/6992#issuecomment-155969455\n>\n> or in June 2019,\n>\n>   What this PR is proposing is to get rid of a command-line option that is\n>   (a) a footgun for users and (b) does not reflect what I believe to be\n>   the understanding most users have, which is that [X txs] are expected\n>   to propagate well on the network.\n>\n>   ..\n>\n>   I don't think this rises to the level that Luke is concerned about,\n>   namely a prelude to forcing a common relay policy on all nodes. In\n>   particular I do agree it makes sense that we offer some ways of\n>   customizing policy parameters (eg the mempool size, min relay fee,\n>   etc). Instead, I think the justification for this change is that we\n>   should not support behaviors we think are harmful to the ecosystem\n>   overall and have no legitimate use-case, and we should eliminate ways\n>   that users might inadvertently shoot themselves in the foot.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/16171#issuecomment-500393271\n>\n> (or see discussion in https://github.com/bitcoin/bitcoin/pull/7219)\n>\n> I don't mean to imply the above are saying \"there's one way to do\n> things and it's this way\", or that the old way of doing things should\n> necessarily be the way we keep doing things. Just that previously core\n> has tended towards designing a single policy that works as well as it\n> can for everyone and the ecosystem as a whole. (I'm also not saying that\n> fullrbf can't work well for everyone or the ecosystem as a whole)\n>\n>\n> By contrast, I think the most common response to pushback against the\n> full rbf option has been along the lines of \"it's just an option, we\n> don't want to force people\", eg:\n>\n>   Blaming the default false -mempoolfullrbf option for a full RBF network\n>   would be holding Bitcoin Core developers responsible for the decisions\n>   of individual node operators and miners. I don't think having the\n>   option (again, default false) can directly cause a full RBF network,\n>   and likewise, I don't think removing this option removes the \"risk\"\n>   of a full RBF network.\n>    - glozow\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274949400\n>\n>   NACK. This is a default false option.\n>    - achow101\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n>\n>   Erecting artificial barriers to prevent or make it difficult for users\n>   to do what they want to do, is not appropriate behaviour.\n>    - luke-jr\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1290721905\n>\n>   I'm in general against removing options.\n>    - instagibbs\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1292030700\n>\n> I think this differs from what core has done in the past, in that\n> previously we've tried to ensure a new policy is good for everyone (or as\n> nearly as it can be), and then enabled it as soon as it's implemented.\n> Any options that have been added have either been to control resource\n> usage in ways that don't significantly effect tx propagation, to\n> allow people to revert to the old behaviour when the new behaviour is\n> controversial (eg the -mempoolreplacement=0 option from 0.12 to 0.18),\n> and to make it easier to test/debug the implementation.\n>\n> Giving people a new relay behaviour they can opt-in to when we aren't\n> confident enough to turn on by default doesn't match the approach I've\n> seen core take in the past.\n>\n>\n> If this is going to be an ongoing shift in how core sees relay/mempool\n> policy, I think that's significant and worth paying attention to.\n>\n> I don't think it's necessary to have that shift to roll out full rbf.\n> The other approach would be either:\n>\n>  * set -mempoolfullrbf=true as the default for 24.0, and just have the\n>    command line param there in case people want to do a\n>    \"UserRejectedMempoolPolicy\" campaign to get everyone to opt-out\n>\n>  * revert it for now because we don't think mainnet is ready for fullrbf\n>    yet, and introduce it as default true for 25.0 or 26.0 or 27.0 or\n>    to activate at some scheduled date in that timeframe (potentially\n>    backporting it to previous releases to help with adoption too,\n>    whatever). same effect as the previous option, just with a bit more\n>    advanced notice and time to prepare\n>\n> I don't think anyone's proposed the first (which I interpret as \"most of\n> us don't think mainnet is ready for fullrbf today\"), but the comments\n> above are all pushback by people arguing against (the first step of)\n> the second approach, and they seem to be winning the day.\n>\n> It's also possible that this is something of a one time thing: full rbf\n> has been controversial for ages, but widely liked by devs, and other\n> attempts (eg making it available in knots) haven't actually achieved\n> much of a result in practice. So maybe this is just a special case and\n> not a precedent, and when people propose other default false options,\n> there will be substantially more resistance to them being merged,\n> despite all the talk about users having options that's going on right now.\n>\n>\n> Assuming it is the change of direction it appears to be -- and all of\n> the above is really just justification for that assumption -- then like\n> I said, I think it's worth seriously considering what it means for people\n> to choose their own relay/mempool policies and for you to expect to have\n> different mempool policies to many or most of your potential peers.\n>\n>\n> One thing maybe worth noting is that is that you can still only choose\n> your policy from options that people write code for -- if it wasn't\n> something you could get by running knots or compiling a rejected PR\n> yourself, it won't magically become more possible now.  Presumably it\n> would mean that once a PR is written, it might get better review (rather\n> than being dismissed as not suitable for everyone), and there would be\n> less maintenance burden than if it had to be manually rebased every\n> release, though (or at least the maintenance burden would be shared\n> across everyone working on the codebase).\n>\n>\n> The second thing is that whatever your relay policy is, you still\n> need a path all the way to miners through nodes that will accept your\n> transaction at every step. If you're making your mempool more restrictive\n> (eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\n> you're making life more difficult for people who do create those sorts\n> of txs); but if you want a more permissive policy (package relay,\n> version-3-rbf, full-rbf), you might need to do some work.\n>\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your tx,\n> just by random chance. If erlay allows increasing your outbound count to\n> 12 connections instead of 8; that might reduce down to needing just 20%\n> of listening nodes (~93%).\n>\n> But for cases where less than 30% (20%) of network supports your preferred\n> policy, you probably need to do something cleverer.\n>\n> One approach is to set a service bit and preferentially peer with other\n> nodes that advertise that service bit; knots does the first half of this\n> for fullrbf, and both halves have been proposed for core in #25600.\n> Preferential peering was previously done for the segwit deployment,\n> though in that case it was necessary not just for tx propogation but\n> also for ensuring block propogation, making it effectively a consensus\n> critical issue.\n>\n> Another approach is having a separate relay network -- eg, lightning nodes\n> already have a gossip network, and might want to help their own ecosystem\n> by ensuring unilateral channel closes and justice transactions are quickly\n> relayed. Using their own gossip network to relay the transaction around,\n> and each lightning node adding it to their local bitcoind's mempool and\n> allowing it to propogate (or not) from there as normal, would also be a\n> way of allowing transactions to propogate well. It does mean that miners\n> would either need to also participate in lightning gossip directly, or\n> that miners would need to connect to *many* peers to be confident of\n> seeing those transactions (eg, if only 2% of the network would see a\n> tx, you'd need to make 228 connections to have a 99% chance of seeing\n> the tx). You can't currently do something like this, because all the\n> relay policies are also applied when adding txs to the mempool via RPC,\n> and there's no convenient way to remove txs from the mempool.\n>\n> A case where something like that might occur is in preventing L2\n> transactions from pinning attacks -- so you might have a high-fee,\n> low-feerate transaction that's been widely propogated, sitting in the\n> bottom of people's mempools, and you want to replace it with a smaller,\n> higher-feerate transaction, but don't want to pay a higher absolute fee,\n> and are thus blocked by BIP 125 rule 3. Perhaps 98% of the network is\n> unwilling to deviate from BIP 125 rule 3 for you; because that would\n> make it easy for random griefers to spam their mempool with large txs\n> then delete them while only paying a small fee; but your L2 peers may be\n> able to decode your replacement transaction and be sure that you aren't\n> going to spam them, and thus will happily relay it.\n>\n> From a technical point-of-view, that's largely fine; the downside is it\n> increases the centralisation pressure on mining: whether that's by having\n> to connect to substantially more nodes, or having to parse through more\n> spam, you can't just run your mining operation off a standard install\n> of bitcoin core anymore, but need to actively opt-in to find all the\n> weird unusual ways people are sending transactions around in order to\n> actually collect as much in fees as your competitors are.\n>\n> That's probably moderately bad for privacy as well -- if lightning or\n> coinjoins need special relay rules that most nodes haven't opted into,\n> it's potentially easy to use that to find the bitcoin nodes on the\n> network that are participating in those protocols, and from there to\n> either identify the operator, or run a DoS attack to make it hard for you\n> to keep doing what you want. Obviously if you're setting a service bit to\n> get better routing, you've given up that privacy already. Likewise if the\n> government or random vandals are opposed to bitcoin mining, and miners\n> have to have special configuration on their nodes that distinguish them\n> from regular users, then perhaps that makes it easier to find or shut\n> down their operations.\n>\n> There are a few efficiencies to be gained from similar mempool policies as\n> well: more reliable compact block reconstruction (if you're not missing\n> any transactions, you avoid a round-trip) and presumably more efficient\n> set reconstruction with erlay. You'll also waste less bandwidth sending\n> transactions that the other node is only going to reject. Both those\n> depend on how many transactions are going to rely on unusual mempool\n> policies in the first place though.\n>\n> ariard wrote:\n>\n>   I know I've advocated in the past to turn RBF support by default in\n>   the past. Though after gathering a lot of feedbacks, this approach\n>   of offering the policy flexiblity to the interested users only and\n>   favoring a full-rbf gradual deployment sounds better to me.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/25353#issuecomment-1157137026\n>\n> I guess all the above leads me to think that gradual deployments of\n> mempool policies are likely the worse approach: even when they're not\n> hurting anyone, it makes them hard to use during the gradual phase,\n> and getting around that comes with worrying compromises on privacy and\n> centralisation; and when they are problematic for some, the indeterminate\n> nature of a gradual deployment means it's hard to plan for when that\n> risk is going to eventuate.\n>\n>\n> Theoretically, one way to recover the good parts of core deciding on\n> what's good for the network might be for people outside of core to\n> recommend a mempool configuration; then core can just have an option\n> to make that easy, similar to \"-std=c++17\" for a C++ compiler, and much\n> the same as knots' \"-corepolicy\" option.\n>\n> Presuming anyone actually wants to take on that job, and listen to the\n> concerns of zeroconf businesses, lightning and coinjoin devs, miners, etc;\n> and can come up with something that keeps most of them happy, and that\n> 70% or 90% of the network ends up just following those recommendations\n> because it's easy, it works, and it's recommended by all the apps they\n> want to use, then that could work great:\n>\n>  * miners don't need to do anything special, so there's no new\n>    mining centralisation pressure\n>  * miners and users don't reveal what they're doing with bitcoin by the way\n>    they configure their nodes, so there's no privacy problems\n>  * devs can be fairly confident in how they have to design their apps\n>    in order to get their transactions to most hashpower\n>  * devs don't have to add new p2p layers to make it happen\n>  * at least there's someone to talk to when you're trying to figure out\n>    how to make some new project possible when it's inhibited by current\n>    relay policies and you don't have to try to convince everyone to\n>    upgrade on your own\n>  * core devs just provide options, and don't have to worry about being\n>    seen as gatekeepers\n>\n> The \"downside\" in that scenario is that users/dev aren't making much\n> actual use of all the choices core is offering by making different\n> options available; but the upside is that that choice is at least readily\n> available should whoever is coming up with these policy become out of\n> step with what people actually want.\n>\n> One thing that might make an approach like that difficult is that core\n> has historically been happy to remove options that don't seem useful\n> anymore: eg the ability to turn of BIP 125 support (#16171), and priority\n> transactions (#9602). Perhaps that's fine if you're trying to actively\n> craft a single mempool/relay policy that's good enough for almost everyone\n> (after all, it makes the code simpler and more efficient, and reduces\n> the number of footguns); all you're doing is leaving a minority of people\n> who want weird things to run a fork, and that's going to happen anyway.\n>\n> But if people are following policy developed outside of core, core\n> might well disagree with them and decide \"no that's a stupid policy,\n> no one should do that\" and remove some feature that others thing should\n> continue to be normal. Beyond the examples above, there's already talk of\n> removing the ability to disable fullrbf support in #26305, for instance.\n> If that happens, then the people maintaining the policy will instead\n> end up maintaining an entire fork of bitcoin core, and all we've done\n> is transition to people running software from a different repo, and a\n> different set of maintainers.\n>\n> If we're really going to a world where core's eager to add new options,\n> and reluctant to remove them, at least if anyone at all finds them\n> interesting, that's presumably a non-issue, though.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/1d0aaf6c/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-27T15:37:27",
                "message_text_only": "On Thu, Oct 27, 2022 at 01:36:47PM +0100, Gloria Zhao wrote:\n> > The cutoff for that is probably something like \"do 30% of listening\n> > nodes have a compatible policy\"? If they do, then you'll have about a\n> > 95% chance of having at least one of your outbound peers accept your tx,\n> > just by random chance.\n> Yes, in most cases, whether Bitcoin Core is restricting or loosening\n> policy, the user in question is fine as long as they have a path from their\n> node to a miner that will accept it. This is the case for something like\n> -datacarriersize if the use case is putting stuff into OP_RETURN outputs,\n> or if they're LN and using CPFP carveout, v3, package relay, etc.\n\n> But\n> replacement is not only a question of \"will my transaction propagate\" but\n> also, \"will someone else's transaction propagate, invalidating mine\" or, in\n> other words, \"can I prevent someone else's transaction from propagating.\"\n\n\"Can I prevent someone else's transaction from propagating\" is almost\nthe entirety of the question with -datacarrier, -datacarriersize and\n-permitbaremultisig though: \"we\" don't want people to spam the utxo\nset or the blockchain with lots of data (cf BSV's gigabytes worth of\ndog pictures [0]), so for the people who are going to find some way\nof putting data in we'd like to encourage them to make it small, and\ndo it in a way that's prunable and doesn't bloat the utxo set, whose\nsize matters even more than the overall blockchain's size does. As I\nunderstand it, people were doing that by creating bare multisig utxos,\nie a bare (non-p2sh) scriptPubKey that perhaps looks like:\n\n  1 my_key data1 data2 data3 data4 data5 5 CHECKMULTISIG\n\nwhich is \"bad\" in two ways: you're only committing to the data, so why\nnot save 128 bytes by doing hash(data1 data2 data3 data4 data5) instead;\nand even more so, that data is only interesting to you, not everyone else,\nso why not do it in a way that doesn't bloat the utxo set, which we want\nto keep small so that it's easier to efficiently look up potential spends.\n\nHence the -datacarriersize limitation that limits you to about 2.5\n\"dataN\" entries per tx (\"we'll prevent your tx from propagating if you\ndo much more than publish a hash\") and hence at least the potential for\ndoing the same for baremultisig in general.\n\n[0] https://twitter.com/bsvdata/status/1427866510035324936\n\n> A\n> zeroconf user relies on there *not* being a path from someone else's full\n> RBF node to a full RBF miner. This is why I think RBF is so controversial\n> in general,\n\nYes; but I think it's also true to say that this is why *zeroconf* is as\ncontroversial as it is.\n\nLikewise OP_RETURN has had its own \"controversies\" to some extent, too:\n\n  https://blog.bitmex.com/dapps-or-only-bitcoin-transactions-the-2014-debate/\n  https://github.com/bitcoin/bitcoin/pull/3715\n  https://github.com/bitcoin/bitcoin/pull/3939\n\n> why -mempoolfullrbf on someone else's node is considered more\n> significant than another policy option, and why full RBF shouldn't be\n> compared with something like datacarriersize.\n\nIt's definitely a different scenario: unexpected RBF can cause you to\nhave less money than you expected; whereas more OP_RETURN data just\nbloats the blockchain, and losing money that you thought was yours is\ndefinitely more painful than more spam.\n\nBut while the level of pain is different; I don't think the mechanism is:\nwhether you're trying to preserve zeroconf or prevent utxo set spam,\nyou're still relying on a vast majority of nodes working together to\nprevent even a small minority of hashpower from doing \"bad\" things, with\nno cryptographic assurances that will continue to work well or at all.\n\n> I don't think past patterns can be easily applied here,\n\nI mean, technically they trivially could? We *could* roll out support for\nfull RBF in exactly the same way we rolled out support for opt-in RBF:\nmaking it the default for all nodes, but supplying an option that node\noperators can use to disable the feature for seven releases / ~4 years:\n\nhttps://bitcoin.org/en/release/v0.12.0#opt-in-replace-by-fee-transactions\nhttps://bitcoin.org/en/release/v0.19.0.1#deprecated-or-removed-configuration-options\n\nIf we don't want to do that immediately, but also want to make a definite\nmove forward, then we could:\n\n * just say that, and then keep our word about it\n * keep the feature in master, but remove it in 24.x\n * put a time delay on the feature so that it doesn't happen immediately\n   but is locked in in the code for whenever we are ready to do it\n\n> and I don't think this necessarily shows a\n> different \"direction\" in thinking about mempool policy in general.\n\nIf we're not applying past patterns, then this is a different direction\nin how we're thinking about things than what we did in the past.\n\nThat's not necessarily a bad thing -- maybe we should be thinking\ndifferently; but I don't see how you can honestly dispute it: those are\njust two ways of saying the exact same thing.\n\nCheers,\naj"
            },
            {
                "author": "Luke Dashjr",
                "date": "2022-10-27T18:17:38",
                "message_text_only": "More generally, some of the arguments against full RBF seem like debatable \nreasons (though not fully convincing) to possibly leave it off, and/or \ndisabled by default, but definitely NOT reasons to remove the option and \nprevent users from deciding for themselves.\n\nOn Thursday 27 October 2022 15:37:27 Anthony Towns via bitcoin-dev wrote:\n> \"Can I prevent someone else's transaction from propagating\" is almost\n> the entirety of the question with -datacarrier, -datacarriersize and\n> -permitbaremultisig though:\n\nNot necessarily the entirety, no. Even if others would propagate it, you also \ndon't want to waste _your_ bandwidth doing so. This also reveals a difference \nbetween the two policies: with RBF, you have _already_ spent resources \npropagating the first transaction (what this implies is not immediately \nobvious).\n\nLuke"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-27T13:49:48",
                "message_text_only": "To add a wrinkle, or possibly a confirmation of your long message, up to\nreaders to decipher, there historically has been at least one more RBF\nrelated option that was included, then removed later in Core.\n\nIntroduced as \"permitrbf\" in b768108d9c0b83330572711aef1e569543130d5e with\ndefault \"true\", later renamed to \"replacebyfee\", then finally as\n\"mempoolreplacement\".\n\nIt was later removed in 8053e5cdade87550f0381d51feab81dedfec6c46 with the\nmessage:\n\n\"\nRemove -mempoolreplacement to prevent needless block prop slowness.\n\n    At this point there is no reasonable excuse to disable opt-in RBF,\n    and, unlike when this option was added, there are now significant\n    issues created when disabling it (in the form of compact block\n    reconstruction failures). Further, it breaks a lot of modern wallet\n    behavior.\n\"\n\nSo there is some precedence to including an option that protocol devs don't\nfind useful, then removing it N years later to make sure it doesn't impact\ncompact blocks.\n\nPeering into the \"precedence\" lense, I think this does lend itself to the\ntheory that the transition should be as uniform as possible to avoid\ndegradation of fast block propagation. If not removing options(which is\ndeemed user hostile by a number of folks including me), then at least for a\nflag day switchover.\n\nCheers,\nGreg\n\nOn Wed, Oct 26, 2022 at 7:53 PM Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi *,\n>\n> TLDR: Yes, this post is too long, and there's no TLDR. If it's any\n> consolation, it took longer to write than it does to read?\n>\n> On Tue, Jun 15, 2021 at 12:55:14PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > Subject: Re: [bitcoin-dev] Proposal: Full-RBF in Bitcoin Core 24.0\n> > I'm writing to propose deprecation of opt-in RBF in favor of full-RBF\n>\n> > If there is ecosystem agreement on switching to full-RBF, but 0.24 sounds\n> > too early, let's defer it to 0.25 or 0.26. I don't think Core has a\n> > consistent deprecation process w.r.t to policy rules heavily relied-on by\n> > Bitcoin users, if we do so let sets a precedent satisfying as many folks\n> as\n> > we can.\n>\n> One precedent that seems to be being set here, which to me seems fairly\n> novel for bitcoin core, is that we're about to start supporting and\n> encouraging nodes to have meaningfully different mempool policies. From\n> what I've seen, the baseline expectation has always been that while\n> certainly mempools can and will differ, policies will be largely the same:\n>\n>   Firstly, there is no \"the mempool\". There is no global mempool. Rather\n>   each node maintains its own mempool and accepts and rejects transaction\n>   to that mempool using their own internal policies. Most nodes have\n>   the same policies, but due to different start times, relay delays,\n>   and other factors, not every node has the same mempool, although they\n>   may be very similar.\n>\n>   -\n> https://bitcoin.stackexchange.com/questions/98585/how-to-find-if-two-transactions-in-mempool-are-conflicting\n>\n> Up until now, the differences between node policies supported by different\n> nodes running core have been quite small, with essentially the following\n> options available:\n>\n>  -minrelaytxfee, -maxmempool - changes the lowest fee rate you'll accept\n>\n>  -mempoolexpiry - how long to keep txs in the mempool\n>\n>  -datacarrier - reject txs creating OP_RETURN outputs\n>\n>  -datacarriersize - maximum size of OP_RETURN data\n>\n>  -permitbaremultisig - prevent relay of bare multisig\n>\n>  -bytespersigop - changes how SIGOP accounting works for relay and\n>  mining prioritisation\n>\n> as well as these, marked as \"debug only\" options (only shown with\n> -help-debug):\n>\n>  -incrementalrelayfee - make it easier/harder to spam txs by only\n>  slightly bumping the fee; marked as a \"debug only\" option\n>\n>  -dustrelayfee - make it easier/harder to create uneconomic utxos;\n>  marked as a \"debug only\" option\n>\n>  -limit{descendant,ancestor}{count,size} - changes how large the\n>  transaction chains can be; marked as a \"debug only\" option\n>\n> and in theory, but not available on mainnet:\n>\n>  -acceptnonstdtxn - relay/mine non standard transactions\n>\n> There's also the \"prioritisetransaction\" rpc, which can cause you to keep\n> a low feerate transaction in your mempool longer than you might otherwise.\n>\n> I think that -minrelaytxfee, -maxmempool and -mempoolexpiry are the only\n> ones of those options commonly set, and those only rarely result in any\n> differences in the txs at the top of the mempool.\n>\n> There are also quite a few parameters that aren't even runtime\n> configurable:\n>\n>  - MAX_STANDARD_TX_WEIGHT\n>  - MIN_STANDARD_TX_NONWITNESS_SIZE (see also #26265)\n>  - MAX_P2SH_SIGOPS (see also #26348)\n>  - MAX_STANDARD_TX_SIGOPS_COST\n>  - MAX_STANDARD_P2WSH_STACK_ITEMS\n>  - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE\n>  - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE\n>  - MAX_STANDARD_P2WSH_SCRIPT_SIZE\n>  - MAX_STANDARD_SCRIPTSIG_SIZE\n>  - EXTRA_DESCENDANT_TX_SIZE_LIMIT\n>  - MAX_REPLACEMENT_CANDIDATES\n>\n> And other plausible options aren't configurable even at compile time\n> -- eg, core doesn't implement BIP 125's inherited signalling rule so\n> there's no way to enable it; core doesn't allow opting out of BIP 125\n> rule 3 ratchet on absolute fee; core doesn't allow CPFP carveout with\n> more than 1 ancestor; core doesn't allow opting out of LOW_S checks\n> (even via -acceptnonstdtxn); etc.\n>\n> We also naturally have different mempool policies between different\n> releases: eg, expansions of policy, such as allowing OP_RETURN or\n> expanding it from 40 to 80 bytes or new soft forks where old nodes won't\n> relay transactions that use the new; and also occassional restrictions\n> in policy, such as the LOW_S requirement.\n>\n>\n> While supporting and encouraging different mempool polices might be new\n> for core, it's not new for knots: knots changes some of these defaults\n> (-permitbaremultisig defaults to false, -datacarriersize is reduced to\n> 42), allows the use of -acceptnonstdtxn on mainnet, and introduces new\n> options including -spkreuse and -mempoolreplacement (giving the latter\n> full rbf behaviour by default). Knots also includes a `-corepolicy`\n> option to make it easy to get a configuration matching core's defaults.\n>\n>\n> I think gmaxwell's take from Feb 2015 (in the context of how restrictive\n> policy on OP_RETURN data should be) was a reasonable description for\n> core's approach up until now:\n>\n>   There is also a matter of driving competent design rather than lazy\n>   first thing that works. E.g. In stealth addresses the early proposals\n>   use highly inefficient single ECDH point per output instead of simply\n>   pooling them. Network behavior is one of the few bits of friction\n>   driving good technical design rather than \"move fast, break things, and\n>   force everyone else onto my way of doing thing rather than discussing\n>   the design in public\". No one wants to be an outright gatekeeper,\n>   but the network is a shared resource and it's perfectly reasonable\n>   node behavior to be stingy about the perpetual storage impact of the\n>   transactions they're willing to process, especially when it comes to\n>   neutral technical criteria like the amount of network irrelevant data\n>   stuffed in transactions.\n>\n>   There is also a very clear pattern we've seen in the past where\n>   people take anything the system lets them do as strong evidence that\n>   they have a irrevocable right to use the system in that way, and that\n>   their only responsibility-- and if their usage harms the system it's\n>   the responsibility of the system to not permit it. [...\n>   ...] For mitigating these risks it's optimal if transactions\n>   seem as uniform and indistinguishable as reasonably possible.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/5286#issuecomment-72564175\n>\n> Perhaps see also sdaftuar in Nov 2015,\n>\n>   To me the most important question is, is priority something that miners\n>   want to use?\n>\n>   If a non-negligible amount of hashpower intends to use it in their\n>   transaction selection, then I think it makes sense for nodes to use it\n>   too, because it's generally helpful to have your mempool predict the\n>   UTXO as much as possible, and for nodes to be able to have reasonable\n>   fee and priority estimates (which won't happen unless they track the\n>   priority transactions somehow -- I'm presuming that miners run with\n>   much bigger mempools than regular nodes).\n>\n>   If the answer is no, then that's fine and I don't see a reason to push\n>   in this direction. I sort of assumed there was enough hashpower mining\n>   with priority, since last time I checked estimatepriority was still\n>   giving meaningful results for low-ish blockheights, but I haven't done\n>   any kind of real analysis.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/6992#issuecomment-155969455\n>\n> or in June 2019,\n>\n>   What this PR is proposing is to get rid of a command-line option that is\n>   (a) a footgun for users and (b) does not reflect what I believe to be\n>   the understanding most users have, which is that [X txs] are expected\n>   to propagate well on the network.\n>\n>   ..\n>\n>   I don't think this rises to the level that Luke is concerned about,\n>   namely a prelude to forcing a common relay policy on all nodes. In\n>   particular I do agree it makes sense that we offer some ways of\n>   customizing policy parameters (eg the mempool size, min relay fee,\n>   etc). Instead, I think the justification for this change is that we\n>   should not support behaviors we think are harmful to the ecosystem\n>   overall and have no legitimate use-case, and we should eliminate ways\n>   that users might inadvertently shoot themselves in the foot.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/16171#issuecomment-500393271\n>\n> (or see discussion in https://github.com/bitcoin/bitcoin/pull/7219)\n>\n> I don't mean to imply the above are saying \"there's one way to do\n> things and it's this way\", or that the old way of doing things should\n> necessarily be the way we keep doing things. Just that previously core\n> has tended towards designing a single policy that works as well as it\n> can for everyone and the ecosystem as a whole. (I'm also not saying that\n> fullrbf can't work well for everyone or the ecosystem as a whole)\n>\n>\n> By contrast, I think the most common response to pushback against the\n> full rbf option has been along the lines of \"it's just an option, we\n> don't want to force people\", eg:\n>\n>   Blaming the default false -mempoolfullrbf option for a full RBF network\n>   would be holding Bitcoin Core developers responsible for the decisions\n>   of individual node operators and miners. I don't think having the\n>   option (again, default false) can directly cause a full RBF network,\n>   and likewise, I don't think removing this option removes the \"risk\"\n>   of a full RBF network.\n>    - glozow\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274949400\n>\n>   NACK. This is a default false option.\n>    - achow101\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n>\n>   Erecting artificial barriers to prevent or make it difficult for users\n>   to do what they want to do, is not appropriate behaviour.\n>    - luke-jr\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1290721905\n>\n>   I'm in general against removing options.\n>    - instagibbs\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1292030700\n>\n> I think this differs from what core has done in the past, in that\n> previously we've tried to ensure a new policy is good for everyone (or as\n> nearly as it can be), and then enabled it as soon as it's implemented.\n> Any options that have been added have either been to control resource\n> usage in ways that don't significantly effect tx propagation, to\n> allow people to revert to the old behaviour when the new behaviour is\n> controversial (eg the -mempoolreplacement=0 option from 0.12 to 0.18),\n> and to make it easier to test/debug the implementation.\n>\n> Giving people a new relay behaviour they can opt-in to when we aren't\n> confident enough to turn on by default doesn't match the approach I've\n> seen core take in the past.\n>\n>\n> If this is going to be an ongoing shift in how core sees relay/mempool\n> policy, I think that's significant and worth paying attention to.\n>\n> I don't think it's necessary to have that shift to roll out full rbf.\n> The other approach would be either:\n>\n>  * set -mempoolfullrbf=true as the default for 24.0, and just have the\n>    command line param there in case people want to do a\n>    \"UserRejectedMempoolPolicy\" campaign to get everyone to opt-out\n>\n>  * revert it for now because we don't think mainnet is ready for fullrbf\n>    yet, and introduce it as default true for 25.0 or 26.0 or 27.0 or\n>    to activate at some scheduled date in that timeframe (potentially\n>    backporting it to previous releases to help with adoption too,\n>    whatever). same effect as the previous option, just with a bit more\n>    advanced notice and time to prepare\n>\n> I don't think anyone's proposed the first (which I interpret as \"most of\n> us don't think mainnet is ready for fullrbf today\"), but the comments\n> above are all pushback by people arguing against (the first step of)\n> the second approach, and they seem to be winning the day.\n>\n> It's also possible that this is something of a one time thing: full rbf\n> has been controversial for ages, but widely liked by devs, and other\n> attempts (eg making it available in knots) haven't actually achieved\n> much of a result in practice. So maybe this is just a special case and\n> not a precedent, and when people propose other default false options,\n> there will be substantially more resistance to them being merged,\n> despite all the talk about users having options that's going on right now.\n>\n>\n> Assuming it is the change of direction it appears to be -- and all of\n> the above is really just justification for that assumption -- then like\n> I said, I think it's worth seriously considering what it means for people\n> to choose their own relay/mempool policies and for you to expect to have\n> different mempool policies to many or most of your potential peers.\n>\n>\n> One thing maybe worth noting is that is that you can still only choose\n> your policy from options that people write code for -- if it wasn't\n> something you could get by running knots or compiling a rejected PR\n> yourself, it won't magically become more possible now.  Presumably it\n> would mean that once a PR is written, it might get better review (rather\n> than being dismissed as not suitable for everyone), and there would be\n> less maintenance burden than if it had to be manually rebased every\n> release, though (or at least the maintenance burden would be shared\n> across everyone working on the codebase).\n>\n>\n> The second thing is that whatever your relay policy is, you still\n> need a path all the way to miners through nodes that will accept your\n> transaction at every step. If you're making your mempool more restrictive\n> (eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\n> you're making life more difficult for people who do create those sorts\n> of txs); but if you want a more permissive policy (package relay,\n> version-3-rbf, full-rbf), you might need to do some work.\n>\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your tx,\n> just by random chance. If erlay allows increasing your outbound count to\n> 12 connections instead of 8; that might reduce down to needing just 20%\n> of listening nodes (~93%).\n>\n> But for cases where less than 30% (20%) of network supports your preferred\n> policy, you probably need to do something cleverer.\n>\n> One approach is to set a service bit and preferentially peer with other\n> nodes that advertise that service bit; knots does the first half of this\n> for fullrbf, and both halves have been proposed for core in #25600.\n> Preferential peering was previously done for the segwit deployment,\n> though in that case it was necessary not just for tx propogation but\n> also for ensuring block propogation, making it effectively a consensus\n> critical issue.\n>\n> Another approach is having a separate relay network -- eg, lightning nodes\n> already have a gossip network, and might want to help their own ecosystem\n> by ensuring unilateral channel closes and justice transactions are quickly\n> relayed. Using their own gossip network to relay the transaction around,\n> and each lightning node adding it to their local bitcoind's mempool and\n> allowing it to propogate (or not) from there as normal, would also be a\n> way of allowing transactions to propogate well. It does mean that miners\n> would either need to also participate in lightning gossip directly, or\n> that miners would need to connect to *many* peers to be confident of\n> seeing those transactions (eg, if only 2% of the network would see a\n> tx, you'd need to make 228 connections to have a 99% chance of seeing\n> the tx). You can't currently do something like this, because all the\n> relay policies are also applied when adding txs to the mempool via RPC,\n> and there's no convenient way to remove txs from the mempool.\n>\n> A case where something like that might occur is in preventing L2\n> transactions from pinning attacks -- so you might have a high-fee,\n> low-feerate transaction that's been widely propogated, sitting in the\n> bottom of people's mempools, and you want to replace it with a smaller,\n> higher-feerate transaction, but don't want to pay a higher absolute fee,\n> and are thus blocked by BIP 125 rule 3. Perhaps 98% of the network is\n> unwilling to deviate from BIP 125 rule 3 for you; because that would\n> make it easy for random griefers to spam their mempool with large txs\n> then delete them while only paying a small fee; but your L2 peers may be\n> able to decode your replacement transaction and be sure that you aren't\n> going to spam them, and thus will happily relay it.\n>\n> From a technical point-of-view, that's largely fine; the downside is it\n> increases the centralisation pressure on mining: whether that's by having\n> to connect to substantially more nodes, or having to parse through more\n> spam, you can't just run your mining operation off a standard install\n> of bitcoin core anymore, but need to actively opt-in to find all the\n> weird unusual ways people are sending transactions around in order to\n> actually collect as much in fees as your competitors are.\n>\n> That's probably moderately bad for privacy as well -- if lightning or\n> coinjoins need special relay rules that most nodes haven't opted into,\n> it's potentially easy to use that to find the bitcoin nodes on the\n> network that are participating in those protocols, and from there to\n> either identify the operator, or run a DoS attack to make it hard for you\n> to keep doing what you want. Obviously if you're setting a service bit to\n> get better routing, you've given up that privacy already. Likewise if the\n> government or random vandals are opposed to bitcoin mining, and miners\n> have to have special configuration on their nodes that distinguish them\n> from regular users, then perhaps that makes it easier to find or shut\n> down their operations.\n>\n> There are a few efficiencies to be gained from similar mempool policies as\n> well: more reliable compact block reconstruction (if you're not missing\n> any transactions, you avoid a round-trip) and presumably more efficient\n> set reconstruction with erlay. You'll also waste less bandwidth sending\n> transactions that the other node is only going to reject. Both those\n> depend on how many transactions are going to rely on unusual mempool\n> policies in the first place though.\n>\n> ariard wrote:\n>\n>   I know I've advocated in the past to turn RBF support by default in\n>   the past. Though after gathering a lot of feedbacks, this approach\n>   of offering the policy flexiblity to the interested users only and\n>   favoring a full-rbf gradual deployment sounds better to me.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/25353#issuecomment-1157137026\n>\n> I guess all the above leads me to think that gradual deployments of\n> mempool policies are likely the worse approach: even when they're not\n> hurting anyone, it makes them hard to use during the gradual phase,\n> and getting around that comes with worrying compromises on privacy and\n> centralisation; and when they are problematic for some, the indeterminate\n> nature of a gradual deployment means it's hard to plan for when that\n> risk is going to eventuate.\n>\n>\n> Theoretically, one way to recover the good parts of core deciding on\n> what's good for the network might be for people outside of core to\n> recommend a mempool configuration; then core can just have an option\n> to make that easy, similar to \"-std=c++17\" for a C++ compiler, and much\n> the same as knots' \"-corepolicy\" option.\n>\n> Presuming anyone actually wants to take on that job, and listen to the\n> concerns of zeroconf businesses, lightning and coinjoin devs, miners, etc;\n> and can come up with something that keeps most of them happy, and that\n> 70% or 90% of the network ends up just following those recommendations\n> because it's easy, it works, and it's recommended by all the apps they\n> want to use, then that could work great:\n>\n>  * miners don't need to do anything special, so there's no new\n>    mining centralisation pressure\n>  * miners and users don't reveal what they're doing with bitcoin by the way\n>    they configure their nodes, so there's no privacy problems\n>  * devs can be fairly confident in how they have to design their apps\n>    in order to get their transactions to most hashpower\n>  * devs don't have to add new p2p layers to make it happen\n>  * at least there's someone to talk to when you're trying to figure out\n>    how to make some new project possible when it's inhibited by current\n>    relay policies and you don't have to try to convince everyone to\n>    upgrade on your own\n>  * core devs just provide options, and don't have to worry about being\n>    seen as gatekeepers\n>\n> The \"downside\" in that scenario is that users/dev aren't making much\n> actual use of all the choices core is offering by making different\n> options available; but the upside is that that choice is at least readily\n> available should whoever is coming up with these policy become out of\n> step with what people actually want.\n>\n> One thing that might make an approach like that difficult is that core\n> has historically been happy to remove options that don't seem useful\n> anymore: eg the ability to turn of BIP 125 support (#16171), and priority\n> transactions (#9602). Perhaps that's fine if you're trying to actively\n> craft a single mempool/relay policy that's good enough for almost everyone\n> (after all, it makes the code simpler and more efficient, and reduces\n> the number of footguns); all you're doing is leaving a minority of people\n> who want weird things to run a fork, and that's going to happen anyway.\n>\n> But if people are following policy developed outside of core, core\n> might well disagree with them and decide \"no that's a stupid policy,\n> no one should do that\" and remove some feature that others thing should\n> continue to be normal. Beyond the examples above, there's already talk of\n> removing the ability to disable fullrbf support in #26305, for instance.\n> If that happens, then the people maintaining the policy will instead\n> end up maintaining an entire fork of bitcoin core, and all we've done\n> is transition to people running software from a different repo, and a\n> different set of maintainers.\n>\n> If we're really going to a world where core's eager to add new options,\n> and reluctant to remove them, at least if anyone at all finds them\n> interesting, that's presumably a non-issue, though.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/e73c3002/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-27T15:00:16",
                "message_text_only": "On Thu, Oct 27, 2022 at 09:49:48AM -0400, Greg Sanders via bitcoin-dev wrote:\n> So there is some precedence to including an option that protocol devs don't\n> find useful, then removing it N years later to make sure it doesn't impact\n> compact blocks.\n\nI think the lesson there is we're willing to remove options that are\nridiculous. Replacements are widely used, and downright essential in high-fee\nsituations.\n\n> Peering into the \"precedence\" lense, I think this does lend itself to the\n> theory that the transition should be as uniform as possible to avoid\n> degradation of fast block propagation. If not removing options(which is\n> deemed user hostile by a number of folks including me), then at least for a\n> flag day switchover.\n\nRe: compact blocks, note that RBF is a special case: for the sake of\nreconstruction, it'd make sense to temporarily cache transactions have have\nbeen replaced rather than discarding them entirely, in case a prior version\ngets mined. Irregardless of policy this will happen occasionally simple due to\npropagation delays. Equally, if we cached transactions that we rejected due to\npolicy, that'd help with reconstruction success in the event that policy is\nchanging.\n\nAnyway, since the compact blocks implementation efficiently deals with the case\nwhere miners have policy that differs from most nodes, by immediately\nforwarding missing transactions, I don't think the occasional full-rbf\nreplacement is going to have much impact. The nodes that had full-rbf disabled\nwill forward the tx to their peers directly, and then the subset of full-rbf\ndisabled peers will do the same again. So long as the network has a mix of both\ntypes, and they're interconnected rather than in clusters, the latency impact\nshould be minimal.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/9719c3e0/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-10-27T20:29:47",
                "message_text_only": "Hi AJ,\n\n\nLet's take the contra.\n\n\nI would say the current post describes the state of Bitcoin Core and\nbeyond policy\nrules with a high-degree of exhaustivity and completeness, though itt what\nis, mostly a description. While I think it ends with a set of\nrecommendations on what could be the relations between miners, devs and\nnode operators w.r.t adopting policy rules, to me it doesn't explore enough\nthe hard part of the subject. What should be actually the design goals and\nprinciples of Core's transaction-relay propagation rules\n\nof which mempool accepts ones is a subset ? By such design goals, I'm\nthinking either, a qualitative framework, like attacks game for a concrete\napplication (\"Can\n\nwe prevent pinning against multi-party Coinjoin ?\"). Or a quantitative\napproach, e.g how fast should be transaction-relay throughput for a given\ntopology, or how much accurate is the block template against usual blocks\n[0]\n\n\nAssuming we would have technical principles and goals guiding our\ndevelopment process, of which the discussion and revision should be an\ninherent part of the process itself,  I believe we would come up with a\nsecond-order observation. That we might not be able to satisfy every\nuse-case with the standard set of policy rules. E.g, a contracting protocol\ncould look for package size beyond the upper bound anti-Dos limit. Or even the\nglobal ressources offered by the network of full-nodes are not high enough\nto handle some application event. E.g a Lightning Service Provider doing a\nliquidity maintenance round of all its counterparties, and as such\nforce-closing and broadcasting more transactions than can be handled at the\ntransaction-relay layer due to default MAX_PEER_TX_ANNOUNCEMENTS value.\n\n\nMy personal take on those subjects, we might have to realize we're facing\nan heterogeneity of Bitcoin applications and use-cases [1]. And this sounds\nlike a long-term upward trend, akin to the history of the Internet: mail\nclients, web browser, streaming applications, etc, all with different\nservice-level requirements in terms of latency, jitters and bandwidth. We might\nobserve that Bitcoin actors might adopt individual strategies for the\nconsumption of it. E.g a multi-party contracting protocol with asymmetric\nstates, a counterparty could \"front-run\" the others at the\ntransaction-relay to avoid encumbering the RBF penalty in case of\nconcurrent broadcast. Or they could deploy an additive layer of\ncommunication channels, like private transaction-relay to miners, e.g a LN\nnode broadcasting a HTLC-preimage and restraining the odds of mapping to an\noff-chain payment path. Those additive layers of communication can be also\nseen as mitigations against components failure risks, e.g a\ntransaction-relay\n\ncensorship vector in the p2p stack. To put it simply, some advanced Bitcoin\napplications might have to outgrow the \"mempool policy rules\" game, as\nwe're currently defining it to satisfy to a higher degree their security\nand operational models. I think this has been historically the case with\nsome miners deciding to join FIBER, to improve their view of mined blocks.\n\n\nWhile I still think we can come up with clear policy rules for some ideal\nor reasonable use-case (let's say the Bitcoin hobbyist aiming to strong\ncensorship-resistance of its\n\npayment). And I hold the belief we can improve on that front, as we've done\nduring the past years by formalizing a subset of policy rules in Bitcoin\nCore documentation. In\n\nparallel, we might acknowledge the heterogeneity of use-cases, and that we\ncannot offer the same level of censorship-resistance, privacy or\ncost-effectiveness (And that might be okay if we remember that e.g\ncensorship-resistance between a simple Bitcoin payment and a Lightning HTLC\nisn't defined the same, due to the usage of timelocks by the latter).\n\n\nWhat I'm expressing is a long-term perspective, and we might be too early\nin the evolutionary process that is Bitcoin Core development to abandon yet\nthe \"one-size-fits-all\"\n\npolicy rules conception that I understand from your post. Though to me, as\nwe progress on modularity and flexibility of the Core codebase, we might\nhave to envision a Bitcoin ecosystem where configuring a client is on the\nsame bar as the kernel Kconfig (hopefully not because no drivers/ but\nstill..). Of course, you can have \"blessed\" config to avoid the complexity\nturning away node operators and users, though at the price of increasing\nthe trust in your vendors.\n\n\nMore concretely, about the issue of today, full-rbf, I think the lack of\ndesign heuristic in the sense of what should be the reasonable or average\nuse-case\n\nsupported by the Bitcoin base-layer transaction-relay rules. Should we\nfavor the historical ones (0confs) or the new incumbent (contracting\nprotocols) ? There is always the \"First, do not harm\" principle in lack of\nclear guidelines in any area of Bitcoin protocol development. Though when\nwe're facing risk arbitrage like the current one, I don't think as protocol\ndevs we have any strong reasoning framework. Deferring the decision to the\nnode operators as the approach is with #25353 + #25000, did acknowledge the\nuncharted territory we're in with policy rules deprecation or novation.\nQualifying the gradual approach of \"worst\" sounds to me that every policy\nrule will ever have to design or deploy will suffer from the same trade-off of\nfull-rbf. A gradual approach could be a really realistic way to move forward\nwith some experimental package formats or Dandelion-like transaction\ndissemination strategy. Such gradual approach of full-rbf deployment was\nalso aiming to set the precedent that in a situation of risk arbitrage,\nwith irreconcilable views between class of use-cases operators, the\ndecision shouldn't be in the scope of Bitcoin Core.\n\n\nHopefully, with a renewed effort of communication in the case of full-rbf,\nwe can accommodate the maximum of use-cases risks model and move towards a\ncoordinated approach, offering a visible and predictable timeline. Though\nif we fail to reach \"consensus\" there, we might have to fallback on the\n\"gradual\" approach, stating the full-rbf case is beyond the responsibility of\nscope of Bitcoin Core.\n\n\nOverall, many thanks for this thoughtful post. Good for me to uplift the\nlevel of the discussion when we're hitting some bottleneck in our\ndevelopment process.\n\n\nBest,\n\nAntoine\n\n\n[0] https://github.com/bitcoin/bitcoin/issues/19820\n\n\n[1] To be clear, this the opposite view I did express in :\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-July/018063.html\n\nAfter exposure and exploration of more Bitcoin use-cases and applications,\nand even among the different requirement among types of use-cases nodes\n(e.g LN mobile vs LSP), I believe more heterogeneity in the policy rules\nusage makes more sense\n\n\nLe jeu. 27 oct. 2022 \u00e0 00:52, Anthony Towns via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Hi *,\n>\n> TLDR: Yes, this post is too long, and there's no TLDR. If it's any\n> consolation, it took longer to write than it does to read?\n>\n> On Tue, Jun 15, 2021 at 12:55:14PM -0400, Antoine Riard via bitcoin-dev\n> wrote:\n> > Subject: Re: [bitcoin-dev] Proposal: Full-RBF in Bitcoin Core 24.0\n> > I'm writing to propose deprecation of opt-in RBF in favor of full-RBF\n>\n> > If there is ecosystem agreement on switching to full-RBF, but 0.24 sounds\n> > too early, let's defer it to 0.25 or 0.26. I don't think Core has a\n> > consistent deprecation process w.r.t to policy rules heavily relied-on by\n> > Bitcoin users, if we do so let sets a precedent satisfying as many folks\n> as\n> > we can.\n>\n> One precedent that seems to be being set here, which to me seems fairly\n> novel for bitcoin core, is that we're about to start supporting and\n> encouraging nodes to have meaningfully different mempool policies. From\n> what I've seen, the baseline expectation has always been that while\n> certainly mempools can and will differ, policies will be largely the same:\n>\n>   Firstly, there is no \"the mempool\". There is no global mempool. Rather\n>   each node maintains its own mempool and accepts and rejects transaction\n>   to that mempool using their own internal policies. Most nodes have\n>   the same policies, but due to different start times, relay delays,\n>   and other factors, not every node has the same mempool, although they\n>   may be very similar.\n>\n>   -\n> https://bitcoin.stackexchange.com/questions/98585/how-to-find-if-two-transactions-in-mempool-are-conflicting\n>\n> Up until now, the differences between node policies supported by different\n> nodes running core have been quite small, with essentially the following\n> options available:\n>\n>  -minrelaytxfee, -maxmempool - changes the lowest fee rate you'll accept\n>\n>  -mempoolexpiry - how long to keep txs in the mempool\n>\n>  -datacarrier - reject txs creating OP_RETURN outputs\n>\n>  -datacarriersize - maximum size of OP_RETURN data\n>\n>  -permitbaremultisig - prevent relay of bare multisig\n>\n>  -bytespersigop - changes how SIGOP accounting works for relay and\n>  mining prioritisation\n>\n> as well as these, marked as \"debug only\" options (only shown with\n> -help-debug):\n>\n>  -incrementalrelayfee - make it easier/harder to spam txs by only\n>  slightly bumping the fee; marked as a \"debug only\" option\n>\n>  -dustrelayfee - make it easier/harder to create uneconomic utxos;\n>  marked as a \"debug only\" option\n>\n>  -limit{descendant,ancestor}{count,size} - changes how large the\n>  transaction chains can be; marked as a \"debug only\" option\n>\n> and in theory, but not available on mainnet:\n>\n>  -acceptnonstdtxn - relay/mine non standard transactions\n>\n> There's also the \"prioritisetransaction\" rpc, which can cause you to keep\n> a low feerate transaction in your mempool longer than you might otherwise.\n>\n> I think that -minrelaytxfee, -maxmempool and -mempoolexpiry are the only\n> ones of those options commonly set, and those only rarely result in any\n> differences in the txs at the top of the mempool.\n>\n> There are also quite a few parameters that aren't even runtime\n> configurable:\n>\n>  - MAX_STANDARD_TX_WEIGHT\n>  - MIN_STANDARD_TX_NONWITNESS_SIZE (see also #26265)\n>  - MAX_P2SH_SIGOPS (see also #26348)\n>  - MAX_STANDARD_TX_SIGOPS_COST\n>  - MAX_STANDARD_P2WSH_STACK_ITEMS\n>  - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE\n>  - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE\n>  - MAX_STANDARD_P2WSH_SCRIPT_SIZE\n>  - MAX_STANDARD_SCRIPTSIG_SIZE\n>  - EXTRA_DESCENDANT_TX_SIZE_LIMIT\n>  - MAX_REPLACEMENT_CANDIDATES\n>\n> And other plausible options aren't configurable even at compile time\n> -- eg, core doesn't implement BIP 125's inherited signalling rule so\n> there's no way to enable it; core doesn't allow opting out of BIP 125\n> rule 3 ratchet on absolute fee; core doesn't allow CPFP carveout with\n> more than 1 ancestor; core doesn't allow opting out of LOW_S checks\n> (even via -acceptnonstdtxn); etc.\n>\n> We also naturally have different mempool policies between different\n> releases: eg, expansions of policy, such as allowing OP_RETURN or\n> expanding it from 40 to 80 bytes or new soft forks where old nodes won't\n> relay transactions that use the new; and also occassional restrictions\n> in policy, such as the LOW_S requirement.\n>\n>\n> While supporting and encouraging different mempool polices might be new\n> for core, it's not new for knots: knots changes some of these defaults\n> (-permitbaremultisig defaults to false, -datacarriersize is reduced to\n> 42), allows the use of -acceptnonstdtxn on mainnet, and introduces new\n> options including -spkreuse and -mempoolreplacement (giving the latter\n> full rbf behaviour by default). Knots also includes a `-corepolicy`\n> option to make it easy to get a configuration matching core's defaults.\n>\n>\n> I think gmaxwell's take from Feb 2015 (in the context of how restrictive\n> policy on OP_RETURN data should be) was a reasonable description for\n> core's approach up until now:\n>\n>   There is also a matter of driving competent design rather than lazy\n>   first thing that works. E.g. In stealth addresses the early proposals\n>   use highly inefficient single ECDH point per output instead of simply\n>   pooling them. Network behavior is one of the few bits of friction\n>   driving good technical design rather than \"move fast, break things, and\n>   force everyone else onto my way of doing thing rather than discussing\n>   the design in public\". No one wants to be an outright gatekeeper,\n>   but the network is a shared resource and it's perfectly reasonable\n>   node behavior to be stingy about the perpetual storage impact of the\n>   transactions they're willing to process, especially when it comes to\n>   neutral technical criteria like the amount of network irrelevant data\n>   stuffed in transactions.\n>\n>   There is also a very clear pattern we've seen in the past where\n>   people take anything the system lets them do as strong evidence that\n>   they have a irrevocable right to use the system in that way, and that\n>   their only responsibility-- and if their usage harms the system it's\n>   the responsibility of the system to not permit it. [...\n>   ...] For mitigating these risks it's optimal if transactions\n>   seem as uniform and indistinguishable as reasonably possible.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/5286#issuecomment-72564175\n>\n> Perhaps see also sdaftuar in Nov 2015,\n>\n>   To me the most important question is, is priority something that miners\n>   want to use?\n>\n>   If a non-negligible amount of hashpower intends to use it in their\n>   transaction selection, then I think it makes sense for nodes to use it\n>   too, because it's generally helpful to have your mempool predict the\n>   UTXO as much as possible, and for nodes to be able to have reasonable\n>   fee and priority estimates (which won't happen unless they track the\n>   priority transactions somehow -- I'm presuming that miners run with\n>   much bigger mempools than regular nodes).\n>\n>   If the answer is no, then that's fine and I don't see a reason to push\n>   in this direction. I sort of assumed there was enough hashpower mining\n>   with priority, since last time I checked estimatepriority was still\n>   giving meaningful results for low-ish blockheights, but I haven't done\n>   any kind of real analysis.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/6992#issuecomment-155969455\n>\n> or in June 2019,\n>\n>   What this PR is proposing is to get rid of a command-line option that is\n>   (a) a footgun for users and (b) does not reflect what I believe to be\n>   the understanding most users have, which is that [X txs] are expected\n>   to propagate well on the network.\n>\n>   ..\n>\n>   I don't think this rises to the level that Luke is concerned about,\n>   namely a prelude to forcing a common relay policy on all nodes. In\n>   particular I do agree it makes sense that we offer some ways of\n>   customizing policy parameters (eg the mempool size, min relay fee,\n>   etc). Instead, I think the justification for this change is that we\n>   should not support behaviors we think are harmful to the ecosystem\n>   overall and have no legitimate use-case, and we should eliminate ways\n>   that users might inadvertently shoot themselves in the foot.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/16171#issuecomment-500393271\n>\n> (or see discussion in https://github.com/bitcoin/bitcoin/pull/7219)\n>\n> I don't mean to imply the above are saying \"there's one way to do\n> things and it's this way\", or that the old way of doing things should\n> necessarily be the way we keep doing things. Just that previously core\n> has tended towards designing a single policy that works as well as it\n> can for everyone and the ecosystem as a whole. (I'm also not saying that\n> fullrbf can't work well for everyone or the ecosystem as a whole)\n>\n>\n> By contrast, I think the most common response to pushback against the\n> full rbf option has been along the lines of \"it's just an option, we\n> don't want to force people\", eg:\n>\n>   Blaming the default false -mempoolfullrbf option for a full RBF network\n>   would be holding Bitcoin Core developers responsible for the decisions\n>   of individual node operators and miners. I don't think having the\n>   option (again, default false) can directly cause a full RBF network,\n>   and likewise, I don't think removing this option removes the \"risk\"\n>   of a full RBF network.\n>    - glozow\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274949400\n>\n>   NACK. This is a default false option.\n>    - achow101\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1274953204\n>\n>   Erecting artificial barriers to prevent or make it difficult for users\n>   to do what they want to do, is not appropriate behaviour.\n>    - luke-jr\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1290721905\n>\n>   I'm in general against removing options.\n>    - instagibbs\n>      https://github.com/bitcoin/bitcoin/pull/26287#issuecomment-1292030700\n>\n> I think this differs from what core has done in the past, in that\n> previously we've tried to ensure a new policy is good for everyone (or as\n> nearly as it can be), and then enabled it as soon as it's implemented.\n> Any options that have been added have either been to control resource\n> usage in ways that don't significantly effect tx propagation, to\n> allow people to revert to the old behaviour when the new behaviour is\n> controversial (eg the -mempoolreplacement=0 option from 0.12 to 0.18),\n> and to make it easier to test/debug the implementation.\n>\n> Giving people a new relay behaviour they can opt-in to when we aren't\n> confident enough to turn on by default doesn't match the approach I've\n> seen core take in the past.\n>\n>\n> If this is going to be an ongoing shift in how core sees relay/mempool\n> policy, I think that's significant and worth paying attention to.\n>\n> I don't think it's necessary to have that shift to roll out full rbf.\n> The other approach would be either:\n>\n>  * set -mempoolfullrbf=true as the default for 24.0, and just have the\n>    command line param there in case people want to do a\n>    \"UserRejectedMempoolPolicy\" campaign to get everyone to opt-out\n>\n>  * revert it for now because we don't think mainnet is ready for fullrbf\n>    yet, and introduce it as default true for 25.0 or 26.0 or 27.0 or\n>    to activate at some scheduled date in that timeframe (potentially\n>    backporting it to previous releases to help with adoption too,\n>    whatever). same effect as the previous option, just with a bit more\n>    advanced notice and time to prepare\n>\n> I don't think anyone's proposed the first (which I interpret as \"most of\n> us don't think mainnet is ready for fullrbf today\"), but the comments\n> above are all pushback by people arguing against (the first step of)\n> the second approach, and they seem to be winning the day.\n>\n> It's also possible that this is something of a one time thing: full rbf\n> has been controversial for ages, but widely liked by devs, and other\n> attempts (eg making it available in knots) haven't actually achieved\n> much of a result in practice. So maybe this is just a special case and\n> not a precedent, and when people propose other default false options,\n> there will be substantially more resistance to them being merged,\n> despite all the talk about users having options that's going on right now.\n>\n>\n> Assuming it is the change of direction it appears to be -- and all of\n> the above is really just justification for that assumption -- then like\n> I said, I think it's worth seriously considering what it means for people\n> to choose their own relay/mempool policies and for you to expect to have\n> different mempool policies to many or most of your potential peers.\n>\n>\n> One thing maybe worth noting is that is that you can still only choose\n> your policy from options that people write code for -- if it wasn't\n> something you could get by running knots or compiling a rejected PR\n> yourself, it won't magically become more possible now.  Presumably it\n> would mean that once a PR is written, it might get better review (rather\n> than being dismissed as not suitable for everyone), and there would be\n> less maintenance burden than if it had to be manually rebased every\n> release, though (or at least the maintenance burden would be shared\n> across everyone working on the codebase).\n>\n>\n> The second thing is that whatever your relay policy is, you still\n> need a path all the way to miners through nodes that will accept your\n> transaction at every step. If you're making your mempool more restrictive\n> (eg -permitbaremultisig=0, -datacarrier=0), that's easy for you (though\n> you're making life more difficult for people who do create those sorts\n> of txs); but if you want a more permissive policy (package relay,\n> version-3-rbf, full-rbf), you might need to do some work.\n>\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your tx,\n> just by random chance. If erlay allows increasing your outbound count to\n> 12 connections instead of 8; that might reduce down to needing just 20%\n> of listening nodes (~93%).\n>\n> But for cases where less than 30% (20%) of network supports your preferred\n> policy, you probably need to do something cleverer.\n>\n> One approach is to set a service bit and preferentially peer with other\n> nodes that advertise that service bit; knots does the first half of this\n> for fullrbf, and both halves have been proposed for core in #25600.\n> Preferential peering was previously done for the segwit deployment,\n> though in that case it was necessary not just for tx propogation but\n> also for ensuring block propogation, making it effectively a consensus\n> critical issue.\n>\n> Another approach is having a separate relay network -- eg, lightning nodes\n> already have a gossip network, and might want to help their own ecosystem\n> by ensuring unilateral channel closes and justice transactions are quickly\n> relayed. Using their own gossip network to relay the transaction around,\n> and each lightning node adding it to their local bitcoind's mempool and\n> allowing it to propogate (or not) from there as normal, would also be a\n> way of allowing transactions to propogate well. It does mean that miners\n> would either need to also participate in lightning gossip directly, or\n> that miners would need to connect to *many* peers to be confident of\n> seeing those transactions (eg, if only 2% of the network would see a\n> tx, you'd need to make 228 connections to have a 99% chance of seeing\n> the tx). You can't currently do something like this, because all the\n> relay policies are also applied when adding txs to the mempool via RPC,\n> and there's no convenient way to remove txs from the mempool.\n>\n> A case where something like that might occur is in preventing L2\n> transactions from pinning attacks -- so you might have a high-fee,\n> low-feerate transaction that's been widely propogated, sitting in the\n> bottom of people's mempools, and you want to replace it with a smaller,\n> higher-feerate transaction, but don't want to pay a higher absolute fee,\n> and are thus blocked by BIP 125 rule 3. Perhaps 98% of the network is\n> unwilling to deviate from BIP 125 rule 3 for you; because that would\n> make it easy for random griefers to spam their mempool with large txs\n> then delete them while only paying a small fee; but your L2 peers may be\n> able to decode your replacement transaction and be sure that you aren't\n> going to spam them, and thus will happily relay it.\n>\n> From a technical point-of-view, that's largely fine; the downside is it\n> increases the centralisation pressure on mining: whether that's by having\n> to connect to substantially more nodes, or having to parse through more\n> spam, you can't just run your mining operation off a standard install\n> of bitcoin core anymore, but need to actively opt-in to find all the\n> weird unusual ways people are sending transactions around in order to\n> actually collect as much in fees as your competitors are.\n>\n> That's probably moderately bad for privacy as well -- if lightning or\n> coinjoins need special relay rules that most nodes haven't opted into,\n> it's potentially easy to use that to find the bitcoin nodes on the\n> network that are participating in those protocols, and from there to\n> either identify the operator, or run a DoS attack to make it hard for you\n> to keep doing what you want. Obviously if you're setting a service bit to\n> get better routing, you've given up that privacy already. Likewise if the\n> government or random vandals are opposed to bitcoin mining, and miners\n> have to have special configuration on their nodes that distinguish them\n> from regular users, then perhaps that makes it easier to find or shut\n> down their operations.\n>\n> There are a few efficiencies to be gained from similar mempool policies as\n> well: more reliable compact block reconstruction (if you're not missing\n> any transactions, you avoid a round-trip) and presumably more efficient\n> set reconstruction with erlay. You'll also waste less bandwidth sending\n> transactions that the other node is only going to reject. Both those\n> depend on how many transactions are going to rely on unusual mempool\n> policies in the first place though.\n>\n> ariard wrote:\n>\n>   I know I've advocated in the past to turn RBF support by default in\n>   the past. Though after gathering a lot of feedbacks, this approach\n>   of offering the policy flexiblity to the interested users only and\n>   favoring a full-rbf gradual deployment sounds better to me.\n>\n>   - https://github.com/bitcoin/bitcoin/pull/25353#issuecomment-1157137026\n>\n> I guess all the above leads me to think that gradual deployments of\n> mempool policies are likely the worse approach: even when they're not\n> hurting anyone, it makes them hard to use during the gradual phase,\n> and getting around that comes with worrying compromises on privacy and\n> centralisation; and when they are problematic for some, the indeterminate\n> nature of a gradual deployment means it's hard to plan for when that\n> risk is going to eventuate.\n>\n>\n> Theoretically, one way to recover the good parts of core deciding on\n> what's good for the network might be for people outside of core to\n> recommend a mempool configuration; then core can just have an option\n> to make that easy, similar to \"-std=c++17\" for a C++ compiler, and much\n> the same as knots' \"-corepolicy\" option.\n>\n> Presuming anyone actually wants to take on that job, and listen to the\n> concerns of zeroconf businesses, lightning and coinjoin devs, miners, etc;\n> and can come up with something that keeps most of them happy, and that\n> 70% or 90% of the network ends up just following those recommendations\n> because it's easy, it works, and it's recommended by all the apps they\n> want to use, then that could work great:\n>\n>  * miners don't need to do anything special, so there's no new\n>    mining centralisation pressure\n>  * miners and users don't reveal what they're doing with bitcoin by the way\n>    they configure their nodes, so there's no privacy problems\n>  * devs can be fairly confident in how they have to design their apps\n>    in order to get their transactions to most hashpower\n>  * devs don't have to add new p2p layers to make it happen\n>  * at least there's someone to talk to when you're trying to figure out\n>    how to make some new project possible when it's inhibited by current\n>    relay policies and you don't have to try to convince everyone to\n>    upgrade on your own\n>  * core devs just provide options, and don't have to worry about being\n>    seen as gatekeepers\n>\n> The \"downside\" in that scenario is that users/dev aren't making much\n> actual use of all the choices core is offering by making different\n> options available; but the upside is that that choice is at least readily\n> available should whoever is coming up with these policy become out of\n> step with what people actually want.\n>\n> One thing that might make an approach like that difficult is that core\n> has historically been happy to remove options that don't seem useful\n> anymore: eg the ability to turn of BIP 125 support (#16171), and priority\n> transactions (#9602). Perhaps that's fine if you're trying to actively\n> craft a single mempool/relay policy that's good enough for almost everyone\n> (after all, it makes the code simpler and more efficient, and reduces\n> the number of footguns); all you're doing is leaving a minority of people\n> who want weird things to run a fork, and that's going to happen anyway.\n>\n> But if people are following policy developed outside of core, core\n> might well disagree with them and decide \"no that's a stupid policy,\n> no one should do that\" and remove some feature that others thing should\n> continue to be normal. Beyond the examples above, there's already talk of\n> removing the ability to disable fullrbf support in #26305, for instance.\n> If that happens, then the people maintaining the policy will instead\n> end up maintaining an entire fork of bitcoin core, and all we've done\n> is transition to people running software from a different repo, and a\n> different set of maintainers.\n>\n> If we're really going to a world where core's eager to add new options,\n> and reluctant to remove them, at least if anyone at all finds them\n> interesting, that's presumably a non-issue, though.\n>\n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221027/225d0c30/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-30T02:24:43",
                "message_text_only": "On Thu, Oct 27, 2022 at 09:29:47PM +0100, Antoine Riard via bitcoin-dev wrote:\n> Let's take the contra.\n\n(I don't think I know that phrase? Is it like \"play devil's advocate\"?)\n\n> I would say the current post describes the state of Bitcoin Core and\n> beyond policy\n> rules with a high-degree of exhaustivity and completeness, though itt what\n> is, mostly a description. While I think it ends with a set of\n> recommendations\n\nIt was only intended as a description, not a recommendation for anything.\n\nAt this point, the only thing I think I could honestly recommend\nthat doesn't seem like it comes with massive downsides, is for core to\nrecommend and implement a particular mempool policy, and only have options\nthat either make it feasible to scale that policy to different hardware\nlimitations, and provide options that users can activate en-masse if it\nturns out people are doing crazy things in the mempool (eg, a new policy\nturns out to be ill-conceived, and it's better to revert to a previous\npolicy; or a potential spam vector gets exploited at scale).\n\n> What should be actually the design goals and\n> principles of Core's transaction-relay propagation rules\n> of which mempool accepts ones is a subset?\n\nI think the goals of mempool/relay policy are _really_ simple; namely:\n\n * relay transactions from users to all potential miners, so that\n   non-mining nodes don't have to directly contact miners to announce\n   their tx, both for efficiency (your tx can appear in the next block\n   anyone mines, rather than just the next block you mine) and privacy\n   (so that miners don't know who a transaction belongs to, so that\n   users don't have to know who miners are, and so there's no/minimal\n   correlation between who proposed a tx and who mined the block it\n   appears in)\n\n * having most of the data that makes up the next block pre-validated\n   and pre-distributed throughout the network, so that block validation\n   and relay is much more efficient\n\n> By such design goals, I'm\n> thinking either, a qualitative framework, like attacks game for a concrete\n> application (\"Can we prevent pinning against multi-party Coinjoin ?\").\n\nI don't think that even makes sense as a question at that level: you can\nonly ask questions like that if you already have known mempool policies\nacross the majority of nodes and miners. If you don't, you have to allow\nfor the possibility that 99% of hashrate is receiving private blacklists\nfrom OFAC and that one of your coinjoin counterparties is on that list,\neg, and at that point, I don't think pinning is even conceivably solvable.\n\n> I believe we would come up with a\n> second-order observation. That we might not be able to satisfy every\n> use-case with the standard set of policy rules. E.g, a contracting protocol\n> could look for package size beyond the upper bound anti-Dos limit.\n\nOne reason that limit is in place is that it the larger the tx is\ncompared to the block limit, the more likely you are to hit corner cases\nwhere greedily filling a block with the highest fee ratex txs first\nis significantly suboptimal. That might mean, eg, that there's 410kvB\nof higher fee rate txs than your 600kvB large package, and that your\nstuff gets delayed, because the miner isn't clever enough to realise\ndropping the 10kvB is worthwhile. Or it might mean that your tx gets\ndelayed because the complicated analysis takes a minute to run and a\nblock was mined using the simpler algorithm first. Or it might mean that\nsome mining startup with clever proprietary software that can calculate\nthis stuff quickly make substantially more profit than everyone else,\nso they start dominating block generation, despite the fact that they're\ncensoring transactions due to OFAC rules.\n\n> Or even the\n> global ressources offered by the network of full-nodes are not high enough\n> to handle some application event.\n\nBlocks are limited on average to 4MB-per-10-minutes (6.7kB/second),\nand applications certainly shouldn't be being designed to only work if\nthey can monopolise the entirety of the next few blocks. I don't think\nit makes any sense to imagine application events in Bitcoin that exceed\nthe capacity of a random full node. And equally, even if you're talking\nabout some other blockchain with higher capacity; I don't really think\nit makes sense to call it a \"full\" node if it can't actually cope with\nthe demands placed on it by any application that works on that network.\n\n> E.g a Lightning Service Provider doing a\n> liquidity maintenance round of all its counterparties, and as such\n> force-closing and broadcasting more transactions than can be handled at the\n> transaction-relay layer due to default MAX_PEER_TX_ANNOUNCEMENTS value.\n\nMAX_PEER_TX_ANNOUNCEMENTS is 5000 txs, and it's per-peer. If you're an\nLSP that's doing that much work, it seems likely that you'd at least\nbe running a long-lived listening node, so likely have 100+ peers, and\ncould conceivably simultaneously announce 500k txs distributed across\nthem, which at 130vB each (1-taproot-in, 2-p2wpkh out, which I think is\npretty minimal) adds up to 65 blocks worth of transactions. And then,\nyou could run more than one node, as well.\n\nYour real limitation is likely that most nodes on the network\nwill only relay your txs onwards at an average rate of ~7/second\n(INVENTORY_BROADCAST_PER_SECOND), so even 5000 txs will likely take over\n700s to propagate anyway.\n\n> My personal take on those subjects, we might have to realize we're facing\n> an heterogeneity of Bitcoin applications and use-cases [1].\n\nSure; but that's why you make your policy generic, rather than having\nto introduce a new, different policy targeted at each new use case.\n\n> And this sounds\n> like a long-term upward trend, akin to the history of the Internet: mail\n> clients, web browser, streaming applications, etc, all with different\n> service-level requirements in terms of latency, jitters and bandwidth.\n\nBack in the mid/late 90s, people argued that real-time communication,\n(like audio chat, let alone streaming video) wasn't suitable for IP,\nbut would require a different network like ATM where dedicated circuits\nwere established between the sender and recipient to avoid latency,\njitter and bandwidth competition. Turns out that separate networks\nweren't optimal for that.\n\n> To put it simply, some advanced Bitcoin\n> applications might have to outgrow the \"mempool policy rules\" game,\n\nI think if you stick to the fundamentals -- that relay/mempool is about\ngetting transactions to miners and widely preseeding the contents of\nwhatever the next block will be -- then it's pretty unlikely that any\nBitcoin application will outgrow the mempool policy game.\n\n> I think this has been historically the case with\n> some miners deciding to join FIBER, to improve their view of mined blocks.\n\nFIBRE (it doesn't use the US spelling) is a speedup on top of compact\nblock relay -- it still gets you exactly the same data if you don't use,\nit's just everything is slightly faster if you do. Even better, if you\nget a block via FIBRE, then you relay it on to your peers over regular\np2p, helping them get it faster too.\n\nDoing something similar with mempool txs -- having some high bandwidth\noverlay network where the edges then feed txs back into the main p2p\nnetwork at a slower rate that filters out spam or whatever -- would\nprobably likewise be a fine addition to bitcoin, provided it had the\nsame policy rules as regular bitcoin nodes employ for tx relay. If it\nhad different ones, it would become a signficant centralisation risk: app\ndevelopers who make use of the different rules would need to comply with\nthe overlay networks ToS to avoid getting banned, and miners would need\nto subscribe to the feed to avoid missing out on txs and thus fee income.\n\n> What I'm expressing is a long-term perspective, and we might be too early\n> in the evolutionary process that is Bitcoin Core development to abandon yet\n> the \"one-size-fits-all\" policy rules conception that I understand from\n> your post.\n\nI don't think \"one-size-fits-all\" is a principle at all; I think\ndecentralisation/censorship-resistance, privacy, and efficiency are the\nfundamental principles. As far as I can see, a one-size-fits-all approach\n(or, more precisely, an approach where >90% of the network converges to\nthe same set of rules) is far better at achieving those principles than\na heterogenous policy approach.\n\n> After exposure and exploration of more Bitcoin use-cases and applications,\n> and even among the different requirement among types of use-cases nodes\n> (e.g LN mobile vs LSP), I believe more heterogeneity in the policy rules\n> usage makes more sense\n\nI think when you say \"more heterogeneity\" what you're actually assuming\nis that miners will implement a superset of all those policies, so that\nif *any* node on the network accepts a tx X, *every* miner will also\naccept a tx X, with the only exception being if there's some conflicting\ntx Y that allows the miner to collect more fees.\n\nBut that's not really a heterogenous policy: in that case all miners\nare employing exactly the same policy.\n\nIn that scenario, I don't think you'll end up with nodes running\nheteregenous policies either: part of the point of having mempool\npolicies is to predict the next block, so if all miners really do have\na common policy, it makes sense for nodes to have the same policy. The\nonly potential difference is miners might be willing to dedicate more\nresources, so might set some knobs related to memory/bandwidth/cpu\nconsumption differently.\n\nI think what you're actually assuming is that this scenario will mean\nthat miners will quickly expand their shared policy to accept *any*\nset of txs that are accepted by a small minority of relay nodes: after\nall, if there are some txs out there that pay fees, why wouldn't miners\nwant to include them? That's what incentive compatible means, right? And\nthat's great from a protocol reasearch point-of-view: it allows you to\nhandwave away people complaining that your idea is bad -- by assumption,\nall you need to do is deploy it, and it immediately starts working,\nwithout anyone else needing to adopt it.\n\nI don't think that's actually a realistic assumption though: first,\nupdating miners' policy rules requires updated software to be tested\nand deployed, so isn't trivial enough that it should be handwaved away,\nsecond, as in the \"big packages\" example above, constructing an efficient\nblock becomes harder the more mempool rules you throw away, so even if\nthere are txs violating those rules that are offering extra fees, they\nmay not actually cover the extra costs to generate a block when you're\nno longer able to rely on those rules to reduce the complexity of the\nproblem space.\n\nNote also that \"relay nodes will want to use the same policy as mining\nnodes\" goes both ways -- if that doesn't happen, and compact block\nrelay requires an extra round trip to reconstruct the block, miners'\nblocks won't relay as quickly, and they'll have an increased orphan rate.\n\nCheers,\naj"
            },
            {
                "author": "David A. Harding",
                "date": "2022-10-29T07:45:09",
                "message_text_only": "On 2022-10-26 13:52, Anthony Towns via bitcoin-dev wrote:\n> The cutoff for that is probably something like \"do 30% of listening\n> nodes have a compatible policy\"? If they do, then you'll have about a\n> 95% chance of having at least one of your outbound peers accept your \n> tx,\n> just by random chance.\n\nI think this might be understating the problem.  A 95% chance of having\nan outbound peer accept your tx conversely implies 1 in 20 payments will \nfail to\npropagate on their initial broadcast.  That seems to me like an\nunacceptably high failure rate both for the UX of regular payments and\nfor the safety of time-sensitive transactions like onchain HTLC\nresolutions.\n\nAdditionally, the less reliable propagation is, the more reliably spy\nnodes can assume the first IP address they received a transaction from\nis the creator of that transaction.\n\nI think those two problems combine in an especially unfortunate way for\nlightweight clients.  Lightweight clients wanting to find a peer who\nsupports a more permissive policy than most of the network and whose\nclient authors want to provide a good UX (or safety in the case of time\nsensitive contract protocols like LN) will need to open large numbers of\nconnections, increasing their chance of connecting to a spy node which\nwill associate their IP address with their transaction, especially since\nlightweight clients can't pretend to be relaying transactions for other\nusers.  Some napkin math: there are about 250,000 transactions a day; if\nwe round that up to 100 million a year and assume we only want one\ntransaction per year to fail to initially propagate on a network where\n30% of nodes have adopted a more permissive policy, lightweight clients\nwill need to connect to over 50 randomly selected nodes.[1]  For a more\npermissive policy only adopted by 10% of nodes, the lightweight client\nneeds to connect to almost 150 nodes.\n\nThis also implies that nodes adopting a more restrictive policy degrades\nUX, safety, and privacy for users of transactions violating that policy.\nFor example, if 30% of nodes used Knots's -spkreuse configuration option\nand about 50% of transactions reuse scriptPubKeys, then about 9\ntransactions a day wouldn't initially propagate (assuming 8 randomly\nselected peers[2]) and lightweight clients who wanted 1-in-100-million\nsafety would need to connect to about 15 random nodes.\n\nTowns's post to which I'm replying describes several alternative\napproaches which mitigate the above problems, but he also documents that\nthey're not without tradeoffs.\n\n-Dave\n\n[1] (1-0.3)**50 * 100_000_000 =~ 1.8\n\n[2] That assumes every transaction is sent to a different\nrandomly-selected set of peers, which isn't really the case.  However,\none day $GIANT_EXCHANGE could suddenly be unable to broadcast hundreds \nor\nthousands of withdrawal transactions because all of its peers implement\na restrictive policy."
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-30T01:02:43",
                "message_text_only": "On Fri, Oct 28, 2022 at 09:45:09PM -1000, David A. Harding via bitcoin-dev wrote:\n> I think this might be understating the problem.  A 95% chance of having\n> an outbound peer accept your tx conversely implies 1 in 20 payments will\n> fail to propagate on their initial broadcast.\n\nWhether that's terrible or not depends on how easy it is to retry (and how\nlikely the retry is to succeed) after a failure -- if a TCP packet fails,\nit just gets automatically resent, and if that succeeds, there's a little\nlag, but your connection is still usable. I think it's *conceivable* that\na 5% failure rate could be detectable and automatically rectified. Not\nthat I have a good idea how you'd actually do that, in a way that's\nefficient/private/decentralised...\n\n> Some napkin math: there are about 250,000 transactions a day; if\n> we round that up to 100 million a year and assume we only want one\n> transaction per year to fail to initially propagate on a network where\n> 30% of nodes have adopted a more permissive policy, lightweight clients\n> will need to connect to over 50 randomly selected nodes.[1]  \n\nA target failure probability of 1-in-1e8 means:\n\n * with 8 connections, you need 90% of the network to support your txs\n * with 12 connections, you need ~79%\n * with 24 connections (eg everyone running a long-lived node is\n   listening, so long lived nodes make 12 outbound and receive about\n   ~12 inbound; shortlived nodes just do 24 outbound), you need ~54%\n\nSo with that success target, and no preferential peering, you need\na majority of listening nodes to support your tx's features in most\nreasonable scenarios, I think.\n\n> For a more\n> permissive policy only adopted by 10% of nodes, the lightweight client\n> needs to connect to almost 150 nodes.\n\nI get 175 connections needed for that scenario; or 153 with a target\nfailure rate of 1-in-10-million.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-10-30T02:40:14",
                "message_text_only": "On Sun, Oct 30, 2022 at 11:02:43AM +1000, Anthony Towns via bitcoin-dev wrote:\n> > Some napkin math: there are about 250,000 transactions a day; if\n> > we round that up to 100 million a year and assume we only want one\n> > transaction per year to fail to initially propagate on a network where\n> > 30% of nodes have adopted a more permissive policy, lightweight clients\n> > will need to connect to over 50 randomly selected nodes.[1]  \n> A target failure probability of 1-in-1e8 means:\n\nOh, based on the \"receive version message\" log entries of a node that\nonly does outbound connections, over the last ~3 weeks I see about 3000\noutbound connections (mostly feelers/block-relay-only ones), of which\na bunch identify as non-taproot supporting:\n\n     10 /Satoshi:0.16.0/:\n     13 /Satoshi:0.17.0/:\n     13 /Satoshi:0.17.0.1/:\n     28 /Satoshi:0.16.3/:\n     29 /Satoshi:0.19.0.1/:\n     36 /Satoshi:0.18.1/:\n     37 /Satoshi:0.19.1/:\n     39 /Satoshi:0.17.1/:\n     50 /Satoshi:0.20.0/:\n     94 /Satoshi:0.21.0/:\n     95 /Satoshi:0.18.0/:\n    244 /Satoshi:0.20.1/:\n\nThose add up to 688+ of 3065 total; if that's representative, it\npresumably means a random node connecting to 8 random listening peers has\na 6.44-in-1-million chance of only connecting to peers that don't support\ntaproot, ie failing your suggested threshold by a factor of about 644.\n\nCheers,\naj"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-30T11:06:32",
                "message_text_only": "> Whether that's terrible or not depends on how easy it is to retry (and \n> how\n> likely the retry is to succeed) after a failure -- if a TCP packet \n> fails,\n> it just gets automatically resent, and if that succeeds, there's a \n> little\n> lag, but your connection is still usable\n\nI'm not sure if that analogy fits here.  A TCP packet will be retried \n(as opposed to UDP), although usually the retry strategy is because of \nan underlying connection issue, not a protocol mismatch or in this case \n\"policy\" mismatch, right?\n\nIf network propagation and node discovery becomes an issue, and as \nAntoine mentions, there becomes a need for competing services as I \nunderstand it, could that give rise to indexes and trackers who spider \nthe network to create world view?  Perhaps it's a bad idea since \"third \nparty\" trackers are security holes, however, to my knowledge, we already \nhave \"trusted\" nodes during the initial bootstrap process.  Even so, I \ndon't think we could preclude such solutions from occurring organically \nif the need is arises.\n\nCheers,\n-Yancy\n\nOn 2022-10-30 02:02, Anthony Towns via bitcoin-dev wrote:\n\n> On Fri, Oct 28, 2022 at 09:45:09PM -1000, David A. Harding via\n> bitcoin-dev wrote:\n> \n>> I think this might be understating the problem.  A 95% chance of \n>> having\n>> an outbound peer accept your tx conversely implies 1 in 20 payments \n>> will\n>> fail to propagate on their initial broadcast.\n> \n> Whether that's terrible or not depends on how easy it is to retry (and \n> how\n> likely the retry is to succeed) after a failure -- if a TCP packet \n> fails,\n> it just gets automatically resent, and if that succeeds, there's a \n> little\n> lag, but your connection is still usable. I think it's *conceivable* \n> that\n> a 5% failure rate could be detectable and automatically rectified. Not\n> that I have a good idea how you'd actually do that, in a way that's\n> efficient/private/decentralised...\n> \n>> Some napkin math: there are about 250,000 transactions a day; if\n>> we round that up to 100 million a year and assume we only want one\n>> transaction per year to fail to initially propagate on a network where\n>> 30% of nodes have adopted a more permissive policy, lightweight \n>> clients\n>> will need to connect to over 50 randomly selected nodes.[1]\n> \n> A target failure probability of 1-in-1e8 means:\n> \n> * with 8 connections, you need 90% of the network to support your txs\n> * with 12 connections, you need ~79%\n> * with 24 connections (eg everyone running a long-lived node is\n> listening, so long lived nodes make 12 outbound and receive about\n> ~12 inbound; shortlived nodes just do 24 outbound), you need ~54%\n> \n> So with that success target, and no preferential peering, you need\n> a majority of listening nodes to support your tx's features in most\n> reasonable scenarios, I think.\n> \n>> For a more\n>> permissive policy only adopted by 10% of nodes, the lightweight client\n>> needs to connect to almost 150 nodes.\n> \n> I get 175 connections needed for that scenario; or 153 with a target\n> failure rate of 1-in-10-million.\n> \n> Cheers,\n> aj\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221030/bdc55eb9/attachment-0001.html>"
            },
            {
                "author": "Suhas Daftuar",
                "date": "2022-10-31T13:02:02",
                "message_text_only": "AJ,\n\nThanks for the thoughtful post. I think your observations about how we view\nmempool policy in the Bitcoin Core project, and how that seems to be\nchanging in the discussions around `-mempoolfullrbf`, are on-point and\nprovide a helpful baseline for considering future policy changes.\n\nFor a long time I viewed fullrbf as an eventuality and I considered myself\nto be philosophically supportive of the idea.  However, after giving this\nissue some thought in the past few weeks, I am reversing my thinking on\nthis.  Concretely, I will argue that we should continue to maintain a relay\npolicy where replacements are rejected for transactions that don't opt-in\nto RBF (as described in BIP 125), and moreover, that we should remove the\n`-mempoolfullrbf` flag from Bitcoin Core\u2019s latest release candidate and not\nplan to release software with that flag, unless (or until) circumstances\nchange on the network, which I'll discuss below.\n\nThis is, of course, a nuanced topic, and among the considerations is a\nphilosophy of how to think about the relay policy and configuration options\nthat we make available in Bitcoin Core (a consideration that is perhaps\nunique to that project, but I think relevant for this mailing list).\n\nI'll start with some technical issues regarding the benefits of enabling\nfullrbf on the network.  In the current BIP 125 regime, every time a\ntransaction is created, a choice is made whether to subject the transaction\nto BIP 125\u2019s RBF rules or not (based on the sequence values of the\ninputs).  So given that users can already opt-in to RBF, the benefit of a\n\u201cfullrbf\u201d network policy would be if, somehow, RBF users were still denied\nthe benefits of RBF due to the existence of other transactions that don\u2019t\nopt-in.\n\nAlong those lines, Antoine Riard brought up[1] a DoS vector that is\navailable to someone who wants to interfere with multi-party funded\ntransactions, and suggested that fullrbf would eliminate the problem.\nAfter exploring that question again in this thread (thanks to Greg Sanders\nfor clarifying this to me), I understand that the issue is around ensuring\nthat a multiparty (coinjoin-type) protocol is able to make eventual\nprogress, by having a candidate multiparty transaction either eventually\nconfirm or become conflicted with something that has been confirmed, in\nwhich case the double-spend information could be used to start a new\ncoinjoin round with fewer participants.  The concern Antoine and Greg have\nbrought up is that non-rbf transactions can persist in the mempool\n~indefinitely (at a low feerate and not subject to replacement) and\ninterfere with progress being made in a coinjoin protocol.\n\nHowever, it seems to me that similar problems exist for such a protocol\neven in a fullrbf world, as we understand that term today.  I mentioned the\nability for rbf \u201cpinning\u201d to interfere with relay of the multiparty\ntransaction (even if the conflicting transaction signals for RBF \u2013 a set of\nlarge but low feerate conflicting transactions can persist in the mempool\nand make it difficult for the coinjoin transaction from confirming, at\nleast without attaching a very large fee); and as Greg mentioned in a\nfollowup, the BIP 125 rule to only permit 100 transactions to be removed\nfrom the mempool at a time during a replacement can also be used to pin a\ncoinjoin protocol in the same way as a non-rbf transaction today.  It seems\nto me that what these multiparty protocols actually need is some sort of\n\"maximal rbf\" network policy: a way to guarantee that a transaction which\nshould be desirable for a miner to mine would always get to a miner and\nconsidered for inclusion in a block, no matter what the state of node\u2019s\nmempools on the network.\n\nWhile that sounds like a reasonable thing to want on its face (and worth\nworking on), it's not how opt-in RBF works today, nor is it how transaction\nrelay has ever conceptually worked.  We have not, thus far, been able to\ncome up with a total ordering on transaction desirability.  Moreover, due\nto all the DoS issues that exist with transaction relay, there are plenty\nof seemingly legitimate ways to construct transactions that would not relay\nwell on the network.  Relay has only ever been a best-efforts concept,\nwhere we carve out a small subset of the entire transaction universe for\nwhich we try to optimize propagation.  The idea behind this approach is\nthat if every use case we can come up with has some way to achieve its\ngoals using transactions that should (eventually) be able to relay, then\nusers wouldn\u2019t have much demand for transactions that would deviate from\nthe supported policies, and we therefore shouldn\u2019t need to worry too much\nabout incentive compatibility concerns when it comes to transaction types\nthat wouldn\u2019t relay at all, even if they are high feerate.  (And when those\nsituations arise where the standard transactions do not accommodate some\nneeded use case, developers typically work to define a policy that is\ncompatible with our anti-DoS goals to support such use cases, such as with\nthe recent proposal for version=3 transactions [2].)\n\nBIP 125's RBF rules themselves were an effort to carve out just a subset of\nsituations where a transaction should evict conflicting ones -- it was not\na design that anyone thought would ensure that all replacements which\n\"should\" be mined would always propagate.  And I don't believe that we know\nhow to design policy rules that would achieve the goals of this kind of\nmultiparty protocol in a DoS resistant way, today.  Along those lines, I\nwould point out that even the BIP 125 design itself is not entirely\nincentive compatible, in that it is possible to construct a replacement\ntransaction that would evict transactions which would be preferable to be\nincluded in a block! [3]  (This has been known for years, but fixing this\nhas proven difficult, and the only way to fix it that I\u2019m aware of would be\nto make BIP 125 RBF even more restrictive than it is today. I do think this\nis something that needs to be worked on.)\n\nGiven the limitations of RBF as we have it today, it appears to be\nincorrect that a fullrbf network policy would solve the problems Antoine\nraised.  And so absent any other examples, it does not seem to me that\nfullrbf solves any problems for RBF users, who are already free to choose\nto subject their transactions to BIP 125\u2019s RBF policy.  From this\nperspective, \"enabling fullrbf\" is really just taking away user choice to\nopt a transaction into a non-replacement policy regime.\n\nI think we should ask, then, whether it is reasonable on its face that\nusers might want to opt-in to a non-replacement policy?  Or in other words,\nis it reasonable for a user to mark a transaction as non-replaceable and\nhave that indication be enforced by the network? Note that these are two\ndifferent questions: you could imagine a world where fullrbf is a dominant\npolicy, but users still use the BIP 125 signaling method to indicate, in an\nunenforced way, their intention to not replace a transaction.  This might\ngive useful information to the network or the recipient for how to interact\nwith such a transaction.\n\nAnd I think that it's entirely possible that users would continue to use\nthe BIP 125 signaling to indicate that they do not intend to replace a\ntransaction.  For better or worse, this might be because zeroconf services\ncontinue to differentiate their behavior based on such a signal (possibly\nin conjunction with other factors), or it could be because there are other\nbehaviors that could be utilized more effectively if the transaction\noriginator has made such a signal, such as the recipient chaining an\nunconfirmed transaction as a way to bump the fee (CPFP) [4].\n\nIf it were to be the case that users continued to use BIP 125-style\nsignaling to indicate that they do not plan to replace a transaction, would\nthat be harmful to the network?  This is not something we can stop in our\npolicy rules (short of censoring such transactions, an obviously bad\nidea).  I think network actors can always do things that we might think are\nharmful for the network, but that doesn\u2019t mean that there are no legitimate\nuse cases for the tools that such actors might be using.  Just because\nsomeone might use some policy to adopt a zeroconf model, doesn\u2019t mean that\nothers aren\u2019t using the same policy to achieve benign ends (such as better\nCPFP behavior).\n\nMoreover, while users might attempt to exploit services that offer zeroconf\nor other differentiated behavior to non-replacement signaling transactions,\nthey also might not -- I think predicting user behavior in this way (and\nspecifically predicting the complexities of what a business might do and\nwhether users might try to subvert it) is beyond the scope of what we can\ndo as protocol developers.  Instead, I think we can try to answer a\ndifferent question: if a group of users were to want the ability to opt-in\nto a non-replacement policy regime, is that a technically sound option for\nus to have on the network and enforce in software?  Specifically, does that\ninterfere with having a sensible anti-DoS mempool acceptance algorithm, or\ninterfere with other protocols on the network, or necessarily run counter\nto the interests of miners or node operators?\n\nAnd I think the answer to that question, in looking at the difference\nbetween opt-in RBF and fullrbf, is no: offering the ability to opt-in to a\nnon-replacement regime for transactions doesn't introduce any fundamental\nissues with software or network policy or other protocols.  In a world\nwhere we only had fullrbf, I could imagine at some point down the road\nproposing a non-replacement signal myself, because the complexities around\ntransaction chains (and pinning) are more complex for the RBF case than for\nthe non-RBF case (and BIP 125 is not always incentive compatible to begin\nwith!).  Conceptually, this is no different to me than the version=3\ntransaction policy proposal that has been advancing, if we think of it as a\nspecial set of restrictions on transactions designed to accommodate a\nparticular use case.\n\nPhilosophically, I think we should be looking to add non-interfering use\ncases to what the network supports.\n\nTo those who argue for making fullrbf a default policy on the network (or\neven just offering a flag for users to enable fullrbf), I pose this\nhypothetical: suppose we deploy the v3 transaction policy proposal (which I\nhope will happen in the near future).  That policy would restrict the ways\nthat outputs of a v3 transaction can be spent while the transaction is\nunconfirmed, including by limiting the number and size of descendants that\nsuch a transaction can have, and limiting the types of unconfirmed\nancestors that can be included.  Suppose in a few years someone proposes\nthat we add a \"-disable_v3_transaction_enforcement\" flag to our software,\nto let users decide to turn off those policy restrictions and treat v3\ntransactions the same as v2, for all the same reasons that could be argued\ntoday with fullrbf: miners might earn more revenue if we allowed multiple\ndescendant v3 transactions; it's illogical for the recipient of a v3\ntransaction to believe what is a fundamentally unenforceable promise of a\nsender to not issue more high value children that descend from an\nunconfirmed transaction; it's inappropriate for Bitcoin Core to dictate\npolicy on the network and we should honor user choice to turn off that flag\nif that\u2019s what users want; if users are relying on v3\u2019s policy restrictions\nfor security then that is an unstable model and we should assume it will\nget broken[5].\n\nIt\u2019s obvious to me that adding a flag to disable v3 policy would be\nsubversive to making the lightning use case for v3 transactions work.  And\nso my response to such a hypothetical proposal would be to argue that no,\nwe should not enable users to disable this policy, because as long as that\npolicy is just optional and working for those who want it, it shouldn\u2019t\nharm anyone that we offer a tighter set of rules for a particular use\ncase.  Adding a way to bypass those rules is just trying to break someone\nelse\u2019s use case, not trying to add a new one.  We should not wield\n\"incentive compatibility\" as a bludgeon for breaking things that appear to\nbe working and not causing others harm.\n\nI think this is exactly what is happening with fullrbf.\n\nIn comparing v3 transaction policy with opting out of transaction\nreplacement, there is of course one significant difference that I have\nignored thus far: I think the real difference is an opinion about whether\nnon-replacement transactions that are being used today are, overall, bad\nfor Bitcoin, and whether lightning\u2019s use of v3 transactions in the future\nwould be bad for Bitcoin. If you think that zeroconf is unequivocally bad,\nand that no one will be able to plausibly construct a case that lightning\nis bad, then that qualitative judgment might sway you to not worrying about\nthe philosophical issues I've raised above, because these situations can be\ndistinguished.\n\nHowever I am not personally willing to say that I think, overall,\nnon-rbf-signaling transactions in use on the network today are bad for\nBitcoin (or that fullrbf is definitely good \u2013 BIP 125\u2019s rbf rules are\nsomething we\u2019ve been trying to improve upon for years, with little\nsuccess).  Nor am I convinced that someone couldn\u2019t put together a cogent\nargument for lightning being bad for Bitcoin, because of its reliance on\nrelay policies that are difficult to design and impossible to guarantee as\npart of its security model.  So I choose instead to merely make a judgment\nthat seems more factually verifiable, which is that non-replacement is a\npolicy widely in use on the network today, and we largely don't have reason\nto think (as far as I know!) that the network is seeing a lot of\ntransactions that would violate that policy.\n\nIf it did turn out that users were commonly signaling non-replacement, but\nthen signing and trying to relay doublespends, then I think that would be a\nvery good reason for Bitcoin Core to adopt fullrbf to reflect the reality\nof what is happening.  In the meantime, I think it makes more sense to say\nthat because we have BIP 125, there seems to be no need for users to signal\none way and behave another, and therefore there is no need to offer\nsoftware that might break a policy that is working well for some users.\nOther software projects might choose differently, and it is after all a\npermissionless network, so if this is in fact an unstable equilibrium that\nwill not last, then presumably someday it will be apparent it is not\nworking and we\u2019ll abandon it.  But I think the philosophy of transaction\nrelay policy in Bitcoin Core should be to support disparate use cases in\norder to try to make everything work better, rather than break things\nprematurely because we guess others will break them eventually anyway.\n\nFor those that have read this long email and still favor a fullrbf network\npolicy (or even just the ability for users to be able to turn on fullrbf\nfor themselves), I\u2019d ask for thoughts on the following questions, which\nhave guided my thinking on this:\n\nDoes fullrbf offer any benefits other than breaking zeroconf business\npractices?  If so, what are they?\n\nIs it reasonable to enforce BIP 125's rbf rules on all transactions, if\nthose rules themselves are not always incentive compatible?\n\nIf someone were to propose a command line option that breaks v3 transaction\nrelay in the future, is there a logical basis for opposing that which is\nconsistent with moving towards fullrbf now?\n\nCheers,\nSuhas\n\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n\n[2]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n\n[3] This is because under the BIP 125 rules, the feerate of the replacement\ntransaction is not compared to the individual feerates of all transactions\nbeing evicted \u2013 we just compare feerates with the transactions that are\ndirectly in conflict (and not their descendants). So it\u2019s possible for a\ntransaction that would evict 2 or more transactions to have a higher\nfeerate than the direct conflicts, and higher total fee than the set being\nevicted, but have a lower feerate (eg if it is larger) than that of some\nsubset of the set of transactions being evicted.\n\n[4]  Chaining unconfirmed transactions when the sender might RBF the parent\nis far riskier than if the sender indicates they don't plan to do so\n(chaining onto an RBF transaction creates pinning issues for the sender,\nand risks having the child wiped out if the parent is replaced), so I think\nthis is a concrete reason why signaling that a transaction won\u2019t be\nreplaced could be useful.\n\n[5] This is a subtle point. I don\u2019t think v3 transactions create an\nunreasonable security assumption for the use case it is being designed for.\nHowever, I don\u2019t think anyone could rule out the possibility that someone\ncould adopt a usage pattern for v3 transactions that subverts the intent of\nthis policy.  For example, if users started using v3 transactions for all\ntheir payments, then the limitations on the number of descendants could\ndirectly interfere with CPFP by a recipient, and someone could argue that\nwe should break the policy in order to allow for this hypothetical\nbehavior. I think this is a similar form of argument as saying that\nzeroconf practices + BIP 125 create an incentive to double-spend non-rbf\nsignaling transactions.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221031/82fe4bab/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-10-31T16:25:46",
                "message_text_only": "Thanks for your full thoughts Suhas,\n\nThe idea of V3 is that we're currently leaving fees on the table by\nallowing use-cases to be pinned, not that we like Lightning and we think\nminers should stop being profit maximizing somehow to enable safer/better\nlayer 2 systems.\n\nIf someone wants to bump fees for V3 transactions(or replace them!),\nthere's a much simpler \"API\" to do so than in legacy policy land. The fact\nthat it disallows more idiotic ways to add more total fees means wallets\n\"shouldn't do that\". If it ends up that V3 is disallowing too many\n\"natural\" ways to fee bump, that's a strike against the V3 idea and should\nbe discussed. For 0-conf services we have potential thieves who are willing\nto *out-bid themselves* to have funds come back to themselves. It's not a\n\"legitimate\" use-case, but a rational one.\n\nI have mostly come around to not pushing for fullrbf due to the issues you\nmentioned, except taking away the option. Removing a\nquite-likely-incentive-compatible option from the software just encourages\nminers to adopt an additional patch if they ever deem it necessary to\nincrease their revenue, even if that revenue is from hurting 0-conf\nbusinesses.\n\nMaybe putting/leaving in a default-false flag for disabling these \"carve\nouts\" is the least bad option. V3 usage patterns shouldn't crumble if a\nlarge majority of miners opt out, but 0-conf use cases crumble after a\nsmall percentage of adoption.\n\nTo recap my thoughts:\n\n1) I have put away my fullrbf hats, I will not advocate anyone running it\nas I think it doesn't really do anything useful for users who aren't trying\nto double-spend merchants.\n2) Forcing miners to honor fees left on the table with respect to 0-conf,\nor forcing them to run a custom patchset to go around it, is a step\nbackwards.\n\nGreg\n\nOn Mon, Oct 31, 2022 at 11:03 AM Suhas Daftuar via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> AJ,\n>\n> Thanks for the thoughtful post. I think your observations about how we\n> view mempool policy in the Bitcoin Core project, and how that seems to be\n> changing in the discussions around `-mempoolfullrbf`, are on-point and\n> provide a helpful baseline for considering future policy changes.\n>\n> For a long time I viewed fullrbf as an eventuality and I considered myself\n> to be philosophically supportive of the idea.  However, after giving this\n> issue some thought in the past few weeks, I am reversing my thinking on\n> this.  Concretely, I will argue that we should continue to maintain a relay\n> policy where replacements are rejected for transactions that don't opt-in\n> to RBF (as described in BIP 125), and moreover, that we should remove the\n> `-mempoolfullrbf` flag from Bitcoin Core\u2019s latest release candidate and not\n> plan to release software with that flag, unless (or until) circumstances\n> change on the network, which I'll discuss below.\n>\n> This is, of course, a nuanced topic, and among the considerations is a\n> philosophy of how to think about the relay policy and configuration options\n> that we make available in Bitcoin Core (a consideration that is perhaps\n> unique to that project, but I think relevant for this mailing list).\n>\n> I'll start with some technical issues regarding the benefits of enabling\n> fullrbf on the network.  In the current BIP 125 regime, every time a\n> transaction is created, a choice is made whether to subject the transaction\n> to BIP 125\u2019s RBF rules or not (based on the sequence values of the\n> inputs).  So given that users can already opt-in to RBF, the benefit of a\n> \u201cfullrbf\u201d network policy would be if, somehow, RBF users were still denied\n> the benefits of RBF due to the existence of other transactions that don\u2019t\n> opt-in.\n>\n> Along those lines, Antoine Riard brought up[1] a DoS vector that is\n> available to someone who wants to interfere with multi-party funded\n> transactions, and suggested that fullrbf would eliminate the problem.\n> After exploring that question again in this thread (thanks to Greg Sanders\n> for clarifying this to me), I understand that the issue is around ensuring\n> that a multiparty (coinjoin-type) protocol is able to make eventual\n> progress, by having a candidate multiparty transaction either eventually\n> confirm or become conflicted with something that has been confirmed, in\n> which case the double-spend information could be used to start a new\n> coinjoin round with fewer participants.  The concern Antoine and Greg have\n> brought up is that non-rbf transactions can persist in the mempool\n> ~indefinitely (at a low feerate and not subject to replacement) and\n> interfere with progress being made in a coinjoin protocol.\n>\n> However, it seems to me that similar problems exist for such a protocol\n> even in a fullrbf world, as we understand that term today.  I mentioned the\n> ability for rbf \u201cpinning\u201d to interfere with relay of the multiparty\n> transaction (even if the conflicting transaction signals for RBF \u2013 a set of\n> large but low feerate conflicting transactions can persist in the mempool\n> and make it difficult for the coinjoin transaction from confirming, at\n> least without attaching a very large fee); and as Greg mentioned in a\n> followup, the BIP 125 rule to only permit 100 transactions to be removed\n> from the mempool at a time during a replacement can also be used to pin a\n> coinjoin protocol in the same way as a non-rbf transaction today.  It seems\n> to me that what these multiparty protocols actually need is some sort of\n> \"maximal rbf\" network policy: a way to guarantee that a transaction which\n> should be desirable for a miner to mine would always get to a miner and\n> considered for inclusion in a block, no matter what the state of node\u2019s\n> mempools on the network.\n>\n> While that sounds like a reasonable thing to want on its face (and worth\n> working on), it's not how opt-in RBF works today, nor is it how transaction\n> relay has ever conceptually worked.  We have not, thus far, been able to\n> come up with a total ordering on transaction desirability.  Moreover, due\n> to all the DoS issues that exist with transaction relay, there are plenty\n> of seemingly legitimate ways to construct transactions that would not relay\n> well on the network.  Relay has only ever been a best-efforts concept,\n> where we carve out a small subset of the entire transaction universe for\n> which we try to optimize propagation.  The idea behind this approach is\n> that if every use case we can come up with has some way to achieve its\n> goals using transactions that should (eventually) be able to relay, then\n> users wouldn\u2019t have much demand for transactions that would deviate from\n> the supported policies, and we therefore shouldn\u2019t need to worry too much\n> about incentive compatibility concerns when it comes to transaction types\n> that wouldn\u2019t relay at all, even if they are high feerate.  (And when those\n> situations arise where the standard transactions do not accommodate some\n> needed use case, developers typically work to define a policy that is\n> compatible with our anti-DoS goals to support such use cases, such as with\n> the recent proposal for version=3 transactions [2].)\n>\n> BIP 125's RBF rules themselves were an effort to carve out just a subset\n> of situations where a transaction should evict conflicting ones -- it was\n> not a design that anyone thought would ensure that all replacements which\n> \"should\" be mined would always propagate.  And I don't believe that we know\n> how to design policy rules that would achieve the goals of this kind of\n> multiparty protocol in a DoS resistant way, today.  Along those lines, I\n> would point out that even the BIP 125 design itself is not entirely\n> incentive compatible, in that it is possible to construct a replacement\n> transaction that would evict transactions which would be preferable to be\n> included in a block! [3]  (This has been known for years, but fixing this\n> has proven difficult, and the only way to fix it that I\u2019m aware of would be\n> to make BIP 125 RBF even more restrictive than it is today. I do think this\n> is something that needs to be worked on.)\n>\n> Given the limitations of RBF as we have it today, it appears to be\n> incorrect that a fullrbf network policy would solve the problems Antoine\n> raised.  And so absent any other examples, it does not seem to me that\n> fullrbf solves any problems for RBF users, who are already free to choose\n> to subject their transactions to BIP 125\u2019s RBF policy.  From this\n> perspective, \"enabling fullrbf\" is really just taking away user choice to\n> opt a transaction into a non-replacement policy regime.\n>\n> I think we should ask, then, whether it is reasonable on its face that\n> users might want to opt-in to a non-replacement policy?  Or in other words,\n> is it reasonable for a user to mark a transaction as non-replaceable and\n> have that indication be enforced by the network? Note that these are two\n> different questions: you could imagine a world where fullrbf is a dominant\n> policy, but users still use the BIP 125 signaling method to indicate, in an\n> unenforced way, their intention to not replace a transaction.  This might\n> give useful information to the network or the recipient for how to interact\n> with such a transaction.\n>\n> And I think that it's entirely possible that users would continue to use\n> the BIP 125 signaling to indicate that they do not intend to replace a\n> transaction.  For better or worse, this might be because zeroconf services\n> continue to differentiate their behavior based on such a signal (possibly\n> in conjunction with other factors), or it could be because there are other\n> behaviors that could be utilized more effectively if the transaction\n> originator has made such a signal, such as the recipient chaining an\n> unconfirmed transaction as a way to bump the fee (CPFP) [4].\n>\n> If it were to be the case that users continued to use BIP 125-style\n> signaling to indicate that they do not plan to replace a transaction, would\n> that be harmful to the network?  This is not something we can stop in our\n> policy rules (short of censoring such transactions, an obviously bad\n> idea).  I think network actors can always do things that we might think are\n> harmful for the network, but that doesn\u2019t mean that there are no legitimate\n> use cases for the tools that such actors might be using.  Just because\n> someone might use some policy to adopt a zeroconf model, doesn\u2019t mean that\n> others aren\u2019t using the same policy to achieve benign ends (such as better\n> CPFP behavior).\n>\n> Moreover, while users might attempt to exploit services that offer\n> zeroconf or other differentiated behavior to non-replacement signaling\n> transactions, they also might not -- I think predicting user behavior in\n> this way (and specifically predicting the complexities of what a business\n> might do and whether users might try to subvert it) is beyond the scope of\n> what we can do as protocol developers.  Instead, I think we can try to\n> answer a different question: if a group of users were to want the ability\n> to opt-in to a non-replacement policy regime, is that a technically sound\n> option for us to have on the network and enforce in software?\n> Specifically, does that interfere with having a sensible anti-DoS mempool\n> acceptance algorithm, or interfere with other protocols on the network, or\n> necessarily run counter to the interests of miners or node operators?\n>\n> And I think the answer to that question, in looking at the difference\n> between opt-in RBF and fullrbf, is no: offering the ability to opt-in to a\n> non-replacement regime for transactions doesn't introduce any fundamental\n> issues with software or network policy or other protocols.  In a world\n> where we only had fullrbf, I could imagine at some point down the road\n> proposing a non-replacement signal myself, because the complexities around\n> transaction chains (and pinning) are more complex for the RBF case than for\n> the non-RBF case (and BIP 125 is not always incentive compatible to begin\n> with!).  Conceptually, this is no different to me than the version=3\n> transaction policy proposal that has been advancing, if we think of it as a\n> special set of restrictions on transactions designed to accommodate a\n> particular use case.\n>\n> Philosophically, I think we should be looking to add non-interfering use\n> cases to what the network supports.\n>\n> To those who argue for making fullrbf a default policy on the network (or\n> even just offering a flag for users to enable fullrbf), I pose this\n> hypothetical: suppose we deploy the v3 transaction policy proposal (which I\n> hope will happen in the near future).  That policy would restrict the ways\n> that outputs of a v3 transaction can be spent while the transaction is\n> unconfirmed, including by limiting the number and size of descendants that\n> such a transaction can have, and limiting the types of unconfirmed\n> ancestors that can be included.  Suppose in a few years someone proposes\n> that we add a \"-disable_v3_transaction_enforcement\" flag to our software,\n> to let users decide to turn off those policy restrictions and treat v3\n> transactions the same as v2, for all the same reasons that could be argued\n> today with fullrbf: miners might earn more revenue if we allowed multiple\n> descendant v3 transactions; it's illogical for the recipient of a v3\n> transaction to believe what is a fundamentally unenforceable promise of a\n> sender to not issue more high value children that descend from an\n> unconfirmed transaction; it's inappropriate for Bitcoin Core to dictate\n> policy on the network and we should honor user choice to turn off that flag\n> if that\u2019s what users want; if users are relying on v3\u2019s policy restrictions\n> for security then that is an unstable model and we should assume it will\n> get broken[5].\n>\n> It\u2019s obvious to me that adding a flag to disable v3 policy would be\n> subversive to making the lightning use case for v3 transactions work.  And\n> so my response to such a hypothetical proposal would be to argue that no,\n> we should not enable users to disable this policy, because as long as that\n> policy is just optional and working for those who want it, it shouldn\u2019t\n> harm anyone that we offer a tighter set of rules for a particular use\n> case.  Adding a way to bypass those rules is just trying to break someone\n> else\u2019s use case, not trying to add a new one.  We should not wield\n> \"incentive compatibility\" as a bludgeon for breaking things that appear to\n> be working and not causing others harm.\n>\n> I think this is exactly what is happening with fullrbf.\n>\n> In comparing v3 transaction policy with opting out of transaction\n> replacement, there is of course one significant difference that I have\n> ignored thus far: I think the real difference is an opinion about whether\n> non-replacement transactions that are being used today are, overall, bad\n> for Bitcoin, and whether lightning\u2019s use of v3 transactions in the future\n> would be bad for Bitcoin. If you think that zeroconf is unequivocally bad,\n> and that no one will be able to plausibly construct a case that lightning\n> is bad, then that qualitative judgment might sway you to not worrying about\n> the philosophical issues I've raised above, because these situations can be\n> distinguished.\n>\n> However I am not personally willing to say that I think, overall,\n> non-rbf-signaling transactions in use on the network today are bad for\n> Bitcoin (or that fullrbf is definitely good \u2013 BIP 125\u2019s rbf rules are\n> something we\u2019ve been trying to improve upon for years, with little\n> success).  Nor am I convinced that someone couldn\u2019t put together a cogent\n> argument for lightning being bad for Bitcoin, because of its reliance on\n> relay policies that are difficult to design and impossible to guarantee as\n> part of its security model.  So I choose instead to merely make a judgment\n> that seems more factually verifiable, which is that non-replacement is a\n> policy widely in use on the network today, and we largely don't have reason\n> to think (as far as I know!) that the network is seeing a lot of\n> transactions that would violate that policy.\n>\n> If it did turn out that users were commonly signaling non-replacement, but\n> then signing and trying to relay doublespends, then I think that would be a\n> very good reason for Bitcoin Core to adopt fullrbf to reflect the reality\n> of what is happening.  In the meantime, I think it makes more sense to say\n> that because we have BIP 125, there seems to be no need for users to signal\n> one way and behave another, and therefore there is no need to offer\n> software that might break a policy that is working well for some users.\n> Other software projects might choose differently, and it is after all a\n> permissionless network, so if this is in fact an unstable equilibrium that\n> will not last, then presumably someday it will be apparent it is not\n> working and we\u2019ll abandon it.  But I think the philosophy of transaction\n> relay policy in Bitcoin Core should be to support disparate use cases in\n> order to try to make everything work better, rather than break things\n> prematurely because we guess others will break them eventually anyway.\n>\n> For those that have read this long email and still favor a fullrbf network\n> policy (or even just the ability for users to be able to turn on fullrbf\n> for themselves), I\u2019d ask for thoughts on the following questions, which\n> have guided my thinking on this:\n>\n> Does fullrbf offer any benefits other than breaking zeroconf business\n> practices?  If so, what are they?\n>\n> Is it reasonable to enforce BIP 125's rbf rules on all transactions, if\n> those rules themselves are not always incentive compatible?\n>\n> If someone were to propose a command line option that breaks v3\n> transaction relay in the future, is there a logical basis for opposing that\n> which is consistent with moving towards fullrbf now?\n>\n> Cheers,\n> Suhas\n>\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n>\n> [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n>\n> [3] This is because under the BIP 125 rules, the feerate of the\n> replacement transaction is not compared to the individual feerates of all\n> transactions being evicted \u2013 we just compare feerates with the transactions\n> that are directly in conflict (and not their descendants). So it\u2019s possible\n> for a transaction that would evict 2 or more transactions to have a higher\n> feerate than the direct conflicts, and higher total fee than the set being\n> evicted, but have a lower feerate (eg if it is larger) than that of some\n> subset of the set of transactions being evicted.\n>\n> [4]  Chaining unconfirmed transactions when the sender might RBF the\n> parent is far riskier than if the sender indicates they don't plan to do so\n> (chaining onto an RBF transaction creates pinning issues for the sender,\n> and risks having the child wiped out if the parent is replaced), so I think\n> this is a concrete reason why signaling that a transaction won\u2019t be\n> replaced could be useful.\n>\n> [5] This is a subtle point. I don\u2019t think v3 transactions create an\n> unreasonable security assumption for the use case it is being designed for.\n> However, I don\u2019t think anyone could rule out the possibility that someone\n> could adopt a usage pattern for v3 transactions that subverts the intent of\n> this policy.  For example, if users started using v3 transactions for all\n> their payments, then the limitations on the number of descendants could\n> directly interfere with CPFP by a recipient, and someone could argue that\n> we should break the policy in order to allow for this hypothetical\n> behavior. I think this is a similar form of argument as saying that\n> zeroconf practices + BIP 125 create an incentive to double-spend non-rbf\n> signaling transactions.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221031/a253148a/attachment-0001.html>"
            },
            {
                "author": "email at yancy.lol",
                "date": "2022-10-31T17:21:08",
                "message_text_only": "Protocol Devs,\n\nAfter reading through this email thread and BIP125, I'm curious if \nnon-rbf nodes will relay full-rbf transactions and vice versa.  That is \nto say, if only one non-rbf node exists on the network, however, every \nother node implements full-rbf, will the transaction still be \npropagated?  IE can we always guarantee a path through the network for \neither transaction type no matter what the combination of network \npolicies are?\n\n> Does fullrbf offer any benefits other than breaking zeroconf\n> business practices?  If so, what are they?\n\nI think AJ mentioned this earlier, but adding more configuration options \nalways increases code complexity, and with that, there is likely more \nunforeseen bugs.  However, there is a section of network participants \nthat rely on both types of transaction policy, so from my limited \nview-point, it seems worth accommodating if possible.\n\nCheers,\n-Yancy\n\nOn 2022-10-31 17:25, Greg Sanders via bitcoin-dev wrote:\n\n> Thanks for your full thoughts Suhas,\n> \n> The idea of V3 is that we're currently leaving fees on the table by\n> allowing use-cases to be pinned, not that we like Lightning and we\n> think miners should stop being profit maximizing somehow to enable\n> safer/better layer 2 systems.\n> \n> If someone wants to bump fees for V3 transactions(or replace them!),\n> there's a much simpler \"API\" to do so than in legacy policy land. The\n> fact that it disallows more idiotic ways to add more total fees means\n> wallets \"shouldn't do that\". If it ends up that V3 is disallowing too\n> many \"natural\" ways to fee bump, that's a strike against the V3 idea\n> and should be discussed. For 0-conf services we have potential thieves\n> who are willing to *out-bid themselves* to have funds come back to\n> themselves. It's not a \"legitimate\" use-case, but a rational one.\n> \n> I have mostly come around to not pushing for fullrbf due to the issues\n> you mentioned, except taking away the option. Removing a\n> quite-likely-incentive-compatible option from the software just\n> encourages miners to adopt an additional patch if they ever deem it\n> necessary to increase their revenue, even if that revenue is from\n> hurting 0-conf businesses.\n> \n> Maybe putting/leaving in a default-false flag for disabling these\n> \"carve outs\" is the least bad option. V3 usage patterns shouldn't\n> crumble if a large majority of miners opt out, but 0-conf use cases\n> crumble after a small percentage of adoption.\n> \n> To recap my thoughts:\n> \n> 1) I have put away my fullrbf hats, I will not advocate anyone running\n> it as I think it doesn't really do anything useful for users who\n> aren't trying to double-spend merchants.\n> \n> 2) Forcing miners to honor fees left on the table with respect to\n> 0-conf, or forcing them to run a custom patchset to go around it, is a\n> step backwards.\n> \n> Greg\n> \n> On Mon, Oct 31, 2022 at 11:03 AM Suhas Daftuar via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n>> AJ,\n>> \n>> Thanks for the thoughtful post. I think your observations about how\n>> we view mempool policy in the Bitcoin Core project, and how that\n>> seems to be changing in the discussions around `-mempoolfullrbf`,\n>> are on-point and provide a helpful baseline for considering future\n>> policy changes.\n>> \n>> For a long time I viewed fullrbf as an eventuality and I considered\n>> myself to be philosophically supportive of the idea.  However, after\n>> giving this issue some thought in the past few weeks, I am reversing\n>> my thinking on this.  Concretely, I will argue that we should\n>> continue to maintain a relay policy where replacements are rejected\n>> for transactions that don't opt-in to RBF (as described in BIP 125),\n>> and moreover, that we should remove the `-mempoolfullrbf` flag from\n>> Bitcoin Core's latest release candidate and not plan to release\n>> software with that flag, unless (or until) circumstances change on\n>> the network, which I'll discuss below.\n>> \n>> This is, of course, a nuanced topic, and among the considerations is\n>> a philosophy of how to think about the relay policy and\n>> configuration options that we make available in Bitcoin Core (a\n>> consideration that is perhaps unique to that project, but I think\n>> relevant for this mailing list).\n>> \n>> I'll start with some technical issues regarding the benefits of\n>> enabling fullrbf on the network.  In the current BIP 125 regime,\n>> every time a transaction is created, a choice is made whether to\n>> subject the transaction to BIP 125's RBF rules or not (based on\n>> the sequence values of the inputs).  So given that users can already\n>> opt-in to RBF, the benefit of a \"fullrbf\" network policy would\n>> be if, somehow, RBF users were still denied the benefits of RBF due\n>> to the existence of other transactions that don't opt-in.\n>> \n>> Along those lines, Antoine Riard brought up[1] a DoS vector that is\n>> available to someone who wants to interfere with multi-party funded\n>> transactions, and suggested that fullrbf would eliminate the\n>> problem.  After exploring that question again in this thread (thanks\n>> to Greg Sanders for clarifying this to me), I understand that the\n>> issue is around ensuring that a multiparty (coinjoin-type) protocol\n>> is able to make eventual progress, by having a candidate multiparty\n>> transaction either eventually confirm or become conflicted with\n>> something that has been confirmed, in which case the double-spend\n>> information could be used to start a new coinjoin round with fewer\n>> participants.  The concern Antoine and Greg have brought up is that\n>> non-rbf transactions can persist in the mempool ~indefinitely (at a\n>> low feerate and not subject to replacement) and interfere with\n>> progress being made in a coinjoin protocol.\n>> \n>> However, it seems to me that similar problems exist for such a\n>> protocol even in a fullrbf world, as we understand that term today.\n>> I mentioned the ability for rbf \"pinning\" to interfere with\n>> relay of the multiparty transaction (even if the conflicting\n>> transaction signals for RBF - a set of large but low feerate\n>> conflicting transactions can persist in the mempool and make it\n>> difficult for the coinjoin transaction from confirming, at least\n>> without attaching a very large fee); and as Greg mentioned in a\n>> followup, the BIP 125 rule to only permit 100 transactions to be\n>> removed from the mempool at a time during a replacement can also be\n>> used to pin a coinjoin protocol in the same way as a non-rbf\n>> transaction today.  It seems to me that what these multiparty\n>> protocols actually need is some sort of \"maximal rbf\" network\n>> policy: a way to guarantee that a transaction which should be\n>> desirable for a miner to mine would always get to a miner and\n>> considered for inclusion in a block, no matter what the state of\n>> node's mempools on the network.\n>> \n>> While that sounds like a reasonable thing to want on its face (and\n>> worth working on), it's not how opt-in RBF works today, nor is it\n>> how transaction relay has ever conceptually worked.  We have not,\n>> thus far, been able to come up with a total ordering on transaction\n>> desirability.  Moreover, due to all the DoS issues that exist with\n>> transaction relay, there are plenty of seemingly legitimate ways to\n>> construct transactions that would not relay well on the network.\n>> Relay has only ever been a best-efforts concept, where we carve out\n>> a small subset of the entire transaction universe for which we try\n>> to optimize propagation.  The idea behind this approach is that if\n>> every use case we can come up with has some way to achieve its goals\n>> using transactions that should (eventually) be able to relay, then\n>> users wouldn't have much demand for transactions that would\n>> deviate from the supported policies, and we therefore shouldn't\n>> need to worry too much about incentive compatibility concerns when\n>> it comes to transaction types that wouldn't relay at all, even if\n>> they are high feerate.  (And when those situations arise where the\n>> standard transactions do not accommodate some needed use case,\n>> developers typically work to define a policy that is compatible with\n>> our anti-DoS goals to support such use cases, such as with the\n>> recent proposal for version=3 transactions [2].)\n>> \n>> BIP 125's RBF rules themselves were an effort to carve out just a\n>> subset of situations where a transaction should evict conflicting\n>> ones -- it was not a design that anyone thought would ensure that\n>> all replacements which \"should\" be mined would always propagate.\n>> And I don't believe that we know how to design policy rules that\n>> would achieve the goals of this kind of multiparty protocol in a DoS\n>> resistant way, today.  Along those lines, I would point out that\n>> even the BIP 125 design itself is not entirely incentive compatible,\n>> in that it is possible to construct a replacement transaction that\n>> would evict transactions which would be preferable to be included in\n>> a block! [3]  (This has been known for years, but fixing this has\n>> proven difficult, and the only way to fix it that I'm aware of\n>> would be to make BIP 125 RBF even more restrictive than it is today.\n>> I do think this is something that needs to be worked on.)\n>> \n>> Given the limitations of RBF as we have it today, it appears to be\n>> incorrect that a fullrbf network policy would solve the problems\n>> Antoine raised.  And so absent any other examples, it does not seem\n>> to me that fullrbf solves any problems for RBF users, who are\n>> already free to choose to subject their transactions to BIP 125's\n>> RBF policy.  From this perspective, \"enabling fullrbf\" is really\n>> just taking away user choice to opt a transaction into a\n>> non-replacement policy regime.\n>> \n>> I think we should ask, then, whether it is reasonable on its face\n>> that users might want to opt-in to a non-replacement policy?  Or in\n>> other words, is it reasonable for a user to mark a transaction as\n>> non-replaceable and have that indication be enforced by the network?\n>> Note that these are two different questions: you could imagine a\n>> world where fullrbf is a dominant policy, but users still use the\n>> BIP 125 signaling method to indicate, in an unenforced way, their\n>> intention to not replace a transaction.  This might give useful\n>> information to the network or the recipient for how to interact with\n>> such a transaction.\n>> \n>> And I think that it's entirely possible that users would continue to\n>> use the BIP 125 signaling to indicate that they do not intend to\n>> replace a transaction.  For better or worse, this might be because\n>> zeroconf services continue to differentiate their behavior based on\n>> such a signal (possibly in conjunction with other factors), or it\n>> could be because there are other behaviors that could be utilized\n>> more effectively if the transaction originator has made such a\n>> signal, such as the recipient chaining an unconfirmed transaction as\n>> a way to bump the fee (CPFP) [4].\n>> \n>> If it were to be the case that users continued to use BIP 125-style\n>> signaling to indicate that they do not plan to replace a\n>> transaction, would that be harmful to the network?  This is not\n>> something we can stop in our policy rules (short of censoring such\n>> transactions, an obviously bad idea).  I think network actors can\n>> always do things that we might think are harmful for the network,\n>> but that doesn't mean that there are no legitimate use cases for\n>> the tools that such actors might be using.  Just because someone\n>> might use some policy to adopt a zeroconf model, doesn't mean that\n>> others aren't using the same policy to achieve benign ends (such\n>> as better CPFP behavior).\n>> \n>> Moreover, while users might attempt to exploit services that offer\n>> zeroconf or other differentiated behavior to non-replacement\n>> signaling transactions, they also might not -- I think predicting\n>> user behavior in this way (and specifically predicting the\n>> complexities of what a business might do and whether users might try\n>> to subvert it) is beyond the scope of what we can do as protocol\n>> developers.  Instead, I think we can try to answer a different\n>> question: if a group of users were to want the ability to opt-in to\n>> a non-replacement policy regime, is that a technically sound option\n>> for us to have on the network and enforce in software?\n>> Specifically, does that interfere with having a sensible anti-DoS\n>> mempool acceptance algorithm, or interfere with other protocols on\n>> the network, or necessarily run counter to the interests of miners\n>> or node operators?\n>> \n>> And I think the answer to that question, in looking at the\n>> difference between opt-in RBF and fullrbf, is no: offering the\n>> ability to opt-in to a non-replacement regime for transactions\n>> doesn't introduce any fundamental issues with software or network\n>> policy or other protocols.  In a world where we only had fullrbf, I\n>> could imagine at some point down the road proposing a\n>> non-replacement signal myself, because the complexities around\n>> transaction chains (and pinning) are more complex for the RBF case\n>> than for the non-RBF case (and BIP 125 is not always incentive\n>> compatible to begin with!).  Conceptually, this is no different to\n>> me than the version=3 transaction policy proposal that has been\n>> advancing, if we think of it as a special set of restrictions on\n>> transactions designed to accommodate a particular use case.\n>> \n>> Philosophically, I think we should be looking to add non-interfering\n>> use cases to what the network supports.\n>> \n>> To those who argue for making fullrbf a default policy on the\n>> network (or even just offering a flag for users to enable fullrbf),\n>> I pose this hypothetical: suppose we deploy the v3 transaction\n>> policy proposal (which I hope will happen in the near future).  That\n>> policy would restrict the ways that outputs of a v3 transaction can\n>> be spent while the transaction is unconfirmed, including by limiting\n>> the number and size of descendants that such a transaction can have,\n>> and limiting the types of unconfirmed ancestors that can be\n>> included.  Suppose in a few years someone proposes that we add a\n>> \"-disable_v3_transaction_enforcement\" flag to our software, to let\n>> users decide to turn off those policy restrictions and treat v3\n>> transactions the same as v2, for all the same reasons that could be\n>> argued today with fullrbf: miners might earn more revenue if we\n>> allowed multiple descendant v3 transactions; it's illogical for the\n>> recipient of a v3 transaction to believe what is a fundamentally\n>> unenforceable promise of a sender to not issue more high value\n>> children that descend from an unconfirmed transaction; it's\n>> inappropriate for Bitcoin Core to dictate policy on the network and\n>> we should honor user choice to turn off that flag if that's what\n>> users want; if users are relying on v3's policy restrictions for\n>> security then that is an unstable model and we should assume it will\n>> get broken[5].\n>> \n>> It's obvious to me that adding a flag to disable v3 policy would\n>> be subversive to making the lightning use case for v3 transactions\n>> work.  And so my response to such a hypothetical proposal would be\n>> to argue that no, we should not enable users to disable this policy,\n>> because as long as that policy is just optional and working for\n>> those who want it, it shouldn't harm anyone that we offer a\n>> tighter set of rules for a particular use case.  Adding a way to\n>> bypass those rules is just trying to break someone else's use\n>> case, not trying to add a new one.  We should not wield \"incentive\n>> compatibility\" as a bludgeon for breaking things that appear to be\n>> working and not causing others harm.\n>> \n>> I think this is exactly what is happening with fullrbf.\n>> \n>> In comparing v3 transaction policy with opting out of transaction\n>> replacement, there is of course one significant difference that I\n>> have ignored thus far: I think the real difference is an opinion\n>> about whether non-replacement transactions that are being used today\n>> are, overall, bad for Bitcoin, and whether lightning's use of v3\n>> transactions in the future would be bad for Bitcoin. If you think\n>> that zeroconf is unequivocally bad, and that no one will be able to\n>> plausibly construct a case that lightning is bad, then that\n>> qualitative judgment might sway you to not worrying about the\n>> philosophical issues I've raised above, because these situations can\n>> be distinguished.\n>> \n>> However I am not personally willing to say that I think, overall,\n>> non-rbf-signaling transactions in use on the network today are bad\n>> for Bitcoin (or that fullrbf is definitely good - BIP 125's rbf\n>> rules are something we've been trying to improve upon for years,\n>> with little success).  Nor am I convinced that someone couldn't\n>> put together a cogent argument for lightning being bad for Bitcoin,\n>> because of its reliance on relay policies that are difficult to\n>> design and impossible to guarantee as part of its security model.\n>> So I choose instead to merely make a judgment that seems more\n>> factually verifiable, which is that non-replacement is a policy\n>> widely in use on the network today, and we largely don't have reason\n>> to think (as far as I know!) that the network is seeing a lot of\n>> transactions that would violate that policy.\n>> \n>> If it did turn out that users were commonly signaling\n>> non-replacement, but then signing and trying to relay doublespends,\n>> then I think that would be a very good reason for Bitcoin Core to\n>> adopt fullrbf to reflect the reality of what is happening.  In the\n>> meantime, I think it makes more sense to say that because we have\n>> BIP 125, there seems to be no need for users to signal one way and\n>> behave another, and therefore there is no need to offer software\n>> that might break a policy that is working well for some users.\n>> Other software projects might choose differently, and it is after\n>> all a permissionless network, so if this is in fact an unstable\n>> equilibrium that will not last, then presumably someday it will be\n>> apparent it is not working and we'll abandon it.  But I think the\n>> philosophy of transaction relay policy in Bitcoin Core should be to\n>> support disparate use cases in order to try to make everything work\n>> better, rather than break things prematurely because we guess others\n>> will break them eventually anyway.\n>> \n>> For those that have read this long email and still favor a fullrbf\n>> network policy (or even just the ability for users to be able to\n>> turn on fullrbf for themselves), I'd ask for thoughts on the\n>> following questions, which have guided my thinking on this:\n>> \n>> Does fullrbf offer any benefits other than breaking zeroconf\n>> business practices?  If so, what are they?\n>> \n>> Is it reasonable to enforce BIP 125's rbf rules on all transactions,\n>> if those rules themselves are not always incentive compatible?\n>> \n>> If someone were to propose a command line option that breaks v3\n>> transaction relay in the future, is there a logical basis for\n>> opposing that which is consistent with moving towards fullrbf now?\n>> \n>> Cheers,\n>> Suhas\n>> \n>> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html\n> \n>> [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html\n> \n>> [3] This is because under the BIP 125 rules, the feerate of the\n>> replacement transaction is not compared to the individual feerates\n>> of all transactions being evicted - we just compare feerates with\n>> the transactions that are directly in conflict (and not their\n>> descendants). So it's possible for a transaction that would evict\n>> 2 or more transactions to have a higher feerate than the direct\n>> conflicts, and higher total fee than the set being evicted, but have\n>> a lower feerate (eg if it is larger) than that of some subset of the\n>> set of transactions being evicted.\n>> \n>> [4]  Chaining unconfirmed transactions when the sender might RBF the\n>> parent is far riskier than if the sender indicates they don't plan\n>> to do so (chaining onto an RBF transaction creates pinning issues\n>> for the sender, and risks having the child wiped out if the parent\n>> is replaced), so I think this is a concrete reason why signaling\n>> that a transaction won't be replaced could be useful.\n>> \n>> [5] This is a subtle point. I don't think v3 transactions create\n>> an unreasonable security assumption for the use case it is being\n>> designed for. However, I don't think anyone could rule out the\n>> possibility that someone could adopt a usage pattern for v3\n>> transactions that subverts the intent of this policy.  For example,\n>> if users started using v3 transactions for all their payments, then\n>> the limitations on the number of descendants could directly\n>> interfere with CPFP by a recipient, and someone could argue that we\n>> should break the policy in order to allow for this hypothetical\n>> behavior. I think this is a similar form of argument as saying that\n>> zeroconf practices + BIP 125 create an incentive to double-spend\n>> non-rbf signaling transactions.\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221031/fc8ddf49/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2022-10-31T17:51:10",
                "message_text_only": "On Mon, Oct 31, 2022 at 06:21:08PM +0100, yancy via bitcoin-dev wrote:\n> \n> Protocol Devs,\n> \n> After reading through this email thread and BIP125, I'm curious if non-rbf\n> nodes will relay full-rbf transactions and vice versa.  That is to say, if\n> only one non-rbf node exists on the network, however, every other node\n> implements full-rbf, will the transaction still be propagated?  IE can we\n> always guarantee a path through the network for either transaction type no\n> matter what the combination of network policies are?\n\n1) There are nodes that signal full-rbf, and preferentially peer to each other,\nthus ensuring good transaction propagation. The most recent patch to implement\nthis is: https://github.com/bitcoin/bitcoin/pull/25600\n\nThere's enough peers running full-rbf that the last time I started up a new\nnode on a fresh IP address, it happened to have a peer relaying full-rbf\nreplacements to it. And of course, if people want full-rbf to work more\nreliably, it's very easy to just run some nodes with a large number of outgoing\npeers. Changing the hard-coded 8 outgoing peers to, say, 800, isn't very hard.\n\n2) There's nothing special about a \"full-rbf transaction\" other than the fact\nthat it's replacing a previously broadcast transaction that didn't signal\nreplacement. There is not consensus over the mempool, so in certain cases\nnon-full-rbf nodes will in fact broadcast replacements when they didn't happen\nto receive the \"first\" transaction first.\n\nThe latter makes testing full-rbf a bit problematic, as if you don't take\nspecial measures to ensure good propagation a small % of the time the\n\"replacement\" transaction will in fact be the one that gets gets mined.\n\n> > Does fullrbf offer any benefits other than breaking zeroconf\n> > business practices?  If so, what are they?\n> \n> I think AJ mentioned this earlier, but adding more configuration options\n> always increases code complexity, and with that, there is likely more\n> unforeseen bugs.  However, there is a section of network participants that\n> rely on both types of transaction policy, so from my limited view-point, it\n> seems worth accommodating if possible.\n\nSince all the machinery to do replacemnt already exists, adding a full-rbf\nconfig flag is particularly trivial. It requires just a single line in the\nmempool code.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20221031/b7db88a7/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "On mempool policy consistency",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Antoine Riard",
                "David A. Harding",
                "Anthony Towns",
                "Suhas Daftuar",
                "John Carvalho",
                "Peter Todd",
                "email at yancy.lol",
                "Gloria Zhao",
                "Luke Dashjr",
                "Greg Sanders"
            ],
            "messages_count": 21,
            "total_messages_chars_count": 234235
        }
    }
]