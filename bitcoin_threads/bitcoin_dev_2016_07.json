[
    {
        "title": "[bitcoin-dev] BIP 151 use of HMAC_SHA512",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-07-01T03:25:17",
                "message_text_only": "Ethan Heilman <eth3rs at gmail.com> writes:\n>>It's also not clear to me why the HMAC, vs just SHA256(key|cipher-type|mesg).  But that's probably just my crypto ignorance...\n>\n> SHA256(key|cipher-type|mesg) is an extremely insecure MAC because of\n> the length extension property of SHA256.\n>\n> If I have a tag y = SHA256(key|cipher-type|mesg), I can without\n> knowing key or msg compute a value y' such that\n> y' = SHA256(key|cipher-type|mesg|any values I want).\n\nNot quite, there's an important subtlety that SHA256 appends the\nbitlength, so you can only create:\n\ny' = SHA256(key|cipher-type|mesg|padding|bitlength|any values I want).\n\nBut we're not using this for a MAC in BIP151, we're using this to\ngenerate the encryption keys.\n\nArthur Chen <arthur.chen at btcc.com> said:\n> HMAC has proven security property.\n> It is still secure even when underlying crypto hashing function has\n> collision resistant weakness.\n> For example, MD5 is considered completely insecure now, but HMAC-MD5 is\n> still considered secure.\n> When in doubt, we should always use HMAC for MAC(Message Authentication\n> Code) rather than custom construction\n\nBitcoin already relies on SHA256's robustness, but again, we don't need\na MAC here.\n\nI'm happy to buy \"we just copied ssh\" if that's the answer, and I can't\nsee anything wrong with using HMAC here, it just seems odd...\n\nThanks!\nRusty."
            },
            {
                "author": "Zooko Wilcox",
                "date": "2016-07-01T22:42:19",
                "message_text_only": "I haven't been able to find the beginning of this thread, so apologies\nif I've misunderstood what this is for, but it _sounds_ like we're\nre-inventing HKDF.\n\nI'd recommend reading the paper about HKDF. It stands out among crypto\npapers for having a nice clear justification for each of its design\ndecisions, so you can see why they did it (very slightly) differently\nthan the various constructions proposed up-thread.\n\nhttps://eprint.iacr.org/2010/264\n\nAlso, of course, it is a great idea to re-use a standard\n(https://tools.ietf.org/html/rfc5869) and widely-understood crypto\nalgorithm to reduce risk of both cryptographer errors and implementor\nerrors.\n\nOf course, the cost of that is the you sometimes end up computing\nsomething that is a tiny bit more complicated or inefficient than a\ncustom algorithm for our current use case. IMHO that's a cheap price\nto pay.\n\nRegards,\n\nZooko"
            },
            {
                "author": "Arthur Chen",
                "date": "2016-07-04T01:23:14",
                "message_text_only": "I strongly agree!\nIn crypto we should always follow well-studied open standard rather than\ncustom construction.\n\nOn Fri, Jul 1, 2016 at 10:42 PM, Zooko Wilcox via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I haven't been able to find the beginning of this thread, so apologies\n> if I've misunderstood what this is for, but it _sounds_ like we're\n> re-inventing HKDF.\n>\n> I'd recommend reading the paper about HKDF. It stands out among crypto\n> papers for having a nice clear justification for each of its design\n> decisions, so you can see why they did it (very slightly) differently\n> than the various constructions proposed up-thread.\n>\n> https://eprint.iacr.org/2010/264\n>\n> Also, of course, it is a great idea to re-use a standard\n> (https://tools.ietf.org/html/rfc5869) and widely-understood crypto\n> algorithm to reduce risk of both cryptographer errors and implementor\n> errors.\n>\n> Of course, the cost of that is the you sometimes end up computing\n> something that is a tiny bit more complicated or inefficient than a\n> custom algorithm for our current use case. IMHO that's a cheap price\n> to pay.\n>\n> Regards,\n>\n> Zooko\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n\n\n\n-- \nXuesong (Arthur) Chen\nSenior Principle Engineer\nBlockChain Technologist\nBTCC\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160704/01f4de23/attachment.html>"
            },
            {
                "author": "Arthur Chen",
                "date": "2016-07-04T01:44:30",
                "message_text_only": "https://www.schneier.com/crypto-gram/archives/1998/1015.html#cipherdesign\n\nOn Mon, Jul 4, 2016 at 1:23 AM, Arthur Chen <arthur.chen at btcc.com> wrote:\n\n> I strongly agree!\n> In crypto we should always follow well-studied open standard rather than\n> custom construction.\n>\n> On Fri, Jul 1, 2016 at 10:42 PM, Zooko Wilcox via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> I haven't been able to find the beginning of this thread, so apologies\n>> if I've misunderstood what this is for, but it _sounds_ like we're\n>> re-inventing HKDF.\n>>\n>> I'd recommend reading the paper about HKDF. It stands out among crypto\n>> papers for having a nice clear justification for each of its design\n>> decisions, so you can see why they did it (very slightly) differently\n>> than the various constructions proposed up-thread.\n>>\n>> https://eprint.iacr.org/2010/264\n>>\n>> Also, of course, it is a great idea to re-use a standard\n>> (https://tools.ietf.org/html/rfc5869) and widely-understood crypto\n>> algorithm to reduce risk of both cryptographer errors and implementor\n>> errors.\n>>\n>> Of course, the cost of that is the you sometimes end up computing\n>> something that is a tiny bit more complicated or inefficient than a\n>> custom algorithm for our current use case. IMHO that's a cheap price\n>> to pay.\n>>\n>> Regards,\n>>\n>> Zooko\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>\n>\n>\n> --\n> Xuesong (Arthur) Chen\n> Senior Principle Engineer\n> BlockChain Technologist\n> BTCC\n>\n\n\n\n-- \nXuesong (Arthur) Chen\nSenior Principle Engineer\nBlockChain Technologist\nBTCC\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160704/a5d96302/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-07-04T06:47:05",
                "message_text_only": "Hi Arthur\n> \n>     I strongly agree!\n>     In crypto we should always follow well-studied open standard rather\n>     than custom construction.\n\nI totally agree.\nBIP151 does not introduce new cipher types.\nThe BIP uses ECDH together with ChaCha20-Poly1305 at openssh.\nBoth very well known and broad used crypo.\n\n/jonas\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160704/97fb8245/attachment.sig>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-07-04T06:37:45",
                "message_text_only": "> I haven't been able to find the beginning of this thread, so apologies\n> if I've misunderstood what this is for, but it _sounds_ like we're\n> re-inventing HKDF.\n\n> I'd recommend reading the paper about HKDF. It stands out among crypto\n> papers for having a nice clear justification for each of its design\n> decisions, so you can see why they did it (very slightly) differently\n> than the various constructions proposed up-thread.\n\nThanks Zooko\n\nI think HKDF instead of a single HMAC_SHA512 seams reasonable and\nsomething we should consider.\n\nI'll try to evaluate the implications of using HKDF over HMAC_SHA512 and\nwill update the BIP if there are no concerns about it.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160704/029dc8b2/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP 151 use of HMAC_SHA512",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Zooko Wilcox",
                "Arthur Chen",
                "Jonas Schnelli"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 7323
        }
    },
    {
        "title": "[bitcoin-dev] BIP 151",
        "thread_messages": [
            {
                "author": "Chris Priest",
                "date": "2016-07-02T09:44:00",
                "message_text_only": "On 6/30/16, Erik Aronesty via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I would like to see a PGP-like \"web of trust\" proposal for both the\n> security of the bitcoin network itself /and/ (eventually) of things like\n> transmission of bitcoin addresses.\n>\n> Something where nodes of any kind (full, spv, mobile wallets) can\n> /optionally/ accumulate trust over time and are capable of verifying the\n> identity of other nodes in that web.\n>\n\nIsn't the system already functioning in this way already? Bitcoin\nexchanges and block explorers already have a reputation earned by so\nmany years of serving the community. Their HTTPS certificate acts like\na public/private key, and when your wallet makes a request to their\nserver, the keys are automatically checked for validity by the\nunderlying http library."
            }
        ],
        "thread_summary": {
            "title": "BIP 151",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Chris Priest"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 824
        }
    },
    {
        "title": "[bitcoin-dev] Code Review: The Consensus Critical Parts of Segwit by Peter Todd",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-07-02T18:43:50",
                "message_text_only": "On Wed, Jun 29, 2016 at 12:22:45AM +0800, Johnson Lau via bitcoin-dev wrote:\n> Thanks for Peter Todd\u2019s detailed report:\n> https://petertodd.org/2016/segwit-consensus-critical-code-review\n> \n> I have the following response.\n> \n> >Since the reserve value is only a single, 32-byte value, we\u2019re setting ourselves up for the same problem again7.\n> \n> Please note that unlimited space has been reserved after the witness commitment:\n> \n>   block.vtx[0].vout[o].scriptPubKey.size() >= 38\n> \n>  Which means anything after 38 bytes has no consensus meaning. Any new consensus critical commitments/metadata could be put there. Anyway, there is no efficient way to add a new commitment with softfork.\n\nSure - equally you could say you could add additional commitments as other\ncoinbase txouts.\n\nMy point is that the extensible commitment - specifically the thing described\nin the BIP - can't be easily used for the purpose of extending segwit due to a\ndesign flaw.\n\n> > the fact that we do this has a rather odd result: a transaction spending a witness output with an unknown version is valid even if the transaction doesn\u2019t have any witnesses!\n> \n> I don\u2019t see any reason to have such check. We simply leave unknown witness program as any-one-can-spend without looking at the witness, as described in BIP141.\n\nIt will lead to a special case in code that does things with witness\ntransactions, as we can spend a witness output without a witness.\n\n> > Bizzarely segwit has an additonal pay-to-witness-pubkey-hashP2WPKH that lets you use a 160-bit (20 byte) commitment\u2026\u2026\n> \n> Since ~90% of current transactions are P2PKH, we expect many people will keep using this type of transaction in the future. P2WPKH gives the same level of security as P2PKH, and smaller scriptPubKey.\n> \n> >give users the option instead to choose to accept the less secure 160-bit commitment if their use-case doesn\u2019t need the full 256-bit security level\n> \n> This is actually discussed on the mailing list. P2WSH with multi-sig is subject to birthday attack, and therefore 256-bit is used to provide 128-bit security. P2WPKH is used as single sig and therefore 160-bit is enough.\n\nI'm aware of that - there are many P2SH scripts where birthday attacks are not\nan issue. In fact, _most_ usage of P2SH right now - multifactor wallets -\ndoesn't have a birthday attack problem.\n\n> >Secondly, if you are going to give a 160-bit commitment option, you don\u2019t need the extra level of indirection in the P2SH case: just make the segwit redeemScript be: <version> <serialized witness script>\n> \n> Something wrong here? In P2WPKH, the witness is <sig> <pubkey>\n\nHuh? That still another level of indirection.\n\nAnyway, the right argument against my proposal for pay-to-pubkey-hash\nfunctionality, is that taking into account the witness discount, my proposal is\nslightly less efficient. In P2WPKH in P2SH the witness program in the\nredeemScript is 22 bytes:\n\n    <1-byte version> <1-byte length> <20 byte pubkey hash>\n\nAnd the witness len(sig) + 34 bytes:\n\n    <sig> <1 byte length> <33 bytes pubkey>\n\nTaking into account the discount, that results in 22*4 + 34 + len(sig) = 122 bytes + len(sig)\n\nMy proposal would have a 37 byte redeemScript:\n\n    <1-byte version> <1-byte witness script length> {<1-byte pubkey length> <33 byte pubkey> OP_CHECKSIG}\n\nand a len(sig) length witness:\n\n    <sig>\n\nTaking into account the discount, that results in 37*4 + len(sig) = 148 bytes + len(sig)\nMeanwhile for any more complex script, you'd certainly want to use the 256-bit\nhash instead, due to the witness discount.\n\nThis suggests an obvious alternative: let users choose to use 160-bit security,\nand make 256-bit and 160-bit witness programm commitments just be different\nhash functions. P2PKH functionality implemented this way would be a single\nextra byte vs. special-casing it.\n\nThus you could summarize the argument for the P2PKH special case as \"We don't\nwant to make it possible to use 160-bit commitments for multisig, which _might_\nneed 256-bit security. But we do want to special-case pubkeys to save a few\nbytes.\"\n\n> >The only downside is the serialized witness script is constrained to 520 bytes max\n> \n> 520 is the original limit. BIP141 tries to mimic the existing behaviour as much as possible. Anyway, normally nothing in the current scripts should use a push with more than 75 bytes\n\nNo, you're quite confused at my point: the witness script is otherwise\nconstrained to 10,000 bytes, as the first item in the witness is special-cased\nfor version 0 to be not be subject to the 520 byte rule.\n\n> >we haven\u2019t explicitly ensured that signatures for the new signature hash can\u2019t be reused for the old signature hash\n> \n> How could that be? That\u2019d be a hash collision.\n\nNope. The problem is it might not be a hash collission, if the actual bytes\nsigned can be interpreted in two different ways, by different types of\nsignature hashes.\n\nThis is the same reason the signmessage functionality prepends the message\nbeing signed with the \"Bitcoin Signed Message:\\n\" magic string.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160702/3df077cb/attachment.sig>"
            },
            {
                "author": "Johnson Lau",
                "date": "2016-07-02T19:20:42",
                "message_text_only": "> \n>>> the fact that we do this has a rather odd result: a transaction spending a witness output with an unknown version is valid even if the transaction doesn\u2019t have any witnesses!\n>> \n>> I don\u2019t see any reason to have such check. We simply leave unknown witness program as any-one-can-spend without looking at the witness, as described in BIP141.\n> \n> It will lead to a special case in code that does things with witness\n> transactions, as we can spend a witness output without a witness.\n\nIt is trivial to softfork a new rule to require the witness must not be empty for a witness output. However, does it really make the code simpler?\n> \n> Thus you could summarize the argument for the P2PKH special case as \"We don't\n> want to make it possible to use 160-bit commitments for multisig, which _might_\n> need 256-bit security. But we do want to special-case pubkeys to save a few\n> bytes.\u201d\n\nActually I would like to see even shorter hash and pubkey to be used. Storing 1 BTC for a few months does not really require the security level of P2PKH.\n\n> \n>>> we haven\u2019t explicitly ensured that signatures for the new signature hash can\u2019t be reused for the old signature hash\n>> \n>> How could that be? That\u2019d be a hash collision.\n> \n> Nope. The problem is it might not be a hash collission, if the actual bytes\n> signed can be interpreted in two different ways, by different types of\n> signature hashes.\n> \n> This is the same reason the signmessage functionality prepends the message\n> being signed with the \"Bitcoin Signed Message:\\n\" magic string.\n> \n\nIn BIP143 sig, first 4 bytes is nVersion, and the next 32 bytes (hashPrevouts) is a hash of all prevouts. (in the case of ANYONECANPAY, the bytes following would be zero, as you proposed)\n\nIn the original sig, first 4 bytes in nVersion, next 4 bytes is number of inputs, and the next 32 bytes is a txid.\n\nFor a signature to be valid for both schemes, the last 28 bytes of the hashPrevouts must also be the first 28 bytes of a valid txid. This is already impossible. And this is just one of the many collisions required. In such case SHA256 would be insecure and adding a zero after the nVersion as you suggest would not be helpful at all.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 671 bytes\nDesc: Message signed with OpenPGP using GPGMail\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160703/08937db5/attachment.sig>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-07-04T23:27:15",
                "message_text_only": "On Sun, Jul 03, 2016 at 03:20:42AM +0800, Johnson Lau wrote:\n> >>> the fact that we do this has a rather odd result: a transaction spending a witness output with an unknown version is valid even if the transaction doesn\u2019t have any witnesses!\n> >> \n> >> I don\u2019t see any reason to have such check. We simply leave unknown witness program as any-one-can-spend without looking at the witness, as described in BIP141.\n> > \n> > It will lead to a special case in code that does things with witness\n> > transactions, as we can spend a witness output without a witness.\n> \n> It is trivial to softfork a new rule to require the witness must not be empty for a witness output. However, does it really make the code simpler?\n\nThe Bitcoin Core codebase, no, but it does reduce the number of special cases\nother codebases have to contend with.\n\nProbably not worth changing now, but it was I think a weird design choice to\nmake.\n\n> > Thus you could summarize the argument for the P2PKH special case as \"We don't\n> > want to make it possible to use 160-bit commitments for multisig, which _might_\n> > need 256-bit security. But we do want to special-case pubkeys to save a few\n> > bytes.\u201d\n> \n> Actually I would like to see even shorter hash and pubkey to be used. Storing 1 BTC for a few months does not really require the security level of P2PKH.\n\nHow short? 128 bits? 80 bits? 64 bits?\n\nIt's hard to know what's the point where you're going to risk massive losses\ndue to theft... and as we've seen with the DAO, those kinds of losses can lead\nto very undesirable pressure for devs to act as a central authority and\nintervene.\n\n> >>> we haven\u2019t explicitly ensured that signatures for the new signature hash can\u2019t be reused for the old signature hash\n> >> \n> >> How could that be? That\u2019d be a hash collision.\n> > \n> > Nope. The problem is it might not be a hash collission, if the actual bytes\n> > signed can be interpreted in two different ways, by different types of\n> > signature hashes.\n> > \n> > This is the same reason the signmessage functionality prepends the message\n> > being signed with the \"Bitcoin Signed Message:\\n\" magic string.\n> > \n> \n> In BIP143 sig, first 4 bytes is nVersion, and the next 32 bytes (hashPrevouts) is a hash of all prevouts. (in the case of ANYONECANPAY, the bytes following would be zero, as you proposed)\n> \n> In the original sig, first 4 bytes in nVersion, next 4 bytes is number of inputs, and the next 32 bytes is a txid.\n> \n> For a signature to be valid for both schemes, the last 28 bytes of the hashPrevouts must also be the first 28 bytes of a valid txid. This is already impossible. And this is just one of the many collisions required. In such case SHA256 would be insecure and adding a zero after the nVersion as you suggest would not be helpful at all.\n\nWhy isn't this carefully documented in the BIPs then?\n\nAgain, as I said in my summary:\n\n    In a number of places we either have a belt, or suspenders, when given the\n    importance of this code we\u2019d rather have both a belt and suspenders.\n\nTagged hashing is an excellent way to absolutely sure that signatures can't be\nreused in different contexts; if it happens to be overkill in a specific\ncontext, the overhead of hashing another few bytes is trivial; the gain of\nbeing absolutely sure you haven't missed a vulnerability can't be easily\ndismissed.\n\nEqually, I think in most cases simply XORing the digest obtained by hashing\nwith a magic tag prior to using it (e.g. by signing it) should be sufficient\nfor signature applications, and the overhead of doing that is ~zero.\nEssentially you can think of the magic tag that's XORed with the raw digest as\nmaking clear the intent of the signature: \"this is why I think I'm signing this\ndigest\"\n\nHowever, the XOR option does have one potentially big downside in other\ncontexts, like general use in committed data structures: it's incompatible with\ntimestamping schemes like OpenTimestamps that rely on all operations being\ncryptographically secure.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160704/8235c4f2/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Code Review: The Consensus Critical Parts of Segwit by Peter Todd",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau",
                "Peter Todd"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 12155
        }
    },
    {
        "title": "[bitcoin-dev] BIP Number Request: Open Asset",
        "thread_messages": [
            {
                "author": "Peter Todd",
                "date": "2016-07-05T17:46:36",
                "message_text_only": "On Thu, May 26, 2016 at 03:53:04AM +0000, Luke Dashjr via bitcoin-dev wrote:\n> On Thursday, May 26, 2016 2:50:26 AM Nicolas Dorier via bitcoin-dev wrote:\n> >   Author: Flavien Charlon <flavien at charlon.net>\n\nWhat's the status of this BIP? Will it be assigned?\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160705/bf9a3ca7/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-07-06T01:22:19",
                "message_text_only": "On Tuesday, July 05, 2016 5:46:36 PM Peter Todd wrote:\n> On Thu, May 26, 2016 at 03:53:04AM +0000, Luke Dashjr via bitcoin-dev wrote:\n> > On Thursday, May 26, 2016 2:50:26 AM Nicolas Dorier via bitcoin-dev wrote:\n> > >   Author: Flavien Charlon <flavien at charlon.net>\n> \n> What's the status of this BIP? Will it be assigned?\n\nI was waiting for clarification on the Author thing, but Nicholas hasn't \nresponded yet. I am unaware of any reason NOT to assign it, and there appear \nto be no objections, so let's call it BIP 160.\n\nLuke"
            },
            {
                "author": "James MacWhyte",
                "date": "2016-07-06T02:14:57",
                "message_text_only": "I'm curious to hear the answers to the questions Luke asked earlier. I also\nread through the documentation and wasn't convinced it was thought out well\nenough to actually build something on top of, but there's no reason it\ncan't get a number as a work-in-progress.\n\nI hope it does continue to get worked on, though. The lack of response or\ndiscussion worries me that it might become an abandoned project.\n\nOn Tue, Jul 5, 2016, 18:32 Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Tuesday, July 05, 2016 5:46:36 PM Peter Todd wrote:\n> > On Thu, May 26, 2016 at 03:53:04AM +0000, Luke Dashjr via bitcoin-dev\n> wrote:\n> > > On Thursday, May 26, 2016 2:50:26 AM Nicolas Dorier via bitcoin-dev\n> wrote:\n> > > >   Author: Flavien Charlon <flavien at charlon.net>\n> >\n> > What's the status of this BIP? Will it be assigned?\n>\n> I was waiting for clarification on the Author thing, but Nicholas hasn't\n> responded yet. I am unaware of any reason NOT to assign it, and there\n> appear\n> to be no objections, so let's call it BIP 160.\n>\n> Luke\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160706/bbb89dc6/attachment.html>"
            },
            {
                "author": "Alex Mizrahi",
                "date": "2016-07-06T06:49:00",
                "message_text_only": "> I'm curious to hear the answers to the questions Luke asked earlier. I\n> also read through the documentation and wasn't convinced it was thought out\n> well enough to actually build something on top of,\n>\nThere are many colored coin protocols in use. OpenAssets is probably the\nmost popular one, but it has many critical flaws IMHO.\nhttps://github.com/bitcoinx/colored-coin-tools/wiki/OpenAssets-deficiencies\n\n\n> but there's no reason it can't get a number as a work-in-progress.\n>\nThe protocol is not a work-in-progress, it is already in use, you cannot\nchange it without breaking stuff.\nThe doc can be improved, though. There is a lot of fluff but the actual\nimportant stuff gets just few ambiguous sentences.\n\nI hope it does continue to get worked on, though. The lack of response or\n> discussion worries me that it might become an abandoned project.\n>\n\nThe original author, Flavien, have abandoned it, he now does a private\nblockchain thing, OpenChain.\nThere are others who still use OpenAssets, e.g. Nicolas, but the protocol\ncan't be changed.\n\nThere are other colored coin protocols in existence/in development, though.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160706/154adabd/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Number Request: Open Asset",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "James MacWhyte",
                "Luke Dashjr",
                "Peter Todd",
                "Alex Mizrahi"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 3873
        }
    },
    {
        "title": "[bitcoin-dev] Status updates for BIP 9, 68, 112, and 113",
        "thread_messages": [
            {
                "author": "Luke Dashjr",
                "date": "2016-07-15T16:08:51",
                "message_text_only": "Daniel Cousens opened the issue a few weeks ago, that BIP 9 should progress to \nAccepted stage. However, as an informational BIP, it is not entirely clear on \nwhether it falls in the Draft/Accepted/Final classification of proposals \nrequiring implementation, or the Draft/Active classification like process \nBIPs. Background of this discussion is at:\n    https://github.com/bitcoin/bips/pull/413\n(Discussion on the GitHub BIPs repo is *NOT* recommended, hence bringing this \ntopic to the mailing list)\n\nReviewing the criteria for status changes, my opinion is that:\n- BIPs 68, 112, 113, and 141 are themselves implementations of BIP 9\n-- therefore, BIP 9 falls under the Draft/Accepted/Final class\n- BIPs 68, 112, and 113 have been deployed to the network successfully\n-- therefore, BIP 9 has satisfied the conditions of not only Accepted status,\n   but also Final status\n-- therefore, BIPs 68, 112, and 113 also ought to be Final status\n\nIf there are no objections, I plan to update the status to Final for BIPs 9, \n68, 112, and 113 in one month. Since all four BIPs are currently Draft, I also \nneed at least one author from each BIP to sign-off on promoting them to (and \nbeyond) Accepted.\n\nBIP   9: Pieter Wuille <pieter.wuille at gmail.com>\n         Peter Todd <pete at petertodd.org>\n         Greg Maxwell <greg at xiph.org>\n         Rusty Russell <rusty at rustcorp.com.au>\n\nBIP  68: Mark Friedenbach <mark at friedenbach.org>\n         BtcDrak <btcdrak at gmail.com>\n         Nicolas Dorier <nicolas.dorier at gmail.com>\n         kinoshitajona <kinoshitajona at gmail.com>\n\nBIP 112: BtcDrak <btcdrak at gmail.com>\n         Mark Friedenbach <mark at friedenbach.org>\n         Eric Lombrozo <elombrozo at gmail.com>\n\nBIP 113: Thomas Kerin <me at thomaskerin.io>\n         Mark Friedenbach <mark at friedenbach.org>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-07-15T16:31:12",
                "message_text_only": "On Fri, Jul 15, 2016 at 04:08:51PM +0000, Luke Dashjr via bitcoin-dev wrote:\n> Daniel Cousens opened the issue a few weeks ago, that BIP 9 should progress to \n> Accepted stage. However, as an informational BIP, it is not entirely clear on \n> whether it falls in the Draft/Accepted/Final classification of proposals \n> requiring implementation, or the Draft/Active classification like process \n> BIPs. Background of this discussion is at:\n>     https://github.com/bitcoin/bips/pull/413\n> (Discussion on the GitHub BIPs repo is *NOT* recommended, hence bringing this \n> topic to the mailing list)\n\nAs of writing the text of BIP68 says:\n\n    'This BIP is to be deployed by \"versionbits\" BIP9 using bit 0.'\n\nEssentially including BIP9 as part of the BIP68 standard; BIP68 could have\nequally been written by including some or all of the text of BIP9. If it had\ndone that, that text would be part of a \"Standard BIP\" rather than\n\"Informational BIP\", thus I'll argue that BIP9 should also be a \"Standard BIP\"\n\nAlso, note that if we ever modified BIP9, we'd most likely do so with a new\nBIP, and in soft-forks using that new standard, would refer to the new BIP #.\n\n> Reviewing the criteria for status changes, my opinion is that:\n> - BIPs 68, 112, 113, and 141 are themselves implementations of BIP 9\n> -- therefore, BIP 9 falls under the Draft/Accepted/Final class\n> - BIPs 68, 112, and 113 have been deployed to the network successfully\n> -- therefore, BIP 9 has satisfied the conditions of not only Accepted status,\n>    but also Final status\n> -- therefore, BIPs 68, 112, and 113 also ought to be Final status\n> \n> If there are no objections, I plan to update the status to Final for BIPs 9, \n> 68, 112, and 113 in one month. Since all four BIPs are currently Draft, I also \n> need at least one author from each BIP to sign-off on promoting them to (and \n> beyond) Accepted.\n> \n> BIP   9: Pieter Wuille <pieter.wuille at gmail.com>\n>          Peter Todd <pete at petertodd.org>\n>          Greg Maxwell <greg at xiph.org>\n>          Rusty Russell <rusty at rustcorp.com.au>\n\nACK \"Final\" status.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160715/6424d10a/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Status updates for BIP 9, 68, 112, and 113",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Peter Todd"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4239
        }
    },
    {
        "title": "[bitcoin-dev] Merkle trees and mountain ranges",
        "thread_messages": [
            {
                "author": "Bram Cohen",
                "date": "2016-07-15T23:00:57",
                "message_text_only": "On Sat, Jun 18, 2016 at 4:01 PM, Peter Todd <pete at petertodd.org> wrote:\n\n>\n>\nHave you seen how BLAKE2 omits padding when the data to be hashed happens\n> to be\n> exactly one block in size? It's significantly faster than SHA256, and\n> that's a\n> standard part of the algorithm already.\n>\n\nThat's very convenient! I didn't know it, but had 'look up how blake2 does\npadding' in my list of stuff to do. I'm leaning heavily towards using\nblake2b at this point, at least for internal hashing.\n\n\n>\n> > At the root there's a branch block. It consists of all nodes up to some\n> > fixed depth - let's say 12 - with that depth set so that it roughly fits\n> > within a single memory page. Branch blocks are arranged with the nodes in\n> > fixed position defined by the prefix they correspond to, and the\n> terminals\n> > have outpointers to other blocks. Because they're all clustered\n> together, a\n> > lookup or update will only require a single\n>\n> A single....?\n>\n\nOkay, I've figured out the root cause of general confusion here. It's\nmostly my fault.\n\nThere are a few different media on which data can be stored, with different\nproperties in terms of how long it takes to retrieve data from them, and\nhow much of a readahead they typically have. I was misreading the l2 cache\nsize as the main memory readahead amount, which is... probably wrong? The\nreadahead properties of memory aren't well documented and apparently vary a\nlot. On SSDs it typically pulls down a kilobyte at once and they call them\npages, hence my use of that term above. But since my real point is that my\nimplementation should act as a silver bullet which can have acceptable\nperformance even on extremely bad devices, I'll give an analysis of how\nwell it works when everything is stored on a regular spinning hard drive.\n\nLet's say you're storing 100 million items, which will fit within 10\ngigabytes. If you set the block depths to about 10 bits they'll be about\n32K, and if you set the size of leaf blocks to be about the same then\nmemory efficiency will be good because the leaf blocks will store twigs of\nabout 2^7 in size while having 2^10 space so they'll fit reasonably. Almost\neverything will be three blocks from root, so updates will generally\nrequire two disk seeks (plus one more for a write but those are generally\nfaster because they get batched.)\n\nFor latency numbers, I'm going off these:\nhttps://gist.github.com/jboner/2841832\n\nIf the blockchain is very full of simple transactions and a disk seek takes\n15 milliseconds, then going with the assumption that a block is about 600\nseconds and the blockchain can handle 4 transactions per second and each of\nthem is 3 updates (one utxo spent plus two new ones created) that's 15 *\n600 * 4 * 3 * 2 milliseconds per block, or about 200 seconds per block, so\nif the uxto roots trail by a few blocks even a ludicrously underpowered\nnode could keep up.\n\nOn an SSD keeping up is completely trivial, the problem becomes one of how\nquickly you can validate an entire blockchain history. There a read takes\nabout 0.15 milliseconds and you have to do 5 of them instead of 2 because\nthe natural memory block size is 4k, so it's about 1 millisecond per\nupdate, or 600 * 4 * 3 total time for each block, which is about 7 seconds.\nThat's large enough that making the utxo root trail by two blocks is still\na good idea, but small enough that it isn't a big factor in the cost of\nrunning a node. It's enough that validating a complete block history might\ntake a while though, and even validating just the last year would take a\nfew days. This is very conservative and it's assuming that *everything* is\nkept on an SSD though. If the numbers work better and a few layers are kept\nin regular memory validating a whole year of history might only take a few\nhours.\n\nHopefully that all makes a fairly good case that raw merkle tree utxo root\ntrailing by a few blocks is a viable strategy. The data structures in the\nMMR proposal are fairly complicated and the analysis of them talks in\nsomewhat vague terms about things being fast and slow. A similar analysis\nof the MMR proposal specifying storage media and expectations of latency\nnumbers would clarify the reasoning a lot.\n\n(By the way, sorry for the slow response - I got preempted by a bunch of\nother work duties.)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160715/1202d694/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Merkle trees and mountain ranges",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bram Cohen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4458
        }
    },
    {
        "title": "[bitcoin-dev] BIP draft: HTLC transactions",
        "thread_messages": [
            {
                "author": "Sean Bowe",
                "date": "2016-07-20T04:35:39",
                "message_text_only": "I'm requesting feedback for Hash Time-Locked Contract (HTLC) transactions\nin Bitcoin.\n\nHTLC transactions allow you to pay for the preimage of a hash. CSV/CLTV can\nbe used to recover your funds if the other party is not cooperative. These\nscripts take the following general form:\n\n    [HASHOP] <digest> OP_EQUAL\n    OP_IF\n        <seller pubkey>\n    OP_ELSE\n        <num> [TIMEOUTOP] OP_DROP <buyer pubkey>\n    OP_ENDIF\n    OP_CHECKSIG\n\nThese transactions are useful for both the Lightning network and in\nzero-knowledge contingent payments. This very script (using CLTV and\nSHA256) was used as part of our \"pay-to-sudoku\" ZKCP demo earlier this\nyear: https://github.com/zcash/pay-to-sudoku\n\nMembers of the community have expressed the desire for a BIP to submitted\nin coordination with changes to Bitcoin Core that support these\ntransactions in the wallet.\n\nPlease review my draft BIP here:\nhttps://gist.github.com/ebfull/8306903041d46e4119a39442f72a3741\n\nAn implementation is being worked on here:\nhttps://github.com/bitcoin/bitcoin/pull/7601\n\nThanks!\n\nSean Bowe\nZcash\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160719/2976c883/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2016-07-20T05:46:54",
                "message_text_only": "On Tue, Jul 19, 2016 at 10:35:39PM -0600, Sean Bowe via bitcoin-dev wrote:\n> I'm requesting feedback for Hash Time-Locked Contract (HTLC) transactions\n> in Bitcoin.\n> \n> HTLC transactions allow you to pay for the preimage of a hash. CSV/CLTV can\n> be used to recover your funds if the other party is not cooperative. These\n> scripts take the following general form:\n> \n>     [HASHOP] <digest> OP_EQUAL\n>     OP_IF\n>         <seller pubkey>\n>     OP_ELSE\n>         <num> [TIMEOUTOP] OP_DROP <buyer pubkey>\n>     OP_ENDIF\n>     OP_CHECKSIG\n\nNote that because you're hashing the top item on the stack regardless\nscriptSig's that satisfy HTLC's are malleable: that top stack item can be\nchanged anything in the digest-not-provided case and the script still passes.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160720/87cd5733/attachment.sig>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-07-20T06:17:39",
                "message_text_only": "On Wednesday, July 20, 2016 5:46:54 AM Peter Todd via bitcoin-dev wrote:\n> On Tue, Jul 19, 2016 at 10:35:39PM -0600, Sean Bowe via bitcoin-dev wrote:\n> > I'm requesting feedback for Hash Time-Locked Contract (HTLC) transactions\n> > in Bitcoin.\n> > \n> > HTLC transactions allow you to pay for the preimage of a hash. CSV/CLTV\n> > can be used to recover your funds if the other party is not cooperative.\n> > These\n> > \n> > scripts take the following general form:\n> >     [HASHOP] <digest> OP_EQUAL\n> >     OP_IF\n> >     \n> >         <seller pubkey>\n> >     \n> >     OP_ELSE\n> >     \n> >         <num> [TIMEOUTOP] OP_DROP <buyer pubkey>\n> >     \n> >     OP_ENDIF\n> >     OP_CHECKSIG\n> \n> Note that because you're hashing the top item on the stack regardless\n> scriptSig's that satisfy HTLC's are malleable: that top stack item can be\n> changed anything in the digest-not-provided case and the script still\n> passes.\n\nOP_SIZE\nOP_IF\n  [HASHOP] <digest> OP_EQUALVERIFY\n  <seller pubkey>\nOP_ELSE\n  <num> [TIMEOUTOP]\n  <buyer pubkey>\nOP_ENDIF\nOP_CHECKSIG"
            }
        ],
        "thread_summary": {
            "title": "BIP draft: HTLC transactions",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Luke Dashjr",
                "Peter Todd",
                "Sean Bowe"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3389
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.13.0 release candidate 1 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-07-20T08:07:02",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBinaries for bitcoin Core version 0.13.0rc1 are available from:\n\n    https://bitcoin.org/bin/bitcoin-core-0.13.0/test.rc1/\n\nSource code can be found on github under the signed tag\n\n    https://github.com/bitcoin/bitcoin/tree/v0.13.0rc1\n\nThis is a release candidate for a new major version release, bringing new\nfeatures, bug fixes, as well as other improvements.\n\nPreliminary release notes for the release can be found at\n\n    https://github.com/bitcoin/bitcoin/blob/0.13/doc/release-notes.md\n\nRelease candidates are test versions for releases. When no critical problems\nare found, this release candidate will be tagged as 0.13.0.\n\nPlease report bugs using the issue tracker at github:\n\n    https://github.com/bitcoin/bitcoin/issues\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXjzAsAAoJEHSBCwEjRsmmv48IALAQw9GTDt63ST9dWBdlB1uz\n9JOxIZLsd/u9lcBUMzUoLRsdYVu/OTJKoDDD1vE6YmtO+FLEYJgqKjkaIE1AzxD+\nkwKP4KemZEsbk/e+eywZB1MKHvLyYY/W31k5kjQm8iDNNQs+1jJEfvgaZzdLBA2L\nvKRPYg7P+maBWa7m6LjoUZFvjXfZ6eu80QjsH6ujM3aObQOmcAM1bgOCDH7sqzH8\nckgyUJlSWzJyTgdKEUapMoHdCiHyb7axZHAICIsOR7DPVsLc1oiAmxAfyKJvKIhm\n0hclCziCu6I38dVqbAFcuwHaTD/dgyN92lanoB67XxExY1y+IP1RW5qc2Bt+wew=\n=RJAl\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.13.0 release candidate 1 available",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1255
        }
    },
    {
        "title": "[bitcoin-dev] Reasons to add sync flags to Bitcoin",
        "thread_messages": [
            {
                "author": "Moral Agent",
                "date": "2016-07-26T12:47:25",
                "message_text_only": "I posted this to /r/bitcoin yesterday but it got minimal comments. One uses\nsuggested I try the mailing list so here it is:\n\nThe idea presented here could have the following benefits:\n\n1. Improve mining decentralization\n2. Reduce variance in mining profitability\n3. Reduce or eliminate SPV mined blocks\n4. Reduce or eliminate empty blocks, smoothing out resource usage\n5. Reduce or eliminate the latency bottleneck on throughput\n6. Make transaction stuffing by miners be either obvious or costly\n7. Gives miners something to do while they wait for attractive transactions\nto appear\n8. Can be easily done with a soft fork\n\n#Basic idea:\n\nIdeally, all miners would begin hashing the next block at exactly the same\ntime. Miners with a head start are more profitable, and the techniques that\nhelp miners receive and validate blocks quickly create centralization\npressure.\n\nWhat if there was something that acted like the starting flag at a race,\nwhich could suddenly wave and cause all of the miners to simultaneously\nbegin hashing the next block?\n\n#Implementation:\n\nLet a sync flag be a message consisting of:\n\n1. Hash of the previous block.\n2. Bitcoin address\n3. Nonce\n\nThis tiny message could propagate through the network at maximum speed. If\nminers had to include the hash of this flag in the next block, then all\nminers wait for this flag, and when it suddenly spread through the network,\nall miners could simultaneously begin hashing the next block.\n\nThe sync flag should not be produced too quickly. You want to give everyone\nenough time to be ready to hash the next block. Let's say that the hash of\nthe sync flag is a proof of work that is targeted for 2 minutes.\n\nTo fund this proof of work, the protocol is modified to demand that the\nblock produced 10 blocks after the sync flag must allocate 25% of the block\nreward to the address published by the sync flag. In this way, sync flags\nare produced in 2 minutes, and blocks are produced in 8 minutes, with 10\nminutes total.\n\n\nIllustration 1: https://s32.postimg.org/wzg0hs8lx/sync_flag.png)\n\nIllustration 2: https://s32.postimg.org/vc5y9yz4l/sync_flag2.png\n\n\n#Explanation of reasons:\n\n**Improve mining decentralization**\n\nOne factor driving centralization is the imperative miners have to achieve\nlow latency in receiving and validating blocks. To achieve low latency, it\nhelps a lot if you have expensive low-latency internet connections, curated\nnetwork topologies, and large pools that have a plausible chance of finding\nconsecutive blocks. If miners are expected (or forced) to validate a block\nprior to mining on top of it, the rational end game would be to outsource\nthe validation step to a trusted third party specialist who can choose\noptimal locations on the globe to serve their (multiple?) mining pool\nclients. These are all less decentralized than the mining situation Satoshi\nand others imagined.\n\n**Reduce variance in mining revenue**\n\nCurrently, there are about 144 opportunities per day for a pool or solo\nminer to see any revenue at all. With sync flags, that number doubles to\n288. Sync flags are only worth 25% of what a block is worth, but this still\nrepresents a significant reduction in variance. This variance is one factor\ncausing solo miners to group into pools, and large pools to be more\nattractive than small pools.\n\n**Reduce or eliminate SPV mined blocks**\n\nOne way miners have sought to make\nfull-block-transmission-and-validation-latency irrelevant has been through\n\"SPV\" mining or \"Head-first\" mining. There is some evidence that these\ntechniques may be widely used, and that badgering the miners about it is an\nineffective strategy to stop them.\n\nIn SPV mining, a miner would simply accept any block header that shows the\ncorrect proof of work. All other validation is entrusted to other miners.\nThis practice is quite dangerous as the SPV miners can wander off on some\ninvalid chain, taking SPV nodes with them. If this occurs during a soft\nfork, these blind miners can also fool unupgraded fully validating nodes\ninto following them.\n\n\"Head-first\" mining means that miners start hashing as soon as they receive\nthe block header with the correct POW, but they simultaneously validate the\nblock, and abandon it if is not valid. I consider this to be pretty safe,\nas it strictly limits the length of an invalid chain that can result from\nmining without validating. However, \"Head-first\" mining can plausibly\ngenerate 2 or 3 confirmations of an invalid block. It would be nice if such\nconfirmations did not happen.\n\nThe sync flag technique is similar to head-first mining, but rather than\nhashing the next block while they wait for transmission and validation of\nthe prior block, they hash the sync flag. Nodes can differentiate between\nsync flags and blocks, and can ignore sync flags when counting\nconfirmations.\n\n**Reduce or eliminate empty blocks, smoothing out resource usage**\n\nEmpty blocks are another consequence of SPV or Headfirst mining, because\nthe miner cannot safely include any transactions in the block they are\nhashing until they have validated the prior block. By delaying the start of\nhashing the next block until after validation, miners would not have this\nreason to mine empty blocks.\n\n**Reduce or eliminate the latency bottleneck on throughput**\n\nCentralization pressure due to latency issues has been a major\npreoccupation over the last year. If latency mattered much less, it could\nrepresent a scalability improvement that could enable higher throughput.\n\n**Make transaction stuffing by miners be either obvious or costly**\n\nCurrently, the entire block reward goes to the miner who mines it. One\nunfortunate consequence of this is that it does not cost the miner anything\nto covertly stuff the block with transactions. These transactions would pay\nfees and be indistinguishable from ordinary transactions, but the fees are\npaid by the miner and then immediately returned to the miner.\n\nWith sync flags, the miner must share these transaction fees with the\naddress contained in the sync flag 10 blocks prior. This means that if the\nminer gives the transactions a normal looking fee, they will incur a cost\nthat will be paid to the sync flag. If the miner wants to avoid this, they\nmust give their stuffing transactions a zero fee, which provides evidence\nthat they are stuffing.\n\nAlso, when miners stuff with transactions using a zero fee, they cannot\nmanipulate the perception of how much fee it takes to get into a block.\n\nNote that miners could still try to covertly stuff blocks that will pay a\nsync flag that they themselves created. if this is a big concern, it can be\naddressed by forcing blocks to pay multiple sync flags.\n\n**Gives miners something to do while they wait for attractive transactions\nto appear**\n\n>From the Montreal scaling workshop last year, we have [this talk](\nhttps://scalingbitcoin.org/montreal2015/presentations/Day1/13-miles-carlsten-Mind-the-Gap.pdf)\nwhich worried that as the block subsidy reduced and transactions became a\nmore important fraction of miner revenue, it would be rational for miners\nto turn off their mining equipment for a \"gap\" phase after a block is\nfound, to allow time to pass as more lucrative transactions entered the\nmempool.\n\nI don't know whether this will actually happen. The presence of a suitable\nbacklog of transactions would help prevent this dynamic from emerging. But\nif such idling behavior was the optima mining strategy, it could create a\nserious vulnerability. Idle hands are the devil's workshop as the saying\ngoes, and idle miners represent a pool of inert hashpower that is available\nto rent for all kinds of destabilizing purposes. It would be better to put\nthose miners to profitable work mining a sync flag while they wait.\n\nAlso, this creates a more efficient price discovery mechanism for\ntransactions, because you allow transactions paying high fees time to\narrive to the marketplace, rather than take whatever anyone is offering\nbecause all the \"good\" transactions got gobbled up in the prior block.\n\n**Can be easily done with a soft fork**\n\nAlthough a hard fork would be more efficient, sync flags could be easily\nimplemented using a soft fork by introducing the following rule:\n\nEvery block must include a transaction which pays 25% of the block reward\nto the address given by the 10th previous sync flag, and commits to the\nhash of the 1st previous sync flag.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160726/28026960/attachment.html>"
            },
            {
                "author": "Tom",
                "date": "2016-07-26T13:51:56",
                "message_text_only": "> #Basic idea:\n> \n> Ideally, all miners would begin hashing the next block at exactly the same\n> time. Miners with a head start are more profitable, and the techniques that\n> help miners receive and validate blocks quickly create centralization\n> pressure.\n> \n> What if there was something that acted like the starting flag at a race,\n> which could suddenly wave and cause all of the miners to simultaneously\n> begin hashing the next block?\n> \n> #Implementation:\n> \n> Let a sync flag be a message consisting of:\n> \n> 1. Hash of the previous block.\n> 2. Bitcoin address\n> 3. Nonce\n> \n> This tiny message could propagate through the network at maximum speed. If\n> miners had to include the hash of this flag in the next block, then all\n> miners wait for this flag, and when it suddenly spread through the network,\n> all miners could simultaneously begin hashing the next block.\n\nWhat you describe in this part of your message can be done with no forks \nwhatsoever and I think that this is enough. Don't really see the reason for \nany change in funding.\n\nThe idea of sending out a block header is essentially what I called \n\"optimistic mining\" and has been described in more detail in my blog here;\nhttp://zander.github.io/posts/Innovation%20-%20OnlineScaling/\n\nThe video explains with graphics too...\n\nYou may find this interesting :)"
            },
            {
                "author": "Erik Aronesty",
                "date": "2016-07-26T17:27:22",
                "message_text_only": "- Flags will be mined selfishly, and not published until the advantage\n   gained from withholding is less than the mining reward.  This effect may\n   kill the decentralization features, since big miners will be the only ones\n   that can selfish-mine flags.  Indeed, collusion would be encouraged... just\n   ship the flag to the miners you do business with, and no one else.   At the\n   expense of loss of flag revenue, your in-group would gain a massive\n   advantage in main-chain mining.\n\n\nOn Tue, Jul 26, 2016 at 9:51 AM, Tom via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> > #Basic idea:\n> >\n> > Ideally, all miners would begin hashing the next block at exactly the\n> same\n> > time. Miners with a head start are more profitable, and the techniques\n> that\n> > help miners receive and validate blocks quickly create centralization\n> > pressure.\n> >\n> > What if there was something that acted like the starting flag at a race,\n> > which could suddenly wave and cause all of the miners to simultaneously\n> > begin hashing the next block?\n> >\n> > #Implementation:\n> >\n> > Let a sync flag be a message consisting of:\n> >\n> > 1. Hash of the previous block.\n> > 2. Bitcoin address\n> > 3. Nonce\n> >\n> > This tiny message could propagate through the network at maximum speed.\n> If\n> > miners had to include the hash of this flag in the next block, then all\n> > miners wait for this flag, and when it suddenly spread through the\n> network,\n> > all miners could simultaneously begin hashing the next block.\n>\n> What you describe in this part of your message can be done with no forks\n> whatsoever and I think that this is enough. Don't really see the reason for\n> any change in funding.\n>\n> The idea of sending out a block header is essentially what I called\n> \"optimistic mining\" and has been described in more detail in my blog here;\n> http://zander.github.io/posts/Innovation%20-%20OnlineScaling/\n>\n> The video explains with graphics too...\n>\n> You may find this interesting :)\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160726/f4924d63/attachment-0001.html>"
            },
            {
                "author": "Nick ODell",
                "date": "2016-07-26T22:03:41",
                "message_text_only": "Moral,\n\nMining the sync flag isn't compatible with the payout structure of non\nhot-wallet pools like Eligius or decentralized pools like p2pool.\nThose need the ability to split a reward among multiple parties.\nInstead of giving an address to send the funds to, you could include\nthe hash of the transaction allowed to spend the sync flag output.\nYou'd have to zero the previous outpoint of the transaction before\nhashing, since you don't know what the hash of the coinbase ten blocks\nfrom now will be.\n\n\nOn Tue, Jul 26, 2016 at 6:47 AM, Moral Agent via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> I posted this to /r/bitcoin yesterday but it got minimal comments. One uses\n> suggested I try the mailing list so here it is:\n>\n> The idea presented here could have the following benefits:\n>\n> 1. Improve mining decentralization\n> 2. Reduce variance in mining profitability\n> 3. Reduce or eliminate SPV mined blocks\n> 4. Reduce or eliminate empty blocks, smoothing out resource usage\n> 5. Reduce or eliminate the latency bottleneck on throughput\n> 6. Make transaction stuffing by miners be either obvious or costly\n> 7. Gives miners something to do while they wait for attractive transactions\n> to appear\n> 8. Can be easily done with a soft fork\n>\n> #Basic idea:\n>\n> Ideally, all miners would begin hashing the next block at exactly the same\n> time. Miners with a head start are more profitable, and the techniques that\n> help miners receive and validate blocks quickly create centralization\n> pressure.\n>\n> What if there was something that acted like the starting flag at a race,\n> which could suddenly wave and cause all of the miners to simultaneously\n> begin hashing the next block?\n>\n> #Implementation:\n>\n> Let a sync flag be a message consisting of:\n>\n> 1. Hash of the previous block.\n> 2. Bitcoin address\n> 3. Nonce\n>\n> This tiny message could propagate through the network at maximum speed. If\n> miners had to include the hash of this flag in the next block, then all\n> miners wait for this flag, and when it suddenly spread through the network,\n> all miners could simultaneously begin hashing the next block.\n>\n> The sync flag should not be produced too quickly. You want to give everyone\n> enough time to be ready to hash the next block. Let's say that the hash of\n> the sync flag is a proof of work that is targeted for 2 minutes.\n>\n> To fund this proof of work, the protocol is modified to demand that the\n> block produced 10 blocks after the sync flag must allocate 25% of the block\n> reward to the address published by the sync flag. In this way, sync flags\n> are produced in 2 minutes, and blocks are produced in 8 minutes, with 10\n> minutes total.\n>\n>\n> Illustration 1: https://s32.postimg.org/wzg0hs8lx/sync_flag.png)\n>\n> Illustration 2: https://s32.postimg.org/vc5y9yz4l/sync_flag2.png\n>\n>\n> #Explanation of reasons:\n>\n> **Improve mining decentralization**\n>\n> One factor driving centralization is the imperative miners have to achieve\n> low latency in receiving and validating blocks. To achieve low latency, it\n> helps a lot if you have expensive low-latency internet connections, curated\n> network topologies, and large pools that have a plausible chance of finding\n> consecutive blocks. If miners are expected (or forced) to validate a block\n> prior to mining on top of it, the rational end game would be to outsource\n> the validation step to a trusted third party specialist who can choose\n> optimal locations on the globe to serve their (multiple?) mining pool\n> clients. These are all less decentralized than the mining situation Satoshi\n> and others imagined.\n>\n> **Reduce variance in mining revenue**\n>\n> Currently, there are about 144 opportunities per day for a pool or solo\n> miner to see any revenue at all. With sync flags, that number doubles to\n> 288. Sync flags are only worth 25% of what a block is worth, but this still\n> represents a significant reduction in variance. This variance is one factor\n> causing solo miners to group into pools, and large pools to be more\n> attractive than small pools.\n>\n> **Reduce or eliminate SPV mined blocks**\n>\n> One way miners have sought to make\n> full-block-transmission-and-validation-latency irrelevant has been through\n> \"SPV\" mining or \"Head-first\" mining. There is some evidence that these\n> techniques may be widely used, and that badgering the miners about it is an\n> ineffective strategy to stop them.\n>\n> In SPV mining, a miner would simply accept any block header that shows the\n> correct proof of work. All other validation is entrusted to other miners.\n> This practice is quite dangerous as the SPV miners can wander off on some\n> invalid chain, taking SPV nodes with them. If this occurs during a soft\n> fork, these blind miners can also fool unupgraded fully validating nodes\n> into following them.\n>\n> \"Head-first\" mining means that miners start hashing as soon as they receive\n> the block header with the correct POW, but they simultaneously validate the\n> block, and abandon it if is not valid. I consider this to be pretty safe, as\n> it strictly limits the length of an invalid chain that can result from\n> mining without validating. However, \"Head-first\" mining can plausibly\n> generate 2 or 3 confirmations of an invalid block. It would be nice if such\n> confirmations did not happen.\n>\n> The sync flag technique is similar to head-first mining, but rather than\n> hashing the next block while they wait for transmission and validation of\n> the prior block, they hash the sync flag. Nodes can differentiate between\n> sync flags and blocks, and can ignore sync flags when counting\n> confirmations.\n>\n> **Reduce or eliminate empty blocks, smoothing out resource usage**\n>\n> Empty blocks are another consequence of SPV or Headfirst mining, because the\n> miner cannot safely include any transactions in the block they are hashing\n> until they have validated the prior block. By delaying the start of hashing\n> the next block until after validation, miners would not have this reason to\n> mine empty blocks.\n>\n> **Reduce or eliminate the latency bottleneck on throughput**\n>\n> Centralization pressure due to latency issues has been a major preoccupation\n> over the last year. If latency mattered much less, it could represent a\n> scalability improvement that could enable higher throughput.\n>\n> **Make transaction stuffing by miners be either obvious or costly**\n>\n> Currently, the entire block reward goes to the miner who mines it. One\n> unfortunate consequence of this is that it does not cost the miner anything\n> to covertly stuff the block with transactions. These transactions would pay\n> fees and be indistinguishable from ordinary transactions, but the fees are\n> paid by the miner and then immediately returned to the miner.\n>\n> With sync flags, the miner must share these transaction fees with the\n> address contained in the sync flag 10 blocks prior. This means that if the\n> miner gives the transactions a normal looking fee, they will incur a cost\n> that will be paid to the sync flag. If the miner wants to avoid this, they\n> must give their stuffing transactions a zero fee, which provides evidence\n> that they are stuffing.\n>\n> Also, when miners stuff with transactions using a zero fee, they cannot\n> manipulate the perception of how much fee it takes to get into a block.\n>\n> Note that miners could still try to covertly stuff blocks that will pay a\n> sync flag that they themselves created. if this is a big concern, it can be\n> addressed by forcing blocks to pay multiple sync flags.\n>\n> **Gives miners something to do while they wait for attractive transactions\n> to appear**\n>\n> From the Montreal scaling workshop last year, we have [this\n> talk](https://scalingbitcoin.org/montreal2015/presentations/Day1/13-miles-carlsten-Mind-the-Gap.pdf)\n> which worried that as the block subsidy reduced and transactions became a\n> more important fraction of miner revenue, it would be rational for miners to\n> turn off their mining equipment for a \"gap\" phase after a block is found, to\n> allow time to pass as more lucrative transactions entered the mempool.\n>\n> I don't know whether this will actually happen. The presence of a suitable\n> backlog of transactions would help prevent this dynamic from emerging. But\n> if such idling behavior was the optima mining strategy, it could create a\n> serious vulnerability. Idle hands are the devil's workshop as the saying\n> goes, and idle miners represent a pool of inert hashpower that is available\n> to rent for all kinds of destabilizing purposes. It would be better to put\n> those miners to profitable work mining a sync flag while they wait.\n>\n> Also, this creates a more efficient price discovery mechanism for\n> transactions, because you allow transactions paying high fees time to arrive\n> to the marketplace, rather than take whatever anyone is offering because all\n> the \"good\" transactions got gobbled up in the prior block.\n>\n> **Can be easily done with a soft fork**\n>\n> Although a hard fork would be more efficient, sync flags could be easily\n> implemented using a soft fork by introducing the following rule:\n>\n> Every block must include a transaction which pays 25% of the block reward to\n> the address given by the 10th previous sync flag, and commits to the hash of\n> the 1st previous sync flag.\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "Moral Agent",
                "date": "2016-07-27T14:42:32",
                "message_text_only": "I made a repo to be a home for sync_flags here:\nhttps://github.com/moral-agent/sync_flags\n\nIf you see any personally identifying information, please be a good sport\nand let me know. I'm a nobody, but I'd still prefer not to get doxxed.\n\nTwo changes to the proposal (see repo for explanations)\n\n1. Sync flags now would have the same difficulty as blocks.\n2. Blocks now donate to 5 sync flags instead of 1\n\nI also added comments about selfish mining and invalid block spam.\n\nResponse to replies:\n\ntomz at freedommail.ch: What is the advantage over optimistic mining?\n\n1. Sync flags can be somewhat smaller than block headers.\n2. Sync flags improve variance by doubling the number of chances to win\n3. Sync flags can be distinguished from normal blocks, so SPV clients can\nignore them as confirmations.\n4. Sync flags reward all miners equally. Optimistic blocks have to be empty\nunless you mined the previous block, which damages decentralization.\n5. Sync flags result in fewer empty blocks, smoothing out resource usage\n6. Sync flags make transaction stuffing by miners either obvious or costly\n7. Sync flags give miners something to do while they wait for attractive\ntransactions to appear.\n\nerik at q32.com: Flags will be selfish mined.\n\nI agree that flags would likely be selfish mined. I have modified the\nproposal to say that flags have the same POW target as blocks, so the\nselfish mining vulnerability should be equal to the current protocol.\n\nmartijn.meijering at mevs.nl: Why expect more selfish mining?\n\nBecause flags had small POW relative to blocks. After you find a block, why\nnot hide it while you take a crack at the flag?\n\ntier.nolan at gmail.com: Effect is same as mandatory empty blocks.\n\nNot quite the same:\n\n1. Sync flags can be somewhat smaller than block headers.\n2. Sync flags can be distinguished from normal blocks, so SPV clients can\nignore them as confirmations.\n3. Sync flags make transaction stuffing by miners either obvious or costly\n4. No one pays for empty blocks, except for the block subsidy. Some miners\nmay choose to only mine the non-empty blocks, resulting in\nhashpower-for-rent to make mischief or hashpower that oscillates, creating\na situation where empty blocks take longer to mine than full blocks.\n\nnickodell at gmail.com: Payout mechanism incompatible with certain mining pools\n\nHopefully some kind of smart contract structure could be implemented as you\nsuggested.\n\n\nOn Tue, Jul 26, 2016 at 6:03 PM, Nick ODell <nickodell at gmail.com> wrote:\n\n> Moral,\n>\n> Mining the sync flag isn't compatible with the payout structure of non\n> hot-wallet pools like Eligius or decentralized pools like p2pool.\n> Those need the ability to split a reward among multiple parties.\n> Instead of giving an address to send the funds to, you could include\n> the hash of the transaction allowed to spend the sync flag output.\n> You'd have to zero the previous outpoint of the transaction before\n> hashing, since you don't know what the hash of the coinbase ten blocks\n> from now will be.\n>\n>\n> On Tue, Jul 26, 2016 at 6:47 AM, Moral Agent via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I posted this to /r/bitcoin yesterday but it got minimal comments. One\n> uses\n> > suggested I try the mailing list so here it is:\n> >\n> > The idea presented here could have the following benefits:\n> >\n> > 1. Improve mining decentralization\n> > 2. Reduce variance in mining profitability\n> > 3. Reduce or eliminate SPV mined blocks\n> > 4. Reduce or eliminate empty blocks, smoothing out resource usage\n> > 5. Reduce or eliminate the latency bottleneck on throughput\n> > 6. Make transaction stuffing by miners be either obvious or costly\n> > 7. Gives miners something to do while they wait for attractive\n> transactions\n> > to appear\n> > 8. Can be easily done with a soft fork\n> >\n> > #Basic idea:\n> >\n> > Ideally, all miners would begin hashing the next block at exactly the\n> same\n> > time. Miners with a head start are more profitable, and the techniques\n> that\n> > help miners receive and validate blocks quickly create centralization\n> > pressure.\n> >\n> > What if there was something that acted like the starting flag at a race,\n> > which could suddenly wave and cause all of the miners to simultaneously\n> > begin hashing the next block?\n> >\n> > #Implementation:\n> >\n> > Let a sync flag be a message consisting of:\n> >\n> > 1. Hash of the previous block.\n> > 2. Bitcoin address\n> > 3. Nonce\n> >\n> > This tiny message could propagate through the network at maximum speed.\n> If\n> > miners had to include the hash of this flag in the next block, then all\n> > miners wait for this flag, and when it suddenly spread through the\n> network,\n> > all miners could simultaneously begin hashing the next block.\n> >\n> > The sync flag should not be produced too quickly. You want to give\n> everyone\n> > enough time to be ready to hash the next block. Let's say that the hash\n> of\n> > the sync flag is a proof of work that is targeted for 2 minutes.\n> >\n> > To fund this proof of work, the protocol is modified to demand that the\n> > block produced 10 blocks after the sync flag must allocate 25% of the\n> block\n> > reward to the address published by the sync flag. In this way, sync flags\n> > are produced in 2 minutes, and blocks are produced in 8 minutes, with 10\n> > minutes total.\n> >\n> >\n> > Illustration 1: https://s32.postimg.org/wzg0hs8lx/sync_flag.png)\n> >\n> > Illustration 2: https://s32.postimg.org/vc5y9yz4l/sync_flag2.png\n> >\n> >\n> > #Explanation of reasons:\n> >\n> > **Improve mining decentralization**\n> >\n> > One factor driving centralization is the imperative miners have to\n> achieve\n> > low latency in receiving and validating blocks. To achieve low latency,\n> it\n> > helps a lot if you have expensive low-latency internet connections,\n> curated\n> > network topologies, and large pools that have a plausible chance of\n> finding\n> > consecutive blocks. If miners are expected (or forced) to validate a\n> block\n> > prior to mining on top of it, the rational end game would be to outsource\n> > the validation step to a trusted third party specialist who can choose\n> > optimal locations on the globe to serve their (multiple?) mining pool\n> > clients. These are all less decentralized than the mining situation\n> Satoshi\n> > and others imagined.\n> >\n> > **Reduce variance in mining revenue**\n> >\n> > Currently, there are about 144 opportunities per day for a pool or solo\n> > miner to see any revenue at all. With sync flags, that number doubles to\n> > 288. Sync flags are only worth 25% of what a block is worth, but this\n> still\n> > represents a significant reduction in variance. This variance is one\n> factor\n> > causing solo miners to group into pools, and large pools to be more\n> > attractive than small pools.\n> >\n> > **Reduce or eliminate SPV mined blocks**\n> >\n> > One way miners have sought to make\n> > full-block-transmission-and-validation-latency irrelevant has been\n> through\n> > \"SPV\" mining or \"Head-first\" mining. There is some evidence that these\n> > techniques may be widely used, and that badgering the miners about it is\n> an\n> > ineffective strategy to stop them.\n> >\n> > In SPV mining, a miner would simply accept any block header that shows\n> the\n> > correct proof of work. All other validation is entrusted to other miners.\n> > This practice is quite dangerous as the SPV miners can wander off on some\n> > invalid chain, taking SPV nodes with them. If this occurs during a soft\n> > fork, these blind miners can also fool unupgraded fully validating nodes\n> > into following them.\n> >\n> > \"Head-first\" mining means that miners start hashing as soon as they\n> receive\n> > the block header with the correct POW, but they simultaneously validate\n> the\n> > block, and abandon it if is not valid. I consider this to be pretty\n> safe, as\n> > it strictly limits the length of an invalid chain that can result from\n> > mining without validating. However, \"Head-first\" mining can plausibly\n> > generate 2 or 3 confirmations of an invalid block. It would be nice if\n> such\n> > confirmations did not happen.\n> >\n> > The sync flag technique is similar to head-first mining, but rather than\n> > hashing the next block while they wait for transmission and validation of\n> > the prior block, they hash the sync flag. Nodes can differentiate between\n> > sync flags and blocks, and can ignore sync flags when counting\n> > confirmations.\n> >\n> > **Reduce or eliminate empty blocks, smoothing out resource usage**\n> >\n> > Empty blocks are another consequence of SPV or Headfirst mining, because\n> the\n> > miner cannot safely include any transactions in the block they are\n> hashing\n> > until they have validated the prior block. By delaying the start of\n> hashing\n> > the next block until after validation, miners would not have this reason\n> to\n> > mine empty blocks.\n> >\n> > **Reduce or eliminate the latency bottleneck on throughput**\n> >\n> > Centralization pressure due to latency issues has been a major\n> preoccupation\n> > over the last year. If latency mattered much less, it could represent a\n> > scalability improvement that could enable higher throughput.\n> >\n> > **Make transaction stuffing by miners be either obvious or costly**\n> >\n> > Currently, the entire block reward goes to the miner who mines it. One\n> > unfortunate consequence of this is that it does not cost the miner\n> anything\n> > to covertly stuff the block with transactions. These transactions would\n> pay\n> > fees and be indistinguishable from ordinary transactions, but the fees\n> are\n> > paid by the miner and then immediately returned to the miner.\n> >\n> > With sync flags, the miner must share these transaction fees with the\n> > address contained in the sync flag 10 blocks prior. This means that if\n> the\n> > miner gives the transactions a normal looking fee, they will incur a cost\n> > that will be paid to the sync flag. If the miner wants to avoid this,\n> they\n> > must give their stuffing transactions a zero fee, which provides evidence\n> > that they are stuffing.\n> >\n> > Also, when miners stuff with transactions using a zero fee, they cannot\n> > manipulate the perception of how much fee it takes to get into a block.\n> >\n> > Note that miners could still try to covertly stuff blocks that will pay a\n> > sync flag that they themselves created. if this is a big concern, it can\n> be\n> > addressed by forcing blocks to pay multiple sync flags.\n> >\n> > **Gives miners something to do while they wait for attractive\n> transactions\n> > to appear**\n> >\n> > From the Montreal scaling workshop last year, we have [this\n> > talk](\n> https://scalingbitcoin.org/montreal2015/presentations/Day1/13-miles-carlsten-Mind-the-Gap.pdf\n> )\n> > which worried that as the block subsidy reduced and transactions became a\n> > more important fraction of miner revenue, it would be rational for\n> miners to\n> > turn off their mining equipment for a \"gap\" phase after a block is\n> found, to\n> > allow time to pass as more lucrative transactions entered the mempool.\n> >\n> > I don't know whether this will actually happen. The presence of a\n> suitable\n> > backlog of transactions would help prevent this dynamic from emerging.\n> But\n> > if such idling behavior was the optima mining strategy, it could create a\n> > serious vulnerability. Idle hands are the devil's workshop as the saying\n> > goes, and idle miners represent a pool of inert hashpower that is\n> available\n> > to rent for all kinds of destabilizing purposes. It would be better to\n> put\n> > those miners to profitable work mining a sync flag while they wait.\n> >\n> > Also, this creates a more efficient price discovery mechanism for\n> > transactions, because you allow transactions paying high fees time to\n> arrive\n> > to the marketplace, rather than take whatever anyone is offering because\n> all\n> > the \"good\" transactions got gobbled up in the prior block.\n> >\n> > **Can be easily done with a soft fork**\n> >\n> > Although a hard fork would be more efficient, sync flags could be easily\n> > implemented using a soft fork by introducing the following rule:\n> >\n> > Every block must include a transaction which pays 25% of the block\n> reward to\n> > the address given by the 10th previous sync flag, and commits to the\n> hash of\n> > the 1st previous sync flag.\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160727/6ccd1a29/attachment-0001.html>"
            },
            {
                "author": "Moral Agent",
                "date": "2016-07-28T16:41:48",
                "message_text_only": "If there is concern about the\nblock-with-valid-header-but-invalid-transactions-spam-attack, I have a\nstrategy using sync flags that may drastically reduce the problem.\n\nSync flags documented here:\n\nhttps://github.com/moral-agent/sync_flags/blob/master/README.md)\n\nThe strategy to defeat the above attack is illustrated here:\n\nhttps://s32.postimg.org/e94tqdqat/sync_flag_invalid_block.png\n\nThe key is to relax the requirement that a flag commit to a completely\nvalid block. The flag is valid if it commits to a valid block header, even\nif the block body is invalid.\n\n>From the perspective of an individual miner, they can safely commence\nmining a flag the moment they obtain (or discover) a valid block header.\n\nAs soon as the spam is discovered, miners can choose to either abandon the\nflag and return to mining on the previous block, or they can continue\nmining on the flag.\n\nIt's difficult for me to game out which of these strategies would be\npreferable. My first thought is that the miners should have the incentive\nto mine whichever option has the fewest miners, which should result in a\n50/50 split.\n\nHowever, the miners who continue mining the flag have a chance of ending up\nin a situation where they mine the flag before anyone mines a valid block.\nIf this happens, it is sub-optimal for them. They can start mining for the\nnext valid block but if someone else broadcasts a valid block header they\nwill be in the same pickle that miners under the current protocol are: they\nmust either keep mining for a valid block, or SPV mine the newly arrived\nblock while they do validation. The third option, of mining a flag, is not\navailable to them, because the flag has already been mined for this cycle.\n\nAs a result of the above, it may be most rational for miners to (upon\nlearning that they are mining a flag on top of an invalid block) split\ntheir hashpower unevenly between the flag and continuing to mine for a\nvalid block. The hashpower split reflects their estimates of the cost of\nthe above negative outcome. I think the split would be pretty close to\n50/50, but deviations from 50/50 would not necessarily be bad. For example,\nif they split 52/48, with more hashpower toward finding the valid block\ninstead of the flag, then that decreases the likelyhood that the flag will\nbe discovered before the next valid block, which is good for all of the\nminers. So it's a nice positive feedback.\n\n*****\n\nThis approach mostly neutralizes the harm done by the (currently very rare)\ninvalid block spam attack. As a kind of amazing side effect, the work done\nto produce the spam is incorporated into the blockchain cumulative Proof of\nWork, and the spammer is not paid for this contribution.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160728/cd41259c/attachment.html>"
            },
            {
                "author": "Tier Nolan",
                "date": "2016-07-26T21:45:14",
                "message_text_only": "On Tue, Jul 26, 2016 at 9:58 PM, Martijn Meijering via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Is there a reason miners would be more likely to engage in selfish\n> mining of sync flags than they are now with ordinary blocks?\n>\n\n\nThis proposal has the same effect as adding mandatory empty blocks.\n\nPOW targeted at 2 minutes means that the POW for the flag is 25% of the\nblock POW.  That gives a flag every 2 minutes and a block every 8 minutes.\n\nIt has the feature that the conversion rate from hashing power to reward is\nthe same for the flags and the blocks.  A flag get 25% of the reward for\n25% of the effort.\n\nA soft fork to add this rule would have a disadvantage relative to a\ncompeting chain.  It would divert 20% of its hashing power to the flag\nblocks, which would be ignored by legacy nodes.  The soft fork would need\n55% of the hashing power to win the race.\n\nThis isn't that big a deal if a 75% activation threshold is used.  It might\nbe worth bumping it up to 80% in that case.\n\nThis rule would mean that headers first clients would have to download more\ninformation to verify the longest chain.  If they only download the\nheaders, they are missing 20% of the POW.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160726/ed137f92/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Reasons to add sync flags to Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom",
                "Nick ODell",
                "Tier Nolan",
                "Erik Aronesty",
                "Moral Agent"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 38589
        }
    },
    {
        "title": "[bitcoin-dev] BIP proposal: derived mnemonics",
        "thread_messages": [
            {
                "author": "millibitcoin",
                "date": "2016-07-26T18:31:36",
                "message_text_only": "(not sure so sent again after subscribing (one use case added))\n\nDear Bitcoin developers,\n\nBelow is provided a draft BIP proposal for a master mnemonic sentence \nfrom which other mnemonics sentences can be derived in a deterministic \nnon-reversible way (on an offline computer). This would make it much \neasier to split funds into smaller fractions and use those in a \nHD-wallet when appropriate (just by inserting 12 or more words), without \never putting the master mnemonic at risk on an online computer. But \nthere are many more use cases.\n\nA reference implementation, specifically for use with a Trezor, has been \ngenerated and can be found at: \nhttp://thebitcoinecosystem.info/DerivedMnemonics.html\n\nI'm not a professional programmer or cryptographer, so the idea and \nreference implementation will probably need a lot of reviewing but I do \nthink Bitcoin needs this extension and the corresponding ease of use and \nimproved security model.\n\nIn the hope you like the idea,\n\nRegards,\nsumBTC\n\n\n<pre>\n   BIP: ???\n   Title: Derived mnemonics from a master mnemonic.\n   Author: sumBTC <millibitcoins at gmail.com>\n   Status: For Discussion\n   Type:\n   Created: 2016-07-24\n</pre>\n\n==Abstract==\n\nThis BIP??? uses a master mnemonic sentence, as described in BIP39, for \nthe deterministic generation of derived mnemonic sentences. The derived \nmnemonics are of the same format as the master mnemonic but can consist \nof a higher or lower number of words.\n\nBinary seeds can then be generated for derived mnemonics (and master \nmnemonic) as described in BIP39. Each of these seeds can be used to \ngenerate deterministic wallets using BIP-0032 or similar methods.\n\n==Motivation==\n\nA mnemonic code or sentence is superior for human interaction as \ndescribed in BIP39 and can, for example, be written on paper or even \nmemorized. However, once a mnemonic has been used online, even through \nthe use of a hardware wallet, the mnemonic could be compromised. This \nshould be considered a bad practice from a security standpoint.\n\nWe therefore propose the generation of a master mnemonic offline and \nfrom this generate (also offline) multiple derived mnemonics in a \ndeterministic way for online use. The master mnemonic is never used \nonline and the master mnemonic cannot be obtained from the derived \nmnemonics. Examples of use cases are described below.\n\n==Generating the master mnemonic==\n\nThe master mnemonic is first derived as a standard mnemonic as described \nin BIP39.\n\n==From master mnemonic to derived mnemonics==\n\n From the master mnemonic a new string is created:\n\nstring = MasterMnemonic + \" \" + Count + \" \" + Strength;\n\nHere, MasterMnemonic are the space separated words of the master \nmnemonic. Count = 0, 1, 2 denotes the different derived mnemonics of a \ngiven strength and Strength = numWords / 3 * 32, where numWords is the \nnumber of words desired for the derived mnemonic and only integer \narithmetic is used in the calculation (e.g. for numWords = 14, Strength \n= 128). Both Count and Strength are converted to strings.\n\nThis string is then hashed using sha512:\n\nhash = sha512(string);\n\nand turned into a byte array:\n\nfor (var i=0; i<strength/8; i++) {\n   byteArray[i] = (hash[Math.floor((i%64)/4)] >>> ((i%4)*8)) & 0b11111111;\n}\n\nThis byte array is then used to generate a new mnemonic as shown in the \nreference implementation using the method described in BIP39. The core \nof the new code in the reference manual can be found by jumping to \n\"start: new code\" in the reference software.\n\nA passphrase for the master mnemonic has the same effect on the derived \nmnemoncis (so must be included).\n\n==Reference Implementation==\n\nThe reference implementation generates addresses based on BIP44 for a 24 \nword master mnemonic and is available from\n\nhttp://thebitcoinecosystem.info/DerivedMnemonics.html\n\nor\n\ngithub (not yet)\n\n==Checking the derived mnemonics using Electrum==\n\nThe displayed addresses in each of the reference implementations can be \neasily checked using Electrum in the following manner:\n\nmove the directory ~/.electrum to a backup directory.\nstart Electrum and choose:\nRestore a wallet or import keys\nHardware wallet\nRestore Electum wallet from device seed words\nTREZOR wallet\nInsert one of the mnemonics and check that the same addresses are \ngenerated by Electrum\n\nCheck the private keys:\nmove the directory ~/.electrum to a backup directory.\nstart Electrum and choose:\nRestore a wallet or import keys\nStandard wallet\nImport one of the private keys and check that the correct address has \nbeen generated.\n\nSome checks should include a passphrase.\n\n==Examples of Use Cases==\n\nA person with 25 bitcoin splits funds using 5 derived mnemonics and \nsends 5 bitcoins to the first address of each derived mnemonic. He can \nthen use a (hardware) HD-wallet and simply insert one of the derived \nmnemonics to put only 5 bitcoins online and at risk at once. All funds \ncan be recovered from the master mnemonic.\n\nA person wants to give 10 bitcoin to each of his family members, giving \neach participant a derived mnemonic and sending bitcoin to each of them. \nThe donating person can always recover the derived mnemonic if one of \nhis family members loses his derived mnemonic.\n\nFor his Trezor wallet, someone wants to memorize only a 12 words master \nseed but wants to insert a 24 words derived seed so a key logger on his \ncomputer has 24! possibilities to check and not 12! (not a possibility \nfor the current reference implementation but trivial to add)."
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-07-26T20:10:15",
                "message_text_only": "Hi\n\n\n> ==Generating the master mnemonic==\n> \n> The master mnemonic is first derived as a standard mnemonic as described\n> in BIP39.\n\n\n\n> ==From master mnemonic to derived mnemonics==\n> \n> From the master mnemonic a new string is created:\n> \n> string = MasterMnemonic + \" \" + Count + \" \" + Strength;\n> \n> Here, MasterMnemonic are the space separated words of the master\n> mnemonic. Count = 0, 1, 2 denotes the different derived mnemonics of a\n> given strength and Strength = numWords / 3 * 32, where numWords is the\n> number of words desired for the derived mnemonic and only integer\n> arithmetic is used in the calculation (e.g. for numWords = 14, Strength\n> = 128). Both Count and Strength are converted to strings.\n> \n> This string is then hashed using sha512:\n> \n> hash = sha512(string);\n\n1)\nMy humble cryptographic understanding tells me that you should probably\nuse sha512_hmac where you add an passphrase and a salt.\n\n2)\nSide-note: Bip39 does still use PBKDF2 with 2048 iterations which I\npersonally consider \"not enough\" to protect a serious amount of funds.\n\nAlso the checksum based on the predetermined wordlist has some security\ndownsides over using a plain 32byte entropy (64hex chars) or a\nbase58check encoded extended private master key.\n\n3)\nAnother idea:\nWhat would speak against deriving a child key after bip32, lets say at\nm/88'/0'/n' and use the derived 256bits to encode your mnemonic?\nThis would at least require your master mnemonic passphrase to derive a\nvalid \"child mnemonic\".\n\n4)\nI'm still not convinced if we should encourage users to \"only store and\nbackup\" the bip39 mnemonic.\nReconstructing funds from a seed can be difficult especially if you\ndon't have access to a trusted TX-indexed full node (~150GB of data\nrequired).\nNovice users might also underestimate the risk of losing metadata\ncoupled with their transactions when they only store the wallet seed.\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160726/d070c20b/attachment.sig>"
            },
            {
                "author": "Jochen Hoenicke",
                "date": "2016-07-27T10:39:36",
                "message_text_only": "Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nschrieb am Di., 26. Juli 2016 um 22:10 Uhr:\n\n> Side-note: Bip39 does still use PBKDF2 with 2048 iterations which I\n> personally consider \"not enough\" to protect a serious amount of funds.\n>\n>\nBut what are the alternatives?  Put an expensive processor and a decent\namount of memory in every hardware wallet to support scrypt?  Use a million\niterations and just wait 10 minutes after entering you passphrase?  Or\ncompute the secret key on your online computer instead?\n\nAlso, how many iterations are secure?  A million?  Then just add two random\nlower-case letters to the end of your passphrase and you have a better\nprotection with 2048 iterations. If you want to be able to use your\npassphrase with cheap hardware and be protected against a high-end computer\nwith multiple GPUs that is almost a mllion times faster, then you have to\nchoose a good passphrase.  Or just make sure nobody steals your seed; it is\nnot a brainwallet that is only protected by the passphrase after all.\n\nRegards,\n  Jochen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160727/6744055a/attachment.html>"
            },
            {
                "author": "Jonas Schnelli",
                "date": "2016-07-27T10:53:24",
                "message_text_only": "> But what are the alternatives?  Put an expensive processor and a decent\n> amount of memory in every hardware wallet to support scrypt?  Use a\n> million iterations and just wait 10 minutes after entering you\n> passphrase?  Or compute the secret key on your online computer instead?\n\nWhat the Digital Bitbox team does, is, PBKDF2 the user entered\npassphrase on the computer with >20'000 iterations, then PBKDF2 again\nonchip with the 2048 rounds.\nIf somebody manages to steal your backup (in that case a file/SDCard or\nprinted PDF), it would at least required > 22'048 iterations to derive\nthe key from a passphrase which I consider \"stronger\" then just using\n2048 iterations.\n\n> Also, how many iterations are secure?  A million?  Then just add two\n> random lower-case letters to the end of your passphrase and you have a\n> better protection with 2048 iterations.\n\nI guess you shouldn't delegate KDF security to the user. But sure, this\ncould help as well. This is part of the UI.\n\nOn the other hand, forcing the user to select a long/more-secure\npassphrase will very likely lead to many funds get lost behind\nencryption because of lost/forgotten passphrases.\n\n> If you want to be able to use\n> your passphrase with cheap hardware and be protected against a high-end\n> computer with multiple GPUs that is almost a mllion times faster, then\n> you have to choose a good passphrase.  Or just make sure nobody steals\n> your seed; it is not a brainwallet that is only protected by the\n> passphrase after all.\n\nAgree.\nBut IMO this fact should not be an excuse to reduce/use low iterations\nduring KDF (especially SHA2 based KDFs).\n\n</jonas>\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160727/9022ee3f/attachment.sig>"
            },
            {
                "author": "Gregory Maxwell",
                "date": "2016-07-27T20:59:54",
                "message_text_only": "On Wed, Jul 27, 2016 at 10:39 AM, Jochen Hoenicke via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n> schrieb am Di., 26. Juli 2016 um 22:10 Uhr:\n>>\n>> Side-note: Bip39 does still use PBKDF2 with 2048 iterations which I\n>> personally consider \"not enough\" to protect a serious amount of funds.\n>>\n>\n> But what are the alternatives?  Put an expensive processor and a decent\n> amount of memory in every hardware wallet to support scrypt?  Use a million\n> iterations and just wait 10 minutes after entering you passphrase?  Or\n> compute the secret key on your online computer instead?\n>\n> Also, how many iterations are secure?  A million?  Then just add two random\n> lower-case letters to the end of your passphrase and you have a better\n> protection with 2048 iterations. If you want to be able to use your\n> passphrase with cheap hardware and be protected against a high-end computer\n> with multiple GPUs that is almost a mllion times faster, then you have to\n> choose a good passphrase.  Or just make sure nobody steals your seed;\n\nJochen, two alternatives were raised in public discussion:\n\nUse a scheme which supports delegatable hardening-- (there are two\nbroad classes proposed, one where the delegated party learns\ninformation that would let them bypass the part of the hardening they\nperform but only that part, and another where the delegation is\ninformation theoretically private.)\n\nor\n\nEschew the pretextual 'hardening' that serves no purpose but to cause\nusers to think the scheme is more secure than it is, and which makes\nthe system more complex to implement.\n\nBoth were rejected by the authors of that spec.\n\n> it is\n> not a brainwallet that is only protected by the passphrase after all.\n\nThis ignores the history of that spec and the widespread use. Because\nof the design, the check value can't be computed without a fixed\ndictionary, and many people do use it as a brainwallet-- which is what\nthat BIP originally specified, in fact."
            }
        ],
        "thread_summary": {
            "title": "BIP proposal: derived mnemonics",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "millibitcoin",
                "Jochen Hoenicke",
                "Gregory Maxwell",
                "Jonas Schnelli"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 12870
        }
    },
    {
        "title": "[bitcoin-dev]  Reasons to add sync flags to Bitcoin",
        "thread_messages": [
            {
                "author": "Martijn Meijering",
                "date": "2016-07-26T20:58:00",
                "message_text_only": "- Flags will be mined selfishly, and not published until the advantage\n   gained from withholding is less than the mining reward.  This effect may\n   kill the decentralization features, since big miners will be the only ones\n   that can selfish-mine flags.  Indeed, collusion would be encouraged... just\n   ship the flag to the miners you do business with, and no one else.   At the\n   expense of loss of flag revenue, your in-group would gain a massive\n   advantage in main-chain mining.\n\n---\n\nIs there a reason miners would be more likely to engage in selfish\nmining of sync flags than they are now with ordinary blocks?"
            }
        ],
        "thread_summary": {
            "title": "Reasons to add sync flags to Bitcoin",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Martijn Meijering"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 622
        }
    },
    {
        "title": "[bitcoin-dev] Committed bloom filters for improved wallet performance and SPV security",
        "thread_messages": [
            {
                "author": "Leo Wandersleb",
                "date": "2016-07-28T21:07:29",
                "message_text_only": "gmaxwell just made me aware of this mail thread [0]. Some days ago I had\nindependently and naively started implementing \"something similar\" [1].\n\nMy version totally ignored the commitment and signing part but I'm pretty sure\nthat 12GB is overkill. My code is currently broken and I have no time to work on\nit much but I thought it might be helpful to chime in.\n\nAt this point in time the difference between 80GB and 3GB (as my current 1.5GB\nof only outputs would suggest if I had covered the inputs) or even 12GB makes\nthe difference of being able to store it on a phone, vs. not being able to. 80GB\n\"compressed\" to 3GB is not that bad at all. Unfortunately, with segWit this will\nbe worse, with the higher transaction count per MB.\n\nRegards,\n\nLeo\n\n[0]\nhttps://www.reddit.com/r/Bitcoin/comments/4v28jl/how_have_fungiblity_problems_affected_you_in/d5ux6aq\n[1] https://github.com/Giszmo/TransactionFinder\n\nOn 05/11/2016 10:29 PM, Bob McElrath via bitcoin-dev wrote:\n> Eerrrr....let me revise that last paragraph.  That's 12 *GB* of filters at\n> today's block height (at fixed false-positive rate 1e-6.  Compared to block\n> headers only which are about 33 MB today.  So this proposal is not really\n> compatible with such a wallet being \"light\"...\n>\n> Damn units...\n>\n> Bob McElrath via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n>> I like this idea, but let's run some numbers...\n>>\n>> bfd--- via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:\n>>> A Bloom Filter Digest is deterministically created of every block\n>> Bloom filters completely obfuscate the required size of the filter for a desired\n>> false-positive rate.  But, an optimal filter is linear in the number of elements\n>> it contains for fixed false-positive rate, and logarithmic in the false-positive\n>> rate.  (This comment applies to a RLL encoded Bloom filter Greg mentioned, but\n>> that's not the only way)  That is for N elements and false positive rate\n>> \\epsilon:\n>>\n>>     filter size = - N \\log_2 \\epsilon\n>>\n>> Given that the data that would be put into this particular filter is *already*\n>> hashed, it makes more sense and is faster to use a Cuckoo[1] filter, choosing a\n>> fixed false-positive rate, given expected wallet sizes.  For Bloom filters,\n>> multiply the above formula by 1.44.\n>>\n>> To prevent light clients from downloading more blocks than necessary, the\n>> false-positive rate should be roughly less than 1/(block height).  If we take\n>> the false positive rate to be 1e-6 for today's block height ~ 410000, this is\n>> about 20 bits per element.  So for todays block's, this is a 30kb filter, for a\n>> 3% increase in block size, if blocks commit to the filter.  Thus the required\n>> size of the filter commitment is roughly:\n>>\n>>     filter size = N \\log_2 H\n>>\n>> where H is the block height.  If bitcoin had these filters from the beginning, a\n>> light client today would have to download about 12MB of data in filters.  My\n>> personal SPV wallet is using 31MB currently.  It's not clear this is a bandwidth\n>> win, though it's definitely a win for computing load on full nodes.\n>>\n>>\n>> [1] https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf\n>>\n>> --\n>> Cheers, Bob McElrath\n>>\n>> \"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n>>     -- H. L. Mencken \n>>\n>>\n>>\n>> !DSPAM:5733934b206851108912031!\n>\n>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n>>\n>> !DSPAM:5733934b206851108912031!\n> --\n> Cheers, Bob McElrath\n>\n> \"For every complex problem, there is a solution that is simple, neat, and wrong.\"\n>     -- H. L. Mencken \n>\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 473 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160728/17064a1c/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Committed bloom filters for improved wallet performance and SPV security",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Leo Wandersleb"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 4215
        }
    },
    {
        "title": "[bitcoin-dev] Holdup on Block Alerts / Fraud Proofs ?",
        "thread_messages": [
            {
                "author": "Paul Sztorc",
                "date": "2016-07-30T23:18:36",
                "message_text_only": "Dear list,\n\nAs we know, it would be desirable for Alice, running an SPV client, to tip (say $5) anyone who can prove to her that a given block has invalid content.\n\nIf no one takes these tips, then this is weak evidence that the entire block is valid. Alice gets validation, full nodes can get paid...this idea goes back to Satoshi's whitepaper.\n\nIn my view, \"alerts\" are relatively straightforward: a new OP CODE (details below) st. the txn only succeeds if it references invalid block content on a \"pretender block\".\n\nHowever, my background reading seems to reveal that \"fraud proofs\" (as they are now called) require some kind of tremendous engineering overhaul. Can anyone point me to these large problem(s)?\n\nRegards,\nPaul Sztorc\n\n\n------------------------------------\n\nFraud Proof, Simple (?)\n\n\n1. \"OP FraudProof\", which:\n\t1. Contains arguments [a] block number (from Alice), [b] block header, and [c] merkle path from header to an invalid transaction*.\n\t2. Checks to see if the provided header _is_ in the position which Alice requested.\n\t2. Checks to see if the header _is_ valid (ie, has sufficient work).\n\t3. Checks to see if the merkle path _does_ lead from the header to \"something invalid\"*.\n\n2. This OP Code can then be used in a transaction of the form:\n\tInputs:\n\t\t1 from Alice\n\t\t0.2 from X**\n\tOutput:\n\t\t1.2 to Alice, timelocked\n\t\t(or)\n\t\t1.2 to X, OP FraudProof .\n\n\n3. Alice could sign this txn and circulate it, waiting for \"X\" to add the second signature. \n\n\"Eric\", for example, might sign. As soon as Alice get's Eric's signature, she [1] assumes the block *is* invalid, and [2] stops offering to buy FraudProofs on it.\n\nIf Eric does not deliver the fraud proof, Alice gets her money back + 0.2 BTC from Eric (for wasting her time). Alice can't lose -- she either buys a fraud proof for 1, or she gets a free 0.2.\n\nEric can't lose either. Either he doesn't sign (and nothing happens), or he places himself in a position to trade a FraudProof for 1 BTC.\n\n- FraudProof can use \"OP Equal\" to request fraud for a certain block.\n- This can all happen through the lightning network.\n\n* \"invalid transaction\" is defined either [1] as a script which fails, or [2] a double-spend (headers/paths to 2 txns spending the same input). This definition does not catch bad coinbase transactions, but this doesn't concern me. Those outputs aren't spendable for 100 blocks, and anyway, SPV clients could be programmed to never accept them (it would be annoying, but possible).\n\n** For simplicity, I assume that \"FraudProof sellers\" will pre-identify themselves (and their unspent outputs, etc, by making them \"watching only\" or whatever).\n\n---\n\nNow, I wouldn't describe this as a \"weekend project\", but I wouldn't describe it as an \"engineering overhaul\" either. Just a new OP Code, and code to create / scan for these \"Alert Transactions\". So, if the idea is 5+ years old, what's the hold up?\n\nI've also heard that segwit will help, but don't understand why."
            },
            {
                "author": "Bryan Bishop",
                "date": "2016-07-31T01:31:56",
                "message_text_only": "On Sat, Jul 30, 2016 at 6:18 PM, Paul Sztorc via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I've also heard that segwit will help, but don't understand why.\n>\n\nThere are some helpful discussions that happened over here:\nhttps://botbot.me/freenode/bitcoin-core-dev/2015-12-28/?msg=56907496&page=2\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160730/c3679f1e/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2016-07-31T05:18:18",
                "message_text_only": "On Saturday, July 30, 2016 11:18:36 PM Paul Sztorc via bitcoin-dev wrote:\n> In my view, \"alerts\" are relatively straightforward: a new OP CODE (details\n> below) st. the txn only succeeds if it references invalid block content on\n> a \"pretender block\".\n> \n> However, my background reading seems to reveal that \"fraud proofs\" (as they\n> are now called) require some kind of tremendous engineering overhaul. Can\n> anyone point me to these large problem(s)?\n\nEssentially this comes down to attackers being able to construct a block for \nwhich invalidity cannot be proven. While you could always show a proof for an \ninvalid transaction within a well-formed block, you cannot show a proof that a \nblock is not well-formed. For example, the merkle tree that ought to represent \na set of transactions may be corrupted in such a manner that the transaction \npaying Alice can have a SPV proof made, but the links in the merkle path have \nno known data (transactions) behind them. This could even be a perfectly valid \nblock, but with some of the transactions withheld until it is stale - full \nnodes and miners cannot accept it without knowing the entire block's \ntransactions. The only solution to this I am aware of, is for Alice to be told \n\"hey, block XYZHASH is incomplete and cannot be checked\", and then Alice \ndemands the full block from the attacker. But of course this makes it trivial \nto DoS Alice by giving her bogus incomplete-block claims and forcing her to \nuse the same bandwidth as a full node - which is a major problem if she lacks \nthe bandwidth to run a full node (presumably her reason for using SPV in the \nfirst place).\n\nLuke"
            }
        ],
        "thread_summary": {
            "title": "Holdup on Block Alerts / Fraud Proofs ?",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Luke Dashjr",
                "Paul Sztorc"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5147
        }
    },
    {
        "title": "[bitcoin-dev] BIP114 MAST updated",
        "thread_messages": [
            {
                "author": "Johnson Lau",
                "date": "2016-07-31T02:03:11",
                "message_text_only": "I have published a new version for BIP114 MAST. It's a bit more complicated with some new features:\n\n1. It allows different parties in a contract not to expose their scripts to each other until redemption.\n\n2. It includes a field to indicate the script language version so new opcodes could be added without touching the version byte nor the witness program.\n\nYou can find the updated BIP and code at:\n\nhttps://github.com/bitcoin/bips/blob/master/bip-0114.mediawiki\n\nhttps://github.com/jl2012/bitcoin/tree/bip114v2\n\n\nThe old version:\n\nhttps://github.com/bitcoin/bips/blob/7478ee3260c0d3c0cef39233931b307691764edc/bip-0114.mediawiki\n\nhttps://github.com/jl2012/bitcoin/tree/segwit_mast\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160730/cef1c311/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP114 MAST updated",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Johnson Lau"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 866
        }
    },
    {
        "title": "[bitcoin-dev] Bitcoin Core 0.13.0 release candidate 2 available",
        "thread_messages": [
            {
                "author": "Wladimir J. van der Laan",
                "date": "2016-07-31T13:44:12",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nBinaries for bitcoin Core version 0.13.0rc2 are available from:\n\n    https://bitcoin.org/bin/bitcoin-core-0.13.0/test.rc2/\n\nSource code can be found on github under the signed tag\n\n    https://github.com/bitcoin/bitcoin/tree/v0.13.0rc2\n\nThis is a release candidate for a new major version release, bringing new\nfeatures, bug fixes, as well as other improvements.\n\nPreliminary release notes for the release can be found at\n\n    https://github.com/bitcoin/bitcoin/blob/0.13/doc/release-notes.md\n\nRelease candidates are test versions for releases. When no critical problems\nare found, this release candidate will be tagged as 0.13.0.\n\nPlease report bugs using the issue tracker at github:\n\n    https://github.com/bitcoin/bitcoin/issues\n\nNotable changes since rc1:\n\n### Build system\n- - #8373 `1fe7f40` Fix OSX non-deterministic dmg (theuni)\n- - #8358 `cfd1280` Gbuild: Set memory explicitly (default is too low) (MarcoFalke)\n\n### GUI\n- - #8407 `45eba4b` Add dbcache migration path (jonasschnelli)\n\n### Wallet\n- - #8378 `ebea651` Move SetMinVersion for FEATURE_HD to SetHDMasterKey (pstratem)\n- - #8390 `73adfe3` Correct hdmasterkeyid/masterkeyid name confusion (jonasschnelli)\n- - #8206 `18b8ee1` Add HD xpriv to dumpwallet (jonasschnelli)\n- - #8389 `c3c82c4` Create a new HD seed after encrypting the wallet (jonasschnelli)\n\n### P2P protocol and network code\n- - #8408 `b7e2011` Prevent fingerprinting, disk-DoS with compact blocks (sdaftuar)\n\n### Consensus\n- - #8412 `8360d5b` libconsensus: Expose a flag for BIP112 (jtimon)\n\n### Mining\n- - #8362 `86edc20` Scale legacy sigop count in CreateNewBlock (sdaftuar)\n\n### Block and transaction handling\n- - #8381 `f84ee3d` Make witness v0 outputs non-standard (jl2012)\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAEBCgAGBQJXngBiAAoJEHSBCwEjRsmmS5kIAMFiXFua9ruR8Vwu1fNgnWTb\nX4tsNOdPScm7jwsFavcwygqZQlDNDURjcocQFcehHgEickBrk6eaplTuB4VJidPG\nAqw+nLrd6M//Ohy+7eke7aCg5/QV7poplM3glwow4gQfoSBvL0ywMEhWEzGL7EPH\nFH5pyY9o4QZw5wGdvMWxvYVTLPZkm0W2cSWCHZ0WgzWvTkZ7aMzSQ5F5TXPfjzED\nDNuQQRMm9H1H3LJkmWAwjCXLzKNMzjmefLujyEII388s6UoWnA1ufosqb1kMqL+h\nkuEelzef4cMBZEvHgfzsvlLmba2DLr7xhwudd3HK2NHSmO/wAUdhbQOQSts9NoY=\n=rN68\n-----END PGP SIGNATURE-----"
            }
        ],
        "thread_summary": {
            "title": "Bitcoin Core 0.13.0 release candidate 2 available",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Wladimir J. van der Laan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2234
        }
    },
    {
        "title": "[bitcoin-dev] Proposal: Hard fork opt-out bits",
        "thread_messages": [
            {
                "author": "Tom Harding",
                "date": "2016-07-31T18:01:18",
                "message_text_only": "Your thoughts are sought on this simple proposal to allow transaction\nauthors to restrict execution to fewer than all blockchain forks where\nthe transaction would otherwise be valid.\n\n\nProposal\n\nNode implementations select a bit from among the upper 8 bits of the\ntransaction version space to enforce as a hard fork opt-out bit.\n\nTo specify that a transaction NOT be mined by nodes that enforce a\nparticular bit, authors set that bit in the transaction version.\nOpt-out is enforced by consensus among nodes enforcing each bit.\n\nAn implementation will relay, process and mine transactions that opt out\nof other blockchain forks; just not those that opt out of its own fork.\n\n\nNotes\n\nExample: Via soft fork, all implementations may begin enforcing hard\nfork opt-out bit 30.  Post soft fork, setting this bit would make a\ntransaction invalid, unless a fork emerges that has stopped enforcing\nbit 30.\n\nExample: BIP109 implementations may stop enforcing bit 30 and begin\nenforcing bit 28 when the BIP109 hard fork is activated for a chain they\nare tracking.\n\nEnforcing more than one hard fork opt-out bit would imply that an\nimplementation is actively participating in building more than one\nblockchain fork, and therefore providing a way to opt out of each.\n\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 819 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160731/7b1a2154/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Hard fork opt-out bits",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Tom Harding"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1540
        }
    }
]