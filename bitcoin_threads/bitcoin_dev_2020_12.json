[
    {
        "title": "[bitcoin-dev] Out-of-band transaction fees",
        "thread_messages": [
            {
                "author": "eric at voskuil.org",
                "date": "2020-12-01T01:06:13",
                "message_text_only": "Hi Sebastian,\n\nIt's important to consider here that anonymity is the reason fees are incorporated into transactions. One must generally trust the party with whom one transacts. But since integral fees are paid to any miner, this does not apply to fees. In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:\n\n> Miners that included a transaction need a way to authenticate when claiming the bounty.\n\nIt is also the case that the \"bounty\" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.\n\nTotal transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's *possible* to spend and pay a fee with a single input and output. That is not the case with externalized fees.\n\ne\n\n-----Original Message-----\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On Behalf Of Sebastian Geisler via bitcoin-dev\nSent: Monday, November 30, 2020 3:03 PM\nTo: bitcoin-dev at lists.linuxfoundation.org\nSubject: [bitcoin-dev] Out-of-band transaction fees\n\nHi all,\n\nthe possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).\n\nOne such use case is sending UTXOs \"intact\". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.\nThese L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, \u2026). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.\n\nTaking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused \"toxic waste\"\ninevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as _no_ fee inputs had to be provided (assuming the inputs already have the right size).\n\nOut-of-band transaction \"accelerators\" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.\n\nImo the central questions are:\n * how to build such a out-of-band \"transaction bounty\" system\n * how to standardized it\n * how can the centralizing effects from it be mitigated\n\nImo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.\n\nEach such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent \"invoice\" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.\n\nMiners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).\n\nAny feedback is welcome :)\n\ntl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.\n\nBest,\nSebastian\n\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Sebastian Geisler",
                "date": "2020-12-01T14:19:56",
                "message_text_only": "Hi Eric,\n\n> In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:\n\nI'm not sure I follow, do you see a problem beyond the facts that miners\nwould need to authenticate somehow? This can be done in a privacy\npreserving way per block. I don't think transactions would need to\nchange in any way. The bounty-transaction link is upheld by a third\nparty service which the miners have to trust that it will pay out if the\ntransaction is included (not perfect, but a business decision they can\nmake).\n\n> It is also the case that the \"bounty\" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.\n> Total transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's *possible* to spend and pay a fee with a single input and output. That is not the case with externalized fees.\n\nI should have made this more clear, I don't imagine anyone to pay these\nfees with L1 transactions, but rather some L2 system like Lightning or a\nBTC backed chaumian token issued for that purpose by the bounty service\nprovider. Even Lightning would be far more private for the use cases I\ndescribed that don't allow fee deduction from inputs. But if one accepts\nmore counter party risk with e.g. some centrally pegged chaumian token\nit can be anonymous.\n\nI see that this might not be very useful today, but I imagine a future\nin which Bitcoin is mostly a settlement and reserve layer. This would\nmake it feasible to keep most UTXOs in common sizes. Only large, round\ntransactions happen on-chain, the rest can happen on L2. This would\nallow tumbling these already evenly-sized UTXOs on spend without toxic\nwaste if we can somehow tackle the fee payment problem. I know of the\nfollowing solutions:\n\n * everyone has to add a second UTXO per input\n * Someone is chosen fairly at random to pay the total fee\n * pay a service on L2 to add an input/output for fee payment\n * out-of-band L2 fee payments\n\nOnly L2 fee payments can hide who is involved in such a tumbling\noperation as additional fee inputs that get reused would indicate the\nsame entity was present in two tumbling operations. The out-of-band\napproach saves one input and one output and appears more general (e.g.\ncould be used like rbf).\n\nThis is also not a general solution for fee payments. In many cases it\nwill still be preferable to pay on-chain fees. But having the option to\navoid that in a standardized way could help some protocols imo.\n\nBest,\nSebastian\n\n\n> -----Original Message-----\n> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On Behalf Of Sebastian Geisler via bitcoin-dev\n> Sent: Monday, November 30, 2020 3:03 PM\n> To: bitcoin-dev at lists.linuxfoundation.org\n> Subject: [bitcoin-dev] Out-of-band transaction fees\n> \n> Hi all,\n> \n> the possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).\n> \n> One such use case is sending UTXOs \"intact\". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.\n> These L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, \u2026). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.\n> \n> Taking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused \"toxic waste\"\n> inevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as _no_ fee inputs had to be provided (assuming the inputs already have the right size).\n> \n> Out-of-band transaction \"accelerators\" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.\n> \n> Imo the central questions are:\n>  * how to build such a out-of-band \"transaction bounty\" system\n>  * how to standardized it\n>  * how can the centralizing effects from it be mitigated\n> \n> Imo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.\n> \n> Each such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent \"invoice\" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.\n> \n> Miners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).\n> \n> Any feedback is welcome :)\n> \n> tl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.\n> \n> Best,\n> Sebastian\n> \n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-01T15:49:49",
                "message_text_only": "Good morning Sebastian and e,\n\n> Hi Eric,\n>\n> > In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:\n>\n> I'm not sure I follow, do you see a problem beyond the facts that miners\n> would need to authenticate somehow? This can be done in a privacy\n> preserving way per block. I don't think transactions would need to\n> change in any way. The bounty-transaction link is upheld by a third\n> party service which the miners have to trust that it will pay out if the\n> transaction is included (not perfect, but a business decision they can\n> make).\n\nThere has to be an association of \"how much do I get if I include *this* particular transaction\" to \"*this* particular transaction\", so that the miners have an informed decision of how much they stand to earn.\nUnless fees are also standardized, this can be used to leak the same information (\"sombody offered this specific amount of money to the bounty server, and the bounty server associated this particular amount to this particular transaction\").\n\n\nMore concerningly, [a trusted third party is hard to get out of](https://nakamotoinstitute.org/trusted-third-parties/).\nIf there are only a few of them, it becomes easy to co-opt, and then a part of the mining infrastructure is now controllable from central points of failure.\nIf there are many of them, then evaluating which ones cheat and which ones do not will take a lot of effort, and the system as a whole may not provide benefits commensurate to the overall system cost in finding good third parties.\n\n\n> > It is also the case that the \"bounty\" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.\n> > Total transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's possible to spend and pay a fee with a single input and output. That is not the case with externalized fees.\n>\n> I should have made this more clear, I don't imagine anyone to pay these\n> fees with L1 transactions, but rather some L2 system like Lightning or a\n> BTC backed chaumian token issued for that purpose by the bounty service\n> provider. Even Lightning would be far more private for the use cases I\n> described that don't allow fee deduction from inputs. But if one accepts\n> more counter party risk with e.g. some centrally pegged chaumian token\n> it can be anonymous.\n\nSince such L2 mechanisms themselves are dependent on L1 and require a facility to bump up fees for e.g. commitment transactions in Lightning Network, this brings up the possibility of getting into a bootstrapping problem, where the security of L2 is dependent on the existence of a reliable fee-bumping mechanism at L1, but the fee-bumping mechanism at L1 is dependent on the security of L2.\nNot impossible, but such strange loops give me pause; I am uncertain if we have the tools to properly analyze such.\n\n>\n> I see that this might not be very useful today, but I imagine a future\n> in which Bitcoin is mostly a settlement and reserve layer. This would\n> make it feasible to keep most UTXOs in common sizes. Only large, round\n> transactions happen on-chain, the rest can happen on L2. This would\n> allow tumbling these already evenly-sized UTXOs on spend without toxic\n> waste if we can somehow tackle the fee payment problem. I know of the\n> following solutions:\n>\n> -   everyone has to add a second UTXO per input\n> -   Someone is chosen fairly at random to pay the total fee\n> -   pay a service on L2 to add an input/output for fee payment\n> -   out-of-band L2 fee payments\n>\n>     Only L2 fee payments can hide who is involved in such a tumbling\n>     operation as additional fee inputs that get reused would indicate the\n>     same entity was present in two tumbling operations. The out-of-band\n>     approach saves one input and one output and appears more general (e.g.\n>     could be used like rbf).\n>\n>     This is also not a general solution for fee payments. In many cases it\n>     will still be preferable to pay on-chain fees. But having the option to\n>     avoid that in a standardized way could help some protocols imo.\n>\n>     Best,\n>     Sebastian\n>\n>\n> > -----Original Message-----\n> > From: bitcoin-dev bitcoin-dev-bounces at lists.linuxfoundation.org On Behalf Of Sebastian Geisler via bitcoin-dev\n> > Sent: Monday, November 30, 2020 3:03 PM\n> > To: bitcoin-dev at lists.linuxfoundation.org\n> > Subject: [bitcoin-dev] Out-of-band transaction fees\n> > Hi all,\n> > the possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).\n> > One such use case is sending UTXOs \"intact\". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.\n> > These L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, \u2026). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.\n> > Taking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused \"toxic waste\"\n> > inevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as no fee inputs had to be provided (assuming the inputs already have the right size).\n> > Out-of-band transaction \"accelerators\" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.\n> > Imo the central questions are:\n> >\n> > -   how to build such a out-of-band \"transaction bounty\" system\n> > -   how to standardized it\n> > -   how can the centralizing effects from it be mitigated\n> >\n> > Imo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.\n> > Each such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent \"invoice\" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.\n> > Miners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).\n> > Any feedback is welcome :)\n> > tl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.\n> > Best,\n> > Sebastian\n> >\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-01T16:24:11",
                "message_text_only": "Good morning e, and Sebastian,\n\nSo it seems, the goals are the below:\n\n* Someone wants to pay a fee to get a transaction confirmed.\n* Miners want to know how much they earn if they confirm a transaction.\n* The one paying for the fee does not want to link its other coins to the transaction it wants confirmed.\n\nWould that be a fair restatement of the goal?\n\nIf so, it seems to me we can make a CoinJoin-like approach using only L1, and combine fees by a kind of FeeJoin.\n\nThe issue with linking is that if for example the one paying a fee to get a transaction confirmed wants to CPFP the transaction, it may need to take another UTXO it controls into the child transaction, thereby linking its \"another UTXO\" with the \"transaction it wants confirmed\".\n\nHowever, if multiple such individuals were to CoinJoin their transactions, the linking becomes much harder to trace.\n\nSo a possible mechanism, with a third-party that is trusted only to keep the service running (and cannot cheat the system and abscond with the fees and leave miners without money) would be:\n\n* The third-party service divides its service into fixed-feerate bins.\n* Clients select a preferred feerate bin they want to use.\n* For each client:\n  * Connects to the service by Tor to register a transaction it wants to have CPFPed.\n  * Connects to the service by a different Tor circuit to register a UTXO it will use to spend fees.\n* The server passes through the CPFPed outputs in the whole value.\n* The server deducts the fee from the fee-paying UTXO and creates an output with all the fees (CPFP output spend, UTXO input spend, CPFP output re-creation, UTXO output re-creation) deducted from the UTXO.\n* The server gives the resulting transaction to the clients.\n* The clients sign the transaction after checking that its interested CPFPed outputs and fee-paying UTXOs are present.\n\nThis results in a transaction with many CPFPed inputs and fee-paying UTXOs, and no easy way to link the latter with the former.\n\n* Miners and chain analysis cannot link them, as they see only the resulting tx.\n* The service cannot link them, as clients talk to them on two separate Tor connections.\n\nThe above is blatantly the Wasabi way of CoinJoining; using the JoinMarket way of CoinJoining should be possible as well, and is left as an exercise to the reader.\n\nNow, you have mentioned a number of times that you believe Bitcoin will eventually be a settlement layer, and somehow link this with standardized UTXO sizes.\nBut I think the end goal should be:\n\n* To improve Bitcoin blockchain layer privacy.\n\nIt should not matter how we achieve this, whether it involves standardized UTXO sizes or not; if you want to use this solution, you need to present a good reason why this is the best solution for Bitcoin privacy, and better than other solutions.\n\nFor example, the JoinMarket way of CoinJoining does not require any particular standardized UTXO size.\nThe upcoming SwapMarket that Chris Belcher is working on, also does not require such a standardized UTXO size, as it is based as well on the JoinMarket technique, where the client can select whatever sizes it wants.\nWhy should the Bitcoin ecosystem adopt a strict schedule of UTXO sizes for privacy, if apparently JoinMarket and SwapMarket can improve privacy without this?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Sebastian Geisler",
                "date": "2020-12-01T19:14:26",
                "message_text_only": "Hi ZmnSCPxj,\n\nthank you for your detailed comments. I agree that the centralization\nrisk is a big problem. I didn't fully take into account how hard it\nmight be to distinguish honest service providers, which makes that\nproblem so much worse. I think I'll not pursue this approach for that\nreason. While such a system can't be prevented I don't need to encourage it.\n\nI might look into the \"pay someone to add their UTXO to a tx for fees\nand give them back the remainder\" approach though, it doesn't seem as\nhazardous and might even be possible to do in a decentralized fashion.\n\n> Now, you have mentioned a number of times that you believe Bitcoin will eventually be a settlement layer, and somehow link this with standardized UTXO sizes.\n> But I think the end goal should be:\n> \n> * To improve Bitcoin blockchain layer privacy.\n> \n> It should not matter how we achieve this, whether it involves standardized UTXO sizes or not; if you want to use this solution, you need to present a good reason why this is the best solution for Bitcoin privacy, and better than other solutions.\n\nI completely agree.\n\n> For example, the JoinMarket way of CoinJoining does not require any particular standardized UTXO size.\n> The upcoming SwapMarket that Chris Belcher is working on, also does not require such a standardized UTXO size, as it is based as well on the JoinMarket technique, where the client can select whatever sizes it wants.\n> Why should the Bitcoin ecosystem adopt a strict schedule of UTXO sizes for privacy, if apparently JoinMarket and SwapMarket can improve privacy without this?\n\nThese efforts are great! Yet all CoinJoin based protocols I have seen\n(mostly academic ones tbh, that provide strong guarantees) have some\namount of overhead in the form of creating more UTXOs and bigger\ntransactions than minimally possible or even \"toxic waste\" we don't know\nwhat to do with. As far as I understand it there's now way around that\nwithout relaxing anonymity guarantees. Maybe I'm not up to date in that\nregard.\n\nI also think that the privacy properties/the actual anonymity set of\nunequal output size CoinJoins (i.e. knapsack mixing) is not as well\nunderstood as for evenly-sized output CoinJoins. If we are only talking\nabout user-defined CoinJoin output sizes it comes down to efficiency\nagain. This will nearly always lead to change and not many parties will\nbe interested in the particular output size so you even need to pay them\nto participate.\n\nPlease bear with me as the following part is _very_ speculative:\n\nI believe that if Bitcoin becomes mainstream (I take no stance whether\nthis is good or not, but consider it a possibility) transaction prices\nare bound to increase dramatically, which would make such protocols\nuneconomical. This also means most people will rely on some L2\ntechnology. But the fees might even make Lightning nodes uneconomical\nfor the majority of people. So if we are lucky federated L2 systems, or\nif we are unlucky centralized ones, will play an important role imo.\n\nIn such an environment, where on-chain transactions are mostly used as\nsettlements between somewhat big players, having (multiple tiers of)\nevenly sized UTXOs makes a lot of sense. You don't need exact valued\ntransfers and get free/cheaper than free and effective mixing on spends\nif you just combine your transactions.\n\nSo imo the pros of this technique are:\n * as simple as possible (easy to assess exact anonymity set)\n * cheap, so it could be made a default, leading to a large anon set\n\nwhile the cons are:\n * only makes sense when exact values aren't important (e.g. L2 funding)\n * needs fee hacks\n\nI don't want to derail this any further. I agree that my initial idea\nbears too great risks of regulatory capture. While I find the\nevenly-sized UTXO idea intriguing I'd be even happier about a\narbitrary-amount scheme that gives the same strong assurances in an\n_efficient_ manner, I just haven't seen a way to achieve this so far.\n\nBest,\nSebastian"
            }
        ],
        "thread_summary": {
            "title": "Out-of-band transaction fees",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Sebastian Geisler",
                "eric at voskuil.org"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 27962
        }
    },
    {
        "title": "[bitcoin-dev] Progress on bech32 for future Segwit Versions (BIP-173)",
        "thread_messages": [
            {
                "author": "Pieter Wuille",
                "date": "2020-12-05T22:59:17",
                "message_text_only": "> On Wednesday, October 7, 2020 5:21 PM, Rusty Russell via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > I propose an alternative to length restrictions suggested by\n> > Russell in https://github.com/bitcoin/bips/pull/945: use the\n> > https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,\n> > unless the first byte is 0.\n>\n> Hi all,\n>\n> starting a slight side-thread here.\n\nAnother update, and a longer write-up.\n\n\nIntroduction\n------------\n\nBech32's checksum algorithm was designed to be strong against substitution\nerrors, but it also provides some protection against more general classes of\nerrors. The final constant M that is XOR'ed into the checksum influences that\nprotection. BIP173 today uses M=1, but it is now known that this has a\nweakness: if the final character is a \"p\", any number of \"q\" characters can be\ninserted or erased right before it, without invalidating the checksum.\n\nAs it was recognized that other constants do not have this issue, the obvious\nquestion is whether this is the only possible type of weakness, and if not, if\nthere is an optimal constant to use that minimizes the largest number of\nweaknesses.\n\nSince my last mail I've realized that it is actually possible to analyse the\nbehavior of these final constants under a wide variety of error classes\n(substitutions, deletions, insertions, swaps, duplications) programatically.\nGreg Maxwell and I have used this to perform an exhaustive analysis of certain\nerror patterns for all 2^30 possible M values, selected a number of criteria\nto optimize for, and conclude that we should use as constant:\n\n  M = 0x2bc830a3\n\nThe code used to do this analysis, as well as the code used to verify some\nexpected properties of the final result, and more, can be found on\nhttps://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e\n\nSee results_final.txt to see how this constant compares with the previously\nsuggested constants 1, 0x3fffffff, and 0x3fefffff.\n\nProperties\n----------\n\nIf we define an error as a deletion of one position, a swap of adjacent\npositions, a substitution in a specific position with a random character, an\ninsertion of one random character in a specific position, or a duplication of\nthe character in a specific position, then this M constant above gives us the\nfollowing properties:\n\n* For generic HRPs and errors that don't affect the first 6 data characters,\n  or alternatively averaged over all HRPs (see details futher):\n  * Always detected:\n    * (P) Up to 4 substitution errors (true for any constant).\n    * (Q) Any valid code with the new constant, fed without modification to\n          software that uses the old constant 1 (true for any constant).\n  * Any error pattern has failure to detect probability <= 2^-30:\n    * (L) Any number of errors restricted to a single window of up to 4\n          characters.\n    * (B) Up to two errors restricted to a window of up to 68 characters.\n    * (D) Any one error made to a valid code with the new constant, and fed to\n          software that uses the old constant 1\n  * Most error patterns have probability <= 2^-30:\n    * (C) Up to two errors in general: out of 23926796 such error patterns,\n          0.0040% have probability 2^-25.\n    * (N) Up to three errors restricted to a window of up to 69 characters:\n          out of 284708444 such patterns, 0.033% have probability 2^-25.\n    * (O) Up to three errors in general: out of 295744442 such error patterns,\n          0.034% have probability 2^-25; 0.000065% have probability 2^-20.\n    * (G) Up to two errors made to a valid code with the new constant, and fed\n          to software that uses the old constant 1: out of 2831622 such error\n          patterns, 0.048% have probability 2^-25.\n\n* Specifically for the bc1 HRP, with the BIP173 length restrictions:\n  * Always detected:\n    * (R) Up to 4 substitution errors (true for any constant).\n    * (A) Up to 3 substitution errors made to a valid code with the new\n          constant, and fed to software that uses the old constant 1.\n  * Any error pattern has failure to detect probability <= 2^-30:\n    * (E) Any one error.\n    * (F) Any one error made to a valid code with the new constant, and fed to\n          software that uses the old constant 1.\n    * (H) Up to two errors restricted to a window of 28 characters.\n  * Most error patterns have probability <= 2^-30:\n    * (J) Up to two errors in general: out of 455916 such error patterns,\n          0.039% have probability 2^-25; 0.0053% have 2^-20.\n    * (K) Any number of errors restricted to a window of 4 characters: out of\n          5813139 such error patterns, 0.0016% have probability 2^-25.\n    * (M) Up to three errors: out of 50713466 such error patterns, 0.078% have\n          probability 2^-25; 0.00063% have 2^-20.\n    * (I) Up to two errors made to a valid code with the new constant, and fed\n          to software that uses the old constant 1: out of 610683 such error\n          patterns, 0.092% have probability 2^-25; 0.00049% have probability\n          2^-20.\n\nTo give an idea of what these probabilities mean, consider the known BIP173\ninsertion issue. It admits an error pattern of 1 error (insertion in\npenultimate position) that has a failure to detect probability of 2^-10:\nit requires the final character to be 'p', and the inserted character to be\n'q'. Assuming those are both random, we have a chance of 1 in 32*32 to hit it.\nNote that the choice of *what* the error pattern is (whether it's insertion,\nand where) isn't part of our probabilities: we try to make sure that *every*\npattern behaves well, not just randomly chosen ones, because presumably humans\nmake some kinds of errors more than others, and we don't know which ones.\n\nAll the analyzed patterns above are guaranteed to be detected with probability\n2^-20 or better (and most are 2^-30). Of course, if we'd search for even\nlarger classes of errors, say any 4 independent errors of any type, we would\nprobably discover patterns with worse probabilities, but at that point the\nprobability of the pattern itself being hit should be taken into account.\n\nThe selection was made based on these same properties:\n* Start with the set of all 2^30 constants.\n* The generic properties (L), (B), (D), (C), (N), (O), and (G) were selected\n  for by rejecting all constants that left any worse error patterns (e.g.\n  all codes for which patterns matching (N) existed with failure probability\n  above 2^-25 were removed). All these restrictions are as strong as they\n  can be: making them over longer strings, wider windows, or more errors with\n  the same restrictions removes all remaining constants. This leaves us with\n  just 12054 acceptable constants.\n* The same was then done for the bc1/BIP173 specific properties (A), (E), (J),\n  (F), (H), (K), (M), and (I). This reduces the set further to 79 acceptable\n  constants. The full analysis output for all of these can be found in\n  output.txt.\n* Finally, the constant with the minimal number of worst-probability patterns\n  was chosen for the generic property (N). The single constant 0x2bc830a3\n  remains.\n* This solution and a few of its expected properties were then validated using\n  a simple program that makes random errors (see the monte_carlo.py file).\n\n\nTechnical details\n-----------------\n\nFor the purpose of this analysis, define an \"error pattern\" as a starting\nlength (of a valid string consisting of otherwise randomly chosen characters)\ncombined with a sequence of the following (in this order):\n* 0 or more deletions of characters at specific positions (without\n  constraining what those characters are)\n* 0 or more swaps of characters at specific positions with the character\n  following it\n* 0 or more substitutions of characters at specific positions with a uniformly\n  randomly selected character\n* 0 or more insertions of uniformly randomly selected characters at specific\n  positions\n* 0 or more duplications of characters at specific positions (including\n  duplications of characters inserted/substituted in the previous steps)\n\nExamples:\n* \"Start with a random valid 58 character string, remove the 17th character,\n  swap the 11th character with the 12th character, and insert a random\n  character in the 24th position\" is an error pattern.\n* \"Replace the 17th through 24th characters in a 78 character string with\n  'aardvark'\" is not an error pattern, because substituted characters have to\n  be random, and can't be specific values.\n\nGiven such a pattern, assign variable names to every input character, and to\nevery inserted/substituted character. For example, the pattern \"Start with\na 6 character string, delete the 1st character, swap the 2nd and 3rd\ncharacter, and insert a random character between those\" would be represented\nas [v0 v1 v2 v3 v4 v5] and [v1 v3 v6 v2 v4 v5]. Treat these variables as\nelements of GF(32), and write out the equations that both the first and second\nlist have a valid checksum. Due to the fact that BCH codes are linear, this is\njust a linear set of equations over GF(32), and we can use Gaussian\nelimination to find the size of the solution space. If the input and output\nare the same length, we need to subtract the number of solutions for which the\ninput and output are exactly the same, which is easy to find with another set\nof equations. Now compute the ratio of this number divided by (32^numvars /\n32^6), where the 32^6 is due to the precondition that the input string is\nvalid. This gives us the probability of failure, assuming input and output are\nrandom, apart from the known relation between the two, and the fact that both\nare valid.\n\nThis technique has an important limitation: it can only reason about randomly-\nchosen input strings, and the presence of the HRP and version numbers at the\nstart violates that assumption. These are not random, and we're forced to\nmake one of these concessions:\n1) Ignore the problem, and treat the HRP as random. This lets us derive\n   properties that hold over all potential HRPs on average, but will thus fail\n   to account for the possibility that for a small numbers of potential HRPs\n   some error patterns may exist that behave worse. For technical reasons,\n   this averaging makes all constants behave identically for error patterns\n   that don't change the length of the string. Given that substitution/swap\n   only errors are already dealt with well due to the BCH design this is\n   perhaps not too important. One exception is frame-shifting errors (a\n   deletion in one place compensated with an insertion in another place).\n2) Restrict analysis to error patterns that don't affect the first 6 actual\n   characters. Doing so \"masks\" the effect of the HRP completely.\n3) Do analysis for specific HRPs only, allowing much more accurate statements,\n   but HRP-specific ones that may not hold for every HRP.\n\nOur final selection primarily optimizes for 1) and 2) as those benefit all\npotential uses of the encoding, but do optimize for 3) the \"bc1\" prefix\nspecifically (and the BIP173 length restriction) as a tiebreaker.\n\nThe code for this can be found under the link above, in const_analysis.cpp.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-12-05T23:10:51",
                "message_text_only": "On Friday, November 6, 2020 11:49 AM, Mike Schmidt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Well I sure picked a bad couple weeks to volunteer to send a bunch of Bitcoin test transactions...\n>\n> While I tested less than I would have liked, there are some notable results:\n\nI think these results really show there is no reason to try to maintain the old-software-can-send-to-future-segwit-versions property, given that more than one not just didn't support it, but actually sent coins into a black hole.\n\nThus, I agree with Rusty that we should change the checksum for v1+ unconditionally. That also means that old senders are protected from the insertion issue (by failing, as we can guarantee that new-checksum addresses, even after a few errors, are invalid to old software).\n\nI've sent another mail in this thread with details, but the TL;DR is that we should use the constant M=0x2bc830a3 rather than 0x3fffffff as previous suggested. More information on https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e.\n\nAbsent objections, I'll write up a BIP soon.\n\nCheers,\n\n--\nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201205/32d286a4/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2020-12-06T13:04:53",
                "message_text_only": "On Sat, Dec 05, 2020 at 11:10:51PM +0000, Pieter Wuille via bitcoin-dev wrote:\n> I think these results really show there is no reason to try to\n> maintain the old-software-can-send-to-future-segwit-versions property,\n> given that more than one not just didn't support it, but actually sent\n> coins into a black hole.\n\nI don't think this is a good criteria to use for making a decision.  We\nshouldn't deny users of working implementations the benefit of a feature\nbecause some other developers didn't implement it correctly.\n\n> Thus, I agree with Rusty that we should change the checksum for v1+\n> unconditionally. \n\nI disagreed with Rusty previously and he proposed we check to see how\ndisruptive an address format change would be by seeing how many wallets\nalready provide forward compatibility and how many would need to be\nupdated for taproot no matter what address format is used.  I think that\ninstead is a good criteria for making a decision.\n\nI understand the results of that survey to be that only two wallets\ncorrectly handled v1+ BIP173 addresses.  One of those wallets is Bitcoin\nCore, which I personally believe will unhesitatingly update to a new\naddress format that's technically sound and which has widespread support\n(doubly so if it's just a tweak to an already-implemented checksum\nalgorithm).\n\nGiven that, I also now agree with changing the checksum for v1+.\n\nThanks,\n\n-Dave\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201206/415223da/attachment.sig>"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-12-06T20:43:49",
                "message_text_only": "\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Sunday, December 6, 2020 5:04 AM, David A. Harding <dave at dtrt.org> wrote:\n\n> On Sat, Dec 05, 2020 at 11:10:51PM +0000, Pieter Wuille via bitcoin-dev wrote:\n>\n> > I think these results really show there is no reason to try to\n> > maintain the old-software-can-send-to-future-segwit-versions property,\n> > given that more than one not just didn't support it, but actually sent\n> > coins into a black hole.\n>\n> I don't think this is a good criteria to use for making a decision. We\n> shouldn't deny users of working implementations the benefit of a feature\n> because some other developers didn't implement it correctly.\n>\n> > Thus, I agree with Rusty that we should change the checksum for v1+\n> > unconditionally.\n>\n> I disagreed with Rusty previously and he proposed we check to see how\n> disruptive an address format change would be by seeing how many wallets\n> already provide forward compatibility and how many would need to be\n> updated for taproot no matter what address format is used. I think that\n> instead is a good criteria for making a decision.\n>\n> I understand the results of that survey to be that only two wallets\n> correctly handled v1+ BIP173 addresses. One of those wallets is Bitcoin\n> Core, which I personally believe will unhesitatingly update to a new\n> address format that's technically sound and which has widespread support\n> (doubly so if it's just a tweak to an already-implemented checksum\n> algorithm).\n\nHi Dave,\n\nYou're right to point out there is nuance I skipped over.\n\nLet's look at the behavior of different classes of software/services that exist today when trying to send to v1+ addresses:\n\n(A) Supports sending to v1+ today\n  * Old proposal: works, but subject to bech32 insertion issue\n  * New proposal: fails\n(B) Fails to send to v1+ today\n  * Old proposal: fails\n  * New proposal: fails\n(C) Incorrectly sends to v1+ today\n  * Old proposal: lost funds\n  * New proposal: fails\n\nSo the question is how the support for sending to v1+ in (a) software weighs up against protecting both (a) from the insertion issue, and (c) from lost funds. I do think (c) matters in this equation - people may choose to avoid adopting v1+ witnesses if it were to be known that some senders out there would misdirect funds. But the fact that (a) is small also means there is very little to gain from the old proposal.\n\nSo perhaps I should have formulated it as: the small number of v1+ compatible senders today (regardless of the reasons for that) shows how futile the attempt to have one address type for all witness versions was, and the fact that there are even some who misdirect(ed) funds is the final nail in the coffin. Changing the checksum unconditionally gives us a new attempt at that.\n\n> Given that, I also now agree with changing the checksum for v1+.\n\nGreat.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Ryan Grant",
                "date": "2020-12-08T17:39:23",
                "message_text_only": "It looks like a good strategy for a bech32 library that is external to\nBitcoin Core would be:\n\n  - Default to the new M, under the same bech32 brand.\n\n  - Provide an interface to explicitly use both M=1 and M=0x2bc830a3.\n\n  - If decoding fails, throw an error; but in constructing that error\n    inform whether the other M would have succeeded.\n\n  - Provide an interface for a BIP173 implementation to peek at the\n    witness version byte of the data part, which may also involve\n    sanity-checking that byte for errors using a BIP173-specific\n    understanding of the appropriate checksum.\n\n    Return values for this special interface might currently be:\n      \"it's version zero, based on a clean decoding\",\n      \"it's version one,  based on a clean decoding\",\n      \"it's version zero, based on an auto-corrected byte\",\n      \"it's version one,  based on an auto-corrected byte\",\n      \"no result, due to a decoding error on this byte\", and\n      \"too many errors to say anything more about decoding\".\n\nAlthough the reasoning is clear for doing so, looking into the data\nthat is supposed to be checksummed to determine which checksum to use\nis not very elegant.  There are two trips into a bech32 library for a\nBIP173 decoding, and an indeterminate result on the version byte would\nrequire heuristics for deciding what to do with the rest of the data\npart to even advise the user on the error.  Because of this, as a\nlibrary writer I would be tempted to auto-correct the witness version\nbyte (against the \"SHOULD NOT\" advice of BIP173's current version), if\nit were the only one corrupted, as per the example return values\nabove.  Please advise.\n\nSome of the libraries that will be contemplating these steps include:\n  https://github.com/topics/bech32?o=desc&s=stars\n\nHere are three existing uses of bech32 that are external to Bitcoin Core:\n\n  https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md\n  https://github.com/btcontract/lnurl-rfc\n  https://github.com/bitcoin/bips/blob/master/bip-0136.mediawiki\n\nOf the above, I think BIP136 can be unconditionally moved to\nM=0x2bc830a3 due to having little legacy burden."
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-12-18T02:02:04",
                "message_text_only": "On Tuesday, December 8, 2020 9:39 AM, Ryan Grant <bitcoin-dev at rgrant.org> wrote:\n\n> It looks like a good strategy for a bech32 library that is external to\n> Bitcoin Core would be:\n>\n> -   Default to the new M, under the same bech32 brand.\n> -   Provide an interface to explicitly use both M=1 and M=0x2bc830a3.\n> -   If decoding fails, throw an error; but in constructing that error\n>     inform whether the other M would have succeeded.\n>\n> -   Provide an interface for a BIP173 implementation to peek at the\n>     witness version byte of the data part, which may also involve\n>     sanity-checking that byte for errors using a BIP173-specific\n>     understanding of the appropriate checksum.\n\nI think there are two possible interfaces that make sense:\n\n- Have the caller explicitly specify whether they want bech32 or bech32m (which someone - I think Rusty? - started using in reference to this new code and I'm going to adopt now).\n\n- Have the bech32 decoding function return a tristate (failed, valid as bech32, valid as bech32m). No string is ever valid as both, so there is no loss of information here.\n\nThe former is a bit cleaner, and also the only real choice if error location hinting is desired. The second is more efficient if decoding twice is a performance concern.\n\nCheers,\n\n--\nPieter"
            }
        ],
        "thread_summary": {
            "title": "Progress on bech32 for future Segwit Versions (BIP-173)",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Ryan Grant",
                "Pieter Wuille",
                "David A. Harding"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 20383
        }
    },
    {
        "title": "[bitcoin-dev] BIP - Automated and Secure Communication",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2020-12-06T18:20:02",
                "message_text_only": "Hello Everyone,\n\nI know there have been lot of controversial and heated discussions involving Samourai in past. Ignoring everything including the tweets in which Samourai team mentioned no interest in proposing a BIP related to automated and secure communication used in Soroban, I wanted to know if enough people would be interested in a BIP because it may help other bitcoin projects in future.\n\nTweets:\u00a0https://twitter.com/SamouraiWallet/status/1334977957157367810 <https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19>\n\nhttps://twitter.com/SamouraiDev/status/1335103101188104194 <https://twitter.com/SamouraiDev/status/1335103101188104194?s=19>\n\nBen also tweeted that a BIP would make sense:\u00a0https://twitter.com/benthecarman/status/1334977096079306753 <https://twitter.com/benthecarman/status/1334977096079306753?s=19>\n\nI think we should keep all the controversial things aside and do everything that helps Bitcoin. It's mentioned in the medium article that it can help other projects like joinmarket, coinswap, snickr etc.\n\nhttps://link.medium.com/uBvIJUSLQbb\n\nThe source code for a client library in Java is available here https://code.samourai.io/wallet/soroban-client-java and the source code for the Go based server component is available here https://code.samourai.io/wallet/samourai-soroban\n\nLet me know if a BIP for such implementation to be used by other bitcoin projects makes sense and if anyone willing to help me in creating a BIP.\n\nThanks.\n\n-- Prayank\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201206/64b59e21/attachment.html>"
            },
            {
                "author": "yanmaani at cock.li",
                "date": "2020-12-06T19:14:13",
                "message_text_only": "The reason Samourai did not propose a BIP is that that was not a \nproposal to improve the Bitcoin protocol.\n\nYou could write a specification for it, but this mailing list is \nprobably the wrong venue.\n\nOn 2020-12-06 18:20, Prayank via bitcoin-dev wrote:\n> Hello Everyone,\n> \n> I know there have been lot of controversial and heated discussions\n> involving Samourai in past. Ignoring everything including the tweets\n> in which Samourai team mentioned no interest in proposing a BIP\n> related to automated and secure communication used in Soroban, I\n> wanted to know if enough people would be interested in a BIP because\n> it may help other bitcoin projects in future.\n> \n> Tweets: https://twitter.com/SamouraiWallet/status/1334977957157367810\n> [1]\n> \n> https://twitter.com/SamouraiDev/status/1335103101188104194 [2]\n> \n> Ben also tweeted that a BIP would make sense:\n> https://twitter.com/benthecarman/status/1334977096079306753 [3]\n> \n> I think we should keep all the controversial things aside and do\n> everything that helps Bitcoin. It's mentioned in the medium article\n> that it can help other projects like joinmarket, coinswap, snickr etc.\n> \n> https://link.medium.com/uBvIJUSLQbb\n> \n> The source code for a client library in Java is available here\n> https://code.samourai.io/wallet/soroban-client-java and the source\n> code for the Go based server component is available here\n> https://code.samourai.io/wallet/samourai-soroban\n> \n> Let me know if a BIP for such implementation to be used by other\n> bitcoin projects makes sense and if anyone willing to help me in\n> creating a BIP.\n> \n> Thanks.\n> \n> -- Prayank\n> \n> Links:\n> ------\n> [1] https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19\n> [2] https://twitter.com/SamouraiDev/status/1335103101188104194?s=19\n> [3] https://twitter.com/benthecarman/status/1334977096079306753?s=19\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-12-06T19:36:48",
                "message_text_only": "Anything that makes sense to coordinate between different programs is BIP \nmaterial, not just core Bitcoin protocol...\n\n\nOn Sunday 06 December 2020 19:14:13 yanmaani--- via bitcoin-dev wrote:\n> The reason Samourai did not propose a BIP is that that was not a\n> proposal to improve the Bitcoin protocol.\n>\n> You could write a specification for it, but this mailing list is\n> probably the wrong venue.\n>\n> On 2020-12-06 18:20, Prayank via bitcoin-dev wrote:\n> > Hello Everyone,\n> >\n> > I know there have been lot of controversial and heated discussions\n> > involving Samourai in past. Ignoring everything including the tweets\n> > in which Samourai team mentioned no interest in proposing a BIP\n> > related to automated and secure communication used in Soroban, I\n> > wanted to know if enough people would be interested in a BIP because\n> > it may help other bitcoin projects in future.\n> >\n> > Tweets: https://twitter.com/SamouraiWallet/status/1334977957157367810\n> > [1]\n> >\n> > https://twitter.com/SamouraiDev/status/1335103101188104194 [2]\n> >\n> > Ben also tweeted that a BIP would make sense:\n> > https://twitter.com/benthecarman/status/1334977096079306753 [3]\n> >\n> > I think we should keep all the controversial things aside and do\n> > everything that helps Bitcoin. It's mentioned in the medium article\n> > that it can help other projects like joinmarket, coinswap, snickr etc.\n> >\n> > https://link.medium.com/uBvIJUSLQbb\n> >\n> > The source code for a client library in Java is available here\n> > https://code.samourai.io/wallet/soroban-client-java and the source\n> > code for the Go based server component is available here\n> > https://code.samourai.io/wallet/samourai-soroban\n> >\n> > Let me know if a BIP for such implementation to be used by other\n> > bitcoin projects makes sense and if anyone willing to help me in\n> > creating a BIP.\n> >\n> > Thanks.\n> >\n> > -- Prayank\n> >\n> > Links:\n> > ------\n> > [1] https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19\n> > [2] https://twitter.com/SamouraiDev/status/1335103101188104194?s=19\n> > [3] https://twitter.com/benthecarman/status/1334977096079306753?s=19\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            }
        ],
        "thread_summary": {
            "title": "BIP - Automated and Secure Communication",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "yanmaani at cock.li",
                "Luke Dashjr",
                "Prayank"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6208
        }
    },
    {
        "title": "[bitcoin-dev] New PSBT version proposal",
        "thread_messages": [
            {
                "author": "Andrew Chow",
                "date": "2020-12-09T22:25:37",
                "message_text_only": "Hi All,\n\nI would like to propose a new PSBT version that addresses a few \ndeficiencies in the current PSBT v0. As this will be backwards \nincompatible, a new PSBT version will be used, v1.\n\nThe primary change is to truly have all input and output data for each \nin their respective maps. Instead of having to parse an unsigned \ntransaction and lookup some data from there, and other data from the \ncorrect map, all of the data for an input will be contained in its map. \nDoing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version. \nThus I propose that the following fields be added:\n\nGlobal:\n* PSBT_GLOBAL_TX_VERSION = 0x02\n \u00a0 * Key: empty\n \u00a0 * Value: 32-bit little endian unsigned integer for the transaction \nversion number. Must be provided in PSBT v1 and omitted in v0.\n* PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit little endian unsigned integer for the preferred \ntransaction lock time. Must be omitted in PSBT v0. May be provided in \nPSBT v1, assumed to be 0 if not provided.\n* PSBT_GLOBAL_INPUT_COUNT = 0x04\n \u00a0 * Key: empty\n \u00a0 * Value: Compact size unsigned integer. Number of inputs in this \nPSBT. Must be provided in PSBT v1 and omitted in v0.\n* PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n \u00a0 * Key: empty\n \u00a0 * Value: Compact size unsigned integer. Number of outputs in this \nPSBT. Must be provided in PSBT v1 and omitted in v0.\n\nInput:\n* PSBT_IN_PREVIOUS_TXID = 0x0e\n \u00a0 * Key: empty\n \u00a0 * Value: 32 byte txid of the previous transaction whose output at \nPSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and \nomitted in v0.\n* PSBT_IN_OUTPUT_INDEX = 0x0f\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit little endian integer for the index of the output \nbeing spent. Must be provided in PSBT v1 and omitted in v0.\n* PSBT_IN_SEQUENCE = 0x0f\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit unsigned little endian integer for the sequence \nnumber. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed \nto be max sequence (0xffffffff) if not provided.\n* PSBT_IN_REQUIRED_LOCKTIME = 0x10\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit unsigned little endian integer for the lock time that \nthis input requires. Must be omitted in PSBT v0. May be provided in PSBT \nv1, assumed to be 0 if not provided.\n\nOutput:\n* PSBT_OUT_VALUE = 0x03\n \u00a0 * Key: empty\n \u00a0 * Value: 64-bit unsigned little endian integer for the output's \namount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n* PSBT_OUT_OUTPUT_SCRIPT = 0x04\n \u00a0 * Key: empty\n \u00a0 * Value: The script for this output. Otherwise known as the \nscriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n\nThis change allows for PSBT to be used in the construction of \ntransactions. With these new fields, inputs and outputs can be added as \nneeded. One caveat is that there is no longer a unique transaction \nidentifier so more care must be taken when combining PSBTs. \nAdditionally, adding new inputs and outputs must be done such that \nsignatures are not invalidated. This may be harder to specify.\n\nAn important thing to note in this proposal are the fields \nPSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin \ntransaction only has a single locktime yet a PSBT may have multiple \nlocktimes. To choose the locktime for the transaction, finalizers must \nchoose the maximum of all of the *_LOCKTIME fields. \nPSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those \ninvolving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to \nbe set. This field allows finalizers to choose a locktime that is high \nenough for all inputs without needing to understand the scripts \ninvolved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if \nno inputs require a particular locktime.\n\nAs these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1 \nneeds the version number bump to enforce backwards incompatibility. \nHowever once the inputs and outputs of a PSBT are decided, a PSBT could \nbe \"downgraded\" back to v0 by creating the unsigned transaction from the \nabove fields, and then dropping these new fields.\n\nIf the list finds that these changes are reasonable, I will write a PR \nto modify BIP 174 to incorporate them.\n\nThanks,\nAndrew Chow"
            },
            {
                "author": "Sanket Kanjalkar",
                "date": "2020-12-10T11:28:23",
                "message_text_only": ">\n> The primary change is to truly have all input and output data for each  in\n> their respective maps\n\n1) +1. It would be really great to have a complete map per input/output\nthat does not require an annoying lookup to a global field.\n\nA Bitcoin transaction only has a single locktime yet a PSBT may have\n> multiple lock times.\n\n2) One other thing, the per input timelock also helps in detecting whether\nthe transaction contains a mix of block-based\ntimelocks and height based timelocks. Recall that such inputs can't be\nspent together under the same nLocktime.\n\n3) Finally, one last thing which I noted while implementing a generic\nfinalizer for Miniscript is the restriction on sighashType.\n>From the BIP\n\n> Signatures for this input must use the sighash type, finalizers must fail\n> to finalize inputs which have signatures that do not match the specified\n> sighash type. Signers who cannot produce signatures with the sighash type\n> must not provide a signature.\n\nIs such a restriction necessary? If the purpose is to only suggest signer\nwhich sighashType to use, then I think the finalizer\nshould not reject those. Along those lines, we can also mark with\nsuggestions for the type of nlockTime(block vs height) that\nshould be used. With such suggestions, input parties can decide which\nbranches in the satisfaction they should prefer and\nsign with the corresponding signatures. Note that this purpose is different\nfrom the stated purpose of\nPSBT_GLOBAL_PREFERRED_LOCKTIME.\n\nCheers,\nSanket\n\nOn Wed, Dec 9, 2020 at 4:33 PM Andrew Chow via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi All,\n>\n> I would like to propose a new PSBT version that addresses a few\n> deficiencies in the current PSBT v0. As this will be backwards\n> incompatible, a new PSBT version will be used, v1.\n>\n> The primary change is to truly have all input and output data for each\n> in their respective maps. Instead of having to parse an unsigned\n> transaction and lookup some data from there, and other data from the\n> correct map, all of the data for an input will be contained in its map.\n> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.\n> Thus I propose that the following fields be added:\n>\n> Global:\n> * PSBT_GLOBAL_TX_VERSION = 0x02\n>    * Key: empty\n>    * Value: 32-bit little endian unsigned integer for the transaction\n> version number. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n>    * Key: empty\n>    * Value: 32 bit little endian unsigned integer for the preferred\n> transaction lock time. Must be omitted in PSBT v0. May be provided in\n> PSBT v1, assumed to be 0 if not provided.\n> * PSBT_GLOBAL_INPUT_COUNT = 0x04\n>    * Key: empty\n>    * Value: Compact size unsigned integer. Number of inputs in this\n> PSBT. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n>    * Key: empty\n>    * Value: Compact size unsigned integer. Number of outputs in this\n> PSBT. Must be provided in PSBT v1 and omitted in v0.\n>\n> Input:\n> * PSBT_IN_PREVIOUS_TXID = 0x0e\n>    * Key: empty\n>    * Value: 32 byte txid of the previous transaction whose output at\n> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and\n> omitted in v0.\n> * PSBT_IN_OUTPUT_INDEX = 0x0f\n>    * Key: empty\n>    * Value: 32 bit little endian integer for the index of the output\n> being spent. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_IN_SEQUENCE = 0x0f\n>    * Key: empty\n>    * Value: 32 bit unsigned little endian integer for the sequence\n> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed\n> to be max sequence (0xffffffff) if not provided.\n> * PSBT_IN_REQUIRED_LOCKTIME = 0x10\n>    * Key: empty\n>    * Value: 32 bit unsigned little endian integer for the lock time that\n> this input requires. Must be omitted in PSBT v0. May be provided in PSBT\n> v1, assumed to be 0 if not provided.\n>\n> Output:\n> * PSBT_OUT_VALUE = 0x03\n>    * Key: empty\n>    * Value: 64-bit unsigned little endian integer for the output's\n> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_OUT_OUTPUT_SCRIPT = 0x04\n>    * Key: empty\n>    * Value: The script for this output. Otherwise known as the\n> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n>\n> This change allows for PSBT to be used in the construction of\n> transactions. With these new fields, inputs and outputs can be added as\n> needed. One caveat is that there is no longer a unique transaction\n> identifier so more care must be taken when combining PSBTs.\n> Additionally, adding new inputs and outputs must be done such that\n> signatures are not invalidated. This may be harder to specify.\n>\n> An important thing to note in this proposal are the fields\n> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin\n> transaction only has a single locktime yet a PSBT may have multiple\n> locktimes. To choose the locktime for the transaction, finalizers must\n> choose the maximum of all of the *_LOCKTIME fields.\n> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those\n> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to\n> be set. This field allows finalizers to choose a locktime that is high\n> enough for all inputs without needing to understand the scripts\n> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if\n> no inputs require a particular locktime.\n>\n> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1\n> needs the version number bump to enforce backwards incompatibility.\n> However once the inputs and outputs of a PSBT are decided, a PSBT could\n> be \"downgraded\" back to v0 by creating the unsigned transaction from the\n> above fields, and then dropping these new fields.\n>\n> If the list finds that these changes are reasonable, I will write a PR\n> to modify BIP 174 to incorporate them.\n>\n> Thanks,\n> Andrew Chow\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201210/8d157a07/attachment-0001.html>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2020-12-16T17:44:11",
                "message_text_only": "On Wed, Dec 09, 2020 at 10:25:37PM +0000, Andrew Chow via bitcoin-dev wrote:\n> Hi All,\n> \n> I would like to propose a new PSBT version that addresses a few \n> deficiencies in the current PSBT v0. As this will be backwards \n> incompatible, a new PSBT version will be used, v1.\n> \n> The primary change is to truly have all input and output data for each \n> in their respective maps. Instead of having to parse an unsigned \n> transaction and lookup some data from there, and other data from the \n> correct map, all of the data for an input will be contained in its map. \n> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version. \n> Thus I propose that the following fields be added:\n> \n> Global:\n> * PSBT_GLOBAL_TX_VERSION = 0x02\n>  ?? * Key: empty\n>  ?? * Value: 32-bit little endian unsigned integer for the transaction \n> version number. Must be provided in PSBT v1 and omitted in v0.\n\nAll of these changes sound great. It would definitely make working with\nPSBTs easier if all data was accessible in the same format, rather than\nbeing split between the global unsigned tx and the main body.\n\nOne minor quibble is the version numbering -- you mention \"v1\" in this\npost but set GLOBAL_TX_VERSION to 2. I think we should consistently use\n2 everywhere; probably nobody thinks of the existing PSBT as \"version 0\".\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/244f8942/attachment.sig>"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-12-22T20:12:22",
                "message_text_only": "Hi All,\n\nI have some updates on this after speaking with some people off-list.\n\nFirstly, the version number will be set to 2. In most discussions, this \nproposal was being referred to as PSBT version 2, so it'll be easier and \nclearer to set the version number to 2.\n\nFor lock times, instead of a single\u00a0 PSBT_IN_REQUIRED_LOCKTIME field, \nthere will be 2 of them, one for a time based lock time, and the other \nfor height based. These will be:\n* PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit unsigned little endian integer greater than or equal \nto 500000000 representing the minimum Unix timestamp that this input \nrequires to be set as the transaction's lock time. Must be omitted in \nPSBTv0, and may be omitted in PSBTv2\n* PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11\n \u00a0 * Key: empty\n \u00a0 * Value: 32 bit unsigned little endian integer less than 500000000 \nrepresenting the minimum block height that this input requires to be set \nas the transaction's lock time. Must be omitted in PSBTv0, and may be \nomitted in PSBTv2.\n\nHaving two lock time fields is necessary due to the behavior where all \ninputs must use the same type of lock time (height or time). Thus if an \ninput requires a particular type of lock time, it must set the requisite \nfield. Any new inputs being added must be able to accommodate all \nexisting inputs' lock time type. This means they either must not have a \nlock time specified (i.e. no OP_CLTV involved), or have branches that \nallow the acceptance of either type. If an input has a lock time type \nthat is incompatible with the rest of the transaction, it must not be added.\n\nPSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback \noption if no input lock time fields are present. If there are input lock \ntimes, all lock time calculations must ignore it.\n\nAny role which does lock time calculation will first check if there are \ninput lock time fields. If there are not, it must then check for a \nPSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the \ntransaction's lock time. If it does not, the lock time is 0. If there \nare input lock time fields, it must choose the type which does not \ninvalidate any inputs. The lock time is then determined to be the \nmaximum value of all of the lock time fields for the chosen type.\n\n\nAdditionally, I would like to add a new global field:\n* PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05\n \u00a0 * Key: empty\n \u00a0 * Value: A single byte as a boolean. 0 for False, 1 for True. All \nother values ore prohibited. Must be omitted for PSBTv0, may be omitted \nin PSBTv2.\n\nPSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and \noutputs can be added to the PSBT. This flag may be set to True when \ninputs and outputs are being updated, signed, and finalized. However \ncare must be taken when there are existing signatures. If this field is \nomitted or set to False, no further inputs and outputs may be added to \nthe PSBT.\n\nSeveral rules must be followed to ensure that adding additional inputs \nand outputs will not invalidate existing signatures. First, an input or \noutput adder must check for any existing signatures in all of the other \ninputs. If there are none, the input or output may be added in any \nposition. If there are one or more signatures, each signature's sighash \ntype must be examined. Inputs may only be added if all existing \nsignatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all \nexisting signatures use SIGHASH_NONE. If an input has a signature using \nSIGHASH_SINGLE, the same number of inputs and outputs must be added \nbefore that input and it's corresponding output. For all other sighash \ntypes (i.e. SIGHASH_ALL and any future sighash types), no inputs or \noutputs may be added to the PSBT. Specific exceptions can be made in the \nfuture for additional sighash types.\n\nFurthermore, these newly added inputs must follow additional lock time \nrules. Because all signatures, regardless of sighash type, sign the \ntransaction lock time, newly added inputs when there are existing \nsignatures must have the same type of lock time used in the transaction, \nand must be less than or equal to the transaction lock time. It must not \ncause the transaction lock time to change, otherwise the signatures will \nbe invalidated.\n\n\nLastly, to uniquely identify transactions for combiners, a txid can be \ncomputed from the information present in the PSBT. Internally, combiners \ncan create an unsigned transaction given the transaction version, the \ninput prevouts, the outputs, and the computed locktime. This can then be \nused to calculate a txid and thus used as a way to identify PSBTs. \nCombiners will need to do this for all version 2 PSBTs in order to avoid \ncombining distinct transactions.\n\n\nAndrew Chow\n\nOn 12/9/20 5:25 PM, Andrew Chow wrote:\n> Hi All,\n>\n> I would like to propose a new PSBT version that addresses a few\n> deficiencies in the current PSBT v0. As this will be backwards\n> incompatible, a new PSBT version will be used, v1.\n>\n> The primary change is to truly have all input and output data for each\n> in their respective maps. Instead of having to parse an unsigned\n> transaction and lookup some data from there, and other data from the\n> correct map, all of the data for an input will be contained in its map.\n> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.\n> Thus I propose that the following fields be added:\n>\n> Global:\n> * PSBT_GLOBAL_TX_VERSION = 0x02\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32-bit little endian unsigned integer for the transaction\n> version number. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit little endian unsigned integer for the preferred\n> transaction lock time. Must be omitted in PSBT v0. May be provided in\n> PSBT v1, assumed to be 0 if not provided.\n> * PSBT_GLOBAL_INPUT_COUNT = 0x04\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: Compact size unsigned integer. Number of inputs in this\n> PSBT. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: Compact size unsigned integer. Number of outputs in this\n> PSBT. Must be provided in PSBT v1 and omitted in v0.\n>\n> Input:\n> * PSBT_IN_PREVIOUS_TXID = 0x0e\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 byte txid of the previous transaction whose output at\n> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and\n> omitted in v0.\n> * PSBT_IN_OUTPUT_INDEX = 0x0f\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit little endian integer for the index of the output\n> being spent. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_IN_SEQUENCE = 0x0f\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit unsigned little endian integer for the sequence\n> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed\n> to be max sequence (0xffffffff) if not provided.\n> * PSBT_IN_REQUIRED_LOCKTIME = 0x10\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit unsigned little endian integer for the lock time that\n> this input requires. Must be omitted in PSBT v0. May be provided in PSBT\n> v1, assumed to be 0 if not provided.\n>\n> Output:\n> * PSBT_OUT_VALUE = 0x03\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 64-bit unsigned little endian integer for the output's\n> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n> * PSBT_OUT_OUTPUT_SCRIPT = 0x04\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: The script for this output. Otherwise known as the\n> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n>\n> This change allows for PSBT to be used in the construction of\n> transactions. With these new fields, inputs and outputs can be added as\n> needed. One caveat is that there is no longer a unique transaction\n> identifier so more care must be taken when combining PSBTs.\n> Additionally, adding new inputs and outputs must be done such that\n> signatures are not invalidated. This may be harder to specify.\n>\n> An important thing to note in this proposal are the fields\n> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin\n> transaction only has a single locktime yet a PSBT may have multiple\n> locktimes. To choose the locktime for the transaction, finalizers must\n> choose the maximum of all of the *_LOCKTIME fields.\n> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those\n> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to\n> be set. This field allows finalizers to choose a locktime that is high\n> enough for all inputs without needing to understand the scripts\n> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if\n> no inputs require a particular locktime.\n>\n> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1\n> needs the version number bump to enforce backwards incompatibility.\n> However once the inputs and outputs of a PSBT are decided, a PSBT could\n> be \"downgraded\" back to v0 by creating the unsigned transaction from the\n> above fields, and then dropping these new fields.\n>\n> If the list finds that these changes are reasonable, I will write a PR\n> to modify BIP 174 to incorporate them.\n>\n> Thanks,\n> Andrew Chow"
            },
            {
                "author": "fiatjaf",
                "date": "2020-12-23T03:30:20",
                "message_text_only": "Hi Andrew.\n\nI'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?\n\nUltimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.\n\nAlso let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html\n\n ---- On Tue, 22 Dec 2020 17:12:22 -0300 Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote ----\n > Hi All,\n > \n > I have some updates on this after speaking with some people off-list.\n > \n > Firstly, the version number will be set to 2. In most discussions, this \n > proposal was being referred to as PSBT version 2, so it'll be easier and \n > clearer to set the version number to 2.\n > \n > For lock times, instead of a single  PSBT_IN_REQUIRED_LOCKTIME field, \n > there will be 2 of them, one for a time based lock time, and the other \n > for height based. These will be:\n > * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10\n >    * Key: empty\n >    * Value: 32 bit unsigned little endian integer greater than or equal \n > to 500000000 representing the minimum Unix timestamp that this input \n > requires to be set as the transaction's lock time. Must be omitted in \n > PSBTv0, and may be omitted in PSBTv2\n > * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11\n >    * Key: empty\n >    * Value: 32 bit unsigned little endian integer less than 500000000 \n > representing the minimum block height that this input requires to be set \n > as the transaction's lock time. Must be omitted in PSBTv0, and may be \n > omitted in PSBTv2.\n > \n > Having two lock time fields is necessary due to the behavior where all \n > inputs must use the same type of lock time (height or time). Thus if an \n > input requires a particular type of lock time, it must set the requisite \n > field. Any new inputs being added must be able to accommodate all \n > existing inputs' lock time type. This means they either must not have a \n > lock time specified (i.e. no OP_CLTV involved), or have branches that \n > allow the acceptance of either type. If an input has a lock time type \n > that is incompatible with the rest of the transaction, it must not be added.\n > \n > PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback \n > option if no input lock time fields are present. If there are input lock \n > times, all lock time calculations must ignore it.\n > \n > Any role which does lock time calculation will first check if there are \n > input lock time fields. If there are not, it must then check for a \n > PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the \n > transaction's lock time. If it does not, the lock time is 0. If there \n > are input lock time fields, it must choose the type which does not \n > invalidate any inputs. The lock time is then determined to be the \n > maximum value of all of the lock time fields for the chosen type.\n > \n > \n > Additionally, I would like to add a new global field:\n > * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05\n >    * Key: empty\n >    * Value: A single byte as a boolean. 0 for False, 1 for True. All \n > other values ore prohibited. Must be omitted for PSBTv0, may be omitted \n > in PSBTv2.\n > \n > PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and \n > outputs can be added to the PSBT. This flag may be set to True when \n > inputs and outputs are being updated, signed, and finalized. However \n > care must be taken when there are existing signatures. If this field is \n > omitted or set to False, no further inputs and outputs may be added to \n > the PSBT.\n > \n > Several rules must be followed to ensure that adding additional inputs \n > and outputs will not invalidate existing signatures. First, an input or \n > output adder must check for any existing signatures in all of the other \n > inputs. If there are none, the input or output may be added in any \n > position. If there are one or more signatures, each signature's sighash \n > type must be examined. Inputs may only be added if all existing \n > signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all \n > existing signatures use SIGHASH_NONE. If an input has a signature using \n > SIGHASH_SINGLE, the same number of inputs and outputs must be added \n > before that input and it's corresponding output. For all other sighash \n > types (i.e. SIGHASH_ALL and any future sighash types), no inputs or \n > outputs may be added to the PSBT. Specific exceptions can be made in the \n > future for additional sighash types.\n > \n > Furthermore, these newly added inputs must follow additional lock time \n > rules. Because all signatures, regardless of sighash type, sign the \n > transaction lock time, newly added inputs when there are existing \n > signatures must have the same type of lock time used in the transaction, \n > and must be less than or equal to the transaction lock time. It must not \n > cause the transaction lock time to change, otherwise the signatures will \n > be invalidated.\n > \n > \n > Lastly, to uniquely identify transactions for combiners, a txid can be \n > computed from the information present in the PSBT. Internally, combiners \n > can create an unsigned transaction given the transaction version, the \n > input prevouts, the outputs, and the computed locktime. This can then be \n > used to calculate a txid and thus used as a way to identify PSBTs. \n > Combiners will need to do this for all version 2 PSBTs in order to avoid \n > combining distinct transactions.\n > \n > \n > Andrew Chow\n > \n > On 12/9/20 5:25 PM, Andrew Chow wrote:\n > > Hi All,\n > >\n > > I would like to propose a new PSBT version that addresses a few\n > > deficiencies in the current PSBT v0. As this will be backwards\n > > incompatible, a new PSBT version will be used, v1.\n > >\n > > The primary change is to truly have all input and output data for each\n > > in their respective maps. Instead of having to parse an unsigned\n > > transaction and lookup some data from there, and other data from the\n > > correct map, all of the data for an input will be contained in its map.\n > > Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.\n > > Thus I propose that the following fields be added:\n > >\n > > Global:\n > > * PSBT_GLOBAL_TX_VERSION = 0x02\n > >     * Key: empty\n > >     * Value: 32-bit little endian unsigned integer for the transaction\n > > version number. Must be provided in PSBT v1 and omitted in v0.\n > > * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n > >     * Key: empty\n > >     * Value: 32 bit little endian unsigned integer for the preferred\n > > transaction lock time. Must be omitted in PSBT v0. May be provided in\n > > PSBT v1, assumed to be 0 if not provided.\n > > * PSBT_GLOBAL_INPUT_COUNT = 0x04\n > >     * Key: empty\n > >     * Value: Compact size unsigned integer. Number of inputs in this\n > > PSBT. Must be provided in PSBT v1 and omitted in v0.\n > > * PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n > >     * Key: empty\n > >     * Value: Compact size unsigned integer. Number of outputs in this\n > > PSBT. Must be provided in PSBT v1 and omitted in v0.\n > >\n > > Input:\n > > * PSBT_IN_PREVIOUS_TXID = 0x0e\n > >     * Key: empty\n > >     * Value: 32 byte txid of the previous transaction whose output at\n > > PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and\n > > omitted in v0.\n > > * PSBT_IN_OUTPUT_INDEX = 0x0f\n > >     * Key: empty\n > >     * Value: 32 bit little endian integer for the index of the output\n > > being spent. Must be provided in PSBT v1 and omitted in v0.\n > > * PSBT_IN_SEQUENCE = 0x0f\n > >     * Key: empty\n > >     * Value: 32 bit unsigned little endian integer for the sequence\n > > number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed\n > > to be max sequence (0xffffffff) if not provided.\n > > * PSBT_IN_REQUIRED_LOCKTIME = 0x10\n > >     * Key: empty\n > >     * Value: 32 bit unsigned little endian integer for the lock time that\n > > this input requires. Must be omitted in PSBT v0. May be provided in PSBT\n > > v1, assumed to be 0 if not provided.\n > >\n > > Output:\n > > * PSBT_OUT_VALUE = 0x03\n > >     * Key: empty\n > >     * Value: 64-bit unsigned little endian integer for the output's\n > > amount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n > > * PSBT_OUT_OUTPUT_SCRIPT = 0x04\n > >     * Key: empty\n > >     * Value: The script for this output. Otherwise known as the\n > > scriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n > >\n > > This change allows for PSBT to be used in the construction of\n > > transactions. With these new fields, inputs and outputs can be added as\n > > needed. One caveat is that there is no longer a unique transaction\n > > identifier so more care must be taken when combining PSBTs.\n > > Additionally, adding new inputs and outputs must be done such that\n > > signatures are not invalidated. This may be harder to specify.\n > >\n > > An important thing to note in this proposal are the fields\n > > PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin\n > > transaction only has a single locktime yet a PSBT may have multiple\n > > locktimes. To choose the locktime for the transaction, finalizers must\n > > choose the maximum of all of the *_LOCKTIME fields.\n > > PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those\n > > involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to\n > > be set. This field allows finalizers to choose a locktime that is high\n > > enough for all inputs without needing to understand the scripts\n > > involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if\n > > no inputs require a particular locktime.\n > >\n > > As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1\n > > needs the version number bump to enforce backwards incompatibility.\n > > However once the inputs and outputs of a PSBT are decided, a PSBT could\n > > be \"downgraded\" back to v0 by creating the unsigned transaction from the\n > > above fields, and then dropping these new fields.\n > >\n > > If the list finds that these changes are reasonable, I will write a PR\n > > to modify BIP 174 to incorporate them.\n > >\n > > Thanks,\n > > Andrew Chow\n > \n > \n > _______________________________________________\n > bitcoin-dev mailing list\n > bitcoin-dev at lists.linuxfoundation.org\n > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n >"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2020-12-23T15:22:01",
                "message_text_only": "On Wed, Dec 23, 2020 at 12:30:20AM -0300, fiatjaf via bitcoin-dev wrote:\n> Hi Andrew.\n> \n> I'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?\n>\n\nYes, software will have to support both versions for a long time (likely\nforever, at least in the case of Core). But I think this is okay, for a\ncouple of reasons:\n\n1. it is very easy to convert from the old to new format, and from new to\n   old (unless the new one uses features unsupported by the old). Indeed,\n   the conversion logic is essentially the same as the logic that the\n   Extractor role uses, so there isn't even that much redundant code.\n\n2. There actually isn't a lot of software using PSBT out there, and most\n   of that that does use PSBT is under rapid development. The obvious\n   exception to this deployed hardware wallets, but as far as \"software\n   developers supporting old things for the sake of old hardware wallets\"\n   I think this transition is an order of magnitude simpler to handle\n   than many of the ad-hoc protocol changes that individual vendors have\n   done. In other words this is a \"fact of life\", and not even one of\n   the grosser ones.\n\n3. PSBT is pretty-much a dumb pure data format, and the diff between the\n   new format and the old is pretty small.\n\n> Ultimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.\n>\n\nThe reasons for switching to PSBT 2 are actually more than just structuring\nthe data in a cleaner way. I agree that if the point of this upgrade were\njust elegance, it would not be worth the compatibility loss. But there are\npractical limitations that this proposal eliminates:\n\n1. PSBT provides no way to modify the set of inputs or outputs after the\n   Creator role is done.\n\n2. Because of this, it forces certain things (e.g. locktimes and sequence\n   numbers) to be chosen by the Creator, who may not have all the relevant\n   information, and who certainly might not have it before any Updaters\n   have done their part.\n\nas well, of course, as elegance reasons:\n\n3. Parsers of the existing PSBT need to understand the Bitcoin transaction\n   format just to learn e.g. how many inputs and outputs there are. It is\n   impossible to parse a PSBT without also parsing (almost) the whole\n   transaction.\n\n4. Similarly to cross-check fields like 'non_witness_utxo' which are\n   committed to in the transaction, you have to parse the whole transaction\n   just to make sure that the purely-redundant data is correctly redundant.\n\n5. If you put a 0-input transaction into a PSBT (which would be pointless\n   because there's no way to add inputs, but it's not forbidden so your\n   software still has to deal with this somehow..), you need a different\n   transaction parser than the normal one, because there is an ambiguity\n   related to segwit that PSBT resolves differently.\n\nIt's also worth considering that PSBT is a young protocol, and future\nextensions will be easier starting from PSBT 2 than starting from the\noriginal version.\n\n \n> Also let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html\n> \n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/05050b70/attachment.sig>"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-12-23T21:30:04",
                "message_text_only": "Hi,\n\nOn 12/22/20 10:30 PM, fiatjaf wrote:\n> Hi Andrew.\n>\n> I'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?\nNo, it is not just \"improvements in the way data is structured.\"\n\nThe primary reason for these changes is to allow PSBT to properly \nsupport adding inputs and outputs. This is a feature that many people \nhave requested, and the ways that people have been doing it are honestly \njust hacks and not really the right way to be doing that. These changes \nallow for that feature to be supported well.\n\nFurthermore, it is possible to downgrade and upgrade PSBTs between the \ntwo versions, once all inputs and outputs have been decided. Since \nPSBTv2 is essentially just taking all of the normal transaction fields \nand grouping them all with the rest of the data for those inputs and \noutputs, it is easy to reconstruct a global unsigned transaction and \nturn a PSBTv2 into a PSBTv0. It is likewise just as easy to go the other \nway and break apart the global unsigned tx to turn a PSBTv0 into a \nPSBTv2. Originally, I had considered requiring that once a transaction \nwas fully constructed it must be downgraded to a PSBTv0, but the \nstructure changes that were made do make it easier to work with PSBT so \nI decided not to add this requirement.\n\nPerhaps to maintain compatibility PSBT_GLOBAL_UNSIGNED_TX shouldn't be \ndisallowed in PSBTv2 once the transaction is constructed? It would make \nthings much more confusing though as it would no longer be a clean break.\n\n\nAndrew Chow\n\n> Ultimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.\n>\n> Also let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html\n>\n>   ---- On Tue, 22 Dec 2020 17:12:22 -0300 Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote ----\n>   > Hi All,\n>   >\n>   > I have some updates on this after speaking with some people off-list.\n>   >\n>   > Firstly, the version number will be set to 2. In most discussions, this\n>   > proposal was being referred to as PSBT version 2, so it'll be easier and\n>   > clearer to set the version number to 2.\n>   >\n>   > For lock times, instead of a single  PSBT_IN_REQUIRED_LOCKTIME field,\n>   > there will be 2 of them, one for a time based lock time, and the other\n>   > for height based. These will be:\n>   > * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10\n>   >    * Key: empty\n>   >    * Value: 32 bit unsigned little endian integer greater than or equal\n>   > to 500000000 representing the minimum Unix timestamp that this input\n>   > requires to be set as the transaction's lock time. Must be omitted in\n>   > PSBTv0, and may be omitted in PSBTv2\n>   > * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11\n>   >    * Key: empty\n>   >    * Value: 32 bit unsigned little endian integer less than 500000000\n>   > representing the minimum block height that this input requires to be set\n>   > as the transaction's lock time. Must be omitted in PSBTv0, and may be\n>   > omitted in PSBTv2.\n>   >\n>   > Having two lock time fields is necessary due to the behavior where all\n>   > inputs must use the same type of lock time (height or time). Thus if an\n>   > input requires a particular type of lock time, it must set the requisite\n>   > field. Any new inputs being added must be able to accommodate all\n>   > existing inputs' lock time type. This means they either must not have a\n>   > lock time specified (i.e. no OP_CLTV involved), or have branches that\n>   > allow the acceptance of either type. If an input has a lock time type\n>   > that is incompatible with the rest of the transaction, it must not be added.\n>   >\n>   > PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback\n>   > option if no input lock time fields are present. If there are input lock\n>   > times, all lock time calculations must ignore it.\n>   >\n>   > Any role which does lock time calculation will first check if there are\n>   > input lock time fields. If there are not, it must then check for a\n>   > PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the\n>   > transaction's lock time. If it does not, the lock time is 0. If there\n>   > are input lock time fields, it must choose the type which does not\n>   > invalidate any inputs. The lock time is then determined to be the\n>   > maximum value of all of the lock time fields for the chosen type.\n>   >\n>   >\n>   > Additionally, I would like to add a new global field:\n>   > * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05\n>   >    * Key: empty\n>   >    * Value: A single byte as a boolean. 0 for False, 1 for True. All\n>   > other values ore prohibited. Must be omitted for PSBTv0, may be omitted\n>   > in PSBTv2.\n>   >\n>   > PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and\n>   > outputs can be added to the PSBT. This flag may be set to True when\n>   > inputs and outputs are being updated, signed, and finalized. However\n>   > care must be taken when there are existing signatures. If this field is\n>   > omitted or set to False, no further inputs and outputs may be added to\n>   > the PSBT.\n>   >\n>   > Several rules must be followed to ensure that adding additional inputs\n>   > and outputs will not invalidate existing signatures. First, an input or\n>   > output adder must check for any existing signatures in all of the other\n>   > inputs. If there are none, the input or output may be added in any\n>   > position. If there are one or more signatures, each signature's sighash\n>   > type must be examined. Inputs may only be added if all existing\n>   > signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all\n>   > existing signatures use SIGHASH_NONE. If an input has a signature using\n>   > SIGHASH_SINGLE, the same number of inputs and outputs must be added\n>   > before that input and it's corresponding output. For all other sighash\n>   > types (i.e. SIGHASH_ALL and any future sighash types), no inputs or\n>   > outputs may be added to the PSBT. Specific exceptions can be made in the\n>   > future for additional sighash types.\n>   >\n>   > Furthermore, these newly added inputs must follow additional lock time\n>   > rules. Because all signatures, regardless of sighash type, sign the\n>   > transaction lock time, newly added inputs when there are existing\n>   > signatures must have the same type of lock time used in the transaction,\n>   > and must be less than or equal to the transaction lock time. It must not\n>   > cause the transaction lock time to change, otherwise the signatures will\n>   > be invalidated.\n>   >\n>   >\n>   > Lastly, to uniquely identify transactions for combiners, a txid can be\n>   > computed from the information present in the PSBT. Internally, combiners\n>   > can create an unsigned transaction given the transaction version, the\n>   > input prevouts, the outputs, and the computed locktime. This can then be\n>   > used to calculate a txid and thus used as a way to identify PSBTs.\n>   > Combiners will need to do this for all version 2 PSBTs in order to avoid\n>   > combining distinct transactions.\n>   >\n>   >\n>   > Andrew Chow\n>   >\n>   > On 12/9/20 5:25 PM, Andrew Chow wrote:\n>   > > Hi All,\n>   > >\n>   > > I would like to propose a new PSBT version that addresses a few\n>   > > deficiencies in the current PSBT v0. As this will be backwards\n>   > > incompatible, a new PSBT version will be used, v1.\n>   > >\n>   > > The primary change is to truly have all input and output data for each\n>   > > in their respective maps. Instead of having to parse an unsigned\n>   > > transaction and lookup some data from there, and other data from the\n>   > > correct map, all of the data for an input will be contained in its map.\n>   > > Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.\n>   > > Thus I propose that the following fields be added:\n>   > >\n>   > > Global:\n>   > > * PSBT_GLOBAL_TX_VERSION = 0x02\n>   > >     * Key: empty\n>   > >     * Value: 32-bit little endian unsigned integer for the transaction\n>   > > version number. Must be provided in PSBT v1 and omitted in v0.\n>   > > * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n>   > >     * Key: empty\n>   > >     * Value: 32 bit little endian unsigned integer for the preferred\n>   > > transaction lock time. Must be omitted in PSBT v0. May be provided in\n>   > > PSBT v1, assumed to be 0 if not provided.\n>   > > * PSBT_GLOBAL_INPUT_COUNT = 0x04\n>   > >     * Key: empty\n>   > >     * Value: Compact size unsigned integer. Number of inputs in this\n>   > > PSBT. Must be provided in PSBT v1 and omitted in v0.\n>   > > * PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n>   > >     * Key: empty\n>   > >     * Value: Compact size unsigned integer. Number of outputs in this\n>   > > PSBT. Must be provided in PSBT v1 and omitted in v0.\n>   > >\n>   > > Input:\n>   > > * PSBT_IN_PREVIOUS_TXID = 0x0e\n>   > >     * Key: empty\n>   > >     * Value: 32 byte txid of the previous transaction whose output at\n>   > > PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and\n>   > > omitted in v0.\n>   > > * PSBT_IN_OUTPUT_INDEX = 0x0f\n>   > >     * Key: empty\n>   > >     * Value: 32 bit little endian integer for the index of the output\n>   > > being spent. Must be provided in PSBT v1 and omitted in v0.\n>   > > * PSBT_IN_SEQUENCE = 0x0f\n>   > >     * Key: empty\n>   > >     * Value: 32 bit unsigned little endian integer for the sequence\n>   > > number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed\n>   > > to be max sequence (0xffffffff) if not provided.\n>   > > * PSBT_IN_REQUIRED_LOCKTIME = 0x10\n>   > >     * Key: empty\n>   > >     * Value: 32 bit unsigned little endian integer for the lock time that\n>   > > this input requires. Must be omitted in PSBT v0. May be provided in PSBT\n>   > > v1, assumed to be 0 if not provided.\n>   > >\n>   > > Output:\n>   > > * PSBT_OUT_VALUE = 0x03\n>   > >     * Key: empty\n>   > >     * Value: 64-bit unsigned little endian integer for the output's\n>   > > amount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n>   > > * PSBT_OUT_OUTPUT_SCRIPT = 0x04\n>   > >     * Key: empty\n>   > >     * Value: The script for this output. Otherwise known as the\n>   > > scriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n>   > >\n>   > > This change allows for PSBT to be used in the construction of\n>   > > transactions. With these new fields, inputs and outputs can be added as\n>   > > needed. One caveat is that there is no longer a unique transaction\n>   > > identifier so more care must be taken when combining PSBTs.\n>   > > Additionally, adding new inputs and outputs must be done such that\n>   > > signatures are not invalidated. This may be harder to specify.\n>   > >\n>   > > An important thing to note in this proposal are the fields\n>   > > PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin\n>   > > transaction only has a single locktime yet a PSBT may have multiple\n>   > > locktimes. To choose the locktime for the transaction, finalizers must\n>   > > choose the maximum of all of the *_LOCKTIME fields.\n>   > > PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those\n>   > > involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to\n>   > > be set. This field allows finalizers to choose a locktime that is high\n>   > > enough for all inputs without needing to understand the scripts\n>   > > involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if\n>   > > no inputs require a particular locktime.\n>   > >\n>   > > As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1\n>   > > needs the version number bump to enforce backwards incompatibility.\n>   > > However once the inputs and outputs of a PSBT are decided, a PSBT could\n>   > > be \"downgraded\" back to v0 by creating the unsigned transaction from the\n>   > > above fields, and then dropping these new fields.\n>   > >\n>   > > If the list finds that these changes are reasonable, I will write a PR\n>   > > to modify BIP 174 to incorporate them.\n>   > >\n>   > > Thanks,\n>   > > Andrew Chow\n>   >\n>   >\n>   > _______________________________________________\n>   > bitcoin-dev mailing list\n>   > bitcoin-dev at lists.linuxfoundation.org\n>   > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>   >"
            },
            {
                "author": "Andrew Chow",
                "date": "2020-12-23T21:32:33",
                "message_text_only": "Hi All,\n\nThe full modified BIP can be read at \nhttps://github.com/achow101/bips/blob/psbt2/bip-0174.mediawiki.\n\nI will open a PR to the BIPs repo soon after further discussion on this.\n\n\nAndrew\n\nOn 12/22/20 3:12 PM, Andrew Chow wrote:\n> Hi All,\n>\n> I have some updates on this after speaking with some people off-list.\n>\n> Firstly, the version number will be set to 2. In most discussions, this\n> proposal was being referred to as PSBT version 2, so it'll be easier and\n> clearer to set the version number to 2.\n>\n> For lock times, instead of a single\u00a0 PSBT_IN_REQUIRED_LOCKTIME field,\n> there will be 2 of them, one for a time based lock time, and the other\n> for height based. These will be:\n> * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit unsigned little endian integer greater than or equal\n> to 500000000 representing the minimum Unix timestamp that this input\n> requires to be set as the transaction's lock time. Must be omitted in\n> PSBTv0, and may be omitted in PSBTv2\n> * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: 32 bit unsigned little endian integer less than 500000000\n> representing the minimum block height that this input requires to be set\n> as the transaction's lock time. Must be omitted in PSBTv0, and may be\n> omitted in PSBTv2.\n>\n> Having two lock time fields is necessary due to the behavior where all\n> inputs must use the same type of lock time (height or time). Thus if an\n> input requires a particular type of lock time, it must set the requisite\n> field. Any new inputs being added must be able to accommodate all\n> existing inputs' lock time type. This means they either must not have a\n> lock time specified (i.e. no OP_CLTV involved), or have branches that\n> allow the acceptance of either type. If an input has a lock time type\n> that is incompatible with the rest of the transaction, it must not be added.\n>\n> PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback\n> option if no input lock time fields are present. If there are input lock\n> times, all lock time calculations must ignore it.\n>\n> Any role which does lock time calculation will first check if there are\n> input lock time fields. If there are not, it must then check for a\n> PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the\n> transaction's lock time. If it does not, the lock time is 0. If there\n> are input lock time fields, it must choose the type which does not\n> invalidate any inputs. The lock time is then determined to be the\n> maximum value of all of the lock time fields for the chosen type.\n>\n>\n> Additionally, I would like to add a new global field:\n> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05\n>   \u00a0 * Key: empty\n>   \u00a0 * Value: A single byte as a boolean. 0 for False, 1 for True. All\n> other values ore prohibited. Must be omitted for PSBTv0, may be omitted\n> in PSBTv2.\n>\n> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and\n> outputs can be added to the PSBT. This flag may be set to True when\n> inputs and outputs are being updated, signed, and finalized. However\n> care must be taken when there are existing signatures. If this field is\n> omitted or set to False, no further inputs and outputs may be added to\n> the PSBT.\n>\n> Several rules must be followed to ensure that adding additional inputs\n> and outputs will not invalidate existing signatures. First, an input or\n> output adder must check for any existing signatures in all of the other\n> inputs. If there are none, the input or output may be added in any\n> position. If there are one or more signatures, each signature's sighash\n> type must be examined. Inputs may only be added if all existing\n> signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all\n> existing signatures use SIGHASH_NONE. If an input has a signature using\n> SIGHASH_SINGLE, the same number of inputs and outputs must be added\n> before that input and it's corresponding output. For all other sighash\n> types (i.e. SIGHASH_ALL and any future sighash types), no inputs or\n> outputs may be added to the PSBT. Specific exceptions can be made in the\n> future for additional sighash types.\n>\n> Furthermore, these newly added inputs must follow additional lock time\n> rules. Because all signatures, regardless of sighash type, sign the\n> transaction lock time, newly added inputs when there are existing\n> signatures must have the same type of lock time used in the transaction,\n> and must be less than or equal to the transaction lock time. It must not\n> cause the transaction lock time to change, otherwise the signatures will\n> be invalidated.\n>\n>\n> Lastly, to uniquely identify transactions for combiners, a txid can be\n> computed from the information present in the PSBT. Internally, combiners\n> can create an unsigned transaction given the transaction version, the\n> input prevouts, the outputs, and the computed locktime. This can then be\n> used to calculate a txid and thus used as a way to identify PSBTs.\n> Combiners will need to do this for all version 2 PSBTs in order to avoid\n> combining distinct transactions.\n>\n>\n> Andrew Chow\n>\n> On 12/9/20 5:25 PM, Andrew Chow wrote:\n>> Hi All,\n>>\n>> I would like to propose a new PSBT version that addresses a few\n>> deficiencies in the current PSBT v0. As this will be backwards\n>> incompatible, a new PSBT version will be used, v1.\n>>\n>> The primary change is to truly have all input and output data for each\n>> in their respective maps. Instead of having to parse an unsigned\n>> transaction and lookup some data from there, and other data from the\n>> correct map, all of the data for an input will be contained in its map.\n>> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.\n>> Thus I propose that the following fields be added:\n>>\n>> Global:\n>> * PSBT_GLOBAL_TX_VERSION = 0x02\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32-bit little endian unsigned integer for the transaction\n>> version number. Must be provided in PSBT v1 and omitted in v0.\n>> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32 bit little endian unsigned integer for the preferred\n>> transaction lock time. Must be omitted in PSBT v0. May be provided in\n>> PSBT v1, assumed to be 0 if not provided.\n>> * PSBT_GLOBAL_INPUT_COUNT = 0x04\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: Compact size unsigned integer. Number of inputs in this\n>> PSBT. Must be provided in PSBT v1 and omitted in v0.\n>> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: Compact size unsigned integer. Number of outputs in this\n>> PSBT. Must be provided in PSBT v1 and omitted in v0.\n>>\n>> Input:\n>> * PSBT_IN_PREVIOUS_TXID = 0x0e\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32 byte txid of the previous transaction whose output at\n>> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and\n>> omitted in v0.\n>> * PSBT_IN_OUTPUT_INDEX = 0x0f\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32 bit little endian integer for the index of the output\n>> being spent. Must be provided in PSBT v1 and omitted in v0.\n>> * PSBT_IN_SEQUENCE = 0x0f\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32 bit unsigned little endian integer for the sequence\n>> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed\n>> to be max sequence (0xffffffff) if not provided.\n>> * PSBT_IN_REQUIRED_LOCKTIME = 0x10\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 32 bit unsigned little endian integer for the lock time that\n>> this input requires. Must be omitted in PSBT v0. May be provided in PSBT\n>> v1, assumed to be 0 if not provided.\n>>\n>> Output:\n>> * PSBT_OUT_VALUE = 0x03\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: 64-bit unsigned little endian integer for the output's\n>> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.\n>> * PSBT_OUT_OUTPUT_SCRIPT = 0x04\n>>    \u00a0 * Key: empty\n>>    \u00a0 * Value: The script for this output. Otherwise known as the\n>> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.\n>>\n>> This change allows for PSBT to be used in the construction of\n>> transactions. With these new fields, inputs and outputs can be added as\n>> needed. One caveat is that there is no longer a unique transaction\n>> identifier so more care must be taken when combining PSBTs.\n>> Additionally, adding new inputs and outputs must be done such that\n>> signatures are not invalidated. This may be harder to specify.\n>>\n>> An important thing to note in this proposal are the fields\n>> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin\n>> transaction only has a single locktime yet a PSBT may have multiple\n>> locktimes. To choose the locktime for the transaction, finalizers must\n>> choose the maximum of all of the *_LOCKTIME fields.\n>> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those\n>> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to\n>> be set. This field allows finalizers to choose a locktime that is high\n>> enough for all inputs without needing to understand the scripts\n>> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if\n>> no inputs require a particular locktime.\n>>\n>> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1\n>> needs the version number bump to enforce backwards incompatibility.\n>> However once the inputs and outputs of a PSBT are decided, a PSBT could\n>> be \"downgraded\" back to v0 by creating the unsigned transaction from the\n>> above fields, and then dropping these new fields.\n>>\n>> If the list finds that these changes are reasonable, I will write a PR\n>> to modify BIP 174 to incorporate them.\n>>\n>> Thanks,\n>> Andrew Chow"
            }
        ],
        "thread_summary": {
            "title": "New PSBT version proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Poelstra",
                "Andrew Chow",
                "fiatjaf",
                "Sanket Kanjalkar"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 59093
        }
    },
    {
        "title": "[bitcoin-dev] BIP 155 (addrv2) update - spec and Bitcoin Core v0.21 implementation",
        "thread_messages": [
            {
                "author": "John Newbery",
                "date": "2020-12-10T09:47:54",
                "message_text_only": "Hi folks,\n\nBIP 155 was proposed[1] in Feb 2019 by Wladimir van der Laan as a way of\ngossipping longer node addresses over the Bitcoin P2P network, primarily\nto support torv3 and other networks.\n\nIn the time since that initial mailing list post, several changes have\nbeen made to the proposal. Discussion has been held on the BIPs repo[2],\nand (for implementation issues) the Bitcoin Core repo[3].\n\nThis email summarizes the changes. Readers should refer to BIP 155[4]\nfor the full specification.\n\n### Specification changes\n\n1. The `time` field in the `addrv2` message is now stored as a fixed\n   length uint32 instead of a variable-length compact size.\n\n2. The `addr` field may be up to a maximum of 512 bytes (4096 bits)\n   instead of 32 bytes (256 bits) for compatibility with future address\n   formats.\n\n3. Clients now SHOULD gossip addresses for known networks (even if they\n   can't connect to those networks). They SHOULD NOT gossip addresses\n   for unknown networks. They SHOULD also ignore addresses for known\n   networks that are different from the address length for that network\n   specified in BIP 155.\n\n4. New network IDs MUST be reserved in a BIP document.\n\n5. Support for `addrv2` is not dependent on a p2p protocol version.\n   A new message type `sendaddrv2` is introduced to signal support\n   for addrv2. To signal support for addrv2, this message MUST be sent\n   after the initial version message is sent and before the verack\n   message is sent.\n\n### Implementation detail\n\nDuring testing of the Bitcoin Core implementation, it was found that\nanother Bitcoin implementation would disconnect from peers on receipt of\nan unknown message[5]. I believe that to be an incorrect interpretation\nof the Bitcoin p2p protocol. The original v0.1 Satoshi client (and all\nBitcoin Core versions derived from it) have always explicitly ignored\nunknown message types as a mechanism to extend the p2p protocol[6]. This\nproperty allows p2p implementions to permissionlessly deploy opt-in\nextensions to the protocol.\n\nAs a pragmatic step to prevent those implementations from being\ndisconnected from v0.21 Bitcoin Core nodes, this initial version will\n_only_ send sendaddrv2 messages to peers on p2p protocol version 70016\nand higher. This behaviour may be reverted in future, at which point\nBitcoin Core would send sendaddrv2 messages to all peers during the\nversion/verack handshake.\n\nThanks to everyone who has contributed to the addrv2\nspec/implementation.\n\nJohn\n\n[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016687.html\n[2] https://github.com/bitcoin/bips/search?q=addrv2+is%3Apr&type=Issues\n[3] https://github.com/bitcoin/bitcoin/pull/20564\n[4] https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki\n[5] https://github.com/btcsuite/btcd/issues/1661\n[6] https://github.com/benjyz/bitcoinArchive/blob/master/bitcoin0.1/src/main.cpp#L2035-L2039\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201210/b6445a1c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP 155 (addrv2) update - spec and Bitcoin Core v0.21 implementation",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "John Newbery"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3067
        }
    },
    {
        "title": "[bitcoin-dev] bip48 proposal",
        "thread_messages": [
            {
                "author": "dentondevelopment",
                "date": "2020-12-16T12:43:58",
                "message_text_only": "Hello,\n\nI would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.\n\nPlease see a rough draft of the proposed bip attached, comments/input welcome.\n\nRegards,\nFontaine\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/d7e0c7d2/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: bip-0048.mediawiki\nType: application/octet-stream\nSize: 6667 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/d7e0c7d2/attachment.obj>"
            },
            {
                "author": "dentondevelopment",
                "date": "2020-12-16T14:10:28",
                "message_text_only": "Here is the repo instead of a static link: https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki\n\nFontaine\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello,\n>\n> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.\n>\n> Please see a rough draft of the proposed bip attached, comments/input welcome.\n>\n> Regards,\n> Fontaine\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/40281a60/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-12-16T17:16:54",
                "message_text_only": "BIP number 48 has not been assigned. Do not self-assign BIP numbers.\n\nIs this intended to be compatible with \nhttps://github.com/bitcoin/bips/pull/253 ?\n\nLuke\n\n\n\nOn Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev \nwrote:\n> Here is the repo instead of a static link:\n> https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki\n>\n> Fontaine\n>\n> Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>\n> On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev \n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > Hello,\n> >\n> > I would like to propose bip48 (taking bip44 as inspiration), with the\n> > purpose of documenting modern multi-sig derivations.\n> >\n> > Please see a rough draft of the proposed bip attached, comments/input\n> > welcome.\n> >\n> > Regards,\n> > Fontaine"
            },
            {
                "author": "Keagan McClelland",
                "date": "2020-12-16T18:48:30",
                "message_text_only": "I was just looking into the conventions around this yesterday! It seems\nlike this proposal is mostly just formalizing stuff that is already a tacit\nstandard. I'm glad to see that someone is documenting it somewhere more\n\"official\".\n\nIt appears consistent with https://github.com/bitcoin/bips/pull/253, However,\ndue to historical timing, the PR you linked doesn't include any standards\naround segwit conventions.\n\nIn the review thread you had mentioned that you needed an ACK from prusnak,\nbut he explicitly gave a NACK in favor of a separate proposal for BIP 48,\nwhich seems like it could be something like the OP. Reading the proposal it\nseems consistent with the pull request that you linked, as well. At the end\nof the thread the author of PR#253 said they would open a separate\nproposal, but it appears that it never materialized. Was there a reason for\nthis?\n\nKeagan\n\nOn Wed, Dec 16, 2020 at 10:17 AM Luke Dashjr via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> BIP number 48 has not been assigned. Do not self-assign BIP numbers.\n>\n> Is this intended to be compatible with\n> https://github.com/bitcoin/bips/pull/253 ?\n>\n> Luke\n>\n>\n>\n> On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev\n> wrote:\n> > Here is the repo instead of a static link:\n> > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki\n> >\n> > Fontaine\n> >\n> > Sent with [ProtonMail](https://protonmail.com) Secure Email.\n> >\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> >\n> > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via\n> bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > > Hello,\n> > >\n> > > I would like to propose bip48 (taking bip44 as inspiration), with the\n> > > purpose of documenting modern multi-sig derivations.\n> > >\n> > > Please see a rough draft of the proposed bip attached, comments/input\n> > > welcome.\n> > >\n> > > Regards,\n> > > Fontaine\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/034a2dfd/attachment-0001.html>"
            },
            {
                "author": "dentondevelopment",
                "date": "2020-12-18T01:44:27",
                "message_text_only": "Hi Luke,\n\nIt looks to have the same motivations and be compatible with https://github.com/bitcoin/bips/pull/253 (if I am reading it correctly).\n\nThe only guidance I have on proposing a bip is what is on the readme https://github.com/bitcoin/bips/blob/master/README.mediawiki\n\n48 would be fitting if it is unused.\n\nThis is still very much a work in progress and there does seem to be community support.\n\nPavol and others have shared relevant info/suggestions which I will be using to update the proposal.\n\nWill share again here when the next draft is ready.\n\nMany thanks,\nFontaine\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, December 17, 2020 1:16 AM, Luke Dashjr <luke at dashjr.org> wrote:\n\n> BIP number 48 has not been assigned. Do not self-assign BIP numbers.\n>\n> Is this intended to be compatible with\n> https://github.com/bitcoin/bips/pull/253 ?\n>\n> Luke\n>\n> On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev\n> wrote:\n>\n> > Here is the repo instead of a static link:\n> > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki\n> > Fontaine\n> > Sent with ProtonMail Secure Email.\n> > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev\n>\n> bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > > Hello,\n> > > I would like to propose bip48 (taking bip44 as inspiration), with the\n> > > purpose of documenting modern multi-sig derivations.\n> > > Please see a rough draft of the proposed bip attached, comments/input\n> > > welcome.\n> > > Regards,\n> > > Fontaine"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-12-18T04:08:30",
                "message_text_only": "Thanks for explaining where instructions are lacking.\n\nHow does this look?\nhttps://github.com/bitcoin/bips/pull/1046/files\n\nOn Friday 18 December 2020 01:44:27 dentondevelopment wrote:\n> Hi Luke,\n>\n> It looks to have the same motivations and be compatible with\n> https://github.com/bitcoin/bips/pull/253 (if I am reading it correctly).\n>\n> The only guidance I have on proposing a bip is what is on the readme\n> https://github.com/bitcoin/bips/blob/master/README.mediawiki\n>\n> 48 would be fitting if it is unused.\n>\n> This is still very much a work in progress and there does seem to be\n> community support.\n>\n> Pavol and others have shared relevant info/suggestions which I will be\n> using to update the proposal.\n>\n> Will share again here when the next draft is ready.\n>\n> Many thanks,\n> Fontaine\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n>\n> On Thursday, December 17, 2020 1:16 AM, Luke Dashjr <luke at dashjr.org> wrote:\n> > BIP number 48 has not been assigned. Do not self-assign BIP numbers.\n> >\n> > Is this intended to be compatible with\n> > https://github.com/bitcoin/bips/pull/253 ?\n> >\n> > Luke\n> >\n> > On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev\n> >\n> > wrote:\n> > > Here is the repo instead of a static link:\n> > > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki\n> > > Fontaine\n> > > Sent with ProtonMail Secure Email.\n> > > \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> > > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via\n> > > bitcoin-dev\n> >\n> > bitcoin-dev at lists.linuxfoundation.org wrote:\n> > > > Hello,\n> > > > I would like to propose bip48 (taking bip44 as inspiration), with the\n> > > > purpose of documenting modern multi-sig derivations.\n> > > > Please see a rough draft of the proposed bip attached, comments/input\n> > > > welcome.\n> > > > Regards,\n> > > > Fontaine"
            },
            {
                "author": "Pavol Rusnak",
                "date": "2020-12-17T10:58:08",
                "message_text_only": "I applaud this effort!\n\nWe tried to document the 48 path usage in this document:\n\nhttps://github.com/trezor/trezor-firmware/blob/master/docs/misc/purpose48.md\n\nThe only difference I can spot is that our document also documents script_type=0 which is for the raw BIP-11 multisig. While almost not used in the wild, it could be imho documented in this proposed BIP as well.\n\n\u2014\nBest Regards / S pozdravom,\n\nPavol \u201cstick\u201d Rusnak\nCo-founder and CTO, SatoshiLabs\n\n> On Wednesday, Dec 16, 2020 at 2:48 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org (mailto:bitcoin-dev at lists.linuxfoundation.org)> wrote:\n> Hello,\n>\n> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.\n>\n> Please see a rough draft of the proposed bip attached, comments/input welcome.\n>\n> Regards,\n> Fontaine\n>\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201217/b47648bc/attachment.html>"
            },
            {
                "author": "dentondevelopment",
                "date": "2020-12-18T01:49:07",
                "message_text_only": "Thanks for the link, will certainly be using the provided info as a reference and updating soon.\n\nRegards,\nFontaine\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, December 17, 2020 6:58 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:\n\n> I applaud this effort!\n>\n> We tried to document the 48 path usage in this document:\n>\n> https://github.com/trezor/trezor-firmware/blob/master/docs/misc/purpose48.md\n>\n> The only difference I can spot is that our document also documents script_type=0 which is for the raw BIP-11 multisig. While almost not used in the wild, it could be imho documented in this proposed BIP as well.\n>\n> \u2014\n> Best Regards / S pozdravom,\n>\n> Pavol \u201cstick\u201d Rusnak\n> Co-founder and CTO, SatoshiLabs\n>\n>> On Wednesday, Dec 16, 2020 at 2:48 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> Hello,\n>>\n>> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.\n>>\n>> Please see a rough draft of the proposed bip attached, comments/input welcome.\n>>\n>> Regards,\n>> Fontaine\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201218/3e20a405/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bip48 proposal",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Keagan McClelland",
                "Pavol Rusnak",
                "Luke Dashjr",
                "dentondevelopment"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 10851
        }
    },
    {
        "title": "[bitcoin-dev] BIP-0322 (generic signmessage) improvements",
        "thread_messages": [
            {
                "author": "Andrew Poelstra",
                "date": "2020-12-18T15:27:20",
                "message_text_only": "I have gone over BIP-0322 and substantially rewritten the text.\nEverything I did is (I think) simply clarifying the existing\nprotocol, which felt like it was written by committee and wasn't\neasy to follow, EXCEPT:\n\n1. I rewrote the motivation section, which I believe originally\n   was a paraphrase of Luke-jr's general objections to having any\n   signmessage functionality. I hope Luke in particular can take\n   a look at what I wrote under \"Motivation\" and see if it\n   captures his concerns.\n\n2. I merged the \"consensus\" and \"upgradeable\" rules to simply be\n   one set of rules, consisting of consensus checks plus additional\n   restrictions, all of which must be included. The new \"Extensions\"\n   section allows validators to output the state \"consensus-valid\"\n   if they really don't want to check the additional restrictions.\n\n3. The \"inconclusive\" state, which was originally used for what I've\n   called \"consensus-valid\", now indicates that a validator does not\n   understand the script that it is checking (also described in the\n   new \"Extensions\" section). The goal is that implementors are able\n   to be meaningfully BIP-0322 while only supporting a subset of\n   Script, e.g. the templates that their own software supports, or\n   Miniscript, or the non-raw non-address set of output descriptors,\n   or whatever.\n\n   We have seen opposition to supporting BIP-322, e.g. [1] because\n   of the requirement that you either have a full script interpreter\n   (plus an open-ended list of Core's standardness flags, which is\n   not even available through libbitcoinconsensus) or nothing. On\n   the other hand, the vast majority of outputs are single-key p2pkh,\n   p2pkwh or p2sh-wpkh.\n\nThe new text is here (and for posterity I will also include it\ninline below, though unless Github deletes it it will be easier\nto read in rendered form):\n\nhttps://github.com/apoelstra/bips/blob/2020-12--bip322-overhaul/bip-0322.mediawiki\n\nI'll also PR this to the BIPs repo in the next day or two, and\ncomments on Github are then welcome.\n\n\n[1] https://bitcointalk.org/index.php?topic=5261605.0\n\n\n\n* * * * * Full text of the above link * * * * *\n\n<pre>\n  BIP: 322\n  Layer: Applications\n  Title: Generic Signed Message Format\n  Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-09-10\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nA standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the intended recipient of funds sent to the invoice address.\n\n== Motivation ==\n\nThe current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This ensures that any coins, no matter what script they are controlled by, can in-principle be signed for. For easy interoperability with existing signing hardware, we also define a signature message format which resembles a Bitcoin transaction (except that it contains an invalid input, so it cannot be spent on any real network).\n\nAdditionally, the current message signature format uses ECDSA signatures which do not commit to the public key, meaning that they do not actually prove knowledge of any secret keys. (Indeed, valid signatures can be tweaked by 3rd parties to become valid signatures on certain related keys.)\n\nUltimately no message signing protocol can actually prove control of funds, both because a signature is obsolete as soon as it is created, and because the possessor of a secret key may be willing to sign messages on others' behalf even if it would not sign actual transactions. No signmessage protocol can fix these limitations.\n\n== Types of Signatures ==\n\nThis BIP specifies three formats for signing messages: ''legacy'', ''simple'' and ''full''. Additionally, a variant of the ''full'' format can be used to demonstrate control over a set of UTXOs.\n\n=== Legacy ===\n\nNew proofs should use the new format for all invoice address formats, including P2PKH.\n\nThe legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.\n\n=== Simple ===\n\nA ''simple'' signature consists of a witness stack, consensus encoded as a vector of vectors of bytes, and base64-encoded. Validators should construct <code>to_spend</code> and <code>to_sign</code> as defined below, with default values for all fields except that\n\n* <code>message_hash</code> is a BIP340-tagged hash of the message, as specified below\n* <code>message_challenge</code> in <code>to_spend</code> is set to the scriptPubKey being signed with\n* <code>message_signature</code> in <code>to_sign</code> is set to the provided simple signature.\n\nand then proceed as they would for a full signature.\n\n=== Full ===\n\nFull signatures follow an analogous specification to the BIP-325 challenges and solutions used by Signet.\n\nLet there be two virtual transactions to_spend and to_sign.\n\nThe \"to_spend\" transaction is:\n\n    nVersion = 0\n    nLockTime = 0\n    vin[0].prevout.hash = 0000...000\n    vin[0].prevout.n = 0xFFFFFFFF\n    vin[0].nSequence = 0\n    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n    vin[0].scriptWitness = []\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = message_challenge\n\nwhere <code>message_hash</code> is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code>, and <code>message_challenge</code> is the to be proven (public) key script.\n\nThe \"to_sign\" transaction is:\n\n    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n    nLockTime = 0 or as appropriate (for time locks)\n    vin[0].prevout.hash = to_spend.txid\n    vin[0].prevout.n = 0\n    vin[0].nSequence = 0 or as appropriate (for time locks)\n    vin[0].scriptWitness = message_signature\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = OP_RETURN\n\nA full signature consists of the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation.\n\n=== Full (Proof of Funds) ===\n\nA signer may construct a proof of funds, demonstrating control of a set of UTXOs, by constructing a full signature as above, with the following modifications.\n\n* <code>message_challenge</code> is unused and shall be set to <code>OP_TRUE</code>\n* Similarly, <code>message_signature</code> is then empty.\n* All outputs that the signer wishes to demonstrate control of are included as additional outputs to <code>to_sign</code>, and their witness and scriptSig data should be set as though these outputs were actually being spent.\n\nUnlike an ordinary signature, validators of a proof of funds need access to the current UTXO set, to learn that the claimed inputs exist on the blockchain, and to learn their scriptPubKeys.\n\n== Detailed Specification ==\n\nFor all signature types, except legacy, the <code>to_spend</code> and <code>to_sign</code> transactions must be valid transactions which pass all consensus checks, except of course that the output with prevout <code>000...000:FFFFFFFF</code> does not exist.\n\nWe additionally require the following restrictions be met.\n\n* All signatures must use the SIGHASH_ALL flag.\n* The use of <code>CODESEPARATOR</code> or <code>FindAndDelete</code> is forbidden.\n* The use of NOPs reserved for upgrades is forbidden.\n* The use of segwit versions greater than 1 are forbidden.\n* <code>LOW_S</code>, <code>STRICTENC</code> and <code>NULLFAIL</code>: valid ECDSA signatures must be strictly DER-encoded and have a low-S value; invalid ECDSA signature must be the empty push\n* <code>MINIMALDATA</code>: all pushes must be minimally encoded\n* <code>CLEANSTACK</code>: require that only a single stack element remains after evaluation\n* <code>MINIMALIF</code>: the argument of <code>IF</code>/<code>NOTIF</code> must be exactly 0x01 or empty push\n\nFuture versions of this BIP may relax these rules, in particular those around NOPs and future Segwit versions, as they are deployed on Bitcoin.\n\n=== Verification ===\n\nValidation consists of the following steps. A validator is given as input an address ''A'' (which may be omitted in a proof-of-funds), signature ''s'' and message ''m'', and outputs one of four states (although validators are only required to be able to output the first and last):\n* ''valid'' indicates that the signature passed all checks described below\n* ''valid at time t and age s'' indicates that the signature has set timelocks but is otherwise valid (see \"Extensions\" below)\n* ''consensus-valid'' indicates that the signature passed validation except for the additonal restrictions in the above section (see \"Extensions\" below)\n* ''inconclusive'' means the validator was unable to check the scripts (see \"Extensions\" below)\n* ''invalid'' means none of the other states\n\n# Decode ''s'' as the transactions <code>to_sign</code> and <code>to_spend</code>\n# Confirm that <code>message_hash</code> is the correct hash of ''m''\n# Confirm that <code>message_challenge</code> is the scriptPubKey corresponding to ''A'' if ''A'' is present, and otherwise must be <code>OP_TRUE</code>\n# Confirm that all other fields are set as specified above; in particular that\n** <code>to_spend</code> has exactly one input and one output\n** <code>to_sign</code> has at least one input and its first input spends the output of </code>to_spend</code>\n** <code>to_sign</code> has exactly one output, as specified above\n# Confirm that the two transactions together satisfy all consensus rules, except for <code>to_spend</code>'s missing input, and except that ''nSequence'' of <code>to_sign</code>'s first input and ''nLockTime'' of <code>to_sign</code> are not checked.\n# Confirm that all of the above restrictions are met.\n\nIf the above conditions are met, the signature is considered ''valid''. Otherwise the signature is ''invalid''.\n\n=== Signing ===\n\nSigners who control an address ''A'' who wish to sign a message ''m'' act as follows:\n\n# They construct <code>to_spend</code> and <code>to_sign</code> as specified above, using the scriptPubKey of ''A'' for <code>message_challenge</code> and tagged hash of ''m'' as <code>message_hash</code>.\n# Optionally, they may set nLockTime of <code>to_sign</code> or nSequence of its first input.\n# Optionally, they may add any additional outputs to <code>to_sign</code> that they wish to prove control of.\n# They satisfy <code>to_sign</code> as they would any other transaction.\n\nThey then encode their signature, choosing either ''simple'' or ''full'' as follows:\n\n* If they added no inputs to <code>to_sign</code>, left nSequence and nLockTime at 0, and ''A'' is a Segwit address (either pure or P2SH-wrapped), then they may base64-encode <code>message_signature</code>\n* Otherwise they must base64-encode the concatenation of <code>to_spend</code> followed by <code>to_sign</code>.\n\n== Extensions ==\n\nTo ease implementation, we allow some additional states to be output rather than ''valid'' or ''invalid''. Users who do not understand or who do not wish to deal with these states may treat them as ''invalid''.\n\n=== Timelocks === \n\nIf the nLockTime of <code>to_sign</code> is set to ''t'', and the nSequence of the first input of <code>to_sign</code> is set to ''s'', the validator may output the state ''valid at time t and age s''.\n\nIf both ''t'' and ''s'' are 0, the validator must instead output ''valid''.\n\nUsers may then wish to interpret this state as ''valid'' or ''invalid'' relative to the state of the current blockchain, but the rules for doing so are out of scope of this BIP.\n\n=== Incomplete Validation ===\n\nSome validators may not wish to implement a full script interpreter, choosing instead to support only specific script templates, or only Miniscript, for example. In this case, if they are unable to execute the scripts used by <code>to_sign</code>, they should output the state ''inconclusive''.\n\nUsers should interpret this state as the same thing as ''invalid'', although take it as a sign that they should find more capable software.\n\n=== Consensus-Only Validation ===\n\nValidators which are only able to check consensus-correctness of witnesses, but not the additional restrictions imposed by this BIP, may output the state ''consensus-valid'' to indicate that a signature has passed all consensus and structural checks.\n\nUsers should interpret this state as the same thing as ''valid'' but be aware that other software may fail to validate the same signature.\n\n== Compatibility ==\n\nThis specification is backwards compatible with the legacy signmessage/verifymessage specification through the special case as described above.\n\n== Reference implementation ==\n\nTODO\n\n== Acknowledgements ==\n\nThanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille, Andrew Poelstra, and many others for their feedback on the specification.\n\n== References ==\n\n# Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n== Test vectors ==\n\nTODO\n\n* * * * * End full text * * * * *\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201218/f7228b77/attachment.sig>"
            },
            {
                "author": "Karl-Johan Alm",
                "date": "2020-12-21T05:37:38",
                "message_text_only": "Thanks a lot for taking the time to brush up the BIP. For what it's\nworth, I am all for these changes, and I see them as clear\nimprovements all around.\n\nIIRC Pieter was the one who originally suggested the two-checks\napproach (invalid, inconclusive, valid) which is being modified here,\nso would be good if you chimed in (or not -- which I'll assume means\nyou don't mind).\n\nOn Sat, Dec 19, 2020 at 12:27 AM Andrew Poelstra via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> I have gone over BIP-0322 and substantially rewritten the text.\n> Everything I did is (I think) simply clarifying the existing\n> protocol, which felt like it was written by committee and wasn't\n> easy to follow, EXCEPT:\n>\n> 1. I rewrote the motivation section, which I believe originally\n>    was a paraphrase of Luke-jr's general objections to having any\n>    signmessage functionality. I hope Luke in particular can take\n>    a look at what I wrote under \"Motivation\" and see if it\n>    captures his concerns.\n>\n> 2. I merged the \"consensus\" and \"upgradeable\" rules to simply be\n>    one set of rules, consisting of consensus checks plus additional\n>    restrictions, all of which must be included. The new \"Extensions\"\n>    section allows validators to output the state \"consensus-valid\"\n>    if they really don't want to check the additional restrictions.\n>\n> 3. The \"inconclusive\" state, which was originally used for what I've\n>    called \"consensus-valid\", now indicates that a validator does not\n>    understand the script that it is checking (also described in the\n>    new \"Extensions\" section). The goal is that implementors are able\n>    to be meaningfully BIP-0322 while only supporting a subset of\n>    Script, e.g. the templates that their own software supports, or\n>    Miniscript, or the non-raw non-address set of output descriptors,\n>    or whatever.\n>\n>    We have seen opposition to supporting BIP-322, e.g. [1] because\n>    of the requirement that you either have a full script interpreter\n>    (plus an open-ended list of Core's standardness flags, which is\n>    not even available through libbitcoinconsensus) or nothing. On\n>    the other hand, the vast majority of outputs are single-key p2pkh,\n>    p2pkwh or p2sh-wpkh.\n>\n> The new text is here (and for posterity I will also include it\n> inline below, though unless Github deletes it it will be easier\n> to read in rendered form):\n>\n> https://github.com/apoelstra/bips/blob/2020-12--bip322-overhaul/bip-0322.mediawiki\n>\n> I'll also PR this to the BIPs repo in the next day or two, and\n> comments on Github are then welcome.\n>\n>\n> [1] https://bitcointalk.org/index.php?topic=5261605.0\n>\n>\n>\n> * * * * * Full text of the above link * * * * *\n>\n> <pre>\n>   BIP: 322\n>   Layer: Applications\n>   Title: Generic Signed Message Format\n>   Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>\n>   Comments-Summary: No comments yet.\n>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\n>   Status: Draft\n>   Type: Standards Track\n>   Created: 2018-09-10\n>   License: CC0-1.0\n> </pre>\n>\n> == Abstract ==\n>\n> A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the intended recipient of funds sent to the invoice address.\n>\n> == Motivation ==\n>\n> The current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This ensures that any coins, no matter what script they are controlled by, can in-principle be signed for. For easy interoperability with existing signing hardware, we also define a signature message format which resembles a Bitcoin transaction (except that it contains an invalid input, so it cannot be spent on any real network).\n>\n> Additionally, the current message signature format uses ECDSA signatures which do not commit to the public key, meaning that they do not actually prove knowledge of any secret keys. (Indeed, valid signatures can be tweaked by 3rd parties to become valid signatures on certain related keys.)\n>\n> Ultimately no message signing protocol can actually prove control of funds, both because a signature is obsolete as soon as it is created, and because the possessor of a secret key may be willing to sign messages on others' behalf even if it would not sign actual transactions. No signmessage protocol can fix these limitations.\n>\n> == Types of Signatures ==\n>\n> This BIP specifies three formats for signing messages: ''legacy'', ''simple'' and ''full''. Additionally, a variant of the ''full'' format can be used to demonstrate control over a set of UTXOs.\n>\n> === Legacy ===\n>\n> New proofs should use the new format for all invoice address formats, including P2PKH.\n>\n> The legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.\n>\n> === Simple ===\n>\n> A ''simple'' signature consists of a witness stack, consensus encoded as a vector of vectors of bytes, and base64-encoded. Validators should construct <code>to_spend</code> and <code>to_sign</code> as defined below, with default values for all fields except that\n>\n> * <code>message_hash</code> is a BIP340-tagged hash of the message, as specified below\n> * <code>message_challenge</code> in <code>to_spend</code> is set to the scriptPubKey being signed with\n> * <code>message_signature</code> in <code>to_sign</code> is set to the provided simple signature.\n>\n> and then proceed as they would for a full signature.\n>\n> === Full ===\n>\n> Full signatures follow an analogous specification to the BIP-325 challenges and solutions used by Signet.\n>\n> Let there be two virtual transactions to_spend and to_sign.\n>\n> The \"to_spend\" transaction is:\n>\n>     nVersion = 0\n>     nLockTime = 0\n>     vin[0].prevout.hash = 0000...000\n>     vin[0].prevout.n = 0xFFFFFFFF\n>     vin[0].nSequence = 0\n>     vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n>     vin[0].scriptWitness = []\n>     vout[0].nValue = 0\n>     vout[0].scriptPubKey = message_challenge\n>\n> where <code>message_hash</code> is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code>, and <code>message_challenge</code> is the to be proven (public) key script.\n>\n> The \"to_sign\" transaction is:\n>\n>     nVersion = 0 or as appropriate (e.g. 2, for time locks)\n>     nLockTime = 0 or as appropriate (for time locks)\n>     vin[0].prevout.hash = to_spend.txid\n>     vin[0].prevout.n = 0\n>     vin[0].nSequence = 0 or as appropriate (for time locks)\n>     vin[0].scriptWitness = message_signature\n>     vout[0].nValue = 0\n>     vout[0].scriptPubKey = OP_RETURN\n>\n> A full signature consists of the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation.\n>\n> === Full (Proof of Funds) ===\n>\n> A signer may construct a proof of funds, demonstrating control of a set of UTXOs, by constructing a full signature as above, with the following modifications.\n>\n> * <code>message_challenge</code> is unused and shall be set to <code>OP_TRUE</code>\n> * Similarly, <code>message_signature</code> is then empty.\n> * All outputs that the signer wishes to demonstrate control of are included as additional outputs to <code>to_sign</code>, and their witness and scriptSig data should be set as though these outputs were actually being spent.\n>\n> Unlike an ordinary signature, validators of a proof of funds need access to the current UTXO set, to learn that the claimed inputs exist on the blockchain, and to learn their scriptPubKeys.\n>\n> == Detailed Specification ==\n>\n> For all signature types, except legacy, the <code>to_spend</code> and <code>to_sign</code> transactions must be valid transactions which pass all consensus checks, except of course that the output with prevout <code>000...000:FFFFFFFF</code> does not exist.\n>\n> We additionally require the following restrictions be met.\n>\n> * All signatures must use the SIGHASH_ALL flag.\n> * The use of <code>CODESEPARATOR</code> or <code>FindAndDelete</code> is forbidden.\n> * The use of NOPs reserved for upgrades is forbidden.\n> * The use of segwit versions greater than 1 are forbidden.\n> * <code>LOW_S</code>, <code>STRICTENC</code> and <code>NULLFAIL</code>: valid ECDSA signatures must be strictly DER-encoded and have a low-S value; invalid ECDSA signature must be the empty push\n> * <code>MINIMALDATA</code>: all pushes must be minimally encoded\n> * <code>CLEANSTACK</code>: require that only a single stack element remains after evaluation\n> * <code>MINIMALIF</code>: the argument of <code>IF</code>/<code>NOTIF</code> must be exactly 0x01 or empty push\n>\n> Future versions of this BIP may relax these rules, in particular those around NOPs and future Segwit versions, as they are deployed on Bitcoin.\n>\n> === Verification ===\n>\n> Validation consists of the following steps. A validator is given as input an address ''A'' (which may be omitted in a proof-of-funds), signature ''s'' and message ''m'', and outputs one of four states (although validators are only required to be able to output the first and last):\n> * ''valid'' indicates that the signature passed all checks described below\n> * ''valid at time t and age s'' indicates that the signature has set timelocks but is otherwise valid (see \"Extensions\" below)\n> * ''consensus-valid'' indicates that the signature passed validation except for the additonal restrictions in the above section (see \"Extensions\" below)\n> * ''inconclusive'' means the validator was unable to check the scripts (see \"Extensions\" below)\n> * ''invalid'' means none of the other states\n>\n> # Decode ''s'' as the transactions <code>to_sign</code> and <code>to_spend</code>\n> # Confirm that <code>message_hash</code> is the correct hash of ''m''\n> # Confirm that <code>message_challenge</code> is the scriptPubKey corresponding to ''A'' if ''A'' is present, and otherwise must be <code>OP_TRUE</code>\n> # Confirm that all other fields are set as specified above; in particular that\n> ** <code>to_spend</code> has exactly one input and one output\n> ** <code>to_sign</code> has at least one input and its first input spends the output of </code>to_spend</code>\n> ** <code>to_sign</code> has exactly one output, as specified above\n> # Confirm that the two transactions together satisfy all consensus rules, except for <code>to_spend</code>'s missing input, and except that ''nSequence'' of <code>to_sign</code>'s first input and ''nLockTime'' of <code>to_sign</code> are not checked.\n> # Confirm that all of the above restrictions are met.\n>\n> If the above conditions are met, the signature is considered ''valid''. Otherwise the signature is ''invalid''.\n>\n> === Signing ===\n>\n> Signers who control an address ''A'' who wish to sign a message ''m'' act as follows:\n>\n> # They construct <code>to_spend</code> and <code>to_sign</code> as specified above, using the scriptPubKey of ''A'' for <code>message_challenge</code> and tagged hash of ''m'' as <code>message_hash</code>.\n> # Optionally, they may set nLockTime of <code>to_sign</code> or nSequence of its first input.\n> # Optionally, they may add any additional outputs to <code>to_sign</code> that they wish to prove control of.\n> # They satisfy <code>to_sign</code> as they would any other transaction.\n>\n> They then encode their signature, choosing either ''simple'' or ''full'' as follows:\n>\n> * If they added no inputs to <code>to_sign</code>, left nSequence and nLockTime at 0, and ''A'' is a Segwit address (either pure or P2SH-wrapped), then they may base64-encode <code>message_signature</code>\n> * Otherwise they must base64-encode the concatenation of <code>to_spend</code> followed by <code>to_sign</code>.\n>\n> == Extensions ==\n>\n> To ease implementation, we allow some additional states to be output rather than ''valid'' or ''invalid''. Users who do not understand or who do not wish to deal with these states may treat them as ''invalid''.\n>\n> === Timelocks ===\n>\n> If the nLockTime of <code>to_sign</code> is set to ''t'', and the nSequence of the first input of <code>to_sign</code> is set to ''s'', the validator may output the state ''valid at time t and age s''.\n>\n> If both ''t'' and ''s'' are 0, the validator must instead output ''valid''.\n>\n> Users may then wish to interpret this state as ''valid'' or ''invalid'' relative to the state of the current blockchain, but the rules for doing so are out of scope of this BIP.\n>\n> === Incomplete Validation ===\n>\n> Some validators may not wish to implement a full script interpreter, choosing instead to support only specific script templates, or only Miniscript, for example. In this case, if they are unable to execute the scripts used by <code>to_sign</code>, they should output the state ''inconclusive''.\n>\n> Users should interpret this state as the same thing as ''invalid'', although take it as a sign that they should find more capable software.\n>\n> === Consensus-Only Validation ===\n>\n> Validators which are only able to check consensus-correctness of witnesses, but not the additional restrictions imposed by this BIP, may output the state ''consensus-valid'' to indicate that a signature has passed all consensus and structural checks.\n>\n> Users should interpret this state as the same thing as ''valid'' but be aware that other software may fail to validate the same signature.\n>\n> == Compatibility ==\n>\n> This specification is backwards compatible with the legacy signmessage/verifymessage specification through the special case as described above.\n>\n> == Reference implementation ==\n>\n> TODO\n>\n> == Acknowledgements ==\n>\n> Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille, Andrew Poelstra, and many others for their feedback on the specification.\n>\n> == References ==\n>\n> # Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n>\n> == Copyright ==\n>\n> This document is licensed under the Creative Commons CC0 1.0 Universal license.\n>\n> == Test vectors ==\n>\n> TODO\n>\n> * * * * * End full text * * * * *\n>\n> --\n> Andrew Poelstra\n> Director of Research, Blockstream\n> Email: apoelstra at wpsoftware.net\n> Web:   https://www.wpsoftware.net/andrew\n>\n> The sun is always shining in space\n>     -Justin Lewis-Webster\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-12-21T22:57:15",
                "message_text_only": "On Sunday, December 20, 2020 9:37 PM, Karl-Johan Alm via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks a lot for taking the time to brush up the BIP. For what it's\n> worth, I am all for these changes, and I see them as clear\n> improvements all around.\n>\n> IIRC Pieter was the one who originally suggested the two-checks\n> approach (invalid, inconclusive, valid) which is being modified here,\n> so would be good if you chimed in (or not -- which I'll assume means\n> you don't mind).\n\nI agree with the idea of permitting incomplete validators to return inconclusive as well. That doesn't really reduce the functionality (given that \"inconclusive\" was already a potential result), and it obviously makes it much more accessible to a variety of software.\n\nThis suggestion breaks the original use of inconclusive though: the ability to detect that future features are used in the signature. The idea was to use divergence between \"consensus valid\" and \"standardness valid\" as a proxy for future extensions to be detected (e.g. OP_NOPn, future witness versions, ...). I think it's undesirable that these things now become unconditionally invalid (until the BIP is updated, but once that happens old validators will give a different result than new ones).\n\nSince the BIP no longer relies on a nebulous concept of standardness, and instead specifically defines which standardness features are to be considered, this seems easy to fix: whenever validation fails due to any of those, require reporting inconclusive instead of invalid (unless of course something actually invalid also happens). In practice I guess you'd implement that (in capable validators) by still doing validation twice, once with all features enabled that distinguish between valid/invalid, and if valid, again but now with the features enabled that distinguish between valid and (invalid or inconclusive).\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Pieter Wuille",
                "date": "2020-12-22T00:22:37",
                "message_text_only": "On Monday, December 21, 2020 2:57 PM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> On Sunday, December 20, 2020 9:37 PM, Karl-Johan Alm via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:\n>\n> > Thanks a lot for taking the time to brush up the BIP. For what it's\n> > worth, I am all for these changes, and I see them as clear\n> > improvements all around.\n> > IIRC Pieter was the one who originally suggested the two-checks\n> > approach (invalid, inconclusive, valid) which is being modified here,\n> > so would be good if you chimed in (or not -- which I'll assume means\n> > you don't mind).\n>\n> I agree with the idea of permitting incomplete validators to return inconclusive as well. That doesn't really reduce the functionality (given that \"inconclusive\" was already a potential result), and it obviously makes it much more accessible to a variety of software.\n>\n> This suggestion breaks the original use of inconclusive though: the ability to detect that future features are used in the signature. The idea was to use divergence between \"consensus valid\" and \"standardness valid\" as a proxy for future extensions to be detected (e.g. OP_NOPn, future witness versions, ...). I think it's undesirable that these things now become unconditionally invalid (until the BIP is updated, but once that happens old validators will give a different result than new ones).\n>\n> Since the BIP no longer relies on a nebulous concept of standardness, and instead specifically defines which standardness features are to be considered, this seems easy to fix: whenever validation fails due to any of those, require reporting inconclusive instead of invalid (unless of course something actually invalid also happens). In practice I guess you'd implement that (in capable validators) by still doing validation twice, once with all features enabled that distinguish between valid/invalid, and if valid, again but now with the features enabled that distinguish between valid and (invalid or inconclusive).\n\nRe-reading your proposed text, I'm wondering if the \"consensus-only validation\" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.\n\nWhat I'm suggestion could be specified this way:\n* If validator understands the script:\n  * If signature is consensus valid (as far as the validator knows):\n    * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid\n    * Otherwise: return inconclusive\n  * Otherwise: return invalid\n* Otherwise: return inconclusive\n\nOr in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.\n\nThis has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.\n\nCheers,\n\n--\nPieter"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2020-12-22T01:11:42",
                "message_text_only": "On Tue, Dec 22, 2020 at 12:22:37AM +0000, Pieter Wuille via bitcoin-dev wrote:\n> \n> Re-reading your proposed text, I'm wondering if the \"consensus-only validation\" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.\n> \n> What I'm suggestion could be specified this way:\n> * If validator understands the script:\n>   * If signature is consensus valid (as far as the validator knows):\n>     * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid\n>     * Otherwise: return inconclusive\n>   * Otherwise: return invalid\n> * Otherwise: return inconclusive\n> \n> Or in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.\n> \n> This has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.\n>\n\nI like it!\n\nMy thinking regarding standardness vs consensus rules was essentially that\nI wanted to enforce the included standardness rules for anti-malleability\nreasons, i.e. the hope that for \"normal scripts\" we would get strong signatures,\nwhich may be important for anti-DoS reasons. (What I mean by this is that\nif you can easily create mutations of signatures, it may confuse software\nin similar ways to the Gox-era malleability attacks on wallet software of\nthe time.) But conversely, it is hard to enforce these rules as an\nimplementor, because libbitcoinconsensus does not expose them. So allowing\nboth forms of validation, to me, was an attempt to encourage adoption\nrather than anything principled.\n\nI didn't even consider the idea that validators should be able to signal \"this\nsignature appears to use future consensus rules\", although I should have been\nclued in by your \"upgradeable rules\" language that this was your goal. Now that\nyou say this, it's obvious that this is desireable, and also obvious that using\nthe \"inconclusive\" state is an elegant way to achieve this.\n\nI also agree that \"confirming validators should never disagree on valid vs\ninvalid\" is a good design goal and we should make that explicit.\n\n\nI'll add a commit to my PR at https://github.com/bitcoin/bips/pull/1048 which\nadds these thoughts.\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201222/0486ba26/attachment.sig>"
            },
            {
                "author": "Andrew Poelstra",
                "date": "2020-12-23T15:55:42",
                "message_text_only": "On Tue, Dec 22, 2020 at 12:22:37AM +0000, Pieter Wuille via bitcoin-dev wrote:\n> \n> Re-reading your proposed text, I'm wondering if the \"consensus-only validation\" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.\n> \n> What I'm suggestion could be specified this way:\n> * If validator understands the script:\n>   * If signature is consensus valid (as far as the validator knows):\n>     * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid\n>     * Otherwise: return inconclusive\n>   * Otherwise: return invalid\n> * Otherwise: return inconclusive\n> \n> Or in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.\n> \n> This has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.\n>\n\nI've updated my PR at https://github.com/bitcoin/bips/pull/1048\n\nDifferences:\n\n1. I compacted all the validation states into three: valid at time/age T/S, invalid,\n   and inconclusive.\n\n2. \"Inconclusive\" means either an \"upgradeable rule\" failed, e.g. use of a NOP or a\n   bad network version, or the validator just didn't understand the scripts.\n\n3. I removed the \"Extensions\" sections now everything is in the main protocol.\n\n4. I removed the \"to_sign\" transaction from the wire serialization, since after all\n   this, it can always be inferred from the message and address. (This does mean,\n   however, that there is no way to sign for scriptPubKeys that don't have addresses,\n   e.g. bare public keys or multisigs. I don't think it's worth complicated the\n   protocol for such obscure things.)\n\n-- \nAndrew Poelstra\nDirector of Research, Blockstream\nEmail: apoelstra at wpsoftware.net\nWeb:   https://www.wpsoftware.net/andrew\n\nThe sun is always shining in space\n    -Justin Lewis-Webster\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 488 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/858f723b/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "BIP-0322 (generic signmessage) improvements",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "Andrew Poelstra",
                "Pieter Wuille",
                "Karl-Johan Alm"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 38702
        }
    },
    {
        "title": "[bitcoin-dev] BIP Proposal: Wallet Interface",
        "thread_messages": [
            {
                "author": "monokh",
                "date": "2020-12-22T14:43:11",
                "message_text_only": "Hi\n\nThis is a first draft of a BIP we intend to submit. The main intention is\nto define a simple interface that wallets and applications can agree on\nthat would cover the vast majority of use cases. This can enable writing\nbitcoin applications (e.g. time lock, multi sig) on the web that can be\nseamlessly used with any compatible wallets. We have implementations of\nsuch examples but I don't want to turn this thread into a promotion and\nrather focus on the spec.\n\nAppreciate input from the list. Please share if there are existing efforts,\nrelevant specs or use cases.\n\n------------------------------\n\nA wallet interface specification for bitcoin applications\n\n## Abstract\n\nThis BIP describes an API for Bitcoin wallets and applications as a\nstandard.\n\n## Summary\n\nBitcoin wallets should expose their address derivation and signing\nfunctions to external applications. The interface would be expressed as\nfollows in javascript:\n\n```\n{\n// Wallet Metadata\nwallet: {\nname: 'Bitcoin Core'\n},\n\n// Request access to the wallet for the current host\nasync enable: (),\n\n// Request addresses and signatures from wallet\nasync request ({ method, params })\n}\n```\n\nIn the web context the interface could be exposed at the top level of a\nwebpage, for example under `window.bitcoin`. However this spec does not\nintend to define any standards for how and where the interfaces should be\nexposed.\n\n## Motivation\n\nDue to the seldom available APIs exposed by wallets, applications (web or\notherwise) are limited in how they are able to interact. Generally only\nsimple sends have been available. A more robust API that introduces other\nrequests will promote richer Bitcoin applications.\n\nAdditionally, wallet APIs have frequently included inconsistencies in their\ninterfaces and behaviour. This has required applications to build and\nmaintain a separate client for each wallet, increasing the risk of bugs and\nunintended behaviour as well as being a limiting factor for the adoption of\nusable bitcoin applications.\n\nWith a standardised wallet API:\n\n- Wallets have a clear API to implement\n- Applications have a clear expectation of wallet interface and behaviour\n- Applications become agnostic to the wallet specifics, increasing choice\nfor users\n\nIf more wallets implement the specification, applications will be developed\nmore confidently by benefiting from the wallet interoperability. This\ncreates a positive feedback loop.\n\n## Specification\n\nFor simplicity, the interface is defined in the context of web applications\nrunning in the browser (JS) however, they are simple enough to be easily\nimplemented in other contexts.\n\n### General Rules\n\n- For sensitive functions (e.g. signing), wallet software should always\nprompt the user for confirmation\n\n### Types\n\n**UserDeniedError**\nAn error type indicating that the application's request has been denied by\nthe user\nType: Error\n\n**Hex**\nType: String\nExample:\n`\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n\n**Address**\nAddress details\nType: Object\nExample:\n\n```\n{\n\"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n\"publicKey\":\n\"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n\"derivationPath\": \"84'/1'/0'/0/0\"\n}\n```\n\n### API\n\nThe wallet must implement the following methods.\n\n**enable**\n\nThe enable call prompts the user for access to the wallet.\n\nIf successful, it resolves to an address (`**Address**` type) of the\nwallet. Typically the first external address to be used as an identity.\n\n**`UserDeniedError`** will be thrown if the request is rejected.\n\n**request**\n\nThe request method must take one parameter in the following format:\n\n```\n{\n\"method\": \"wallet_methodName\",\n\"params\": [\"foo\", \"bar\", \"baz\"]\n}\n```\n\nFor a list of mandatory methods see Table\n\nThe wallet should reject request calls unless `enable` has been resolved.\n\nSensitive requests that involve signing should always prompt the user for\nconfirmation\n\nOn success the request should resolve to the response as defined in the\nmethod table.\n\n**`UserDeniedError`** will be thrown if the request is rejected.\n\n**Mandatory methods**\n\nmethod: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change\n= false`]\nreturn: `[ Address ]`\nerror: UserDeniedError\n\nmethod: `wallet_signMessage` params: `[ message, address ]`\nreturn: Signature `Hex`\nerror: UserDeniedError\n\nmethod: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`\nreturn: `psbtBase64`\nerror: UserDeniedError\n\nmethod: `wallet_getConnectedNetwork` params: `[]`\nreturn: Network object `mainnet` | `testnet` | `regetst`\nerror: UserDeniedError\n\n## Rationale\n\nThe purpose of the API is to expose a set of commonly used wallet\noperations. In addition, it should be flexible enough to serve for other\nrequests such as node RPC calls.\n\n**Why is there a singular request call instead of named methods?**\nThe transport layer for the requests cannot be assumed, therefore it is\nmuch more flexible to instead define an abstract format.\n\n**Why are the mandatory methods so primitive? Where is getBalance,\ngetUtxos, ... ?**\nA wallet need not worry about providing every possible scenario for usage.\nThe primitives of keys and signing can expose enough to applications to do\nthe rest. Applications should have flexibility in how they implement these\nfunctions. It is the role of a library rather than the wallet.\n\n## Security Implications\n\nGreat care should be taken when exposing wallet functionality externally as\nthe security and privacy of the user is at risk.\n\n### Signing\n\nOperations that trigger signing using private keys should be guarded behind\nconfirmation screens where the user is fully aware of the nature of the\ntransaction. In the example of a PSBT signature request, the outputs, the\ninputs and which key is being used should be clearly marked.\n\n### Privacy\n\nSome api methods expose metadata about the user, such as public keys.\nDepending on how privacy focused the wallet intends to be, the wallet could\nprotect these behind a confirmation. Commonly the wallet just needs to give\nthe origin access to all of its public keys, however it could also allow\nthe option to expose only selected derivation paths.\n\n-monokh\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201222/23f9734a/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2020-12-23T02:15:45",
                "message_text_only": "1) People should not be encouraged to write or use web browsers for their \nwallet.\n2) You may want to look over earlier work in this area.\n\nOn Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:\n> Hi\n>\n> This is a first draft of a BIP we intend to submit. The main intention is\n> to define a simple interface that wallets and applications can agree on\n> that would cover the vast majority of use cases. This can enable writing\n> bitcoin applications (e.g. time lock, multi sig) on the web that can be\n> seamlessly used with any compatible wallets. We have implementations of\n> such examples but I don't want to turn this thread into a promotion and\n> rather focus on the spec.\n>\n> Appreciate input from the list. Please share if there are existing efforts,\n> relevant specs or use cases.\n>\n> ------------------------------\n>\n> A wallet interface specification for bitcoin applications\n>\n> ## Abstract\n>\n> This BIP describes an API for Bitcoin wallets and applications as a\n> standard.\n>\n> ## Summary\n>\n> Bitcoin wallets should expose their address derivation and signing\n> functions to external applications. The interface would be expressed as\n> follows in javascript:\n>\n> ```\n> {\n> // Wallet Metadata\n> wallet: {\n> name: 'Bitcoin Core'\n> },\n>\n> // Request access to the wallet for the current host\n> async enable: (),\n>\n> // Request addresses and signatures from wallet\n> async request ({ method, params })\n> }\n> ```\n>\n> In the web context the interface could be exposed at the top level of a\n> webpage, for example under `window.bitcoin`. However this spec does not\n> intend to define any standards for how and where the interfaces should be\n> exposed.\n>\n> ## Motivation\n>\n> Due to the seldom available APIs exposed by wallets, applications (web or\n> otherwise) are limited in how they are able to interact. Generally only\n> simple sends have been available. A more robust API that introduces other\n> requests will promote richer Bitcoin applications.\n>\n> Additionally, wallet APIs have frequently included inconsistencies in their\n> interfaces and behaviour. This has required applications to build and\n> maintain a separate client for each wallet, increasing the risk of bugs and\n> unintended behaviour as well as being a limiting factor for the adoption of\n> usable bitcoin applications.\n>\n> With a standardised wallet API:\n>\n> - Wallets have a clear API to implement\n> - Applications have a clear expectation of wallet interface and behaviour\n> - Applications become agnostic to the wallet specifics, increasing choice\n> for users\n>\n> If more wallets implement the specification, applications will be developed\n> more confidently by benefiting from the wallet interoperability. This\n> creates a positive feedback loop.\n>\n> ## Specification\n>\n> For simplicity, the interface is defined in the context of web applications\n> running in the browser (JS) however, they are simple enough to be easily\n> implemented in other contexts.\n>\n> ### General Rules\n>\n> - For sensitive functions (e.g. signing), wallet software should always\n> prompt the user for confirmation\n>\n> ### Types\n>\n> **UserDeniedError**\n> An error type indicating that the application's request has been denied by\n> the user\n> Type: Error\n>\n> **Hex**\n> Type: String\n> Example:\n> `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n>\n> **Address**\n> Address details\n> Type: Object\n> Example:\n>\n> ```\n> {\n> \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n> \"publicKey\":\n> \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n> \"derivationPath\": \"84'/1'/0'/0/0\"\n> }\n> ```\n>\n> ### API\n>\n> The wallet must implement the following methods.\n>\n> **enable**\n>\n> The enable call prompts the user for access to the wallet.\n>\n> If successful, it resolves to an address (`**Address**` type) of the\n> wallet. Typically the first external address to be used as an identity.\n>\n> **`UserDeniedError`** will be thrown if the request is rejected.\n>\n> **request**\n>\n> The request method must take one parameter in the following format:\n>\n> ```\n> {\n> \"method\": \"wallet_methodName\",\n> \"params\": [\"foo\", \"bar\", \"baz\"]\n> }\n> ```\n>\n> For a list of mandatory methods see Table\n>\n> The wallet should reject request calls unless `enable` has been resolved.\n>\n> Sensitive requests that involve signing should always prompt the user for\n> confirmation\n>\n> On success the request should resolve to the response as defined in the\n> method table.\n>\n> **`UserDeniedError`** will be thrown if the request is rejected.\n>\n> **Mandatory methods**\n>\n> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change\n> = false`]\n> return: `[ Address ]`\n> error: UserDeniedError\n>\n> method: `wallet_signMessage` params: `[ message, address ]`\n> return: Signature `Hex`\n> error: UserDeniedError\n>\n> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`\n> return: `psbtBase64`\n> error: UserDeniedError\n>\n> method: `wallet_getConnectedNetwork` params: `[]`\n> return: Network object `mainnet` | `testnet` | `regetst`\n> error: UserDeniedError\n>\n> ## Rationale\n>\n> The purpose of the API is to expose a set of commonly used wallet\n> operations. In addition, it should be flexible enough to serve for other\n> requests such as node RPC calls.\n>\n> **Why is there a singular request call instead of named methods?**\n> The transport layer for the requests cannot be assumed, therefore it is\n> much more flexible to instead define an abstract format.\n>\n> **Why are the mandatory methods so primitive? Where is getBalance,\n> getUtxos, ... ?**\n> A wallet need not worry about providing every possible scenario for usage.\n> The primitives of keys and signing can expose enough to applications to do\n> the rest. Applications should have flexibility in how they implement these\n> functions. It is the role of a library rather than the wallet.\n>\n> ## Security Implications\n>\n> Great care should be taken when exposing wallet functionality externally as\n> the security and privacy of the user is at risk.\n>\n> ### Signing\n>\n> Operations that trigger signing using private keys should be guarded behind\n> confirmation screens where the user is fully aware of the nature of the\n> transaction. In the example of a PSBT signature request, the outputs, the\n> inputs and which key is being used should be clearly marked.\n>\n> ### Privacy\n>\n> Some api methods expose metadata about the user, such as public keys.\n> Depending on how privacy focused the wallet intends to be, the wallet could\n> protect these behind a confirmation. Commonly the wallet just needs to give\n> the origin access to all of its public keys, however it could also allow\n> the option to expose only selected derivation paths.\n>\n> -monokh"
            },
            {
                "author": "monokh",
                "date": "2020-12-23T07:29:23",
                "message_text_only": "Thanks for the input Luke.\n\n> 1) People should not be encouraged to write or use web browsers for their\nwallet.\n\nIndeed. Holding keys in the browser can be very insecure, however the spec\nis not limited to this. I will amend to make this clear. The same interface\ncan be used to communicate from a web context or even desktop application\nwith hardware wallets where keys are segregated safely. The prominent\nhardware wallets already have such an interface. Unfortunately as there has\nbeen no standardisation, an application must specifically provide an\nimplementation for each wallet to be compatible.\n\n> 2) You may want to look over earlier work in this area.\n\nPlease share if you have specifics in mind. What has been considered were\nmainly hardware wallet apis. The requests have been defined such that they\nwould be compatible. I will make references to such considerations in the\ntext. I welcome any feedback on what may be missing or problematic for\nthese providers - something I will also pursue outwith the thread.\n\n-monokh\n\nOn Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org> wrote:\n\n> 1) People should not be encouraged to write or use web browsers for their\n> wallet.\n> 2) You may want to look over earlier work in this area.\n>\n> On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:\n> > Hi\n> >\n> > This is a first draft of a BIP we intend to submit. The main intention is\n> > to define a simple interface that wallets and applications can agree on\n> > that would cover the vast majority of use cases. This can enable writing\n> > bitcoin applications (e.g. time lock, multi sig) on the web that can be\n> > seamlessly used with any compatible wallets. We have implementations of\n> > such examples but I don't want to turn this thread into a promotion and\n> > rather focus on the spec.\n> >\n> > Appreciate input from the list. Please share if there are existing\n> efforts,\n> > relevant specs or use cases.\n> >\n> > ------------------------------\n> >\n> > A wallet interface specification for bitcoin applications\n> >\n> > ## Abstract\n> >\n> > This BIP describes an API for Bitcoin wallets and applications as a\n> > standard.\n> >\n> > ## Summary\n> >\n> > Bitcoin wallets should expose their address derivation and signing\n> > functions to external applications. The interface would be expressed as\n> > follows in javascript:\n> >\n> > ```\n> > {\n> > // Wallet Metadata\n> > wallet: {\n> > name: 'Bitcoin Core'\n> > },\n> >\n> > // Request access to the wallet for the current host\n> > async enable: (),\n> >\n> > // Request addresses and signatures from wallet\n> > async request ({ method, params })\n> > }\n> > ```\n> >\n> > In the web context the interface could be exposed at the top level of a\n> > webpage, for example under `window.bitcoin`. However this spec does not\n> > intend to define any standards for how and where the interfaces should be\n> > exposed.\n> >\n> > ## Motivation\n> >\n> > Due to the seldom available APIs exposed by wallets, applications (web or\n> > otherwise) are limited in how they are able to interact. Generally only\n> > simple sends have been available. A more robust API that introduces other\n> > requests will promote richer Bitcoin applications.\n> >\n> > Additionally, wallet APIs have frequently included inconsistencies in\n> their\n> > interfaces and behaviour. This has required applications to build and\n> > maintain a separate client for each wallet, increasing the risk of bugs\n> and\n> > unintended behaviour as well as being a limiting factor for the adoption\n> of\n> > usable bitcoin applications.\n> >\n> > With a standardised wallet API:\n> >\n> > - Wallets have a clear API to implement\n> > - Applications have a clear expectation of wallet interface and behaviour\n> > - Applications become agnostic to the wallet specifics, increasing choice\n> > for users\n> >\n> > If more wallets implement the specification, applications will be\n> developed\n> > more confidently by benefiting from the wallet interoperability. This\n> > creates a positive feedback loop.\n> >\n> > ## Specification\n> >\n> > For simplicity, the interface is defined in the context of web\n> applications\n> > running in the browser (JS) however, they are simple enough to be easily\n> > implemented in other contexts.\n> >\n> > ### General Rules\n> >\n> > - For sensitive functions (e.g. signing), wallet software should always\n> > prompt the user for confirmation\n> >\n> > ### Types\n> >\n> > **UserDeniedError**\n> > An error type indicating that the application's request has been denied\n> by\n> > the user\n> > Type: Error\n> >\n> > **Hex**\n> > Type: String\n> > Example:\n> > `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n> >\n> > **Address**\n> > Address details\n> > Type: Object\n> > Example:\n> >\n> > ```\n> > {\n> > \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n> > \"publicKey\":\n> > \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n> > \"derivationPath\": \"84'/1'/0'/0/0\"\n> > }\n> > ```\n> >\n> > ### API\n> >\n> > The wallet must implement the following methods.\n> >\n> > **enable**\n> >\n> > The enable call prompts the user for access to the wallet.\n> >\n> > If successful, it resolves to an address (`**Address**` type) of the\n> > wallet. Typically the first external address to be used as an identity.\n> >\n> > **`UserDeniedError`** will be thrown if the request is rejected.\n> >\n> > **request**\n> >\n> > The request method must take one parameter in the following format:\n> >\n> > ```\n> > {\n> > \"method\": \"wallet_methodName\",\n> > \"params\": [\"foo\", \"bar\", \"baz\"]\n> > }\n> > ```\n> >\n> > For a list of mandatory methods see Table\n> >\n> > The wallet should reject request calls unless `enable` has been resolved.\n> >\n> > Sensitive requests that involve signing should always prompt the user for\n> > confirmation\n> >\n> > On success the request should resolve to the response as defined in the\n> > method table.\n> >\n> > **`UserDeniedError`** will be thrown if the request is rejected.\n> >\n> > **Mandatory methods**\n> >\n> > method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1,\n> change\n> > = false`]\n> > return: `[ Address ]`\n> > error: UserDeniedError\n> >\n> > method: `wallet_signMessage` params: `[ message, address ]`\n> > return: Signature `Hex`\n> > error: UserDeniedError\n> >\n> > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`\n> > return: `psbtBase64`\n> > error: UserDeniedError\n> >\n> > method: `wallet_getConnectedNetwork` params: `[]`\n> > return: Network object `mainnet` | `testnet` | `regetst`\n> > error: UserDeniedError\n> >\n> > ## Rationale\n> >\n> > The purpose of the API is to expose a set of commonly used wallet\n> > operations. In addition, it should be flexible enough to serve for other\n> > requests such as node RPC calls.\n> >\n> > **Why is there a singular request call instead of named methods?**\n> > The transport layer for the requests cannot be assumed, therefore it is\n> > much more flexible to instead define an abstract format.\n> >\n> > **Why are the mandatory methods so primitive? Where is getBalance,\n> > getUtxos, ... ?**\n> > A wallet need not worry about providing every possible scenario for\n> usage.\n> > The primitives of keys and signing can expose enough to applications to\n> do\n> > the rest. Applications should have flexibility in how they implement\n> these\n> > functions. It is the role of a library rather than the wallet.\n> >\n> > ## Security Implications\n> >\n> > Great care should be taken when exposing wallet functionality externally\n> as\n> > the security and privacy of the user is at risk.\n> >\n> > ### Signing\n> >\n> > Operations that trigger signing using private keys should be guarded\n> behind\n> > confirmation screens where the user is fully aware of the nature of the\n> > transaction. In the example of a PSBT signature request, the outputs, the\n> > inputs and which key is being used should be clearly marked.\n> >\n> > ### Privacy\n> >\n> > Some api methods expose metadata about the user, such as public keys.\n> > Depending on how privacy focused the wallet intends to be, the wallet\n> could\n> > protect these behind a confirmation. Commonly the wallet just needs to\n> give\n> > the origin access to all of its public keys, however it could also allow\n> > the option to expose only selected derivation paths.\n> >\n> > -monokh\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/d52102d4/attachment-0001.html>"
            },
            {
                "author": "Omar Shibli",
                "date": "2020-12-23T11:44:52",
                "message_text_only": "That's a great idea, in traditional banking there are wide initiatives to\nstandardize components between different actors, most widely used is Open\nBanking , i think regardless of the usage, it could be hardware or\nsoftware, there is a big value in standrizating communications between\ndifferent components.\n\nHere is more info about Open Banking:\nhttps://fin.plaid.com/articles/what-is-the-open-banking-standard/#:~:text=The%20Open%20Banking%20Standard%20relies,data%20through%20their%20bank%20accounts\n\nOn Wed, Dec 23, 2020 at 10:42 AM monokh via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Thanks for the input Luke.\n>\n> > 1) People should not be encouraged to write or use web browsers for\n> their wallet.\n>\n> Indeed. Holding keys in the browser can be very insecure, however the spec\n> is not limited to this. I will amend to make this clear. The same interface\n> can be used to communicate from a web context or even desktop application\n> with hardware wallets where keys are segregated safely. The prominent\n> hardware wallets already have such an interface. Unfortunately as there has\n> been no standardisation, an application must specifically provide an\n> implementation for each wallet to be compatible.\n>\n> > 2) You may want to look over earlier work in this area.\n>\n> Please share if you have specifics in mind. What has been considered were\n> mainly hardware wallet apis. The requests have been defined such that they\n> would be compatible. I will make references to such considerations in the\n> text. I welcome any feedback on what may be missing or problematic for\n> these providers - something I will also pursue outwith the thread.\n>\n> -monokh\n>\n> On Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org> wrote:\n>\n>> 1) People should not be encouraged to write or use web browsers for their\n>> wallet.\n>> 2) You may want to look over earlier work in this area.\n>>\n>> On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:\n>> > Hi\n>> >\n>> > This is a first draft of a BIP we intend to submit. The main intention\n>> is\n>> > to define a simple interface that wallets and applications can agree on\n>> > that would cover the vast majority of use cases. This can enable writing\n>> > bitcoin applications (e.g. time lock, multi sig) on the web that can be\n>> > seamlessly used with any compatible wallets. We have implementations of\n>> > such examples but I don't want to turn this thread into a promotion and\n>> > rather focus on the spec.\n>> >\n>> > Appreciate input from the list. Please share if there are existing\n>> efforts,\n>> > relevant specs or use cases.\n>> >\n>> > ------------------------------\n>> >\n>> > A wallet interface specification for bitcoin applications\n>> >\n>> > ## Abstract\n>> >\n>> > This BIP describes an API for Bitcoin wallets and applications as a\n>> > standard.\n>> >\n>> > ## Summary\n>> >\n>> > Bitcoin wallets should expose their address derivation and signing\n>> > functions to external applications. The interface would be expressed as\n>> > follows in javascript:\n>> >\n>> > ```\n>> > {\n>> > // Wallet Metadata\n>> > wallet: {\n>> > name: 'Bitcoin Core'\n>> > },\n>> >\n>> > // Request access to the wallet for the current host\n>> > async enable: (),\n>> >\n>> > // Request addresses and signatures from wallet\n>> > async request ({ method, params })\n>> > }\n>> > ```\n>> >\n>> > In the web context the interface could be exposed at the top level of a\n>> > webpage, for example under `window.bitcoin`. However this spec does not\n>> > intend to define any standards for how and where the interfaces should\n>> be\n>> > exposed.\n>> >\n>> > ## Motivation\n>> >\n>> > Due to the seldom available APIs exposed by wallets, applications (web\n>> or\n>> > otherwise) are limited in how they are able to interact. Generally only\n>> > simple sends have been available. A more robust API that introduces\n>> other\n>> > requests will promote richer Bitcoin applications.\n>> >\n>> > Additionally, wallet APIs have frequently included inconsistencies in\n>> their\n>> > interfaces and behaviour. This has required applications to build and\n>> > maintain a separate client for each wallet, increasing the risk of bugs\n>> and\n>> > unintended behaviour as well as being a limiting factor for the\n>> adoption of\n>> > usable bitcoin applications.\n>> >\n>> > With a standardised wallet API:\n>> >\n>> > - Wallets have a clear API to implement\n>> > - Applications have a clear expectation of wallet interface and\n>> behaviour\n>> > - Applications become agnostic to the wallet specifics, increasing\n>> choice\n>> > for users\n>> >\n>> > If more wallets implement the specification, applications will be\n>> developed\n>> > more confidently by benefiting from the wallet interoperability. This\n>> > creates a positive feedback loop.\n>> >\n>> > ## Specification\n>> >\n>> > For simplicity, the interface is defined in the context of web\n>> applications\n>> > running in the browser (JS) however, they are simple enough to be easily\n>> > implemented in other contexts.\n>> >\n>> > ### General Rules\n>> >\n>> > - For sensitive functions (e.g. signing), wallet software should always\n>> > prompt the user for confirmation\n>> >\n>> > ### Types\n>> >\n>> > **UserDeniedError**\n>> > An error type indicating that the application's request has been denied\n>> by\n>> > the user\n>> > Type: Error\n>> >\n>> > **Hex**\n>> > Type: String\n>> > Example:\n>> > `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n>> >\n>> > **Address**\n>> > Address details\n>> > Type: Object\n>> > Example:\n>> >\n>> > ```\n>> > {\n>> > \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n>> > \"publicKey\":\n>> > \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n>> > \"derivationPath\": \"84'/1'/0'/0/0\"\n>> > }\n>> > ```\n>> >\n>> > ### API\n>> >\n>> > The wallet must implement the following methods.\n>> >\n>> > **enable**\n>> >\n>> > The enable call prompts the user for access to the wallet.\n>> >\n>> > If successful, it resolves to an address (`**Address**` type) of the\n>> > wallet. Typically the first external address to be used as an identity.\n>> >\n>> > **`UserDeniedError`** will be thrown if the request is rejected.\n>> >\n>> > **request**\n>> >\n>> > The request method must take one parameter in the following format:\n>> >\n>> > ```\n>> > {\n>> > \"method\": \"wallet_methodName\",\n>> > \"params\": [\"foo\", \"bar\", \"baz\"]\n>> > }\n>> > ```\n>> >\n>> > For a list of mandatory methods see Table\n>> >\n>> > The wallet should reject request calls unless `enable` has been\n>> resolved.\n>> >\n>> > Sensitive requests that involve signing should always prompt the user\n>> for\n>> > confirmation\n>> >\n>> > On success the request should resolve to the response as defined in the\n>> > method table.\n>> >\n>> > **`UserDeniedError`** will be thrown if the request is rejected.\n>> >\n>> > **Mandatory methods**\n>> >\n>> > method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1,\n>> change\n>> > = false`]\n>> > return: `[ Address ]`\n>> > error: UserDeniedError\n>> >\n>> > method: `wallet_signMessage` params: `[ message, address ]`\n>> > return: Signature `Hex`\n>> > error: UserDeniedError\n>> >\n>> > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address]\n>> ]`\n>> > return: `psbtBase64`\n>> > error: UserDeniedError\n>> >\n>> > method: `wallet_getConnectedNetwork` params: `[]`\n>> > return: Network object `mainnet` | `testnet` | `regetst`\n>> > error: UserDeniedError\n>> >\n>> > ## Rationale\n>> >\n>> > The purpose of the API is to expose a set of commonly used wallet\n>> > operations. In addition, it should be flexible enough to serve for other\n>> > requests such as node RPC calls.\n>> >\n>> > **Why is there a singular request call instead of named methods?**\n>> > The transport layer for the requests cannot be assumed, therefore it is\n>> > much more flexible to instead define an abstract format.\n>> >\n>> > **Why are the mandatory methods so primitive? Where is getBalance,\n>> > getUtxos, ... ?**\n>> > A wallet need not worry about providing every possible scenario for\n>> usage.\n>> > The primitives of keys and signing can expose enough to applications to\n>> do\n>> > the rest. Applications should have flexibility in how they implement\n>> these\n>> > functions. It is the role of a library rather than the wallet.\n>> >\n>> > ## Security Implications\n>> >\n>> > Great care should be taken when exposing wallet functionality\n>> externally as\n>> > the security and privacy of the user is at risk.\n>> >\n>> > ### Signing\n>> >\n>> > Operations that trigger signing using private keys should be guarded\n>> behind\n>> > confirmation screens where the user is fully aware of the nature of the\n>> > transaction. In the example of a PSBT signature request, the outputs,\n>> the\n>> > inputs and which key is being used should be clearly marked.\n>> >\n>> > ### Privacy\n>> >\n>> > Some api methods expose metadata about the user, such as public keys.\n>> > Depending on how privacy focused the wallet intends to be, the wallet\n>> could\n>> > protect these behind a confirmation. Commonly the wallet just needs to\n>> give\n>> > the origin access to all of its public keys, however it could also allow\n>> > the option to expose only selected derivation paths.\n>> >\n>> > -monokh\n>>\n>> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/3dbdb744/attachment-0001.html>"
            },
            {
                "author": "Aymeric Vitte",
                "date": "2020-12-25T11:49:11",
                "message_text_only": "Resending to the list since I am using a different email\n\nComplement: if anonymity is required from the browser (or elsewhere) you\nmight consider looking at https://github.com/Ayms/node-Tor too\n\n\nLe 24/12/2020 \u00e0 20:40, Aymeric Vitte a \u00e9crit :\n>\n> You might want to take a look at: https://peersm.com/wallet\n>\n> And https://github.com/Ayms/bitcoin-transactions\n>\n> \"wallet\" is not the very correct word, it's more bitcoin cli outside\n> of bitcoin core but for now not linked to an explorer/tx system which\n> makes it probably still not so easy to use for the transactions part\n> (which can be extended to lightning, etc)\n>\n> The idea is to propose to people most of the tools they need to manage\n> their coins by themselves, or at least understand better what they are\n> doing\n>\n> \"People should not be encouraged to write or use web browsers for\n> their wallet.\" --> yes and no, please crack the standalone webapp\n> above, so it's finally a no when things are done correctly, of course\n> there is no story of keys storage inside browsers or online stuff with\n> keys\n>\n> Maybe this can be turned one day into a w3c api like webcrypto\n> (window.bitcoin as you sketch)\n>\n> Le 23/12/2020 \u00e0 08:29, monokh via bitcoin-dev a \u00e9crit :\n>> Thanks for the input Luke.\n>>\n>> > 1) People should not be encouraged to write or use web browsers for\n>> their wallet.\n>>\n>> Indeed. Holding keys in the browser can be very insecure, however the\n>> spec is not limited to this. I will amend to make this clear. The\n>> same interface can be used to communicate from a web context or even\n>> desktop application with hardware wallets where keys are segregated\n>> safely. The prominent hardware wallets already have such an\n>> interface. Unfortunately as there has been no standardisation, an\n>> application must specifically provide an implementation for each\n>> wallet to be compatible.\n>>\n>> > 2) You may want to look over earlier work in this area.\n>>\n>> Please share if you have specifics in mind. What has been considered\n>> were mainly hardware wallet apis. The requests have been defined such\n>> that they would be compatible. I will make references to such\n>> considerations in the text. I welcome any feedback on what may be\n>> missing or problematic for these providers - something I will also\n>> pursue outwith the thread.\n>>\n>> -monokh \n>>\n>> On Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org\n>> <mailto:luke at dashjr.org>> wrote:\n>>\n>>     1) People should not be encouraged to write or use web browsers\n>>     for their\n>>     wallet.\n>>     2) You may want to look over earlier work in this area.\n>>\n>>     On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:\n>>     > Hi\n>>     >\n>>     > This is a first draft of a BIP we intend to submit. The main\n>>     intention is\n>>     > to define a simple interface that wallets and applications can\n>>     agree on\n>>     > that would cover the vast majority of use cases. This can\n>>     enable writing\n>>     > bitcoin applications (e.g. time lock, multi sig) on the web\n>>     that can be\n>>     > seamlessly used with any compatible wallets. We have\n>>     implementations of\n>>     > such examples but I don't want to turn this thread into a\n>>     promotion and\n>>     > rather focus on the spec.\n>>     >\n>>     > Appreciate input from the list. Please share if there are\n>>     existing efforts,\n>>     > relevant specs or use cases.\n>>     >\n>>     > ------------------------------\n>>     >\n>>     > A wallet interface specification for bitcoin applications\n>>     >\n>>     > ## Abstract\n>>     >\n>>     > This BIP describes an API for Bitcoin wallets and applications as a\n>>     > standard.\n>>     >\n>>     > ## Summary\n>>     >\n>>     > Bitcoin wallets should expose their address derivation and signing\n>>     > functions to external applications. The interface would be\n>>     expressed as\n>>     > follows in javascript:\n>>     >\n>>     > ```\n>>     > {\n>>     > // Wallet Metadata\n>>     > wallet: {\n>>     > name: 'Bitcoin Core'\n>>     > },\n>>     >\n>>     > // Request access to the wallet for the current host\n>>     > async enable: (),\n>>     >\n>>     > // Request addresses and signatures from wallet\n>>     > async request ({ method, params })\n>>     > }\n>>     > ```\n>>     >\n>>     > In the web context the interface could be exposed at the top\n>>     level of a\n>>     > webpage, for example under `window.bitcoin`. However this spec\n>>     does not\n>>     > intend to define any standards for how and where the interfaces\n>>     should be\n>>     > exposed.\n>>     >\n>>     > ## Motivation\n>>     >\n>>     > Due to the seldom available APIs exposed by wallets,\n>>     applications (web or\n>>     > otherwise) are limited in how they are able to interact.\n>>     Generally only\n>>     > simple sends have been available. A more robust API that\n>>     introduces other\n>>     > requests will promote richer Bitcoin applications.\n>>     >\n>>     > Additionally, wallet APIs have frequently included\n>>     inconsistencies in their\n>>     > interfaces and behaviour. This has required applications to\n>>     build and\n>>     > maintain a separate client for each wallet, increasing the risk\n>>     of bugs and\n>>     > unintended behaviour as well as being a limiting factor for the\n>>     adoption of\n>>     > usable bitcoin applications.\n>>     >\n>>     > With a standardised wallet API:\n>>     >\n>>     > - Wallets have a clear API to implement\n>>     > - Applications have a clear expectation of wallet interface and\n>>     behaviour\n>>     > - Applications become agnostic to the wallet specifics,\n>>     increasing choice\n>>     > for users\n>>     >\n>>     > If more wallets implement the specification, applications will\n>>     be developed\n>>     > more confidently by benefiting from the wallet\n>>     interoperability. This\n>>     > creates a positive feedback loop.\n>>     >\n>>     > ## Specification\n>>     >\n>>     > For simplicity, the interface is defined in the context of web\n>>     applications\n>>     > running in the browser (JS) however, they are simple enough to\n>>     be easily\n>>     > implemented in other contexts.\n>>     >\n>>     > ### General Rules\n>>     >\n>>     > - For sensitive functions (e.g. signing), wallet software\n>>     should always\n>>     > prompt the user for confirmation\n>>     >\n>>     > ### Types\n>>     >\n>>     > **UserDeniedError**\n>>     > An error type indicating that the application's request has\n>>     been denied by\n>>     > the user\n>>     > Type: Error\n>>     >\n>>     > **Hex**\n>>     > Type: String\n>>     > Example:\n>>     >\n>>     `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n>>     >\n>>     > **Address**\n>>     > Address details\n>>     > Type: Object\n>>     > Example:\n>>     >\n>>     > ```\n>>     > {\n>>     > \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n>>     > \"publicKey\":\n>>     >\n>>     \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n>>     > \"derivationPath\": \"84'/1'/0'/0/0\"\n>>     > }\n>>     > ```\n>>     >\n>>     > ### API\n>>     >\n>>     > The wallet must implement the following methods.\n>>     >\n>>     > **enable**\n>>     >\n>>     > The enable call prompts the user for access to the wallet.\n>>     >\n>>     > If successful, it resolves to an address (`**Address**` type)\n>>     of the\n>>     > wallet. Typically the first external address to be used as an\n>>     identity.\n>>     >\n>>     > **`UserDeniedError`** will be thrown if the request is rejected.\n>>     >\n>>     > **request**\n>>     >\n>>     > The request method must take one parameter in the following format:\n>>     >\n>>     > ```\n>>     > {\n>>     > \"method\": \"wallet_methodName\",\n>>     > \"params\": [\"foo\", \"bar\", \"baz\"]\n>>     > }\n>>     > ```\n>>     >\n>>     > For a list of mandatory methods see Table\n>>     >\n>>     > The wallet should reject request calls unless `enable` has been\n>>     resolved.\n>>     >\n>>     > Sensitive requests that involve signing should always prompt\n>>     the user for\n>>     > confirmation\n>>     >\n>>     > On success the request should resolve to the response as\n>>     defined in the\n>>     > method table.\n>>     >\n>>     > **`UserDeniedError`** will be thrown if the request is rejected.\n>>     >\n>>     > **Mandatory methods**\n>>     >\n>>     > method: `wallet_getAddresses` params: [`index = 0, numAddresses\n>>     = 1, change\n>>     > = false`]\n>>     > return: `[ Address ]`\n>>     > error: UserDeniedError\n>>     >\n>>     > method: `wallet_signMessage` params: `[ message, address ]`\n>>     > return: Signature `Hex`\n>>     > error: UserDeniedError\n>>     >\n>>     > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex,\n>>     address] ]`\n>>     > return: `psbtBase64`\n>>     > error: UserDeniedError\n>>     >\n>>     > method: `wallet_getConnectedNetwork` params: `[]`\n>>     > return: Network object `mainnet` | `testnet` | `regetst`\n>>     > error: UserDeniedError\n>>     >\n>>     > ## Rationale\n>>     >\n>>     > The purpose of the API is to expose a set of commonly used wallet\n>>     > operations. In addition, it should be flexible enough to serve\n>>     for other\n>>     > requests such as node RPC calls.\n>>     >\n>>     > **Why is there a singular request call instead of named methods?**\n>>     > The transport layer for the requests cannot be assumed,\n>>     therefore it is\n>>     > much more flexible to instead define an abstract format.\n>>     >\n>>     > **Why are the mandatory methods so primitive? Where is getBalance,\n>>     > getUtxos, ... ?**\n>>     > A wallet need not worry about providing every possible scenario\n>>     for usage.\n>>     > The primitives of keys and signing can expose enough to\n>>     applications to do\n>>     > the rest. Applications should have flexibility in how they\n>>     implement these\n>>     > functions. It is the role of a library rather than the wallet.\n>>     >\n>>     > ## Security Implications\n>>     >\n>>     > Great care should be taken when exposing wallet functionality\n>>     externally as\n>>     > the security and privacy of the user is at risk.\n>>     >\n>>     > ### Signing\n>>     >\n>>     > Operations that trigger signing using private keys should be\n>>     guarded behind\n>>     > confirmation screens where the user is fully aware of the\n>>     nature of the\n>>     > transaction. In the example of a PSBT signature request, the\n>>     outputs, the\n>>     > inputs and which key is being used should be clearly marked.\n>>     >\n>>     > ### Privacy\n>>     >\n>>     > Some api methods expose metadata about the user, such as public\n>>     keys.\n>>     > Depending on how privacy focused the wallet intends to be, the\n>>     wallet could\n>>     > protect these behind a confirmation. Commonly the wallet just\n>>     needs to give\n>>     > the origin access to all of its public keys, however it could\n>>     also allow\n>>     > the option to expose only selected derivation paths.\n>>     >\n>>     > -monokh\n>>\n>>\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n> -- \n> Sophia-Antipolis, France\n> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\n> Move your coins by yourself (browser version): https://peersm.com/wallet\n> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\n> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets\n> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\n> Get the torrent dynamic blocklist: http://peersm.com/getblocklist\n> Check the 10 M passwords list: http://peersm.com/findmyass\n> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org\n> Peersm : http://www.peersm.com\n> torrent-live: https://github.com/Ayms/torrent-live\n> node-Tor : https://www.github.com/Ayms/node-Tor\n> GitHub : https://www.github.com/Ayms\n\n-- \nSophia-Antipolis, France\nLinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26\nMove your coins by yourself (browser version): https://peersm.com/wallet\nBitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions\nZcash wallets made simple: https://github.com/Ayms/zcash-wallets\nBitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets\nGet the torrent dynamic blocklist: http://peersm.com/getblocklist\nCheck the 10 M passwords list: http://peersm.com/findmyass\nAnti-spies and private torrents, dynamic blocklist: http://torrent-live.org\nPeersm : http://www.peersm.com\ntorrent-live: https://github.com/Ayms/torrent-live\nnode-Tor : https://www.github.com/Ayms/node-Tor\nGitHub : https://www.github.com/Ayms\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201225/4362e66c/attachment-0001.html>"
            },
            {
                "author": "Erik Aronesty",
                "date": "2020-12-23T21:13:29",
                "message_text_only": "Obviously Bitcoin has a wallet api, intermingled with other protocol APIs:\n\nhttps://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list\n\nFor security, a standard wallet API should write a token/port to a\nlocal file where the user can grab that token and use it (that's\nbasically how the existing bitcoind does it, with a username/password\nliving in a file... not as nice as a token/port, IMO)\n\nProbably any such standards document should do its best to be\ncompatible with the existing APIs that so many are already familiar\nwith.   Or maybe I misunderstand the proposal.\n\n- Erik\n\nOn Tue, Dec 22, 2020 at 9:48 AM monokh via bitcoin-dev\n<bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> Hi\n>\n> This is a first draft of a BIP we intend to submit. The main intention is to define a simple interface that wallets and applications can agree on that would cover the vast majority of use cases. This can enable writing bitcoin applications (e.g. time lock, multi sig) on the web that can be seamlessly used with any compatible wallets. We have implementations of such examples but I don't want to turn this thread into a promotion and rather focus on the spec.\n>\n> Appreciate input from the list. Please share if there are existing efforts, relevant specs or use cases.\n>\n> ------------------------------\n>\n> A wallet interface specification for bitcoin applications\n>\n> ## Abstract\n>\n> This BIP describes an API for Bitcoin wallets and applications as a standard.\n>\n> ## Summary\n>\n> Bitcoin wallets should expose their address derivation and signing functions to external applications. The interface would be expressed as follows in javascript:\n>\n> ```\n> {\n> // Wallet Metadata\n> wallet: {\n> name: 'Bitcoin Core'\n> },\n>\n> // Request access to the wallet for the current host\n> async enable: (),\n>\n> // Request addresses and signatures from wallet\n> async request ({ method, params })\n> }\n> ```\n>\n> In the web context the interface could be exposed at the top level of a webpage, for example under `window.bitcoin`. However this spec does not intend to define any standards for how and where the interfaces should be exposed.\n>\n> ## Motivation\n>\n> Due to the seldom available APIs exposed by wallets, applications (web or otherwise) are limited in how they are able to interact. Generally only simple sends have been available. A more robust API that introduces other requests will promote richer Bitcoin applications.\n>\n> Additionally, wallet APIs have frequently included inconsistencies in their interfaces and behaviour. This has required applications to build and maintain a separate client for each wallet, increasing the risk of bugs and unintended behaviour as well as being a limiting factor for the adoption of usable bitcoin applications.\n>\n> With a standardised wallet API:\n>\n> - Wallets have a clear API to implement\n> - Applications have a clear expectation of wallet interface and behaviour\n> - Applications become agnostic to the wallet specifics, increasing choice for users\n>\n> If more wallets implement the specification, applications will be developed more confidently by benefiting from the wallet interoperability. This creates a positive feedback loop.\n>\n> ## Specification\n>\n> For simplicity, the interface is defined in the context of web applications running in the browser (JS) however, they are simple enough to be easily implemented in other contexts.\n>\n> ### General Rules\n>\n> - For sensitive functions (e.g. signing), wallet software should always prompt the user for confirmation\n>\n> ### Types\n>\n> **UserDeniedError**\n> An error type indicating that the application's request has been denied by the user\n> Type: Error\n>\n> **Hex**\n> Type: String\n> Example: `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n>\n> **Address**\n> Address details\n> Type: Object\n> Example:\n>\n> ```\n> {\n> \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n> \"publicKey\": \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n> \"derivationPath\": \"84'/1'/0'/0/0\"\n> }\n> ```\n>\n> ### API\n>\n> The wallet must implement the following methods.\n>\n> **enable**\n>\n> The enable call prompts the user for access to the wallet.\n>\n> If successful, it resolves to an address (`**Address**` type) of the wallet. Typically the first external address to be used as an identity.\n>\n> **`UserDeniedError`** will be thrown if the request is rejected.\n>\n> **request**\n>\n> The request method must take one parameter in the following format:\n>\n> ```\n> {\n> \"method\": \"wallet_methodName\",\n> \"params\": [\"foo\", \"bar\", \"baz\"]\n> }\n> ```\n>\n> For a list of mandatory methods see Table\n>\n> The wallet should reject request calls unless `enable` has been resolved.\n>\n> Sensitive requests that involve signing should always prompt the user for confirmation\n>\n> On success the request should resolve to the response as defined in the method table.\n>\n> **`UserDeniedError`** will be thrown if the request is rejected.\n>\n> **Mandatory methods**\n>\n> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change = false`]\n> return: `[ Address ]`\n> error: UserDeniedError\n>\n> method: `wallet_signMessage` params: `[ message, address ]`\n> return: Signature `Hex`\n> error: UserDeniedError\n>\n> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`\n> return: `psbtBase64`\n> error: UserDeniedError\n>\n> method: `wallet_getConnectedNetwork` params: `[]`\n> return: Network object `mainnet` | `testnet` | `regetst`\n> error: UserDeniedError\n>\n> ## Rationale\n>\n> The purpose of the API is to expose a set of commonly used wallet operations. In addition, it should be flexible enough to serve for other requests such as node RPC calls.\n>\n> **Why is there a singular request call instead of named methods?**\n> The transport layer for the requests cannot be assumed, therefore it is much more flexible to instead define an abstract format.\n>\n> **Why are the mandatory methods so primitive? Where is getBalance, getUtxos, ... ?**\n> A wallet need not worry about providing every possible scenario for usage. The primitives of keys and signing can expose enough to applications to do the rest. Applications should have flexibility in how they implement these functions. It is the role of a library rather than the wallet.\n>\n> ## Security Implications\n>\n> Great care should be taken when exposing wallet functionality externally as the security and privacy of the user is at risk.\n>\n> ### Signing\n>\n> Operations that trigger signing using private keys should be guarded behind confirmation screens where the user is fully aware of the nature of the transaction. In the example of a PSBT signature request, the outputs, the inputs and which key is being used should be clearly marked.\n>\n> ### Privacy\n>\n> Some api methods expose metadata about the user, such as public keys. Depending on how privacy focused the wallet intends to be, the wallet could protect these behind a confirmation. Commonly the wallet just needs to give the origin access to all of its public keys, however it could also allow the option to expose only selected derivation paths.\n>\n> -monokh\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Shane Jonas",
                "date": "2020-12-25T18:11:23",
                "message_text_only": "There\u2019s a BIP to create a standard API document for the Bitcoin JSON-RPC API \nhttps://github.com/bitcoin/bips/pull/776\n\nhere\u2019s an example of the generic ethereum api https://github.com/etclabscore/ethereum-json-rpc-specification/blob/master/openrpc.json\n\nand another example of just the wallet interface https://github.com/etclabscore/signatory/blob/master/openrpc.json\n\nhere\u2019s a live demo with interactive documentation:\n\nhttps://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/etclabscore/ethereum-json-rpc-specification/master/openrpc.json\n\nCreating a standard api document like this makes it a lot easier to build dev tools and documentation.\n\nI\u2019d love to help document the bitcoin JSON-RPC API, let me know how I can help.\n\n> On Dec 23, 2020, at 6:15 PM, Erik Aronesty via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> \n> \ufeffObviously Bitcoin has a wallet api, intermingled with other protocol APIs:\n> \n> https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list\n> \n> For security, a standard wallet API should write a token/port to a\n> local file where the user can grab that token and use it (that's\n> basically how the existing bitcoind does it, with a username/password\n> living in a file... not as nice as a token/port, IMO)\n> \n> Probably any such standards document should do its best to be\n> compatible with the existing APIs that so many are already familiar\n> with.   Or maybe I misunderstand the proposal.\n> \n> - Erik\n> \n>> On Tue, Dec 22, 2020 at 9:48 AM monokh via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>> \n>> Hi\n>> \n>> This is a first draft of a BIP we intend to submit. The main intention is to define a simple interface that wallets and applications can agree on that would cover the vast majority of use cases. This can enable writing bitcoin applications (e.g. time lock, multi sig) on the web that can be seamlessly used with any compatible wallets. We have implementations of such examples but I don't want to turn this thread into a promotion and rather focus on the spec.\n>> \n>> Appreciate input from the list. Please share if there are existing efforts, relevant specs or use cases.\n>> \n>> ------------------------------\n>> \n>> A wallet interface specification for bitcoin applications\n>> \n>> ## Abstract\n>> \n>> This BIP describes an API for Bitcoin wallets and applications as a standard.\n>> \n>> ## Summary\n>> \n>> Bitcoin wallets should expose their address derivation and signing functions to external applications. The interface would be expressed as follows in javascript:\n>> \n>> ```\n>> {\n>> // Wallet Metadata\n>> wallet: {\n>> name: 'Bitcoin Core'\n>> },\n>> \n>> // Request access to the wallet for the current host\n>> async enable: (),\n>> \n>> // Request addresses and signatures from wallet\n>> async request ({ method, params })\n>> }\n>> ```\n>> \n>> In the web context the interface could be exposed at the top level of a webpage, for example under `window.bitcoin`. However this spec does not intend to define any standards for how and where the interfaces should be exposed.\n>> \n>> ## Motivation\n>> \n>> Due to the seldom available APIs exposed by wallets, applications (web or otherwise) are limited in how they are able to interact. Generally only simple sends have been available. A more robust API that introduces other requests will promote richer Bitcoin applications.\n>> \n>> Additionally, wallet APIs have frequently included inconsistencies in their interfaces and behaviour. This has required applications to build and maintain a separate client for each wallet, increasing the risk of bugs and unintended behaviour as well as being a limiting factor for the adoption of usable bitcoin applications.\n>> \n>> With a standardised wallet API:\n>> \n>> - Wallets have a clear API to implement\n>> - Applications have a clear expectation of wallet interface and behaviour\n>> - Applications become agnostic to the wallet specifics, increasing choice for users\n>> \n>> If more wallets implement the specification, applications will be developed more confidently by benefiting from the wallet interoperability. This creates a positive feedback loop.\n>> \n>> ## Specification\n>> \n>> For simplicity, the interface is defined in the context of web applications running in the browser (JS) however, they are simple enough to be easily implemented in other contexts.\n>> \n>> ### General Rules\n>> \n>> - For sensitive functions (e.g. signing), wallet software should always prompt the user for confirmation\n>> \n>> ### Types\n>> \n>> **UserDeniedError**\n>> An error type indicating that the application's request has been denied by the user\n>> Type: Error\n>> \n>> **Hex**\n>> Type: String\n>> Example: `\"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08\"`\n>> \n>> **Address**\n>> Address details\n>> Type: Object\n>> Example:\n>> \n>> ```\n>> {\n>> \"address\": \"bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs\",\n>> \"publicKey\": \"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a\",\n>> \"derivationPath\": \"84'/1'/0'/0/0\"\n>> }\n>> ```\n>> \n>> ### API\n>> \n>> The wallet must implement the following methods.\n>> \n>> **enable**\n>> \n>> The enable call prompts the user for access to the wallet.\n>> \n>> If successful, it resolves to an address (`**Address**` type) of the wallet. Typically the first external address to be used as an identity.\n>> \n>> **`UserDeniedError`** will be thrown if the request is rejected.\n>> \n>> **request**\n>> \n>> The request method must take one parameter in the following format:\n>> \n>> ```\n>> {\n>> \"method\": \"wallet_methodName\",\n>> \"params\": [\"foo\", \"bar\", \"baz\"]\n>> }\n>> ```\n>> \n>> For a list of mandatory methods see Table\n>> \n>> The wallet should reject request calls unless `enable` has been resolved.\n>> \n>> Sensitive requests that involve signing should always prompt the user for confirmation\n>> \n>> On success the request should resolve to the response as defined in the method table.\n>> \n>> **`UserDeniedError`** will be thrown if the request is rejected.\n>> \n>> **Mandatory methods**\n>> \n>> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change = false`]\n>> return: `[ Address ]`\n>> error: UserDeniedError\n>> \n>> method: `wallet_signMessage` params: `[ message, address ]`\n>> return: Signature `Hex`\n>> error: UserDeniedError\n>> \n>> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`\n>> return: `psbtBase64`\n>> error: UserDeniedError\n>> \n>> method: `wallet_getConnectedNetwork` params: `[]`\n>> return: Network object `mainnet` | `testnet` | `regetst`\n>> error: UserDeniedError\n>> \n>> ## Rationale\n>> \n>> The purpose of the API is to expose a set of commonly used wallet operations. In addition, it should be flexible enough to serve for other requests such as node RPC calls.\n>> \n>> **Why is there a singular request call instead of named methods?**\n>> The transport layer for the requests cannot be assumed, therefore it is much more flexible to instead define an abstract format.\n>> \n>> **Why are the mandatory methods so primitive? Where is getBalance, getUtxos, ... ?**\n>> A wallet need not worry about providing every possible scenario for usage. The primitives of keys and signing can expose enough to applications to do the rest. Applications should have flexibility in how they implement these functions. It is the role of a library rather than the wallet.\n>> \n>> ## Security Implications\n>> \n>> Great care should be taken when exposing wallet functionality externally as the security and privacy of the user is at risk.\n>> \n>> ### Signing\n>> \n>> Operations that trigger signing using private keys should be guarded behind confirmation screens where the user is fully aware of the nature of the transaction. In the example of a PSBT signature request, the outputs, the inputs and which key is being used should be clearly marked.\n>> \n>> ### Privacy\n>> \n>> Some api methods expose metadata about the user, such as public keys. Depending on how privacy focused the wallet intends to be, the wallet could protect these behind a confirmation. Commonly the wallet just needs to give the origin access to all of its public keys, however it could also allow the option to expose only selected derivation paths.\n>> \n>> -monokh\n>> \n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201225/26428a28/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BIP Proposal: Wallet Interface",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "monokh",
                "Aymeric Vitte",
                "Erik Aronesty",
                "Omar Shibli",
                "Luke Dashjr",
                "Shane Jonas"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 59857
        }
    },
    {
        "title": "[bitcoin-dev] Softchains: Sidechains as a Soft Fork via Proof-of-Work Fraud Proofs",
        "thread_messages": [
            {
                "author": "Ruben Somsen",
                "date": "2020-12-31T22:00:17",
                "message_text_only": "Hi everyone,\n\nThis post describes a fully decentralized two-way peg sidechain design.\nActivating new sidechains requires a soft fork, hence the name softchains.\nThe key aspect is that all softchains are validated by everyone via\nProof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus\nmechanism that only requires the validation of disputed blocks. This does\nincrease the validation burden of mainchain full nodes, but only by a\nminimal amount (~100MB per chain per year). It's similar to drivechains[0],\nbut without the major downside of having to rely on miners, since all\nBitcoin full node users can efficiently validate each sidechain.\n\n\nProof-of-Work Fraud Proofs\n\nLast year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].\nThe idea is that we can use the existence of a fork in Bitcoin's PoW as\nevidence that a block might be invalid (i.e. a proof of potential fraud).\nWhenever this occurs, we download the block in question to verify whether\nit was valid (and available), and reject it if it was not. We forego the\nneed for maintaining a UTXO set with UTXO set commitments (such as\nutreexo[3]), by assuming that the commitment inside the last block to exist\nin both forks is valid. As a result, we only need to download as many\nblocks (and their corresponding UTXO set proofs) as there are orphans,\nwhich lowers the validation costs considerably compared to running a full\nnode.\n\nIn the past 4 months, Forkmonitor has registered 11 stale and invalid\nblocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin\nconsensus would have to download and verify a little over 100MB per year in\norder to have consensus guarantees that come close to that of a full node:\n- All PoW headers (~4MB per year)\n- 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)\n- UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)\n\nThe reason consensus is considered slow, is because we need to allow time\nfor a honest PoW minority to fork away from an invalid chain. If we assume\nonly 1% of all miners are honest, this means consensus slows down by 100x.\nIf you are normally satisfied waiting for 6 confirmations, you now need to\nwait 600 confirmations. The longer you wait, the less honest miners you\nneed.\n\n\nSoftchains\n\nIn order to have two-way pegged sidechains, you need a succinct method for\nproving to the mainchain that a peg-out is valid. PoW FP provides exactly\nthat -- a low-bandwidth way of determining if a chain, and thus a peg-out,\nis valid. The slowness of PoW FP consensus is not an issue, as peg-outs can\nbe made arbitrarily slow (e.g. one year).\n\nThe safest design would be a set of softchains that shares its consensus\ncode with Bitcoin Core, with the addition of UTXO set commitments, and\ndisabling non-taproot address types to minimize certain resource usage\nissues[5]. All users validate the mainchain as usual with their full node,\nand all softchains are validated with PoW FP consensus. If a user is\ninterested in directly using a specific softchain, they should run it as a\nfull node in order to get fast consensus.\n\nPeg-ins occur by freezing coins on the mainchain and assigning them to a\nsoftchain. Peg-outs occur by creating a mainchain transaction that points\nto a peg-out transaction on a softchain and waiting for a sufficient number\nof mainchain confirmations. If the peg-out transaction remains part of the\nsoftchain according to PoW FP consensus, the coins become spendable.\n\nThe peg-in/peg-out mechanism itself would require a soft fork (the exact\ndesign is an open question), and subsequently every softchain that gets\nactivated will also require a soft fork.\n\n\nPotential dangers\n\nSoftchain consensus still requires a form of validation from mainchain\nusers, which means that consensus bugs can have an adverse effect. In\nparticular, if a softchain suffers from a non-deterministic consensus bug,\nit may be the case that a majority accepts a peg-in, while a minority\nrejects it. This specific scenario could cause a chain split in mainchain\nconsensus. This is why it would be safest to base softchain designs on\nBitcoin Core.\n\nSimilarly, it can theoretically be possible that a softchain gets a major\nreorg, invalidating a peg-out right as it would have become accepted on the\nmainchain, thus splitting consensus. The slow peg-out process makes this\nincreasingly unlikely, but not impossible. One thing that might help (or\nperhaps only make it worse) is introducing a consensus rule that disallows\nreorgs that are bigger than half the peg-out time (e.g. half a year, if the\npeg-out is one year). This kind of rule does not actually solve this\nconsensus problem, but instead pushes the problem forward so it plays out\nfirst on the softchain, giving time to take action before the problem\naffects the mainchain.\n\nIt is also important that each softchain produces a non-trivial amount of\nPoW, because if the difficulty is too low, the cost of creating forks and\nincreasing the resource usage of PoW FP consensus goes down. It may\ntherefore make sense to have a minimum accepted difficulty for softchain\nblocks (slowing down the chain when fees are not sufficient). Merged Mining\ncould also help here, since that would allow the softchains to potentially\nreceive the same hashrate as Bitcoin (assuming all miners participate), but\nof course this would also put an additional validation burden on miners.\n\n\nIn closing\n\nIt may turn out that the consensus risks outlined above make this\nprohibitively risky, but at the very least it seems worth exploring the\npossibilities. At a minimum it would provide more opt-in block space, and\nit could potentially open the door to chains with entirely different\nconsensus rules.\n\nThank you for taking the time to read and comprehend my work. I will\nhappily answer any questions and I look forward to any feedback on issues\nthat I might have overlooked, and ideas on mitigating problems to ensure\nmaximum safety.\n\nHopefully this will bring decentralized two-way peg sidechains one step\ncloser to becoming a reality.\n\nHappy new year, everyone.\n\n\n-- Ruben Somsen\n\n\n\nThis post is mirrored and kept up-to-date here:\nhttps://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1\n\n\n[0] Drivechains\nhttps://www.drivechain.info/\n\n[1] PoW FP\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html\n\n[2] PoW FP without a soft fork\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html\n\n[3]: utreexo\nhttps://eprint.iacr.org/2019/611.pdf\n\n[4]: Forkmonitor\nhttps://forkmonitor.info/notifications\n\n[5]: Harding on worst-case utreexo\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201231/c6319a5b/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2020-12-31T23:26:24",
                "message_text_only": "Good morning Ruben, and list,\n\nFirst and foremost --- what is the point of sidechains, in the first place?\n\nIf sidechains are for experimental new features, then softforking in a new sidechain with novel untested new features would be additionally risky --- as you note, a bug in the sidechain consensus may cause non-deterministic consensus in the sidechain which would propagate into mainchain.\nFederated sidechains, which already are enabled on current Bitcoin, are safer here, as mainchain will only care about the k-of-n signature that the federation agrees on, and if the federation is unable to come to consensus due to a sidechain consensus bug, \"fails safe\" in that it effectively disables the peg-out back to mainchain and restricts the consensus problem to the sidechain.\n\nIf sidechains are for scaling, then I would like to remind anyone reading this that ***blockchains do not scale***, and adding more blockchains for the purpose of scaling is *questionable*.\n\"I have a scaling problem.\nI know, I will add a sidechain!\nNow I have two scaling problems.\"\n\nUltimately, proof-of-work is about energy expenditure, and you would be splitting the global energy budget for blockchain security among multiple blockchains, thus making each blockchain easier to 51%.\n\nRegards,\nZmnSCPxj\n\n> Hi everyone,\n>\n> This post describes a fully decentralized two-way peg sidechain design. Activating new sidechains requires a soft fork, hence the name softchains. The key aspect is that all softchains are validated by everyone via Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus mechanism that only requires the validation of disputed blocks. This does increase the validation burden of mainchain full nodes, but only by a minimal amount (~100MB per chain per year). It's similar to drivechains[0], but without the major downside of having to rely on miners, since all Bitcoin full node users can efficiently validate each sidechain.\n>\n> Proof-of-Work Fraud Proofs\n>\n> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2]. The idea is that we can use the existence of a fork in Bitcoin's PoW as evidence that a block might be invalid (i.e. a proof of potential fraud). Whenever this occurs, we download the block in question to verify whether it was valid (and available), and reject it if it was not. We forego the need for maintaining a UTXO set with UTXO set commitments (such as utreexo[3]), by assuming that the commitment inside the last block to exist in both forks is valid. As a result, we only need to download as many blocks (and their corresponding UTXO set proofs) as there are orphans, which lowers the validation costs considerably compared to running a full node.\n>\n> In the past 4 months, Forkmonitor has registered 11 stale and invalid blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin consensus would have to download and verify a little over 100MB per year in order to have consensus guarantees that come close to that of a full node:\n> - All PoW headers (~4MB per year)\n> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)\n> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)\n>\n> The reason consensus is considered slow, is because we need to allow time for a honest PoW minority to fork away from an invalid chain. If we assume only 1% of all miners are honest, this means consensus slows down by 100x. If you are normally satisfied waiting for 6 confirmations, you now need to wait 600 confirmations. The longer you wait, the less honest miners you need.\n>\n> Softchains\n>\n> In order to have two-way pegged sidechains, you need a succinct method for proving to the mainchain that a peg-out is valid. PoW FP provides exactly that -- a low-bandwidth way of determining if a chain, and thus a peg-out, is valid. The slowness of PoW FP consensus is not an issue, as peg-outs can be made arbitrarily slow (e.g. one year).\n>\n> The safest design would be a set of softchains that shares its consensus code with Bitcoin Core, with the addition of UTXO set commitments, and disabling non-taproot address types to minimize certain resource usage issues[5]. All users validate the mainchain as usual with their full node, and all softchains are validated with PoW FP consensus. If a user is interested in directly using a specific softchain, they should run it as a full node in order to get fast consensus.\n>\n> Peg-ins occur by freezing coins on the mainchain and assigning them to a softchain. Peg-outs occur by creating a mainchain transaction that points to a peg-out transaction on a softchain and waiting for a sufficient number of mainchain confirmations. If the peg-out transaction remains part of the softchain according to PoW FP consensus, the coins become spendable.\n>\n> The peg-in/peg-out mechanism itself would require a soft fork (the exact design is an open question), and subsequently every softchain that gets activated will also require a soft fork.\n>\n> Potential dangers\n>\n> Softchain consensus still requires a form of validation from mainchain users, which means that consensus bugs can have an adverse effect. In particular, if a softchain suffers from a non-deterministic consensus bug, it may be the case that a majority accepts a peg-in, while a minority rejects it. This specific scenario could cause a chain split in mainchain consensus. This is why it would be safest to base softchain designs on Bitcoin Core.\n>\n> Similarly, it can theoretically be possible that a softchain gets a major reorg, invalidating a peg-out right as it would have become accepted on the mainchain, thus splitting consensus. The slow peg-out process makes this increasingly unlikely, but not impossible. One thing that might help (or perhaps only make it worse) is introducing a consensus rule that disallows reorgs that are bigger than half the peg-out time (e.g. half a year, if the peg-out is one year). This kind of rule does not actually solve this consensus problem, but instead pushes the problem forward so it plays out first on the softchain, giving time to take action before the problem affects the mainchain.\n>\n> It is also important that each softchain produces a non-trivial amount of PoW, because if the difficulty is too low, the cost of creating forks and increasing the resource usage of PoW FP consensus goes down. It may therefore make sense to have a minimum accepted difficulty for softchain blocks (slowing down the chain when fees are not sufficient). Merged Mining could also help here, since that would allow the softchains to potentially receive the same hashrate as Bitcoin (assuming all miners participate), but of course this would also put an additional validation burden on miners.\n>\n> In closing\n>\n> It may turn out that the consensus risks outlined above make this prohibitively risky, but at the very least it seems worth exploring the possibilities. At a minimum it would provide more opt-in block space, and it could potentially open the door to chains with entirely different consensus rules.\n>\n> Thank you for taking the time to read and comprehend my work. I will happily answer any questions and I look forward to any feedback on issues that I might have overlooked, and ideas on mitigating problems to ensure maximum safety.\n>\n> Hopefully this will bring decentralized two-way peg sidechains one step closer to becoming a reality.\n>\n> Happy new year, everyone.\n>\n> -- Ruben Somsen\n>\n> This post is mirrored and kept up-to-date here:\n> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1\n>\n> [0] Drivechains\n> https://www.drivechain.info/\n>\n> [1] PoW FP\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html\n>\n> [2] PoW FP without a soft fork\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html\n>\n> [3]: utreexo\n> https://eprint.iacr.org/2019/611.pdf\n>\n> [4]: Forkmonitor\n> https://forkmonitor.info/notifications\n>\n> [5]: Harding on worst-case utreexo\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html"
            },
            {
                "author": "Ruben Somsen",
                "date": "2020-12-31T23:39:10",
                "message_text_only": "Happy new morning ZmnSCPxj,\n\nThanks for taking a look :)\n\n>If sidechains are for experimental new features, then softforking in a new\nsidechain with novel untested new features would be additionally risky\n\nThere is definitely a risk, but it's one that can be minimized. For\ninstance, a softchain with Confidential Transactions could be introduced,\nwhich allows for appealing privacy features without introducing a\ncompletely new code base.\n\n>If sidechains are for scaling, then I would like to remind anyone reading\nthis that ***blockchains do not scale***\n\nI agree, you will still run into limitations, but you do get some scaling\ngains from not having to verify each chain, but only the subset that\ninterests you.\n\n>you would be splitting the global energy budget for blockchain security\namong multiple blockchains\n\nNot necessarily if you incorporate Merged Mining, but of course that comes\nwith the tradeoff of requiring miners to do more validation.\n\nCheers,\nRuben\n\nOn Fri, Jan 1, 2021 at 12:26 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Ruben, and list,\n>\n> First and foremost --- what is the point of sidechains, in the first place?\n>\n> If sidechains are for experimental new features, then softforking in a new\n> sidechain with novel untested new features would be additionally risky ---\n> as you note, a bug in the sidechain consensus may cause non-deterministic\n> consensus in the sidechain which would propagate into mainchain.\n> Federated sidechains, which already are enabled on current Bitcoin, are\n> safer here, as mainchain will only care about the k-of-n signature that the\n> federation agrees on, and if the federation is unable to come to consensus\n> due to a sidechain consensus bug, \"fails safe\" in that it effectively\n> disables the peg-out back to mainchain and restricts the consensus problem\n> to the sidechain.\n>\n> If sidechains are for scaling, then I would like to remind anyone reading\n> this that ***blockchains do not scale***, and adding more blockchains for\n> the purpose of scaling is *questionable*.\n> \"I have a scaling problem.\n> I know, I will add a sidechain!\n> Now I have two scaling problems.\"\n>\n> Ultimately, proof-of-work is about energy expenditure, and you would be\n> splitting the global energy budget for blockchain security among multiple\n> blockchains, thus making each blockchain easier to 51%.\n>\n> Regards,\n> ZmnSCPxj\n>\n> > Hi everyone,\n> >\n> > This post describes a fully decentralized two-way peg sidechain design.\n> Activating new sidechains requires a soft fork, hence the name softchains.\n> The key aspect is that all softchains are validated by everyone via\n> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus\n> mechanism that only requires the validation of disputed blocks. This does\n> increase the validation burden of mainchain full nodes, but only by a\n> minimal amount (~100MB per chain per year). It's similar to drivechains[0],\n> but without the major downside of having to rely on miners, since all\n> Bitcoin full node users can efficiently validate each sidechain.\n> >\n> > Proof-of-Work Fraud Proofs\n> >\n> > Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].\n> The idea is that we can use the existence of a fork in Bitcoin's PoW as\n> evidence that a block might be invalid (i.e. a proof of potential fraud).\n> Whenever this occurs, we download the block in question to verify whether\n> it was valid (and available), and reject it if it was not. We forego the\n> need for maintaining a UTXO set with UTXO set commitments (such as\n> utreexo[3]), by assuming that the commitment inside the last block to exist\n> in both forks is valid. As a result, we only need to download as many\n> blocks (and their corresponding UTXO set proofs) as there are orphans,\n> which lowers the validation costs considerably compared to running a full\n> node.\n> >\n> > In the past 4 months, Forkmonitor has registered 11 stale and invalid\n> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin\n> consensus would have to download and verify a little over 100MB per year in\n> order to have consensus guarantees that come close to that of a full node:\n> > - All PoW headers (~4MB per year)\n> > - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)\n> > - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)\n> >\n> > The reason consensus is considered slow, is because we need to allow\n> time for a honest PoW minority to fork away from an invalid chain. If we\n> assume only 1% of all miners are honest, this means consensus slows down by\n> 100x. If you are normally satisfied waiting for 6 confirmations, you now\n> need to wait 600 confirmations. The longer you wait, the less honest miners\n> you need.\n> >\n> > Softchains\n> >\n> > In order to have two-way pegged sidechains, you need a succinct method\n> for proving to the mainchain that a peg-out is valid. PoW FP provides\n> exactly that -- a low-bandwidth way of determining if a chain, and thus a\n> peg-out, is valid. The slowness of PoW FP consensus is not an issue, as\n> peg-outs can be made arbitrarily slow (e.g. one year).\n> >\n> > The safest design would be a set of softchains that shares its consensus\n> code with Bitcoin Core, with the addition of UTXO set commitments, and\n> disabling non-taproot address types to minimize certain resource usage\n> issues[5]. All users validate the mainchain as usual with their full node,\n> and all softchains are validated with PoW FP consensus. If a user is\n> interested in directly using a specific softchain, they should run it as a\n> full node in order to get fast consensus.\n> >\n> > Peg-ins occur by freezing coins on the mainchain and assigning them to a\n> softchain. Peg-outs occur by creating a mainchain transaction that points\n> to a peg-out transaction on a softchain and waiting for a sufficient number\n> of mainchain confirmations. If the peg-out transaction remains part of the\n> softchain according to PoW FP consensus, the coins become spendable.\n> >\n> > The peg-in/peg-out mechanism itself would require a soft fork (the exact\n> design is an open question), and subsequently every softchain that gets\n> activated will also require a soft fork.\n> >\n> > Potential dangers\n> >\n> > Softchain consensus still requires a form of validation from mainchain\n> users, which means that consensus bugs can have an adverse effect. In\n> particular, if a softchain suffers from a non-deterministic consensus bug,\n> it may be the case that a majority accepts a peg-in, while a minority\n> rejects it. This specific scenario could cause a chain split in mainchain\n> consensus. This is why it would be safest to base softchain designs on\n> Bitcoin Core.\n> >\n> > Similarly, it can theoretically be possible that a softchain gets a\n> major reorg, invalidating a peg-out right as it would have become accepted\n> on the mainchain, thus splitting consensus. The slow peg-out process makes\n> this increasingly unlikely, but not impossible. One thing that might help\n> (or perhaps only make it worse) is introducing a consensus rule that\n> disallows reorgs that are bigger than half the peg-out time (e.g. half a\n> year, if the peg-out is one year). This kind of rule does not actually\n> solve this consensus problem, but instead pushes the problem forward so it\n> plays out first on the softchain, giving time to take action before the\n> problem affects the mainchain.\n> >\n> > It is also important that each softchain produces a non-trivial amount\n> of PoW, because if the difficulty is too low, the cost of creating forks\n> and increasing the resource usage of PoW FP consensus goes down. It may\n> therefore make sense to have a minimum accepted difficulty for softchain\n> blocks (slowing down the chain when fees are not sufficient). Merged Mining\n> could also help here, since that would allow the softchains to potentially\n> receive the same hashrate as Bitcoin (assuming all miners participate), but\n> of course this would also put an additional validation burden on miners.\n> >\n> > In closing\n> >\n> > It may turn out that the consensus risks outlined above make this\n> prohibitively risky, but at the very least it seems worth exploring the\n> possibilities. At a minimum it would provide more opt-in block space, and\n> it could potentially open the door to chains with entirely different\n> consensus rules.\n> >\n> > Thank you for taking the time to read and comprehend my work. I will\n> happily answer any questions and I look forward to any feedback on issues\n> that I might have overlooked, and ideas on mitigating problems to ensure\n> maximum safety.\n> >\n> > Hopefully this will bring decentralized two-way peg sidechains one step\n> closer to becoming a reality.\n> >\n> > Happy new year, everyone.\n> >\n> > -- Ruben Somsen\n> >\n> > This post is mirrored and kept up-to-date here:\n> > https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1\n> >\n> > [0] Drivechains\n> > https://www.drivechain.info/\n> >\n> > [1] PoW FP\n> >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html\n> >\n> > [2] PoW FP without a soft fork\n> >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html\n> >\n> > [3]: utreexo\n> > https://eprint.iacr.org/2019/611.pdf\n> >\n> > [4]: Forkmonitor\n> > https://forkmonitor.info/notifications\n> >\n> > [5]: Harding on worst-case utreexo\n> >\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210101/6aa5944d/attachment-0001.html>"
            },
            {
                "author": "Sergio Demian Lerner",
                "date": "2020-12-31T23:37:58",
                "message_text_only": "Hi Roben,\n It's an interesting proposal, but I have two issues with it, one technical\nand one philosophical.\n\nOn the technical side, I don't understand how your proposal prevents miners\nproposing a peg-out for an invalid sidechain fork which is not made\navailable to the nodes (there are missing blocks). It seems that the system\nwould need to allow users to challenge miners to make available full\nsidechain blocks that are missing, which really complicates the protocol.\n\nOn the philosophical side, as you mentioned, it is very limited in the\ntypes of sidechains it can verify. I won't be able to verify RSK\n(merge-mined with Bitcoin, but with different block format and different\nfunctionality). It cannot verify a zCash-like sidechain for the same\nreasons. Therefore it is strictly a payment scalability solution.\nDrivechains, on the other hand, enable many new use cases apart from\nscaling, which have a much lower level of complexity (if implemented\ncorrectly).\n\nSince the inception of RSK sidechain, I suggested in its white-paper that\nsidechains should be designed to support an hybrid peg-out system, based on\nboth a large multisig AND a drivechain, where both groups need to agree for\nthe peg-out to occur.  It's a censorship/security trade-off that most users\nwould be willing to accept until a trusted-setup-free SNARK-like based\nsolution is finally available.\nUntil we have a sidechain-selectable SNARK-like succinct verification of\nany block state transition function, having a single succint proof to cover\nthe whole sidechain validity, as in Coda (now renamed Mina), drivechains\nare the low-hanging-fruit.\n\nregards\n\nOn Thu, Dec 31, 2020 at 7:01 PM Ruben Somsen via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi everyone,\n>\n> This post describes a fully decentralized two-way peg sidechain design.\n> Activating new sidechains requires a soft fork, hence the name softchains.\n> The key aspect is that all softchains are validated by everyone via\n> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus\n> mechanism that only requires the validation of disputed blocks. This does\n> increase the validation burden of mainchain full nodes, but only by a\n> minimal amount (~100MB per chain per year). It's similar to drivechains[0],\n> but without the major downside of having to rely on miners, since all\n> Bitcoin full node users can efficiently validate each sidechain.\n>\n>\n> Proof-of-Work Fraud Proofs\n>\n> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].\n> The idea is that we can use the existence of a fork in Bitcoin's PoW as\n> evidence that a block might be invalid (i.e. a proof of potential fraud).\n> Whenever this occurs, we download the block in question to verify whether\n> it was valid (and available), and reject it if it was not. We forego the\n> need for maintaining a UTXO set with UTXO set commitments (such as\n> utreexo[3]), by assuming that the commitment inside the last block to exist\n> in both forks is valid. As a result, we only need to download as many\n> blocks (and their corresponding UTXO set proofs) as there are orphans,\n> which lowers the validation costs considerably compared to running a full\n> node.\n>\n> In the past 4 months, Forkmonitor has registered 11 stale and invalid\n> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin\n> consensus would have to download and verify a little over 100MB per year in\n> order to have consensus guarantees that come close to that of a full node:\n> - All PoW headers (~4MB per year)\n> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)\n> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)\n>\n> The reason consensus is considered slow, is because we need to allow time\n> for a honest PoW minority to fork away from an invalid chain. If we assume\n> only 1% of all miners are honest, this means consensus slows down by 100x.\n> If you are normally satisfied waiting for 6 confirmations, you now need to\n> wait 600 confirmations. The longer you wait, the less honest miners you\n> need.\n>\n>\n> Softchains\n>\n> In order to have two-way pegged sidechains, you need a succinct method for\n> proving to the mainchain that a peg-out is valid. PoW FP provides exactly\n> that -- a low-bandwidth way of determining if a chain, and thus a peg-out,\n> is valid. The slowness of PoW FP consensus is not an issue, as peg-outs can\n> be made arbitrarily slow (e.g. one year).\n>\n> The safest design would be a set of softchains that shares its consensus\n> code with Bitcoin Core, with the addition of UTXO set commitments, and\n> disabling non-taproot address types to minimize certain resource usage\n> issues[5]. All users validate the mainchain as usual with their full node,\n> and all softchains are validated with PoW FP consensus. If a user is\n> interested in directly using a specific softchain, they should run it as a\n> full node in order to get fast consensus.\n>\n> Peg-ins occur by freezing coins on the mainchain and assigning them to a\n> softchain. Peg-outs occur by creating a mainchain transaction that points\n> to a peg-out transaction on a softchain and waiting for a sufficient number\n> of mainchain confirmations. If the peg-out transaction remains part of the\n> softchain according to PoW FP consensus, the coins become spendable.\n>\n> The peg-in/peg-out mechanism itself would require a soft fork (the exact\n> design is an open question), and subsequently every softchain that gets\n> activated will also require a soft fork.\n>\n>\n> Potential dangers\n>\n> Softchain consensus still requires a form of validation from mainchain\n> users, which means that consensus bugs can have an adverse effect. In\n> particular, if a softchain suffers from a non-deterministic consensus bug,\n> it may be the case that a majority accepts a peg-in, while a minority\n> rejects it. This specific scenario could cause a chain split in mainchain\n> consensus. This is why it would be safest to base softchain designs on\n> Bitcoin Core.\n>\n> Similarly, it can theoretically be possible that a softchain gets a major\n> reorg, invalidating a peg-out right as it would have become accepted on the\n> mainchain, thus splitting consensus. The slow peg-out process makes this\n> increasingly unlikely, but not impossible. One thing that might help (or\n> perhaps only make it worse) is introducing a consensus rule that disallows\n> reorgs that are bigger than half the peg-out time (e.g. half a year, if the\n> peg-out is one year). This kind of rule does not actually solve this\n> consensus problem, but instead pushes the problem forward so it plays out\n> first on the softchain, giving time to take action before the problem\n> affects the mainchain.\n>\n> It is also important that each softchain produces a non-trivial amount of\n> PoW, because if the difficulty is too low, the cost of creating forks and\n> increasing the resource usage of PoW FP consensus goes down. It may\n> therefore make sense to have a minimum accepted difficulty for softchain\n> blocks (slowing down the chain when fees are not sufficient). Merged Mining\n> could also help here, since that would allow the softchains to potentially\n> receive the same hashrate as Bitcoin (assuming all miners participate), but\n> of course this would also put an additional validation burden on miners.\n>\n>\n> In closing\n>\n> It may turn out that the consensus risks outlined above make this\n> prohibitively risky, but at the very least it seems worth exploring the\n> possibilities. At a minimum it would provide more opt-in block space, and\n> it could potentially open the door to chains with entirely different\n> consensus rules.\n>\n> Thank you for taking the time to read and comprehend my work. I will\n> happily answer any questions and I look forward to any feedback on issues\n> that I might have overlooked, and ideas on mitigating problems to ensure\n> maximum safety.\n>\n> Hopefully this will bring decentralized two-way peg sidechains one step\n> closer to becoming a reality.\n>\n> Happy new year, everyone.\n>\n>\n> -- Ruben Somsen\n>\n>\n>\n> This post is mirrored and kept up-to-date here:\n> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1\n>\n>\n> [0] Drivechains\n> https://www.drivechain.info/\n>\n> [1] PoW FP\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html\n>\n> [2] PoW FP without a soft fork\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html\n>\n> [3]: utreexo\n> https://eprint.iacr.org/2019/611.pdf\n>\n> [4]: Forkmonitor\n> https://forkmonitor.info/notifications\n>\n> [5]: Harding on worst-case utreexo\n>\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201231/3ee7d3df/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Softchains: Sidechains as a Soft Fork via Proof-of-Work Fraud Proofs",
            "categories": [
                "bitcoin-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Sergio Demian Lerner",
                "Ruben Somsen"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 33484
        }
    }
]