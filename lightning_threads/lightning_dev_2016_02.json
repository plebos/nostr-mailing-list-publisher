[
    {
        "title": "[Lightning-dev] Laundry list of inter-peer wire protocol changes",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-02-01T01:02:56",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> There are a couple of subjects where new concepts are being worked out,\n> or where alternative concepts exist; these things are likely to continue\n> to evolve after you finish the first version of the protocol.\n>\n> It would be great if concept changes in one subject can be made more or\n> less independently from concept changes in another subject. In order to\n> make this possible, I suggest to de-couple certain things, and let each\n> subject have its own sub-protocol, with version number / protocol\n> identifier.\n>\n> The way I see it, the following subjects have ongoing design /\n> alternative concepts, more or less independently from each other:\n\nIndeed!\n\n> * Micro-transaction channel design: e.g. several variations on the\n> Lightning channel design, and Amiko Pay's escrow-based HTLC emulation\n> and IOU semi-channel.\n\nYes, for lightning I would further split this into wire crypto, wire\nprotocol, anchoring and fee design, and commit transaction design.\n\n> * Commit conditions: traditional definition consists of a hash value and\n> a time-out. For practical purposes, Amiko Pay also adds a \"start time\",\n> and there is an alternative concept of using keypairs instead of hash\n> values to de-correlate a transaction in different links.\n\nGood point.  I think of this as a sub-part of transaction design, but\nit's logically a separable issue.\n\n> * Routing: how to exchange routing info. For source routing: informing\n> each other about Lightning nodes that exist. For source and non-source\n> routing: informing each other about availability of routes, expected\n> capacity and fees. The type of routing info depends on the routing\n> algorithm in use by a node.\n\nThere are several topology issues:\n\n1) Source-routing format (aka. onion design).\n2) Route and fee broadcast and finding (eg. How do I find a route to X\n   where all nodes support keypair commitments?).\n3) Initial node finding (how do I find a node to create channels to?)\n\n> In Amiko Pay, the micro-transaction channel design is already separated\n> from the rest of the protocol; commit conditions are not (yet), and\n> exchange of routing info doesn't really exist yet, since it's still\n> doing \"dumb\" non-source routing (trying every possible route).\n\nIn c-lightning, routing is separate because it doesn't exist yet :)\n\nCheers,\nRusty."
            },
            {
                "author": "Fabrice Drouin",
                "date": "2016-02-01T16:18:21",
                "message_text_only": "On 27 January 2016 at 04:07, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n> Hi all!\n>\n>         As more code emerges, I'd like to try to nail down a \"1.0\"\n> version of the inter-node protocol as much as possible.  Since I'm most\n> familiar with my own code (c-lightning[1]), I'll use that as a basis and\n> discuss differences (esp. vs lnd[2]).\n>\n> For this email I'll simply list the changes or proposals I'm aware of,\n> then we can dissect and comment on each one: defer, accept or close.\n>\n> Direct wire format stuff\n> ------------------------\n>\n> - Protobufs vs open-coded structures\n>   - lnd open-coded their own protocol; I haven't finished reading their\n>     code though.\n>   - protobufs are easy to extend with new fields; with an open-coded\n>     proto we simply need a rule that too-long packets are valid.\n>   - protobufs are annoying for fixed-length blobs which we use a lot\n>     (keys, signatures, hashes).\n>   - The protocol is currently simple with very few variable-length fields.\n\nHello,\n\nWe (Pierre and I, the guys who work on the scala thingy :-) would\nrather use a \"standard\" binary format and protobuf seems to be a very\ngood choice. Since incoming messages are encrypted, text based formats\n(JSON, ...) would not help that much for debugging and are not imho a\ngood fit for binary protocols.\n\n> - Length prefix for initial key exchange\n>   - Both lnd and c-lightning begin by exchanging a 33-byte EC key for DH.\n>   - We should prefix with a length word, so we can extend this later\n>     (eg. for new crypto)\nAgreed.\n\n> - HTLC pipelining\n>   - lnd's protocol supports multiple in-flight HTLC negotiations; this\n>     would allow much greater throughput, with some complexity.\n>   - lightning-c uses a simple one-at-a-time scheme, with alternating\n>     priority in case of simultaneous sends.\n\nJust to be sure that we understand this, you mean grouping HTLCs and\nsending them with one message (so just one signature will be\nexchanged). It becomes more complex for clients because they will have\nto buffer and group incoming HTLCs but the protocol and the\ntransitions remain pretty much the same ?\n\n> Misc\n> ----\n> - shachain vs elkrem\n>   - We use this to generate the revocation secrets, to minimize storage\n>     and computation for a huge number of old commitment txs.\n>   - They're actually very similar, but elkrem is much easier to grok.[6]\nI like both, they're easy to implement and elkrem was indeed much\neasier to understand. I don't know precisely why yet but I would\nchoose shachain though.\n\n\nCheers,\nFabrice"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-02T01:11:36",
                "message_text_only": "Fabrice Drouin <fabrice.drouin at acinq.fr> writes:\n> On 27 January 2016 at 04:07, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> Hello,\n>\n> We (Pierre and I, the guys who work on the scala thingy :-) would\n> rather use a \"standard\" binary format and protobuf seems to be a very\n> good choice. Since incoming messages are encrypted, text based formats\n> (JSON, ...) would not help that much for debugging and are not imho a\n> good fit for binary protocols.\n\nWell, I'm thinking of providing a binary which will do the crypto and\nprovide a (generated) JSON interface.  That will keep the JSON people\nhappy, separate out the crypto and wire-protocol issues, and generally\ngive one less thing to worry about.  I can also keep it up to date as we\ndebate formats...\n\n>> - Length prefix for initial key exchange\n>>   - Both lnd and c-lightning begin by exchanging a 33-byte EC key for DH.\n>>   - We should prefix with a length word, so we can extend this later\n>>     (eg. for new crypto)\n> Agreed.\n>\n>> - HTLC pipelining\n>>   - lnd's protocol supports multiple in-flight HTLC negotiations; this\n>>     would allow much greater throughput, with some complexity.\n>>   - lightning-c uses a simple one-at-a-time scheme, with alternating\n>>     priority in case of simultaneous sends.\n>\n> Just to be sure that we understand this, you mean grouping HTLCs and\n> sending them with one message (so just one signature will be\n> exchanged). It becomes more complex for clients because they will have\n> to buffer and group incoming HTLCs but the protocol and the\n> transitions remain pretty much the same ?\n\nI haven't got a description of lnd's protocol, but I've been thinking\nabout it.  We can certainly be more optimal than the 4 trips per change\nwe have now (amortized).\n\nSee the other thread \"Protocol for multiple in-flight updates.\".\n\n>> Misc\n>> ----\n>> - shachain vs elkrem\n>>   - We use this to generate the revocation secrets, to minimize storage\n>>     and computation for a huge number of old commitment txs.\n>>   - They're actually very similar, but elkrem is much easier to grok.[6]\n> I like both, they're easy to implement and elkrem was indeed much\n> easier to understand. I don't know precisely why yet but I would\n> choose shachain though.\n\nI have to write up a better explanation of shachain.  And as AJ points\nout, it should be defined in the other direction to be more like chains\nin the literature, so seed is index 0, first value is index 2^64-1...\n\nCheers,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2016-02-02T17:56:08",
                "message_text_only": "> > * Message confirmation: this is done manually (instead of relying on\n> > TCP), so that a node knows which messages were received / need to be\n> > re-transmitted, even after a crash + restart.\n> \n> I think the protocol itself needs to be robust against retransmissions.\n> There's no way to know if the other side received your acknowledgement\n> before a crash, so you will always need to handle duplication on\n> re-establishment.\n\nYes. Amiko Pay does that: It assigns a number to every message, and the\nreceiving side can confirm \"I've received up to this number\".\nNot-yet-confirmed messages will be retransmitted, and the receiving\nsides will ignore duplicates (except it will send a confirmation again,\nin case the previous confirmation was lost).\n\n> > * There is not only two-way communication between linked peers, but also\n> > between payer and payee. This is necessary for Amiko Pay's\n> > bi-directional routing, but also useful e.g. for transmitting meta-data\n> > that doesn't fit in a QR code. Amiko Pay transmits an arbitrary-contents\n> > \"receipt\" from payee to payer; in the future, this might be digitally\n> > signed by the payee, as a \"proof of transfer of ownership\" of\n> > non-cryptographic goods.\n> \n> I agree.  There's room in the initial onion design for payer -> payee\n> messages, but we don't have a channel for responses.\n> \n> I can't see an easy way to implement the payee --> payer comms reliably:\n> to be reliable it would have to be published on-chain in the commit tx.\n> (Which we could do by constructing HTLCs such that they require a blob\n> signed by the payee, but that's tracable ...).\n> \n> Mats and Laolu wanted to add an arbitrary comms protocol layer, but I\n> think that's something we can defer.\n\nIn Amiko Pay, payer <-> payee communication is done on a direct TCP\nstream between them. Note that this also reduces latency: once\ntransaction locking reaches the payee, the payee knows (s)he's capable\nof claiming the money, and can tell the payer that the payment is\ncompleted. If reduced latency is in the interest of the payee, this is\nlikely to happen.\n\n> > * Reserving before locking: this is an optimization, to reduce the risk\n> > of locking funds in payment channels on a part of the route, and then\n> > having to undo the locking when it turns out that the remaining part of\n> > the route doesn't exist (anymore). Reserving is an informal(*),\n> > temporary locking of funds for use in the transaction, and can be done\n> > and undone very fast, without any channel operations. It is done\n> > together with route searching + establishment.\n> \n> I think that trades one DoS for another, though.  It saves cryptographic\n> constructs, but latency is the real cost, and this increases it.\n> \n> Of course, we'll have to revisit that if the network in practice proves\n> subject to these problems...\n\nFor one category of channel designs, reserving is absolutely essential:\nchannels where bi-directional payments are made possible with a\ndecrementing lock time. There, you want to make sure that failed routing\nattempts don't cause lock time decrements, since that would reduce the\nchannel lifetime more than necessary. I'd have to check whether there is\nstill any use case for this channel design, and whether the reserving\nstep is important for some other reason.\n\nNote that reserving is necessary for bi-directional routing: on the\npayee side of the meeting point, routing happens in the payee -> meeting\npoint direction, but locking has to happen in the meeting point -> payee\ndirection. So, they have to be different steps.\n\nOn latency: what latency do you think is needed for different use cases,\nand what can we reach? Does this extra step really make a difference?\n\nMy estimate is that we'll typically have 10 hops (\"six degrees of\nseparation\" theory), and 100ms to transmit a message(*) over one hop.\n\nWithout reserving, you need to traverse all hops once(**) (the locking\noperation) before payer(***)+payee know that the transaction has\nsucceeded. Actual settlement on the channels happens afterwards, but is\nno longer critical for the latency as seen by payer+payee.\n\nWith reserving, you need to traverse all hops three times(**), in the\nworst case that the meeting point is on one of the end points of the\nroute: once for making the route and reserving funds, once for\nconfirming that the route has been established and once for locking.\n\nSo, instead of one second, a transaction might take three seconds. Is\nthat a game changer? Maybe it is for e.g. public transport access gates,\nwhere passenger throughput is essential. But then, people could reduce\nlatency a lot by having a direct channel with the public transport\noperator.\n\nFor some use cases, e.g. high-frequency trading, people might of course\nmanually optimize their network and physical location to get better\nfigures than this.\n\nCJP\n\n(*) Not counting sending the confirmation back: a node that receives a\nmessage can immediately forward a message on the next hop; message\nconfirmation on the receiving side can occur in parallel.\n\n(**) Not counting failed routing attempts\n\n(***) Assuming the payee tells the payer directly about the payment\nsucces, over a low-latency connection"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-03T00:55:37",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n>> > * Message confirmation: this is done manually (instead of relying on\n>> > TCP), so that a node knows which messages were received / need to be\n>> > re-transmitted, even after a crash + restart.\n>> \n>> I think the protocol itself needs to be robust against retransmissions.\n>> There's no way to know if the other side received your acknowledgement\n>> before a crash, so you will always need to handle duplication on\n>> re-establishment.\n>\n> Yes. Amiko Pay does that: It assigns a number to every message, and the\n> receiving side can confirm \"I've received up to this number\".\n> Not-yet-confirmed messages will be retransmitted, and the receiving\n> sides will ignore duplicates (except it will send a confirmation again,\n> in case the previous confirmation was lost).\n\nYes, I think packet numbers make sense.  I encoded the packet length and\norder in one single value (ie. byte counter at the end of this packet),\nbut it's too weird for too little gain IMHO.\n\n>> > * There is not only two-way communication between linked peers, but also\n>> > between payer and payee. This is necessary for Amiko Pay's\n>> > bi-directional routing, but also useful e.g. for transmitting meta-data\n>> > that doesn't fit in a QR code. Amiko Pay transmits an arbitrary-contents\n>> > \"receipt\" from payee to payer; in the future, this might be digitally\n>> > signed by the payee, as a \"proof of transfer of ownership\" of\n>> > non-cryptographic goods.\n>> \n>> I agree.  There's room in the initial onion design for payer -> payee\n>> messages, but we don't have a channel for responses.\n>> \n>> I can't see an easy way to implement the payee --> payer comms reliably:\n>> to be reliable it would have to be published on-chain in the commit tx.\n>> (Which we could do by constructing HTLCs such that they require a blob\n>> signed by the payee, but that's tracable ...).\n>> \n>> Mats and Laolu wanted to add an arbitrary comms protocol layer, but I\n>> think that's something we can defer.\n>\n> In Amiko Pay, payer <-> payee communication is done on a direct TCP\n> stream between them. Note that this also reduces latency: once\n> transaction locking reaches the payee, the payee knows (s)he's capable\n> of claiming the money, and can tell the payer that the payment is\n> completed. If reduced latency is in the interest of the payee, this is\n> likely to happen.\n\nI think for v1.0 of the protocol we'll be assuming such a channel for\nsimplicity; that somehow the R hash and route is known by the payer.\n\n> On latency: what latency do you think is needed for different use cases,\n> and what can we reach? Does this extra step really make a difference?\n>\n> My estimate is that we'll typically have 10 hops (\"six degrees of\n> separation\" theory), and 100ms to transmit a message(*) over one hop.\n...\n> (*) Not counting sending the confirmation back: a node that receives a\n> message can immediately forward a message on the next hop; message\n> confirmation on the receiving side can occur in parallel.\n\nThat's a good point; you can offer the next hop and abort if the prior\nhop fails to deliver a signature.  Nice, my estimates were double\nyours...\n\n> Without reserving, you need to traverse all hops once(**) (the locking\n> operation) before payer(***)+payee know that the transaction has\n> succeeded. Actual settlement on the channels happens afterwards, but is\n> no longer critical for the latency as seen by payer+payee.\n>\n> With reserving, you need to traverse all hops three times(**), in the\n> worst case that the meeting point is on one of the end points of the\n> route: once for making the route and reserving funds, once for\n> confirming that the route has been established and once for locking.\n>\n> So, instead of one second, a transaction might take three seconds. Is\n> that a game changer? Maybe it is for e.g. public transport access gates,\n> where passenger throughput is essential. But then, people could reduce\n> latency a lot by having a direct channel with the public transport\n> operator.\n\nI worry that higher latency is a centralization pressure, and encourages\npeople to sacrifice privacy.  I don't know where the threshold is,\nthough, so currently I'm more nervous about complexity :)\n\nCheers,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2016-02-11T22:47:52",
                "message_text_only": "Hi,\n\nI've had another look at C-Lightning protocol description[1], in the\nhope to make a sort of match between your message types and the message\ntypes in Amiko Pay. In the best case, there would be a near-perfect\nmatch; in the worst case, the entire sequence would be different\n(unlikely, since we try to accomplish similar things).\n\nThe result was a bit unexpected: there was hardly any match at all, but\nthis was not due to solving things in different ways, but because of\nimplementing nearly opposite subsets of the functionality of Lightning.\n\nIn Amiko Pay, the core protocol is mostly concerned with multiplexing\nmultiple channels of potentially different types, opening/closing\nchannels, doing a little bit of routing and following the payment\nsequences (reserving/route finding, route canceling, fund locking, fund\nreleasing etc.). Channel implementation details, such as what messages\nto exchange in case of opening/closing a channel, or in the different\nsteps of a transaction, depend on the different channel types, and no\nLightning-style channel type has yet been implemented.\n\nOn the other hand, the C-Lightning protocol description basically *only*\ndeals with the channel implementation details (what data is exchanged in\ncase of opening/closing a channel, or in the different steps of a\ntransaction). I don't see much about routing, for instance. The\nC-lightning message structures would be perfect to put inside Amiko\nPay's ChannelMessage messages, and together they would make a more\ncomplete protocol.\n\nTo make a (pretty weak) analogy: maybe you can see C-Lightning's\nprotocol as a fundamental building block of Lightning networks, in the\nsame way as you can see bi-directional byte streams as a fundamental\nbuilding block of computer networks. Then, the 'raw' protocol used by\nC-lightning would be a bit like a serial point-to-point connection, and\nC-lightning inside Amiko Pay would be a bit like a TCP/IP connection.\nThey deliver the same core functionality on application level, but\nTCP/IP, being more layered, provides more versatility. It adds\nmultiplexing of different streams, and alternative communication\nconcepts (e.g. UDP).\n\nFor me, this was a bit of an eye-opener, though I should have expected\nit, from what I know about C-Lightning. C-Lightning's protocol\ndescription will be a nice guide for developing a true Lightning style\nchannel in Amiko Pay. Judging the development time and lines of code in\nC-lightning, I guess the part that is implemented in C-lightning has\nquite a bit of complexity, so I hope to build on Rusty's experience and\nexpertise, to do things a bit faster in Amiko Pay. I'd like to use some\nC-lightning code as well, but I doubt it will be easy to integrate\n(Amiko Pay is quite a restrictive framework for channel implementations,\nand we have a language barrier between C and Python). Maybe we could\nstart with a 'dirty hack'-style of gluing things together, for a proof\nof concept.\n\nCJP\n\n[1]\nhttps://github.com/ElementsProject/lightning/blob/master/lightning.proto"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-14T03:28:15",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> Hi,\n>\n> I've had another look at C-Lightning protocol description[1], in the\n> hope to make a sort of match between your message types and the message\n> types in Amiko Pay. In the best case, there would be a near-perfect\n> match; in the worst case, the entire sequence would be different\n> (unlikely, since we try to accomplish similar things).\n>\n> The result was a bit unexpected: there was hardly any match at all, but\n> this was not due to solving things in different ways, but because of\n> implementing nearly opposite subsets of the functionality of Lightning.\n\nIndeed!  I kind of like that we're approaching from opposite ends, it\nmeans we can steal off each other.\n\n> For me, this was a bit of an eye-opener, though I should have expected\n> it, from what I know about C-Lightning. C-Lightning's protocol\n> description will be a nice guide for developing a true Lightning style\n> channel in Amiko Pay. Judging the development time and lines of code in\n> C-lightning, I guess the part that is implemented in C-lightning has\n> quite a bit of complexity, so I hope to build on Rusty's experience and\n> expertise, to do things a bit faster in Amiko Pay.\n\nYes.  I'm right now reworking it to do the update pipelining, and it's\nremoved some of the complexity.  But it's not complete yet, so some\nmight come back :)\n\nI'm off on paternity leave for a couple of weeks, but I've pushed my\nunworking code to the multi-htlc branch, so you can see the changes in\nthe protocol as per my email to the list.\n\nhttps://github.com/ElementsProject/lightning/tree/multi-htlc\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Laundry list of inter-peer wire protocol changes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Fabrice Drouin",
                "CJP"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 21419
        }
    },
    {
        "title": "[Lightning-dev] Protocol for multiple in-flight updates.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-02-01T10:08:01",
                "message_text_only": "Hi Joseph and ml,\n\n        Wondering if you can describe your HTLC negotiation protocol?\nLaolu said on IRC you're working on it.\n\nI've been trying to adapt my code to do this, and ended up with\nsomething quite different AFAICT from your HTLC ids.\n\nBecause you need to supply the revocation hash to get a signature from\nthe other side, this implies an ordering in commitments.\n\nThe c-lightning protocol exchange looks like:\n\n        Send: [add/fulfill/fail/timeout, with new revocation hash]\n        Receive: [acceptance, with new revocation hash] or [decline if add]\n        Send: [commitment, with signature of new commit tx, and old\n                revocation preimage]\n        Receive: [commitment reply, with signature of new commit tx, and old\n                revocation preimage]\n\nThe obvious way to batch this is to have variants of the first two which\ndon't have a new revocation hash: you could follow your initial proposal\nwith an arbitrary number of additional changes to build up the new\ncommit tx, and the commitment is to all the accepted updates.\n\nHow similar is this to yours?\n\nThanks!\nRusty.\nPS.  I swear I send this before, but I couldn't find it..."
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-02T01:18:17",
                "message_text_only": "OK, I've thought about this some more, and here's my strawman protocol.\n\nImportantly, if we pipeline requests, we need something more\nsophisticated than \"discard if not your turn\" for overlaps.  Including\nthe other side's commitment and retransmitting seems to work.\n\nEach side keeps two sets of \"proposals\"; mine and yours.  There are two\nkinds of proposals, \"add to my htlcs\" and \"remove from your htlcs\".\n\n- As part of finalizing a commit tx, we always tell the other side\n  what the next revocation hash will be.\n  - This simplifies the protocol, as you need the other side's\n    revocation hash to produce a signature.\n- To add an HTLC, send the proposal.\n  - If they decline, fail the HTLC.\n  - If they accept, add to my proposals.\n- To close an HTLC, send fulfill/timeout/fail:\n  - They cannot decline this.\n  - Add to my proposals.\n- If we receive an add proposal:\n  - If we don't want it, send decline.\n  - If it's OK, send ack, add the their proposals.\n- If we receive a fulfill/timeout/fail:\n  - Add to their proposals.\n\n- If we have no outstanding add requests, we can send commit msg\n  - Send update_commit: signature of current state including our proposals.\n  - If we receive commit_accept with signature and their old revocation preimage.\n    - Commit our proposals\n    - Send update_commit_complete with our old revocation preimage.\n  - If we receive an update_commit message (conflict!)\n    - If signature matches current state + their proposals\n      - They didn't get our update_commit.\n      - Commit their proposals to current state, re-send update_commit\n        with that current state + our proposals.\n    - Otherwise signature matches current state + their proposals + our proposals\n      - Commit their proposals and our proposals to current state.\n      - Send update_commit_accept: signature and revocation preimage.\n      - Expect update_commit_complete or update_commit_accept.\n- If we receive an update_commit message (and we've not sent one!)\n  - Commit \"their changes\" to current state.\n  - Send update_commit_accept: signature and revocation preimage.\n  - Expect update_commit_complete.\n\nPackets involved:\n        update_add_htlc: [new htlc details]\n                update_decline_htlc: [reason]\n                update_accept_htlc\n        update_fulfill_htlc: [r value]\n        update_timeout_htlc: [htlc rhash]\n        update_fail_htlc: [htlc rhash]\n\n        update_commit: [sig]\n        update_commit_accept: [sig] [old commit preimage] [next commit hash]\n        update_commit_complete: [old commit preimage] [next commit hash]\n\nCheers,\nRusty.\nPS.  Yes, it's complex.  Better way welcome..."
            },
            {
                "author": "Joseph Poon",
                "date": "2016-02-02T07:28:14",
                "message_text_only": "Hi Rusty,\n\nFor synchronous across-the-wire commit steps, 3 steps is a good idea and\nmore secure than 2 steps for the commit transaction.\n\nHowever, the nice thing about keeping everything asynchronous is it\nsimplifies orchestration and no locking across-the-wire. We have a\npreliminary explanation on the git repo in the README.md file.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-03T00:32:50",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> Hi Rusty,\n>\n> For synchronous across-the-wire commit steps, 3 steps is a good idea and\n> more secure than 2 steps for the commit transaction.\n\nI guess it depends how we count steps.  Each party needs to receive the\nsignature for the N+1 commit tx before handing over the Nth revocation\npreimage, but that's the only irreducible constraint isn't it?\n\nIt's probably simpler to do a three way handshake on every stage, but I\ndidn't see that in your protocol?\n\n> However, the nice thing about keeping everything asynchronous is it\n> simplifies orchestration and no locking across-the-wire. We have a\n> preliminary explanation on the git repo in the README.md file.\n\nYes, but it was a bit dense.  Or I am :)\n\nIf I receive \"add request\" \"add request\" \"signed commit\", how do I know\nwhat that signatures covers?  Both new htlcs?  Are you required to wait\nfor my accept/reject message replies before commiting?  Or does the\ncommit message include a counter?\n\nI guess \"asynchronous\" is a bit nebulous: out-of-order or in-order?  I\ncouldn't see a good reason for out-of-order.  Whereas letting both sides\noffer updates in parallel makes good sense for throughput...\n\nThanks!\nRusty."
            },
            {
                "author": "Joseph Poon",
                "date": "2016-02-03T01:33:30",
                "message_text_only": "On Wed, Feb 03, 2016 at 11:02:50AM +1030, Rusty Russell wrote:\n> I guess it depends how we count steps.  Each party needs to receive the\n> signature for the N+1 commit tx before handing over the Nth revocation\n> preimage, but that's the only irreducible constraint isn't it?\n\nCorrect, that is a necessity for a secure implementation.\n\n> It's probably simpler to do a three way handshake on every stage, but I\n> didn't see that in your protocol?\n\nUnlike a 3-step synchronous commitment, it doesn't wait for the other\nparty to send their sigantures/revocations and can happen\nsimultaneously.\n\nBob's broadcastable Commitment: Alice sends a Signature to Bob. Bob\nsends the Revocation of the previous Commitment to Alice.\n\nAlice's broadcastable Commitment: Bob sends a Signature to Alice. Alice\nsends to Revocation of the previous Commitment to Bob.\n\nIt's that simple. If the HTLC is reflected in both and the previous\ncommitment(s) is/are revoked, then it's complete.\n\n> If I receive \"add request\" \"add request\" \"signed commit\", how do I know\n> what that signatures covers? \n\nThe protocol is still being optimized (deprecating the even/odd\nstructure, etc.), but the structure is both parties have a list of HTLC\nmodifications which they want to update. When the modification is\nacknowledged by the other party, the HTLC modifcation request is staged\ninto the next Commitment signature. The inclusion of modifications are\nenumerated by including both parties' higest HTLC ID (two of them) in\neach Commitment signature message.\n\n> Are you required to wait for my accept/reject message replies before\n> commiting?  Or does the commit message include a counter?\n\nAny which is accepted by the other party is included. Two IDs, one for\neach party, is included. Two are necessary to allow for timing issues\nwith HTLC Add responses in-flight not being fully synced up.\n\n> I guess \"asynchronous\" is a bit nebulous: out-of-order or in-order?  I\n> couldn't see a good reason for out-of-order.  Whereas letting both\n> sides offer updates in parallel makes good sense for throughput...\n\nIn-order. I should have an update in the coming days for lnstate if that\nhelps (various protocol updates, e.g. fixing exchanging of revocation\nhashes, etc.)\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-03T04:35:33",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> Bob's broadcastable Commitment: Alice sends a Signature to Bob. Bob\n> sends the Revocation of the previous Commitment to Alice.\n>\n> Alice's broadcastable Commitment: Bob sends a Signature to Alice. Alice\n> sends to Revocation of the previous Commitment to Bob.\n>\n> It's that simple. If the HTLC is reflected in both and the previous\n> commitment(s) is/are revoked, then it's complete.\n\nAh, I think I finally understand!  I was artificially linking the two\nsides' commit transactions, but there's really no reason to.  As you\nsay, once you've included an HTLC in both sides in any form, it's\nlocked in.\n\n>> If I receive \"add request\" \"add request\" \"signed commit\", how do I know\n>> what that signatures covers? \n>\n> The protocol is still being optimized (deprecating the even/odd\n> structure, etc.), but the structure is both parties have a list of HTLC\n> modifications which they want to update. When the modification is\n> acknowledged by the other party, the HTLC modifcation request is staged\n> into the next Commitment signature. The inclusion of modifications are\n> enumerated by including both parties' higest HTLC ID (two of them) in\n> each Commitment signature message.\n\nRight, so \"this signature covers you up to X me up to Y\".  That resolves\nthe in-flight issue.\n\nBut isn't that more a request ID rather than an HTLC ID?  Since requests\ncan include removing HTLCs as well?  And doesn't that simply degrade to\na counter?\n\n>> Are you required to wait for my accept/reject message replies before\n>> commiting?  Or does the commit message include a counter?\n>\n> Any which is accepted by the other party is included. Two IDs, one for\n> each party, is included. Two are necessary to allow for timing issues\n> with HTLC Add responses in-flight not being fully synced up.\n\nRight.\n\n>> I guess \"asynchronous\" is a bit nebulous: out-of-order or in-order?  I\n>> couldn't see a good reason for out-of-order.  Whereas letting both\n>> sides offer updates in parallel makes good sense for throughput...\n>\n> In-order. I should have an update in the coming days for lnstate if that\n> helps (various protocol updates, e.g. fixing exchanging of revocation\n> hashes, etc.)\n\nThanks, I feel smarter now! :)\n\nCheers,\nRusty."
            },
            {
                "author": "Joseph Poon",
                "date": "2016-02-03T05:01:35",
                "message_text_only": "On Wed, Feb 03, 2016 at 03:05:33PM +1030, Rusty Russell wrote:\n> Right, so \"this signature covers you up to X me up to Y\".  That resolves\n> the in-flight issue.\n> \n> But isn't that more a request ID rather than an HTLC ID?  Since requests\n> can include removing HTLCs as well?  And doesn't that simply degrade to\n> a counter?\n\nYeah, it's more like a request \"staging\" ID. The \"counter\" aspect\nrequires two counters (one for each originator of the request). Two IDs\nsent in the commitment message allow for simultaneous action on\naccept/reject/etc, whereas only one would require a lock on\naccepting/rejecting modifications.\n\nMinor note which has the potential to be overlooked: It's a hard\nrequirement that all messages sent are in order, and if the replyer\nskips the requester's Add Requests when replying, the skipped are\nassumed to be request rejections (or an outright channel closeout) since\nit should never happen -- this is to enforce accept/reject order, as we\nneed to know which modifications are included in the\nsignature/transaction and not have that change after-the-fact.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-04T04:08:35",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> On Wed, Feb 03, 2016 at 03:05:33PM +1030, Rusty Russell wrote:\n>> Right, so \"this signature covers you up to X me up to Y\".  That resolves\n>> the in-flight issue.\n>> \n>> But isn't that more a request ID rather than an HTLC ID?  Since requests\n>> can include removing HTLCs as well?  And doesn't that simply degrade to\n>> a counter?\n>\n> Yeah, it's more like a request \"staging\" ID. The \"counter\" aspect\n> requires two counters (one for each originator of the request). Two IDs\n> sent in the commitment message allow for simultaneous action on\n> accept/reject/etc, whereas only one would require a lock on\n> accepting/rejecting modifications.\n>\n> Minor note which has the potential to be overlooked: It's a hard\n> requirement that all messages sent are in order, and if the replyer\n> skips the requester's Add Requests when replying, the skipped are\n> assumed to be request rejections (or an outright channel closeout) since\n> it should never happen -- this is to enforce accept/reject order, as we\n> need to know which modifications are included in the\n> signature/transaction and not have that change after-the-fact.\n\nI would simply disallow skipping as a protocol violation.\n\nI think this approach also leads neatly to an gentler close protocol:\nsending close would simply imply the initiator would send no more adds,\nand reject all received.  It could take a while to clean out all the\nremaining HTLCs for mutual close (assuming we still don't support close\nwith htlcs), but at least the other side knows what we're doing and\ncan open new channels to replace capacity if it wants to.\n\nI'm going to try to document your protocol in another mail, let's see\nhow close I get this time!\n\nThanks,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-05T00:54:14",
                "message_text_only": "OK, so this is based on my understanding of what Joseph's protocol will\nlook like when done, from here and perusing the lnd source.  See\nproposals if this is all simply revision; it's mainly to document my\nunderstanding.\n\nEach HTLC has one of these states:\n\n\tADD_PRESTAGE\n\tADD_STAGED\n\tADD_SIGNING_AND_REVOKING\n\tADD_COMPLETE\n\tADD_REJECTED\n\n\tTIMEOUT_PRESTAGE\n\tTIMEOUT_STAGED\n\tTIMEOUT_SIGNING_AND_REVOKING\n\tTIMEOUT_COMPLETE\n\n\tSETTLE_PRESTAGE\n\tSETTLE_STAGED\n\tSETTLE_SIGNING_AND_REVOKING\n\tSETTLE_COMPLETE\n\nEach side starts with a commit tx with 0 HTLCs.  HTLCs are numbered\nusing a counter, but these numbers explicitly sent on the wire.\nProposed changes are processed in order.\n\nAdding An HTLC\n--------------\nA: HTLC = ADD_PRESTAGE.  Send \"add request { htlc details }\".\nB: Receive \"add request\".\n   (If reject, reply and forget HTLC, we'll ignore this)\n   If accept, HTLC = ADD_STAGED (since both sides know it), send \"accept\"\nA: Receive \"accept\".  HTLC = ADD_STAGED.\n\nRemoving An HTLC\n----------------\nThere's timeout and there's settle; the only difference is settle\nrequires the R value.\n\nA: HTLC must be in ADD_COMPLETE state.  HTLC = SETTLE/TIMEOUT_PRESTAGE.\n   Send \"settle/timeout request { htlc id [r value] }\".\nB: Receive \"request\".  Check r value for settle, time for timeout.\n   HTLC = SETTLE/TIMEOUT_STAGED (since both sides know it), send \"accept\"\nA: Receive \"accept\".  HTLC = ADD_STAGED.\n\nCommitting\n----------\nBoth sides can do this.  I can't figure out how the HTLC states work\nhere, since we might have sent the signature, but not received theirs.\nShould there be a separate SIG_SENT and SIG_RECEIVED states?  \n\nA: Move HTLCs all *_STAGED htlcs to *_SIGNING_AND_REVOKING, then\n   generate their commit tx using all the ADD_COMPLETE and\n   ADD_SIGNING_AND_REVOKING htlcs.  Sign it, and send\n   \"commit { staged-htlcs; sig }\"\nB: Receive commit, generate our commit tx using all the ADD_COMPLETE,\n   and any TIMEOUT_PRESTAGE or SETTLE_PRESTAGE which are not listed\n   in staged-htlcs.  Check their signature is valid for this.\n   [FIXME: Does B update states here?]\n   Send \"commit revocation { old-revocation-preimage }\" for\n   the previous commit tx.\nA: Receive commit revocation, move all the HTLCs we moved in\n   step 1 above from *_SIGNING_AND_REVOKING to *_COMPLETE.\n   (If we never create two commits in-flight at once, this is simply\n   every *_SIGNING_AND_REVOKING htlc).\n\nProposals\n=========\n\nThere's no reason to \"accept\" anything except an add request.  Thus the\nstates SETTLE_PRESTAGE and TIMEOUT_PRESTAGE are redundant.\n\nThere are also other failures (ie. upstream node rejected).  This\nsuggests a FAIL messages, perhaps with a reason message (which might be\nencrypted back to the payer).\n\nC-lightning only allows closes be sent from the HTLC recipient.  I\nthought that would be simpler but it doesn't make any real difference\n(it only applies to TIMEOUT; FAIL and SETTLE have to come from recipient\nanyway).  I would defined TIMEOUT to be the responsibility of the HTLC\nproposer.\n\nIn order to reduce latency, we want to be able to start staging an HTLC\non the outgoing channel before it's committed on the incoming one.  But\nthis means an HTLC recipient can't commit to the HTLC until the HTLC\nsender does.\n\nThis has a few implications:\n1) We need a new \"unstage request\" to unstage if the incoming HTLC fails\n   to complete in reasonable time.  This requires no accept response.\n2) We don't need to commit to adds and removes in order wrt each other;\n   a commit message always commits to:\n        - All HTLCs proposed and commited by the other side, and\n        - All removes staged by the other side up to some counter, and\n        - All HTLCs proposed by this side up to some counter, and\n        - All removes sent by this side.\n3) This implies we should count htlcs and remove requests separately;\n   the htlc count could also serve as an HTLC ID which makes timeout/fail/abort\n   messages shorter than using R hashes.\n\nOh, and it should be illegal to send a noop commit (ie. one which\ndoesn't change the commit tx).\n\nThat's enough email for now!\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-04T06:35:03",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> On Wed, Feb 03, 2016 at 03:05:33PM +1030, Rusty Russell wrote:\n>> Right, so \"this signature covers you up to X me up to Y\".  That resolves\n>> the in-flight issue.\n>> \n>> But isn't that more a request ID rather than an HTLC ID?  Since requests\n>> can include removing HTLCs as well?  And doesn't that simply degrade to\n>> a counter?\n>\n> Yeah, it's more like a request \"staging\" ID. The \"counter\" aspect\n> requires two counters (one for each originator of the request). Two IDs\n> sent in the commitment message allow for simultaneous action on\n> accept/reject/etc, whereas only one would require a lock on\n> accepting/rejecting modifications.\n\nIndeed.\n\nI wrote up the protocol as I gleaned it from your explanations, and it\nwas many words.  But I couldn't quite figure out the commitment steps,\nso maybe I'm missing something.\n\nDoes your scheme prevent cut-through HTLCs?  A sends B an \"add request\"\nand B wants to send the corresponding \"add request\" to C immediately to\nminimize latency.\n\nIf B does this, it has the HTLCa in ADD_STAGED with A, and HTLCb in\nADD_STAGED and C.  C sends B a commit sig which covers the new HTLCb,\nbut B doesn't want to be locked into HTLCb in case A vanishes before\nHTLCa is committed...\n\nThanks!\nRusty.\nPS.  Reading Go is suprisingly nice :)"
            }
        ],
        "thread_summary": {
            "title": "Protocol for multiple in-flight updates.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Joseph Poon"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 18134
        }
    },
    {
        "title": "[Lightning-dev] Simplified protocol for multiple in-flight updates.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-02-08T20:17:07",
                "message_text_only": "Hi all!\n\n        Eliminating all acknowledgements makes for a much simpler\nprotocol.\n\n        Each side sends one or more updates\n(ADD/SETTLE/TIMEOUT/FAIL/UNADD), followed by a COMMIT (with sig).  Reply\nCOMPLETE with the old revocation preimage.  Each side tracks two commit\ntxs: its own and the other side's.  When you COMMIT you're locking in\nyour updates to my commit, and staging them for your commit, enforcing\nthe requirement that you commit to your updates first.\n\nDetails\n-------\nADD:\n        Insert this new HTLC from proposer to recipient.\nSETTLE:\n        Recipient collects proposers's committed HTLC with R value.\nTIMEOUT:\n        Proposer removes committed HTLC it added.\nFAIL:\n        Recipient removes committed HTLC it received.\nUNADD:\n        Proposer removes uncommitted HTLC it added.\n\nCOMMIT:\n        Contains a signature for receiver's commit tx, with all the\n        updates included.  Recipient commits updates to its own commit tx,\n        and stages those same updates to the other side's commit tx, then\n        sends COMPLETE for its own old commit tx.\n\nCOMPLETE:\n        Completes removal of old commit tx.  Recipient commits updates\n        to other side's commit tx, stages those same updates for its own\n        commit tx.\n\nSo the shortest possible complete exchange looks like:\n\nA               B\nADD->\nCOMMIT->\n                <-COMPLETE\n                <-COMMIT\nCOMPLETE->\n\nOptimizations\n-------------\nIf we want to fail faster, we can add a non-binding ADD_FAIL message,\nrather than waiting for a COMMIT.  This would be a hint that we will\nFAIL an HTLC as soon as it is committed; recipient may UNADD if it\nreceives it in time.\n\nFee Negotiation\n---------------\nlnd has a fee field in their commit msg, c-lightning uses a fixed fee\nnegotiation at channel establishment and a FIXME.  The logical place for\nfee negotiation is in the COMMIT message, with a requested fee rate and\na range of acceptable values.  Instead of COMPLETE a node may REJECT,\nwith a fee range; the COMPLETE may then be reattempted.\n\nSimilar fee negotiation would be required for mutual close (this isn't\nas urgent and so would use a normal fee).\n\nCheers,\nRusty."
            },
            {
                "author": "Joseph Poon",
                "date": "2016-02-09T01:08:20",
                "message_text_only": "On Tue, Feb 09, 2016 at 06:47:07AM +1030, Rusty Russell wrote:\n>         Eliminating all acknowledgements makes for a much simpler\n> protocol.\n\nFor adding HTLCs, this may be an option, but there are some tradeoffs.\nThe downside of doing this is that it's uncertain whether the other\nparty has received the message. Essentially, the moment the packets are\nsent over the wire, it should be assumed the other party can broadcast\n(TCP SACKs cannot be relied upon, of course). To remove the HTLC\nsecurely, it requires removing the HTLC, committing, and then the other\nparty revokes the prior commitment. If the ratio of success/failure is\nhigh enough it can be worth it. This may have some disadvantages with\nintermittently connected nodes, as requiring confirmation has a\nsignificantly smaller time window for non-responsive payments. I'm\noptimizing against payment failure on the ADD side, as failure may\nrequire a re-route in the opposite direction to do a full cancel with a\nnon-responsive node in multi-hop payments (as an add request/accept\nstructure has lower time windows for going offline). However, I agree if\nboth nodes are well connected, then this is more optimal if latency is\nthe primary concern.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-09T04:30:24",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> On Tue, Feb 09, 2016 at 06:47:07AM +1030, Rusty Russell wrote:\n>>         Eliminating all acknowledgements makes for a much simpler\n>> protocol.\n>\n> For adding HTLCs, this may be an option, but there are some tradeoffs.\n> The downside of doing this is that it's uncertain whether the other\n> party has received the message. Essentially, the moment the packets are\n> sent over the wire, it should be assumed the other party can broadcast\n> (TCP SACKs cannot be relied upon, of course).\n\nOnly once you've sent the signature; they ack the signature with the old\nrevocation preimage.  It's a single-RTT window.\n\n> To remove the HTLC securely, it requires removing the HTLC,\n> committing, and then the other party revokes the prior commitment. If\n> the ratio of success/failure is high enough it can be worth it.\n> This may have some disadvantages with\n> intermittently connected nodes, as requiring confirmation has a\n> significantly smaller time window for non-responsive payments.\n\nI don't think anything can save a node which goes offline in the middle\nof an exchange.  Not sure this makes it worse?\n\n> I'm\n> optimizing against payment failure on the ADD side, as failure may\n> require a re-route in the opposite direction to do a full cancel with a\n> non-responsive node in multi-hop payments (as an add request/accept\n> structure has lower time windows for going offline).\n\nI'm not convinced the re-route scheme will be used in practice.  We're\nprobably going to need to distinguish (for fee reasons) payments\nexpected to resolve quickly, and those expected to take a long time.\nRe-routing in the opposite direction is worst case: it ties up funds for\na long time with no actual likely redemption, thus would require a large\nup-front fee.\n\nI think in practice, if a node goes down with possibly-live HTLCs, those\nHTLCs get delayed.  The node loses channels, too, so it's not free for\nthem either.\n\n> However, I agree if\n> both nodes are well connected, then this is more optimal if latency is\n> the primary concern.\n\nThis offers 3x inter-node latency, which is optimal AFAICT (I know I\ntalked about cut-through, but while possible for route discovery it\nturns out not to help total end-to-end commit latency).\n\nAs I said before, I was unsure on your commitment scheme, so maybe I'm\nmissing a trick?\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Simplified protocol for multiple in-flight updates.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Joseph Poon"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5756
        }
    },
    {
        "title": "[Lightning-dev] HTLCs using OP_CHECKSEQUENCEVERIFY/OP_LOCKTIMEVERIFY and revocation hashes.",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2016-02-08T22:07:53",
                "message_text_only": "> See:\n> \n>         https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf\n\nSorry for replying to a very old e-mail, but I've finally had a really\nclose look at this, and the way I see it, there could be a potential\nproblem.\n\nSuppose Eve (E) has two channels with Alice (A). She intends to steal\nfunds from Alice. This is what she does:\n\nShe performs a payment to herself, routed through Alice with the two\nchannels. When the funds are locked in the two channels, she is supposed\nto reveal the transaction R value as a payee, but she doesn't. So, the\ntransaction times out on both channels, leading to a channel update on\nboth: the HTLCs are removed, reverting back to the original situation. \n\nThe following actions primarily take place on the channel where Eve was\non the RECEIVING side of the transaction. First, Eve spends all her\ncoins on that channel, e.g. by sending them to herself on the other\nchannel. This way, she doesn't risk losing them.\n\nNext, on the channel where Eve was on the RECEIVING side of the\ntransaction, Eve signs and broadcasts the version of the commit\ntransaction that contained the HTLC. Of course, since revocation\npre-images have been exchanged, Alice can immediately spend the HTLC,\nusing either the HTLC-TIMEOUT & SIG-PAYER clause or the REVOCATION-E &\nSIG A clause. However, this is not guaranteed to work: Eve has the\ntransaction R value, so Eve can *also* try to spend it, using the\nR-VALUE & SIG-PAYEE clause. In fact, since Eve knows sooner about the\ncommit transaction than Alice, Eve is more likely to be the first to\nspend the HTLC, especially when Alice is offline for a moment (Eve can\nknow that).\n\nNow, if Eve succeeds in spending the HTLC, what can Alice do? She can of\ncourse claim her own balance, and using the revocation pre-image, claim\nEve's balance in the commit transaction, but that way, she receives less\nthan the total channel capacity, which is what she should have received.\n\nOn the other channel, Alice could try to perform the same trick on Eve\nthat Eve performed on her, since Alice now has the transaction R value.\nHowever, that is not guaranteed to work. Worse: Eve could also have\ndepleted her own balance on *that* channel, e.g. with a payment to\nherself through a third party. That way, Alice will never be able to get\nall the funds that belong to her, and Eve gets more than she deserves.\n\nHow to solve this issue? My first thought was that we should add an\nOP_CSV to the R-VALUE & SIG-PAYEE clause, but that would break its\nlegitimate use. I don't see how this can be solved without having a\ntwo-transaction set-up, and hence something like SIGHASH_NOINPUT (or\nmaybe SegWitness?). So it would have to be a bit more like \"Poon-Dryja\nchannels\".\n\nMaybe a \"never completely deplete the channel\" rule could be a\nwork-around? You could define a maximum for the sum of all active HTLCs\nin one direction in a commit transaction, and require the other side to\nalways have at least one or two times that maximum as remaining balance.\nWould that work?\n\nBTW, apologies if this was already known. In that case, my question is:\nwhere can I find an updated design?\n\nCJP"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-08T23:39:12",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n>> See:\n>> \n>>         https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf\n>\n> Sorry for replying to a very old e-mail, but I've finally had a really\n> close look at this, and the way I see it, there could be a potential\n> problem.\n>\n> Suppose Eve (E) has two channels with Alice (A). She intends to steal\n> funds from Alice. This is what she does:\n>\n> She performs a payment to herself, routed through Alice with the two\n> channels. When the funds are locked in the two channels, she is supposed\n> to reveal the transaction R value as a payee, but she doesn't. So, the\n> transaction times out on both channels, leading to a channel update on\n> both: the HTLCs are removed, reverting back to the original situation. \n>\n> The following actions primarily take place on the channel where Eve was\n> on the RECEIVING side of the transaction. First, Eve spends all her\n> coins on that channel, e.g. by sending them to herself on the other\n> channel. This way, she doesn't risk losing them.\n>\n> Next, on the channel where Eve was on the RECEIVING side of the\n> transaction, Eve signs and broadcasts the version of the commit\n> transaction that contained the HTLC. Of course, since revocation\n> pre-images have been exchanged, Alice can immediately spend the HTLC,\n> using either the HTLC-TIMEOUT & SIG-PAYER clause or the REVOCATION-E &\n> SIG A clause. However, this is not guaranteed to work: Eve has the\n> transaction R value, so Eve can *also* try to spend it, using the\n> R-VALUE & SIG-PAYEE clause. In fact, since Eve knows sooner about the\n> commit transaction than Alice, Eve is more likely to be the first to\n> spend the HTLC, especially when Alice is offline for a moment (Eve can\n> know that).\n\nFor this reason, the rule is that all outputs to A in A's commit\ntransaction must be delayed (via OP_CSV).  This includes HTLC outputs.\n\nReferring to Appendix A of the paper, under \"HTLC Receiver Redeemscript\"\n(since Alice offers Eve the HTLC, Eve is B):\n\nHTLC Receiver Redeemscript\n        OP_HASH160 OP_DUP Replace top element with two copies of its hash\n        <R-HASH> OP_EQUAL B redeeming the contract, using R preimage?\n        OP_IF\n                <DELAY> OP_CHECKSEQUENCEVERIFY Delay gives A enough\n                        time to use revocation if it has it.\n                OP_2DROP Drop extra hash and delay from the stack\n                <KEY-B> Pay to B\n        OP_ELSE\n                <COMMIT-REVOCATION-HASH> OP_EQUAL If the commit\n                                        has been revoked.\n                OP_NOTIF If not, you need to wait for timeout.\n                        <HTLC-TIMEOUT> OP_CHECKLOCKTIMEVERIFY OP_DROP\n                                       Ensure (absolute) time has passed.\n                OP_ENDIF\n                <KEY-A> Pay to A\n        OP_ENDIF\n        OP_CHECKSIG Verify A or B's signature is correct.\n\nHere you can see the CSV delay on the \"using R preimage\" path.\n\nI have a subtler suggestion, though: perhaps we should OP_CSV delay all\nthe non-revocation paths in HTLCs and in the straight payment outputs.\nOtherwise, if you want to do a unilateral close, there's some game\ntheory as you'd rather convince the other side to do it so your own\nfunds aren't locked up.  Delaying all non-revocation paths makes it an\narbitrary choice.\n\nI know Joseph will have some thoughts about that :)\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2016-02-09T08:59:56",
                "message_text_only": "On Tue, Feb 09, 2016 at 10:09:12AM +1030, Rusty Russell wrote:\n> Otherwise, if you want to do a unilateral close, there's some game\n> theory as you'd rather convince the other side to do it so your own\n> funds aren't locked up.\n\nI think the options are:\n\n a) keep the channel open\n b) they close the channel unilaterally\n c) you close the channel unilaterally\n d) you both close the channel cooperatively\n\nAt any point, I believe the preferences are strictly: d > b > c\n\n(b) is better than (c) because of the OP_CSV delay; and (d) is better\nthan (b) if you can use a lower transaction fee than you use for your\ncommitment transactions, or spend directly to a useful output address\n(opening up a new channel eg).\n\nIf you find yourself trying to convince the other person to do (b)\nto avoid doing (c) yourself, I think it's a dominating strategy to\nsimply do (d) -- you prefer that over (b) anyway, and they will prefer\nit over (c).\n\nWith the current arrangement, I don't think your counterparty can\nrealistically make any threats: \"you'll close the channel? okay,\nthat's better than me closing it!\" and \"you'll close the channel\nunilaterally? well, that's a lot worse for you as it is for me,\nso whatever\".\n\nWith an OP_CSV on both sides of HTLCs, you can make a somewhat\nrealistic threat: \"if you don't pay me $x to do a cooperative close,\nI'll close unilaterally which will lock your funds up. sure you can\nclose unilaterally yourself, but your funds will still be locked up that\nway too.\"\n\nSo changing seems like it would make things marginally worse, but no\nbetter, to me.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-09T23:14:46",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Tue, Feb 09, 2016 at 10:09:12AM +1030, Rusty Russell wrote:\n>> Otherwise, if you want to do a unilateral close, there's some game\n>> theory as you'd rather convince the other side to do it so your own\n>> funds aren't locked up.\n>\n> I think the options are:\n>\n>  a) keep the channel open\n>  b) they close the channel unilaterally\n>  c) you close the channel unilaterally\n>  d) you both close the channel cooperatively\n>\n> At any point, I believe the preferences are strictly: d > b > c\n>\n> (b) is better than (c) because of the OP_CSV delay; and (d) is better\n> than (b) if you can use a lower transaction fee than you use for your\n> commitment transactions, or spend directly to a useful output address\n> (opening up a new channel eg).\n>\n> If you find yourself trying to convince the other person to do (b)\n> to avoid doing (c) yourself, I think it's a dominating strategy to\n> simply do (d) -- you prefer that over (b) anyway, and they will prefer\n> it over (c).\n>\n> With the current arrangement, I don't think your counterparty can\n> realistically make any threats: \"you'll close the channel? okay,\n> that's better than me closing it!\" and \"you'll close the channel\n> unilaterally? well, that's a lot worse for you as it is for me,\n> so whatever\".\n>\n> With an OP_CSV on both sides of HTLCs, you can make a somewhat\n> realistic threat: \"if you don't pay me $x to do a cooperative close,\n> I'll close unilaterally which will lock your funds up. sure you can\n> close unilaterally yourself, but your funds will still be locked up that\n> way too.\"\n>\n> So changing seems like it would make things marginally worse, but no\n> better, to me.\n\nFair point.  The issue will improve when we have close with outstanding\nHTLCs.  Meanwhile it disturbs me that the party which goes offline pays\nthe least penalty; their counterparties have their funds tied though.\n\nCheers,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2016-02-09T19:48:59",
                "message_text_only": "Rusty Russell schreef op di 09-02-2016 om 10:09 [+1030]:\n> \n> For this reason, the rule is that all outputs to A in A's commit\n> transaction must be delayed (via OP_CSV).  This includes HTLC outputs.\n> \n> Referring to Appendix A of the paper, under \"HTLC Receiver Redeemscript\"\n> (since Alice offers Eve the HTLC, Eve is B):\n> [..]\n\nSo, summarized, the \"HTLC Receiver Redeemscript\" is actually something\nlike:\n\nR-VALUE & OP_CSV & SIG-PAYEE\nOR\nHTLC-TIMEOUT & SIG-PAYER\nOR\nREVOCATION-B & SIG A\n\nNow, I thought it wouldn't be OK to add an OP_CSV there, so let's see if\nI can exploit it.\n\nSame situation: Alice and Eve, connected with two channels. Eve performs\na payment to herself, routed through these two channels.\n\nNow, Eve allows the transaction to succeed on the channel where she\nreceives: Eve sends the R value to Alice, and Alice sends Eve a commit\ntransaction update where the HTLC is removed and Eve receives the funds.\n\nOn the other channel, Alice sends the R value to Eve, but Eve does not\nsend Alice a commit transaction update. In fact, Eve becomes completely\nunresponsive on this channel. This forces Alice to broadcast her commit\ntransaction, containing the HTLC. She has to do this *before* the CLTV\nof the HTLC times out, or otherwise Eve can try to claim the HTLC funds.\n\nNow, the question is: which times out first, Alice's CSV or Eve's CLTV?\nThe one that times out first will be the first to be able to claim the\nfunds. This *should* of course be Alice, so Alice's CSV should be the\nfirst to time out.\n\nLet's assume the HTLC timeout is T0 + 1 day on the channel where Eve\nreceives, T0 + 2 days on the channel where Eve sends. Eve wants to delay\nAlice's commit transaction as long as possible, so she sends the R value\njust before T0 + 1 day. That means Alice's CSV should have a delay *less\nthan* one day. If the CSV delay is set to 0.5 day, that means Alice has\na remaining 0.5 day time window in which her node must be up and running\nand connected to the Bitcoin network, to claim the HTLC funds.\n\nSo, I think it *is possible*. However, this leads to some uncomfortable\ntime trade-offs. The CSV delay determines how often your node must be up\nand running, to catch the use of revoked commit transactions. Longer is\nbetter: I'd be much more comfortable with 30 days than with 1 day. The\nHTLC timeout increment determines how long funds can be locked up and\npayment status can stay undetermined (worst-case); it adds up over the\nentire route. For this, shorter is better: 1 day would be much better\nthan 30 days.\n\nEven if you assume \"always-on, always connected\" nodes, e.g. cell\nphones, service providers and home servers, you have to take into\naccount that systems can fail, and manual intervention may be needed to\nrestore them. The downtime / DoS attack -> theft escalation is something\nwe don't want to happen.\n\nCJP"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-10T01:15:16",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> Rusty Russell schreef op di 09-02-2016 om 10:09 [+1030]:\n>> \n>> For this reason, the rule is that all outputs to A in A's commit\n>> transaction must be delayed (via OP_CSV).  This includes HTLC outputs.\n>> \n>> Referring to Appendix A of the paper, under \"HTLC Receiver Redeemscript\"\n>> (since Alice offers Eve the HTLC, Eve is B):\n>> [..]\n>\n> So, summarized, the \"HTLC Receiver Redeemscript\" is actually something\n> like:\n>\n> R-VALUE & OP_CSV & SIG-PAYEE\n> OR\n> HTLC-TIMEOUT & SIG-PAYER\n> OR\n> REVOCATION-B & SIG A\n\nYes.\n\n> Now, I thought it wouldn't be OK to add an OP_CSV there, so let's see if\n> I can exploit it.\n>\n> Same situation: Alice and Eve, connected with two channels. Eve performs\n> a payment to herself, routed through these two channels.\n>\n> Now, Eve allows the transaction to succeed on the channel where she\n> receives: Eve sends the R value to Alice, and Alice sends Eve a commit\n> transaction update where the HTLC is removed and Eve receives the funds.\n>\n> On the other channel, Alice sends the R value to Eve, but Eve does not\n> send Alice a commit transaction update. In fact, Eve becomes completely\n> unresponsive on this channel. This forces Alice to broadcast her commit\n> transaction, containing the HTLC. She has to do this *before* the CLTV\n> of the HTLC times out, or otherwise Eve can try to claim the HTLC funds.\n>\n> Now, the question is: which times out first, Alice's CSV or Eve's CLTV?\n> The one that times out first will be the first to be able to claim the\n> funds. This *should* of course be Alice, so Alice's CSV should be the\n> first to time out.\n\nYes, unfortunately they're intertwined.  I was sure we'd discussed\nthis before, and I found it.\n\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000077.html\n\nWe keep rediscovering this problem so I need to document it somewhere.\n\n> Let's assume the HTLC timeout is T0 + 1 day on the channel where Eve\n> receives, T0 + 2 days on the channel where Eve sends. Eve wants to delay\n> Alice's commit transaction as long as possible, so she sends the R value\n> just before T0 + 1 day. That means Alice's CSV should have a delay *less\n> than* one day. If the CSV delay is set to 0.5 day, that means Alice has\n> a remaining 0.5 day time window in which her node must be up and running\n> and connected to the Bitcoin network, to claim the HTLC funds.\n>\n> So, I think it *is possible*. However, this leads to some uncomfortable\n> time trade-offs. The CSV delay determines how often your node must be up\n> and running, to catch the use of revoked commit transactions. Longer is\n> better: I'd be much more comfortable with 30 days than with 1 day. The\n> HTLC timeout increment determines how long funds can be locked up and\n> payment status can stay undetermined (worst-case); it adds up over the\n> entire route. For this, shorter is better: 1 day would be much better\n> than 30 days.\n\nYes.  If A insists that B use a 30 day CSV, A can't ask B to accept an\nHTLC with less than (say) 31 days lifetime.\n\nIn general, an HTLC timeout must comfortably exceed the highest CSV\ndelay on the route.\n\nIt sucks, but at least it's not the sum of CSV delays.  Keeping CSV time\ndown is the motivation for outsourcing the enforcement (which I think\nSegWit gives us the ability to do, because the txids of the commit\ntransactions won't be malleable).\n\n> Even if you assume \"always-on, always connected\" nodes, e.g. cell\n> phones, service providers and home servers, you have to take into\n> account that systems can fail, and manual intervention may be needed to\n> restore them. The downtime / DoS attack -> theft escalation is something\n> we don't want to happen.\n\nIndeed!  c-lightning requests a CSV timeout of 1 day, allows requests of\nup to 2 days (comment says 3, but it's wrong).  It only allows HTLCS of\nup to 5 days in the future, but it wants a 6 hour window minimum[1].\n\nIf we want to allow CSV timeouts of 5 days[2], HTLC timeout decrements\nof up to 1 day per node over 20 hops, that means we need to allow HTLC\ntimeouts of 26 days :(\n\nWe can play with those numbers a bit (20 hops is a bit much, 1 day seems\nexcessive given you can always drop commit txs to blockchain if DDoS is\nsevere), but I think the per-hop decrement will dominate.\n\nCheers,\nRusty.\n[1] It should be \"CSV + 6 hours\", this is the bug.\n[2] A 4-day long weekend plus one day of frantic panic; this was the\n    default timeout in the Linux NAT code."
            },
            {
                "author": "CJP",
                "date": "2016-02-11T21:00:32",
                "message_text_only": "> Yes, unfortunately they're intertwined.  I was sure we'd discussed\n> this before, and I found it.\n> \n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000077.html\n> \n> We keep rediscovering this problem so I need to document it somewhere.\n\nAh, I see. I think, at the time that message was sent, I didn't\nunderstand it yet. Now that I did the thinking myself, I guess I do.\n\nCool to see that the alternative solution (never completely depleting\nones channel balance, to have some 'collateral') was also mentioned. I'm\nnot sure yet which is better; if there is a demand for it, both types\ncould be implemented and used next to each other in Amiko Pay.\n\nCJP"
            },
            {
                "author": "Anthony Towns",
                "date": "2016-02-10T16:50:49",
                "message_text_only": "On Tue, Feb 09, 2016 at 08:48:59PM +0100, CJP wrote:\n\nReference:\n http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000361.html\n\n> Same situation: Alice and Eve, connected with two channels. Eve performs\n> a payment to herself, routed through these two channels.\n\nOkay, so the channels are:\n\n   Eve <-> Alice\n   Evelyn <-> Alice  (Eve's alias)\n\nwith the delay (OP_CSV) parameter for both channels set at the value\n\"D\". In addition, Alice's commitments include a fee that she expects will\nresult in confirmation in less than a delay of \"F\", and she's confident\nthat a transaction can be spent so long as its been in the blockchain for\n\"N\" units of time.\n\nThe HTLCs are:\n\n   Eve pays Alice $X on receipt of R, CLTV at time T\n   Alice pays Evelyn $X on receipt of R, CLTV at time T'\n\nPer the mail above, when forwarding the HTLC, Alice calculates T' such that\n\n   T' <= T - D - 2*F - N\n\nand\n\n   T' >= now + D + F\n\n> Now, Eve allows the transaction to succeed on the channel where she\n> receives: Eve sends the R value to Alice, and Alice sends Eve a commit\n> transaction update where the HTLC is removed and Eve receives the funds.\n\nAssuming that all works out, and Evelyn reveals R and collects $X straight\naway, the second HTLC is dealt with, and things are fine so far.\n\n> On the other channel, Alice sends the R value to Eve, but Eve does not\n> send Alice a commit transaction update. In fact, Eve becomes completely\n> unresponsive on this channel.\n\nAt this point Alice should start the timer ticking. If she doesn't get\nan ack from Eve prior to T-D-F, she must go to the blockchain. Suppose\nshe leaves it to the last minute.\n\n> This forces Alice to broadcast her commit\n> transaction, containing the HTLC. She has to do this *before* the CLTV\n> of the HTLC times out, or otherwise Eve can try to claim the HTLC funds.\n\nSo she publishes her commitment transaction at T-D-F. The transaction\ngets mined before \"F\" time units transpire, so the time is now T-D-x.\nAfter an additional \"D\" time units, the time is T-x, at which point Alice\ncan spend the transaction, but Eve cannot.\n\n> Now, the question is: which times out first, Alice's CSV or Eve's CLTV?\n> The one that times out first will be the first to be able to claim the\n> funds. This *should* of course be Alice, so Alice's CSV should be the\n> first to time out.\n\nSo I think that answers the question.\n\n> Let's assume the HTLC timeout is T0 + 1 day on the channel where Eve\n> receives, T0 + 2 days on the channel where Eve sends. \n\nIn that case, from the above inequalities:\n\n   D + 2*F + N <= 1 day\n\n> Eve wants to delay\n> Alice's commit transaction as long as possible, so she sends the R value\n> just before T0 + 1 day.\n\nThat doesn't work: if the forwarded HTLC isn't resolved by T'-D-F she\nhas to close the channel on the blockchain to be safe. If her fees are\nhigh enough, D+F could perhaps be as low as an hour, though, so T0+23\nhours might be reasonable.\n\n> That means Alice's CSV should have a delay *less\n> than* one day. If the CSV delay is set to 0.5 day, that means Alice has\n> a remaining 0.5 day time window in which her node must be up and running\n> and connected to the Bitcoin network, to claim the HTLC funds.\n\nYes, rearranging the inequality above gives D <= (T-T') - 2*F - N, so\nit has to be quite a bit smaller than the delta between timeouts across\na given node.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "HTLCs using OP_CHECKSEQUENCEVERIFY/OP_LOCKTIMEVERIFY and revocation hashes.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "CJP"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 21406
        }
    },
    {
        "title": "[Lightning-dev] Fwd: [bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2016-02-26T01:21:31",
                "message_text_only": "From: Joseph Poon via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nDate: Thu, Feb 25, 2016 at 7:07 PM\nSubject: [bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness\nTo: bitcoin-dev at lists.linuxfoundation.org\n\n\nAs Segregated Witness will be merged soon as a solution for transaction\nmalleability, especially with multi-party adversarial signatures, there\nmay be an additional use case/functionality which is helpful for\nLightning Network and possibly other Bitcoin use cases. This requires a\nnew SIGHASH flag inside Segregated Witness which does not sign the input\ntxid/index.\n\nSegwit is very helpful in resolving malleability in pretty much every\ncase which matters. It is especially helpful in having solid and safe\ndefaults for standard Bitcoin payments; it's very difficult to mess up\nif you are writing code in conjunction with the Bitcoin RPC API.\n\nHowever, it is very useful for LN if there is a certain level of\noutsourcibility for transactions without this 3rd party taking on\nonerous costs. In LN, there is a dispute resolution period established\nto prevent the counterparty from attesting an incorrect channel state\n(represented by broadcasting a timelocked transaction). In other words,\nif someone in a channel broadcasts an incorrect state, the output can be\nredeemed by a 3rd party (but this 3rd party is not a custodian, since\nthe output goes to the other party in the channel).\n\nIdeally, a 3rd-party can be handed a transaction which can encompass all\nprior states in a compact way. For currently-designed Segregated Witness\ntransactions, this requires storing all previous signatures, which can\nbecome very costly if individuals to thousands of channel state updates\nper day. This is very possible, as fees are near-zero, the value in\natomizing all payments to many transactions becomes viable (reducing\ntransaction/information costs). If individuals are doing tens of\nthousands of transactions per day, and one presumes something like\n70-bytes of data per Commitment state in the channel, it quickly becomes\ninfeasible to watch on behalf of many channels without material costs.\n\nThis is especially necessary because it is highly desirable to make\nkeeping track of these channels be very cheap, as it allows for more\nparticipants to be watching on one's behalf (reducing the chance of a\n3rd party fail to watch). Further, it may reduce the need to notify the\n3rd party for every single channel Commitment state, instead only\nproviding the most recent one should provide sufficient information for\nall prior states (since the signature will apply for any type of\ntransaction), making the only updated information the revocation\nsecret/preimage. Without this SIGHASH flag, every single state would\nneed to be contacted and updated with 3rd parties. With this SIGHASH\nflag, one could instead delegate outsourcing when one's client goes\noffline with a single message several hundred bytes in size,\nencompassing all prior states.\n\nOf course, while running a 24/7 full-node is encouraged, I suspect many\npeople will not want to do so at the current time, and it needs to be\nfunctional for those who elect to be connected intermittently. This\nrequires outsourcing or watching on one's behalf.\n\nThis would be achieved using a SIGHASH flag, termed SIGHASH_NOINPUT. It\ndoes not include as part of the signature, the outpoint being spent\n(txid and index), nor the amount. It however, would include the spent\noutpoint's script as part of the signature. Note that this is just a\nSIGHASH flag, and the outpoints are still being included as part of the\ntxins (if they are mutated, the new txids can be updated by the wallet\nwithout resigning). This allows for a signature to apply to anything\nwith that pubkey (therefore pubkeys with this flag should not be\nreused). For safety, this only applies in SegWit transactions, as segwit\nprovides a sufficient malleability solution, there is no incentive to\nimproperly use this sighash flag as a roundabout way to resolve\nmalleability.\n\nThis helps with 3rd-party outsourcing for watching the blockchain, as\none can provide a signature (and the most recent hash-chain of\nrevocation preimages), which encompasses penalty transactions for all\nprior states. Functionally, this allows for opt-in wildcard inputs, but\nwallets which do not require these transactions do not need to be\nconcerned with this flag; since they will never be signing with this\nflag, they do not need to be concerned with address re-use.\n\nI'm interested in input and in the level of receptiveness to this. If\nthere is interest, I'll write up a draft BIP in the next couple days.\n\n--\nJoseph Poon\n_______________________________________________\nbitcoin-dev mailing list\nbitcoin-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n\n\n\n-- \n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160225/d36eb404/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: SIGHASH_NOINPUT in Segregated Witness",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Bryan Bishop"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5031
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2016-02-26T01:34:24",
                "message_text_only": "On Thu, Feb 25, 2016 at 7:07 PM, Joseph Poon wrote:\n> This would be achieved using a SIGHASH flag, termed SIGHASH_NOINPUT. It\n> does not include as part of the signature, the outpoint being spent\n> (txid and index), nor the amount. It however, would include the spent\n> outpoint's script as part of the signature. Note that this is just a\n\nWell if you are bothering to draft up a BIP about that SIGHASH flag,\nthen perhaps also consider some other SIGHASH flag types as well while\nyou are at it?\n\nVarious proposed sighash types:\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010759.html\n\n\"Build your own nHashType\" proposal draft:\nhttps://github.com/scmorse/bitcoin-misc/blob/master/sighash_proposal.md\n\njl2012's reply:\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010779.html\n\npetertodd's reply about OP_CODESEPARATOR linked back to this thread\nregarding \"Build your own nHashType\":\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-April/007771.html\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-April/007802.html\nhttp://gnusha.org/bitcoin-wizards/2014-12-09.log\n\n((That particular thread had other replies which can be viewed here:\nhttp://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-April/thread.html\n))\n\nAlso, there was a draft implementation of SIGHASH_NOINPUT:\nhttps://github.com/Roasbeef/bitcoin/commit/4b3c3f1baf7985208ceb6887261ee150ab6e3328\nhttps://github.com/Roasbeef/btcd/commit/67830e506fa135d5239177340918cea39909e6a4\n\nFWIW there was some concern about replay using SIGHAHS_NOINPUT or something:\nhttp://gnusha.org/bitcoin-wizards/2015-04-07.log\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507"
            },
            {
                "author": "Joseph Poon",
                "date": "2016-02-26T02:02:26",
                "message_text_only": "Hi Bryan,\n\nOn Thu, Feb 25, 2016 at 07:34:24PM -0600, Bryan Bishop wrote:\n> Well if you are bothering to draft up a BIP about that SIGHASH flag,\n> then perhaps also consider some other SIGHASH flag types as well while\n> you are at it?\n\nI'll take a look at those proposals when drafting the BIP. I think for\nLN, there is a single clean way to achieve outsourcability, but may be\ncompatible with other arrangements. I'm somewhat averse to proposing too\nmuch flexibility before there's clear use-cases, though. However, if\nothers do have uses/examples for other sighash flags, I'd be very\ninterested while drafting this BIP!\n\n> FWIW there was some concern about replay using SIGHAHS_NOINPUT or something:\n> http://gnusha.org/bitcoin-wizards/2015-04-07.log\n\nYeah, I think the nice thing about SegWit is that you resolve\nmalleability without worrying about replay attacks in the event of key\nreuse. That's why I think it's only safe to do this new sighash type\ninside segwit itself -- if you only wanted protection against\nmalleability you'd use segwit, and not touch this new sighash type\n(you'd only use the new sighash flag if you actually need its features).\n\n-- \nJoseph Poon"
            },
            {
                "author": "Anthony Towns",
                "date": "2016-02-26T03:20:56",
                "message_text_only": "On Fri, Feb 26, 2016 at 01:32:34AM +0000, Gregory Maxwell via bitcoin-dev wrote:\n> On Fri, Feb 26, 2016 at 1:07 AM, Joseph Poon via bitcoin-dev\n> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n> > I'm interested in input and in the level of receptiveness to this. If\n> > there is interest, I'll write up a draft BIP in the next couple days.\n> .. I think this should probably be constructed as a new segwit script type,\n> and not a base feature.\n\n+1 to both\n\n> The exact construction you're thinking of there isn't clear to me...\n\nI think the idea is that you have three transactions:\n\n anchor:\n   input: whatever\n   output:\n     - single output, spendable by 2-of-2 multisig\n     - [possibly others as well, whatever]\n\n commitment:\n   input: anchor\n   outputs:\n     1. payment to A\n     2. payment to B\n     3. HTLC to A on R1, timeout T1\n     4. HTLC to A on R2, timeout T2\n     5. HTLC to B on R3, timeout T3\n     ...\n\n penalty:\n   inputs:\n     all the outputs from the commitment tx\n   outputs:\n     1. 99% as payment to me\n     2.  1% as outsourcing fee\n\nAs long as the key I use for spending each of commitment transactions\noutputs is \"single use\" -- ie, I don't use it for other channels or\nanywhere else on the blockchain, then as long as the signature commits\nto the outputs it's safe afaics.\n\n(You still have to send a lot of data to the place you're outsourcing\nchain-monitoring to; all the R1,R2,R3 and T1,T2,T3 values are needed in\norder to reconstruct the redeem scripts)\n\n> one thing that comes to mind is that I think it is imperative that we\n> do not deploy a without-inputs SIGHASH flag without also deploying at\n> least a fee-committing sighash-all.\n\nIf the fee for commitment transactions changes regularly (eg, a new\ncommitment transaction is generated every few seconds/minutes, and the fee\nis chosen based on whatever estimatefee returns), I think this would cause\nproblems -- you couldn't use a single signature to cover every revoked\ncommitment, you'd need one for each different fee level that you'd used\nfor the lifetime of the channel. Actually, the size of the commitment\ntransaction will differ anyway depending on how many HTLCs are open,\nso even if estimatefee didn't change, the fee would still differ. So I\nthink commiting to a fee isn't workable for the lightning use case...\n\n> When you do write a BIP for this its imperative that the vulnerability\n> to replay is called out in bold blinking flaming text, along with the\n> necessary description of how to use it safely. The fact that without\n> input commitments transactions are replayable is highly surprising to\n> many developers... Personally, I'd even go so far as to name the flag\n> SIGHASH_REPLAY_VULNERABLE. :)\n\n+1, though I'm not sure it's so much \"vulnerable\" to replay as it is\n\"explicitly designed\" to be replayable...\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-02-29T00:25:53",
                "message_text_only": "Joseph Poon via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:\n> Ideally, a 3rd-party can be handed a transaction which can encompass all\n> prior states in a compact way. For currently-designed Segregated Witness\n> transactions, this requires storing all previous signatures, which can\n> become very costly if individuals to thousands of channel state updates\n> per day.\n\nAFAICT we need more than this.  Or are you using something other than\nthe deployable lightning commit tx style?\n\nIf each HTLC output is a p2sh[1], you need the timeout and rhash for\neach one to build the script to redeem it.  In practice, there's not\nmuch difference between sending a watcher a tx for every commit tx and\nsending it information for every new HTLC (roughly a factor of 2).\n\nSo we also need to put more in the scriptPubKey for this to work; either\nthe entire redeemscript, or possibly some kind of multiple-choice P2SH\nwhere any one of the hashes will redeem the payment.\n\nCheers,\nRusty.\n[1] eg. from https://github.com/ElementsProject/lightning/blob/master/doc/deployable-lightning.pdf\n        OP_HASH160 OP_DUP # Replace top element with two copies of its hash\n        <R-HASH> OP_EQUAL # Test if they supplied the HTLC R value\n        OP_SWAP <COMMIT-REVOCATION-HASH> OP_EQUAL OP_ADD\n                          # Or the commitment revocation hash\n        OP_IF # If any hash matched.\n                <KEY-B> # Pay to B.\n        OP_ELSE # Must be A, after HTLC has timed out.\n                <HTLC-TIMEOUT> OP_CHECKLOCKTIMEVERIFY Ensure (absolute) time has passed.\n                <DELAY> OP_CHECKSEQUENCEVERIFY # Delay gives B enough time to use revocation if it has it.\n                OP_2DROP # Drop the delay and htlc-timeout from the stack.\n                <KEY-A> # Pay to A.\n        OP_ENDIF\n        OP_CHECKSIG # Verify A or B's signature is correct.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "SIGHASH_NOINPUT in Segregated Witness",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Bryan Bishop",
                "Joseph Poon"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7559
        }
    }
]