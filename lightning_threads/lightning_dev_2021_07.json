[
    {
        "title": "[Lightning-dev] bLIPs: A proposal for community-driven app layer and protocol extension standardization",
        "thread_messages": [
            {
                "author": "Ariel Luaces",
                "date": "2021-07-01T00:31:40",
                "message_text_only": "BIPs are already the Bazaar style of evolution that simultaneously\nallows flexibility and coordination/interoperability (since anyone can\ncreate a BIP and they create an environment of discussion).\n\nBOLTs are essentially one big BIP in the sense that they started as a\nplace for discussion but are now more rigid. BOLTs must be followed\nstrictly to ensure a node is interoperable with the network. And BOLTs\nshould be rigid, as rigid as any widely used BIP like 32 for example.\nEven though BOLTs were flexible when being drafted their purpose has\nchanged from descriptive to prescriptive.\nAny alternatives, or optional features should be extracted out of\nBOLTs, written as BIPs. The BIP should then reference the BOLT and the\nrequired flags set, messages sent, or alterations made to signal that\nthe BIP's feature is enabled.\n\nA BOLT may at some point organically change to reference a BIP. For\nexample if a BIP was drafted as an optional feature but then becomes\nmore widespread and then turns out to be crucial for the proper\noperation of the network then a BOLT can be changed to just reference\nthe BIP as mandatory. There isn't anything wrong with this.\n\nAll of the above would work exactly the same if there was a bLIP\nrepository instead. I don't see the value in having both bLIPs and\nBIPs since AFAICT they seem to be functionally equivalent and BIPs are\nnot restricted to exclude lightning, and never have been.\n\nI believe the reason this move to BIPs hasn't happened organically is\nbecause many still perceive the BOLTs available for editing, so\nchanges continue to be made. If instead BOLTs were perceived as more\n\"consensus critical\", not subject to change, and more people were\nstrongly encouraged to write specs for new lightning features\nelsewhere (like the BIP repo) then you would see this issue of growing\nBOLTs resolved.\n\nCheers\nAriel Lorenzo-Luaces\n\nOn Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>\n> > That being said I think all the points that are addressed in Ryan's mail\n> > could very well be formalized into BOLTs but maybe we just need to rethink\n> > the current process of the BOLTs to make it more accessible for new ideas\n> > to find their way into the BOLTs?\n>\n> I think part of what bLIPs are trying to solve here is promoting more loosely\n> coupled evolution of the network. I think the BOLTs do a good job currently of\n> specifying what _base_ functionality is required for a routing node in a\n> prescriptive manner (you must forward an HTLC like this, etc). However there's\n> a rather large gap in describing functionality that has emerged over time due\n> to progressive evolution, and aren't absolutely necessary, but enhance\n> node/wallet operation.\n>\n> Examples of  include things like: path finding heuristics (BOLTs just say you\n> should get from Alice to Bob, but provides no recommendations w.r.t _how_ to do\n> so), fee bumping heuristics, breach retribution handling, channel management,\n> rebalancing, custom records usage (like the podcast index meta-data, messaging,\n> etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n> optimization, initial channel boostrapping, etc.\n>\n> All these examples are effectively optional as they aren't required for base\n> node operation, but they've organically evolved over time as node\n> implementations and wallet seek to solve UX and operational problems for\n> their users. bLIPs can be a _descriptive_ (this is how things can be done)\n> home for these types of standards, while BOLTs can be reserved for\n> _prescriptive_ measures (an HTLC looks like this, etc).\n>\n> The protocol as implemented today has a number of extensions (TLVs, message\n> types, feature bits, etc) that allow implementations to spin out their own\n> sub-protocols, many of which won't be considered absolutely necessary for node\n> operation. IMO we should embrace more of a \"bazaar\" style of evolution, and\n> acknowledge that loosely coupled evolution allows participants to more broadly\n> explore the design space, without the constraints of \"it isn't a thing until N\n> of us start to do it\".\n>\n> Historically, BOLTs have also had a rather monolithic structure. We've used\n> the same 11 or so documents for the past few years with the size of the\n> documents swelling over time with new exceptions, features, requirements,\n> etc. If you were hired to work on a new codebase and saw that everything is\n> defined in 11 \"functions\" that have been growing linearly over time, you'd\n> probably declare the codebase as being unmaintainable. By having distinct\n> documents for proposals/standards, bLIPs (author documents really), each new\n> standard/proposal is able to be more effectively explained, motivated, versionsed,\n> etc.\n>\n> -- Laolu\n>\n>\n> On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>>\n>> Hey everyone,\n>>\n>> just for reference when I was new here (and did not understand the processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>>\n>> I wonder what exactly has changed in the reasoning by roasbeef which I will repeat here:\n>>\n>> > We already have the equiv of improvement proposals: BOLTs. Historically\n>>\n>> > new standardization documents are proposed initially as issues or PR's when\n>>\n>> > ultimately accepted. Why do we need another repo?\n>>\n>>\n>> As far as I can tell there was always some form of (invisible?) barrier to participate in the BOLTs but there are also new BOLTs being offered:\n>> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n>> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>> and topics to be included like:\n>> * dual funding\n>> * splicing\n>> * the examples given by Ryan\n>>\n>> I don't see how a new repo would reduce that barrier - Actually I think it would even create more confusion as I for example would not know where something belongs. That being said I think all the points that are addressed in Ryan's mail could very well be formalized into BOLTs but maybe we just need to rethink the current process of the BOLTs to make it more accessible for new ideas to find their way into the BOLTs? One thing that I can say from answering lightning-network questions on stackexchange is that it would certainly help if the BOLTs where referenced  on lightning.network web page and in the whitepaper as the place to be if one wants to learn about the Lightning Network\n>>\n>> with kind regards Rene\n>>\n>> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>>>\n>>> Hi all,\n>>>\n>>>\n>>> The recent thread around zero-conf channels [1] provides an opportunity to discuss how the BOLT process handles features and best practices that arise in the wild vs. originating within the process itself. Zero-conf channels are one of many LN innovations on the app layer that have struggled to make their way into the spec. John Carvalho and Bitrefill launched Turbo channels in April 2019 [2], Breez posted their solution to the mailing list for feedback in August 2020 [3], and we know at least ACINQ and Muun (amongst others) have their own implementations. In an ideal world there would be a descriptive design document that the app layer implementers had collaborated on over the years that the spec group could then pick up and merge into the BOLTs now that the feature is deemed spec-worthy.\n>>>\n>>>\n>>> Over the last couple of months, we have discussed the idea of adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various members of the community, and have received positive feedback from both app layer and protocol devs. This would not affect the existing BOLT process at all, but simply add a place for app layer best practices to be succinctly described and organized, especially those that require coordination. These features are being built outside of the BOLT process today anyways, so ideally a bLIP process would bring them into the fold instead of leaving them buried in old ML posts or not documented at all.\n>>>\n>>>\n>>> Some potential bLIP ideas that people have mentioned include: each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast payment metadata, p2p messaging formats, new pathfinding heuristics, remote node connection standards, etc.\n>>>\n>>>\n>>> If the community is interested in moving forward, we've started a branch [5] describing such a process. It's based on BIP-0002, so not trying to reinvent any wheels. It would be great to have developers from various implementations and from the broader app layer ecosystem volunteer to be listed as editors (basically the same role as in the BIPs).\n>>>\n>>>\n>>> Looking forward to hearing your thoughts!\n>>>\n>>>\n>>> Best,\n>>> Ryan\n>>>\n>>>\n>>> [1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>>>\n>>> [2] https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>>>\n>>> [3] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>>>\n>>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK = Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>>>\n>>> [5] https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>> --\n>> https://www.rene-pickhardt.de\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-07-01T09:19:09",
                "message_text_only": "Thanks for starting that discussion.\n\nIn my opinion, what we're really trying to address here are the two\nfollowing\npoints (at least from the point of view of someone who works on the spec and\nan implementation):\n\n- Implementers get frustrated when they've worked on something that they\nthink\nis useful and they can't get it into the BOLTs (the spec PR isn't reviewed,\nit progresses too slowly or there isn't enough agreement to merge it)\n- Implementers expect other implementers to specify the optional features\nthey\nship: we don't want to have to reverse-engineer a sub-protocol when users\nwant our implementation to provide support for feature XXX\n\nNote that these are two very different concerns.\n\nbLIPs/SPARKS/BIPs clearly address the second point, which is good.\nBut they don't address the first point at all, they instead work around it.\nTo be fair, I don't think we can completely address that first point:\nproperly\nreviewing spec proposals takes a lot of effort and accepting complex changes\nto the BOLTs shouldn't be done lightly.\n\nI am mostly in favor of this solution, but I want to highlight that it isn't\nonly rainbows and unicorns: it will add fragmentation to the network, it\nwill\nadd maintenance costs and backwards-compatibility issues, many bLIPs will be\nsub-optimal solutions to the problem they try to solve and some bLIPs will\nbe\nsimply insecure and may put users' funds at risk (L2 protocols are hard and\nhave\nsubtle issues that can be easily missed). On the other hand, it allows for\nreal\nworld experimentation and iteration, and it's easier to amend a bLIP than\nthe\nBOLTs.\n\nOn the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a fully\nbazaar\nstyle of evolution. Most of them will need:\n\n- to assign feature bit(s)\n- to insert new tlv fields in existing messages\n- to create new messages\n\nWe can't have collisions on any of these three things. bLIP XXX cannot use\nthe\nsame tlv types as bLIP YYY otherwise we're creating network\nincompatibilities.\nSo they really need to be centralized, and we need a process to assign these\nand ensure they don't collide. It's not a hard problem, but we need to be\nclear\nabout the process around those.\n\nRegarding the details of where they live, I don't have a strong opinion,\nbut I\nthink they must be easy to find and browse, and I think it's easier for\nreaders\nif they're inside the spec repository. We already have PRs that use a\ndedicated\n\"proposals\" folder (e.g. [1], [2]).\n\nCheers,\nBastien\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n[2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n\nLe jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a \u00e9crit :\n\n> BIPs are already the Bazaar style of evolution that simultaneously\n> allows flexibility and coordination/interoperability (since anyone can\n> create a BIP and they create an environment of discussion).\n>\n> BOLTs are essentially one big BIP in the sense that they started as a\n> place for discussion but are now more rigid. BOLTs must be followed\n> strictly to ensure a node is interoperable with the network. And BOLTs\n> should be rigid, as rigid as any widely used BIP like 32 for example.\n> Even though BOLTs were flexible when being drafted their purpose has\n> changed from descriptive to prescriptive.\n> Any alternatives, or optional features should be extracted out of\n> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n> required flags set, messages sent, or alterations made to signal that\n> the BIP's feature is enabled.\n>\n> A BOLT may at some point organically change to reference a BIP. For\n> example if a BIP was drafted as an optional feature but then becomes\n> more widespread and then turns out to be crucial for the proper\n> operation of the network then a BOLT can be changed to just reference\n> the BIP as mandatory. There isn't anything wrong with this.\n>\n> All of the above would work exactly the same if there was a bLIP\n> repository instead. I don't see the value in having both bLIPs and\n> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n> not restricted to exclude lightning, and never have been.\n>\n> I believe the reason this move to BIPs hasn't happened organically is\n> because many still perceive the BOLTs available for editing, so\n> changes continue to be made. If instead BOLTs were perceived as more\n> \"consensus critical\", not subject to change, and more people were\n> strongly encouraged to write specs for new lightning features\n> elsewhere (like the BIP repo) then you would see this issue of growing\n> BOLTs resolved.\n>\n> Cheers\n> Ariel Lorenzo-Luaces\n>\n> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> wrote:\n> >\n> > > That being said I think all the points that are addressed in Ryan's\n> mail\n> > > could very well be formalized into BOLTs but maybe we just need to\n> rethink\n> > > the current process of the BOLTs to make it more accessible for new\n> ideas\n> > > to find their way into the BOLTs?\n> >\n> > I think part of what bLIPs are trying to solve here is promoting more\n> loosely\n> > coupled evolution of the network. I think the BOLTs do a good job\n> currently of\n> > specifying what _base_ functionality is required for a routing node in a\n> > prescriptive manner (you must forward an HTLC like this, etc). However\n> there's\n> > a rather large gap in describing functionality that has emerged over\n> time due\n> > to progressive evolution, and aren't absolutely necessary, but enhance\n> > node/wallet operation.\n> >\n> > Examples of  include things like: path finding heuristics (BOLTs just\n> say you\n> > should get from Alice to Bob, but provides no recommendations w.r.t\n> _how_ to do\n> > so), fee bumping heuristics, breach retribution handling, channel\n> management,\n> > rebalancing, custom records usage (like the podcast index meta-data,\n> messaging,\n> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n> > optimization, initial channel boostrapping, etc.\n> >\n> > All these examples are effectively optional as they aren't required for\n> base\n> > node operation, but they've organically evolved over time as node\n> > implementations and wallet seek to solve UX and operational problems for\n> > their users. bLIPs can be a _descriptive_ (this is how things can be\n> done)\n> > home for these types of standards, while BOLTs can be reserved for\n> > _prescriptive_ measures (an HTLC looks like this, etc).\n> >\n> > The protocol as implemented today has a number of extensions (TLVs,\n> message\n> > types, feature bits, etc) that allow implementations to spin out their\n> own\n> > sub-protocols, many of which won't be considered absolutely necessary\n> for node\n> > operation. IMO we should embrace more of a \"bazaar\" style of evolution,\n> and\n> > acknowledge that loosely coupled evolution allows participants to more\n> broadly\n> > explore the design space, without the constraints of \"it isn't a thing\n> until N\n> > of us start to do it\".\n> >\n> > Historically, BOLTs have also had a rather monolithic structure. We've\n> used\n> > the same 11 or so documents for the past few years with the size of the\n> > documents swelling over time with new exceptions, features, requirements,\n> > etc. If you were hired to work on a new codebase and saw that everything\n> is\n> > defined in 11 \"functions\" that have been growing linearly over time,\n> you'd\n> > probably declare the codebase as being unmaintainable. By having distinct\n> > documents for proposals/standards, bLIPs (author documents really), each\n> new\n> > standard/proposal is able to be more effectively explained, motivated,\n> versionsed,\n> > etc.\n> >\n> > -- Laolu\n> >\n> >\n> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> Hey everyone,\n> >>\n> >> just for reference when I was new here (and did not understand the\n> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n> >>\n> >> I wonder what exactly has changed in the reasoning by roasbeef which I\n> will repeat here:\n> >>\n> >> > We already have the equiv of improvement proposals: BOLTs.\n> Historically\n> >>\n> >> > new standardization documents are proposed initially as issues or\n> PR's when\n> >>\n> >> > ultimately accepted. Why do we need another repo?\n> >>\n> >>\n> >> As far as I can tell there was always some form of (invisible?) barrier\n> to participate in the BOLTs but there are also new BOLTs being offered:\n> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> >> and topics to be included like:\n> >> * dual funding\n> >> * splicing\n> >> * the examples given by Ryan\n> >>\n> >> I don't see how a new repo would reduce that barrier - Actually I think\n> it would even create more confusion as I for example would not know where\n> something belongs. That being said I think all the points that are\n> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n> we just need to rethink the current process of the BOLTs to make it more\n> accessible for new ideas to find their way into the BOLTs? One thing that I\n> can say from answering lightning-network questions on stackexchange is that\n> it would certainly help if the BOLTs where referenced  on lightning.network\n> web page and in the whitepaper as the place to be if one wants to learn\n> about the Lightning Network\n> >>\n> >> with kind regards Rene\n> >>\n> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>>\n> >>> Hi all,\n> >>>\n> >>>\n> >>> The recent thread around zero-conf channels [1] provides an\n> opportunity to discuss how the BOLT process handles features and best\n> practices that arise in the wild vs. originating within the process itself.\n> Zero-conf channels are one of many LN innovations on the app layer that\n> have struggled to make their way into the spec. John Carvalho and Bitrefill\n> launched Turbo channels in April 2019 [2], Breez posted their solution to\n> the mailing list for feedback in August 2020 [3], and we know at least\n> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n> world there would be a descriptive design document that the app layer\n> implementers had collaborated on over the years that the spec group could\n> then pick up and merge into the BOLTs now that the feature is deemed\n> spec-worthy.\n> >>>\n> >>>\n> >>> Over the last couple of months, we have discussed the idea of adding a\n> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n> members of the community, and have received positive feedback from both app\n> layer and protocol devs. This would not affect the existing BOLT process at\n> all, but simply add a place for app layer best practices to be succinctly\n> described and organized, especially those that require coordination. These\n> features are being built outside of the BOLT process today anyways, so\n> ideally a bLIP process would bring them into the fold instead of leaving\n> them buried in old ML posts or not documented at all.\n> >>>\n> >>>\n> >>> Some potential bLIP ideas that people have mentioned include: each\n> lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n> node connection standards, etc.\n> >>>\n> >>>\n> >>> If the community is interested in moving forward, we've started a\n> branch [5] describing such a process. It's based on BIP-0002, so not trying\n> to reinvent any wheels. It would be great to have developers from various\n> implementations and from the broader app layer ecosystem volunteer to be\n> listed as editors (basically the same role as in the BIPs).\n> >>>\n> >>>\n> >>> Looking forward to hearing your thoughts!\n> >>>\n> >>>\n> >>> Best,\n> >>> Ryan\n> >>>\n> >>>\n> >>> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n> >>>\n> >>> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n> >>>\n> >>> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n> >>>\n> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n> >>>\n> >>> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n> >>>\n> >>> _______________________________________________\n> >>> Lightning-dev mailing list\n> >>> Lightning-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>\n> >>\n> >>\n> >> --\n> >> https://www.rene-pickhardt.de\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210701/db735010/attachment-0001.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-07-01T20:43:13",
                "message_text_only": "> But they don't address the first point at all, they instead work around\n> it.  To be fair, I don't think we can completely address that first point:\n> properly reviewing spec proposals takes a lot of effort and accepting\n> complex changes to the BOLTs shouldn't be done lightly.\n\nI think this is a fair characterization that I agree with. I also agree that\nthere isn't really a way to fundamentally address it. The issue of scarce\nreview resources is something just about any large open source project needs\nto deal with: everyone wants to make a PR, but no one wants to review the\nPRs of others, unless it scratches some tangential itch they may have. IMO\nit's also the case that the problem/solution space of LN is so large, that\nit's hard to expect every developer to review each new proposal that comes\nin, as they themselves have their own set of priorities (product,\nbusinesses, protocol, personal, etc).\n\nIn the end though, I think when there've been critical items that affect all\nimplementations and/or the existence of the protocol itself, developers\ntypically band together to commit resources to help a proposal move forward.\nOne upcoming example of this will be the \"base\" taproot channel type (the\ndesign space is pretty large in that it even permits a new type of symmetric\nstate revocation-based channel).\n\n>  it will add fragmentation to the network, it will add maintenance costs\n>  and backwards-compatibility issues\n\nWill it actually add any more fragmentation that already exists? Due to all\nthe extensibility we've added in the protocol, it's already possible for any\nimplementation to start to work on their own sub-protocols. This just gives\nthem a new venue to at least _describe_ what they're using. As usual, it's\nup to other implementations if they want to adopt it or not, or advise\nagainst its use.\n\n>  many bLIPs will be sub-optimal solutions to the problem they try to solve\n>  and some bLIPs will be simply insecure and may put users' funds at risk\n>  (L2 protocols are hard and have subtle issues that can be easily missed)\n\nThis may be the case, but I guess at times it's hard to know if something is\nobjectively sub-optimal without further exploration of the design space,\nwhich usually means either more people involved, or more time examining the\nproblem. Ultimately, different wallets/implementations may also be willing\nto make different usability/security trade-offs. One example here is zero\nconf channels: they assume a greater degree of trust with the party you're\n_accepting_ the channel from, as if you receive funds over the channel, they\ncan be double spent away. However it's undeniable that they improve the UX\nby reducing the amount of time a user needs to wait around before they can\nactually jump in and use LN.\n\nIn the end though, there's no grand global committee that prevents people\nfrom deploying software they think is interesting or useful. In the long\nrun, I guess one simply needs to hope that bad ideas die out, or speak out\nagainst them to the public. As LN sits a layer above the base protocol,\nwidespread global consensus isn't really required to make certain classes of\nchanges, and you can't stop people from experimenting on their own.\n\n> We can't have collisions on any of these three things.\n\nYeah, collisions are def possible. IMO, this is where the interplay with\nBOLTs comes in: BOLTs are the global feature bit/tlv/message namespace.  A\nbLIP might come with the amendment of BOLT 9 to define feature bits they\nused. Of course, this should be done on a best effort basis, as even if you\nassign a bit for your idea, someone can just go ahead and deploy something\nelse w/ that same bit, and they may never really intersect depending on the\nnature or how widespread the new feature is.\n\nIt's also likely the case that already implementations, or typically forks\nof implementations are already using \"undocumented\" TLVs or feature bits in\nthe wild today. I don't know exactly which TLV type things like applications\nthat tunnel messages over the network use, but afaik so far there haven't\nbeen any disastrous collisions in the wild.\n\n-- Laolu\n\nOn Thu, Jul 1, 2021 at 2:19 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Thanks for starting that discussion.\n>\n> In my opinion, what we're really trying to address here are the two\n> following\n> points (at least from the point of view of someone who works on the spec\n> and\n> an implementation):\n>\n> - Implementers get frustrated when they've worked on something that they\n> think\n> is useful and they can't get it into the BOLTs (the spec PR isn't reviewed,\n> it progresses too slowly or there isn't enough agreement to merge it)\n> - Implementers expect other implementers to specify the optional features\n> they\n> ship: we don't want to have to reverse-engineer a sub-protocol when users\n> want our implementation to provide support for feature XXX\n>\n> Note that these are two very different concerns.\n>\n> bLIPs/SPARKS/BIPs clearly address the second point, which is good.\n> But they don't address the first point at all, they instead work around it.\n> To be fair, I don't think we can completely address that first point:\n> properly\n> reviewing spec proposals takes a lot of effort and accepting complex\n> changes\n> to the BOLTs shouldn't be done lightly.\n>\n> I am mostly in favor of this solution, but I want to highlight that it\n> isn't\n> only rainbows and unicorns: it will add fragmentation to the network, it\n> will\n> add maintenance costs and backwards-compatibility issues, many bLIPs will\n> be\n> sub-optimal solutions to the problem they try to solve and some bLIPs will\n> be\n> simply insecure and may put users' funds at risk (L2 protocols are hard\n> and have\n> subtle issues that can be easily missed). On the other hand, it allows for\n> real\n> world experimentation and iteration, and it's easier to amend a bLIP than\n> the\n> BOLTs.\n>\n> On the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a fully\n> bazaar\n> style of evolution. Most of them will need:\n>\n> - to assign feature bit(s)\n> - to insert new tlv fields in existing messages\n> - to create new messages\n>\n> We can't have collisions on any of these three things. bLIP XXX cannot use\n> the\n> same tlv types as bLIP YYY otherwise we're creating network\n> incompatibilities.\n> So they really need to be centralized, and we need a process to assign\n> these\n> and ensure they don't collide. It's not a hard problem, but we need to be\n> clear\n> about the process around those.\n>\n> Regarding the details of where they live, I don't have a strong opinion,\n> but I\n> think they must be easy to find and browse, and I think it's easier for\n> readers\n> if they're inside the spec repository. We already have PRs that use a\n> dedicated\n> \"proposals\" folder (e.g. [1], [2]).\n>\n> Cheers,\n> Bastien\n>\n> [1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n> [2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n>\n> Le jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a\n> \u00e9crit :\n>\n>> BIPs are already the Bazaar style of evolution that simultaneously\n>> allows flexibility and coordination/interoperability (since anyone can\n>> create a BIP and they create an environment of discussion).\n>>\n>> BOLTs are essentially one big BIP in the sense that they started as a\n>> place for discussion but are now more rigid. BOLTs must be followed\n>> strictly to ensure a node is interoperable with the network. And BOLTs\n>> should be rigid, as rigid as any widely used BIP like 32 for example.\n>> Even though BOLTs were flexible when being drafted their purpose has\n>> changed from descriptive to prescriptive.\n>> Any alternatives, or optional features should be extracted out of\n>> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n>> required flags set, messages sent, or alterations made to signal that\n>> the BIP's feature is enabled.\n>>\n>> A BOLT may at some point organically change to reference a BIP. For\n>> example if a BIP was drafted as an optional feature but then becomes\n>> more widespread and then turns out to be crucial for the proper\n>> operation of the network then a BOLT can be changed to just reference\n>> the BIP as mandatory. There isn't anything wrong with this.\n>>\n>> All of the above would work exactly the same if there was a bLIP\n>> repository instead. I don't see the value in having both bLIPs and\n>> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n>> not restricted to exclude lightning, and never have been.\n>>\n>> I believe the reason this move to BIPs hasn't happened organically is\n>> because many still perceive the BOLTs available for editing, so\n>> changes continue to be made. If instead BOLTs were perceived as more\n>> \"consensus critical\", not subject to change, and more people were\n>> strongly encouraged to write specs for new lightning features\n>> elsewhere (like the BIP repo) then you would see this issue of growing\n>> BOLTs resolved.\n>>\n>> Cheers\n>> Ariel Lorenzo-Luaces\n>>\n>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n>> wrote:\n>> >\n>> > > That being said I think all the points that are addressed in Ryan's\n>> mail\n>> > > could very well be formalized into BOLTs but maybe we just need to\n>> rethink\n>> > > the current process of the BOLTs to make it more accessible for new\n>> ideas\n>> > > to find their way into the BOLTs?\n>> >\n>> > I think part of what bLIPs are trying to solve here is promoting more\n>> loosely\n>> > coupled evolution of the network. I think the BOLTs do a good job\n>> currently of\n>> > specifying what _base_ functionality is required for a routing node in a\n>> > prescriptive manner (you must forward an HTLC like this, etc). However\n>> there's\n>> > a rather large gap in describing functionality that has emerged over\n>> time due\n>> > to progressive evolution, and aren't absolutely necessary, but enhance\n>> > node/wallet operation.\n>> >\n>> > Examples of  include things like: path finding heuristics (BOLTs just\n>> say you\n>> > should get from Alice to Bob, but provides no recommendations w.r.t\n>> _how_ to do\n>> > so), fee bumping heuristics, breach retribution handling, channel\n>> management,\n>> > rebalancing, custom records usage (like the podcast index meta-data,\n>> messaging,\n>> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n>> > optimization, initial channel boostrapping, etc.\n>> >\n>> > All these examples are effectively optional as they aren't required for\n>> base\n>> > node operation, but they've organically evolved over time as node\n>> > implementations and wallet seek to solve UX and operational problems for\n>> > their users. bLIPs can be a _descriptive_ (this is how things can be\n>> done)\n>> > home for these types of standards, while BOLTs can be reserved for\n>> > _prescriptive_ measures (an HTLC looks like this, etc).\n>> >\n>> > The protocol as implemented today has a number of extensions (TLVs,\n>> message\n>> > types, feature bits, etc) that allow implementations to spin out their\n>> own\n>> > sub-protocols, many of which won't be considered absolutely necessary\n>> for node\n>> > operation. IMO we should embrace more of a \"bazaar\" style of evolution,\n>> and\n>> > acknowledge that loosely coupled evolution allows participants to more\n>> broadly\n>> > explore the design space, without the constraints of \"it isn't a thing\n>> until N\n>> > of us start to do it\".\n>> >\n>> > Historically, BOLTs have also had a rather monolithic structure. We've\n>> used\n>> > the same 11 or so documents for the past few years with the size of the\n>> > documents swelling over time with new exceptions, features,\n>> requirements,\n>> > etc. If you were hired to work on a new codebase and saw that\n>> everything is\n>> > defined in 11 \"functions\" that have been growing linearly over time,\n>> you'd\n>> > probably declare the codebase as being unmaintainable. By having\n>> distinct\n>> > documents for proposals/standards, bLIPs (author documents really),\n>> each new\n>> > standard/proposal is able to be more effectively explained, motivated,\n>> versionsed,\n>> > etc.\n>> >\n>> > -- Laolu\n>> >\n>> >\n>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n>> lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>\n>> >> Hey everyone,\n>> >>\n>> >> just for reference when I was new here (and did not understand the\n>> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>> >>\n>> >> I wonder what exactly has changed in the reasoning by roasbeef which I\n>> will repeat here:\n>> >>\n>> >> > We already have the equiv of improvement proposals: BOLTs.\n>> Historically\n>> >>\n>> >> > new standardization documents are proposed initially as issues or\n>> PR's when\n>> >>\n>> >> > ultimately accepted. Why do we need another repo?\n>> >>\n>> >>\n>> >> As far as I can tell there was always some form of (invisible?)\n>> barrier to participate in the BOLTs but there are also new BOLTs being\n>> offered:\n>> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n>> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>> >> and topics to be included like:\n>> >> * dual funding\n>> >> * splicing\n>> >> * the examples given by Ryan\n>> >>\n>> >> I don't see how a new repo would reduce that barrier - Actually I\n>> think it would even create more confusion as I for example would not know\n>> where something belongs. That being said I think all the points that are\n>> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n>> we just need to rethink the current process of the BOLTs to make it more\n>> accessible for new ideas to find their way into the BOLTs? One thing that I\n>> can say from answering lightning-network questions on stackexchange is that\n>> it would certainly help if the BOLTs where referenced  on lightning.network\n>> web page and in the whitepaper as the place to be if one wants to learn\n>> about the Lightning Network\n>> >>\n>> >> with kind regards Rene\n>> >>\n>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n>> lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>>\n>> >>> Hi all,\n>> >>>\n>> >>>\n>> >>> The recent thread around zero-conf channels [1] provides an\n>> opportunity to discuss how the BOLT process handles features and best\n>> practices that arise in the wild vs. originating within the process itself.\n>> Zero-conf channels are one of many LN innovations on the app layer that\n>> have struggled to make their way into the spec. John Carvalho and Bitrefill\n>> launched Turbo channels in April 2019 [2], Breez posted their solution to\n>> the mailing list for feedback in August 2020 [3], and we know at least\n>> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n>> world there would be a descriptive design document that the app layer\n>> implementers had collaborated on over the years that the spec group could\n>> then pick up and merge into the BOLTs now that the feature is deemed\n>> spec-worthy.\n>> >>>\n>> >>>\n>> >>> Over the last couple of months, we have discussed the idea of adding\n>> a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n>> members of the community, and have received positive feedback from both app\n>> layer and protocol devs. This would not affect the existing BOLT process at\n>> all, but simply add a place for app layer best practices to be succinctly\n>> described and organized, especially those that require coordination. These\n>> features are being built outside of the BOLT process today anyways, so\n>> ideally a bLIP process would bring them into the fold instead of leaving\n>> them buried in old ML posts or not documented at all.\n>> >>>\n>> >>>\n>> >>> Some potential bLIP ideas that people have mentioned include: each\n>> lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n>> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n>> node connection standards, etc.\n>> >>>\n>> >>>\n>> >>> If the community is interested in moving forward, we've started a\n>> branch [5] describing such a process. It's based on BIP-0002, so not trying\n>> to reinvent any wheels. It would be great to have developers from various\n>> implementations and from the broader app layer ecosystem volunteer to be\n>> listed as editors (basically the same role as in the BIPs).\n>> >>>\n>> >>>\n>> >>> Looking forward to hearing your thoughts!\n>> >>>\n>> >>>\n>> >>> Best,\n>> >>> Ryan\n>> >>>\n>> >>>\n>> >>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>> >>>\n>> >>> [2]\n>> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>> >>>\n>> >>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>> >>>\n>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n>> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>> >>>\n>> >>> [5]\n>> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>> >>>\n>> >>> _______________________________________________\n>> >>> Lightning-dev mailing list\n>> >>> Lightning-dev at lists.linuxfoundation.org\n>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>\n>> >>\n>> >>\n>> >> --\n>> >> https://www.rene-pickhardt.de\n>> >> _______________________________________________\n>> >> Lightning-dev mailing list\n>> >> Lightning-dev at lists.linuxfoundation.org\n>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210701/21d65d9a/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-07-02T08:00:32",
                "message_text_only": ">\n> Will it actually add any more fragmentation that already exists? Due to all\n> the extensibility we've added in the protocol, it's already possible for\n> any\n> implementation to start to work on their own sub-protocols. This just gives\n> them a new venue to at least _describe_ what they're using.\n>\n\nIt's only my 2 cents, but I'm afraid it will indeed add more fragmentation,\nbecause\nthe fact that there exists a bLIP for feature XXX will likely act as a\ngreen light to\ndeploy it faster instead of spending more time talking about it with the\ncommunity\nand thinking about potential issues, forward-compatibility, etc.\n\nBut I agree with you that it also gives more freedom to experiment in the\nreal world,\nwhich helps find issues and correct them, paving the way for better\nfeatures for\nend users.\n\nIt's also likely the case that already implementations, or typically forks\n> of implementations are already using \"undocumented\" TLVs or feature bits in\n> the wild today.\n>\n\nBut today we're usually very careful when we do that, and use numbers in\nhigh ranges\nfor these use-cases. In our case for example we use message type 35007 for\nour\nswap-in and we expect that to change once standardized, so we did extra\nwork to\nensure we wouldn't paint ourselves into a corner when switching to a\nstandard version.\n\nI think that if we have a centralized bLIP repo, we can take this\nopportunity to safely\nassign \"final\" values for types and feature bits that are used by each\nbLIP, and stronger\nguarantees that they will not conflict with another bLIP or BOLT. Of course\nthat doesn't\nstop anyone from deploying a conflict, but their use of the same bits won't\nbe documented\nso it shouldn't be widely deployed, and browsing the BOLTs and bLIPs should\nlet anyone\nsee what the \"correct\" meaning of those bits should be.\n\nCheers,\nBastien\n\n\nLe jeu. 1 juil. 2021 \u00e0 22:43, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n\u00e9crit :\n\n> > But they don't address the first point at all, they instead work around\n> > it.  To be fair, I don't think we can completely address that first\n> point:\n> > properly reviewing spec proposals takes a lot of effort and accepting\n> > complex changes to the BOLTs shouldn't be done lightly.\n>\n> I think this is a fair characterization that I agree with. I also agree\n> that\n> there isn't really a way to fundamentally address it. The issue of scarce\n> review resources is something just about any large open source project\n> needs\n> to deal with: everyone wants to make a PR, but no one wants to review the\n> PRs of others, unless it scratches some tangential itch they may have. IMO\n> it's also the case that the problem/solution space of LN is so large, that\n> it's hard to expect every developer to review each new proposal that comes\n> in, as they themselves have their own set of priorities (product,\n> businesses, protocol, personal, etc).\n>\n> In the end though, I think when there've been critical items that affect\n> all\n> implementations and/or the existence of the protocol itself, developers\n> typically band together to commit resources to help a proposal move\n> forward.\n> One upcoming example of this will be the \"base\" taproot channel type (the\n> design space is pretty large in that it even permits a new type of\n> symmetric\n> state revocation-based channel).\n>\n> >  it will add fragmentation to the network, it will add maintenance costs\n> >  and backwards-compatibility issues\n>\n> Will it actually add any more fragmentation that already exists? Due to all\n> the extensibility we've added in the protocol, it's already possible for\n> any\n> implementation to start to work on their own sub-protocols. This just gives\n> them a new venue to at least _describe_ what they're using. As usual, it's\n> up to other implementations if they want to adopt it or not, or advise\n> against its use.\n>\n> >  many bLIPs will be sub-optimal solutions to the problem they try to\n> solve\n> >  and some bLIPs will be simply insecure and may put users' funds at risk\n> >  (L2 protocols are hard and have subtle issues that can be easily missed)\n>\n> This may be the case, but I guess at times it's hard to know if something\n> is\n> objectively sub-optimal without further exploration of the design space,\n> which usually means either more people involved, or more time examining the\n> problem. Ultimately, different wallets/implementations may also be willing\n> to make different usability/security trade-offs. One example here is zero\n> conf channels: they assume a greater degree of trust with the party you're\n> _accepting_ the channel from, as if you receive funds over the channel,\n> they\n> can be double spent away. However it's undeniable that they improve the UX\n> by reducing the amount of time a user needs to wait around before they can\n> actually jump in and use LN.\n>\n> In the end though, there's no grand global committee that prevents people\n> from deploying software they think is interesting or useful. In the long\n> run, I guess one simply needs to hope that bad ideas die out, or speak out\n> against them to the public. As LN sits a layer above the base protocol,\n> widespread global consensus isn't really required to make certain classes\n> of\n> changes, and you can't stop people from experimenting on their own.\n>\n> > We can't have collisions on any of these three things.\n>\n> Yeah, collisions are def possible. IMO, this is where the interplay with\n> BOLTs comes in: BOLTs are the global feature bit/tlv/message namespace.  A\n> bLIP might come with the amendment of BOLT 9 to define feature bits they\n> used. Of course, this should be done on a best effort basis, as even if you\n> assign a bit for your idea, someone can just go ahead and deploy something\n> else w/ that same bit, and they may never really intersect depending on the\n> nature or how widespread the new feature is.\n>\n> It's also likely the case that already implementations, or typically forks\n> of implementations are already using \"undocumented\" TLVs or feature bits in\n> the wild today. I don't know exactly which TLV type things like\n> applications\n> that tunnel messages over the network use, but afaik so far there haven't\n> been any disastrous collisions in the wild.\n>\n> -- Laolu\n>\n> On Thu, Jul 1, 2021 at 2:19 AM Bastien TEINTURIER <bastien at acinq.fr>\n> wrote:\n>\n>> Thanks for starting that discussion.\n>>\n>> In my opinion, what we're really trying to address here are the two\n>> following\n>> points (at least from the point of view of someone who works on the spec\n>> and\n>> an implementation):\n>>\n>> - Implementers get frustrated when they've worked on something that they\n>> think\n>> is useful and they can't get it into the BOLTs (the spec PR isn't\n>> reviewed,\n>> it progresses too slowly or there isn't enough agreement to merge it)\n>> - Implementers expect other implementers to specify the optional features\n>> they\n>> ship: we don't want to have to reverse-engineer a sub-protocol when users\n>> want our implementation to provide support for feature XXX\n>>\n>> Note that these are two very different concerns.\n>>\n>> bLIPs/SPARKS/BIPs clearly address the second point, which is good.\n>> But they don't address the first point at all, they instead work around\n>> it.\n>> To be fair, I don't think we can completely address that first point:\n>> properly\n>> reviewing spec proposals takes a lot of effort and accepting complex\n>> changes\n>> to the BOLTs shouldn't be done lightly.\n>>\n>> I am mostly in favor of this solution, but I want to highlight that it\n>> isn't\n>> only rainbows and unicorns: it will add fragmentation to the network, it\n>> will\n>> add maintenance costs and backwards-compatibility issues, many bLIPs will\n>> be\n>> sub-optimal solutions to the problem they try to solve and some bLIPs\n>> will be\n>> simply insecure and may put users' funds at risk (L2 protocols are hard\n>> and have\n>> subtle issues that can be easily missed). On the other hand, it allows\n>> for real\n>> world experimentation and iteration, and it's easier to amend a bLIP than\n>> the\n>> BOLTs.\n>>\n>> On the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a fully\n>> bazaar\n>> style of evolution. Most of them will need:\n>>\n>> - to assign feature bit(s)\n>> - to insert new tlv fields in existing messages\n>> - to create new messages\n>>\n>> We can't have collisions on any of these three things. bLIP XXX cannot\n>> use the\n>> same tlv types as bLIP YYY otherwise we're creating network\n>> incompatibilities.\n>> So they really need to be centralized, and we need a process to assign\n>> these\n>> and ensure they don't collide. It's not a hard problem, but we need to be\n>> clear\n>> about the process around those.\n>>\n>> Regarding the details of where they live, I don't have a strong opinion,\n>> but I\n>> think they must be easy to find and browse, and I think it's easier for\n>> readers\n>> if they're inside the spec repository. We already have PRs that use a\n>> dedicated\n>> \"proposals\" folder (e.g. [1], [2]).\n>>\n>> Cheers,\n>> Bastien\n>>\n>> [1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n>> [2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n>>\n>> Le jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a\n>> \u00e9crit :\n>>\n>>> BIPs are already the Bazaar style of evolution that simultaneously\n>>> allows flexibility and coordination/interoperability (since anyone can\n>>> create a BIP and they create an environment of discussion).\n>>>\n>>> BOLTs are essentially one big BIP in the sense that they started as a\n>>> place for discussion but are now more rigid. BOLTs must be followed\n>>> strictly to ensure a node is interoperable with the network. And BOLTs\n>>> should be rigid, as rigid as any widely used BIP like 32 for example.\n>>> Even though BOLTs were flexible when being drafted their purpose has\n>>> changed from descriptive to prescriptive.\n>>> Any alternatives, or optional features should be extracted out of\n>>> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n>>> required flags set, messages sent, or alterations made to signal that\n>>> the BIP's feature is enabled.\n>>>\n>>> A BOLT may at some point organically change to reference a BIP. For\n>>> example if a BIP was drafted as an optional feature but then becomes\n>>> more widespread and then turns out to be crucial for the proper\n>>> operation of the network then a BOLT can be changed to just reference\n>>> the BIP as mandatory. There isn't anything wrong with this.\n>>>\n>>> All of the above would work exactly the same if there was a bLIP\n>>> repository instead. I don't see the value in having both bLIPs and\n>>> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n>>> not restricted to exclude lightning, and never have been.\n>>>\n>>> I believe the reason this move to BIPs hasn't happened organically is\n>>> because many still perceive the BOLTs available for editing, so\n>>> changes continue to be made. If instead BOLTs were perceived as more\n>>> \"consensus critical\", not subject to change, and more people were\n>>> strongly encouraged to write specs for new lightning features\n>>> elsewhere (like the BIP repo) then you would see this issue of growing\n>>> BOLTs resolved.\n>>>\n>>> Cheers\n>>> Ariel Lorenzo-Luaces\n>>>\n>>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n>>> wrote:\n>>> >\n>>> > > That being said I think all the points that are addressed in Ryan's\n>>> mail\n>>> > > could very well be formalized into BOLTs but maybe we just need to\n>>> rethink\n>>> > > the current process of the BOLTs to make it more accessible for new\n>>> ideas\n>>> > > to find their way into the BOLTs?\n>>> >\n>>> > I think part of what bLIPs are trying to solve here is promoting more\n>>> loosely\n>>> > coupled evolution of the network. I think the BOLTs do a good job\n>>> currently of\n>>> > specifying what _base_ functionality is required for a routing node in\n>>> a\n>>> > prescriptive manner (you must forward an HTLC like this, etc). However\n>>> there's\n>>> > a rather large gap in describing functionality that has emerged over\n>>> time due\n>>> > to progressive evolution, and aren't absolutely necessary, but enhance\n>>> > node/wallet operation.\n>>> >\n>>> > Examples of  include things like: path finding heuristics (BOLTs just\n>>> say you\n>>> > should get from Alice to Bob, but provides no recommendations w.r.t\n>>> _how_ to do\n>>> > so), fee bumping heuristics, breach retribution handling, channel\n>>> management,\n>>> > rebalancing, custom records usage (like the podcast index meta-data,\n>>> messaging,\n>>> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n>>> > optimization, initial channel boostrapping, etc.\n>>> >\n>>> > All these examples are effectively optional as they aren't required\n>>> for base\n>>> > node operation, but they've organically evolved over time as node\n>>> > implementations and wallet seek to solve UX and operational problems\n>>> for\n>>> > their users. bLIPs can be a _descriptive_ (this is how things can be\n>>> done)\n>>> > home for these types of standards, while BOLTs can be reserved for\n>>> > _prescriptive_ measures (an HTLC looks like this, etc).\n>>> >\n>>> > The protocol as implemented today has a number of extensions (TLVs,\n>>> message\n>>> > types, feature bits, etc) that allow implementations to spin out their\n>>> own\n>>> > sub-protocols, many of which won't be considered absolutely necessary\n>>> for node\n>>> > operation. IMO we should embrace more of a \"bazaar\" style of\n>>> evolution, and\n>>> > acknowledge that loosely coupled evolution allows participants to more\n>>> broadly\n>>> > explore the design space, without the constraints of \"it isn't a thing\n>>> until N\n>>> > of us start to do it\".\n>>> >\n>>> > Historically, BOLTs have also had a rather monolithic structure. We've\n>>> used\n>>> > the same 11 or so documents for the past few years with the size of the\n>>> > documents swelling over time with new exceptions, features,\n>>> requirements,\n>>> > etc. If you were hired to work on a new codebase and saw that\n>>> everything is\n>>> > defined in 11 \"functions\" that have been growing linearly over time,\n>>> you'd\n>>> > probably declare the codebase as being unmaintainable. By having\n>>> distinct\n>>> > documents for proposals/standards, bLIPs (author documents really),\n>>> each new\n>>> > standard/proposal is able to be more effectively explained, motivated,\n>>> versionsed,\n>>> > etc.\n>>> >\n>>> > -- Laolu\n>>> >\n>>> >\n>>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n>>> lightning-dev at lists.linuxfoundation.org> wrote:\n>>> >>\n>>> >> Hey everyone,\n>>> >>\n>>> >> just for reference when I was new here (and did not understand the\n>>> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>>> >>\n>>> >> I wonder what exactly has changed in the reasoning by roasbeef which\n>>> I will repeat here:\n>>> >>\n>>> >> > We already have the equiv of improvement proposals: BOLTs.\n>>> Historically\n>>> >>\n>>> >> > new standardization documents are proposed initially as issues or\n>>> PR's when\n>>> >>\n>>> >> > ultimately accepted. Why do we need another repo?\n>>> >>\n>>> >>\n>>> >> As far as I can tell there was always some form of (invisible?)\n>>> barrier to participate in the BOLTs but there are also new BOLTs being\n>>> offered:\n>>> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n>>> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>>> >> and topics to be included like:\n>>> >> * dual funding\n>>> >> * splicing\n>>> >> * the examples given by Ryan\n>>> >>\n>>> >> I don't see how a new repo would reduce that barrier - Actually I\n>>> think it would even create more confusion as I for example would not know\n>>> where something belongs. That being said I think all the points that are\n>>> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n>>> we just need to rethink the current process of the BOLTs to make it more\n>>> accessible for new ideas to find their way into the BOLTs? One thing that I\n>>> can say from answering lightning-network questions on stackexchange is that\n>>> it would certainly help if the BOLTs where referenced  on lightning.network\n>>> web page and in the whitepaper as the place to be if one wants to learn\n>>> about the Lightning Network\n>>> >>\n>>> >> with kind regards Rene\n>>> >>\n>>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n>>> lightning-dev at lists.linuxfoundation.org> wrote:\n>>> >>>\n>>> >>> Hi all,\n>>> >>>\n>>> >>>\n>>> >>> The recent thread around zero-conf channels [1] provides an\n>>> opportunity to discuss how the BOLT process handles features and best\n>>> practices that arise in the wild vs. originating within the process itself.\n>>> Zero-conf channels are one of many LN innovations on the app layer that\n>>> have struggled to make their way into the spec. John Carvalho and Bitrefill\n>>> launched Turbo channels in April 2019 [2], Breez posted their solution to\n>>> the mailing list for feedback in August 2020 [3], and we know at least\n>>> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n>>> world there would be a descriptive design document that the app layer\n>>> implementers had collaborated on over the years that the spec group could\n>>> then pick up and merge into the BOLTs now that the feature is deemed\n>>> spec-worthy.\n>>> >>>\n>>> >>>\n>>> >>> Over the last couple of months, we have discussed the idea of adding\n>>> a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n>>> members of the community, and have received positive feedback from both app\n>>> layer and protocol devs. This would not affect the existing BOLT process at\n>>> all, but simply add a place for app layer best practices to be succinctly\n>>> described and organized, especially those that require coordination. These\n>>> features are being built outside of the BOLT process today anyways, so\n>>> ideally a bLIP process would bring them into the fold instead of leaving\n>>> them buried in old ML posts or not documented at all.\n>>> >>>\n>>> >>>\n>>> >>> Some potential bLIP ideas that people have mentioned include: each\n>>> lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n>>> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n>>> node connection standards, etc.\n>>> >>>\n>>> >>>\n>>> >>> If the community is interested in moving forward, we've started a\n>>> branch [5] describing such a process. It's based on BIP-0002, so not trying\n>>> to reinvent any wheels. It would be great to have developers from various\n>>> implementations and from the broader app layer ecosystem volunteer to be\n>>> listed as editors (basically the same role as in the BIPs).\n>>> >>>\n>>> >>>\n>>> >>> Looking forward to hearing your thoughts!\n>>> >>>\n>>> >>>\n>>> >>> Best,\n>>> >>> Ryan\n>>> >>>\n>>> >>>\n>>> >>> [1]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>>> >>>\n>>> >>> [2]\n>>> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>>> >>>\n>>> >>> [3]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>>> >>>\n>>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n>>> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>>> >>>\n>>> >>> [5]\n>>> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>>> >>>\n>>> >>> _______________________________________________\n>>> >>> Lightning-dev mailing list\n>>> >>> Lightning-dev at lists.linuxfoundation.org\n>>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>> >>\n>>> >>\n>>> >>\n>>> >> --\n>>> >> https://www.rene-pickhardt.de\n>>> >> _______________________________________________\n>>> >> Lightning-dev mailing list\n>>> >> Lightning-dev at lists.linuxfoundation.org\n>>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>> >\n>>> > _______________________________________________\n>>> > Lightning-dev mailing list\n>>> > Lightning-dev at lists.linuxfoundation.org\n>>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210702/8b6fcefe/attachment-0001.html>"
            },
            {
                "author": "Michael Folkson",
                "date": "2021-07-02T08:48:20",
                "message_text_only": "> The other thing bLIPs do is do away with the whole \"human picks the number of documents\", and \"don't assign your own number, you must wait\".\n\nSo TL;DR BIPs and BOLTs sometimes require waiting for things (like\nreview and consensus) and there should be a new acronym and process\n(\"bLIPs\") to avoid us having to wait for things. I just think \"bLIPs\"\nadds confusion e.g. should something be a bLIP or a BOLT? Does a bLIP\neventually become a BOLT when it is mature enough? This tendency to\nfragment and introduce new acronyms and new processes should be\nresisted imo. If a new process is introduced every time there is a\ndisagreement or perceived friction it just erodes the value of\nexisting processes and means they all get bypassed. Strengthen and\nimprove existing processes and only introduce a new one as an absolute\nlast resort.\n\nOther than the minor frictions described above I don't see why \"bLIPs\"\ncan't just be draft BOLTs.\n\n> Adding a third BIP editor more involved with Lightning sounds like a good idea.\n\nOr alternatively if BOLTs were subsumed into BIPs I think Bastien\nwould be a great additional BIP editor to cover Lightning related BIPs\n:) I think BOLTs being subsumed into BIPs would be nice but I'm\npessimistic it will happen. Like legislation and regulation in the\nlegacy financial system alphabet soups only expand they never get\nsimplified. Let's at least resist alphabet soup expansion here.\n\nOn Fri, Jul 2, 2021 at 9:01 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>>\n>> Will it actually add any more fragmentation that already exists? Due to all\n>> the extensibility we've added in the protocol, it's already possible for any\n>> implementation to start to work on their own sub-protocols. This just gives\n>> them a new venue to at least _describe_ what they're using.\n>\n>\n> It's only my 2 cents, but I'm afraid it will indeed add more fragmentation, because\n> the fact that there exists a bLIP for feature XXX will likely act as a green light to\n> deploy it faster instead of spending more time talking about it with the community\n> and thinking about potential issues, forward-compatibility, etc.\n>\n> But I agree with you that it also gives more freedom to experiment in the real world,\n> which helps find issues and correct them, paving the way for better features for\n> end users.\n>\n>> It's also likely the case that already implementations, or typically forks\n>> of implementations are already using \"undocumented\" TLVs or feature bits in\n>> the wild today.\n>\n>\n> But today we're usually very careful when we do that, and use numbers in high ranges\n> for these use-cases. In our case for example we use message type 35007 for our\n> swap-in and we expect that to change once standardized, so we did extra work to\n> ensure we wouldn't paint ourselves into a corner when switching to a standard version.\n>\n> I think that if we have a centralized bLIP repo, we can take this opportunity to safely\n> assign \"final\" values for types and feature bits that are used by each bLIP, and stronger\n> guarantees that they will not conflict with another bLIP or BOLT. Of course that doesn't\n> stop anyone from deploying a conflict, but their use of the same bits won't be documented\n> so it shouldn't be widely deployed, and browsing the BOLTs and bLIPs should let anyone\n> see what the \"correct\" meaning of those bits should be.\n>\n> Cheers,\n> Bastien\n>\n>\n> Le jeu. 1 juil. 2021 \u00e0 22:43, Olaoluwa Osuntokun <laolu32 at gmail.com> a \u00e9crit :\n>>\n>> > But they don't address the first point at all, they instead work around\n>> > it.  To be fair, I don't think we can completely address that first point:\n>> > properly reviewing spec proposals takes a lot of effort and accepting\n>> > complex changes to the BOLTs shouldn't be done lightly.\n>>\n>> I think this is a fair characterization that I agree with. I also agree that\n>> there isn't really a way to fundamentally address it. The issue of scarce\n>> review resources is something just about any large open source project needs\n>> to deal with: everyone wants to make a PR, but no one wants to review the\n>> PRs of others, unless it scratches some tangential itch they may have. IMO\n>> it's also the case that the problem/solution space of LN is so large, that\n>> it's hard to expect every developer to review each new proposal that comes\n>> in, as they themselves have their own set of priorities (product,\n>> businesses, protocol, personal, etc).\n>>\n>> In the end though, I think when there've been critical items that affect all\n>> implementations and/or the existence of the protocol itself, developers\n>> typically band together to commit resources to help a proposal move forward.\n>> One upcoming example of this will be the \"base\" taproot channel type (the\n>> design space is pretty large in that it even permits a new type of symmetric\n>> state revocation-based channel).\n>>\n>> >  it will add fragmentation to the network, it will add maintenance costs\n>> >  and backwards-compatibility issues\n>>\n>> Will it actually add any more fragmentation that already exists? Due to all\n>> the extensibility we've added in the protocol, it's already possible for any\n>> implementation to start to work on their own sub-protocols. This just gives\n>> them a new venue to at least _describe_ what they're using. As usual, it's\n>> up to other implementations if they want to adopt it or not, or advise\n>> against its use.\n>>\n>> >  many bLIPs will be sub-optimal solutions to the problem they try to solve\n>> >  and some bLIPs will be simply insecure and may put users' funds at risk\n>> >  (L2 protocols are hard and have subtle issues that can be easily missed)\n>>\n>> This may be the case, but I guess at times it's hard to know if something is\n>> objectively sub-optimal without further exploration of the design space,\n>> which usually means either more people involved, or more time examining the\n>> problem. Ultimately, different wallets/implementations may also be willing\n>> to make different usability/security trade-offs. One example here is zero\n>> conf channels: they assume a greater degree of trust with the party you're\n>> _accepting_ the channel from, as if you receive funds over the channel, they\n>> can be double spent away. However it's undeniable that they improve the UX\n>> by reducing the amount of time a user needs to wait around before they can\n>> actually jump in and use LN.\n>>\n>> In the end though, there's no grand global committee that prevents people\n>> from deploying software they think is interesting or useful. In the long\n>> run, I guess one simply needs to hope that bad ideas die out, or speak out\n>> against them to the public. As LN sits a layer above the base protocol,\n>> widespread global consensus isn't really required to make certain classes of\n>> changes, and you can't stop people from experimenting on their own.\n>>\n>> > We can't have collisions on any of these three things.\n>>\n>> Yeah, collisions are def possible. IMO, this is where the interplay with\n>> BOLTs comes in: BOLTs are the global feature bit/tlv/message namespace.  A\n>> bLIP might come with the amendment of BOLT 9 to define feature bits they\n>> used. Of course, this should be done on a best effort basis, as even if you\n>> assign a bit for your idea, someone can just go ahead and deploy something\n>> else w/ that same bit, and they may never really intersect depending on the\n>> nature or how widespread the new feature is.\n>>\n>> It's also likely the case that already implementations, or typically forks\n>> of implementations are already using \"undocumented\" TLVs or feature bits in\n>> the wild today. I don't know exactly which TLV type things like applications\n>> that tunnel messages over the network use, but afaik so far there haven't\n>> been any disastrous collisions in the wild.\n>>\n>> -- Laolu\n>>\n>> On Thu, Jul 1, 2021 at 2:19 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>>>\n>>> Thanks for starting that discussion.\n>>>\n>>> In my opinion, what we're really trying to address here are the two following\n>>> points (at least from the point of view of someone who works on the spec and\n>>> an implementation):\n>>>\n>>> - Implementers get frustrated when they've worked on something that they think\n>>> is useful and they can't get it into the BOLTs (the spec PR isn't reviewed,\n>>> it progresses too slowly or there isn't enough agreement to merge it)\n>>> - Implementers expect other implementers to specify the optional features they\n>>> ship: we don't want to have to reverse-engineer a sub-protocol when users\n>>> want our implementation to provide support for feature XXX\n>>>\n>>> Note that these are two very different concerns.\n>>>\n>>> bLIPs/SPARKS/BIPs clearly address the second point, which is good.\n>>> But they don't address the first point at all, they instead work around it.\n>>> To be fair, I don't think we can completely address that first point: properly\n>>> reviewing spec proposals takes a lot of effort and accepting complex changes\n>>> to the BOLTs shouldn't be done lightly.\n>>>\n>>> I am mostly in favor of this solution, but I want to highlight that it isn't\n>>> only rainbows and unicorns: it will add fragmentation to the network, it will\n>>> add maintenance costs and backwards-compatibility issues, many bLIPs will be\n>>> sub-optimal solutions to the problem they try to solve and some bLIPs will be\n>>> simply insecure and may put users' funds at risk (L2 protocols are hard and have\n>>> subtle issues that can be easily missed). On the other hand, it allows for real\n>>> world experimentation and iteration, and it's easier to amend a bLIP than the\n>>> BOLTs.\n>>>\n>>> On the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a fully bazaar\n>>> style of evolution. Most of them will need:\n>>>\n>>> - to assign feature bit(s)\n>>> - to insert new tlv fields in existing messages\n>>> - to create new messages\n>>>\n>>> We can't have collisions on any of these three things. bLIP XXX cannot use the\n>>> same tlv types as bLIP YYY otherwise we're creating network incompatibilities.\n>>> So they really need to be centralized, and we need a process to assign these\n>>> and ensure they don't collide. It's not a hard problem, but we need to be clear\n>>> about the process around those.\n>>>\n>>> Regarding the details of where they live, I don't have a strong opinion, but I\n>>> think they must be easy to find and browse, and I think it's easier for readers\n>>> if they're inside the spec repository. We already have PRs that use a dedicated\n>>> \"proposals\" folder (e.g. [1], [2]).\n>>>\n>>> Cheers,\n>>> Bastien\n>>>\n>>> [1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n>>> [2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n>>>\n>>> Le jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a \u00e9crit :\n>>>>\n>>>> BIPs are already the Bazaar style of evolution that simultaneously\n>>>> allows flexibility and coordination/interoperability (since anyone can\n>>>> create a BIP and they create an environment of discussion).\n>>>>\n>>>> BOLTs are essentially one big BIP in the sense that they started as a\n>>>> place for discussion but are now more rigid. BOLTs must be followed\n>>>> strictly to ensure a node is interoperable with the network. And BOLTs\n>>>> should be rigid, as rigid as any widely used BIP like 32 for example.\n>>>> Even though BOLTs were flexible when being drafted their purpose has\n>>>> changed from descriptive to prescriptive.\n>>>> Any alternatives, or optional features should be extracted out of\n>>>> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n>>>> required flags set, messages sent, or alterations made to signal that\n>>>> the BIP's feature is enabled.\n>>>>\n>>>> A BOLT may at some point organically change to reference a BIP. For\n>>>> example if a BIP was drafted as an optional feature but then becomes\n>>>> more widespread and then turns out to be crucial for the proper\n>>>> operation of the network then a BOLT can be changed to just reference\n>>>> the BIP as mandatory. There isn't anything wrong with this.\n>>>>\n>>>> All of the above would work exactly the same if there was a bLIP\n>>>> repository instead. I don't see the value in having both bLIPs and\n>>>> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n>>>> not restricted to exclude lightning, and never have been.\n>>>>\n>>>> I believe the reason this move to BIPs hasn't happened organically is\n>>>> because many still perceive the BOLTs available for editing, so\n>>>> changes continue to be made. If instead BOLTs were perceived as more\n>>>> \"consensus critical\", not subject to change, and more people were\n>>>> strongly encouraged to write specs for new lightning features\n>>>> elsewhere (like the BIP repo) then you would see this issue of growing\n>>>> BOLTs resolved.\n>>>>\n>>>> Cheers\n>>>> Ariel Lorenzo-Luaces\n>>>>\n>>>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>>>> >\n>>>> > > That being said I think all the points that are addressed in Ryan's mail\n>>>> > > could very well be formalized into BOLTs but maybe we just need to rethink\n>>>> > > the current process of the BOLTs to make it more accessible for new ideas\n>>>> > > to find their way into the BOLTs?\n>>>> >\n>>>> > I think part of what bLIPs are trying to solve here is promoting more loosely\n>>>> > coupled evolution of the network. I think the BOLTs do a good job currently of\n>>>> > specifying what _base_ functionality is required for a routing node in a\n>>>> > prescriptive manner (you must forward an HTLC like this, etc). However there's\n>>>> > a rather large gap in describing functionality that has emerged over time due\n>>>> > to progressive evolution, and aren't absolutely necessary, but enhance\n>>>> > node/wallet operation.\n>>>> >\n>>>> > Examples of  include things like: path finding heuristics (BOLTs just say you\n>>>> > should get from Alice to Bob, but provides no recommendations w.r.t _how_ to do\n>>>> > so), fee bumping heuristics, breach retribution handling, channel management,\n>>>> > rebalancing, custom records usage (like the podcast index meta-data, messaging,\n>>>> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n>>>> > optimization, initial channel boostrapping, etc.\n>>>> >\n>>>> > All these examples are effectively optional as they aren't required for base\n>>>> > node operation, but they've organically evolved over time as node\n>>>> > implementations and wallet seek to solve UX and operational problems for\n>>>> > their users. bLIPs can be a _descriptive_ (this is how things can be done)\n>>>> > home for these types of standards, while BOLTs can be reserved for\n>>>> > _prescriptive_ measures (an HTLC looks like this, etc).\n>>>> >\n>>>> > The protocol as implemented today has a number of extensions (TLVs, message\n>>>> > types, feature bits, etc) that allow implementations to spin out their own\n>>>> > sub-protocols, many of which won't be considered absolutely necessary for node\n>>>> > operation. IMO we should embrace more of a \"bazaar\" style of evolution, and\n>>>> > acknowledge that loosely coupled evolution allows participants to more broadly\n>>>> > explore the design space, without the constraints of \"it isn't a thing until N\n>>>> > of us start to do it\".\n>>>> >\n>>>> > Historically, BOLTs have also had a rather monolithic structure. We've used\n>>>> > the same 11 or so documents for the past few years with the size of the\n>>>> > documents swelling over time with new exceptions, features, requirements,\n>>>> > etc. If you were hired to work on a new codebase and saw that everything is\n>>>> > defined in 11 \"functions\" that have been growing linearly over time, you'd\n>>>> > probably declare the codebase as being unmaintainable. By having distinct\n>>>> > documents for proposals/standards, bLIPs (author documents really), each new\n>>>> > standard/proposal is able to be more effectively explained, motivated, versionsed,\n>>>> > etc.\n>>>> >\n>>>> > -- Laolu\n>>>> >\n>>>> >\n>>>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>>>> >>\n>>>> >> Hey everyone,\n>>>> >>\n>>>> >> just for reference when I was new here (and did not understand the processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>>>> >>\n>>>> >> I wonder what exactly has changed in the reasoning by roasbeef which I will repeat here:\n>>>> >>\n>>>> >> > We already have the equiv of improvement proposals: BOLTs. Historically\n>>>> >>\n>>>> >> > new standardization documents are proposed initially as issues or PR's when\n>>>> >>\n>>>> >> > ultimately accepted. Why do we need another repo?\n>>>> >>\n>>>> >>\n>>>> >> As far as I can tell there was always some form of (invisible?) barrier to participate in the BOLTs but there are also new BOLTs being offered:\n>>>> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n>>>> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>>>> >> and topics to be included like:\n>>>> >> * dual funding\n>>>> >> * splicing\n>>>> >> * the examples given by Ryan\n>>>> >>\n>>>> >> I don't see how a new repo would reduce that barrier - Actually I think it would even create more confusion as I for example would not know where something belongs. That being said I think all the points that are addressed in Ryan's mail could very well be formalized into BOLTs but maybe we just need to rethink the current process of the BOLTs to make it more accessible for new ideas to find their way into the BOLTs? One thing that I can say from answering lightning-network questions on stackexchange is that it would certainly help if the BOLTs where referenced  on lightning.network web page and in the whitepaper as the place to be if one wants to learn about the Lightning Network\n>>>> >>\n>>>> >> with kind regards Rene\n>>>> >>\n>>>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>>>> >>>\n>>>> >>> Hi all,\n>>>> >>>\n>>>> >>>\n>>>> >>> The recent thread around zero-conf channels [1] provides an opportunity to discuss how the BOLT process handles features and best practices that arise in the wild vs. originating within the process itself. Zero-conf channels are one of many LN innovations on the app layer that have struggled to make their way into the spec. John Carvalho and Bitrefill launched Turbo channels in April 2019 [2], Breez posted their solution to the mailing list for feedback in August 2020 [3], and we know at least ACINQ and Muun (amongst others) have their own implementations. In an ideal world there would be a descriptive design document that the app layer implementers had collaborated on over the years that the spec group could then pick up and merge into the BOLTs now that the feature is deemed spec-worthy.\n>>>> >>>\n>>>> >>>\n>>>> >>> Over the last couple of months, we have discussed the idea of adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various members of the community, and have received positive feedback from both app layer and protocol devs. This would not affect the existing BOLT process at all, but simply add a place for app layer best practices to be succinctly described and organized, especially those that require coordination. These features are being built outside of the BOLT process today anyways, so ideally a bLIP process would bring them into the fold instead of leaving them buried in old ML posts or not documented at all.\n>>>> >>>\n>>>> >>>\n>>>> >>> Some potential bLIP ideas that people have mentioned include: each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast payment metadata, p2p messaging formats, new pathfinding heuristics, remote node connection standards, etc.\n>>>> >>>\n>>>> >>>\n>>>> >>> If the community is interested in moving forward, we've started a branch [5] describing such a process. It's based on BIP-0002, so not trying to reinvent any wheels. It would be great to have developers from various implementations and from the broader app layer ecosystem volunteer to be listed as editors (basically the same role as in the BIPs).\n>>>> >>>\n>>>> >>>\n>>>> >>> Looking forward to hearing your thoughts!\n>>>> >>>\n>>>> >>>\n>>>> >>> Best,\n>>>> >>> Ryan\n>>>> >>>\n>>>> >>>\n>>>> >>> [1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>>>> >>>\n>>>> >>> [2] https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>>>> >>>\n>>>> >>> [3] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>>>> >>>\n>>>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK = Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>>>> >>>\n>>>> >>> [5] https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>>>> >>>\n>>>> >>> _______________________________________________\n>>>> >>> Lightning-dev mailing list\n>>>> >>> Lightning-dev at lists.linuxfoundation.org\n>>>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>> >>\n>>>> >>\n>>>> >>\n>>>> >> --\n>>>> >> https://www.rene-pickhardt.de\n>>>> >> _______________________________________________\n>>>> >> Lightning-dev mailing list\n>>>> >> Lightning-dev at lists.linuxfoundation.org\n>>>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>> >\n>>>> > _______________________________________________\n>>>> > Lightning-dev mailing list\n>>>> > Lightning-dev at lists.linuxfoundation.org\n>>>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-07-02T18:20:51",
                "message_text_only": "Hi Ryan,\n\nThanks for starting this discussion, I agree it's a good time for the\nLightning development community to start this self-introspection on its own\nspecification process :)\n\nFirst and foremost, maybe we could take a minute off to celebrate the\nsuccess of the BOLT process and the road traveled so far ? What was a fuzzy\nheap of ideas on a whiteboard a few years ago has bloomed up to a living\nand pulsating distributed ecosystem of thousands of nodes all around the\nworld. If the bet was to deliver on fast, instant, cheap, reasonably\nscalable, reasonably confidential Bitcoin payments, it's a won one and\nthat's really cool.\n\nRetrospectively, it was a foolhardy bet for a wide diversity of factors.\nOne could think about opinionated, early design choices deeply affecting\nprotocol safety and efficiency of which the ultimate validity was still a\nfunction of fluky base layer evolutions [0]. Another could consider the\ncommunication challenges of softly aligning development teams on the common\neffort of designing and deploying from scratch a cryptographic protocol as\nsophisticated as Lightning. Not an easy task when you're mindful about the\ntimezones spread, the diversity of software engineering backgrounds and the\ndiffering schedules of priorities.\n\nSo kudos to everyone who has played a part in the Lightning dev process.\nThe OGs who started the tale, the rookies who jumped on the wagon on the\nway and today newcomers showing up with new seeds to nurture the ecosystem\n:)\n\nNow, I would say we more-or-less all agree that the current BOLT process\nhas reached its limits. Both from private conservations across the teams\nbut also frustrations expressed during the irc meetings in the past months.\nOr as a simple data point, the only meaningful spec object we did merge on\nthe last 18 months is anchor output, it did consumes a lot of review and\nengineering bandwidth from contributors, took few refinement to finalize\n(`option_anchors_zero_fee_htlc_tx`) and I believe every implementations are\nstill scratching their heads on a robust, default fee-bumping strategy.\n\nSo if we agree about the BOLT process limitations, the next question to\nraise is how to improve it. Though there, as expressed in other replies,\nI'm more we're not going to be able to do that much, as ultimately we're\nupper bounded by a fast-pacing, always-growing, permissionless ecosystem of\napplications and experiments moving forward in baazar-style and\nlower-bounded by a decentralized process across teams allocating their\nengineering resources with different priorities or even exploring Lightning\nmassive evolution stages in heterogenous, synergic directions.\n\nBreeding another specification process on top of Lightning sounds a good\nway forward. Though I believe it might be better to take time to operate\nthe disentanglement nicely. If we take the list of ideas which could be\npart of such a process, one of them, dynamic commitments could make a lot\nof sense to be well-designed and well-supported by every implementation. In\ncase of emergency fixes to deploy safer channel types, if you have to close\nall your channels with other implementations, on a holistic scale, it might\ncloak the mempools and spike the feerate, strickening safety of every other\nchannel on the network. Yes we might have safety interdepencies between\nimplementations :/\n\nAnd it's also good to have thoughtful, well-defined specification bounds\nwhen you're working on coordinated security disclosures to know who has\nimplemented what and whom you should reach out when something is broken.\n\nAnother orthogonal point to consider is the existence of already\nhigher-layer protocol specifications such as the dlcspecs. Even if the\necosystem is still in the bootstrap phase for now, we already have a\ndiscussion to split between a \"consensus\" track and more optional features.\nI believe some features discussed there such as negotiation layer about\npremium fee to compensate unilateral fee-bumping responsibility risk could\nbelong to such a new bLIPs process ?\n\nSo here my thinking, as a BOLT contributor, what the common subset of\nproblems we want to keep tackling down together in the coming years, what\nis the remaining subset we're happy to be engage by a higher layer\ndevelopment community and how to draw both communication and software\ninterfaces in-between ?\n\nPersonally, I would be glad if we not extend the scope of the current BOLT\ncoverage and focus more on fixing the known-issues, simplifying state\nmachines, fixing oddities of channel policies announcements [1], writing\ndown best practices on fee-bumping strategies, agreeing on channel types\nupgrades raw mechanisms, features discovery and if we want to innovate\nfocus on taproot well-done integration which should keep us busy for few\nyears, among others PTLC support, funding output taproot support,\ncomposable taptree for revokeable outputs, ...\n\nIHMO, if the BOLT process is officialized it will enter in a more boring\nphase, focused on safety/reliability/privacy fixes on the initial value\nproposition laid out above that's really okay :)\n\nI know, it might be a passionate discussion to have among ourselves as\neveryone would like its pet project to benefit from the BOLT \"boost\nspotlight\"... Though in the long term we can also imagine bLIPs as a\nstaging room with a formalized path for BOLT upgrade when it makes sense.\nAlso, we shouldn't expect a per-team position there as some of them are\ndeliberately \"bazaar\" in themselves :)\n\nFurther I really believe this question of interfaces and\nforward-flexibility across communities matters a lot. I would be glad if we\ncan save us some passionate discussions a few years from now on the size of\nthe onions, echo of the current discussion we have on the base layer,\nwhere, among a lot, the current mempool package limits might not fit every\nL2's chain of pre-committed transactions.\n\nOf course, offering more flexibility might come at the price of security\nand privacy concerns, as the trampoline discussions raised it. Though in a\npermissionless system like Bitcoin, even with a lot of good will, it's hard\nto prevent folks from harming themselves. Maybe we can promote best\npractices and design protocols and features combining both\neconomic-optimality and safety ?\n\nW.r.t to the TLV types/features bits/message types namespace allocation\nissue, if it's heavily re-used by this upper specification, I feel it can\nbe still be handled by the BOLT community to minimize confusions risks,\nthough with a super-dumb, automatic process ? As the experience did learn\nus in the past months, in Bitcoin, even standard slot allocation can be\ncontentious.\n\nMore personally, I feel it would be better if such a new specification\nprocess doesn't completely share the same communication infrastructure as\nthe BOLTs, like having them in the same repository. Otherwise it might\nspread the belief among public perception that those standards have been\n\"blessed\" in any way by LN devs and have been through the same thoroughness\nof design and review process. Or even switching the communication and\nstandard maintenance on the author itself like Dave Harding's rough\nproposal from a few months ago seems to suggest to me [2].\n\nCheers,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2017-January/000652.html\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003005.html\n\n[2]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018868.html\n\nLe ven. 2 juil. 2021 \u00e0 04:48, Michael Folkson <michaelfolkson at gmail.com> a\n\u00e9crit :\n\n> > The other thing bLIPs do is do away with the whole \"human picks the\n> number of documents\", and \"don't assign your own number, you must wait\".\n>\n> So TL;DR BIPs and BOLTs sometimes require waiting for things (like\n> review and consensus) and there should be a new acronym and process\n> (\"bLIPs\") to avoid us having to wait for things. I just think \"bLIPs\"\n> adds confusion e.g. should something be a bLIP or a BOLT? Does a bLIP\n> eventually become a BOLT when it is mature enough? This tendency to\n> fragment and introduce new acronyms and new processes should be\n> resisted imo. If a new process is introduced every time there is a\n> disagreement or perceived friction it just erodes the value of\n> existing processes and means they all get bypassed. Strengthen and\n> improve existing processes and only introduce a new one as an absolute\n> last resort.\n>\n> Other than the minor frictions described above I don't see why \"bLIPs\"\n> can't just be draft BOLTs.\n>\n> > Adding a third BIP editor more involved with Lightning sounds like a\n> good idea.\n>\n> Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n> would be a great additional BIP editor to cover Lightning related BIPs\n> :) I think BOLTs being subsumed into BIPs would be nice but I'm\n> pessimistic it will happen. Like legislation and regulation in the\n> legacy financial system alphabet soups only expand they never get\n> simplified. Let's at least resist alphabet soup expansion here.\n>\n> On Fri, Jul 2, 2021 at 9:01 AM Bastien TEINTURIER <bastien at acinq.fr>\n> wrote:\n> >>\n> >> Will it actually add any more fragmentation that already exists? Due to\n> all\n> >> the extensibility we've added in the protocol, it's already possible\n> for any\n> >> implementation to start to work on their own sub-protocols. This just\n> gives\n> >> them a new venue to at least _describe_ what they're using.\n> >\n> >\n> > It's only my 2 cents, but I'm afraid it will indeed add more\n> fragmentation, because\n> > the fact that there exists a bLIP for feature XXX will likely act as a\n> green light to\n> > deploy it faster instead of spending more time talking about it with the\n> community\n> > and thinking about potential issues, forward-compatibility, etc.\n> >\n> > But I agree with you that it also gives more freedom to experiment in\n> the real world,\n> > which helps find issues and correct them, paving the way for better\n> features for\n> > end users.\n> >\n> >> It's also likely the case that already implementations, or typically\n> forks\n> >> of implementations are already using \"undocumented\" TLVs or feature\n> bits in\n> >> the wild today.\n> >\n> >\n> > But today we're usually very careful when we do that, and use numbers in\n> high ranges\n> > for these use-cases. In our case for example we use message type 35007\n> for our\n> > swap-in and we expect that to change once standardized, so we did extra\n> work to\n> > ensure we wouldn't paint ourselves into a corner when switching to a\n> standard version.\n> >\n> > I think that if we have a centralized bLIP repo, we can take this\n> opportunity to safely\n> > assign \"final\" values for types and feature bits that are used by each\n> bLIP, and stronger\n> > guarantees that they will not conflict with another bLIP or BOLT. Of\n> course that doesn't\n> > stop anyone from deploying a conflict, but their use of the same bits\n> won't be documented\n> > so it shouldn't be widely deployed, and browsing the BOLTs and bLIPs\n> should let anyone\n> > see what the \"correct\" meaning of those bits should be.\n> >\n> > Cheers,\n> > Bastien\n> >\n> >\n> > Le jeu. 1 juil. 2021 \u00e0 22:43, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n> \u00e9crit :\n> >>\n> >> > But they don't address the first point at all, they instead work\n> around\n> >> > it.  To be fair, I don't think we can completely address that first\n> point:\n> >> > properly reviewing spec proposals takes a lot of effort and accepting\n> >> > complex changes to the BOLTs shouldn't be done lightly.\n> >>\n> >> I think this is a fair characterization that I agree with. I also agree\n> that\n> >> there isn't really a way to fundamentally address it. The issue of\n> scarce\n> >> review resources is something just about any large open source project\n> needs\n> >> to deal with: everyone wants to make a PR, but no one wants to review\n> the\n> >> PRs of others, unless it scratches some tangential itch they may have.\n> IMO\n> >> it's also the case that the problem/solution space of LN is so large,\n> that\n> >> it's hard to expect every developer to review each new proposal that\n> comes\n> >> in, as they themselves have their own set of priorities (product,\n> >> businesses, protocol, personal, etc).\n> >>\n> >> In the end though, I think when there've been critical items that\n> affect all\n> >> implementations and/or the existence of the protocol itself, developers\n> >> typically band together to commit resources to help a proposal move\n> forward.\n> >> One upcoming example of this will be the \"base\" taproot channel type\n> (the\n> >> design space is pretty large in that it even permits a new type of\n> symmetric\n> >> state revocation-based channel).\n> >>\n> >> >  it will add fragmentation to the network, it will add maintenance\n> costs\n> >> >  and backwards-compatibility issues\n> >>\n> >> Will it actually add any more fragmentation that already exists? Due to\n> all\n> >> the extensibility we've added in the protocol, it's already possible\n> for any\n> >> implementation to start to work on their own sub-protocols. This just\n> gives\n> >> them a new venue to at least _describe_ what they're using. As usual,\n> it's\n> >> up to other implementations if they want to adopt it or not, or advise\n> >> against its use.\n> >>\n> >> >  many bLIPs will be sub-optimal solutions to the problem they try to\n> solve\n> >> >  and some bLIPs will be simply insecure and may put users' funds at\n> risk\n> >> >  (L2 protocols are hard and have subtle issues that can be easily\n> missed)\n> >>\n> >> This may be the case, but I guess at times it's hard to know if\n> something is\n> >> objectively sub-optimal without further exploration of the design space,\n> >> which usually means either more people involved, or more time examining\n> the\n> >> problem. Ultimately, different wallets/implementations may also be\n> willing\n> >> to make different usability/security trade-offs. One example here is\n> zero\n> >> conf channels: they assume a greater degree of trust with the party\n> you're\n> >> _accepting_ the channel from, as if you receive funds over the channel,\n> they\n> >> can be double spent away. However it's undeniable that they improve the\n> UX\n> >> by reducing the amount of time a user needs to wait around before they\n> can\n> >> actually jump in and use LN.\n> >>\n> >> In the end though, there's no grand global committee that prevents\n> people\n> >> from deploying software they think is interesting or useful. In the long\n> >> run, I guess one simply needs to hope that bad ideas die out, or speak\n> out\n> >> against them to the public. As LN sits a layer above the base protocol,\n> >> widespread global consensus isn't really required to make certain\n> classes of\n> >> changes, and you can't stop people from experimenting on their own.\n> >>\n> >> > We can't have collisions on any of these three things.\n> >>\n> >> Yeah, collisions are def possible. IMO, this is where the interplay with\n> >> BOLTs comes in: BOLTs are the global feature bit/tlv/message\n> namespace.  A\n> >> bLIP might come with the amendment of BOLT 9 to define feature bits they\n> >> used. Of course, this should be done on a best effort basis, as even if\n> you\n> >> assign a bit for your idea, someone can just go ahead and deploy\n> something\n> >> else w/ that same bit, and they may never really intersect depending on\n> the\n> >> nature or how widespread the new feature is.\n> >>\n> >> It's also likely the case that already implementations, or typically\n> forks\n> >> of implementations are already using \"undocumented\" TLVs or feature\n> bits in\n> >> the wild today. I don't know exactly which TLV type things like\n> applications\n> >> that tunnel messages over the network use, but afaik so far there\n> haven't\n> >> been any disastrous collisions in the wild.\n> >>\n> >> -- Laolu\n> >>\n> >> On Thu, Jul 1, 2021 at 2:19 AM Bastien TEINTURIER <bastien at acinq.fr>\n> wrote:\n> >>>\n> >>> Thanks for starting that discussion.\n> >>>\n> >>> In my opinion, what we're really trying to address here are the two\n> following\n> >>> points (at least from the point of view of someone who works on the\n> spec and\n> >>> an implementation):\n> >>>\n> >>> - Implementers get frustrated when they've worked on something that\n> they think\n> >>> is useful and they can't get it into the BOLTs (the spec PR isn't\n> reviewed,\n> >>> it progresses too slowly or there isn't enough agreement to merge it)\n> >>> - Implementers expect other implementers to specify the optional\n> features they\n> >>> ship: we don't want to have to reverse-engineer a sub-protocol when\n> users\n> >>> want our implementation to provide support for feature XXX\n> >>>\n> >>> Note that these are two very different concerns.\n> >>>\n> >>> bLIPs/SPARKS/BIPs clearly address the second point, which is good.\n> >>> But they don't address the first point at all, they instead work\n> around it.\n> >>> To be fair, I don't think we can completely address that first point:\n> properly\n> >>> reviewing spec proposals takes a lot of effort and accepting complex\n> changes\n> >>> to the BOLTs shouldn't be done lightly.\n> >>>\n> >>> I am mostly in favor of this solution, but I want to highlight that it\n> isn't\n> >>> only rainbows and unicorns: it will add fragmentation to the network,\n> it will\n> >>> add maintenance costs and backwards-compatibility issues, many bLIPs\n> will be\n> >>> sub-optimal solutions to the problem they try to solve and some bLIPs\n> will be\n> >>> simply insecure and may put users' funds at risk (L2 protocols are\n> hard and have\n> >>> subtle issues that can be easily missed). On the other hand, it allows\n> for real\n> >>> world experimentation and iteration, and it's easier to amend a bLIP\n> than the\n> >>> BOLTs.\n> >>>\n> >>> On the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a\n> fully bazaar\n> >>> style of evolution. Most of them will need:\n> >>>\n> >>> - to assign feature bit(s)\n> >>> - to insert new tlv fields in existing messages\n> >>> - to create new messages\n> >>>\n> >>> We can't have collisions on any of these three things. bLIP XXX cannot\n> use the\n> >>> same tlv types as bLIP YYY otherwise we're creating network\n> incompatibilities.\n> >>> So they really need to be centralized, and we need a process to assign\n> these\n> >>> and ensure they don't collide. It's not a hard problem, but we need to\n> be clear\n> >>> about the process around those.\n> >>>\n> >>> Regarding the details of where they live, I don't have a strong\n> opinion, but I\n> >>> think they must be easy to find and browse, and I think it's easier\n> for readers\n> >>> if they're inside the spec repository. We already have PRs that use a\n> dedicated\n> >>> \"proposals\" folder (e.g. [1], [2]).\n> >>>\n> >>> Cheers,\n> >>> Bastien\n> >>>\n> >>> [1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n> >>> [2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n> >>>\n> >>> Le jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a\n> \u00e9crit :\n> >>>>\n> >>>> BIPs are already the Bazaar style of evolution that simultaneously\n> >>>> allows flexibility and coordination/interoperability (since anyone can\n> >>>> create a BIP and they create an environment of discussion).\n> >>>>\n> >>>> BOLTs are essentially one big BIP in the sense that they started as a\n> >>>> place for discussion but are now more rigid. BOLTs must be followed\n> >>>> strictly to ensure a node is interoperable with the network. And BOLTs\n> >>>> should be rigid, as rigid as any widely used BIP like 32 for example.\n> >>>> Even though BOLTs were flexible when being drafted their purpose has\n> >>>> changed from descriptive to prescriptive.\n> >>>> Any alternatives, or optional features should be extracted out of\n> >>>> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n> >>>> required flags set, messages sent, or alterations made to signal that\n> >>>> the BIP's feature is enabled.\n> >>>>\n> >>>> A BOLT may at some point organically change to reference a BIP. For\n> >>>> example if a BIP was drafted as an optional feature but then becomes\n> >>>> more widespread and then turns out to be crucial for the proper\n> >>>> operation of the network then a BOLT can be changed to just reference\n> >>>> the BIP as mandatory. There isn't anything wrong with this.\n> >>>>\n> >>>> All of the above would work exactly the same if there was a bLIP\n> >>>> repository instead. I don't see the value in having both bLIPs and\n> >>>> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n> >>>> not restricted to exclude lightning, and never have been.\n> >>>>\n> >>>> I believe the reason this move to BIPs hasn't happened organically is\n> >>>> because many still perceive the BOLTs available for editing, so\n> >>>> changes continue to be made. If instead BOLTs were perceived as more\n> >>>> \"consensus critical\", not subject to change, and more people were\n> >>>> strongly encouraged to write specs for new lightning features\n> >>>> elsewhere (like the BIP repo) then you would see this issue of growing\n> >>>> BOLTs resolved.\n> >>>>\n> >>>> Cheers\n> >>>> Ariel Lorenzo-Luaces\n> >>>>\n> >>>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> wrote:\n> >>>> >\n> >>>> > > That being said I think all the points that are addressed in\n> Ryan's mail\n> >>>> > > could very well be formalized into BOLTs but maybe we just need\n> to rethink\n> >>>> > > the current process of the BOLTs to make it more accessible for\n> new ideas\n> >>>> > > to find their way into the BOLTs?\n> >>>> >\n> >>>> > I think part of what bLIPs are trying to solve here is promoting\n> more loosely\n> >>>> > coupled evolution of the network. I think the BOLTs do a good job\n> currently of\n> >>>> > specifying what _base_ functionality is required for a routing node\n> in a\n> >>>> > prescriptive manner (you must forward an HTLC like this, etc).\n> However there's\n> >>>> > a rather large gap in describing functionality that has emerged\n> over time due\n> >>>> > to progressive evolution, and aren't absolutely necessary, but\n> enhance\n> >>>> > node/wallet operation.\n> >>>> >\n> >>>> > Examples of  include things like: path finding heuristics (BOLTs\n> just say you\n> >>>> > should get from Alice to Bob, but provides no recommendations w.r.t\n> _how_ to do\n> >>>> > so), fee bumping heuristics, breach retribution handling, channel\n> management,\n> >>>> > rebalancing, custom records usage (like the podcast index\n> meta-data, messaging,\n> >>>> > etc), JIT channel opening, hosted channels, randomized channel IDs,\n> fee\n> >>>> > optimization, initial channel boostrapping, etc.\n> >>>> >\n> >>>> > All these examples are effectively optional as they aren't required\n> for base\n> >>>> > node operation, but they've organically evolved over time as node\n> >>>> > implementations and wallet seek to solve UX and operational\n> problems for\n> >>>> > their users. bLIPs can be a _descriptive_ (this is how things can\n> be done)\n> >>>> > home for these types of standards, while BOLTs can be reserved for\n> >>>> > _prescriptive_ measures (an HTLC looks like this, etc).\n> >>>> >\n> >>>> > The protocol as implemented today has a number of extensions (TLVs,\n> message\n> >>>> > types, feature bits, etc) that allow implementations to spin out\n> their own\n> >>>> > sub-protocols, many of which won't be considered absolutely\n> necessary for node\n> >>>> > operation. IMO we should embrace more of a \"bazaar\" style of\n> evolution, and\n> >>>> > acknowledge that loosely coupled evolution allows participants to\n> more broadly\n> >>>> > explore the design space, without the constraints of \"it isn't a\n> thing until N\n> >>>> > of us start to do it\".\n> >>>> >\n> >>>> > Historically, BOLTs have also had a rather monolithic structure.\n> We've used\n> >>>> > the same 11 or so documents for the past few years with the size of\n> the\n> >>>> > documents swelling over time with new exceptions, features,\n> requirements,\n> >>>> > etc. If you were hired to work on a new codebase and saw that\n> everything is\n> >>>> > defined in 11 \"functions\" that have been growing linearly over\n> time, you'd\n> >>>> > probably declare the codebase as being unmaintainable. By having\n> distinct\n> >>>> > documents for proposals/standards, bLIPs (author documents really),\n> each new\n> >>>> > standard/proposal is able to be more effectively explained,\n> motivated, versionsed,\n> >>>> > etc.\n> >>>> >\n> >>>> > -- Laolu\n> >>>> >\n> >>>> >\n> >>>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>>> >>\n> >>>> >> Hey everyone,\n> >>>> >>\n> >>>> >> just for reference when I was new here (and did not understand the\n> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n> >>>> >>\n> >>>> >> I wonder what exactly has changed in the reasoning by roasbeef\n> which I will repeat here:\n> >>>> >>\n> >>>> >> > We already have the equiv of improvement proposals: BOLTs.\n> Historically\n> >>>> >>\n> >>>> >> > new standardization documents are proposed initially as issues\n> or PR's when\n> >>>> >>\n> >>>> >> > ultimately accepted. Why do we need another repo?\n> >>>> >>\n> >>>> >>\n> >>>> >> As far as I can tell there was always some form of (invisible?)\n> barrier to participate in the BOLTs but there are also new BOLTs being\n> offered:\n> >>>> >> * BOLT 12:\n> https://github.com/lightningnetwork/lightning-rfc/pull/798\n> >>>> >> * BOLT 14:\n> https://github.com/lightningnetwork/lightning-rfc/pull/780\n> >>>> >> and topics to be included like:\n> >>>> >> * dual funding\n> >>>> >> * splicing\n> >>>> >> * the examples given by Ryan\n> >>>> >>\n> >>>> >> I don't see how a new repo would reduce that barrier - Actually I\n> think it would even create more confusion as I for example would not know\n> where something belongs. That being said I think all the points that are\n> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n> we just need to rethink the current process of the BOLTs to make it more\n> accessible for new ideas to find their way into the BOLTs? One thing that I\n> can say from answering lightning-network questions on stackexchange is that\n> it would certainly help if the BOLTs where referenced  on lightning.network\n> web page and in the whitepaper as the place to be if one wants to learn\n> about the Lightning Network\n> >>>> >>\n> >>>> >> with kind regards Rene\n> >>>> >>\n> >>>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>>> >>>\n> >>>> >>> Hi all,\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> The recent thread around zero-conf channels [1] provides an\n> opportunity to discuss how the BOLT process handles features and best\n> practices that arise in the wild vs. originating within the process itself.\n> Zero-conf channels are one of many LN innovations on the app layer that\n> have struggled to make their way into the spec. John Carvalho and Bitrefill\n> launched Turbo channels in April 2019 [2], Breez posted their solution to\n> the mailing list for feedback in August 2020 [3], and we know at least\n> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n> world there would be a descriptive design document that the app layer\n> implementers had collaborated on over the years that the spec group could\n> then pick up and merge into the BOLTs now that the feature is deemed\n> spec-worthy.\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> Over the last couple of months, we have discussed the idea of\n> adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with\n> various members of the community, and have received positive feedback from\n> both app layer and protocol devs. This would not affect the existing BOLT\n> process at all, but simply add a place for app layer best practices to be\n> succinctly described and organized, especially those that require\n> coordination. These features are being built outside of the BOLT process\n> today anyways, so ideally a bLIP process would bring them into the fold\n> instead of leaving them buried in old ML posts or not documented at all.\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> Some potential bLIP ideas that people have mentioned include:\n> each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments,\n> podcast payment metadata, p2p messaging formats, new pathfinding\n> heuristics, remote node connection standards, etc.\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> If the community is interested in moving forward, we've started a\n> branch [5] describing such a process. It's based on BIP-0002, so not trying\n> to reinvent any wheels. It would be great to have developers from various\n> implementations and from the broader app layer ecosystem volunteer to be\n> listed as editors (basically the same role as in the BIPs).\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> Looking forward to hearing your thoughts!\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> Best,\n> >>>> >>> Ryan\n> >>>> >>>\n> >>>> >>>\n> >>>> >>> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n> >>>> >>>\n> >>>> >>> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n> >>>> >>>\n> >>>> >>> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n> >>>> >>>\n> >>>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n> >>>> >>>\n> >>>> >>> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n> >>>> >>>\n> >>>> >>> _______________________________________________\n> >>>> >>> Lightning-dev mailing list\n> >>>> >>> Lightning-dev at lists.linuxfoundation.org\n> >>>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>>> >>\n> >>>> >>\n> >>>> >>\n> >>>> >> --\n> >>>> >> https://www.rene-pickhardt.de\n> >>>> >> _______________________________________________\n> >>>> >> Lightning-dev mailing list\n> >>>> >> Lightning-dev at lists.linuxfoundation.org\n> >>>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>>> >\n> >>>> > _______________________________________________\n> >>>> > Lightning-dev mailing list\n> >>>> > Lightning-dev at lists.linuxfoundation.org\n> >>>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>>> _______________________________________________\n> >>>> Lightning-dev mailing list\n> >>>> Lightning-dev at lists.linuxfoundation.org\n> >>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>>\n> >>> _______________________________________________\n> >>> Lightning-dev mailing list\n> >>> Lightning-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at gmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210702/6d3cd8a3/attachment-0001.html>"
            },
            {
                "author": "Ryan Gentry",
                "date": "2021-07-07T21:28:45",
                "message_text_only": "Hi all,\n\nThanks so much for the great feedback over the last week. Seems like\ngeneral agreement that adding a simple home for descriptive design\ndocuments focusing on new LN features would be a good thing, and augment\nthe prescriptive BOLTs (which have done a great job getting us this far!).\n\nIf there is a point of contention, it seems to be about how not only this\ninteracts with the existing BIP system, but also how the BOLTs interact\nwith the BIP system. The only problem I have with BOLTs and bLIPs as BIPs\nis that it introduces large scope creep over what was originally a pretty\nsimple proposal. I don't really care where these design documents exist,\nonly that there is a standard format and that LN developers and users feel\nempowered to create them and share them with the broader ecosystem.\n\nIf we proceed with creating bLIPs in the lightning-rfc repo today and later\ndecide to recreate the BOLTs as BIPs, it will be no trouble at all to\nrecreate bLIPs as BIPs as well.\n\nThe BIP Process Wishlist sounds great and can be addressed independently.\nIf recruits for merging the BOLTs can be found, we can tackle the mechanics\nof a merge then (alongside maybe some of the other bitcoin-related *IP\nrepos that exist outside the BIPs? [1] [2]).\n\nBest,\nRyan\n\n[1] https://github.com/satoshilabs/slips\n[2] https://github.com/rsksmart/RSKIPs\n\nOn Fri, Jul 2, 2021 at 1:21 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Ryan,\n>\n> Thanks for starting this discussion, I agree it's a good time for the\n> Lightning development community to start this self-introspection on its own\n> specification process :)\n>\n> First and foremost, maybe we could take a minute off to celebrate the\n> success of the BOLT process and the road traveled so far ? What was a fuzzy\n> heap of ideas on a whiteboard a few years ago has bloomed up to a living\n> and pulsating distributed ecosystem of thousands of nodes all around the\n> world. If the bet was to deliver on fast, instant, cheap, reasonably\n> scalable, reasonably confidential Bitcoin payments, it's a won one and\n> that's really cool.\n>\n> Retrospectively, it was a foolhardy bet for a wide diversity of factors.\n> One could think about opinionated, early design choices deeply affecting\n> protocol safety and efficiency of which the ultimate validity was still a\n> function of fluky base layer evolutions [0]. Another could consider the\n> communication challenges of softly aligning development teams on the common\n> effort of designing and deploying from scratch a cryptographic protocol as\n> sophisticated as Lightning. Not an easy task when you're mindful about the\n> timezones spread, the diversity of software engineering backgrounds and the\n> differing schedules of priorities.\n>\n> So kudos to everyone who has played a part in the Lightning dev process.\n> The OGs who started the tale, the rookies who jumped on the wagon on the\n> way and today newcomers showing up with new seeds to nurture the ecosystem\n> :)\n>\n> Now, I would say we more-or-less all agree that the current BOLT process\n> has reached its limits. Both from private conservations across the teams\n> but also frustrations expressed during the irc meetings in the past months.\n> Or as a simple data point, the only meaningful spec object we did merge on\n> the last 18 months is anchor output, it did consumes a lot of review and\n> engineering bandwidth from contributors, took few refinement to finalize\n> (`option_anchors_zero_fee_htlc_tx`) and I believe every implementations are\n> still scratching their heads on a robust, default fee-bumping strategy.\n>\n> So if we agree about the BOLT process limitations, the next question to\n> raise is how to improve it. Though there, as expressed in other replies,\n> I'm more we're not going to be able to do that much, as ultimately we're\n> upper bounded by a fast-pacing, always-growing, permissionless ecosystem of\n> applications and experiments moving forward in baazar-style and\n> lower-bounded by a decentralized process across teams allocating their\n> engineering resources with different priorities or even exploring Lightning\n> massive evolution stages in heterogenous, synergic directions.\n>\n> Breeding another specification process on top of Lightning sounds a good\n> way forward. Though I believe it might be better to take time to operate\n> the disentanglement nicely. If we take the list of ideas which could be\n> part of such a process, one of them, dynamic commitments could make a lot\n> of sense to be well-designed and well-supported by every implementation. In\n> case of emergency fixes to deploy safer channel types, if you have to close\n> all your channels with other implementations, on a holistic scale, it might\n> cloak the mempools and spike the feerate, strickening safety of every other\n> channel on the network. Yes we might have safety interdepencies between\n> implementations :/\n>\n> And it's also good to have thoughtful, well-defined specification bounds\n> when you're working on coordinated security disclosures to know who has\n> implemented what and whom you should reach out when something is broken.\n>\n> Another orthogonal point to consider is the existence of already\n> higher-layer protocol specifications such as the dlcspecs. Even if the\n> ecosystem is still in the bootstrap phase for now, we already have a\n> discussion to split between a \"consensus\" track and more optional features.\n> I believe some features discussed there such as negotiation layer about\n> premium fee to compensate unilateral fee-bumping responsibility risk could\n> belong to such a new bLIPs process ?\n>\n> So here my thinking, as a BOLT contributor, what the common subset of\n> problems we want to keep tackling down together in the coming years, what\n> is the remaining subset we're happy to be engage by a higher layer\n> development community and how to draw both communication and software\n> interfaces in-between ?\n>\n> Personally, I would be glad if we not extend the scope of the current BOLT\n> coverage and focus more on fixing the known-issues, simplifying state\n> machines, fixing oddities of channel policies announcements [1], writing\n> down best practices on fee-bumping strategies, agreeing on channel types\n> upgrades raw mechanisms, features discovery and if we want to innovate\n> focus on taproot well-done integration which should keep us busy for few\n> years, among others PTLC support, funding output taproot support,\n> composable taptree for revokeable outputs, ...\n>\n> IHMO, if the BOLT process is officialized it will enter in a more boring\n> phase, focused on safety/reliability/privacy fixes on the initial value\n> proposition laid out above that's really okay :)\n>\n> I know, it might be a passionate discussion to have among ourselves as\n> everyone would like its pet project to benefit from the BOLT \"boost\n> spotlight\"... Though in the long term we can also imagine bLIPs as a\n> staging room with a formalized path for BOLT upgrade when it makes sense.\n> Also, we shouldn't expect a per-team position there as some of them are\n> deliberately \"bazaar\" in themselves :)\n>\n> Further I really believe this question of interfaces and\n> forward-flexibility across communities matters a lot. I would be glad if we\n> can save us some passionate discussions a few years from now on the size of\n> the onions, echo of the current discussion we have on the base layer,\n> where, among a lot, the current mempool package limits might not fit every\n> L2's chain of pre-committed transactions.\n>\n> Of course, offering more flexibility might come at the price of security\n> and privacy concerns, as the trampoline discussions raised it. Though in a\n> permissionless system like Bitcoin, even with a lot of good will, it's hard\n> to prevent folks from harming themselves. Maybe we can promote best\n> practices and design protocols and features combining both\n> economic-optimality and safety ?\n>\n> W.r.t to the TLV types/features bits/message types namespace allocation\n> issue, if it's heavily re-used by this upper specification, I feel it can\n> be still be handled by the BOLT community to minimize confusions risks,\n> though with a super-dumb, automatic process ? As the experience did learn\n> us in the past months, in Bitcoin, even standard slot allocation can be\n> contentious.\n>\n> More personally, I feel it would be better if such a new specification\n> process doesn't completely share the same communication infrastructure as\n> the BOLTs, like having them in the same repository. Otherwise it might\n> spread the belief among public perception that those standards have been\n> \"blessed\" in any way by LN devs and have been through the same thoroughness\n> of design and review process. Or even switching the communication and\n> standard maintenance on the author itself like Dave Harding's rough\n> proposal from a few months ago seems to suggest to me [2].\n>\n> Cheers,\n> Antoine\n>\n> [0]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2017-January/000652.html\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003005.html\n>\n> [2]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018868.html\n>\n> Le ven. 2 juil. 2021 \u00e0 04:48, Michael Folkson <michaelfolkson at gmail.com>\n> a \u00e9crit :\n>\n>> > The other thing bLIPs do is do away with the whole \"human picks the\n>> number of documents\", and \"don't assign your own number, you must wait\".\n>>\n>> So TL;DR BIPs and BOLTs sometimes require waiting for things (like\n>> review and consensus) and there should be a new acronym and process\n>> (\"bLIPs\") to avoid us having to wait for things. I just think \"bLIPs\"\n>> adds confusion e.g. should something be a bLIP or a BOLT? Does a bLIP\n>> eventually become a BOLT when it is mature enough? This tendency to\n>> fragment and introduce new acronyms and new processes should be\n>> resisted imo. If a new process is introduced every time there is a\n>> disagreement or perceived friction it just erodes the value of\n>> existing processes and means they all get bypassed. Strengthen and\n>> improve existing processes and only introduce a new one as an absolute\n>> last resort.\n>>\n>> Other than the minor frictions described above I don't see why \"bLIPs\"\n>> can't just be draft BOLTs.\n>>\n>> > Adding a third BIP editor more involved with Lightning sounds like a\n>> good idea.\n>>\n>> Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n>> would be a great additional BIP editor to cover Lightning related BIPs\n>> :) I think BOLTs being subsumed into BIPs would be nice but I'm\n>> pessimistic it will happen. Like legislation and regulation in the\n>> legacy financial system alphabet soups only expand they never get\n>> simplified. Let's at least resist alphabet soup expansion here.\n>>\n>> On Fri, Jul 2, 2021 at 9:01 AM Bastien TEINTURIER <bastien at acinq.fr>\n>> wrote:\n>> >>\n>> >> Will it actually add any more fragmentation that already exists? Due\n>> to all\n>> >> the extensibility we've added in the protocol, it's already possible\n>> for any\n>> >> implementation to start to work on their own sub-protocols. This just\n>> gives\n>> >> them a new venue to at least _describe_ what they're using.\n>> >\n>> >\n>> > It's only my 2 cents, but I'm afraid it will indeed add more\n>> fragmentation, because\n>> > the fact that there exists a bLIP for feature XXX will likely act as a\n>> green light to\n>> > deploy it faster instead of spending more time talking about it with\n>> the community\n>> > and thinking about potential issues, forward-compatibility, etc.\n>> >\n>> > But I agree with you that it also gives more freedom to experiment in\n>> the real world,\n>> > which helps find issues and correct them, paving the way for better\n>> features for\n>> > end users.\n>> >\n>> >> It's also likely the case that already implementations, or typically\n>> forks\n>> >> of implementations are already using \"undocumented\" TLVs or feature\n>> bits in\n>> >> the wild today.\n>> >\n>> >\n>> > But today we're usually very careful when we do that, and use numbers\n>> in high ranges\n>> > for these use-cases. In our case for example we use message type 35007\n>> for our\n>> > swap-in and we expect that to change once standardized, so we did extra\n>> work to\n>> > ensure we wouldn't paint ourselves into a corner when switching to a\n>> standard version.\n>> >\n>> > I think that if we have a centralized bLIP repo, we can take this\n>> opportunity to safely\n>> > assign \"final\" values for types and feature bits that are used by each\n>> bLIP, and stronger\n>> > guarantees that they will not conflict with another bLIP or BOLT. Of\n>> course that doesn't\n>> > stop anyone from deploying a conflict, but their use of the same bits\n>> won't be documented\n>> > so it shouldn't be widely deployed, and browsing the BOLTs and bLIPs\n>> should let anyone\n>> > see what the \"correct\" meaning of those bits should be.\n>> >\n>> > Cheers,\n>> > Bastien\n>> >\n>> >\n>> > Le jeu. 1 juil. 2021 \u00e0 22:43, Olaoluwa Osuntokun <laolu32 at gmail.com> a\n>> \u00e9crit :\n>> >>\n>> >> > But they don't address the first point at all, they instead work\n>> around\n>> >> > it.  To be fair, I don't think we can completely address that first\n>> point:\n>> >> > properly reviewing spec proposals takes a lot of effort and accepting\n>> >> > complex changes to the BOLTs shouldn't be done lightly.\n>> >>\n>> >> I think this is a fair characterization that I agree with. I also\n>> agree that\n>> >> there isn't really a way to fundamentally address it. The issue of\n>> scarce\n>> >> review resources is something just about any large open source project\n>> needs\n>> >> to deal with: everyone wants to make a PR, but no one wants to review\n>> the\n>> >> PRs of others, unless it scratches some tangential itch they may have.\n>> IMO\n>> >> it's also the case that the problem/solution space of LN is so large,\n>> that\n>> >> it's hard to expect every developer to review each new proposal that\n>> comes\n>> >> in, as they themselves have their own set of priorities (product,\n>> >> businesses, protocol, personal, etc).\n>> >>\n>> >> In the end though, I think when there've been critical items that\n>> affect all\n>> >> implementations and/or the existence of the protocol itself, developers\n>> >> typically band together to commit resources to help a proposal move\n>> forward.\n>> >> One upcoming example of this will be the \"base\" taproot channel type\n>> (the\n>> >> design space is pretty large in that it even permits a new type of\n>> symmetric\n>> >> state revocation-based channel).\n>> >>\n>> >> >  it will add fragmentation to the network, it will add maintenance\n>> costs\n>> >> >  and backwards-compatibility issues\n>> >>\n>> >> Will it actually add any more fragmentation that already exists? Due\n>> to all\n>> >> the extensibility we've added in the protocol, it's already possible\n>> for any\n>> >> implementation to start to work on their own sub-protocols. This just\n>> gives\n>> >> them a new venue to at least _describe_ what they're using. As usual,\n>> it's\n>> >> up to other implementations if they want to adopt it or not, or advise\n>> >> against its use.\n>> >>\n>> >> >  many bLIPs will be sub-optimal solutions to the problem they try to\n>> solve\n>> >> >  and some bLIPs will be simply insecure and may put users' funds at\n>> risk\n>> >> >  (L2 protocols are hard and have subtle issues that can be easily\n>> missed)\n>> >>\n>> >> This may be the case, but I guess at times it's hard to know if\n>> something is\n>> >> objectively sub-optimal without further exploration of the design\n>> space,\n>> >> which usually means either more people involved, or more time\n>> examining the\n>> >> problem. Ultimately, different wallets/implementations may also be\n>> willing\n>> >> to make different usability/security trade-offs. One example here is\n>> zero\n>> >> conf channels: they assume a greater degree of trust with the party\n>> you're\n>> >> _accepting_ the channel from, as if you receive funds over the\n>> channel, they\n>> >> can be double spent away. However it's undeniable that they improve\n>> the UX\n>> >> by reducing the amount of time a user needs to wait around before they\n>> can\n>> >> actually jump in and use LN.\n>> >>\n>> >> In the end though, there's no grand global committee that prevents\n>> people\n>> >> from deploying software they think is interesting or useful. In the\n>> long\n>> >> run, I guess one simply needs to hope that bad ideas die out, or speak\n>> out\n>> >> against them to the public. As LN sits a layer above the base protocol,\n>> >> widespread global consensus isn't really required to make certain\n>> classes of\n>> >> changes, and you can't stop people from experimenting on their own.\n>> >>\n>> >> > We can't have collisions on any of these three things.\n>> >>\n>> >> Yeah, collisions are def possible. IMO, this is where the interplay\n>> with\n>> >> BOLTs comes in: BOLTs are the global feature bit/tlv/message\n>> namespace.  A\n>> >> bLIP might come with the amendment of BOLT 9 to define feature bits\n>> they\n>> >> used. Of course, this should be done on a best effort basis, as even\n>> if you\n>> >> assign a bit for your idea, someone can just go ahead and deploy\n>> something\n>> >> else w/ that same bit, and they may never really intersect depending\n>> on the\n>> >> nature or how widespread the new feature is.\n>> >>\n>> >> It's also likely the case that already implementations, or typically\n>> forks\n>> >> of implementations are already using \"undocumented\" TLVs or feature\n>> bits in\n>> >> the wild today. I don't know exactly which TLV type things like\n>> applications\n>> >> that tunnel messages over the network use, but afaik so far there\n>> haven't\n>> >> been any disastrous collisions in the wild.\n>> >>\n>> >> -- Laolu\n>> >>\n>> >> On Thu, Jul 1, 2021 at 2:19 AM Bastien TEINTURIER <bastien at acinq.fr>\n>> wrote:\n>> >>>\n>> >>> Thanks for starting that discussion.\n>> >>>\n>> >>> In my opinion, what we're really trying to address here are the two\n>> following\n>> >>> points (at least from the point of view of someone who works on the\n>> spec and\n>> >>> an implementation):\n>> >>>\n>> >>> - Implementers get frustrated when they've worked on something that\n>> they think\n>> >>> is useful and they can't get it into the BOLTs (the spec PR isn't\n>> reviewed,\n>> >>> it progresses too slowly or there isn't enough agreement to merge it)\n>> >>> - Implementers expect other implementers to specify the optional\n>> features they\n>> >>> ship: we don't want to have to reverse-engineer a sub-protocol when\n>> users\n>> >>> want our implementation to provide support for feature XXX\n>> >>>\n>> >>> Note that these are two very different concerns.\n>> >>>\n>> >>> bLIPs/SPARKS/BIPs clearly address the second point, which is good.\n>> >>> But they don't address the first point at all, they instead work\n>> around it.\n>> >>> To be fair, I don't think we can completely address that first point:\n>> properly\n>> >>> reviewing spec proposals takes a lot of effort and accepting complex\n>> changes\n>> >>> to the BOLTs shouldn't be done lightly.\n>> >>>\n>> >>> I am mostly in favor of this solution, but I want to highlight that\n>> it isn't\n>> >>> only rainbows and unicorns: it will add fragmentation to the network,\n>> it will\n>> >>> add maintenance costs and backwards-compatibility issues, many bLIPs\n>> will be\n>> >>> sub-optimal solutions to the problem they try to solve and some bLIPs\n>> will be\n>> >>> simply insecure and may put users' funds at risk (L2 protocols are\n>> hard and have\n>> >>> subtle issues that can be easily missed). On the other hand, it\n>> allows for real\n>> >>> world experimentation and iteration, and it's easier to amend a bLIP\n>> than the\n>> >>> BOLTs.\n>> >>>\n>> >>> On the nuts-and-bolts (see the pun?) side, bLIPs cannot embrace a\n>> fully bazaar\n>> >>> style of evolution. Most of them will need:\n>> >>>\n>> >>> - to assign feature bit(s)\n>> >>> - to insert new tlv fields in existing messages\n>> >>> - to create new messages\n>> >>>\n>> >>> We can't have collisions on any of these three things. bLIP XXX\n>> cannot use the\n>> >>> same tlv types as bLIP YYY otherwise we're creating network\n>> incompatibilities.\n>> >>> So they really need to be centralized, and we need a process to\n>> assign these\n>> >>> and ensure they don't collide. It's not a hard problem, but we need\n>> to be clear\n>> >>> about the process around those.\n>> >>>\n>> >>> Regarding the details of where they live, I don't have a strong\n>> opinion, but I\n>> >>> think they must be easy to find and browse, and I think it's easier\n>> for readers\n>> >>> if they're inside the spec repository. We already have PRs that use a\n>> dedicated\n>> >>> \"proposals\" folder (e.g. [1], [2]).\n>> >>>\n>> >>> Cheers,\n>> >>> Bastien\n>> >>>\n>> >>> [1] https://github.com/lightningnetwork/lightning-rfc/pull/829\n>> >>> [2] https://github.com/lightningnetwork/lightning-rfc/pull/854\n>> >>>\n>> >>> Le jeu. 1 juil. 2021 \u00e0 02:31, Ariel Luaces <arielluaces at gmail.com> a\n>> \u00e9crit :\n>> >>>>\n>> >>>> BIPs are already the Bazaar style of evolution that simultaneously\n>> >>>> allows flexibility and coordination/interoperability (since anyone\n>> can\n>> >>>> create a BIP and they create an environment of discussion).\n>> >>>>\n>> >>>> BOLTs are essentially one big BIP in the sense that they started as a\n>> >>>> place for discussion but are now more rigid. BOLTs must be followed\n>> >>>> strictly to ensure a node is interoperable with the network. And\n>> BOLTs\n>> >>>> should be rigid, as rigid as any widely used BIP like 32 for example.\n>> >>>> Even though BOLTs were flexible when being drafted their purpose has\n>> >>>> changed from descriptive to prescriptive.\n>> >>>> Any alternatives, or optional features should be extracted out of\n>> >>>> BOLTs, written as BIPs. The BIP should then reference the BOLT and\n>> the\n>> >>>> required flags set, messages sent, or alterations made to signal that\n>> >>>> the BIP's feature is enabled.\n>> >>>>\n>> >>>> A BOLT may at some point organically change to reference a BIP. For\n>> >>>> example if a BIP was drafted as an optional feature but then becomes\n>> >>>> more widespread and then turns out to be crucial for the proper\n>> >>>> operation of the network then a BOLT can be changed to just reference\n>> >>>> the BIP as mandatory. There isn't anything wrong with this.\n>> >>>>\n>> >>>> All of the above would work exactly the same if there was a bLIP\n>> >>>> repository instead. I don't see the value in having both bLIPs and\n>> >>>> BIPs since AFAICT they seem to be functionally equivalent and BIPs\n>> are\n>> >>>> not restricted to exclude lightning, and never have been.\n>> >>>>\n>> >>>> I believe the reason this move to BIPs hasn't happened organically is\n>> >>>> because many still perceive the BOLTs available for editing, so\n>> >>>> changes continue to be made. If instead BOLTs were perceived as more\n>> >>>> \"consensus critical\", not subject to change, and more people were\n>> >>>> strongly encouraged to write specs for new lightning features\n>> >>>> elsewhere (like the BIP repo) then you would see this issue of\n>> growing\n>> >>>> BOLTs resolved.\n>> >>>>\n>> >>>> Cheers\n>> >>>> Ariel Lorenzo-Luaces\n>> >>>>\n>> >>>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <\n>> laolu32 at gmail.com> wrote:\n>> >>>> >\n>> >>>> > > That being said I think all the points that are addressed in\n>> Ryan's mail\n>> >>>> > > could very well be formalized into BOLTs but maybe we just need\n>> to rethink\n>> >>>> > > the current process of the BOLTs to make it more accessible for\n>> new ideas\n>> >>>> > > to find their way into the BOLTs?\n>> >>>> >\n>> >>>> > I think part of what bLIPs are trying to solve here is promoting\n>> more loosely\n>> >>>> > coupled evolution of the network. I think the BOLTs do a good job\n>> currently of\n>> >>>> > specifying what _base_ functionality is required for a routing\n>> node in a\n>> >>>> > prescriptive manner (you must forward an HTLC like this, etc).\n>> However there's\n>> >>>> > a rather large gap in describing functionality that has emerged\n>> over time due\n>> >>>> > to progressive evolution, and aren't absolutely necessary, but\n>> enhance\n>> >>>> > node/wallet operation.\n>> >>>> >\n>> >>>> > Examples of  include things like: path finding heuristics (BOLTs\n>> just say you\n>> >>>> > should get from Alice to Bob, but provides no recommendations\n>> w.r.t _how_ to do\n>> >>>> > so), fee bumping heuristics, breach retribution handling, channel\n>> management,\n>> >>>> > rebalancing, custom records usage (like the podcast index\n>> meta-data, messaging,\n>> >>>> > etc), JIT channel opening, hosted channels, randomized channel\n>> IDs, fee\n>> >>>> > optimization, initial channel boostrapping, etc.\n>> >>>> >\n>> >>>> > All these examples are effectively optional as they aren't\n>> required for base\n>> >>>> > node operation, but they've organically evolved over time as node\n>> >>>> > implementations and wallet seek to solve UX and operational\n>> problems for\n>> >>>> > their users. bLIPs can be a _descriptive_ (this is how things can\n>> be done)\n>> >>>> > home for these types of standards, while BOLTs can be reserved for\n>> >>>> > _prescriptive_ measures (an HTLC looks like this, etc).\n>> >>>> >\n>> >>>> > The protocol as implemented today has a number of extensions\n>> (TLVs, message\n>> >>>> > types, feature bits, etc) that allow implementations to spin out\n>> their own\n>> >>>> > sub-protocols, many of which won't be considered absolutely\n>> necessary for node\n>> >>>> > operation. IMO we should embrace more of a \"bazaar\" style of\n>> evolution, and\n>> >>>> > acknowledge that loosely coupled evolution allows participants to\n>> more broadly\n>> >>>> > explore the design space, without the constraints of \"it isn't a\n>> thing until N\n>> >>>> > of us start to do it\".\n>> >>>> >\n>> >>>> > Historically, BOLTs have also had a rather monolithic structure.\n>> We've used\n>> >>>> > the same 11 or so documents for the past few years with the size\n>> of the\n>> >>>> > documents swelling over time with new exceptions, features,\n>> requirements,\n>> >>>> > etc. If you were hired to work on a new codebase and saw that\n>> everything is\n>> >>>> > defined in 11 \"functions\" that have been growing linearly over\n>> time, you'd\n>> >>>> > probably declare the codebase as being unmaintainable. By having\n>> distinct\n>> >>>> > documents for proposals/standards, bLIPs (author documents\n>> really), each new\n>> >>>> > standard/proposal is able to be more effectively explained,\n>> motivated, versionsed,\n>> >>>> > etc.\n>> >>>> >\n>> >>>> > -- Laolu\n>> >>>> >\n>> >>>> >\n>> >>>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n>> lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>>> >>\n>> >>>> >> Hey everyone,\n>> >>>> >>\n>> >>>> >> just for reference when I was new here (and did not understand\n>> the processes well enough) I proposed a similar idea (called LIP) in 2018\n>> c.f.:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>> >>>> >>\n>> >>>> >> I wonder what exactly has changed in the reasoning by roasbeef\n>> which I will repeat here:\n>> >>>> >>\n>> >>>> >> > We already have the equiv of improvement proposals: BOLTs.\n>> Historically\n>> >>>> >>\n>> >>>> >> > new standardization documents are proposed initially as issues\n>> or PR's when\n>> >>>> >>\n>> >>>> >> > ultimately accepted. Why do we need another repo?\n>> >>>> >>\n>> >>>> >>\n>> >>>> >> As far as I can tell there was always some form of (invisible?)\n>> barrier to participate in the BOLTs but there are also new BOLTs being\n>> offered:\n>> >>>> >> * BOLT 12:\n>> https://github.com/lightningnetwork/lightning-rfc/pull/798\n>> >>>> >> * BOLT 14:\n>> https://github.com/lightningnetwork/lightning-rfc/pull/780\n>> >>>> >> and topics to be included like:\n>> >>>> >> * dual funding\n>> >>>> >> * splicing\n>> >>>> >> * the examples given by Ryan\n>> >>>> >>\n>> >>>> >> I don't see how a new repo would reduce that barrier - Actually I\n>> think it would even create more confusion as I for example would not know\n>> where something belongs. That being said I think all the points that are\n>> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n>> we just need to rethink the current process of the BOLTs to make it more\n>> accessible for new ideas to find their way into the BOLTs? One thing that I\n>> can say from answering lightning-network questions on stackexchange is that\n>> it would certainly help if the BOLTs where referenced  on lightning.network\n>> web page and in the whitepaper as the place to be if one wants to learn\n>> about the Lightning Network\n>> >>>> >>\n>> >>>> >> with kind regards Rene\n>> >>>> >>\n>> >>>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n>> lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>>> >>>\n>> >>>> >>> Hi all,\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> The recent thread around zero-conf channels [1] provides an\n>> opportunity to discuss how the BOLT process handles features and best\n>> practices that arise in the wild vs. originating within the process itself.\n>> Zero-conf channels are one of many LN innovations on the app layer that\n>> have struggled to make their way into the spec. John Carvalho and Bitrefill\n>> launched Turbo channels in April 2019 [2], Breez posted their solution to\n>> the mailing list for feedback in August 2020 [3], and we know at least\n>> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n>> world there would be a descriptive design document that the app layer\n>> implementers had collaborated on over the years that the spec group could\n>> then pick up and merge into the BOLTs now that the feature is deemed\n>> spec-worthy.\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> Over the last couple of months, we have discussed the idea of\n>> adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with\n>> various members of the community, and have received positive feedback from\n>> both app layer and protocol devs. This would not affect the existing BOLT\n>> process at all, but simply add a place for app layer best practices to be\n>> succinctly described and organized, especially those that require\n>> coordination. These features are being built outside of the BOLT process\n>> today anyways, so ideally a bLIP process would bring them into the fold\n>> instead of leaving them buried in old ML posts or not documented at all.\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> Some potential bLIP ideas that people have mentioned include:\n>> each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments,\n>> podcast payment metadata, p2p messaging formats, new pathfinding\n>> heuristics, remote node connection standards, etc.\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> If the community is interested in moving forward, we've started\n>> a branch [5] describing such a process. It's based on BIP-0002, so not\n>> trying to reinvent any wheels. It would be great to have developers from\n>> various implementations and from the broader app layer ecosystem volunteer\n>> to be listed as editors (basically the same role as in the BIPs).\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> Looking forward to hearing your thoughts!\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> Best,\n>> >>>> >>> Ryan\n>> >>>> >>>\n>> >>>> >>>\n>> >>>> >>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>> >>>> >>>\n>> >>>> >>> [2]\n>> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>> >>>> >>>\n>> >>>> >>> [3]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>> >>>> >>>\n>> >>>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n>> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>> >>>> >>>\n>> >>>> >>> [5]\n>> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>> >>>> >>>\n>> >>>> >>> _______________________________________________\n>> >>>> >>> Lightning-dev mailing list\n>> >>>> >>> Lightning-dev at lists.linuxfoundation.org\n>> >>>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>>> >>\n>> >>>> >>\n>> >>>> >>\n>> >>>> >> --\n>> >>>> >> https://www.rene-pickhardt.de\n>> >>>> >> _______________________________________________\n>> >>>> >> Lightning-dev mailing list\n>> >>>> >> Lightning-dev at lists.linuxfoundation.org\n>> >>>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>>> >\n>> >>>> > _______________________________________________\n>> >>>> > Lightning-dev mailing list\n>> >>>> > Lightning-dev at lists.linuxfoundation.org\n>> >>>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>>> _______________________________________________\n>> >>>> Lightning-dev mailing list\n>> >>>> Lightning-dev at lists.linuxfoundation.org\n>> >>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>>\n>> >>> _______________________________________________\n>> >>> Lightning-dev mailing list\n>> >>> Lightning-dev at lists.linuxfoundation.org\n>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>>\n>> --\n>> Michael Folkson\n>> Email: michaelfolkson at gmail.com\n>> Keybase: michaelfolkson\n>> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210707/144453c3/attachment-0001.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2021-07-10T01:48:04",
                "message_text_only": "On Fri, Jul 02, 2021 at 02:20:51PM -0400, Antoine Riard wrote:\n> More personally, I feel it would be better if such a new specification\n> process doesn't completely share the same communication infrastructure as\n> the BOLTs, like [avoiding] having them in the same repository. \n\nIn addition to Antoine's perception-based concern, I think an additional\nproblem with keeping both BOLTs and BLIPs in the same repository is that\nthere's no easy way for contributors to subscribe to only a subset of\nissues and PRs.  E.g., if Alice is only interested in BOLTs and she\nclicks the GitHub Watch Repository button, she'll receive notifications\nfor issues and PRs about BLIPs that she's not interested in; vice-versa\nfor Bob who's only interested in BLIPs.\n\nIf you still think it's desirable to keep BOLTs and BLIPs in the same\nsource tree, you could maybe consider the monotree approach that\noriginated with the Linux kernel project (AFAIK) and which the Bitcoin\nCore project began experimenting with about a year ago[1] (to moderate\nsuccess AFAICT).\n\n-Dave\n\n[1] https://bitcoinops.org/en/newsletters/2020/06/24/#bitcoin-core-19071\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210709/ed66f453/attachment.sig>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-07-01T10:38:46",
                "message_text_only": "Here's another feature which just appeared and would benefit from a\nbLIP for compatibility:\nhttps://twitter.com/SimpleBtcWallet/status/1410506889545359365\n\nAtomic splitting of bills. A very small thing, but also very cool. I\ncan't imagine it fitting in the BOLTs at all.\n\n2021-06-30 09:10 (GMT-05:00), Ryan Gentry via Lightning-dev\n<lightning-dev at lists.linuxfoundation.org> said:\n> Hi all,\n> The recent thread around zero-conf channels [1] provides an opportunity to\n> discuss how the BOLT process handles features and best practices that arise in\n> the wild vs. originating within the process itself. Zero-conf channels are one\n> of many LN innovations on the app layer that have struggled to make their way\n> into the spec. John Carvalho and Bitrefill launched Turbo channels in April\n> 2019 [2], Breez posted their solution to the mailing list for feedback in\n> August 2020 [3], and we know at least ACINQ and Muun (amongst others) have\n> their own implementations. In an ideal world there would be a descriptive\n> design document that the app layer implementers had collaborated on over the\n> years that the spec group could then pick up and merge into the BOLTs now that\n> the feature is deemed spec-worthy.\n> Over the last couple of months, we have discussed the idea of adding a\n> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various members\n> of the community, and have received positive feedback from both app layer and\n> protocol devs. This would not affect the existing BOLT process at all, but\n> simply add a place for app layer best practices to be succinctly described and\n> organized, especially those that require coordination. These features are being\n> built outside of the BOLT process today anyways, so ideally a bLIP process\n> would bring them into the fold instead of leaving them buried in old ML posts\n> or not documented at all.\n> Some potential bLIP ideas that people have mentioned include: each lnurl\n> variant, on-the-fly channel opens, AMP, dynamic commitments, podcast payment\n> metadata, p2p messaging formats, new pathfinding heuristics, remote node\n> connection standards, etc.\n> If the community is interested in moving forward, we've started a branch [5]\n> describing such a process. It's based on BIP-0002, so not trying to reinvent\n> any wheels. It would be great to have developers from various implementations\n> and from the broader app layer ecosystem volunteer to be listed as editors\n> (basically the same role as in the BIPs).\n> Looking forward to hearing your thoughts!\n> Best,\n> Ryan\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK = Standardization\n> of Protocols at the Request of the Kommunity (h/t fiatjaf)\n> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki_______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-07-01T20:25:23",
                "message_text_only": "> BIPs are already the Bazaar style of evolution that simultaneously\n> allows flexibility and coordination/interoperability (since anyone can\ncreate a\n> BIP and they create an environment of discussion).\n\nThe answer to why not BIPs here applies to BOLTs as well, as bLIPs are\nintended to effectively be nested under the BOLT umbrella (same repo, etc).\nIt's also the case that any document can be mirrored as a BIP, this has been\nsuggested before, but the BIP editors have decided not to do so.\n\nbLIPs have a slightly different process than BIPs, as well as a different\nset\nof editors/maintainers (more widely distributed). As we saw with the Speedy\nTrial saga (fingers crossed), the sole (?) maintainer of the BIP process was\nable to effectively steelman the progression of an author document, with no\nsound technical objection (they had a competing proposal that could've been\na distinct document). bLIPs sidestep shenanigans like this by having the\nprimary maintainer/editors be more widely distributed and closer to the\ntarget domain (LN).\n\nThe other thing bLIPs do is do away with the whole \"human picks the number\nof documents\", and \"don't assign your own number, you must wait\". Borrowing\nfrom EIPs, the number of a document is simply the number of the PR that\nproposes the document. This reduces friction, and eliminates a possible\nbikeshedding vector.\n\n-- Laolu\n\n\nOn Wed, Jun 30, 2021 at 5:31 PM Ariel Luaces <arielluaces at gmail.com> wrote:\n\n> BIPs are already the Bazaar style of evolution that simultaneously\n> allows flexibility and coordination/interoperability (since anyone can\n> create a BIP and they create an environment of discussion).\n>\n> BOLTs are essentially one big BIP in the sense that they started as a\n> place for discussion but are now more rigid. BOLTs must be followed\n> strictly to ensure a node is interoperable with the network. And BOLTs\n> should be rigid, as rigid as any widely used BIP like 32 for example.\n> Even though BOLTs were flexible when being drafted their purpose has\n> changed from descriptive to prescriptive.\n> Any alternatives, or optional features should be extracted out of\n> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n> required flags set, messages sent, or alterations made to signal that\n> the BIP's feature is enabled.\n>\n> A BOLT may at some point organically change to reference a BIP. For\n> example if a BIP was drafted as an optional feature but then becomes\n> more widespread and then turns out to be crucial for the proper\n> operation of the network then a BOLT can be changed to just reference\n> the BIP as mandatory. There isn't anything wrong with this.\n>\n> All of the above would work exactly the same if there was a bLIP\n> repository instead. I don't see the value in having both bLIPs and\n> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n> not restricted to exclude lightning, and never have been.\n>\n> I believe the reason this move to BIPs hasn't happened organically is\n> because many still perceive the BOLTs available for editing, so\n> changes continue to be made. If instead BOLTs were perceived as more\n> \"consensus critical\", not subject to change, and more people were\n> strongly encouraged to write specs for new lightning features\n> elsewhere (like the BIP repo) then you would see this issue of growing\n> BOLTs resolved.\n>\n> Cheers\n> Ariel Lorenzo-Luaces\n>\n> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> wrote:\n> >\n> > > That being said I think all the points that are addressed in Ryan's\n> mail\n> > > could very well be formalized into BOLTs but maybe we just need to\n> rethink\n> > > the current process of the BOLTs to make it more accessible for new\n> ideas\n> > > to find their way into the BOLTs?\n> >\n> > I think part of what bLIPs are trying to solve here is promoting more\n> loosely\n> > coupled evolution of the network. I think the BOLTs do a good job\n> currently of\n> > specifying what _base_ functionality is required for a routing node in a\n> > prescriptive manner (you must forward an HTLC like this, etc). However\n> there's\n> > a rather large gap in describing functionality that has emerged over\n> time due\n> > to progressive evolution, and aren't absolutely necessary, but enhance\n> > node/wallet operation.\n> >\n> > Examples of  include things like: path finding heuristics (BOLTs just\n> say you\n> > should get from Alice to Bob, but provides no recommendations w.r.t\n> _how_ to do\n> > so), fee bumping heuristics, breach retribution handling, channel\n> management,\n> > rebalancing, custom records usage (like the podcast index meta-data,\n> messaging,\n> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n> > optimization, initial channel boostrapping, etc.\n> >\n> > All these examples are effectively optional as they aren't required for\n> base\n> > node operation, but they've organically evolved over time as node\n> > implementations and wallet seek to solve UX and operational problems for\n> > their users. bLIPs can be a _descriptive_ (this is how things can be\n> done)\n> > home for these types of standards, while BOLTs can be reserved for\n> > _prescriptive_ measures (an HTLC looks like this, etc).\n> >\n> > The protocol as implemented today has a number of extensions (TLVs,\n> message\n> > types, feature bits, etc) that allow implementations to spin out their\n> own\n> > sub-protocols, many of which won't be considered absolutely necessary\n> for node\n> > operation. IMO we should embrace more of a \"bazaar\" style of evolution,\n> and\n> > acknowledge that loosely coupled evolution allows participants to more\n> broadly\n> > explore the design space, without the constraints of \"it isn't a thing\n> until N\n> > of us start to do it\".\n> >\n> > Historically, BOLTs have also had a rather monolithic structure. We've\n> used\n> > the same 11 or so documents for the past few years with the size of the\n> > documents swelling over time with new exceptions, features, requirements,\n> > etc. If you were hired to work on a new codebase and saw that everything\n> is\n> > defined in 11 \"functions\" that have been growing linearly over time,\n> you'd\n> > probably declare the codebase as being unmaintainable. By having distinct\n> > documents for proposals/standards, bLIPs (author documents really), each\n> new\n> > standard/proposal is able to be more effectively explained, motivated,\n> versionsed,\n> > etc.\n> >\n> > -- Laolu\n> >\n> >\n> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>\n> >> Hey everyone,\n> >>\n> >> just for reference when I was new here (and did not understand the\n> processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n> >>\n> >> I wonder what exactly has changed in the reasoning by roasbeef which I\n> will repeat here:\n> >>\n> >> > We already have the equiv of improvement proposals: BOLTs.\n> Historically\n> >>\n> >> > new standardization documents are proposed initially as issues or\n> PR's when\n> >>\n> >> > ultimately accepted. Why do we need another repo?\n> >>\n> >>\n> >> As far as I can tell there was always some form of (invisible?) barrier\n> to participate in the BOLTs but there are also new BOLTs being offered:\n> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> >> and topics to be included like:\n> >> * dual funding\n> >> * splicing\n> >> * the examples given by Ryan\n> >>\n> >> I don't see how a new repo would reduce that barrier - Actually I think\n> it would even create more confusion as I for example would not know where\n> something belongs. That being said I think all the points that are\n> addressed in Ryan's mail could very well be formalized into BOLTs but maybe\n> we just need to rethink the current process of the BOLTs to make it more\n> accessible for new ideas to find their way into the BOLTs? One thing that I\n> can say from answering lightning-network questions on stackexchange is that\n> it would certainly help if the BOLTs where referenced  on lightning.network\n> web page and in the whitepaper as the place to be if one wants to learn\n> about the Lightning Network\n> >>\n> >> with kind regards Rene\n> >>\n> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> >>>\n> >>> Hi all,\n> >>>\n> >>>\n> >>> The recent thread around zero-conf channels [1] provides an\n> opportunity to discuss how the BOLT process handles features and best\n> practices that arise in the wild vs. originating within the process itself.\n> Zero-conf channels are one of many LN innovations on the app layer that\n> have struggled to make their way into the spec. John Carvalho and Bitrefill\n> launched Turbo channels in April 2019 [2], Breez posted their solution to\n> the mailing list for feedback in August 2020 [3], and we know at least\n> ACINQ and Muun (amongst others) have their own implementations. In an ideal\n> world there would be a descriptive design document that the app layer\n> implementers had collaborated on over the years that the spec group could\n> then pick up and merge into the BOLTs now that the feature is deemed\n> spec-worthy.\n> >>>\n> >>>\n> >>> Over the last couple of months, we have discussed the idea of adding a\n> BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n> members of the community, and have received positive feedback from both app\n> layer and protocol devs. This would not affect the existing BOLT process at\n> all, but simply add a place for app layer best practices to be succinctly\n> described and organized, especially those that require coordination. These\n> features are being built outside of the BOLT process today anyways, so\n> ideally a bLIP process would bring them into the fold instead of leaving\n> them buried in old ML posts or not documented at all.\n> >>>\n> >>>\n> >>> Some potential bLIP ideas that people have mentioned include: each\n> lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast\n> payment metadata, p2p messaging formats, new pathfinding heuristics, remote\n> node connection standards, etc.\n> >>>\n> >>>\n> >>> If the community is interested in moving forward, we've started a\n> branch [5] describing such a process. It's based on BIP-0002, so not trying\n> to reinvent any wheels. It would be great to have developers from various\n> implementations and from the broader app layer ecosystem volunteer to be\n> listed as editors (basically the same role as in the BIPs).\n> >>>\n> >>>\n> >>> Looking forward to hearing your thoughts!\n> >>>\n> >>>\n> >>> Best,\n> >>> Ryan\n> >>>\n> >>>\n> >>> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n> >>>\n> >>> [2]\n> https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n> >>>\n> >>> [3]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n> >>>\n> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n> >>>\n> >>> [5]\n> https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n> >>>\n> >>> _______________________________________________\n> >>> Lightning-dev mailing list\n> >>> Lightning-dev at lists.linuxfoundation.org\n> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >>\n> >>\n> >>\n> >> --\n> >> https://www.rene-pickhardt.de\n> >> _______________________________________________\n> >> Lightning-dev mailing list\n> >> Lightning-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210701/b6a01bed/attachment-0001.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2021-07-02T02:28:40",
                "message_text_only": "BOLTs should be BIPs too. Ideally, the authors should be the ones to migrate \nthem, but mirroring is fine - just nobody's taken the time to do it yet.\n\nPlease stop promoting lies about the BIP repo. I did not \"steelman\" anything.\n\nAdding a third BIP editor more involved with Lightning sounds like a good \nidea.\n\n\n\nOn Thursday 01 July 2021 20:25:23 Olaoluwa Osuntokun wrote:\n> > BIPs are already the Bazaar style of evolution that simultaneously\n> > allows flexibility and coordination/interoperability (since anyone can\n>\n> create a\n>\n> > BIP and they create an environment of discussion).\n>\n> The answer to why not BIPs here applies to BOLTs as well, as bLIPs are\n> intended to effectively be nested under the BOLT umbrella (same repo, etc).\n> It's also the case that any document can be mirrored as a BIP, this has\n> been suggested before, but the BIP editors have decided not to do so.\n>\n> bLIPs have a slightly different process than BIPs, as well as a different\n> set\n> of editors/maintainers (more widely distributed). As we saw with the Speedy\n> Trial saga (fingers crossed), the sole (?) maintainer of the BIP process\n> was able to effectively steelman the progression of an author document,\n> with no sound technical objection (they had a competing proposal that\n> could've been a distinct document). bLIPs sidestep shenanigans like this by\n> having the primary maintainer/editors be more widely distributed and closer\n> to the target domain (LN).\n>\n> The other thing bLIPs do is do away with the whole \"human picks the number\n> of documents\", and \"don't assign your own number, you must wait\". Borrowing\n> from EIPs, the number of a document is simply the number of the PR that\n> proposes the document. This reduces friction, and eliminates a possible\n> bikeshedding vector.\n>\n> -- Laolu\n>\n> On Wed, Jun 30, 2021 at 5:31 PM Ariel Luaces <arielluaces at gmail.com> wrote:\n> > BIPs are already the Bazaar style of evolution that simultaneously\n> > allows flexibility and coordination/interoperability (since anyone can\n> > create a BIP and they create an environment of discussion).\n> >\n> > BOLTs are essentially one big BIP in the sense that they started as a\n> > place for discussion but are now more rigid. BOLTs must be followed\n> > strictly to ensure a node is interoperable with the network. And BOLTs\n> > should be rigid, as rigid as any widely used BIP like 32 for example.\n> > Even though BOLTs were flexible when being drafted their purpose has\n> > changed from descriptive to prescriptive.\n> > Any alternatives, or optional features should be extracted out of\n> > BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n> > required flags set, messages sent, or alterations made to signal that\n> > the BIP's feature is enabled.\n> >\n> > A BOLT may at some point organically change to reference a BIP. For\n> > example if a BIP was drafted as an optional feature but then becomes\n> > more widespread and then turns out to be crucial for the proper\n> > operation of the network then a BOLT can be changed to just reference\n> > the BIP as mandatory. There isn't anything wrong with this.\n> >\n> > All of the above would work exactly the same if there was a bLIP\n> > repository instead. I don't see the value in having both bLIPs and\n> > BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n> > not restricted to exclude lightning, and never have been.\n> >\n> > I believe the reason this move to BIPs hasn't happened organically is\n> > because many still perceive the BOLTs available for editing, so\n> > changes continue to be made. If instead BOLTs were perceived as more\n> > \"consensus critical\", not subject to change, and more people were\n> > strongly encouraged to write specs for new lightning features\n> > elsewhere (like the BIP repo) then you would see this issue of growing\n> > BOLTs resolved.\n> >\n> > Cheers\n> > Ariel Lorenzo-Luaces\n> >\n> > On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com>\n> >\n> > wrote:\n> > > > That being said I think all the points that are addressed in Ryan's\n> >\n> > mail\n> >\n> > > > could very well be formalized into BOLTs but maybe we just need to\n> >\n> > rethink\n> >\n> > > > the current process of the BOLTs to make it more accessible for new\n> >\n> > ideas\n> >\n> > > > to find their way into the BOLTs?\n> > >\n> > > I think part of what bLIPs are trying to solve here is promoting more\n> >\n> > loosely\n> >\n> > > coupled evolution of the network. I think the BOLTs do a good job\n> >\n> > currently of\n> >\n> > > specifying what _base_ functionality is required for a routing node in\n> > > a prescriptive manner (you must forward an HTLC like this, etc).\n> > > However\n> >\n> > there's\n> >\n> > > a rather large gap in describing functionality that has emerged over\n> >\n> > time due\n> >\n> > > to progressive evolution, and aren't absolutely necessary, but enhance\n> > > node/wallet operation.\n> > >\n> > > Examples of  include things like: path finding heuristics (BOLTs just\n> >\n> > say you\n> >\n> > > should get from Alice to Bob, but provides no recommendations w.r.t\n> >\n> > _how_ to do\n> >\n> > > so), fee bumping heuristics, breach retribution handling, channel\n> >\n> > management,\n> >\n> > > rebalancing, custom records usage (like the podcast index meta-data,\n> >\n> > messaging,\n> >\n> > > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n> > > optimization, initial channel boostrapping, etc.\n> > >\n> > > All these examples are effectively optional as they aren't required for\n> >\n> > base\n> >\n> > > node operation, but they've organically evolved over time as node\n> > > implementations and wallet seek to solve UX and operational problems\n> > > for their users. bLIPs can be a _descriptive_ (this is how things can\n> > > be\n> >\n> > done)\n> >\n> > > home for these types of standards, while BOLTs can be reserved for\n> > > _prescriptive_ measures (an HTLC looks like this, etc).\n> > >\n> > > The protocol as implemented today has a number of extensions (TLVs,\n> >\n> > message\n> >\n> > > types, feature bits, etc) that allow implementations to spin out their\n> >\n> > own\n> >\n> > > sub-protocols, many of which won't be considered absolutely necessary\n> >\n> > for node\n> >\n> > > operation. IMO we should embrace more of a \"bazaar\" style of evolution,\n> >\n> > and\n> >\n> > > acknowledge that loosely coupled evolution allows participants to more\n> >\n> > broadly\n> >\n> > > explore the design space, without the constraints of \"it isn't a thing\n> >\n> > until N\n> >\n> > > of us start to do it\".\n> > >\n> > > Historically, BOLTs have also had a rather monolithic structure. We've\n> >\n> > used\n> >\n> > > the same 11 or so documents for the past few years with the size of the\n> > > documents swelling over time with new exceptions, features,\n> > > requirements, etc. If you were hired to work on a new codebase and saw\n> > > that everything\n> >\n> > is\n> >\n> > > defined in 11 \"functions\" that have been growing linearly over time,\n> >\n> > you'd\n> >\n> > > probably declare the codebase as being unmaintainable. By having\n> > > distinct documents for proposals/standards, bLIPs (author documents\n> > > really), each\n> >\n> > new\n> >\n> > > standard/proposal is able to be more effectively explained, motivated,\n> >\n> > versionsed,\n> >\n> > > etc.\n> > >\n> > > -- Laolu\n> > >\n> > >\n> > > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <\n> >\n> > lightning-dev at lists.linuxfoundation.org> wrote:\n> > >> Hey everyone,\n> > >>\n> > >> just for reference when I was new here (and did not understand the\n> >\n> > processes well enough) I proposed a similar idea (called LIP) in 2018\n> > c.f.:\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/00136\n> >7.html\n> >\n> > >> I wonder what exactly has changed in the reasoning by roasbeef which I\n> >\n> > will repeat here:\n> > >> > We already have the equiv of improvement proposals: BOLTs.\n> >\n> > Historically\n> >\n> > >> > new standardization documents are proposed initially as issues or\n> >\n> > PR's when\n> >\n> > >> > ultimately accepted. Why do we need another repo?\n> > >>\n> > >> As far as I can tell there was always some form of (invisible?)\n> > >> barrier\n> >\n> > to participate in the BOLTs but there are also new BOLTs being offered:\n> > >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n> > >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> > >> and topics to be included like:\n> > >> * dual funding\n> > >> * splicing\n> > >> * the examples given by Ryan\n> > >>\n> > >> I don't see how a new repo would reduce that barrier - Actually I\n> > >> think\n> >\n> > it would even create more confusion as I for example would not know where\n> > something belongs. That being said I think all the points that are\n> > addressed in Ryan's mail could very well be formalized into BOLTs but\n> > maybe we just need to rethink the current process of the BOLTs to make it\n> > more accessible for new ideas to find their way into the BOLTs? One thing\n> > that I can say from answering lightning-network questions on\n> > stackexchange is that it would certainly help if the BOLTs where\n> > referenced  on lightning.network web page and in the whitepaper as the\n> > place to be if one wants to learn about the Lightning Network\n> >\n> > >> with kind regards Rene\n> > >>\n> > >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <\n> >\n> > lightning-dev at lists.linuxfoundation.org> wrote:\n> > >>> Hi all,\n> > >>>\n> > >>>\n> > >>> The recent thread around zero-conf channels [1] provides an\n> >\n> > opportunity to discuss how the BOLT process handles features and best\n> > practices that arise in the wild vs. originating within the process\n> > itself. Zero-conf channels are one of many LN innovations on the app\n> > layer that have struggled to make their way into the spec. John Carvalho\n> > and Bitrefill launched Turbo channels in April 2019 [2], Breez posted\n> > their solution to the mailing list for feedback in August 2020 [3], and\n> > we know at least ACINQ and Muun (amongst others) have their own\n> > implementations. In an ideal world there would be a descriptive design\n> > document that the app layer implementers had collaborated on over the\n> > years that the spec group could then pick up and merge into the BOLTs now\n> > that the feature is deemed spec-worthy.\n> >\n> > >>> Over the last couple of months, we have discussed the idea of adding\n> > >>> a\n> >\n> > BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various\n> > members of the community, and have received positive feedback from both\n> > app layer and protocol devs. This would not affect the existing BOLT\n> > process at all, but simply add a place for app layer best practices to be\n> > succinctly described and organized, especially those that require\n> > coordination. These features are being built outside of the BOLT process\n> > today anyways, so ideally a bLIP process would bring them into the fold\n> > instead of leaving them buried in old ML posts or not documented at all.\n> >\n> > >>> Some potential bLIP ideas that people have mentioned include: each\n> >\n> > lnurl variant, on-the-fly channel opens, AMP, dynamic commitments,\n> > podcast payment metadata, p2p messaging formats, new pathfinding\n> > heuristics, remote node connection standards, etc.\n> >\n> > >>> If the community is interested in moving forward, we've started a\n> >\n> > branch [5] describing such a process. It's based on BIP-0002, so not\n> > trying to reinvent any wheels. It would be great to have developers from\n> > various implementations and from the broader app layer ecosystem\n> > volunteer to be listed as editors (basically the same role as in the\n> > BIPs).\n> >\n> > >>> Looking forward to hearing your thoughts!\n> > >>>\n> > >>>\n> > >>> Best,\n> > >>> Ryan\n> > >>>\n> > >>>\n> > >>> [1]\n> >\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/00307\n> >4.html\n> >\n> > >>> [2]\n> >\n> > https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-\n> >bitcoins-lightning-faster\n> >\n> > >>> [3]\n> >\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002\n> >780.html\n> >\n> > >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK =\n> >\n> > Standardization of Protocols at the Request of the Kommunity (h/t\n> > fiatjaf)\n> >\n> > >>> [5]\n> >\n> > https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-\n> >0001.mediawiki\n> >\n> > >>> _______________________________________________\n> > >>> Lightning-dev mailing list\n> > >>> Lightning-dev at lists.linuxfoundation.org\n> > >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > >>\n> > >> --\n> > >> https://www.rene-pickhardt.de\n> > >> _______________________________________________\n> > >> Lightning-dev mailing list\n> > >> Lightning-dev at lists.linuxfoundation.org\n> > >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > >\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Ariel Luaces",
                "date": "2021-07-02T05:39:44",
                "message_text_only": "> bLIPs have a slightly different process than BIPs, as well as a different set\n> of editors/maintainers (more widely distributed). As we saw with the Speedy\n> Trial saga (fingers crossed), the sole (?) maintainer of the BIP process was\n> able to effectively steelman the progression of an author document, with no\n> sound technical objection (they had a competing proposal that could've been\n> a distinct document). bLIPs sidestep shenanigans like this by having the\n> primary maintainer/editors be more widely distributed and closer to the\n> target domain (LN).\n\nThat's fair. The BIP repository as a whole lost credibility when the\nsole maintainer at the time steelmanned progress for no good reason.\nIt was done in bad faith and no steps were taken to remove even the\n*perception* of impropriety.\nI hope the maintainers of the bLIP repository can be more impartial.\n\nThe automatic assignment of proposal numbers is an excellent\nimprovement. It's an idea that the BIP repo should adopt since it\nremoves responsibility and power from the maintainers.\n\n>\n> The other thing bLIPs do is do away with the whole \"human picks the number\n> of documents\", and \"don't assign your own number, you must wait\". Borrowing\n> from EIPs, the number of a document is simply the number of the PR that\n> proposes the document. This reduces friction, and eliminates a possible\n> bikeshedding vector.\n>\n> -- Laolu\n>\n>\n> On Wed, Jun 30, 2021 at 5:31 PM Ariel Luaces <arielluaces at gmail.com> wrote:\n>>\n>> BIPs are already the Bazaar style of evolution that simultaneously\n>> allows flexibility and coordination/interoperability (since anyone can\n>> create a BIP and they create an environment of discussion).\n>>\n>> BOLTs are essentially one big BIP in the sense that they started as a\n>> place for discussion but are now more rigid. BOLTs must be followed\n>> strictly to ensure a node is interoperable with the network. And BOLTs\n>> should be rigid, as rigid as any widely used BIP like 32 for example.\n>> Even though BOLTs were flexible when being drafted their purpose has\n>> changed from descriptive to prescriptive.\n>> Any alternatives, or optional features should be extracted out of\n>> BOLTs, written as BIPs. The BIP should then reference the BOLT and the\n>> required flags set, messages sent, or alterations made to signal that\n>> the BIP's feature is enabled.\n>>\n>> A BOLT may at some point organically change to reference a BIP. For\n>> example if a BIP was drafted as an optional feature but then becomes\n>> more widespread and then turns out to be crucial for the proper\n>> operation of the network then a BOLT can be changed to just reference\n>> the BIP as mandatory. There isn't anything wrong with this.\n>>\n>> All of the above would work exactly the same if there was a bLIP\n>> repository instead. I don't see the value in having both bLIPs and\n>> BIPs since AFAICT they seem to be functionally equivalent and BIPs are\n>> not restricted to exclude lightning, and never have been.\n>>\n>> I believe the reason this move to BIPs hasn't happened organically is\n>> because many still perceive the BOLTs available for editing, so\n>> changes continue to be made. If instead BOLTs were perceived as more\n>> \"consensus critical\", not subject to change, and more people were\n>> strongly encouraged to write specs for new lightning features\n>> elsewhere (like the BIP repo) then you would see this issue of growing\n>> BOLTs resolved.\n>>\n>> Cheers\n>> Ariel Lorenzo-Luaces\n>>\n>> On Wed, Jun 30, 2021 at 1:16 PM Olaoluwa Osuntokun <laolu32 at gmail.com> wrote:\n>> >\n>> > > That being said I think all the points that are addressed in Ryan's mail\n>> > > could very well be formalized into BOLTs but maybe we just need to rethink\n>> > > the current process of the BOLTs to make it more accessible for new ideas\n>> > > to find their way into the BOLTs?\n>> >\n>> > I think part of what bLIPs are trying to solve here is promoting more loosely\n>> > coupled evolution of the network. I think the BOLTs do a good job currently of\n>> > specifying what _base_ functionality is required for a routing node in a\n>> > prescriptive manner (you must forward an HTLC like this, etc). However there's\n>> > a rather large gap in describing functionality that has emerged over time due\n>> > to progressive evolution, and aren't absolutely necessary, but enhance\n>> > node/wallet operation.\n>> >\n>> > Examples of  include things like: path finding heuristics (BOLTs just say you\n>> > should get from Alice to Bob, but provides no recommendations w.r.t _how_ to do\n>> > so), fee bumping heuristics, breach retribution handling, channel management,\n>> > rebalancing, custom records usage (like the podcast index meta-data, messaging,\n>> > etc), JIT channel opening, hosted channels, randomized channel IDs, fee\n>> > optimization, initial channel boostrapping, etc.\n>> >\n>> > All these examples are effectively optional as they aren't required for base\n>> > node operation, but they've organically evolved over time as node\n>> > implementations and wallet seek to solve UX and operational problems for\n>> > their users. bLIPs can be a _descriptive_ (this is how things can be done)\n>> > home for these types of standards, while BOLTs can be reserved for\n>> > _prescriptive_ measures (an HTLC looks like this, etc).\n>> >\n>> > The protocol as implemented today has a number of extensions (TLVs, message\n>> > types, feature bits, etc) that allow implementations to spin out their own\n>> > sub-protocols, many of which won't be considered absolutely necessary for node\n>> > operation. IMO we should embrace more of a \"bazaar\" style of evolution, and\n>> > acknowledge that loosely coupled evolution allows participants to more broadly\n>> > explore the design space, without the constraints of \"it isn't a thing until N\n>> > of us start to do it\".\n>> >\n>> > Historically, BOLTs have also had a rather monolithic structure. We've used\n>> > the same 11 or so documents for the past few years with the size of the\n>> > documents swelling over time with new exceptions, features, requirements,\n>> > etc. If you were hired to work on a new codebase and saw that everything is\n>> > defined in 11 \"functions\" that have been growing linearly over time, you'd\n>> > probably declare the codebase as being unmaintainable. By having distinct\n>> > documents for proposals/standards, bLIPs (author documents really), each new\n>> > standard/proposal is able to be more effectively explained, motivated, versionsed,\n>> > etc.\n>> >\n>> > -- Laolu\n>> >\n>> >\n>> > On Wed, Jun 30, 2021 at 7:35 AM Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>\n>> >> Hey everyone,\n>> >>\n>> >> just for reference when I was new here (and did not understand the processes well enough) I proposed a similar idea (called LIP) in 2018 c.f.: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001367.html\n>> >>\n>> >> I wonder what exactly has changed in the reasoning by roasbeef which I will repeat here:\n>> >>\n>> >> > We already have the equiv of improvement proposals: BOLTs. Historically\n>> >>\n>> >> > new standardization documents are proposed initially as issues or PR's when\n>> >>\n>> >> > ultimately accepted. Why do we need another repo?\n>> >>\n>> >>\n>> >> As far as I can tell there was always some form of (invisible?) barrier to participate in the BOLTs but there are also new BOLTs being offered:\n>> >> * BOLT 12: https://github.com/lightningnetwork/lightning-rfc/pull/798\n>> >> * BOLT 14: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>> >> and topics to be included like:\n>> >> * dual funding\n>> >> * splicing\n>> >> * the examples given by Ryan\n>> >>\n>> >> I don't see how a new repo would reduce that barrier - Actually I think it would even create more confusion as I for example would not know where something belongs. That being said I think all the points that are addressed in Ryan's mail could very well be formalized into BOLTs but maybe we just need to rethink the current process of the BOLTs to make it more accessible for new ideas to find their way into the BOLTs? One thing that I can say from answering lightning-network questions on stackexchange is that it would certainly help if the BOLTs where referenced  on lightning.network web page and in the whitepaper as the place to be if one wants to learn about the Lightning Network\n>> >>\n>> >> with kind regards Rene\n>> >>\n>> >> On Wed, Jun 30, 2021 at 4:10 PM Ryan Gentry via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>> >>>\n>> >>> Hi all,\n>> >>>\n>> >>>\n>> >>> The recent thread around zero-conf channels [1] provides an opportunity to discuss how the BOLT process handles features and best practices that arise in the wild vs. originating within the process itself. Zero-conf channels are one of many LN innovations on the app layer that have struggled to make their way into the spec. John Carvalho and Bitrefill launched Turbo channels in April 2019 [2], Breez posted their solution to the mailing list for feedback in August 2020 [3], and we know at least ACINQ and Muun (amongst others) have their own implementations. In an ideal world there would be a descriptive design document that the app layer implementers had collaborated on over the years that the spec group could then pick up and merge into the BOLTs now that the feature is deemed spec-worthy.\n>> >>>\n>> >>>\n>> >>> Over the last couple of months, we have discussed the idea of adding a BIP-style process (bLIPs? SPARKs? [4]) on top of the BOLTs with various members of the community, and have received positive feedback from both app layer and protocol devs. This would not affect the existing BOLT process at all, but simply add a place for app layer best practices to be succinctly described and organized, especially those that require coordination. These features are being built outside of the BOLT process today anyways, so ideally a bLIP process would bring them into the fold instead of leaving them buried in old ML posts or not documented at all.\n>> >>>\n>> >>>\n>> >>> Some potential bLIP ideas that people have mentioned include: each lnurl variant, on-the-fly channel opens, AMP, dynamic commitments, podcast payment metadata, p2p messaging formats, new pathfinding heuristics, remote node connection standards, etc.\n>> >>>\n>> >>>\n>> >>> If the community is interested in moving forward, we've started a branch [5] describing such a process. It's based on BIP-0002, so not trying to reinvent any wheels. It would be great to have developers from various implementations and from the broader app layer ecosystem volunteer to be listed as editors (basically the same role as in the BIPs).\n>> >>>\n>> >>>\n>> >>> Looking forward to hearing your thoughts!\n>> >>>\n>> >>>\n>> >>> Best,\n>> >>> Ryan\n>> >>>\n>> >>>\n>> >>> [1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003074.html\n>> >>>\n>> >>> [2] https://www.coindesk.com/bitrefills-thor-turbo-lets-you-get-started-with-bitcoins-lightning-faster\n>> >>>\n>> >>> [3] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-August/002780.html\n>> >>>\n>> >>> [4] bLIP = Bitcoin Lightning Improvement Proposal and SPARK = Standardization of Protocols at the Request of the Kommunity (h/t fiatjaf)\n>> >>>\n>> >>> [5] https://github.com/ryanthegentry/lightning-rfc/blob/blip-0001/blips/blip-0001.mediawiki\n>> >>>\n>> >>> _______________________________________________\n>> >>> Lightning-dev mailing list\n>> >>> Lightning-dev at lists.linuxfoundation.org\n>> >>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >>\n>> >>\n>> >>\n>> >> --\n>> >> https://www.rene-pickhardt.de\n>> >> _______________________________________________\n>> >> Lightning-dev mailing list\n>> >> Lightning-dev at lists.linuxfoundation.org\n>> >> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> >\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "bLIPs: A proposal for community-driven app layer and protocol extension standardization",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "fiatjaf",
                "Michael Folkson",
                "Luke Dashjr",
                "Ariel Luaces",
                "Bastien TEINTURIER",
                "David A. Harding",
                "Olaoluwa Osuntokun",
                "Ryan Gentry"
            ],
            "messages_count": 12,
            "total_messages_chars_count": 192379
        }
    },
    {
        "title": "[Lightning-dev] bLIPs: A proposal for community-driven app layer and protocol extension stand",
        "thread_messages": [
            {
                "author": "nathanael",
                "date": "2021-07-02T09:02:51",
                "message_text_only": "Michael Folkson <michaelfolkson at gmail.com> wrote:\n> > Adding a third BIP editor more involved with Lightning sounds like a good idea.\n> \n> Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n> would be a great additional BIP editor to cover Lightning related BIPs\n> :) I think BOLTs being subsumed into BIPs would be nice but I'm\n> pessimistic it will happen. Like legislation and regulation in the\n> legacy financial system alphabet soups only expand they never get\n> simplified. Let's at least resist alphabet soup expansion here.\n\narent lightning improvements in the end bitcoin improvements too?\ni am thinking of bips like the rfcs of the internet\n\n--\nnathanael"
            },
            {
                "author": "Dan Gershony",
                "date": "2021-07-02T12:02:28",
                "message_text_only": "Hi,\nThere will be many layer 2 (and probably layer 3)  protocols (BOLT, RGB,\nVolts etc...) does it really make sense to merge them all into the BIPs\nsystem?\n\n\nOn Fri, Jul 2, 2021 at 10:03 AM nathanael via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Michael Folkson <michaelfolkson at gmail.com> wrote:\n> > > Adding a third BIP editor more involved with Lightning sounds like a\n> good idea.\n> >\n> > Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n> > would be a great additional BIP editor to cover Lightning related BIPs\n> > :) I think BOLTs being subsumed into BIPs would be nice but I'm\n> > pessimistic it will happen. Like legislation and regulation in the\n> > legacy financial system alphabet soups only expand they never get\n> > simplified. Let's at least resist alphabet soup expansion here.\n>\n> arent lightning improvements in the end bitcoin improvements too?\n> i am thinking of bips like the rfcs of the internet\n>\n> --\n> nathanael\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210702/99e693b5/attachment.html>"
            },
            {
                "author": "Luke Dashjr",
                "date": "2021-07-02T19:31:59",
                "message_text_only": "Yes, many systems doesn't really make sense. We can add editors and revise the \nBIP process as needed (BOLTs might prefer to use markdown?). Even aside from \nLightning BIPs, there are several improvements that can be made, so it makes \nsense to address everything at once.\n\nhttps://github.com/bitcoin/bips/wiki/BIP-Process-wishlist\n\nThe BIP 2xx range has been set aside for Lightning years ago, and we can do \nsimilar things to help keep things organized within BIPs. Kalle suggested \nmaybe it'd be better to do BIP \"L###\" instead, and perhaps that would work \nbetter if there's likely to be several sub-namespaces.\n\nLuke\n\n\nOn Friday 02 July 2021 12:02:28 Dan Gershony wrote:\n> Hi,\n> There will be many layer 2 (and probably layer 3)  protocols (BOLT, RGB,\n> Volts etc...) does it really make sense to merge them all into the BIPs\n> system?\n>\n>\n> On Fri, Jul 2, 2021 at 10:03 AM nathanael via Lightning-dev <\n>\n> lightning-dev at lists.linuxfoundation.org> wrote:\n> > Michael Folkson <michaelfolkson at gmail.com> wrote:\n> > > > Adding a third BIP editor more involved with Lightning sounds like a\n> >\n> > good idea.\n> >\n> > > Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n> > > would be a great additional BIP editor to cover Lightning related BIPs\n> > >\n> > > :) I think BOLTs being subsumed into BIPs would be nice but I'm\n> > >\n> > > pessimistic it will happen. Like legislation and regulation in the\n> > > legacy financial system alphabet soups only expand they never get\n> > > simplified. Let's at least resist alphabet soup expansion here.\n> >\n> > arent lightning improvements in the end bitcoin improvements too?\n> > i am thinking of bips like the rfcs of the internet\n> >\n> > --\n> > nathanael\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "fiatjaf",
                "date": "2021-07-02T20:11:46",
                "message_text_only": "If the BIPs can allow very small standards related to a small niche of\nLightning usage, then I think they are the place for everything indeed. I'm\nconvinced.\n\nThinking about proposing the LNURL specs as BIPs now, but then I don't know\nif it will be weird for them to exist alone there, without the basis of the\nlightning technology to support them. I hope the BOLT authors investigate\nmoving them there too so the other Lightning BIPs can add the BOLT BIPs as\n\"Required\".\n\nThe only question to me is this: should each BOLT be a BIP? Or all BOLTs be\nmashed together as a single BIP? Then what happens when Taproot-based\nchannels, PTLCs or Eltoo-based channels get implemented? They are added as\nnew BIPs that inherit and modify the previous?\n\nI also went through\nhttps://github.com/bitcoin/bips/wiki/BIP-Process-wishlist and to me they\nseem to be all good proposals (specially the list of projects/services\nimplementing the BIP). Except BIP versioning. I like that BIPs have\nmeaningless numbers, just add another BIP and refer to it by a number. For\nthat reason I also don't like prepending an \"L\" to Lightning-related BIPs\n(more so because some of these may be reused later in non-Lightning\ncontexts, who knows?). Anyway I'm fine with anything.\n\nOn Fri, Jul 2, 2021 at 4:32 PM Luke Dashjr <luke at dashjr.org> wrote:\n\n> Yes, many systems doesn't really make sense. We can add editors and revise\n> the\n> BIP process as needed (BOLTs might prefer to use markdown?). Even aside\n> from\n> Lightning BIPs, there are several improvements that can be made, so it\n> makes\n> sense to address everything at once.\n>\n> https://github.com/bitcoin/bips/wiki/BIP-Process-wishlist\n>\n> The BIP 2xx range has been set aside for Lightning years ago, and we can\n> do\n> similar things to help keep things organized within BIPs. Kalle suggested\n> maybe it'd be better to do BIP \"L###\" instead, and perhaps that would work\n> better if there's likely to be several sub-namespaces.\n>\n> Luke\n>\n>\n> On Friday 02 July 2021 12:02:28 Dan Gershony wrote:\n> > Hi,\n> > There will be many layer 2 (and probably layer 3)  protocols (BOLT, RGB,\n> > Volts etc...) does it really make sense to merge them all into the BIPs\n> > system?\n> >\n> >\n> > On Fri, Jul 2, 2021 at 10:03 AM nathanael via Lightning-dev <\n> >\n> > lightning-dev at lists.linuxfoundation.org> wrote:\n> > > Michael Folkson <michaelfolkson at gmail.com> wrote:\n> > > > > Adding a third BIP editor more involved with Lightning sounds like\n> a\n> > >\n> > > good idea.\n> > >\n> > > > Or alternatively if BOLTs were subsumed into BIPs I think Bastien\n> > > > would be a great additional BIP editor to cover Lightning related\n> BIPs\n> > > >\n> > > > :) I think BOLTs being subsumed into BIPs would be nice but I'm\n> > > >\n> > > > pessimistic it will happen. Like legislation and regulation in the\n> > > > legacy financial system alphabet soups only expand they never get\n> > > > simplified. Let's at least resist alphabet soup expansion here.\n> > >\n> > > arent lightning improvements in the end bitcoin improvements too?\n> > > i am thinking of bips like the rfcs of the internet\n> > >\n> > > --\n> > > nathanael\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210702/abb5b479/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bLIPs: A proposal for community-driven app layer and protocol extension stand",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Dan Gershony",
                "nathanael",
                "fiatjaf",
                "Luke Dashjr"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7679
        }
    },
    {
        "title": "[Lightning-dev] Turbo channels spec?",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2021-07-01T18:07:29",
                "message_text_only": "Thanks!\n\nOn 6/29/21 01:34, Rusty Russell wrote:\n> Hi all!\n> \n>          John Carvalo recently pointed out that not every implementation\n> accepts zero-conf channels, but they are useful.  Roasbeef also recently\n> noted that they're not spec'd.\n> \n> How do you all do it?  Here's a strawman proposal:\n> \n> 1. Assign a new feature bit \"I accept zeroconf channels\".\n> 2. If both negotiate this, you can send update_add_htlc (etc) *before*\n>     funding_locked without the peer getting upset.\n\nDoes it make sense to negotiate this per-direction in the channel init message(s)? There's a pretty different threat \nmodel between someone spending a dual-funded or push_msat balance vs someone spending a classic channel-funding balance.\n\n> 3. Nodes are advised *not* to forward HTLCs from an unconfirmed channel\n>     unless they have explicit reason to trust that node (they can still\n>     send *out* that channel, because that's not their problem!).\n> \n> It's a pretty simple change, TBH (this zeroconf feature would also\n> create a new set of channel_types, altering that PR).\n> \n> I can draft something this week?\n> \n> Thanks!\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-07-05T01:21:46",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> Thanks!\n>\n> On 6/29/21 01:34, Rusty Russell wrote:\n>> Hi all!\n>> \n>>          John Carvalo recently pointed out that not every implementation\n>> accepts zero-conf channels, but they are useful.  Roasbeef also recently\n>> noted that they're not spec'd.\n>> \n>> How do you all do it?  Here's a strawman proposal:\n>> \n>> 1. Assign a new feature bit \"I accept zeroconf channels\".\n>> 2. If both negotiate this, you can send update_add_htlc (etc) *before*\n>>     funding_locked without the peer getting upset.\n>\n> Does it make sense to negotiate this per-direction in the channel init message(s)? There's a pretty different threat \n> model between someone spending a dual-funded or push_msat balance vs someone spending a classic channel-funding balance.\n\nchannel_types fixes this :)\n\nUntil then, I'd say keep it simple.  I would think that c-lightning will\nimplement the \"don't route from non-locked-in channels\" and always\nadvertize this option.  That means we're always offering zero-conf\nchannels, but that seems harmless:\n\n- Risks for funder is that channel never confirms, but it probably ignores\n  the risk because it can close onchain (annoying, and fee-heavy, but not\n  loss of funds caused by peer).\n\n- Risks for fundee (or DF channels where peer contributes any funds) is\n  that funder doublespends, so HTLCs must not be routed out to others\n  (unless you have other reason to trust peer).\n\nCheers,\nRusty."
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-07-05T02:20:01",
                "message_text_only": "Good morning Rusty et al,\n\n> Matt Corallo lf-lists at mattcorallo.com writes:\n>\n> > Thanks!\n> > On 6/29/21 01:34, Rusty Russell wrote:\n> >\n> > > Hi all!\n> > >\n> > >          John Carvalo recently pointed out that not every implementation\n> > >\n> > >\n> > > accepts zero-conf channels, but they are useful. Roasbeef also recently\n> > > noted that they're not spec'd.\n> > > How do you all do it? Here's a strawman proposal:\n> > >\n> > > 1.  Assign a new feature bit \"I accept zeroconf channels\".\n> > > 2.  If both negotiate this, you can send update_add_htlc (etc) before\n> > >     funding_locked without the peer getting upset.\n> > >\n> >\n> > Does it make sense to negotiate this per-direction in the channel init message(s)? There's a pretty different threat\n> > model between someone spending a dual-funded or push_msat balance vs someone spending a classic channel-funding balance.\n>\n> channel_types fixes this :)\n>\n> Until then, I'd say keep it simple. I would think that c-lightning will\n> implement the \"don't route from non-locked-in channels\" and always\n> advertize this option. That means we're always offering zero-conf\n> channels, but that seems harmless:\n>\n> -   Risks for funder is that channel never confirms, but it probably ignores\n>     the risk because it can close onchain (annoying, and fee-heavy, but not\n>     loss of funds caused by peer).\n>\n> -   Risks for fundee (or DF channels where peer contributes any funds) is\n>     that funder doublespends, so HTLCs must not be routed out to others\n>     (unless you have other reason to trust peer).\n\nMostly nitpick on terminology below, but I think text substantially like the above should exist in some kind of \"rationale\" section in the BOLT, so ---\n\nIn light of dual-funding we should avoid \"funder\" and \"fundee\" in favor of \"initiator\" and \"acceptor\".\nHowever, we should also note that the substantial feature of turbo channels is ***not*** in channel opening per se, it is the *confirmation* of the channel.\n\nOnce the opening ritual has completed and the funding tx broadcast, that is when turbo channels come in, so it actually does not matter which peer is \"initiator\" and which is \"acceptor\" at that point, the opening ritual has completed.\nBoth peers, at the end of the opening ritual, have a valid commitment tx and both can double-spend the funds they put in to back out of the channel.\n\nSo what matters for the above rationale is the \"sender\" of an HTLC and the \"receiver\" of an HTLC, not really who is acceptor or initiator.\n\n* Risks for HTLC sender is that the channel never confirms, but it probably ignores the risk because it can close onchain (annoying, and fee-heavy, but not loss of funds caused by peer).\n* Risks for HTLC receiver is that the channel never confirms, so HTLC must not be routed out to others or resolved locally if the receiver already knows the preimage, UNLESS the HTLC receiver has some *other* reason to trust the peer.\n\n\nBasically:\n\n* \"funder\" and \"fundee\" are legacy terms that predate dual-funding and are depreciated.\n  In modern terms, the \"funder\" is the \"initiator\" and the \"fundee\" is the \"acceptor\", and in a legacy pre-dua-funding channel, only the initiator can start putting funds into the channel.\n* \"initiator\" is the peer that starts the opening process, and pays for the opening fees.\n* \"acceptor\" is the peer that is contacted by the initiator and decides whether to allow the creation of a channel with the initiator, and pays no opening fees.\n* \"HTLC sender\" is any peer that, *after* the channel opening completes (but possibly before it is locked in), offers an HTLC to the peer.\n* \"HTLC receiver\" is any peer that, *after* the channel opening completes (but possibly before it is locked in), is the one who accepts the HTLC from the HTLC sender.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-07-05T06:38:42",
                "message_text_only": "ZmnSCPxj <ZmnSCPxj at protonmail.com> writes:\n> Mostly nitpick on terminology below, but I think text substantially like the above should exist in some kind of \"rationale\" section in the BOLT, so ---\n>\n> In light of dual-funding we should avoid \"funder\" and \"fundee\" in favor of \"initiator\" and \"acceptor\".\n\nYes, Lisa has a patch for this in her spec PR :)\n\n> So what matters for the above rationale is the \"sender\" of an HTLC and the \"receiver\" of an HTLC, not really who is acceptor or initiator.\n>\n> * Risks for HTLC sender is that the channel never confirms, but it probably ignores the risk because it can close onchain (annoying, and fee-heavy, but not loss of funds caused by peer).\n> * Risks for HTLC receiver is that the channel never confirms, so HTLC must not be routed out to others or resolved locally if the receiver already knows the preimage, UNLESS the HTLC receiver has some *other* reason to trust the peer.\n\nThis misses an important case: even with the dual-funding prototol,\nsingle-sided funding is more common.\n\nSo:\n  - if your peer hasn't contributed funds:\n    - You are in control, channel is safe (modulo your own conf issues)\n  - if the peer has contributed funds:\n    - You can send, since cancellation just gives you a free refund (if\n      you contributed anything at all).\n    - You should not route an incoming HTLCs (unless you trust peer)\n\nCheers,\nRusty."
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2021-07-12T08:19:13",
                "message_text_only": "Hi guys,\n\nhappy to see this being discussed again! When I came up with the idea,\nit was originally intended for cases when there's an inherently trusted\nexchange,\nsuch as trading fiat for sats using an ATM. In this scenario only the push\namount was spendable.\nReceiving more on top of that was disabled.\n\nSince then some implementations have made zero-conf channels fully\noperational.\nWhile strictly worse security, I'm not against it. I'd just really, really\nlike to have these\ncases distinguished.\n\nSo I think we need one more bit to signal whether it's only push being\nzeroconf or the\nchannel is fully zeroconf.\n\nCheers,\nMartin\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210712/63b84d91/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Turbo channels spec?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo",
                "Martin Habov\u0161tiak",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 8781
        }
    },
    {
        "title": "[Lightning-dev] Error Codes for LN",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-07-07T00:36:37",
                "message_text_only": "Carla Kirk-Cohen <kirkcohenc at gmail.com> writes:\n> Hi all,\n\nHi Carla,\n\n        I apologize for not responding to this earlier, but it was\nraised again in the recent spec meeting\n(https://lightningd.github.io/meetings/ln_spec_meeting/2021/ln_spec_meeting.2021-07-05-20.06.log.html).\n\nI love the idea of more specific error codes, BTW!\n\nFeedback interleaved:\n\n> Since we shouldn\u2019t have non-ascii values in the error string itself,\n> this can most easily be achieved by adding TLV fields after the\n> data field. In terms of supporting nodes that have not upgraded,\n> we could either include the error code in the data field to cover\n> our bases, or introduce a feature bit so that we know whether\n> to backfill the data field. This gives upgraded nodes an improved\n> quality of life, while leaving older nodes unaffected.\n\nOlder nodes should definitely ignore extra fields; it's in the spec and\nwe've relied on this to extend messages in the past, so this part is\neasy.\n\nTechnically, all defined types are now assumed to have an optional TLV\nappended, since f068dd0d (Bolt 1: Specify that extensions to existing\nmessages must use TLV (#754)).\n\n> While we can\u2019t enumerate every possible error, there are quite\n> a few cases in the spec where we can introduce explicit error\n> codes. For the sake of the skim-readers, I\u2019ve left that list at\n> the end of the email.\n>\n> Taking the example of our node receiving an invalid signature for\n> a htlc, a new error would look like this:\n\nI think this is both too much, and not enough.\n\nToo much:\n- Many of these errors are \"your implementation is broken\", which is\n  really not something actionable by the recipient.\n- A lot of work to fill in all these error cases, which will (because\n  they're usually impossible) will be untested and broken.\n\nNot enough:\n- Look at the proposal for channel_types, where you would object to the\n  channel_type if you don't like it.  This would be grouped under\n  \"Funding params unacceptable\", which is actually 99% of errors at this\n  point and does not say what the problem is with specificity.\n\nI took a different approach with onion messages[1], where you (optionally)\nspecify the field number, even an optional suggested value:\n\n    1. type: 1 (`erroneous_field`)\n    2. data:\n        * [`tu64`:`tlv_fieldnum`]\n    1. type: 3 (`suggested_value`)\n    2. data:\n        * [`...*byte`:`value`]\n    1. type: 5 (`error`)\n    2. data:\n        * [`...*utf8`:`msg`]\n\nIn our case, we need to refer to which message (if any) caused the\nerror, and we have non-tlv fields, so it can't simply use the tlv field\nnumber.\n\nHere's my straw proposal:\n\n1. `tlv_stream`: `error_tlvs`\n2. types:\n    1. type: 1 (`erroneous_message`)\n    2. data:\n        * [`...*byte`:`message`]\n    1. type: 3 (`erroneous_fieldnum`)\n    2. data:\n        * [`tu64`:`fieldnum`]\n    1. type: 5 (`suggested_value`)\n    2. data:\n        * [`...*byte`:`value`]\n\nerroneous_message is the message we're complaining about (including\n2-byte type), which may be truncated (but must be at least 2 bytes).\n\nfieldnum is either the 0-based field number (for fixed fields), or the\nnumber of fixed fields + the tlv type (for tlv fields).\n\nsuggested_value is the optional value if we have an idea if what we\nexpected / prefer.\n\n> This new kind of error provides us with an error code that tells us\n>\n> exactly what has gone wrong, and metadata pointing to the htlc\n>\n> with an invalid sig. This information can be logged, or stored in a\n>\n> more permanent error store to help diagnose issues in the future.\n>\n> Right now, the spec is pretty strict on error handling [13], indicating\n>\n> that senders/recipients of errors `MUST` fail the channel referenced\n>\n> in the error.\n\n> This isn\u2019t very practical, and I believe that the majority\n> of the impls don\u2019t abide by this instruction.\n\nThis was inevitable eventually, but c-lightning deliberately treated\nerrors as fatal for a long time so people would *notice* and *report*\nthese issues.\n\nTo be fair, *LND* didn't treat them as fatal.  As so naturally your\nengineers didn't *think* of them as a big deal (and testing didn't show\nit up), so it would send errors for cases which it clearly didn't want\nto close the channel (e.g. peer too slow to respond!).\n\nHence this PR, which makes these less fatal, and adds warning support:\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/834\n\n(We should similarly add this TLV to warnings?)\n\n> Candidates for error codes:\n\nThe vast majority of these are \"contact your developer, peer says we did\nsomething illegal\".  Which is always nice to have more information\nabout, but not critital.\n\nThe exceptions are:\n\n> Funding Process:\n>\n> * Funding process timeout [2]\n>\n> * Fees out of range [3]\n>\n> * Funding tx spent [11]\n>\n> * Funding params unacceptable (eg, channel too small)\n...\n> Channel State Machine:\n> \n> * HTLC timeout [4]\n...\n> Fee Updates\n>\n> * Update fee to low/high [9]\n...\n\nAnd BTW this one is misguided:\n\n> * Feature bit required\n\nIf Alice says a feature bit is even (compulsory), and Bob doesn't offer\nit, that's on Bob!  Alice's behavior here is undefined: she may do a\ncourtesy message to Bob, but she may also *assume* it's agreed.\n\nBut it's worth noting that with the exception of timeouts, these are all\nexpressable in form \"problem is this message, this field\".  Perhaps it's\nworth having a special TLV case for timeouts in the message?\n\nThanks for starting this ball rolling!\n\nCheers,\nRusty.\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/759"
            },
            {
                "author": "Carla Kirk-Cohen",
                "date": "2021-07-28T08:25:52",
                "message_text_only": "Hi Rusty,\n\nThanks for taking a look!\n\nI like the idea of being able to reference a specific message/field\nthat your node finds problematic. Definitely makes the job simpler\nthan trying to define every error evar.\n\n> erroneous_message is the message we're complaining about (including\n2-byte type), which may be truncated (but must be at least 2 bytes)\n\nDo you think this could be reduced to just the 2-byte message type?\nIf the reason for including the whole message is so that the error\nrecipient can match it to the original message, we could possibly just\ninclude the field that we had a problem with as another TLV? That way\nwe save on having to resend the whole message, and guarantee that we'd\nbe delivering the problematic field value (it could be cut off if we\ntruncate the message).\n\nWith this approach, there's a chance that we can't match errors back\nto their original message if the same channel sends the same message\nwith the same incorrect field more than once, but I don't see much\npractical need to exactly match error to original message in this case,\nsince we know which field is broken.\n\n> (We should similarly add this TLV to warnings?)\n\nSounds like a good idea to me!\n\n> But it's worth noting that with the exception of timeouts, these are\nall expressible in form \"problem is this message, this field\". Perhaps\nits worth having a special TLV case for timeouts in the message?\n\nIf we're confident that the only error that we're going to need that\ndoesn't follow the \"problem/message\" structure is timeouts, then a\n`timeout` tlv sounds reasonable. If we're also going to add these\nfields to warning messages, I'm wondering whether it could be useful\nto define an `error_code` enum, where `timeout` is one of the cases?\nPerhaps overkill if we're certain that the only value will ever be\n`timeout`.\n\nPutting that all together, an update on your proposed solution:\n1. `tlv_stream`: `error_tlvs`\n2. types:\n    1. type: 1 (`erroneous_msgtype`)\n    2. data:\n        * [`u16`:`type`]\n    1. type: 3 (`erroneous_fieldnum`)\n    2. data:\n        * [`tu64`:`fieldnum`]\n    1. type: 5 (`suggested_value`)\n    2. data:\n        * [`...*byte`:`value`]\n    1. type: 7 (`erroneous_value`)\n    2. data:\n        * [`...*byte`:`value`]\n    1. type: 9 (`error_code`)\n    2. data:\n        * [`u16`:`code`]\n\nCheers,\n  - Carla\n\nOn Wed, Jul 7, 2021 at 2:36 AM Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Carla Kirk-Cohen <kirkcohenc at gmail.com> writes:\n> > Hi all,\n>\n> Hi Carla,\n>\n>         I apologize for not responding to this earlier, but it was\n> raised again in the recent spec meeting\n> (\n> https://lightningd.github.io/meetings/ln_spec_meeting/2021/ln_spec_meeting.2021-07-05-20.06.log.html\n> ).\n>\n> I love the idea of more specific error codes, BTW!\n>\n> Feedback interleaved:\n>\n> > Since we shouldn\u2019t have non-ascii values in the error string itself,\n> > this can most easily be achieved by adding TLV fields after the\n> > data field. In terms of supporting nodes that have not upgraded,\n> > we could either include the error code in the data field to cover\n> > our bases, or introduce a feature bit so that we know whether\n> > to backfill the data field. This gives upgraded nodes an improved\n> > quality of life, while leaving older nodes unaffected.\n>\n> Older nodes should definitely ignore extra fields; it's in the spec and\n> we've relied on this to extend messages in the past, so this part is\n> easy.\n>\n> Technically, all defined types are now assumed to have an optional TLV\n> appended, since f068dd0d (Bolt 1: Specify that extensions to existing\n> messages must use TLV (#754)).\n>\n> > While we can\u2019t enumerate every possible error, there are quite\n> > a few cases in the spec where we can introduce explicit error\n> > codes. For the sake of the skim-readers, I\u2019ve left that list at\n> > the end of the email.\n> >\n> > Taking the example of our node receiving an invalid signature for\n> > a htlc, a new error would look like this:\n>\n> I think this is both too much, and not enough.\n>\n> Too much:\n> - Many of these errors are \"your implementation is broken\", which is\n>   really not something actionable by the recipient.\n> - A lot of work to fill in all these error cases, which will (because\n>   they're usually impossible) will be untested and broken.\n>\n> Not enough:\n> - Look at the proposal for channel_types, where you would object to the\n>   channel_type if you don't like it.  This would be grouped under\n>   \"Funding params unacceptable\", which is actually 99% of errors at this\n>   point and does not say what the problem is with specificity.\n>\n> I took a different approach with onion messages[1], where you (optionally)\n> specify the field number, even an optional suggested value:\n>\n>     1. type: 1 (`erroneous_field`)\n>     2. data:\n>         * [`tu64`:`tlv_fieldnum`]\n>     1. type: 3 (`suggested_value`)\n>     2. data:\n>         * [`...*byte`:`value`]\n>     1. type: 5 (`error`)\n>     2. data:\n>         * [`...*utf8`:`msg`]\n>\n> In our case, we need to refer to which message (if any) caused the\n> error, and we have non-tlv fields, so it can't simply use the tlv field\n> number.\n>\n> Here's my straw proposal:\n>\n> 1. `tlv_stream`: `error_tlvs`\n> 2. types:\n>     1. type: 1 (`erroneous_message`)\n>     2. data:\n>         * [`...*byte`:`message`]\n>     1. type: 3 (`erroneous_fieldnum`)\n>     2. data:\n>         * [`tu64`:`fieldnum`]\n>     1. type: 5 (`suggested_value`)\n>     2. data:\n>         * [`...*byte`:`value`]\n>\n> erroneous_message is the message we're complaining about (including\n> 2-byte type), which may be truncated (but must be at least 2 bytes).\n>\n> fieldnum is either the 0-based field number (for fixed fields), or the\n> number of fixed fields + the tlv type (for tlv fields).\n>\n> suggested_value is the optional value if we have an idea if what we\n> expected / prefer.\n>\n> > This new kind of error provides us with an error code that tells us\n> >\n> > exactly what has gone wrong, and metadata pointing to the htlc\n> >\n> > with an invalid sig. This information can be logged, or stored in a\n> >\n> > more permanent error store to help diagnose issues in the future.\n> >\n> > Right now, the spec is pretty strict on error handling [13], indicating\n> >\n> > that senders/recipients of errors `MUST` fail the channel referenced\n> >\n> > in the error.\n>\n> > This isn\u2019t very practical, and I believe that the majority\n> > of the impls don\u2019t abide by this instruction.\n>\n> This was inevitable eventually, but c-lightning deliberately treated\n> errors as fatal for a long time so people would *notice* and *report*\n> these issues.\n>\n> To be fair, *LND* didn't treat them as fatal.  As so naturally your\n> engineers didn't *think* of them as a big deal (and testing didn't show\n> it up), so it would send errors for cases which it clearly didn't want\n> to close the channel (e.g. peer too slow to respond!).\n>\n> Hence this PR, which makes these less fatal, and adds warning support:\n>\n>         https://github.com/lightningnetwork/lightning-rfc/pull/834\n>\n> (We should similarly add this TLV to warnings?)\n>\n> > Candidates for error codes:\n>\n> The vast majority of these are \"contact your developer, peer says we did\n> something illegal\".  Which is always nice to have more information\n> about, but not critital.\n>\n> The exceptions are:\n>\n> > Funding Process:\n> >\n> > * Funding process timeout [2]\n> >\n> > * Fees out of range [3]\n> >\n> > * Funding tx spent [11]\n> >\n> > * Funding params unacceptable (eg, channel too small)\n> ...\n> > Channel State Machine:\n> >\n> > * HTLC timeout [4]\n> ...\n> > Fee Updates\n> >\n> > * Update fee to low/high [9]\n> ...\n>\n> And BTW this one is misguided:\n>\n> > * Feature bit required\n>\n> If Alice says a feature bit is even (compulsory), and Bob doesn't offer\n> it, that's on Bob!  Alice's behavior here is undefined: she may do a\n> courtesy message to Bob, but she may also *assume* it's agreed.\n>\n> But it's worth noting that with the exception of timeouts, these are all\n> expressable in form \"problem is this message, this field\".  Perhaps it's\n> worth having a special TLV case for timeouts in the message?\n>\n> Thanks for starting this ball rolling!\n>\n> Cheers,\n> Rusty.\n>\n> [1] https://github.com/lightningnetwork/lightning-rfc/pull/759\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210728/4b5ba70c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Error Codes for LN",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Carla Kirk-Cohen"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 13904
        }
    },
    {
        "title": "[Lightning-dev] Eltoo / Anyprevout & Baked in Sequences",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-07-08T01:00:20",
                "message_text_only": "I made a comment on\nhttps://github.com/bitcoin/bips/pull/943#issuecomment-876034559 but it\noccurred to me it is more ML appropriate.\n\nIn general, one thing that strikes me is that when anyprevout is used for\neltoo you're generally doing a script like:\n\n```\nIF\n    10 CSV DROP\n    1::musigkey(As,Bs) CHECKSIG\nELSE\n    <S+1> CLTV DROP\n   1::musigkey(Au,Bu) CHECKSIG\nENDIF\n```\n\nThis means that you're overloading the CLTV clause, which means it's\nimpossible to use Eltoo and use a absolute lock time, it also means you\nhave to use fewer than a billion sequences, and if you pick a random # to\nmask how many payments you've done / pick random gaps let's say that\nreduces your numbers in half. That may be enough, but is still relatively\nlimited. There is also the issue that multiple inputs cannot be combined\ninto a transaction if they have signed on different locktimes.\n\nSince Eltoo is the primary motivation for ANYPREVOUT, it's worth making\nsure we have all the parts we'd need bundled together to see it be\nsuccessful.\n\nA few options come to mind that might be desirable in order to better serve\nthe eltoo usecase\n\n1) Define a new CSV type (e.g. define (1<<31 && 1<<30) as being dedicated\nto eltoo sequences). This has the benefit of giving a per input sequence,\nbut the drawback of using a CSV bit. Because there's only 1 CSV per input,\nthis technique cannot be used with a sequence tag.\n2) CSFS -- it would be possible to take a signature from stack for an\narbitrary higher number, e.g.:\n```\nIF\n    10 CSV DROP\n    1::musigkey(As,Bs) CHECKSIG\nELSE\n    DUP musigkey(Aseq, BSeq) CSFSV <S+1> GTE VERIFY\n   1::musigkey(Au,Bu) CHECKSIG\nENDIF\n```\nThen, posession of a higher signed sequence would allow for the use of the\nupdate path. However, the downside is that there would be no guarantee that\nthe new state provided for update would be higher than the past one without\na more advanced covenant.\n3) Sequenced Signature: It could be set up such that ANYPREVOUT keys are\ntagged with a N byte sequence (instead of 1), and a part of the process of\nsignature verification includes hashing a sequence on the signature itself.\n\nE.g.\n\n```\nIF\n    10 CSV DROP\n    1::musigkey(As,Bs) CHECKSIG\nELSE\n   <N>::musigkey(Au,Bu) CHECKSIG\nENDIF\n```\nTo satisfy this clause, a signature `<N+1>::S` would be required. When\nvalidating the signature S, the APO digest would have to include the value\n<N+1>. It is non cryptographically checked that N+1 > N.\n5) Similar to 3, but look at more values off the stack. This is also OK,\nbut violates the principle of not making opcodes take variable numbers of\nthings off the stack. Verify semantics on the extra data fields could\nameliorate this concern, and it might make sense to do it that way.\n4) Something in the Annex: It would also be possible to define a new\ngeneric place for lock times in the annex (to permit dual height/time\nrelative/absolute, all per input. The pro of this approach is that it would\nbe solving an outstanding problem for script that we want to solve anyways,\nthe downside is that the Annex is totally undefined presently so it's\nunclear that this is an appropriate use for it.\n5) Do Nothing :)\n\n\nOverall I'm somewhat partial to option 3 as it seems to be closest to\nmaking ANYPREVOUT more precisely designed to support Eltoo. It would also\nbe possible to make it such that if the tag N=1, then the behavior is\nidentical to the proposal currently.\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210707/9e3fa6d7/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Eltoo / Anyprevout & Baked in Sequences",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3668
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Eltoo / Anyprevout & Baked in Sequences",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2021-07-08T08:44:16",
                "message_text_only": "On Wed, Jul 07, 2021 at 06:00:20PM -0700, Jeremy via bitcoin-dev wrote:\n> This means that you're overloading the CLTV clause, which means it's impossible\n> to use Eltoo and use a absolute lock time,\n\nIt's already impossible to simultaneously spend two inputs if one\nrequires a locktime specified by mediantime and the other by block\nheight. Having per-input locktimes would satisfy both concerns.\n\n> 1) Define a new CSV type (e.g. define (1<<31 && 1<<30) as being dedicated to\n> eltoo sequences). This has the benefit of giving a per input sequence, but the\n> drawback of using a CSV bit. Because there's only 1 CSV per input, this\n> technique cannot be used with a sequence tag.\n\nThis would disallow using a relative locktime and an absolute locktime\nfor the same input. I don't think I've seen a use case for that so far,\nbut ruling it out seems suboptimal.\n\nAdding a per-input absolute locktime to the annex is what I've had in\nmind. That could also be used to cheaply add a commitment to an historical\nblock hash (eg \"the block at height 650,000 ended in cc6a\") in order to\ndisambiguate which branch of a chain split or reorg your tx is valid for.\n\nCheers,\naj"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-08T15:48:14",
                "message_text_only": ">\n> This would disallow using a relative locktime and an absolute locktime\n> for the same input. I don't think I've seen a use case for that so far,\n> but ruling it out seems suboptimal.\n\n\nI think you meant disallowing a relative locktime and a sequence locktime?\nI agree it is suboptimal.\n\n\nWhat do you make of sequence tagged keys?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210708/6512bb4f/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-07-12T05:01:15",
                "message_text_only": "On Thu, Jul 08, 2021 at 08:48:14AM -0700, Jeremy wrote:\n>     This would disallow using a relative locktime and an absolute locktime\n>     for the same input. I don't think I've seen a use case for that so far,\n>     but ruling it out seems suboptimal.\n> I think you meant disallowing a relative locktime and a sequence locktime? I\n> agree it is suboptimal.\n\nNo? If you overload the nSequence for a per-input absolute locktime\n(well in the past for eltoo), then you can't reuse the same input's\nnSequence for a per-input relative locktime (ie CSV).\n\nApparently I have thought of a use for it now -- cut-through of PTLC\nrefunds when the timeout expires well after the channel settlement delay\nhas passed. (You want a signature that's valid after a relative locktime\nof the delay and after the absolute timeout)\n\n> What do you make of sequence tagged keys?\n\nI think we want sequencing restrictions to be obvious from some (simple)\ncombination of nlocktime/nsequence/annex so that you don't have to\nevaluate scripts/signatures in order to determine if a transaction\nis final.\n\nPerhaps there's a more general principle -- evaluating a script should\nonly return one bit of info: \"bool tx_is_invalid_script_failed\"; every\nother bit of information -- how much is paid in fees (cf ethereum gas\ncalculations), when the tx is final, if the tx is only valid in some\nchain fork, if other txs have to have already been mined / can't have\nbeen mined, who loses funds and who gets funds, etc... -- should already\nbe obvious from a \"simple\" parsing of the tx.\n\nCheers,\naj"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-12T22:07:29",
                "message_text_only": "On Sun, Jul 11, 2021 at 10:01 PM Anthony Towns <aj at erisian.com.au> wrote:\n\n> On Thu, Jul 08, 2021 at 08:48:14AM -0700, Jeremy wrote:\n> >     This would disallow using a relative locktime and an absolute\n> locktime\n> >     for the same input. I don't think I've seen a use case for that so\n> far,\n> >     but ruling it out seems suboptimal.\n> > I think you meant disallowing a relative locktime and a sequence\n> locktime? I\n> > agree it is suboptimal.\n>\n> No? If you overload the nSequence for a per-input absolute locktime\n> (well in the past for eltoo), then you can't reuse the same input's\n> nSequence for a per-input relative locktime (ie CSV).\n>\n> Apparently I have thought of a use for it now -- cut-through of PTLC\n> refunds when the timeout expires well after the channel settlement delay\n> has passed. (You want a signature that's valid after a relative locktime\n> of the delay and after the absolute timeout)\n>\n\nAh -- I didn't mean a per input abs locktime, I mean the  tx global\nlocktime.\n\nI agree that at some point we should just separate all locktime types per\ninput so we get rid of all weirdness/overlap.\n\n\n\n>\n> > What do you make of sequence tagged keys?\n>\n> I think we want sequencing restrictions to be obvious from some (simple)\n> combination of nlocktime/nsequence/annex so that you don't have to\n> evaluate scripts/signatures in order to determine if a transaction\n> is final.\n>\n> Perhaps there's a more general principle -- evaluating a script should\n> only return one bit of info: \"bool tx_is_invalid_script_failed\"; every\n> other bit of information -- how much is paid in fees (cf ethereum gas\n> calculations), when the tx is final, if the tx is only valid in some\n> chain fork, if other txs have to have already been mined / can't have\n> been mined, who loses funds and who gets funds, etc... -- should already\n> be obvious from a \"simple\" parsing of the tx.\n>\n> Cheers,\n> aj\n>\n>\nI don't think we have this property as is.\n\nE.g. consider the transaction:\n\nTX:\n   locktime: None\n   sequence: 100\n   scriptpubkey: 101 CSV\n\nHow will you tell it is able to be included without running the script?\n\nI agree this is a useful property, but I don't think we can do it\npractically.\n\nWhat's nice is the transaction in this form cannot go from invalid to valid\n-- once invalid it is always invalid for a given UTXO.\n\nsequence tagged keys have this property -- a txn is either valid or invalid\nand that never changes w/o any external information needing to be passed up.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210712/d6b5a929/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-07-14T03:32:00",
                "message_text_only": "On Mon, Jul 12, 2021 at 03:07:29PM -0700, Jeremy wrote:\n>     Perhaps there's a more general principle -- evaluating a script should\n>     only return one bit of info: \"bool tx_is_invalid_script_failed\"; every\n>     other bit of information -- how much is paid in fees (cf ethereum gas\n>     calculations), when the tx is final, if the tx is only valid in some\n>     chain fork, if other txs have to have already been mined / can't have\n>     been mined, who loses funds and who gets funds, etc... -- should already\n>     be obvious from a \"simple\" parsing of the tx.\n> I don't think we have this property as is.\n> E.g. consider the transaction:\n> TX:\n> \u00a0 \u00a0locktime: None\n> \u00a0 \u00a0sequence: 100\n> \u00a0 \u00a0scriptpubkey: 101 CSV\n\nThat tx will never be valid, no matter the state of the chain -- even if\nit's 420 blocks after the utxo it's spending: it fails because \"top stack\nitem is greater than the transaction input sequence\" rule from BIP 112.\n\n> How will you tell it is able to be included without running the script?\n\nYou have to run the script at some point, but you don't need to run the\nscript to differentiate between it being valid on one chain vs valid on\nsome other chain.\n\n> What's nice is the transaction in this form cannot go from invalid to valid --\n> once invalid it is always invalid for a given UTXO.\n\nHuh? Timelocks always go from invalid to valid -- they're invalid prior\nto some block height (IsFinal() returns false), then valid after.\n\nNot going from valid to invalid is valuable because it limits the cases\nwhere you have to remove txs (and their descendents) from the mempool.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Eltoo / Anyprevout & Baked in Sequences",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Jeremy"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7514
        }
    },
    {
        "title": "[Lightning-dev] Asymmetric features",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-07-08T07:42:19",
                "message_text_only": "Good morning list,\n\nI've been mulling over some limitations of our feature bits mechanism and\nI'm interested in your ideas and comments.\n\nOur feature bits mechanism works well for symmetric features (where both\npeers play the same role) but not so well for asymmetric features (where\nthere is a client and a service provider). Here is a hypothetical example to\nillustrate that. Any similarity to existing wallet features is entirely\ncoincidental.\n\nAlice has a mobile lightning wallet that can be woken up via push\nnotifications.\nBob runs a lightning node that can send push notifications to mobile\nwallets to\nwake them up on important events (e.g. incoming htlcs).\n\nWe can't use a single feature bit to model that, because what Alice supports\nis actually \"I can be woken up via push notifications\", but she can't send\npush\nnotifications to other nodes (and similarly, Bob only supports waking up\nother\nnodes, not receiving push notifications).\n\nSo we must use two feature bits: `wake_me_up_plz` and `i_say_wake_up`.\nAlice activates `wake_me_up_plz`, Bob activates `i_say_wake_up` and it's\nnow clear what part of the protocol each node can handle.\n\nBut how does Alice require her peers to support `i_say_wake_up`?\nShe can't turn on the feature with the mandatory bit because then her peers\nwould be confused and think she can wake up other devices.\n\nI see two potential solutions:\n\n   1. Re-purpose the meaning of `optional` and `mandatory` bits for\n   asymmetric feature: the odd bit would mean \"I support this feature\"\n   and the even bit would mean \"I require my peer to support this feature\"\n   2. Add a requirement to send a warning and disconnect when a client\n   connects to a provider that hasn't activated the provider-side feature\n\nThoughts?\n\nCheers,\nBastien\n\nNote: I opened an issue for that for those who prefer github:\nhttps://github.com/lightningnetwork/lightning-rfc/issues/885\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210708/d523308b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Asymmetric features",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2076
        }
    },
    {
        "title": "[Lightning-dev] BIP-118 / SigHash \"what's covered\" Cheatsheet",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-07-10T00:11:58",
                "message_text_only": "As a part of my ongoing review of BIP-118 I put together the following\nchart.\n\nSource:\nhttps://docs.google.com/spreadsheets/d/1KeWJ_cly9zoRX5_h70RTniRT2m8_iaVceK_aF6obWeM\n\nNot tightly checked to be free of errors, but I figured such a chart would\nbe helpful for folks evaluating BIP-118.\n\nPerhaps the BIPs (generally, incl 34x) could be updated to present the\ninformation in such a chart -- at least for me it's much clearer than\nfollowing a bunch of conditional logic (maybe if there's ever desire for\nsome consensus refactoring this could be a table in the code replacing the\ncond logic).\n\n[image: image.png]\n\nA few highlighted nuances:\n\n- input index is never signed (i previously thought one mode signed it).\nKey reuse under APOAS|Default and APOAS|All is a bit extra unsafe given\nsusceptibility to the \"half-spend\" problem. This limits usability of APO\nfor covenants a-la CTV because you can't stop someone from adding inputs to\nyour contract nor can you prevent half-spend problems when reusing\naddresses.\n- APO signs the Amounts, APOAS never does.\n- APO signs both the SPK and the Tapleaf hash, meaning that APO binds\nitself to the entire script rather than just it's fragment. There's no\nsetting which is \"just this fragment\"\n- APO's signature binds it to a specific script fragment *within* a taproot\nkey, but not a specific script path\n- the flag \"default\" is not really a flag at all -- when default is used\n(as a or'd byte) there are different results than when default is inferred\n(by absence of a byte) (this is maybe a bitcoin core specific quirk).\n- There are 16 different possible modes total, so all combinations of flags\nmean *something* (advisable or not as with ACP | None)\n- | Default and | All overlap, so there's an opportunity to either reserve\nor assign 4 additional sighash modes if desired. These could cover some of\nthe gaps above, or be saved for future purposes rather than be wasted now.\nAnother point of interest is -- not to rock the boat -- but because BIP-118\nis defining a new key type we could do away with the notion that sighash\nflags are \"flags\" and convert to an enum (e.g., numbered 0-256 for whatever\ncombination of fields each would incur) and give each signature type a\nsensible name, rather than thinking of things as a combo of flags (e.g.,\nAPOAS is not some intersection of what APO and ACP do independently).\n\nHopefully this helps!\n\nCheers,\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210709/620c1d70/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image.png\nType: image/png\nSize: 1104237 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210709/620c1d70/attachment-0001.png>"
            }
        ],
        "thread_summary": {
            "title": "BIP-118 / SigHash \"what's covered\" Cheatsheet",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2937
        }
    },
    {
        "title": "[Lightning-dev] Proposal for an invoice pattern with an embedded Bitcoin onchain address",
        "thread_messages": [
            {
                "author": "micaroni at gmail.com",
                "date": "2021-07-10T05:55:55",
                "message_text_only": "Hi,\n\nI propose a new LN invoice pattern that contains a Bitcoin address for\nonchain transfer as backup.\n\nMotivation: My dream is to have an app wallet that works in a totally\nabstract and transparent way onchain and/or LN depending on the situation.\nPhoenix wallet almost achieves this, but there is still a certain\nLN/onchain distinction that confuses users a bit.\n\nI use Phoenix daily. Today, for some reason, I couldn't pay a friend.\nPayment failed in several attempts. It was not clear why. The fact is that\nI managed to transfer to Breeze and then from there I was finally able to\ntransfer to the final destination. For some reason it had no liquidity on\nthe specific route. These exception cases greatly confuse the most\nnon-expert users. If, on the invoice my friend sent to me, I had embedded a\nBitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\nwant to send it on-chain at XPTO fee rate? It can take a while.\"\n\nThat way, in case of payment failure, there is an immediate onchain backup\nalternative, useful especially when rates are low, like now.\n\nThe format could be something like:\n\n<prefix>:<version>:<bitcoin address>:<invoice>\n\nExample:\n\nln:v2:Hi,\n\nI propose a new invoice pattern that contains a Bitcoin address for onchain\ntransfer.\n\nMotivation: My dream is to have a portfolio that works in a totally\nabstract and transparent way onchain and/or LN depending on the situation.\nPhoenix wallet almost achieves this, but there is still a certain\nLN/onchain distinction that confuses users a bit.\n\nI use Phoenix daily. Today, for some reason, I couldn't pay a friend.\nPayment failed in several attempts. It was not clear why. The fact is that\nI managed to transfer to Breeze and then from there I was finally able to\ntransfer to the final destination. For some reason it had no liquidity on\nthe specific route. These exception cases greatly confuse the most\nnon-expert users. If, on the invoice my friend sent me, I had embedded a\nBitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\nwant to send onchain at XPTO rate?\"\n\nThat way, in case of payment failure, there is an immediate onchain backup\nalternative, useful especially when rates are low, like now.\n\nThe format could be something like:\n\n<prefix>:<version>:<bitcoin address>:<invoice>\n\nExample:\n\nln:v1:bc1qucfe06nunhrczh9nrfdxyvma84thy3eugs0825:lnbc20m1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqhp58yjmdan79s6qqdhdzgynm4zwqd5d7xmw5fk98klysy043l2ahrqsfpp3qjmp7lwpagxun9pygexvgpjdc4jdj85fr9yq20q82gphp2nflc7jtzrcazrra7wwgzxqc8u7754cdlpfrmccae92qgzqvzq2ps8pqqqqqqpqqqqq9qqqvpeuqafqxu92d8lr6fvg0r5gv0heeeqgcrqlnm6jhphu9y00rrhy4grqszsvpcgpy9qqqqqqgqqqqq7qqzqj9n4evl6mr5aj9f58zp6fyjzup6ywn3x6sk8akg5v4tgn2q8g4fhx05wf6juaxu9760yp46454gpg5mtzgerlzezqcqvjnhjh8z3g2qqdhhwkj\n\nThank you.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/01fd7239/attachment.html>"
            },
            {
                "author": "micaroni at gmail.com",
                "date": "2021-07-10T05:58:55",
                "message_text_only": "I'm sorry for the bad copy/paste in the last email. Resending:\n\nHi,\n\nI propose a new invoice pattern that contains a Bitcoin address for onchain\ntransfer.\n\nMotivation: My dream is to have a portfolio that works in a totally\nabstract and transparent way onchain and/or LN depending on the situation.\nPhoenix wallet almost achieves this, but there is still a certain\nLN/onchain distinction that confuses users a bit.\n\nI use Phoenix daily. Today, for some reason, I couldn't pay a friend.\nPayment failed in several attempts. It was not clear why. The fact is that\nI managed to transfer to Breeze and then from there I was finally able to\ntransfer to the final destination. For some reason it had no liquidity on\nthe specific route. These exception cases greatly confuse the most\nnon-expert users. If, on the invoice my friend sent me, I had embedded a\nBitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\nwant to send onchain at XPTO rate?\"\n\nThat way, in case of payment failure, there is an immediate onchain backup\nalternative, useful especially when rates are low, like now.\n\nThe format could be something like:\n\n<prefix>:<version>:<bitcoin address>:<invoice>\n\nExample:\n\nln:v1:bc1qucfe06nunhrczh9nrfdxyvma84thy3eugs0825:lnbc20m1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqhp58yjmdan79s6qqdhdzgynm4zwqd5d7xmw5fk98klysy043l2ahrqsfpp3qjmp7lwpagxun9pygexvgpjdc4jdj85fr9yq20q82gphp2nflc7jtzrcazrra7wwgzxqc8u7754cdlpfrmccae92qgzqvzq2ps8pqqqqqqpqqqqq9qqqvpeuqafqxu92d8lr6fvg0r5gv0heeeqgcrqlnm6jhphu9y00rrhy4grqszsvpcgpy9qqqqqqgqqqqq7qqzqj9n4evl6mr5aj9f58zp6fyjzup6ywn3x6sk8akg5v4tgn2q8g4fhx05wf6juaxu9760yp46454gpg5mtzgerlzezqcqvjnhjh8z3g2qqdhhwkj\n\nThank you.\n\nOn Sat, Jul 10, 2021 at 2:55 AM <micaroni at gmail.com> wrote:\n\n> Hi,\n>\n> I propose a new LN invoice pattern that contains a Bitcoin address for\n> onchain transfer as backup.\n>\n> Motivation: My dream is to have an app wallet that works in a totally\n> abstract and transparent way onchain and/or LN depending on the situation.\n> Phoenix wallet almost achieves this, but there is still a certain\n> LN/onchain distinction that confuses users a bit.\n>\n> I use Phoenix daily. Today, for some reason, I couldn't pay a friend.\n> Payment failed in several attempts. It was not clear why. The fact is that\n> I managed to transfer to Breeze and then from there I was finally able to\n> transfer to the final destination. For some reason it had no liquidity on\n> the specific route. These exception cases greatly confuse the most\n> non-expert users. If, on the invoice my friend sent to me, I had embedded a\n> Bitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\n> want to send it on-chain at XPTO fee rate? It can take a while.\"\n>\n> That way, in case of payment failure, there is an immediate onchain backup\n> alternative, useful especially when rates are low, like now.\n>\n> The format could be something like:\n>\n> <prefix>:<version>:<bitcoin address>:<invoice>\n>\n> Example:\n>\n> ln:v2:Hi,\n>\n> I propose a new invoice pattern that contains a Bitcoin address for\n> onchain transfer.\n>\n> Motivation: My dream is to have a portfolio that works in a totally\n> abstract and transparent way onchain and/or LN depending on the situation.\n> Phoenix wallet almost achieves this, but there is still a certain\n> LN/onchain distinction that confuses users a bit.\n>\n> I use Phoenix daily. Today, for some reason, I couldn't pay a friend.\n> Payment failed in several attempts. It was not clear why. The fact is that\n> I managed to transfer to Breeze and then from there I was finally able to\n> transfer to the final destination. For some reason it had no liquidity on\n> the specific route. These exception cases greatly confuse the most\n> non-expert users. If, on the invoice my friend sent me, I had embedded a\n> Bitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\n> want to send onchain at XPTO rate?\"\n>\n> That way, in case of payment failure, there is an immediate onchain backup\n> alternative, useful especially when rates are low, like now.\n>\n> The format could be something like:\n>\n> <prefix>:<version>:<bitcoin address>:<invoice>\n>\n> Example:\n>\n>\n> ln:v1:bc1qucfe06nunhrczh9nrfdxyvma84thy3eugs0825:lnbc20m1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqhp58yjmdan79s6qqdhdzgynm4zwqd5d7xmw5fk98klysy043l2ahrqsfpp3qjmp7lwpagxun9pygexvgpjdc4jdj85fr9yq20q82gphp2nflc7jtzrcazrra7wwgzxqc8u7754cdlpfrmccae92qgzqvzq2ps8pqqqqqqpqqqqq9qqqvpeuqafqxu92d8lr6fvg0r5gv0heeeqgcrqlnm6jhphu9y00rrhy4grqszsvpcgpy9qqqqqqgqqqqq7qqzqj9n4evl6mr5aj9f58zp6fyjzup6ywn3x6sk8akg5v4tgn2q8g4fhx05wf6juaxu9760yp46454gpg5mtzgerlzezqcqvjnhjh8z3g2qqdhhwkj\n>\n> Thank you.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/7c6e9821/attachment-0001.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2021-07-10T06:56:47",
                "message_text_only": "Hi,\n\nI am sorry to hear you had trouble with payment pathfinding. However if I\nunderstand your suggestion correctly I think the proposed functionality\nalready exists in a very similar way in today's invoices with a mechanism\ncalled fallback address. The main difference seems to be that the fallback\nadress is not a human readable part of the invoice string but encoded with\nthe other data in the bech32 part of the invoice.\n\nCheck bolt 11 [1] on github for more detail but I copied the relevant\nsnippets from there to this mail.\n\n\n   - f (9): data_length variable, depending on version. Fallback on-chain\n   address: for Bitcoin, this starts with a 5-bit version and contains a\n   witness program or P2PKH or P2SH address.\n\nThe f field allows on-chain fallback; however, this may not make sense for\ntiny or time-sensitive payments. It's possible that new address forms will\nappear; thus, multiple f fields (in an implied preferred order) help with\ntransition, and f fields with versions 19-31 will be ignored by readers.\n\n[1]:\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md\n\nWith kind regards Rene Pickhardt\n\n<micaroni at gmail.com> schrieb am Sa., 10. Juli 2021, 07:56:\n\n> Hi,\n>\n> I propose a new LN invoice pattern that contains a Bitcoin address for\n> onchain transfer as backup.\n>\n> Motivation: My dream is to have an app wallet that works in a totally\n> abstract and transparent way onchain and/or LN depending on the situation.\n> Phoenix wallet almost achieves this, but there is still a certain\n> LN/onchain distinction that confuses users a bit.\n>\n> I use Phoenix daily. Today, for some reason, I couldn't pay a friend.\n> Payment failed in several attempts. It was not clear why. The fact is that\n> I managed to transfer to Breeze and then from there I was finally able to\n> transfer to the final destination. For some reason it had no liquidity on\n> the specific route. These exception cases greatly confuse the most\n> non-expert users. If, on the invoice my friend sent to me, I had embedded a\n> Bitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\n> want to send it on-chain at XPTO fee rate? It can take a while.\"\n>\n> That way, in case of payment failure, there is an immediate onchain backup\n> alternative, useful especially when rates are low, like now.\n>\n> The format could be something like:\n>\n> <prefix>:<version>:<bitcoin address>:<invoice>\n>\n> Example:\n>\n> ln:v2:Hi,\n>\n> I propose a new invoice pattern that contains a Bitcoin address for\n> onchain transfer.\n>\n> Motivation: My dream is to have a portfolio that works in a totally\n> abstract and transparent way onchain and/or LN depending on the situation.\n> Phoenix wallet almost achieves this, but there is still a certain\n> LN/onchain distinction that confuses users a bit.\n>\n> I use Phoenix daily. Today, for some reason, I couldn't pay a friend.\n> Payment failed in several attempts. It was not clear why. The fact is that\n> I managed to transfer to Breeze and then from there I was finally able to\n> transfer to the final destination. For some reason it had no liquidity on\n> the specific route. These exception cases greatly confuse the most\n> non-expert users. If, on the invoice my friend sent me, I had embedded a\n> Bitcoin address, the wallet could simply ask: \"Couldn't send via LN, do you\n> want to send onchain at XPTO rate?\"\n>\n> That way, in case of payment failure, there is an immediate onchain backup\n> alternative, useful especially when rates are low, like now.\n>\n> The format could be something like:\n>\n> <prefix>:<version>:<bitcoin address>:<invoice>\n>\n> Example:\n>\n>\n> ln:v1:bc1qucfe06nunhrczh9nrfdxyvma84thy3eugs0825:lnbc20m1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqhp58yjmdan79s6qqdhdzgynm4zwqd5d7xmw5fk98klysy043l2ahrqsfpp3qjmp7lwpagxun9pygexvgpjdc4jdj85fr9yq20q82gphp2nflc7jtzrcazrra7wwgzxqc8u7754cdlpfrmccae92qgzqvzq2ps8pqqqqqqpqqqqq9qqqvpeuqafqxu92d8lr6fvg0r5gv0heeeqgcrqlnm6jhphu9y00rrhy4grqszsvpcgpy9qqqqqqgqqqqq7qqzqj9n4evl6mr5aj9f58zp6fyjzup6ywn3x6sk8akg5v4tgn2q8g4fhx05wf6juaxu9760yp46454gpg5mtzgerlzezqcqvjnhjh8z3g2qqdhhwkj\n>\n> Thank you.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/f7e247db/attachment.html>"
            },
            {
                "author": "Bitcoin Error Log",
                "date": "2021-07-10T09:09:52",
                "message_text_only": "You can already embed a bitcoin address into an LN invoice. See example by\nclicking \u201ccontribute\u201d at https://thebiz.pro\n\nLooks like this:\n\nbitcoin:bc1qfzaj2jaqhq7yn9hy3c00ndat4lq9me7sdvgc4q?lightning=lnbc50u1pswjc7ppp5qddlvfgk6j8aj3p9c3r7ql5j40yntv30ydcw77a6r8vvxmpf9uzsdrq235x2gzzd9azcgznv4shxmmwyqcjcgz9wp5hxmmyv5srxzjtwf5hxare94xx26t8dqsy66twv45xzms2yq34g3jnxqc52vpncqzpgfppqfzaj2jaqhq7yn9hy3c00ndat4lq9me7ssp5ftd8uqjrdrycugwmq0v868vk0zyu9gntrlla3chr74d83hkdz78s9qyyssqahk0vjzc0yfd3faevtsg0rx6guyyw6mnjmsyw858xtsqp3l4k763jhct4k7q5ndpc4mkznuskzj00vqql8vxlfp6n54kskkc8qheseqqf38kwg\n\n-- \n~ John Carvalho\n\nSchedule: https://calendly.com/bitcoinerrorlog\nChat: https://t.me/bitcoinerrorlog\nSocial: https://twitter.com/bitcoinerrorlog\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/99ff5eef/attachment.html>"
            },
            {
                "author": "Harsha Goli",
                "date": "2021-07-10T12:55:55",
                "message_text_only": "It appears your example is of a bitcoin address embedded in a lighting uri,\nnot the lighting invoice (unless it's serialized and I'm not seeing it)\n\nOn Sat, Jul 10, 2021 at 5:10 AM Bitcoin Error Log <bitcoinerrorlog at gmail.com>\nwrote:\n\n> You can already embed a bitcoin address into an LN invoice. See example by\n> clicking \u201ccontribute\u201d at https://thebiz.pro\n>\n> Looks like this:\n>\n>\n> bitcoin:bc1qfzaj2jaqhq7yn9hy3c00ndat4lq9me7sdvgc4q?lightning=lnbc50u1pswjc7ppp5qddlvfgk6j8aj3p9c3r7ql5j40yntv30ydcw77a6r8vvxmpf9uzsdrq235x2gzzd9azcgznv4shxmmwyqcjcgz9wp5hxmmyv5srxzjtwf5hxare94xx26t8dqsy66twv45xzms2yq34g3jnxqc52vpncqzpgfppqfzaj2jaqhq7yn9hy3c00ndat4lq9me7ssp5ftd8uqjrdrycugwmq0v868vk0zyu9gntrlla3chr74d83hkdz78s9qyyssqahk0vjzc0yfd3faevtsg0rx6guyyw6mnjmsyw858xtsqp3l4k763jhct4k7q5ndpc4mkznuskzj00vqql8vxlfp6n54kskkc8qheseqqf38kwg\n>\n> --\n> ~ John Carvalho\n>\n> Schedule: https://calendly.com/bitcoinerrorlog\n> Chat: https://t.me/bitcoinerrorlog\n> Social: https://twitter.com/bitcoinerrorlog\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/0dc80e3e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal for an invoice pattern with an embedded Bitcoin onchain address",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "micaroni at gmail.com",
                "Harsha Goli",
                "Bitcoin Error Log"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 14649
        }
    },
    {
        "title": "[Lightning-dev] Eltoo Burst Mode & Continuations",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-07-10T21:07:02",
                "message_text_only": "Let's say you're about to hit your sequence limits on a Eltoo channel... Do\nyou have to go on chain?\n\nNo, you could do a continuation where for your *final* update, you sign a\nmove to a new update key. E.g.,\n\nstart at: IF \"N+1\" CLTV DROP <pk_u> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i>\nCHECKSIG ENDIF\n\nbefore N+1 = last, sign a txn with pk_s_last that moves coins to\n\nIF \"1\" CLTV DROP <*pk_u**2*> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i> CHECKSIG\nENDIF\n\nThis essentially lets you do 32 bits worth of updates and then fwd to a new\ncontract by paying 1x extra transaction.\n\nThis is potentially better than just directly closing because we keep it\noff chain for longer.  However... this also adds an additional CSV.\n\n(We can get around this by modifying the script branch which ends a CLTV\ndomain with:\n<pk_s_last> CHECKSIG\nsince any updates past that point are done through the continuation\nstate... but let's ignore that for the next part)\n\nWhat if we *always* used this every update? Then we'd essentially have 64\nbits of sequence space. Each layer of this trick adds 32 bytes.\n\nDoing layers like this inherently adds a bunch of CSV layers, so it\nincreases resolution time linearly.\n\nOne possibility to mitigate this is to do a \"semitrusted burst mode\" with a\ncounterparty. Suppose you're at sequence M and it's a normal txn.\n\nParty A requests to Party B to initiate burst mode. A and B move to\nsequence M+1 where state M+1 passes through to a 2 step Eltoo update.\n\nThis burst now has 32 bits of sequences to blow through.\n\nB or A then indicates to the other party to terminate the burst at\n\"internal state number\" Q. Then B and A sign M+2 where M+2 reflects the\nlast state at internal state number Q. This gets rid of the temporary extra\nlocking time for when parties are offline.\n\nThis has a benefit for privacy as well because if this protocol is used,\nthen top level state numbers do not reflect the # of payments strongly as\nthey're more akin to how many burst mode payments were done.\n\nThe semi trusted nature of this is that if a malicious peer induces you\ninto starting this, you double your funds lockup time. There are some\nmitigations:\n\n1) Only enter burst mode with long lived peers\n2) Only enter burst mode when initiator has more funds in the channel than\nyou (or has some ratio) which imposes an opportunity cost for attacking.\n3) Only allow a certain % of liquidity to be moved during a burst -- e.g.,\nany time the delta in balance goes above a threshold, force a higher order\nchannel state update.\n\n\n\n\nBest,\n\nJeremy\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/1267b270/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-10T23:25:06",
                "message_text_only": "on further reflection, i think you can get around the restriction of CSV by\nsigning a eltoo \"trampoline\".\n\nessentially, begin a burst session at pk1:N under pk2, but always include a\nthird branch to go to any pk1:N+1.\n\nThe scripts look like:\n\nEltoo Layer 1 Regular at state i = N<<32:\nOr(And(After(N+1), Key(PK_u1)), And(Older(2016), Key(PK_s_i))\n\nEltoo Layer 1 During Burst at state i = (N<<32) + M:\nOr(And(After(N+1), Key(PK_u1)), Key(PK_s_burst_N == PK_s_i))\n\nEltoo Layer 2 During Burst at state i = (N<<32) + M:\nOr(And(After(N+1), Key(PK_u1)), And(After(M+1), Key(PK_u_burst_N)),\nAnd(Older(2016), Key(PK_s_i))\n\ni represents the 64 bit concatenation of two 32 bit locktimes, where N is\nMSBs and M is LSBs.\n\nDuring burst mode resolving on chain, either:\n1) the published Layer 1 tx is at the tip state N\n    a) The tip N is at inner tip state M, wait 2016 to close with\nAnd(Older(2016), Key(PK_s_i))\n    b) The tip N is at inner tip state M - c, use path And(After(M+1),\nKey(PK_u_burst_N)) to jump to case 1.a\n2) published Layer 1 tx is at non tip state N - c\n    a) Layer 2 does not get published: use path And(After(N+1), Key(PK_u1))\nto jump back to newest state known on parent, repeat from top\n    b) Layer 2 gets published: use path And(After(N+1), Key(PK_u1)) to jump\nback to newest state known on parent, repeat from top\n\n\nThis trampoline pattern should essentially be repeatable as many times as\nneeded, although I think 2 layers is likely enough in practice.\n\nIn terms of \"state management\", it grows at O(layers) but is otherwise\nconstant. A node must only store:\n\nKey/Sigs for\nPK_s_i: to allow closing at the highest reachable state\nPK_u1\nDuring burst:\n    PK_u_burst_N: to allow getting to current burst\n    PK_s_burst_N: the same as PK_s_i just makes sense to think of it's\ndistinct purpose from PK_s_i not requiring a sequence lock\n\nNote that the above scripts can be optimized to remove the Older clause as\nit can be a rule that all PK_s_i must sign with a sequence unless entering\na burst.\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sat, Jul 10, 2021 at 2:07 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Let's say you're about to hit your sequence limits on a Eltoo channel...\n> Do you have to go on chain?\n>\n> No, you could do a continuation where for your *final* update, you sign a\n> move to a new update key. E.g.,\n>\n> start at: IF \"N+1\" CLTV DROP <pk_u> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i>\n> CHECKSIG ENDIF\n>\n> before N+1 = last, sign a txn with pk_s_last that moves coins to\n>\n> IF \"1\" CLTV DROP <*pk_u**2*> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i>\n> CHECKSIG ENDIF\n>\n> This essentially lets you do 32 bits worth of updates and then fwd to a\n> new contract by paying 1x extra transaction.\n>\n> This is potentially better than just directly closing because we keep it\n> off chain for longer.  However... this also adds an additional CSV.\n>\n> (We can get around this by modifying the script branch which ends a CLTV\n> domain with:\n> <pk_s_last> CHECKSIG\n> since any updates past that point are done through the continuation\n> state... but let's ignore that for the next part)\n>\n> What if we *always* used this every update? Then we'd essentially have 64\n> bits of sequence space. Each layer of this trick adds 32 bytes.\n>\n> Doing layers like this inherently adds a bunch of CSV layers, so it\n> increases resolution time linearly.\n>\n> One possibility to mitigate this is to do a \"semitrusted burst mode\" with\n> a counterparty. Suppose you're at sequence M and it's a normal txn.\n>\n> Party A requests to Party B to initiate burst mode. A and B move to\n> sequence M+1 where state M+1 passes through to a 2 step Eltoo update.\n>\n> This burst now has 32 bits of sequences to blow through.\n>\n> B or A then indicates to the other party to terminate the burst at\n> \"internal state number\" Q. Then B and A sign M+2 where M+2 reflects the\n> last state at internal state number Q. This gets rid of the temporary extra\n> locking time for when parties are offline.\n>\n> This has a benefit for privacy as well because if this protocol is used,\n> then top level state numbers do not reflect the # of payments strongly as\n> they're more akin to how many burst mode payments were done.\n>\n> The semi trusted nature of this is that if a malicious peer induces you\n> into starting this, you double your funds lockup time. There are some\n> mitigations:\n>\n> 1) Only enter burst mode with long lived peers\n> 2) Only enter burst mode when initiator has more funds in the channel than\n> you (or has some ratio) which imposes an opportunity cost for attacking.\n> 3) Only allow a certain % of liquidity to be moved during a burst -- e.g.,\n> any time the delta in balance goes above a threshold, force a higher order\n> channel state update.\n>\n>\n>\n>\n> Best,\n>\n> Jeremy\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/5b8c73ed/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-11T00:02:35",
                "message_text_only": "Last thought:\n\nsuppose you make a Taproot tree with N copies (with different keys) of the\nstate update protocol.\n\nThen what you can do is use the 1st copy  until you hit MAX_STATE, and then\nstart signing with the 2nd copy back an state 0 but when you sign with the\n2nd copy you *remove* the 1st copy from the taproot tree.\n\ne.g.,\n\n{A:0, B:0, C:0} -> {A:1, B:0, C:0} -> {A:MAX, B:0, C:0} -> {B:1, C:0}...\n\nThen the cut-thru transition\n\n{A:0, B:0, C:0} -> {B:1, C:0}\n\nis valid, but the regression:\n\n{B:N, C:0} -> {A:M, B:0, C:0} is not.\n\n\nYou can take a random path through which leaf you are using which, if\nyou're careful about how you construct your scripts (e.g., keeping the\ntrees the same size) you can be more private w.r.t. how many state updates\nyou performed throughout the protocol (i.e., you can see the low order bits\nin the CLTV clause, but the high order bits of A, B, C's relationship is\nnot revealed if you traverse them in a deterministically permuted order).\n\nThe space downside of this approach v.s. the approach presented in the\nprior email is that the prior approach achieves 64 bits with 2 txns one of\nwhich should be like 150 bytes, a similar amount of data for the script\nleaves may only gets you 5 bits of added sequence space.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Sat, Jul 10, 2021 at 4:25 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> on further reflection, i think you can get around the restriction of CSV\n> by signing a eltoo \"trampoline\".\n>\n> essentially, begin a burst session at pk1:N under pk2, but always include\n> a third branch to go to any pk1:N+1.\n>\n> The scripts look like:\n>\n> Eltoo Layer 1 Regular at state i = N<<32:\n> Or(And(After(N+1), Key(PK_u1)), And(Older(2016), Key(PK_s_i))\n>\n> Eltoo Layer 1 During Burst at state i = (N<<32) + M:\n> Or(And(After(N+1), Key(PK_u1)), Key(PK_s_burst_N == PK_s_i))\n>\n> Eltoo Layer 2 During Burst at state i = (N<<32) + M:\n> Or(And(After(N+1), Key(PK_u1)), And(After(M+1), Key(PK_u_burst_N)),\n> And(Older(2016), Key(PK_s_i))\n>\n> i represents the 64 bit concatenation of two 32 bit locktimes, where N is\n> MSBs and M is LSBs.\n>\n> During burst mode resolving on chain, either:\n> 1) the published Layer 1 tx is at the tip state N\n>     a) The tip N is at inner tip state M, wait 2016 to close with\n> And(Older(2016), Key(PK_s_i))\n>     b) The tip N is at inner tip state M - c, use path And(After(M+1),\n> Key(PK_u_burst_N)) to jump to case 1.a\n> 2) published Layer 1 tx is at non tip state N - c\n>     a) Layer 2 does not get published: use path And(After(N+1),\n> Key(PK_u1)) to jump back to newest state known on parent, repeat from top\n>     b) Layer 2 gets published: use path And(After(N+1), Key(PK_u1)) to\n> jump back to newest state known on parent, repeat from top\n>\n>\n> This trampoline pattern should essentially be repeatable as many times as\n> needed, although I think 2 layers is likely enough in practice.\n>\n> In terms of \"state management\", it grows at O(layers) but is otherwise\n> constant. A node must only store:\n>\n> Key/Sigs for\n> PK_s_i: to allow closing at the highest reachable state\n> PK_u1\n> During burst:\n>     PK_u_burst_N: to allow getting to current burst\n>     PK_s_burst_N: the same as PK_s_i just makes sense to think of it's\n> distinct purpose from PK_s_i not requiring a sequence lock\n>\n> Note that the above scripts can be optimized to remove the Older clause as\n> it can be a rule that all PK_s_i must sign with a sequence unless entering\n> a burst.\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n>\n>\n> On Sat, Jul 10, 2021 at 2:07 PM Jeremy <jlrubin at mit.edu> wrote:\n>\n>> Let's say you're about to hit your sequence limits on a Eltoo channel...\n>> Do you have to go on chain?\n>>\n>> No, you could do a continuation where for your *final* update, you sign a\n>> move to a new update key. E.g.,\n>>\n>> start at: IF \"N+1\" CLTV DROP <pk_u> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i>\n>> CHECKSIG ENDIF\n>>\n>> before N+1 = last, sign a txn with pk_s_last that moves coins to\n>>\n>> IF \"1\" CLTV DROP <*pk_u**2*> CHECKSIG  ELSE 2016 CSV DROP <pk_s_i>\n>> CHECKSIG ENDIF\n>>\n>> This essentially lets you do 32 bits worth of updates and then fwd to a\n>> new contract by paying 1x extra transaction.\n>>\n>> This is potentially better than just directly closing because we keep it\n>> off chain for longer.  However... this also adds an additional CSV.\n>>\n>> (We can get around this by modifying the script branch which ends a CLTV\n>> domain with:\n>> <pk_s_last> CHECKSIG\n>> since any updates past that point are done through the continuation\n>> state... but let's ignore that for the next part)\n>>\n>> What if we *always* used this every update? Then we'd essentially have 64\n>> bits of sequence space. Each layer of this trick adds 32 bytes.\n>>\n>> Doing layers like this inherently adds a bunch of CSV layers, so it\n>> increases resolution time linearly.\n>>\n>> One possibility to mitigate this is to do a \"semitrusted burst mode\" with\n>> a counterparty. Suppose you're at sequence M and it's a normal txn.\n>>\n>> Party A requests to Party B to initiate burst mode. A and B move to\n>> sequence M+1 where state M+1 passes through to a 2 step Eltoo update.\n>>\n>> This burst now has 32 bits of sequences to blow through.\n>>\n>> B or A then indicates to the other party to terminate the burst at\n>> \"internal state number\" Q. Then B and A sign M+2 where M+2 reflects the\n>> last state at internal state number Q. This gets rid of the temporary extra\n>> locking time for when parties are offline.\n>>\n>> This has a benefit for privacy as well because if this protocol is used,\n>> then top level state numbers do not reflect the # of payments strongly as\n>> they're more akin to how many burst mode payments were done.\n>>\n>> The semi trusted nature of this is that if a malicious peer induces you\n>> into starting this, you double your funds lockup time. There are some\n>> mitigations:\n>>\n>> 1) Only enter burst mode with long lived peers\n>> 2) Only enter burst mode when initiator has more funds in the channel\n>> than you (or has some ratio) which imposes an opportunity cost for\n>> attacking.\n>> 3) Only allow a certain % of liquidity to be moved during a burst --\n>> e.g., any time the delta in balance goes above a threshold, force a higher\n>> order channel state update.\n>>\n>>\n>>\n>>\n>> Best,\n>>\n>> Jeremy\n>>\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210710/fcb0610b/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-07-11T04:10:00",
                "message_text_only": "On Sat, Jul 10, 2021 at 02:07:02PM -0700, Jeremy wrote:\n> Let's say you're about to hit your sequence limits on a Eltoo channel... Do you\n> have to go on chain?\n> No, you could do a continuation where for your *final* update, you sign a move\n> to a new update key. E.g.,\n\nThat adds an extra tx to the uncooperative path every 2**30 states.\n\n> Doing layers like this inherently adds a bunch of CSV layers, so it increases\n> resolution time linearly.\n\nI don't think that's correct -- you should be using the CLTV path for\nupdating the state, rather than the CSV path; so CSV shouldn't matter.\n\nOn Sat, Jul 10, 2021 at 04:25:06PM -0700, Jeremy wrote:\n> [...] signing a eltoo \"trampoline\".\n> essentially, begin a burst session at pk1:N under pk2, but always include a\n> third branch to go to any pk1:N+1.\n\nI think this is effectively reinventing/special casing channel\nfactories? That is you start an eltoo channel factory amongst group\n{A,B,C,...}, then if {A,B} want an eltoo channel, that's a single update\nto the factory; that channel can get updated independently until A and\nB get bored and want to close their channel, which is then a single\nadditional update to the factory. In this case, the factory just doesn't\ninclude the additional members {C,...}.\n\nOn Sat, Jul 10, 2021 at 05:02:35PM -0700, Jeremy wrote:\n> suppose you make a Taproot tree with N copies (with different keys) of the\n> state update protocol.\n\nThis feels cleverer/novel to me -- but as you point out it's actually\nmore costly than the trampoline/factory approach so perhaps it's not\nthat great.\n\nI think what you'd do is change from a single tapscript of \"OP_1\nCHECKSIG <500e6+i> CLTV\" to a tree of tapscripts:\n\n  \"<P_i> CHECKSIG <500e6+j+1> CLTV\"\n\nso if your state is (i*2**30 + j) you're spending using <P_i> with a\nlocktime of 500e6+j, and you're allowing later spends with the above script\nfilled in with (i,j) or (i',0) for i<i'<N.\n\nThat means you're paying extra to specify a merkle path of lg(N)*32 and\nthe key P_i (33 bytes).\n\n> You can take a random path through which leaf you are using which, if you're\n> careful about how you construct your scripts (e.g., keeping the trees the same\n> size) you can be more private w.r.t. how many state updates you performed\n> throughout the protocol (i.e., you can see the low order bits in the CLTV\n> clause, but the high order bits of A, B, C's relationship is not revealed if\n> you traverse them in a deterministically permuted order).\n\nTapscript trees are shuffled randomly based on the hashes of their\nscripts, so I think that's a non-issue. You could keep the trees the\nsame size by adding scripts \"<P_i> CHECKSIG <500e6+j+1> RETURN\".\n\n> The space downside of this approach v.s. the approach presented in the prior\n> email is that the prior approach achieves 64 bits with 2 txns one of which\n> should be like 150 bytes, a similar amount of data for the script leaves may\n> only gets you 5 bits of added sequence space.\u00a0\n\nYou'd get 2**34 states (4 added bits of added sequence space) for\nabout 161 extra bytes (4 merkle branches at 32B each and revealing the\npubkey for 33B), compared to about 2**60 states (2**30 states for the\nsecond tx, with a different second tx for each of the 2**30 states of\nthe first tx). Haven't done the math to check the 150 byte estimate,\nbut it seems the right ballpark.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Eltoo Burst Mode & Continuations",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Jeremy"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 17886
        }
    },
    {
        "title": "[Lightning-dev] Impact of eltoo loss of state",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2021-07-12T08:17:49",
                "message_text_only": "Hello world,\n\nSuppose you have some payments going from Alice to Bob to Carol with\neltoo channels. Bob's lightning node crashes, and he recovers from an\nold backup, and Alice and Carol end up dropping newer channel states\nonto the blockchain.\n\nSuppose the timeout for the payments is a few hours away, while the\nchannels have specified a week long CSV delay to rectify any problems\non-chain.\n\nThen I think that that means that:\n\n 1) Carol will reveal the point preimages on-chain via adaptor\n    signatures, but Bob won't be able to decode those adaptor signatures\n    because those signatures will need to change for each state\n\n 2) Even if Bob knows the point preimages, he won't be able to\n    claim the PTLC payments on-chain, for the same reason: he needs\n    newer adaptor signatures that he'll have lost with the state update\n\n 3) For any payments that timeout, Carol doesn't have any particular\n    incentive to make it easy for Bob to claim the refund, and Bob won't\n    have the adaptor signatures for the latest state to do so\n\n 4) But Alice will be able to claim refunds easily. This is working how\n    it's meant to, at least!\n\nI think you could fix (3) by giving Carol (who does have all the adaptor\nsignatures for the latest state) the ability to steal funds that are\nmeant to have been refunded, provided she gives Bob the option of claiming\nthem first.\n\nHowever fixing (1) and (2) aren't really going against Alice or Carol's\ninterests, so maybe you can just ask: Carol loses nothing by allowing\nBob to claim funds from Alice; and Alice has already indicated that\nknowing P is worth more to her than the PTLC's funds -- otherwise she\nwouldn't have forwarded the PTLC to Bob in the first place.\n\nLikewise, everyone's probably incentivised to negotiate cooperative\ncloses instead of going on-chain -- better privacy, less fees, and less\ndelay before the funds can be used elsewhere.\n\nFWIW, I think a similar flaw exists even in the original eltoo spec --\nAlice could simply decline to publish the settlement transaction until\nthe timeout has been reached, preventing Bob from revealing the HTLC\npreimage before Alice can claim the refund.\n\nSo I think that adds up to:\n\n a) Nodes should share state on reconnection; if you find a node that\n    doesn't do this, close the channel and put the node on your enemies\n    list. If you disagree on what the current state is, share your most\n    recent state, and if the other guy's state is more recent, and all\n    the signatures verify, update your state to match theirs.\n\n b) Always negotiate a mutual/cooperative close if possible, to avoid\n    actually using the eltoo protocol on-chain.\n\n c) If you want to allow continuing the channel after restoring an old\n    state from backup, set the channel state index based on the real time,\n    eg (real_time-start_time)*(max_updates_per_second). That way your\n    first update after a restore from backup will ensure that any old\n    states that your channel partner may not have told you about are\n    invalidated.\n\n d) Accept that if you lose connectivity to a channel partner, you will\n    have to pay any PTLCs that were going to them, and won't be able\n    to claim the PTLCs that were funding them. Perhaps limit the total\n    value of inbound PTLCs for forwarding that you're willing to accept\n    at any one itme?\n\nAlso, layered commitments seem like they make channel factories\ncomplicated too. Nobody came up with a way to avoid layered commitments\nwhile I wasn't watching did they?\n\nCheers,\naj"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-12T22:16:43",
                "message_text_only": "Without an exact implementation, one thing you could do to fix the lost\nstate issue would be to make the scripts something like:\n\n[`<N+1> CLTV DROP PKu CHECKSIGVERIFY GETLOCKTIME <PK_root>\nBIP32DERIVE CHECKTRANSACTIONSIGNEDFROMSTACK`, `2016 CSV DROP PK_si\nCHECKSIG`]\n\nIn order to upgrade to state M>= N+1 you'd have to publish a transaction\nsigned with the BIP32 derived key for that update in the future.\n\nThe downside is that you end up double publishing the txdata on the chain,\nbut it at least ensure data availability.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210712/dabb3aed/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-12T22:20:41",
                "message_text_only": "Another option would be to somehow encrypt this data in, say, an OP_RETURN\nfor any update transaction for each participant (perhaps worth breaking\nupdate symmetry for efficiency on this...) that way if an update ever\nhappens on a state you don't have you can use your static key to decrypt\nthe relevant data for what PK_si signed off on.\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n\n\nOn Mon, Jul 12, 2021 at 3:16 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> Without an exact implementation, one thing you could do to fix the lost\n> state issue would be to make the scripts something like:\n>\n> [`<N+1> CLTV DROP PKu CHECKSIGVERIFY GETLOCKTIME <PK_root>\n> BIP32DERIVE CHECKTRANSACTIONSIGNEDFROMSTACK`, `2016 CSV DROP PK_si\n> CHECKSIG`]\n>\n> In order to upgrade to state M>= N+1 you'd have to publish a transaction\n> signed with the BIP32 derived key for that update in the future.\n>\n> The downside is that you end up double publishing the txdata on the chain,\n> but it at least ensure data availability.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210712/54e583d7/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2021-07-14T14:44:24",
                "message_text_only": "Not quite sure if this issue is unique to eltoo tbh. While in LN-penalty\nloss-of-state equates to loss-of-funds, in eltoo this is reduced to\nimpact only funds that are in a PTLC at the time of the loss-of-state.\n\nWe have a couple of options here, that don't touch the blockchain, and\nare therefore rather lightweight:\n\n 1) Do nothing and keep the incentive to keep up to date backups. It\n still is a reduction in risk w.r.t. LN-penalty, since this is just an\n append only log of secrets, and old secrets don't harm you like\n attempting to close with an old commitment would.\n 2) Use the peer-storage idea, where we deposit an encrypted bundle with\n our peers, and which we expect the peers to return. by hiding the fact\n that we forgot some state, until the data has been exchanged we can\n ensure that peers always return the latest snapshot of whatever we gave\n them.\n\nThe latter is the encrypted-blob idea that Rusty has been proposing for\na while now.\n\nCheers,\nChristian\n\nAnthony Towns <aj at erisian.com.au> writes:\n> Hello world,\n>\n> Suppose you have some payments going from Alice to Bob to Carol with\n> eltoo channels. Bob's lightning node crashes, and he recovers from an\n> old backup, and Alice and Carol end up dropping newer channel states\n> onto the blockchain.\n>\n> Suppose the timeout for the payments is a few hours away, while the\n> channels have specified a week long CSV delay to rectify any problems\n> on-chain.\n>\n> Then I think that that means that:\n>\n>  1) Carol will reveal the point preimages on-chain via adaptor\n>     signatures, but Bob won't be able to decode those adaptor signatures\n>     because those signatures will need to change for each state\n>\n>  2) Even if Bob knows the point preimages, he won't be able to\n>     claim the PTLC payments on-chain, for the same reason: he needs\n>     newer adaptor signatures that he'll have lost with the state update\n>\n>  3) For any payments that timeout, Carol doesn't have any particular\n>     incentive to make it easy for Bob to claim the refund, and Bob won't\n>     have the adaptor signatures for the latest state to do so\n>\n>  4) But Alice will be able to claim refunds easily. This is working how\n>     it's meant to, at least!\n>\n> I think you could fix (3) by giving Carol (who does have all the adaptor\n> signatures for the latest state) the ability to steal funds that are\n> meant to have been refunded, provided she gives Bob the option of claiming\n> them first.\n>\n> However fixing (1) and (2) aren't really going against Alice or Carol's\n> interests, so maybe you can just ask: Carol loses nothing by allowing\n> Bob to claim funds from Alice; and Alice has already indicated that\n> knowing P is worth more to her than the PTLC's funds -- otherwise she\n> wouldn't have forwarded the PTLC to Bob in the first place.\n>\n> Likewise, everyone's probably incentivised to negotiate cooperative\n> closes instead of going on-chain -- better privacy, less fees, and less\n> delay before the funds can be used elsewhere.\n>\n> FWIW, I think a similar flaw exists even in the original eltoo spec --\n> Alice could simply decline to publish the settlement transaction until\n> the timeout has been reached, preventing Bob from revealing the HTLC\n> preimage before Alice can claim the refund.\n>\n> So I think that adds up to:\n>\n>  a) Nodes should share state on reconnection; if you find a node that\n>     doesn't do this, close the channel and put the node on your enemies\n>     list. If you disagree on what the current state is, share your most\n>     recent state, and if the other guy's state is more recent, and all\n>     the signatures verify, update your state to match theirs.\n>\n>  b) Always negotiate a mutual/cooperative close if possible, to avoid\n>     actually using the eltoo protocol on-chain.\n>\n>  c) If you want to allow continuing the channel after restoring an old\n>     state from backup, set the channel state index based on the real time,\n>     eg (real_time-start_time)*(max_updates_per_second). That way your\n>     first update after a restore from backup will ensure that any old\n>     states that your channel partner may not have told you about are\n>     invalidated.\n>\n>  d) Accept that if you lose connectivity to a channel partner, you will\n>     have to pay any PTLCs that were going to them, and won't be able\n>     to claim the PTLCs that were funding them. Perhaps limit the total\n>     value of inbound PTLCs for forwarding that you're willing to accept\n>     at any one itme?\n>\n> Also, layered commitments seem like they make channel factories\n> complicated too. Nobody came up with a way to avoid layered commitments\n> while I wasn't watching did they?\n>\n> Cheers,\n> aj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2021-07-15T10:28:17",
                "message_text_only": "What would happen in 2) if the node has data but the peer returned an\nincorrect state?\n\nOn Wed, Jul 14, 2021, 20:13 Christian Decker <decker.christian at gmail.com>\nwrote:\n\n> Not quite sure if this issue is unique to eltoo tbh. While in LN-penalty\n> loss-of-state equates to loss-of-funds, in eltoo this is reduced to\n> impact only funds that are in a PTLC at the time of the loss-of-state.\n>\n> We have a couple of options here, that don't touch the blockchain, and\n> are therefore rather lightweight:\n>\n>  1) Do nothing and keep the incentive to keep up to date backups. It\n>  still is a reduction in risk w.r.t. LN-penalty, since this is just an\n>  append only log of secrets, and old secrets don't harm you like\n>  attempting to close with an old commitment would.\n>  2) Use the peer-storage idea, where we deposit an encrypted bundle with\n>  our peers, and which we expect the peers to return. by hiding the fact\n>  that we forgot some state, until the data has been exchanged we can\n>  ensure that peers always return the latest snapshot of whatever we gave\n>  them.\n>\n> The latter is the encrypted-blob idea that Rusty has been proposing for\n> a while now.\n>\n> Cheers,\n> Christian\n>\n> Anthony Towns <aj at erisian.com.au> writes:\n> > Hello world,\n> >\n> > Suppose you have some payments going from Alice to Bob to Carol with\n> > eltoo channels. Bob's lightning node crashes, and he recovers from an\n> > old backup, and Alice and Carol end up dropping newer channel states\n> > onto the blockchain.\n> >\n> > Suppose the timeout for the payments is a few hours away, while the\n> > channels have specified a week long CSV delay to rectify any problems\n> > on-chain.\n> >\n> > Then I think that that means that:\n> >\n> >  1) Carol will reveal the point preimages on-chain via adaptor\n> >     signatures, but Bob won't be able to decode those adaptor signatures\n> >     because those signatures will need to change for each state\n> >\n> >  2) Even if Bob knows the point preimages, he won't be able to\n> >     claim the PTLC payments on-chain, for the same reason: he needs\n> >     newer adaptor signatures that he'll have lost with the state update\n> >\n> >  3) For any payments that timeout, Carol doesn't have any particular\n> >     incentive to make it easy for Bob to claim the refund, and Bob won't\n> >     have the adaptor signatures for the latest state to do so\n> >\n> >  4) But Alice will be able to claim refunds easily. This is working how\n> >     it's meant to, at least!\n> >\n> > I think you could fix (3) by giving Carol (who does have all the adaptor\n> > signatures for the latest state) the ability to steal funds that are\n> > meant to have been refunded, provided she gives Bob the option of\n> claiming\n> > them first.\n> >\n> > However fixing (1) and (2) aren't really going against Alice or Carol's\n> > interests, so maybe you can just ask: Carol loses nothing by allowing\n> > Bob to claim funds from Alice; and Alice has already indicated that\n> > knowing P is worth more to her than the PTLC's funds -- otherwise she\n> > wouldn't have forwarded the PTLC to Bob in the first place.\n> >\n> > Likewise, everyone's probably incentivised to negotiate cooperative\n> > closes instead of going on-chain -- better privacy, less fees, and less\n> > delay before the funds can be used elsewhere.\n> >\n> > FWIW, I think a similar flaw exists even in the original eltoo spec --\n> > Alice could simply decline to publish the settlement transaction until\n> > the timeout has been reached, preventing Bob from revealing the HTLC\n> > preimage before Alice can claim the refund.\n> >\n> > So I think that adds up to:\n> >\n> >  a) Nodes should share state on reconnection; if you find a node that\n> >     doesn't do this, close the channel and put the node on your enemies\n> >     list. If you disagree on what the current state is, share your most\n> >     recent state, and if the other guy's state is more recent, and all\n> >     the signatures verify, update your state to match theirs.\n> >\n> >  b) Always negotiate a mutual/cooperative close if possible, to avoid\n> >     actually using the eltoo protocol on-chain.\n> >\n> >  c) If you want to allow continuing the channel after restoring an old\n> >     state from backup, set the channel state index based on the real\n> time,\n> >     eg (real_time-start_time)*(max_updates_per_second). That way your\n> >     first update after a restore from backup will ensure that any old\n> >     states that your channel partner may not have told you about are\n> >     invalidated.\n> >\n> >  d) Accept that if you lose connectivity to a channel partner, you will\n> >     have to pay any PTLCs that were going to them, and won't be able\n> >     to claim the PTLCs that were funding them. Perhaps limit the total\n> >     value of inbound PTLCs for forwarding that you're willing to accept\n> >     at any one itme?\n> >\n> > Also, layered commitments seem like they make channel factories\n> > complicated too. Nobody came up with a way to avoid layered commitments\n> > while I wasn't watching did they?\n> >\n> > Cheers,\n> > aj\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210715/54d800a3/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2021-07-20T10:57:17",
                "message_text_only": "We'd likely be using an HMAC to ensure the integrity of the data returned\nby peers, so we'd only have to guard against them returning an older\nversion, which in eltoo. Furthermore by retrieving the blobs on reconnect\nregardless of whether we need them or not we can verify that peers are\nbehaving correctly, since they shouldn't be able to distinguish whether\nwe're just checking or actually need the data. In addition we can store the\nsame data with multiple peers, ensuring that as long as one node is\nbehaving we're good.\n\nCheers,\nChristian\n\nOn Thu, 15 Jul 2021, 12:28 Martin Habov\u0161tiak <martin.habovstiak at gmail.com>\nwrote:\n\n> What would happen in 2) if the node has data but the peer returned an\n> incorrect state?\n>\n> On Wed, Jul 14, 2021, 20:13 Christian Decker <decker.christian at gmail.com>\n> wrote:\n>\n>> Not quite sure if this issue is unique to eltoo tbh. While in LN-penalty\n>> loss-of-state equates to loss-of-funds, in eltoo this is reduced to\n>> impact only funds that are in a PTLC at the time of the loss-of-state.\n>>\n>> We have a couple of options here, that don't touch the blockchain, and\n>> are therefore rather lightweight:\n>>\n>>  1) Do nothing and keep the incentive to keep up to date backups. It\n>>  still is a reduction in risk w.r.t. LN-penalty, since this is just an\n>>  append only log of secrets, and old secrets don't harm you like\n>>  attempting to close with an old commitment would.\n>>  2) Use the peer-storage idea, where we deposit an encrypted bundle with\n>>  our peers, and which we expect the peers to return. by hiding the fact\n>>  that we forgot some state, until the data has been exchanged we can\n>>  ensure that peers always return the latest snapshot of whatever we gave\n>>  them.\n>>\n>> The latter is the encrypted-blob idea that Rusty has been proposing for\n>> a while now.\n>>\n>> Cheers,\n>> Christian\n>>\n>> Anthony Towns <aj at erisian.com.au> writes:\n>> > Hello world,\n>> >\n>> > Suppose you have some payments going from Alice to Bob to Carol with\n>> > eltoo channels. Bob's lightning node crashes, and he recovers from an\n>> > old backup, and Alice and Carol end up dropping newer channel states\n>> > onto the blockchain.\n>> >\n>> > Suppose the timeout for the payments is a few hours away, while the\n>> > channels have specified a week long CSV delay to rectify any problems\n>> > on-chain.\n>> >\n>> > Then I think that that means that:\n>> >\n>> >  1) Carol will reveal the point preimages on-chain via adaptor\n>> >     signatures, but Bob won't be able to decode those adaptor signatures\n>> >     because those signatures will need to change for each state\n>> >\n>> >  2) Even if Bob knows the point preimages, he won't be able to\n>> >     claim the PTLC payments on-chain, for the same reason: he needs\n>> >     newer adaptor signatures that he'll have lost with the state update\n>> >\n>> >  3) For any payments that timeout, Carol doesn't have any particular\n>> >     incentive to make it easy for Bob to claim the refund, and Bob won't\n>> >     have the adaptor signatures for the latest state to do so\n>> >\n>> >  4) But Alice will be able to claim refunds easily. This is working how\n>> >     it's meant to, at least!\n>> >\n>> > I think you could fix (3) by giving Carol (who does have all the adaptor\n>> > signatures for the latest state) the ability to steal funds that are\n>> > meant to have been refunded, provided she gives Bob the option of\n>> claiming\n>> > them first.\n>> >\n>> > However fixing (1) and (2) aren't really going against Alice or Carol's\n>> > interests, so maybe you can just ask: Carol loses nothing by allowing\n>> > Bob to claim funds from Alice; and Alice has already indicated that\n>> > knowing P is worth more to her than the PTLC's funds -- otherwise she\n>> > wouldn't have forwarded the PTLC to Bob in the first place.\n>> >\n>> > Likewise, everyone's probably incentivised to negotiate cooperative\n>> > closes instead of going on-chain -- better privacy, less fees, and less\n>> > delay before the funds can be used elsewhere.\n>> >\n>> > FWIW, I think a similar flaw exists even in the original eltoo spec --\n>> > Alice could simply decline to publish the settlement transaction until\n>> > the timeout has been reached, preventing Bob from revealing the HTLC\n>> > preimage before Alice can claim the refund.\n>> >\n>> > So I think that adds up to:\n>> >\n>> >  a) Nodes should share state on reconnection; if you find a node that\n>> >     doesn't do this, close the channel and put the node on your enemies\n>> >     list. If you disagree on what the current state is, share your most\n>> >     recent state, and if the other guy's state is more recent, and all\n>> >     the signatures verify, update your state to match theirs.\n>> >\n>> >  b) Always negotiate a mutual/cooperative close if possible, to avoid\n>> >     actually using the eltoo protocol on-chain.\n>> >\n>> >  c) If you want to allow continuing the channel after restoring an old\n>> >     state from backup, set the channel state index based on the real\n>> time,\n>> >     eg (real_time-start_time)*(max_updates_per_second). That way your\n>> >     first update after a restore from backup will ensure that any old\n>> >     states that your channel partner may not have told you about are\n>> >     invalidated.\n>> >\n>> >  d) Accept that if you lose connectivity to a channel partner, you will\n>> >     have to pay any PTLCs that were going to them, and won't be able\n>> >     to claim the PTLCs that were funding them. Perhaps limit the total\n>> >     value of inbound PTLCs for forwarding that you're willing to accept\n>> >     at any one itme?\n>> >\n>> > Also, layered commitments seem like they make channel factories\n>> > complicated too. Nobody came up with a way to avoid layered commitments\n>> > while I wasn't watching did they?\n>> >\n>> > Cheers,\n>> > aj\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210720/29630c09/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-07-27T11:44:21",
                "message_text_only": "Good morning cdecker, aj, and list,\n\n> . In addition we can store the same data with multiple peers, ensuring that as long as one node is behaving we're good.\n\n\nDepending on size limits of the stored data, it may be possible to use some kind of erasure coding so that at least k of n peers need to be honest so we are good.\nI suspect peers would prefer to limit the amount of data they have to store, if they offer this feature, so use of erausre coding seems to be a good idea.\n\nHowever, since the peer does not know the data you are storing, this detail can be known only by the node saving its data with the peer, so not need to put in specifications.\n\n> I don't think you can reliably hide that you forgot some state? If you\n> _did_ forget your state, you'll have forgotten their latest bundle too,\n> and it seems like there's at least a 50/50 chance you'd have to send\n> them their bundle before they sent you yours?\n\nThis objection seems quite correct.\n\nPerhaps it is possible to (mis)use Barrier Escrow: https://suredbits.com/payment-points-implementing-barrier-escrows/\nAfter all, what is needed is a simultaneous way for both sides to provide the data (or admit they lost it) before the other can withhold the data.\n\n1.  Both agree on some Barrier Escrow and generate some temporary points.\n2.  Both sides invoke `barrier-commit` on the Barrier Escrow, receiving E.\n3.  Both sides *additionally* encrypt the bundle using an asymmetric encryption, which can be decrypted only by anyone who knows `e` such that `E = e * G`.\n4.  Both sides exchange the asymmetrically-encrypted bundles.\n5.  Once a side receives the asymmetrically-encrypted bundle from the other side, they invoke `barrier-reveal` using their temporary scalar from #1.\n6.  When they get `e` from `barrier-reveal` they can decrypt the asymmetric encryption layer from the bundle they receive, then proceed to validate and decrypt the actual encrypted bundle.\n\nIf Alice is amnesiac, it just provides a random vector for the \"asymmetric encrypted bundle of Bob\".\n\nSuppose Bob wants to check if Alice is amnesiac.\nBob cannot delay its send of the Alice-bundle, due to the Barrier Escrow ensuring that both parties have sent *some* bundle.\nThus, even if Bob knows later than Alice has gone amnesiac, by the time Bob knows that, it has handed over the memento of Alice by which Alice can recover.\n\nBob can send a bogus bundle to Alice, and then if it also receives a bogus bundle, it knows Alice is amnesiac (and it might be a good time to steal from Alice).\nALTERNATELY Alice is *also* trying to probe Bob, so Alice sent a bogus bundle itself.\nIn that case, Bob could attempt to steal, but runs the risk that Alice was *also* another prober who is not actually amnesiac.\n(Not sure if that is valid game theory, though)\n\n\nOn the other hand, Barrier Escrow services have to be paid for their service (else why would they run), and if you have not connected to your peer then you cannot pay for barrier escrow services over Lightning.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-07-27T16:53:14",
                "message_text_only": "Good morning aj, and list,\n\n\n> > I don't think you can reliably hide that you forgot some state?\n\nThinking a little more --- *why* do we need to hide that we forgot some state?\n\nThe reason is that if your peer learns you forgot state, the peer can pass off obsolete state onchain, thereby stealing funds from you before you can recover your data.\n\nBut if some completely random node that is ***not*** your peer and has ***no*** channels with you is holding your memento, then there is no need to worry --- even if you tell them \"actually I forgot my state\" they have no obsolete state to hurt you with.\n\nSuppose that nodes provide a \"will remember for you\" flag in the feature bits.\n\nNow, your node can then use a secret distance measurement --- for example, it could take the keyed hash (with your node privkey as key) of every \"will remember for you\"-advertising node, then look for the hash that is numerically lowest.\n\nLocating the \"nearest\" node, your node then contacts that node and asks them to remember our memento.\nNow, your node should not be using its \"normal\" pubkey for this, instead, it should generate a \"throwaway\" keypair derived from its privkey plus the pubkey of the selected node.\n\n--\n\nAfter your node hits its head and becomes amnesiac, you provide it with the privkey (which can be represented as some words).\n\nThe node then re-downloads gossip map, and uses the same secret distance measurement to find, say, the 100 \"nearest\" nodes with the \"will remember for you\" feature.\nAssuming the gossip map has not changed too much since before the amnesia event, then it is likely that the previously selected node is still in the nearest 100 nodes.\n\nYour node will then iterate over the nearest 100 nodes, starting with the nearest, and re-derive the \"throwaway\" keypair and ask each node if it holds a memento for that pubkey.\n\nSince your node contacts them using a throwaway keypair that is not correlatable with your normal node pubkey, even if they are conspiring with your channel peers, the \"will remember for you\" node cannot identify that your node has suffered amnesia, it only knows that *some* node *somewhere* suffered amnesia.\n\nThis implies as well that the selected node can even be your peer, and it will still not be sure that the amnesiac node is you or might be somebody else completely.\n\n--\n\nOf course, the anonymous nature of the client requesting data storage is a problem, as this feature is now vulnerable to abuse and DDoS.\nAs a spam prevention, such a \"will remember for you\" node can use any number of techniques developed for anonymously paying to watchtowers, which have a similar \"need to pay for anonymous storage to prevent DoS\" problem.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Jeremy",
                "date": "2021-07-27T18:21:48",
                "message_text_only": "Just my 2 cents:\n\nI think worrying about the size of a resolution during a contested close\nscenario (too much) is not worth it. Encoding the state needed (e.g., in\nop_return or whatever) is the safest option because then you guarantee the\navailability of the closing transaction data in the protocol with no\nexternal dependencies.\n\nIf you want to make it cheaper, then allow for Alice to choose to cooperate\nwith a contesting Bob to replace the transaction with something smaller\n(quibble: we should get rid of mempool absolute fee increase rule for RBF\nperhaps... otherwise, this should be done as pre-broadcast negotiation)\nafter observing the state published by Bob, but make it mandatory to at\nleast reveal it if Bob wants to use the transaction unilaterally.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210727/aa52c40e/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-07-21T06:39:13",
                "message_text_only": "On Wed, Jul 14, 2021 at 04:44:24PM +0200, Christian Decker wrote:\n> Not quite sure if this issue is unique to eltoo tbh. While in LN-penalty\n> loss-of-state equates to loss-of-funds, in eltoo this is reduced to\n> impact only funds that are in a PTLC at the time of the loss-of-state.\n\nWell, the idea (in my head at least) is it should be \"safe\" to restore\nan eltoo channel from a backup even if it's out of date, so the question\nis what \"safe\" can actually mean. LN-penalty definitely isn't safe in\nthat scenario.\n\n>  2) Use the peer-storage idea, where we deposit an encrypted bundle with\n>  our peers, and which we expect the peers to return. by hiding the fact\n>  that we forgot some state, until the data has been exchanged we can\n>  ensure that peers always return the latest snapshot of whatever we gave\n>  them.\n\nI don't think you can reliably hide that you forgot some state? If you\n_did_ forget your state, you'll have forgotten their latest bundle too,\nand it seems like there's at least a 50/50 chance you'd have to send\nthem their bundle before they sent you yours?\n\nSharing with other peers has costs too -- if you can't commit to an\nupdated state with peer A until you've sent the updated data to peers\nB and C as backup, then you've got a lot more latency on each channel,\nfor example. And if you commit first, then you've got the problem of\nwhat happens if you crash before the update has made it to either B or C?\n\nBut I guess what I'm saying is sure -- those are great ideas, but they\nonly reduce the chance that you'll not have the latest state, they don't\neliminate it.\n\nBut it seems like it can probably be reduced enough that it's fine that\nyou're risking the balances in live HTLCs (or perhaps HTLCs that have\nbeen initiated since your last state backup), as long as you're at least\nable to claim your channel balance from whatever more recent state your\npeers may have.\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Impact of eltoo loss of state",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Christian Decker",
                "Jeremy",
                "Martin Habov\u0161tiak",
                "ZmnSCPxj"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 30882
        }
    },
    {
        "title": "[Lightning-dev] Cluster - New terminal UI wallet/node manager for c-lightning",
        "thread_messages": [
            {
                "author": "Friedrich von Hayek",
                "date": "2021-07-23T10:33:03",
                "message_text_only": "Good morning,\n\nA few weeks ago I started working on a new terminal based wallet/node manager for c-lightning. It's very early stage but it's already offering some functionality:\n\n- General node info (i), profit/loss stats\n- Available funds on-chain and LN\n- Recent activity pane (receive/sent/rebalances) ordered by the most recent\n- List of channels (c) ordered by channel balance showing some useful stats:\n- inbound/outbound capacity\n- local/remote fees set and earned\n- last forward\n- peer status, alias and opener\nYou can sort the channel list by different criteria - Press (s) on the channels page\nPress (h) on the channels page for useful keyboard shortcuts\n- Receive (r) / Pay (p) pages are broken atm - don't use them until the next release :)\n\nThe long term goals is to make it much more polished and useful:\n\n- Robust Pay/Receive functions (including support for LNURL)\n- Ability to rebalance / auto rebalance according to preset rules\n- Detailed channel info page with channel specific functions (open/close/rebalance etc.)\n- More useful stats\n- Embrace the terminal UI ( lean and fast app )\n\nShoutout to fiatjaf's Golang libs, c-lightning devs and @prusnak's suez (inspiration for the channels page).\n\nYou can download and play with the alpha version of Cluster here:\n\nhttps://github.com/f-hayek/cluster\n\nBest\n--\nF.A. Hayek\nhayek.f at protonmail.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210723/523473b3/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Cluster - New terminal UI wallet/node manager for c-lightning",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Friedrich von Hayek"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1547
        }
    },
    {
        "title": "[Lightning-dev] Last week's second IRC workshop on L2 onchain support and wrap up",
        "thread_messages": [
            {
                "author": "Michael Folkson",
                "date": "2021-07-29T11:36:25",
                "message_text_only": "There was some additional discussion on L2 onchain support at the\nrecent online Sydney Socratic Seminar. It wasn't recorded but a\ntranscript is below.\n\nTranscript: https://btctranscripts.com/sydney-bitcoin-meetup/2021-07-06-socratic-seminar/\n\nThe discussion focused partly on the rules [1] of BIP 125 RBF and the\nrationale for these rules (which isn't clear from the BIP). Proposed\nideas such as SIGHASH_IOMAP, fee sponsorship and transaction mutation\nwere also discussed that weren't covered during the IRC workshops.\n\n[1] https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#implementation-details\n\nOn Tue, Jun 29, 2021 at 10:44 AM Michael Folkson\n<michaelfolkson at gmail.com> wrote:\n>\n> A summary of the first workshop is here:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019079.html\n>\n> The focus for this second workshop was fee bumping and package relay.\n> For more details on package relay see:\n> https://github.com/ariard/L2-zoology/blob/master/workshops/package-relay-and-friends.md\n>\n> The conversation log for the second workshop is here:\n> https://gist.github.com/ariard/32b51ecceccc5c6f647bae86d083c442\n>\n> Package relay background\n>\n> Package relay is potentially useful for L2 protocols to address the\n> inherent unpredictability of future fees. CPFP (child-pays-for-parent)\n> seeks to ensure say a justice transaction, in Lightning\u2019s case, with a\n> lower fee, gets confirmed in a more timely manner because miners are\n> incentivized to include the child transaction in a block. To do so\n> they must include the parent transaction in that block or a preceding\n> block. By \u201cpackaging\u201d the parent and the child the initiator of the\n> transaction(s) can ensure the miner\u2019s mempool doesn\u2019t initially reject\n> the parent transaction for having a too low fee.\n>\n> There has been prior work done in previous years on package relay,\n> mainly by Suhas Daftuar.\n>\n> Draft BIP: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\n>\n> Package relay design questions: https://github.com/bitcoin/bitcoin/issues/14895\n>\n> Recently Gloria Zhao has been advancing package relay in Bitcoin Core:\n> https://gist.github.com/glozow/7064717e727a3eb27fad4f8504513add\n>\n> Package relay implementation\n>\n> Attendees seemed in agreement that enabling 2 transaction packages\n> would be sufficient (at least for now) for Lightning and DLCs. A L2\n> protocol should always be able to design a two step process where the\n> first transaction has an effective zero fee rate and the second\n> transaction sets the fee. Restricting the size of the package to 2 may\n> have the cost of slightly longer confirmation times and/or slightly\n> higher fees (t-bast) but it compares well to the increased\n> implementation complexity of larger package sizes. Two generation:\n> multi parent, single child shouldn\u2019t introduce material implementation\n> complexity over two generation: single parent, single child (glozow).\n>\n> Package RBF (replace-by-fee) is possible where there are two competing\n> packages with competing Lightning commitment transactions in them and\n> the second package is given a higher fee to attempt to get it\n> confirmed before the first package. However, supporting RBF within a\n> package (ie replacing a transaction in a package with a higher fee\n> transaction) increases implementation complexity and makes it harder\n> to reason about (glozow).\n>\n> rgrant raised the possibility of using two packages {A,B} and {B,C} if\n> three transaction packages e.g. {A,B,C} weren\u2019t supported but it was\n> suggested it is perhaps better to just broadcast a high fee CPFP\n> transaction for the {A,B} package rather than creating two packages.\n> If the first package has been evicted from the mempool the {B,C}\n> package wouldn\u2019t propagate because it would be an orphan package\n> (t-bast).\n>\n> glozow suggested that only hints (wtxids of transactions you think\n> should be package validated) could be communicated rather than\n> relaying the transaction themselves but there were concerns from\n> others on whether these hints would successfully propagate across the\n> network. Instead fee rate hints could be sent to inform a peer\u2019s\n> decision on whether it makes sense to fetch the rest of the package\n> (t-bast).\n>\n> darosior suggested the idea of a package based CBlockPolicyEstimator\n> in Bitcoin Core if CPFP is going to be increasingly used on the\n> network.\n>\n> Witness replacement and Taproot\n>\n> Tapscripts can be unlimited in size so with current Taproot rules you\n> could in theory go from a 100,000 vbyte witness to an empty witness.\n> L2 protocols may have a UTXO shared by two parties where Alice\u2019s\n> witness for her branch is say 1,000 vbytes and Bob\u2019s witness is only\n> say 250 vbytes. Replacing Alice\u2019s larger witness with Bob\u2019s smaller\n> witness could reduce transaction fees. For Lightning the best case is\n> a Taproot key path spend (16 vbyte witness) and the worst case is\n> going to be a 150 vbyte witness. Miniscript can tell you your worst\n> case transaction size and this can be used to assess the transaction\n> pinning risk of a bloated witness (all harding).\n>\n> A future soft fork could give meaning to the annex in Taproot\n> (darosior) which could be used for inflating the fee rate of a\n> witness. Then you could have a same-txid-different-wtxid coming after\n> with a lower fee rate but higher vbytes size to override package\n> limits (ariard). But fee rate is purely a policy concept and the annex\n> operates at the consensus level. In addition the annex can only\n> increase the weight of a transaction, it cannot decrease it (harding).\n>\n> Wrap up and initial goals\n>\n> With regards to the goals of the workshops that were initially\n> announced here:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003002.html\n>\n> 1) 2 transactions packages sounds enough to support currently deployed\n> L2 protocols\n> 2) There are ongoing discussions in the ecosystem regarding\n> deprecation of opt in RBF and implementation of full RBF:\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html\n> 3) Generally status quo and ad hoc security incident response policy\n> in the case of cross-layer security issues\n> 4) Generally status quo on L2 security philosophy design. L2 protocol\n> designers should seek to minimize assumptions on the base layer.\n>\n> --\n> Michael Folkson\n> Email: michaelfolkson at gmail.com\n> Keybase: michaelfolkson\n> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n\n\n-- \nMichael Folkson\nEmail: michaelfolkson at gmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3"
            }
        ],
        "thread_summary": {
            "title": "Last week's second IRC workshop on L2 onchain support and wrap up",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Michael Folkson"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 6621
        }
    }
]