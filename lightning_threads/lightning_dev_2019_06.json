[
    {
        "title": "[Lightning-dev] Proposal for Advertising Channel Liquidity",
        "thread_messages": [
            {
                "author": "Cezary Dziemian",
                "date": "2019-06-05T14:05:17",
                "message_text_only": "Good morning group,\n\nMy friend came to similar (almost the same) conclusions over a year ago,\nand I were working on implementation of this. I had first working prototype\nbased on clightning (but not trustless), but at that time there were so\nmany troubles with c-lightning, co I decided to make this solution based on\nLND. Unfortunately, I have other issues with LND also. There are some API\nmethod missing in LND and c-lightning also. This is the reason, I'm\nseriously tired doing this. I think, that was mistake to start working on\nthat without more talks with you and community.\n\nTomorrow, we scheduled to talk if it make sense to continue. A lot of\noptions are possible. If you, agree, it would be valuable to make such\nthing, I can work on it as full time job (my friend is wiling to pay for\nthat). I prefer to write it in Java rather and also need your support\nespecially in terms of lack of some API methods.\n\nPlease let me know, if we can build cross-implementation group to work on\nsuch thing and if you are willing to help.\n\nBest Regards,\nCezary Dziemian\n\n\n\n\n\n\npon., 12 lis 2018 o 11:05 ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> napisa\u0142(a):\n\n> Good morning lisa,\n>\n> > can simply close the channel. So if I'm charging for liquidity, I'd\n>> actually\n>> > want to charge for the amount (in mSAT/BTC) times time.\n>>\n>> So perhaps you could make a market here by establishing a channel saying\n>> that\n>>\n>>   \"I'll pay 32 msat per 500 satoshi per hour for the first 3 days\"\n>>\n>> When you open the channel with 500,000 satoshi donated by the other guy,\n>> you're then obliged to transfer 32 satoshi every hour to the other guy\n>> for three days (so a total of 14c or so).\n>>\n>> If the channel fails beforehand, they don't get paid; if you stop\n>> paying you can still theoretically do a mutual close.\n>>\n>\n> I think that this can also be gamed by a second, cooperating node that\n> sends payments through the channel to meet the rate and capture the fees\n> for the first. You can make this less likely by charging higher\n> transmission fees that make such an attack infeasible, and it's less\n> 'damaging' than an immediate close in that there's still open capacity\n> available for some time, at least until the 'bogus' payments have drained\n> the capacity that you solicited in the first place.\n>\n>\n> I believe not?\n> I do not see any terms in the contract regarding payments through the\n> channel other than the \"liveness\" payment.\n> So regardless of activity (or lack of activity) in the channel, the above\n> payments should be made.\n> If the taker misses a payment, the maker closes the channel outright,\n> freeing itself from the obligation.\n> If the maker refuses to route, it loses out on potential routing fees.\n> Any activity through it do not seem to matter.\n>\n> This mechanism may actually be superior to the CLTV-encumberance I and\n> Rene proposed.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/36f9459b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal for Advertising Channel Liquidity",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Cezary Dziemian"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3303
        }
    },
    {
        "title": "[Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?",
        "thread_messages": [
            {
                "author": "Ugam Kamat",
                "date": "2019-06-05T15:51:51",
                "message_text_only": "Hey guys,\n\n \n\nI know this question is not right for this mailing list, but I have tried\nasking it on Stackexchange\n<https://bitcoin.stackexchange.com/questions/88100/bolt-3-shouldnt-timeout-b\ne-included-in-the-script-of-offered-htlc-outputs-f>  (even offered a bounty)\nand didn't get a response as of yet.  So here's the question: According to\nthe BOLT #3 documentation,\n<https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactio\nns.md#offered-htlc-outputs> the offered HTLC output has the following script\nthat allows the remote node to claim the funds with the payment pre-image\nand the local node to claim it after a HTLC timeout.\n\n \n\n1.  # To remote node with revocation key\n2.  OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL\n3.  OP_IF\n4.      OP_CHECKSIG\n5.  OP_ELSE\n6.      <remote_htlcpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL\n7.      OP_NOTIF\n8.          # To local node via HTLC-timeout transaction (timelocked).\n9.          OP_DROP 2 OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG\n10.      OP_ELSE\n11.         # To remote node with preimage.\n12.         OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY\n13.         OP_CHECKSIG\n14.      OP_ENDIF\n15. OP_ENDIF\n\n \n\nIf you see the output that sends the funds to the local node (line 7-9), it\nis not timelocked in the script. What is said is that that part is delayed\nin the second stage using to_self_delay. However, a local node after signing\nthis commitment transaction, which includes the HTLC he offered, can\nbroadcast it to claim the bitcoins from the HTLC-timeout (he already has the\nsignatures) and pays to an address although with to_self_delay.\n\n \n\nAlthough the delay exists in the 2nd stage (CSV locked with to_self_delay),\nnothing stops me from offering a htlc to my peer node, sign the updated\ncommitment transaction and a second later broadcast the commitment\ntransaction on mainchain and spend the HTLC to an address locked with CSV.\nThe remote node will still forward the htlc because from its viewpoint it is\nstill within the bounds of the cltv_expiry as specified by BOLTs. Now, when\nthe remote node gets the pre-image it doesn't have any transaction to settle\nwith. Where is the shortcoming in my though process and isn't timelock\nexpiry something that should be included in the script itself?\n\n \n\n \n\nUgam\n\n \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/b45f4506/attachment-0001.html>"
            },
            {
                "author": "Pierre",
                "date": "2019-06-05T16:05:04",
                "message_text_only": "Hello Ugam,\n\nThe HTLC-Timeout transaction\n<https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions>\nis timelocked (with locktime=cltv_expiry).\n\nCheers,\n\nPierre\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/df870013/attachment.html>"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-05T16:30:12",
                "message_text_only": "Hey Pierre, \n\n \n\nThat\u2019s what I am having a hard time understanding. Although it is timelocked in the second stage HTLC-timeout, I can still spend the original commitment transaction although after some time. This is what my thought process is:\n\n \n\n*\tOffer the Htlc output and sign the commitment transactions\n*\tBroadcast the commitment transaction containing the offered HTLC outputs to the main chain. The outputs of commitment tx are: (1) to remote; (2) to local with to_self_delay and (3) to P2WSH (the script I pasted earlier)\n*\tCommitment transaction gets mined\n*\tSpend the third output using 0 <remotehtlcsig> <localhtlcsig> 0 in the witness stack which will send the outputs to <local_delayed_pubkey> using to_self_delay\n\nNow I think when you say the HTLC time out transaction is timelocked, you are referring the to the to_self_delay when spending the htlc-timeout. But although there is that timeout, the commitment transaction is already broadcasted, and the P2WSH output is already sent to my public key (although with a delay I can still spend that without my counterparty\u2019s assent). Now, my counterparty on the other hand  when he gets the pre-image, does not have the P2WSH output to claim his bitcoins with the pre-image because it has been already locked with my <local_delayed_pubkey> which I can spend when the to_senf_delay` is over\n\n \n\nUgam\n\n \n\nFrom: Pierre <pm+lists at acinq.fr> \nSent: Wednesday, June 5, 2019 9:35 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com>\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHello Ugam,\n\n \n\nThe HTLC-Timeout transaction <https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions>  is timelocked (with locktime=cltv_expiry).\n\n \n\nCheers,\n\n \n\nPierre\n\n \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/70751958/attachment.html>"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-05T16:32:51",
                "message_text_only": "Ah, now I see what you mean, it is locked with absolute timelock and hence I cannot broadcast that transaction. My apologies and thanks for the help!\n\n \n\nUgam\n\n \n\nFrom: Ugam Kamat <ugamkamat1 at gmail.com> \nSent: Wednesday, June 5, 2019 10:00 PM\nTo: 'Pierre' <pm+lists at acinq.fr>\nCc: 'lightning-dev' <lightning-dev at lists.linuxfoundation.org>\nSubject: RE: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHey Pierre, \n\n \n\nThat\u2019s what I am having a hard time understanding. Although it is timelocked in the second stage HTLC-timeout, I can still spend the original commitment transaction although after some time. This is what my thought process is:\n\n \n\n*\tOffer the Htlc output and sign the commitment transactions\n*\tBroadcast the commitment transaction containing the offered HTLC outputs to the main chain. The outputs of commitment tx are: (1) to remote; (2) to local with to_self_delay and (3) to P2WSH (the script I pasted earlier)\n*\tCommitment transaction gets mined\n*\tSpend the third output using 0 <remotehtlcsig> <localhtlcsig> 0 in the witness stack which will send the outputs to <local_delayed_pubkey> using to_self_delay\n\nNow I think when you say the HTLC time out transaction is timelocked, you are referring the to the to_self_delay when spending the htlc-timeout. But although there is that timeout, the commitment transaction is already broadcasted, and the P2WSH output is already sent to my public key (although with a delay I can still spend that without my counterparty\u2019s assent). Now, my counterparty on the other hand  when he gets the pre-image, does not have the P2WSH output to claim his bitcoins with the pre-image because it has been already locked with my <local_delayed_pubkey> which I can spend when the to_senf_delay` is over\n\n \n\nUgam\n\n \n\nFrom: Pierre <pm+lists at acinq.fr <mailto:pm+lists at acinq.fr> > \nSent: Wednesday, June 5, 2019 9:35 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> >\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org <mailto:lightning-dev at lists.linuxfoundation.org> >\nSubject: Re: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHello Ugam,\n\n \n\nThe HTLC-Timeout transaction <https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions>  is timelocked (with locktime=cltv_expiry).\n\n \n\nCheers,\n\n \n\nPierre\n\n \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/da8d2741/attachment-0001.html>"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-06-05T16:37:59",
                "message_text_only": "Hi Ugam,\n\nI also ran into an issue understanding this a while back, here's a PR I\nopened to try and make things more clear:\nhttps://github.com/lightningnetwork/lightning-rfc/pull/601\nFeel free to add to it or comment if you think things could be improved :)\n\nBest,\nNadav\n\nOn Wed, Jun 5, 2019 at 11:33 AM Ugam Kamat <ugamkamat1 at gmail.com> wrote:\n\n> Ah, now I see what you mean, it is locked with absolute timelock and hence\n> I cannot broadcast that transaction. My apologies and thanks for the help!\n>\n>\n>\n> Ugam\n>\n>\n>\n> *From:* Ugam Kamat <ugamkamat1 at gmail.com>\n> *Sent:* Wednesday, June 5, 2019 10:00 PM\n> *To:* 'Pierre' <pm+lists at acinq.fr>\n> *Cc:* 'lightning-dev' <lightning-dev at lists.linuxfoundation.org>\n> *Subject:* RE: [Lightning-dev] BOLT #3: Shouldn't timeout be included in\n> the script of \"Offered HTLC Outputs\" for the local node?\n>\n>\n>\n> Hey Pierre,\n>\n>\n>\n> That\u2019s what I am having a hard time understanding. Although it is\n> timelocked in the second stage HTLC-timeout, I can still spend the original\n> commitment transaction although after some time. This is what my thought\n> process is:\n>\n>\n>\n>    - Offer the Htlc output and sign the commitment transactions\n>    - Broadcast the commitment transaction containing the offered HTLC\n>    outputs to the main chain. The outputs of commitment tx are: (1) to remote;\n>    (2) to local with to_self_delay and (3) to P2WSH (the script I pasted\n>    earlier)\n>    - Commitment transaction gets mined\n>    - Spend the third output using 0 <remotehtlcsig> <localhtlcsig> 0 in\n>    the witness stack which will send the outputs to <local_delayed_pubkey>\n>    using to_self_delay\n>\n> Now I think when you say the HTLC time out transaction is timelocked, you\n> are referring the to the to_self_delay when spending the htlc-timeout. But\n> although there is that timeout, the commitment transaction is already\n> broadcasted, and the P2WSH output is already sent to my public key\n> (although with a delay I can still spend that without my counterparty\u2019s\n> assent). Now, my counterparty on the other hand  when he gets the\n> pre-image, does not have the P2WSH output to claim his bitcoins with the\n> pre-image because it has been already locked with my <local_delayed_pubkey>\n> which I can spend when the to_senf_delay` is over\n>\n>\n>\n> Ugam\n>\n>\n>\n> *From:* Pierre <pm+lists at acinq.fr>\n> *Sent:* Wednesday, June 5, 2019 9:35 PM\n> *To:* Ugam Kamat <ugamkamat1 at gmail.com>\n> *Cc:* lightning-dev <lightning-dev at lists.linuxfoundation.org>\n> *Subject:* Re: [Lightning-dev] BOLT #3: Shouldn't timeout be included in\n> the script of \"Offered HTLC Outputs\" for the local node?\n>\n>\n>\n> Hello Ugam,\n>\n>\n>\n> The HTLC-Timeout transaction\n> <https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions>\n> is timelocked (with locktime=cltv_expiry).\n>\n>\n>\n> Cheers,\n>\n>\n>\n> Pierre\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/379de1a0/attachment.html>"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-05T16:45:18",
                "message_text_only": "Hey Nadav, that\u2019s a good call as it\u2019s not particularly intuitive when you try to read it. I\u2019ll try to add to it if I can. Thanks!\n\n \n\nUgam\n\n \n\nFrom: Nadav Kohen <nadav at suredbits.com> \nSent: Wednesday, June 5, 2019 10:08 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com>\nCc: Pierre <pm+lists at acinq.fr>; lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHi Ugam,\n\n \n\nI also ran into an issue understanding this a while back, here's a PR I opened to try and make things more clear: https://github.com/lightningnetwork/lightning-rfc/pull/601\n\nFeel free to add to it or comment if you think things could be improved :)\n\n \n\nBest,\n\nNadav\n\n \n\nOn Wed, Jun 5, 2019 at 11:33 AM Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> > wrote:\n\nAh, now I see what you mean, it is locked with absolute timelock and hence I cannot broadcast that transaction. My apologies and thanks for the help!\n\n \n\nUgam\n\n \n\nFrom: Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> > \nSent: Wednesday, June 5, 2019 10:00 PM\nTo: 'Pierre' <pm+lists at acinq.fr <mailto:pm%2Blists at acinq.fr> >\nCc: 'lightning-dev' <lightning-dev at lists.linuxfoundation.org <mailto:lightning-dev at lists.linuxfoundation.org> >\nSubject: RE: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHey Pierre, \n\n \n\nThat\u2019s what I am having a hard time understanding. Although it is timelocked in the second stage HTLC-timeout, I can still spend the original commitment transaction although after some time. This is what my thought process is:\n\n \n\n*\tOffer the Htlc output and sign the commitment transactions\n*\tBroadcast the commitment transaction containing the offered HTLC outputs to the main chain. The outputs of commitment tx are: (1) to remote; (2) to local with to_self_delay and (3) to P2WSH (the script I pasted earlier)\n*\tCommitment transaction gets mined\n*\tSpend the third output using 0 <remotehtlcsig> <localhtlcsig> 0 in the witness stack which will send the outputs to <local_delayed_pubkey> using to_self_delay\n\nNow I think when you say the HTLC time out transaction is timelocked, you are referring the to the to_self_delay when spending the htlc-timeout. But although there is that timeout, the commitment transaction is already broadcasted, and the P2WSH output is already sent to my public key (although with a delay I can still spend that without my counterparty\u2019s assent). Now, my counterparty on the other hand  when he gets the pre-image, does not have the P2WSH output to claim his bitcoins with the pre-image because it has been already locked with my <local_delayed_pubkey> which I can spend when the to_senf_delay` is over\n\n \n\nUgam\n\n \n\nFrom: Pierre <pm+lists at acinq.fr <mailto:pm+lists at acinq.fr> > \nSent: Wednesday, June 5, 2019 9:35 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> >\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org <mailto:lightning-dev at lists.linuxfoundation.org> >\nSubject: Re: [Lightning-dev] BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?\n\n \n\nHello Ugam,\n\n \n\nThe HTLC-Timeout transaction <https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions>  is timelocked (with locktime=cltv_expiry).\n\n \n\nCheers,\n\n \n\nPierre\n\n \n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org <mailto:Lightning-dev at lists.linuxfoundation.org> \nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190605/6aa78160/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "BOLT #3: Shouldn't timeout be included in the script of \"Offered HTLC Outputs\" for the local node?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "Pierre",
                "Ugam Kamat"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 14950
        }
    },
    {
        "title": "[Lightning-dev] ECDH for spontaneous payments and offline vending machines",
        "thread_messages": [
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-09T19:39:11",
                "message_text_only": "Hi list,\n\nIn the last couple weeks we came up with two ideas that you might find\ninteresting. One is how to do spontaneous lightning payments to a node only\nwith the knowledge of the node id, and the second one is how to generate\ninvoices for the offline vending machine with arbitrary amounts without\nexposing node secrets to it. Both tricks use ECDH key agreement but in a\nslightly different way.\n\n# Spontaneous payments.\n\nThe idea is to send the payment to a friend only with the knowledge of his\nnode id. In this situation the node id acts similar to a bitcoin address\nfor lightning.\n\nWhen we create an onion packet for the target node we calculate a common\nsecret with ECDH ( x-coordinate of `k * N` where `k` is a ephemeral key and\n`N` is the node id). We can use the double-sha256 of this common secret as\na payment hash for the htlc and a single sha256 of this secret will be the\npreimage.\n\nChristian Decker was very kind and implemented this feature as a plugin for\nc-lightning (https://github.com/cdecker/lightning/tree/stepan-pay) and it\nlooks like the changes to be made are pretty small.\n\nIMHO it would be nice to have such functionality and it can be used for\npayments between friends or for donations to charity organisations.\n\n# Offline invoice generation\n\nSome time ago there was a discussion about offline vending machines, the\nidea was to pre-load a vending machine with invoices, display invoices to\nthe user and ask for the preimage as a payment confirmation. When all\ninvoices are used or expired we refill it with the new ones. It is great\nbut it doesn't work if the payment amount is variable (pay for volume or\ntime).\n\nAn alternative could be to share the node private key with the vending\nmachines to generate invoices on the fly, but it is a security hole. There\nis a trick though how generate invoices that our online node could claim\nwithout exposing any secrets to the vending machine.\n\nVending machine generates an ephemeral key `k` and corresponding ephemeral\nnode id `K`. It generates an invoice signed with this key. It also includes\na routing information that the payment should go through our online node\n`N`. As a preimage we use `hmac-sha256(x, amount)` where `x` is a secret\nkey from ECDH(K, N) - (x-coordinate of `k * N`). We also put the amount\ninto the 8-byte short channel id in the routing information to ensure that\nthe node can calculate the preimage even if the user is willing to pay a\ntip and increases the amount of the htlc.\n\nWhen our online node is asked to route a payment to an unknown node `K` it\ntries to generate the preimage. It calculates the ECDH secret `x`\n(x-coordinate of `n * K` where `n` is a private key corresponding to its\nnode id) and calculates the preimage from the amount encoded in the short\nchannel id and the secret x. If the preimage matches the payment hash it\ncan claim the money (also checking that htlc amount is greater or equal the\namount encoded in the channel id).\n\nThis construction allows to generate invoices on a vending machine or a web\nserver without ever talking to the node itself. In contrast to the\nspontaneous payments described above the payer has no idea about the\npreimage.\n\nI don't suggest to include this in the node implementation as is, but\nhaving a plugin / add-on with such functionality could be interesting.\n\nCheers,\nStepan.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190609/5af088ec/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-10T06:04:08",
                "message_text_only": "Good morning Stepan,\n\nThese are very good developments and I applaud them.\n\n\n\n> Vending machine generates an ephemeral key `k` and corresponding ephemeral node id `K`. It generates an invoice signed with this key. It also includes a routing information that the payment should go through our online node `N`. As a preimage we use `hmac-sha256(x, amount)` where `x` is a secret key from ECDH(K, N) - (x-coordinate of `k * N`). We also put the amount into the 8-byte short channel id in the routing information to ensure that the node can calculate the preimage even if the user is willing to pay a tip and increases the amount of the htlc.\n\nJust to be clear: each time the vending node needs a new invoice, it generates a new ephemeral key `k`?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-10T08:34:07",
                "message_text_only": "Hi ZmnSCPxj,\n\n> Just to be clear: each time the vending node needs a new invoice, it\ngenerates a new ephemeral key `k`?\n\nYes, the vending machine generates a new `k` for every invoice.\n\nThe same technique can be used for spontaneous payments as well and in this\ncase we can also provide additional information to the node about the\npayment. For example, let's say I have my digitalocean account with some\nuser id. If I want to top-up my account with certain amount I could just\ngenerate an invoice myself and pay it, and I could also include my ID (or\nlogin) into the short channel id. The node would see this information and\ntop-up my account with the money I just sent.\n\nEffectively this routing trick allows including a \"payment purpose\" by\nmisusing the short channel id. It is a workaround as it uses the data field\nnot according to the purpose and has a limit of 8 bytes, so I would prefer\nto have some metadata field in the invoice that should be passed to the\npayee in the onion packet instead, but this requires changes in the bolt 11\nand as far as I understand something like that is already on the roadmap.\n\nStepan.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190610/6abf7165/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-11T03:47:26",
                "message_text_only": "Good morning Stepan,\n\n> # Offline invoice generation\n>\n> Some time ago there was a discussion about offline vending machines, the idea was to pre-load a vending machine with invoices, display invoices to the user and ask for the preimage as a payment confirmation. When all invoices are used or expired we refill it with the new ones. It is great but it doesn't work if the payment amount is variable (pay for volume or time).\n>\n> An alternative could be to share the node private key with the vending machines to generate invoices on the fly, but it is a security hole. There is a trick though how generate invoices that our online node could claim without exposing any secrets to the vending machine.\n>\n> Vending machine generates an ephemeral key `k` and corresponding ephemeral node id `K`. It generates an invoice signed with this key. It also includes a routing information that the payment should go through our online node `N`. As a preimage we use `hmac-sha256(x, amount)` where `x` is a secret key from ECDH(K, N) - (x-coordinate of `k * N`). We also put the amount into the 8-byte short channel id in the routing information to ensure that the node can calculate the preimage even if the user is willing to pay a tip and increases the amount of the htlc.\n>\n> When our online node is asked to route a payment to an unknown node `K` it tries to generate the preimage. It calculates the ECDH secret `x` (x-coordinate of `n * K` where `n` is a private key corresponding to its node id) and calculates the preimage from the amount encoded in the short channel id and the secret x. If the preimage matches the payment hash it can claim the money (also checking that htlc amount is greater or equal the amount encoded in the channel id).\n\nReviewing BOLT #4, sadly it seems not to work...?\n\n> 1. type: `per_hop` (for `realm` 0)\n> 2. data:\n>    * [`8`:`short_channel_id`]\n>    * [`8`:`amt_to_forward`]\n>    * [`4`:`outgoing_cltv_value`]\n>    * [`12`:`padding`]\n\nThere is no way to inform your online node what `K` is, since what is in the `per_hop` does not include `K`.\nInstead, the `short_channel_id` is intended to inform the forwarding node which is the next hop, using only 8 bytes; presumably the forwarding node has a table mapping short channel IDs to actual peers it has.\nThe online node in your proposal is unable to extract `K`, a the next-node-ID is never transmitted.\n\nFor the donation case, it seems possible, as the donator is the sender and can arrange to use the shared secret as the preimage.\nBut for the invoice-generation case, the invoice-generator is not the sender, and the sender might not know how to properly inform the shared secret.\n\nMaybe later, when we use \"rendezvous routing\" (and provide hooks into BOLT #11 for it), it may become possible to perform this trick (as we will use node IDs in rendezvous routing, rather than `short_channel_id`).\nThen the online node can, if unable to rendezvous-forward to a node on its routemap, check if the \"next node ID\" in the rendezvous routing sub-route can be used as to compute a shared secret that is the preimage.\nhttps://github.com/lightningnetwork/lightning-rfc/pull/611\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-11T07:58:43",
                "message_text_only": "Hi ZmnSCPxj,\n\n> The online node in your proposal is unable to extract `K`, a the\nnext-node-ID is never transmitted.\n\nThen currently for the vending machines we can use a pre-shared common\nsecret set up at installation time (may be unique for every machine) and\nuse it for preimage generation:\n\npreimage = hmac(common_secret, amount | nonce)\n\nWe can pass this nonce as a channel id. This is exactly what we did for the\nhackathon project. Such invoice has to be paid with exact amount, there is\nno way to include a tip - otherwise preimage generation will fail.\nAlternatively, for donation payments we can drop amount from preimage\ngeneration.\n\nOnline node can try to generate the preimage for every htlc offer with all\nknown common secrets and the channel ID, and if it fails - try to route the\npayment as usual.\n\nA set of common secrets also helps to determine the source of the payment,\nin order to avoid bruteforce we can use first byte (or varint) of channel\nid as a secret id (as soon as we have enough space left for nonce)\n\nStepan.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190611/cdeb9fbc/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-11T12:47:28",
                "message_text_only": "Good morning Stepan,\n\n\n\n> Hi ZmnSCPxj,\n>\n> > The online node in your proposal is unable to extract `K`, a the next-node-ID is never transmitted.\n>\n> Then currently for the vending machines we can use a pre-shared common secret set up at installation time (may be unique for every machine) and use it for preimage generation:\n>\n> preimage = hmac(common_secret, amount | nonce)\n>\n> We can pass this nonce as a channel id. This is exactly what we did for the hackathon project. Such invoice has to be paid with exact amount, there is no way to include a tip - otherwise preimage generation will fail.\n\nI observe that any tip worth its name would be a positive delta over the invoice face value.\n\nThus, if you want to accept tips up to (say) 25% above the invoice face value, you can just iterate from `amount_to_forward` down to `0.8 * amount_to_forward` and see if it yields a preimage that matches the payment hash.\n\nThis may require some grinding; but remember that you have several blocks in which you can compute this.\n\nThis is particularly relevant for older versions of C-lightning which implemented value randomization (i.e. adding a small random tip in an attempt to fool analysts from determining the actual value being paid --- BOLT spec specifically allows this behavior).\n(This was inadvertently removed/not implemented in newer versions after the pay algorithm was moved to a plugin; since nobody but me was interested in value randomization anyway, I decided not to reimplement it until somebody else asks for it)\n\n\n> Online node can try to generate the preimage for every htlc offer with all known common secrets and the channel ID, and if it fails - try to route the payment as usual.\n\nIt is probably faster on most implementations to look up the channel ID in some hash table first, i.e. try to route first before generating preimages.\nOf course, 64-bit `short_channel_id` as nonce is likely to hit a \"real\" channel ID, but you can avoid this by restricting the range to far-future blockheights and/or before the `when_lightning_became_cool` blockheight.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "ECDH for spontaneous payments and offline vending machines",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Stepan Snigirev",
                "ZmnSCPxj"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 12066
        }
    },
    {
        "title": "[Lightning-dev] Improve Lightning payment reliability through better error attribution",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2019-06-12T12:59:40",
                "message_text_only": "Hello list,\n\nIn Lightning, the reliability of payments is dependent on the reliability\nof the chosen route. Information about previous payment attempts helps to\nselect better routes and improve the payment experience. Therefore\nimplementations usually track the past performance of nodes and channels.\nThis can be as simple as a black list that contains previously failed\nchannels.\n\nIn order for this mechanism to be most effective, it is important to know\nwhich node is to blame for a non-ideal payment attempt.\n\nNon-ideal payment attempts are not only failed payment attempts (either\ninstantly failed or after a delay), but also successful payments for which\nit took a long time to receive the `htlc_fulfill` message.\n\nFor non-ideal payment attempts, we are currently not always able to\ndetermine the node that should be penalized. In particular:\n* If an attempt takes long to complete (settle or fail), we have no\ninformation that points us to the source of the delay.\n* Nodes can return a corrupt failure message. When this message arrives at\nthe sender after a number of encryption rounds, the sender is no longer\nable to pinpoint the node that failed the payment.\n\nA potential solution is to change the failure message such that every hop\nalong the backward path adds an hmac to the message (currently only the\nerror source authenticates the message). This allows the source of a\ncorruption to be narrowed down to a pair of nodes, which is enough to\nproperly apply a penalty.\n\nIn addition to that, all hops could add two timestamps to the failure\nmessage: the htlc add time and the htlc fail time. Using this information,\nthe sender of the payment can identify the source of the delay down to,\nagain, a pair of nodes. Those timestamps could be added to the settle\nmessage as well, to also allow diagnostics on slow settled payments.\n\nThe challenge here is to design the failure message format in such a way\nthat hops cannot learn their position in the path. Just appending\ntimestamps and hmacs to a variable length message would reveal the distance\nbetween a node and the error source.\n\nA fixed length message in which hops shift some previous (unused) data out\nfrom the message to create space to add their own data does not seem to\nwork. What happens is that the earlier nodes calculate their hmac over data\nthat is shifted out and cannot be recovered anymore by the sender. The\nsender has no way to verify the hmac in that case. Regenerating the shifted\nout data (similar to deterministic padding on the forward path) isn't a\nsolution either, because a node may modify that (unused) data before\npassing the message on. This would invalidate all hmacs, denying the sender\nfrom locating the responsible node.\n\nOne space-inefficient solution is to have every hop add hmacs for every\npossible (real) message length, but this would require n^2 hmacs in total\n(20*20*32 bytes). Half of these could be discarded along the way, but it\nwould still leave 10*20*32=6.4kb of hmacs.\n\nAnother direction might be to use a variable length message, but have the\nerror source add a seemingly random length padding. The actual length could\nbe deterministically derived from the shared secret, so that the erring\nnode cannot just not add padding. This obfuscates the distance to the error\nsource somewhat, but still reveals a bit of information. If one knows that\nthe padding length is somewhere between 0 and 20 blocks worth of bytes, a\nmessage length of say 25 blocks would reveal that the err source is at\nleast 5 hops away. It could be a fair trade-off though.\n\nAn alternative to all of this is to try to locate bad nodes by probing with\ndifferent route lengths and coming from different angles. This will however\nrequire more attempts and more complex processing of the outcomes. There is\nalso a level of indirectness because not all information is gathered in a\nsingle roundtrip. And in addition to that, a malicious node may somehow act\ndifferently if it manages to recognize the probes.\n\nI'd be interested to hear your opinions about the importance of being able\nto locate bad nodes irrefutably, as well as ideas around the failure\nmessage format.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190612/f110fbb1/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-06-13T11:14:39",
                "message_text_only": "Hi Joost,\n\nI agree that this would be desirable and would unlock better\ndecision-making about node and channel pruning.\n\nA fixed length message in which hops shift some previous (unused) data out\n> from the message to create space to add their own data does not seem to\n> work.\n>\n\nI agree that shifting out data doesn't work. An alternative solution would\nbe to use a very big fixed-size message starting with some padding followed\nby a variable-length message. Every node would add its mac to the internal\nvariable-length message and decrease the size of the initial padding.\nHowever this becomes complex to handle when a malicious node reduces the\npadding so that previous nodes don't have enough space to include their own\nmacs and timestamps.\nThat leads me to think that a fixed-size message won't resist arbitrary\nmalicious behavior (and might not offer much compared to a variable-length\nmessage).\n\nAnother direction might be to use a variable length message, but have the\n> error source add a seemingly random length padding. The actual length could\n> be deterministically derived from the shared secret, so that the erring\n> node cannot just not add padding.\n>\n\nWhat about having each node add some padding along the way? The erring\nnode's padding should be bigger than intermediate nodes' padding (ideally\nusing a deterministic construction as you suggest) so details need to be\nfleshed out, but it could mitigate even more the possibility of\nintermediate nodes figuring out their approximate position.\nThat also mitigates the risk that a network observer correlates error\nmessages between hops (because in the variable-length message that you\npropose, a network observer can easily track an error message across the\nwhole payment path).\n\nI'm not a big fan of probing. If we can find a better solution than probing\nI think it would always be desirable.\n\nCheers,\nBastien\n\nLe mer. 12 juin 2019 \u00e0 15:02, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> Hello list,\n>\n> In Lightning, the reliability of payments is dependent on the reliability\n> of the chosen route. Information about previous payment attempts helps to\n> select better routes and improve the payment experience. Therefore\n> implementations usually track the past performance of nodes and channels.\n> This can be as simple as a black list that contains previously failed\n> channels.\n>\n> In order for this mechanism to be most effective, it is important to know\n> which node is to blame for a non-ideal payment attempt.\n>\n> Non-ideal payment attempts are not only failed payment attempts (either\n> instantly failed or after a delay), but also successful payments for which\n> it took a long time to receive the `htlc_fulfill` message.\n>\n> For non-ideal payment attempts, we are currently not always able to\n> determine the node that should be penalized. In particular:\n> * If an attempt takes long to complete (settle or fail), we have no\n> information that points us to the source of the delay.\n> * Nodes can return a corrupt failure message. When this message arrives at\n> the sender after a number of encryption rounds, the sender is no longer\n> able to pinpoint the node that failed the payment.\n>\n> A potential solution is to change the failure message such that every hop\n> along the backward path adds an hmac to the message (currently only the\n> error source authenticates the message). This allows the source of a\n> corruption to be narrowed down to a pair of nodes, which is enough to\n> properly apply a penalty.\n>\n> In addition to that, all hops could add two timestamps to the failure\n> message: the htlc add time and the htlc fail time. Using this information,\n> the sender of the payment can identify the source of the delay down to,\n> again, a pair of nodes. Those timestamps could be added to the settle\n> message as well, to also allow diagnostics on slow settled payments.\n>\n> The challenge here is to design the failure message format in such a way\n> that hops cannot learn their position in the path. Just appending\n> timestamps and hmacs to a variable length message would reveal the distance\n> between a node and the error source.\n>\n> A fixed length message in which hops shift some previous (unused) data out\n> from the message to create space to add their own data does not seem to\n> work. What happens is that the earlier nodes calculate their hmac over data\n> that is shifted out and cannot be recovered anymore by the sender. The\n> sender has no way to verify the hmac in that case. Regenerating the shifted\n> out data (similar to deterministic padding on the forward path) isn't a\n> solution either, because a node may modify that (unused) data before\n> passing the message on. This would invalidate all hmacs, denying the sender\n> from locating the responsible node.\n>\n> One space-inefficient solution is to have every hop add hmacs for every\n> possible (real) message length, but this would require n^2 hmacs in total\n> (20*20*32 bytes). Half of these could be discarded along the way, but it\n> would still leave 10*20*32=6.4kb of hmacs.\n>\n> Another direction might be to use a variable length message, but have the\n> error source add a seemingly random length padding. The actual length could\n> be deterministically derived from the shared secret, so that the erring\n> node cannot just not add padding. This obfuscates the distance to the error\n> source somewhat, but still reveals a bit of information. If one knows that\n> the padding length is somewhere between 0 and 20 blocks worth of bytes, a\n> message length of say 25 blocks would reveal that the err source is at\n> least 5 hops away. It could be a fair trade-off though.\n>\n> An alternative to all of this is to try to locate bad nodes by probing\n> with different route lengths and coming from different angles. This will\n> however require more attempts and more complex processing of the outcomes.\n> There is also a level of indirectness because not all information is\n> gathered in a single roundtrip. And in addition to that, a malicious node\n> may somehow act differently if it manages to recognize the probes.\n>\n> I'd be interested to hear your opinions about the importance of being able\n> to locate bad nodes irrefutably, as well as ideas around the failure\n> message format.\n>\n> Joost\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190613/96d9b570/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-14T08:24:30",
                "message_text_only": "Good morning Bastien and Joost,\n\nBefore proceeding with discussing HMACs and preventing nodes from putting words in the mouths of other nodes, perhaps we should consider, how we can ensure that nodes can be forced to be accurate about what happened.\n\nFor instance, a proposal is for nodes to put timestamps for certain events.\nDoes this imply that all nodes along the route **MUST** have their clocks strongly synchronized to some global clock?\nIf a node along the route happens to be 15 seconds early or 15 seconds late, can it be erroneously \"dinged\" for this when a later hop delays a successful payment for 20 seconds?\n\nIf it requires that hop nodes have strong synchrony with some global clock service, why would I want to run a hop node then?\nWhat happens if some global clock service is attacked in order to convince nodes to route to particular nodes (using a competing global clock service) on the Lightning network?\n\n> I'm not a big fan of probing. If we can find a better solution than probing I think it would always be desirable.\n\nIt has the significant advantage of giving you accurate real-world data, for only the opportunity cost of locking some tiny fraction of your funds.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, June 13, 2019 7:14 PM, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Hi Joost,\n>\n> I agree that this would be desirable and would unlock better decision-making about node and channel pruning.\n>\n> > A fixed length message in which hops shift some previous (unused) data out from the message to create space to add their own data does not seem to work.\n>\n> I agree that shifting out data doesn't work. An alternative solution would be to use a very big fixed-size message starting with some padding followed by a variable-length message. Every node would add its mac to the internal variable-length message and decrease the size of the initial padding.\n> However this becomes complex to handle when a malicious node reduces the padding so that previous nodes don't have enough space to include their own macs and timestamps.\n> That leads me to think that a fixed-size message won't resist arbitrary malicious behavior (and might not offer much compared to a variable-length message).\n>\n> > Another direction might be to use a variable length message, but have the error source add a seemingly random length padding. The actual length could be deterministically derived from the shared secret, so that the erring node cannot just not add padding.\n>\n> What about having each node add some padding along the way? The erring node's padding should be bigger than intermediate nodes' padding (ideally using a deterministic construction as you suggest) so details need to be fleshed out, but it could mitigate even more the possibility of intermediate nodes figuring out their approximate position.\n> That also mitigates the risk that a network observer correlates error messages between hops (because in the variable-length message that you propose, a network observer can easily track an error message across the whole payment path).\n>\n> I'm not a big fan of probing. If we can find a better solution than probing I think it would always be desirable.\n>\n> Cheers,\n> Bastien\n>\n> Le\u00a0mer. 12 juin 2019 \u00e0\u00a015:02, Joost Jager <joost.jager at gmail.com> a \u00e9crit\u00a0:\n>\n> > Hello list,\n> >\n> > In Lightning, the reliability of payments is dependent on the reliability of the chosen route. Information about previous payment attempts helps to select better routes and improve the payment experience. Therefore implementations usually track the past performance of nodes and channels. This can be as simple as a black list that contains previously failed channels.\n> >\n> > In order for this mechanism to be most effective, it is important to know which node is to blame for a non-ideal payment attempt.\n> >\n> > Non-ideal payment attempts are not only failed payment attempts (either instantly failed or after a delay), but also successful payments for which it took a long time to receive the `htlc_fulfill` message.\n> >\n> > For non-ideal payment attempts, we are currently not always able to determine the node that should be penalized. In particular:\n> > * If an attempt takes long to complete (settle or fail), we have no information that points us to the source of the delay.\n> > * Nodes can return a corrupt failure message. When this message arrives at the sender after a number of encryption rounds, the sender is no longer able to pinpoint the node that failed the payment.\n> >\n> > A potential solution is to change the failure message such that every hop along the backward path adds an hmac to the message (currently only the error source authenticates the message). This allows the source of a corruption to be narrowed down to a pair of nodes, which is enough to properly apply a penalty.\n> >\n> > In addition to that, all hops could add two timestamps to the failure message: the htlc add time and the htlc fail time. Using this information, the sender of the payment can identify the source of the delay down to, again, a pair of nodes. Those timestamps could be added to the settle message as well, to also allow diagnostics on slow settled payments.\n> >\n> > The challenge here is to design the failure message format in such a way that hops cannot learn their position in the path. Just appending timestamps and hmacs to a variable length message would reveal the distance between a node and the error source.\n> >\n> > A fixed length message in which hops shift some previous (unused) data out from the message to create space to add their own data does not seem to work. What happens is that the earlier nodes calculate their hmac over data that is shifted out and cannot be recovered anymore by the sender. The sender has no way to verify the hmac in that case. Regenerating the shifted out data (similar to deterministic padding on the forward path) isn't a solution either, because a node may modify that (unused) data before passing the message on. This would invalidate all hmacs, denying the sender from locating the responsible node.\n> >\n> > One space-inefficient solution is to have every hop add hmacs for every possible (real) message length, but this would require n^2 hmacs in total (20*20*32 bytes). Half of these could be discarded along the way, but it would still leave 10*20*32=6.4kb of hmacs.\n> >\n> > Another direction might be to use a variable length message, but have the error source add a seemingly random length padding. The actual length could be deterministically derived from the shared secret, so that the erring node cannot just not add padding. This obfuscates the distance to the error source somewhat, but still reveals a bit of information. If one knows that the padding length is somewhere between 0 and 20 blocks worth of bytes, a message length of say 25 blocks would reveal that the err source is at least 5 hops away. It could be a fair trade-off though.\n> >\n> > An alternative to all of this is to try to locate bad nodes by probing with different route lengths and coming from different angles. This will however require more attempts and more complex processing of the outcomes. There is also a level of indirectness because not all information is gathered in a single roundtrip. And in addition to that, a malicious node may somehow act differently if it manages to recognize the probes.\n> >\n> > I'd be interested to hear your opinions about the importance of being able to locate bad nodes irrefutably, as well as ideas around the failure message format.\u00a0\n> >\n> > Joost\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Joost Jager",
                "date": "2019-06-14T13:50:16",
                "message_text_only": "Hi Bastien,\n\n\n> What about having each node add some padding along the way? The erring\n> node's padding should be bigger than intermediate nodes' padding (ideally\n> using a deterministic construction as you suggest) so details need to be\n> fleshed out, but it could mitigate even more the possibility of\n> intermediate nodes figuring out their approximate position.\n> That also mitigates the risk that a network observer correlates error\n> messages between hops (because in the variable-length message that you\n> propose, a network observer can easily track an error message across the\n> whole payment path).\n>\n\nYes we could also do that. Then even if the same person has two different\nnodes in the path, they can't know for sure how many hops were in between.\n\nIt would be nice if there is a way to add padding such that hops don't\nlearn anything about their position, but not sure if that is possible.\nHaving the error node add padding with a random length between 0 and 20\nblock sizes (block size is the number of bytes a hop would add in the\nbackward path), does reveal an upper bound for the distance to the error\nnode. For example: a node receives a failure with a padding of 3 blocks.\nThat means that the distance to the error node is between 0 and 3 hops.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190614/ed33e37d/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2019-06-14T09:10:26",
                "message_text_only": "Hi ZmnSCPxj,\n\nBefore proceeding with discussing HMACs and preventing nodes from putting\n> words in the mouths of other nodes, perhaps we should consider, how we can\n> ensure that nodes can be forced to be accurate about what happened.\n>\n> For instance, a proposal is for nodes to put timestamps for certain events.\n> Does this imply that all nodes along the route **MUST** have their clocks\n> strongly synchronized to some global clock?\n> If a node along the route happens to be 15 seconds early or 15 seconds\n> late, can it be erroneously \"dinged\" for this when a later hop delays a\n> successful payment for 20 seconds?\n>\n> If it requires that hop nodes have strong synchrony with some global clock\n> service, why would I want to run a hop node then?\n> What happens if some global clock service is attacked in order to convince\n> nodes to route to particular nodes (using a competing global clock service)\n> on the Lightning network?\n>\n\nThat is definitely a concern. It is up to senders how to interpret the\nreceived timestamps. They can decide to tolerate slight variations. Or they\ncould just look at the difference between the in and out timestamp,\nabandoning the synchronization requirement altogether (a node could also\njust report that difference instead of two timestamps). The held duration\nis enough to identify a pair of nodes from which one of the nodes is\nresponsible for the delay.\n\nExample (held durations between parenthesis):\n\nA (15 secs) -> B (14 secs) -> C (3 secs) -> D (2 secs)\n\nIn this case either B or C is delaying the payment. We'd penalize the\nchannel between B and C.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190614/4b3f5654/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-14T09:38:31",
                "message_text_only": "Good morning Joost,\n\n> That is definitely a concern. It is up to senders how to interpret the received timestamps. They can decide to tolerate slight variations. Or they could just look at the difference between the in and out timestamp, abandoning the synchronization requirement altogether (a node could also just report that difference instead of two timestamps). The held duration is enough to identify a pair of nodes from which one of the nodes is responsible for the delay.\n>\n> Example (held durations between parenthesis):\n>\n> A (15 secs) -> B (14 secs) -> C (3 secs) -> D (2 secs)\n>\n> In this case either B or C is delaying the payment. We'd penalize the channel between B and C.\n\nThis seems better.\nIf B is at fault, it could lie and reduce its reported delta time, but that simply means it will be punished with A.\nIf C is at fault, it could lie and increase its reported delta time, but that simply means it will be punished with D.\n\nI presume that the delta time is the time difference from when it sends `update_add_htlc` and when it receives `update_fulfill_htlc`, or when it gets an irrevocably committed `update_fail_htlc` + `revoke_and_ack`.\nIs that accurate?\n\nUnit should probably be milliseconds.\n\n--\n\nAn alternative that comes to mind is to use active probing and tracking persistent data per node.\n\nFor each node we record two pieces of information:\n\n1.  Total imposed delay.\n2.  Number of attempts.\n\nSuppose a probe or payment takes N milliseconds on a route with M nodes to fulfill or irrevocably fail at the payer.\nFor each node on the route, we increase Total imposed delay by N / M rounded up, and increment Number of attempts.\nFor error reports we can shorten the route if we get an error response that points to a specific failing node, or penalize the entire route in case of a completely undecodable error response.\n\nWhen finding a route for a \"real\" payment, we adjust the cost of traversing a node by the ratio Total imposed delay / Number of attempts (we can avoid undefined math by starting both fields at 1).\nFor probes we can probably ignore this factor in order to give nodes that happened to be borked by a different slow node on the trial route another chance to exonerate their apparent slowness.\n\nThis does not need changes in the current spec.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joost Jager",
                "date": "2019-06-14T10:59:26",
                "message_text_only": "Hi ZmnSCPxj,\n\n\n> > That is definitely a concern. It is up to senders how to interpret the\n> received timestamps. They can decide to tolerate slight variations. Or they\n> could just look at the difference between the in and out timestamp,\n> abandoning the synchronization requirement altogether (a node could also\n> just report that difference instead of two timestamps). The held duration\n> is enough to identify a pair of nodes from which one of the nodes is\n> responsible for the delay.\n> >\n> > Example (held durations between parenthesis):\n> >\n> > A (15 secs) -> B (14 secs) -> C (3 secs) -> D (2 secs)\n> >\n> > In this case either B or C is delaying the payment. We'd penalize the\n> channel between B and C.\n>\n> This seems better.\n> If B is at fault, it could lie and reduce its reported delta time, but\n> that simply means it will be punished with A.\n> If C is at fault, it could lie and increase its reported delta time, but\n> that simply means it will be punished with D.\n>\n> I presume that the delta time is the time difference from when it sends\n> `update_add_htlc` and when it receives `update_fulfill_htlc`, or when it\n> gets an irrevocably committed `update_fail_htlc` + `revoke_and_ack`.\n> Is that accurate?\n>\n\nYes that is accurate, although using the time difference between receiving\nthe `update_add_htlc` and sending back the `update_fail_htlc` would work\ntoo. It would then include the node's processing time.\n\n\n> Unit should probably be milliseconds\n>\n\nYes, we probably want sub-second resolution for this.\n\nAn alternative that comes to mind is to use active probing and tracking\n> persistent data per node.\n>\n> For each node we record two pieces of information:\n>\n> 1.  Total imposed delay.\n> 2.  Number of attempts.\n>\n> Suppose a probe or payment takes N milliseconds on a route with M nodes to\n> fulfill or irrevocably fail at the payer.\n> For each node on the route, we increase Total imposed delay by N / M\n> rounded up, and increment Number of attempts.\n> For error reports we can shorten the route if we get an error response\n> that points to a specific failing node, or penalize the entire route in\n> case of a completely undecodable error response.\n>\n> When finding a route for a \"real\" payment, we adjust the cost of\n> traversing a node by the ratio Total imposed delay / Number of attempts (we\n> can avoid undefined math by starting both fields at 1).\n> For probes we can probably ignore this factor in order to give nodes that\n> happened to be borked by a different slow node on the trial route another\n> chance to exonerate their apparent slowness.\n>\n> This does not need changes in the current spec.\n>\n\nI think we could indeed do more with the information that we currently have\nand gather some more by probing. But in the end we would still be sampling\na noisy signal. More scenarios to take into account, less accurate results\nand probably more non-ideal payment attempts. Failed, slow or stuck\npayments degrade the user experience of lightning, while \"fat errors\"\narguably don't impact the user in a noticeable way.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190614/9c95c6f1/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-15T02:53:16",
                "message_text_only": "Good morning Joost,\n\n> Yes that is accurate, although using the time difference between receiving the `update_add_htlc` and sending back the `update_fail_htlc` would work too. It would then include the node's processing time.\n\nIt would not work safely.\nA node can only propagate an `update_fail_htlc` if the downstream `update_fail_htlc` has been irrevocably committed by `revoke_and_ack`.\nSee BOLT spec about this.\n\nSuppose we have a route A -> B -> C.\nC sends `update_fail_htlc` immediately, but dallies on `revoke_and_ack`.\nB cannot send `update_fail_htlc` to A yet, because C can still drop the previous B-C channel state onchain (it is not yet revoked, that is what the `revoke_and_ack` will later do).\nIf B send `update_fail_htlc` to A as soon as it receives `update_fail_htlc` from C, A can use the new A-B channel state onchain, while at the same time C drops the previous B-C channel state onchain.\nthe new A-B channel state returns the HTLC to A, while the previous B-C channel state has the HTLC still claimable by C, causing B to lose funds.\n\nFor `update_fulfill_htlc` B can immediately propagate to A (without waiting for `update_and_ack` from C) since C is already claiming the money.\n\nSince, B cannot report the `update_fail_htlc` immediately, its timer should still be running.\nSuppose we counted only up to `update_fail_htlc` and not on the `revoke_and_ack`.\nIf C sends `update_fail_htlc` immediately, then the `update_add_htlc`->`update_fail_htlc` time reported by B would be fast.\nBut if C then does not send `revoke_and_ack`, B cannot safely propagate `update_fail_htlc` to A, so the time reported by A will be slow.\nThis sudden transition of time from A to B will be blamed on A and B, while C is unpunished.\n\nThat is why, for failures, we ***must*** wait for `revoke_and_ack`.\nThe node must report the time when it can safely propagate the error report upstream, not the time it receives the error report.\nFor payment fulfillment, `update_fulfill_htlc` is fine without waiting for `revoke_and_ack` since it is always reported immediately upstream anyway.\n\nSee my discussion about \"fast forwards\": https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-April/001986.html\n\n> I think we could indeed do more with the information that we currently have and gather some more by probing. But in the end we would still be sampling a noisy signal. More scenarios to take into account, less accurate results and probably more non-ideal payment attempts. Failed, slow or stuck payments degrade the user experience of lightning, while \"fat errors\" arguably don't impact the user in a noticeable way.\n\nFat errors just give you more information when a problem happens for a \"real\" payment.\nBut the problem still occurs on the \"real\" payment and user experience is still degraded.\n\nBackground probing gives you the same information **before** problems happen for \"real\" payments.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Joost Jager",
                "date": "2019-06-15T06:52:30",
                "message_text_only": "Hi ZmnSCPxj,\n\nSince, B cannot report the `update_fail_htlc` immediately, its timer should\n> still be running.\n> Suppose we counted only up to `update_fail_htlc` and not on the\n> `revoke_and_ack`.\n> If C sends `update_fail_htlc` immediately, then the\n> `update_add_htlc`->`update_fail_htlc` time reported by B would be fast.\n> But if C then does not send `revoke_and_ack`, B cannot safely propagate\n> `update_fail_htlc` to A, so the time reported by A will be slow.\n> This sudden transition of time from A to B will be blamed on A and B,\n> while C is unpunished.\n>\n> That is why, for failures, we ***must*** wait for `revoke_and_ack`.\n> The node must report the time when it can safely propagate the error\n> report upstream, not the time it receives the error report.\n> For payment fulfillment, `update_fulfill_htlc` is fine without waiting for\n> `revoke_and_ack` since it is always reported immediately upstream anyway.\n>\n\nYes, that is a good point. C hasn't completed its duty until it sends\n`revoke_and_ack` indeed.\n\n\n> > I think we could indeed do more with the information that we currently\n> have and gather some more by probing. But in the end we would still be\n> sampling a noisy signal. More scenarios to take into account, less accurate\n> results and probably more non-ideal payment attempts. Failed, slow or stuck\n> payments degrade the user experience of lightning, while \"fat errors\"\n> arguably don't impact the user in a noticeable way.\n>\n> Fat errors just give you more information when a problem happens for a\n> \"real\" payment.\n> But the problem still occurs on the \"real\" payment and user experience is\n> still degraded.\n>\n> Background probing gives you the same information **before** problems\n> happen for \"real\" payments.\n>\n\nWith probing, I was thinking about probing right before making the actual\npayment, so not a process that is continuously running in the background. I\nam not sure how that would scale, everyone (assume mass adoption) probing\nthe whole network. Also, for private channels, nodes may put rate limits in\nplace or close channels that are the source of many failures. Then end\npoints with only private channels like a mobile app wouldn't be able to\nprobe effectively anymore.\n\nI do think probes are useful, but would only use them sparingly. Sending a\nprobe before the real payment surely helps to mitigate certain risks. But\nthen I'd still prefer to also have fat errors. To get maximum value out of\nthe probe and minimize the number of probes required. Functionally\nspeaking, I don't see why you wouldn't want to have that extra information.\n\n Joost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190615/82a4f1d1/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Improve Lightning payment reliability through better error attribution",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Joost Jager",
                "ZmnSCPxj"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 33253
        }
    },
    {
        "title": "[Lightning-dev] Possibility to Include refund invoice in lightning payments",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-14T06:16:11",
                "message_text_only": "Good morning Paberlance,\n\nYou may be interested in the current work with \"TLV\" that is on-going at the spec level now.\n\nThis will allow a sort of key-value map to be sent on every payment.\n\nIt would be possible, *once TLV has been finalized*, to propose the addition of such data in a Lightning payment.\n\nAs of now, there is no easy way to transmit extra application-level data on each payment.\n\nThe dependencies, as I understand them, are:\n\nrefund invoice on payment -> application-specific data TLV -> TLV spec -> variable-length onion packet\n\n\nVariable-length onion packet should finalize \"soon\" for some definition of \"soon\", if my understanding is correct.\n\nRegards,\nZmnSCPxj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Friday, June 14, 2019 1:53 PM, Paberlance via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hello Lightning Devs,\n>\n> i was wondering about the following idea: What if you attach a refund invoice to any LN payment. With this the recipient then has the possibility to refund, fully, partially or eventually tipping even a higher payment amount back to the sender.\n>\n> From the user side, the userwallet pays just as normal Lightning Invoice, but attached along with the payment of 0 sat invoice back to the seller. From a UX perspective, this all happens is controlled by the wallet, which must agree on a protocol for embedding the return invoice with the LN payment.\n>\n> On the recipee side, a normal LN invoice is recieved and optionally store that invoice to be able to perform a spontaneous refund later in time if he wants.As the invoice amount is not predefined, the seller is free to refund any payment, just bounded to the invoice timeout. Probably the payer will be motivated to issue invoices with a high expiry time-out.\n>\n> Possible Usecases:\n>\n> *Promotions, like: Every 100x Purchaser wins a prize, gets the order for free.\n>\n> *Refunds: I order something, cancel the transaction, seller refunds the transaction partially, charging a service fee that he does not return.\n>\n> *Safety deposits: You rent a car, the company keeps the payment as safety deposit, that gets reverted as soon as the car is returned.\n>\n> *Spontanous payouts in games\n>\n> Alternatives:\n>\n> *Hodl invoice, can achieve the same goal to refund the customer, but limited as it's an \"all or nothing refund\" option. Amount can't be more than the actual payment.\n> https://github.com/lightningnetwork/lnd/pull/2022\n>\n> *\"Spontaneous LN invoice creation \" with server that acts as a lookup proxy that handles the lightning creation on request. Inspiration: @georgevaccaro\n>\n> Requirements:\n>\n> Payer has to generate a invoice and provide it encoded in the payment request as payload.\n> Reciver: must be able to settle the actual payment. And optionaly he may support the feature After storing the refund invoice, he then has the ability to decice if or how he will use it to refunde the client in the future.\n>\n> Does this exist yet? What people can help me with this idea?\n>\n> Any ressources or hints to digg deeper, built on top of that idea?\n>\n> Paberlance"
            },
            {
                "author": "Conner Fromknecht",
                "date": "2019-06-14T06:34:07",
                "message_text_only": "Hi Paberlance,\n\nAs ZmnSCPxj mentioned, it should be possible to so after TLV and related\ndependencies are finalized.\n\nHowever I don\u2019t think embedding an invoice in the onion is the most\nefficient way to do this. Once a spontaneous payments protocol is\nestablished, it should be sufficient to embed, minimally, the sender\u2019s\npubkey, and perhaps some hop hints if the node is private.\n\nObviously this leaks the sender\u2019s identity, but no more than an invoice\nwould. IMO leaking the sender\u2019s pubkey in every payment (even ones that\nmight not be refunded) seems like pretty big drawback. That being said, the\nsame info could probably be provided externally (or out of band) if the\nsender really does want to be refunded and offer better privacy for\nnon-refunded payments.\n\nCheers,\nConner\n\n\nOn Thu, Jun 13, 2019 at 23:16 ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Paberlance,\n>\n> You may be interested in the current work with \"TLV\" that is on-going at\n> the spec level now.\n>\n> This will allow a sort of key-value map to be sent on every payment.\n>\n> It would be possible, *once TLV has been finalized*, to propose the\n> addition of such data in a Lightning payment.\n>\n> As of now, there is no easy way to transmit extra application-level data\n> on each payment.\n>\n> The dependencies, as I understand them, are:\n>\n> refund invoice on payment -> application-specific data TLV -> TLV spec ->\n> variable-length onion packet\n>\n>\n> Variable-length onion packet should finalize \"soon\" for some definition of\n> \"soon\", if my understanding is correct.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Sent with ProtonMail Secure Email.\n>\n> \u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\n> On Friday, June 14, 2019 1:53 PM, Paberlance via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hello Lightning Devs,\n> >\n> > i was wondering about the following idea: What if you attach a refund\n> invoice to any LN payment. With this the recipient then has the possibility\n> to refund, fully, partially or eventually tipping even a higher payment\n> amount back to the sender.\n> >\n> > From the user side, the userwallet pays just as normal Lightning\n> Invoice, but attached along with the payment of 0 sat invoice back to the\n> seller. From a UX perspective, this all happens is controlled by the\n> wallet, which must agree on a protocol for embedding the return invoice\n> with the LN payment.\n> >\n> > On the recipee side, a normal LN invoice is recieved and optionally\n> store that invoice to be able to perform a spontaneous refund later in time\n> if he wants.As the invoice amount is not predefined, the seller is free to\n> refund any payment, just bounded to the invoice timeout. Probably the payer\n> will be motivated to issue invoices with a high expiry time-out.\n> >\n> > Possible Usecases:\n> >\n> > *Promotions, like: Every 100x Purchaser wins a prize, gets the order for\n> free.\n> >\n> > *Refunds: I order something, cancel the transaction, seller refunds the\n> transaction partially, charging a service fee that he does not return.\n> >\n> > *Safety deposits: You rent a car, the company keeps the payment as\n> safety deposit, that gets reverted as soon as the car is returned.\n> >\n> > *Spontanous payouts in games\n> >\n> > Alternatives:\n> >\n> > *Hodl invoice, can achieve the same goal to refund the customer, but\n> limited as it's an \"all or nothing refund\" option. Amount can't be more\n> than the actual payment.\n> > https://github.com/lightningnetwork/lnd/pull/2022\n> >\n> > *\"Spontaneous LN invoice creation \" with server that acts as a lookup\n> proxy that handles the lightning creation on request. Inspiration:\n> @georgevaccaro\n> >\n> > Requirements:\n> >\n> > Payer has to generate a invoice and provide it encoded in the payment\n> request as payload.\n> > Reciver: must be able to settle the actual payment. And optionaly he may\n> support the feature After storing the refund invoice, he then has the\n> ability to decice if or how he will use it to refunde the client in the\n> future.\n> >\n> > Does this exist yet? What people can help me with this idea?\n> >\n> > Any ressources or hints to digg deeper, built on top of that idea?\n> >\n> > Paberlance\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-- \n\u2014Sent from my Spaceship\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190613/3ebd8d8a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Possibility to Include refund invoice in lightning payments",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Conner Fromknecht",
                "ZmnSCPxj"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7710
        }
    },
    {
        "title": "[Lightning-dev] Fwd: Improve Lightning payment reliability through better error attribution",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2019-06-14T09:08:07",
                "message_text_only": "Hi ZmnSCPxj,\n\nBefore proceeding with discussing HMACs and preventing nodes from putting\n> words in the mouths of other nodes, perhaps we should consider, how we can\n> ensure that nodes can be forced to be accurate about what happened.\n>\n> For instance, a proposal is for nodes to put timestamps for certain events.\n> Does this imply that all nodes along the route **MUST** have their clocks\n> strongly synchronized to some global clock?\n> If a node along the route happens to be 15 seconds early or 15 seconds\n> late, can it be erroneously \"dinged\" for this when a later hop delays a\n> successful payment for 20 seconds?\n>\n> If it requires that hop nodes have strong synchrony with some global clock\n> service, why would I want to run a hop node then?\n> What happens if some global clock service is attacked in order to convince\n> nodes to route to particular nodes (using a competing global clock service)\n> on the Lightning network?\n>\n\nThat is definitely a concern. It is up to senders how to interpret the\nreceived timestamps. They can decide to tolerate slight variations. Or they\ncould just look at the difference between the in and out timestamp,\nabandoning the synchronization requirement altogether (a node could also\njust report that difference instead of two timestamps). The held duration\nis enough to identify a pair of nodes from which one of the nodes is\nresponsible for the delay.\n\nExample (held durations between parenthesis):\n\nA (15 secs) -> B (14 secs) -> C (3 secs) -> D (2 secs)\n\nIn this case either B or C is delaying the payment. We'd penalize the\nchannel between B and C.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190614/ce0d1fb9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fwd: Improve Lightning payment reliability through better error attribution",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Joost Jager"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1786
        }
    },
    {
        "title": "[Lightning-dev] Escrow Over Lightning?",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-20T05:54:16",
                "message_text_only": "Good morning list,\n\nOne thing I am attempting to think through is some implementation of escrow over Lightning.\n\nA non-custodial onchain escrow protocol simply uses a 2-of-3 multisig amongst the two participants and the escrow.\nSuch a contract (like any onchain-enforceable contract) can be transported over a *single* Lightning channel, but cannot be safely hopped across channels: the escrow may take \"one\" side in one channel while taking the \"other\" side on the other channel, thus putting every hop node at risk.\n\nEscrow services are useful when Bitcoin needs to interact with other systems, such as the mythical \"real world\", when tr*st in a brandless entity is difficult to procure, while some escrow service can aggregate and reuse tr*st in its brand to enable trades between brandless entities.\nThus if at all possible, we should consider how best to support escrow services over Lightning.\n\nI formulate the contract below:\n\n* A brandless buyer B wants to pay a brandless seller S for a service or product.\n* Both B and S have non-trust in one another, but can agree to tr*st a common branded escrow E.\n* B shall pay S if both B and S can agree that the service was rendered satisfactorily or product was delivered.\n* In case of dispute, E decides whether S is paid or B is refunded.\n* B and S want to provide as little information to E as possible if both B and S can come to an agreement (i.e. only reveal information if a dispute occurs).\n\nTr*st is still needed in E.\nIn particular, B and S both trust that E will not be susceptible to bribery from their counterparty.\n\nThe above can trivially be implemented onchain using a 2-of-3 multisig.\n\n1,  The branded escrow E provides a public key as part of its brand.\n2.  B and S generate a short contract description of the service or product to be rendered, in a language that E understands.\n3.  B and S tweak the escrow public key (if `E` is the escrow pubkey and `c` is the description of the service/product, use `E + h(E | c) * G`).\n4.  B and S generate a 2-of-3 address using their own keys, plus the tweaked escrow public key.\n5.  If B and S can come to an agreement, then they sign using their own keys, and the third key (the tweaked escrow key) remains tweaked and E cannot determine that it could have been used as the escrow, or the details of the transaction, even if it monitors the blockchain (since its key is not used directly, instead a tweaked version is used, and the tweak is not revealed E if B and S are in agreement).\n    But if B and S come to a dispute, either can provide E with the agreed-upon description `c` that is committed to onchain, and lets E judge where the payment should go.\n\nUnder bip-taproot this can be optimized somewhat in favor of the \"no dispute\" case by setting the taproot internal key to `MuSig(B, S)`, and having separate MAST branches for `MuSig(E + h(E | c) * G, B)` and `MuSig(E + h(E | c) * G, S)`.\n\nThis use-case is important: consider the case where the seller is selling pieces of decorated paper mass-printed by some centralized financial institution.\nFor face-to-face transactions, it is enough for all of the participants to appear and for the Lightning payment to be attempted and so forth.\nBut for non-face-to-face transactions (such as when one participant is secretly an AI that is attempting to take over the world, and is currently unable to puppet some meatspace representative), such escrow would be best done online with no requirement of physical presence.\n\n---\n\nNaively, it seems that switching to payment points / scalars from payment hashes / preimages (a necessity for payment decorrelation) may work.\nIt may be possible to use some kind of verifiable secret sharing.\n\nHowever, I would like to make the following points possible:\n\n* The escrow does not learn about an escrowed trade unless a dispute between buyer and seller occurs.\n* The escrow is capable of returning the buyer funds immediately as soon as it can resolve the dispute without timing out the payment.\n* Intermediate hop nodes that are not the buyer, seller, or escrow, remain unaware of the escrowed trade (ideally, if they support the \"normal\" payment points / scalars system, they should not need any special support for escrowed trade).\n\nLet me sketch below something, which might not work since I have not actually learned verifiable secret sharing at all.\nIn particular, if verifiable secret sharing requires that the participants including the escrow to set up the payment point interactively, this fails the first desired item, that the escrow only learns of the escrowed trade in a dispute case.\n(i.e. a real mathist should actually check this.)\n\n---\n\nI will ignore here temporarily the issues of payment decorrelation, and pretend that the same point is used in the entire path.\n\nBefore all this, E publishes its escrow key `E`.\n\nFirst, B and S generate temporary payment points and scalars, `B = b * G` and `S = s * G`.\nThen they agree on the contract `c` describing their agreement, in a language that E understands, e.g. \"seller S will deliver 100 pieces of USA federal reserve commemorative decoration paper in exchange for 1 satoshi from buyer\".\n\nThen B generates an ECDH shared secrets between escrow and buyer:\n\n    tweak(c, P) = P + h(P | c) * G\n    ecdh(a, B) = h(a * B)\n    b' = ecdh(b, tweak(c, E))\n    B' = b' * G\n    S' = S + B'\n\nThe payment point used in the payment route is `S'`.\n\nB provides `B` and `B'` to S (this can be done using TLV in the onion packet).\nOf course, we also need to provide a proof that `B' == ecdh(b, tweak(c, E)) * G` where `B == b * G`.\nI have no idea how easy (or impossible) it is to make such a proof (without E having to attest to it).\n\nIf S believes it has fulfilled the contract and delivered the product or service, it contacts B.\nIf B is satisfied with the product or service, it provides `b'`, allowing S to compute `s + b'` needed to claim the payment point `S + B'`.\nIn the non-dispute case, E never learns that it could have been the escrow.\nB receives the scalar `s + b'` from the payment, but it knows `b'` and can compute the scalar `s` which now serves as proof-of-payment.\n\nIf B is unsatisfied, we have a dispute condition and S contacts the escrow E.\nS provides `B` and the contract `c` to the escrow.\nECDH allows E to determine `b' = ecdh(e + h((e * G) | c), B)`.\nIf E decides in favor of the seller, then it reveals `b'` to S, which can then compute `s + b'` and claim the payment point `S + B'`.\n\nHowever, note that if E decides in favor of the buyer, it cannot do anything other than let the payment timeout lapse, which automatically forces the seller S to fail the HTLC.\nI cannot derive a way for E to force S to fail the HTLC, without revealing to intermediate hop nodes that this is an escrow payment.\n\nEven if E is the only intermediate hop node between B and S (an undesirable situation since it allows E to censor and surveil the payments between B and S), it is not safe for E to fail its incoming PTLC until S has failed its incoming PTLC, as otherwise B and S could be coordinating to steal from escrow E.\n\nThere are likely to be better schemes.\nAgain, the ideal scheme would provide:\n\n* Escrow only learns of dispute cases, never learns non-dispute case.\n* Buyer can recover funds immediately as soon as escrow decides in favor of buyer. <- this seems difficult/impossible under LN.\n* Intermediate hop nodes are unaware of anything special with the payment.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-06-27T17:40:13",
                "message_text_only": "Hi ZmnSCPxj,\n\nI find this idea super exciting!\n\nI think that the main wrinkle in what you've presented is how the Seller\ncan verify that `B'` is indeed `ecdh(b, tweak(c, E))*G` since absent this\nauthentication, the Escrow will be unable to provide the Seller with the\nnecessary information to claim funds during a dispute.\n\nPerhaps there is some fancy ZKP that allows the Seller and Buyer to\nestablish this alone but I don't know what that would look like. If it\nexists than that scheme would be better than the following but here are my\nthoughts:\n\nIf we do need the Escrow to attest to the validity of `B'`, we want to make\nsure that the Escrow gains as little knowledge as possible. If we add a\nsalt to the `tweak` function's hash (i.e `tweak(c, P, salt) = P + h(P | c |\nsalt)*G`) and this salt is agreed upon by the Buyer and Seller (say for\nexample, `salt = ecdh(s, B)`), then the Seller can tell the Escrow to\ncompute `B'` given only `h(E | c | salt)` and `B` using `B' = ecdh(e + h(E\n| c | salt), B) * G`. In this way, the Escrow can validate for the Seller\nthat `B'` is what it should be, while learning only a random hash (who's\n`salt` ensures no information about `c` is revealed), and a temporary\npublic key, neither of which appear in any traceable way during a routed\npayment; certainly this is worse than no knowledge since the Escrow can\ncompute `b'` and choose to cheat by giving this to the Seller, but I claim\nthat this does not require more trust in the Escrow than is already being\nput in them. The only information gained by the Escrow is that a payment is\nhappening, and assuming that the Seller contacts them over an onion-routed\nnetwork (such as TOR), the Escrow doesn't even learn any information about\nthe Buyer or Seller's identities. Although it would certainly be better to\nhave the Escrow not even learn that they are being used, this seems like a\npretty acceptable amount of information for them to learn, and has the\npotential benefit of ensuring that being a trustworthy Escrow platform\nremains a sustainable (and competitive) endeavor, even in the absence of\ndisputes.\n\nOn a somewhat unrelated note, I just want to throw out there that it may be\nsimpler to have a scheme for routing Discreet Log Contracts over the\nlightning network for the kinds of simple oracle contracts like \"seller S\nwill deliver 100 pieces of USA federal reserve commemorative decoration\npaper in exchange for 1 satoshi from buyer\". Using a DLC would have the\nbenefit of requiring no interaction with the oracle (excluding broadcast\nwhich is fine) during dispute settlement. Just a thought :)\n\nBest,\nNadav\n\nOn Thu, Jun 20, 2019 at 12:54 AM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning list,\n>\n> One thing I am attempting to think through is some implementation of\n> escrow over Lightning.\n>\n> A non-custodial onchain escrow protocol simply uses a 2-of-3 multisig\n> amongst the two participants and the escrow.\n> Such a contract (like any onchain-enforceable contract) can be transported\n> over a *single* Lightning channel, but cannot be safely hopped across\n> channels: the escrow may take \"one\" side in one channel while taking the\n> \"other\" side on the other channel, thus putting every hop node at risk.\n>\n> Escrow services are useful when Bitcoin needs to interact with other\n> systems, such as the mythical \"real world\", when tr*st in a brandless\n> entity is difficult to procure, while some escrow service can aggregate and\n> reuse tr*st in its brand to enable trades between brandless entities.\n> Thus if at all possible, we should consider how best to support escrow\n> services over Lightning.\n>\n> I formulate the contract below:\n>\n> * A brandless buyer B wants to pay a brandless seller S for a service or\n> product.\n> * Both B and S have non-trust in one another, but can agree to tr*st a\n> common branded escrow E.\n> * B shall pay S if both B and S can agree that the service was rendered\n> satisfactorily or product was delivered.\n> * In case of dispute, E decides whether S is paid or B is refunded.\n> * B and S want to provide as little information to E as possible if both B\n> and S can come to an agreement (i.e. only reveal information if a dispute\n> occurs).\n>\n> Tr*st is still needed in E.\n> In particular, B and S both trust that E will not be susceptible to\n> bribery from their counterparty.\n>\n> The above can trivially be implemented onchain using a 2-of-3 multisig.\n>\n> 1,  The branded escrow E provides a public key as part of its brand.\n> 2.  B and S generate a short contract description of the service or\n> product to be rendered, in a language that E understands.\n> 3.  B and S tweak the escrow public key (if `E` is the escrow pubkey and\n> `c` is the description of the service/product, use `E + h(E | c) * G`).\n> 4.  B and S generate a 2-of-3 address using their own keys, plus the\n> tweaked escrow public key.\n> 5.  If B and S can come to an agreement, then they sign using their own\n> keys, and the third key (the tweaked escrow key) remains tweaked and E\n> cannot determine that it could have been used as the escrow, or the details\n> of the transaction, even if it monitors the blockchain (since its key is\n> not used directly, instead a tweaked version is used, and the tweak is not\n> revealed E if B and S are in agreement).\n>     But if B and S come to a dispute, either can provide E with the\n> agreed-upon description `c` that is committed to onchain, and lets E judge\n> where the payment should go.\n>\n> Under bip-taproot this can be optimized somewhat in favor of the \"no\n> dispute\" case by setting the taproot internal key to `MuSig(B, S)`, and\n> having separate MAST branches for `MuSig(E + h(E | c) * G, B)` and `MuSig(E\n> + h(E | c) * G, S)`.\n>\n> This use-case is important: consider the case where the seller is selling\n> pieces of decorated paper mass-printed by some centralized financial\n> institution.\n> For face-to-face transactions, it is enough for all of the participants to\n> appear and for the Lightning payment to be attempted and so forth.\n> But for non-face-to-face transactions (such as when one participant is\n> secretly an AI that is attempting to take over the world, and is currently\n> unable to puppet some meatspace representative), such escrow would be best\n> done online with no requirement of physical presence.\n>\n> ---\n>\n> Naively, it seems that switching to payment points / scalars from payment\n> hashes / preimages (a necessity for payment decorrelation) may work.\n> It may be possible to use some kind of verifiable secret sharing.\n>\n> However, I would like to make the following points possible:\n>\n> * The escrow does not learn about an escrowed trade unless a dispute\n> between buyer and seller occurs.\n> * The escrow is capable of returning the buyer funds immediately as soon\n> as it can resolve the dispute without timing out the payment.\n> * Intermediate hop nodes that are not the buyer, seller, or escrow, remain\n> unaware of the escrowed trade (ideally, if they support the \"normal\"\n> payment points / scalars system, they should not need any special support\n> for escrowed trade).\n>\n> Let me sketch below something, which might not work since I have not\n> actually learned verifiable secret sharing at all.\n> In particular, if verifiable secret sharing requires that the participants\n> including the escrow to set up the payment point interactively, this fails\n> the first desired item, that the escrow only learns of the escrowed trade\n> in a dispute case.\n> (i.e. a real mathist should actually check this.)\n>\n> ---\n>\n> I will ignore here temporarily the issues of payment decorrelation, and\n> pretend that the same point is used in the entire path.\n>\n> Before all this, E publishes its escrow key `E`.\n>\n> First, B and S generate temporary payment points and scalars, `B = b * G`\n> and `S = s * G`.\n> Then they agree on the contract `c` describing their agreement, in a\n> language that E understands, e.g. \"seller S will deliver 100 pieces of USA\n> federal reserve commemorative decoration paper in exchange for 1 satoshi\n> from buyer\".\n>\n> Then B generates an ECDH shared secrets between escrow and buyer:\n>\n>     tweak(c, P) = P + h(P | c) * G\n>     ecdh(a, B) = h(a * B)\n>     b' = ecdh(b, tweak(c, E))\n>     B' = b' * G\n>     S' = S + B'\n>\n> The payment point used in the payment route is `S'`.\n>\n> B provides `B` and `B'` to S (this can be done using TLV in the onion\n> packet).\n> Of course, we also need to provide a proof that `B' == ecdh(b, tweak(c,\n> E)) * G` where `B == b * G`.\n> I have no idea how easy (or impossible) it is to make such a proof\n> (without E having to attest to it).\n>\n> If S believes it has fulfilled the contract and delivered the product or\n> service, it contacts B.\n> If B is satisfied with the product or service, it provides `b'`, allowing\n> S to compute `s + b'` needed to claim the payment point `S + B'`.\n> In the non-dispute case, E never learns that it could have been the escrow.\n> B receives the scalar `s + b'` from the payment, but it knows `b'` and can\n> compute the scalar `s` which now serves as proof-of-payment.\n>\n> If B is unsatisfied, we have a dispute condition and S contacts the escrow\n> E.\n> S provides `B` and the contract `c` to the escrow.\n> ECDH allows E to determine `b' = ecdh(e + h((e * G) | c), B)`.\n> If E decides in favor of the seller, then it reveals `b'` to S, which can\n> then compute `s + b'` and claim the payment point `S + B'`.\n>\n> However, note that if E decides in favor of the buyer, it cannot do\n> anything other than let the payment timeout lapse, which automatically\n> forces the seller S to fail the HTLC.\n> I cannot derive a way for E to force S to fail the HTLC, without revealing\n> to intermediate hop nodes that this is an escrow payment.\n>\n> Even if E is the only intermediate hop node between B and S (an\n> undesirable situation since it allows E to censor and surveil the payments\n> between B and S), it is not safe for E to fail its incoming PTLC until S\n> has failed its incoming PTLC, as otherwise B and S could be coordinating to\n> steal from escrow E.\n>\n> There are likely to be better schemes.\n> Again, the ideal scheme would provide:\n>\n> * Escrow only learns of dispute cases, never learns non-dispute case.\n> * Buyer can recover funds immediately as soon as escrow decides in favor\n> of buyer. <- this seems difficult/impossible under LN.\n> * Intermediate hop nodes are unaware of anything special with the payment.\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190627/b4b71e07/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-27T22:33:45",
                "message_text_only": "Good morning Nadav,\n\n> Hi ZmnSCPxj,\n>\n> I find this idea super exciting!\n\nThank you.\n\nI observe that this idea involves sending a key (`b'`) from buyer (who is paying over the LN, i.e. payer) to seller (who is getting paid over the LN, i.e. payee).\nAs it happens, with knowledge of the contract as well as a (possibly temporary) pubkey of the buyer, the escrow can also provide this key if it decides in favor of the seller.\n\nI observe also that the Stuckless Payments proposal also involves a key being sent from payer (\"buyer\") to payee (\"seller\").\nMight it be possible to reuse the same key for both escrow and stuckless?\n(we might have to separate the scalars used for decorrelation from the final key used in stuckless / escrow).\n\n>\n> I think that the main wrinkle in what you've presented is how the Seller can verify that `B'` is indeed `ecdh(b, tweak(c, E))*G` since absent this authentication, the Escrow will be unable to provide the Seller with the necessary information to claim funds during a dispute.\n>\n> Perhaps there is some fancy ZKP that allows the Seller and Buyer to establish this alone but I don't know what that would look like. If it exists than that scheme would be better than the following but here are my thoughts:\n>\n> If we do need the Escrow to attest to the validity of `B'`, we want to make sure that the Escrow gains as little knowledge as possible. If we add a salt to the `tweak` function's hash (i.e `tweak(c, P, salt) = P + h(P | c | salt)*G`) and this salt is agreed upon by the Buyer and Seller (say for example, `salt = ecdh(s, B)`), then the Seller can tell the Escrow to compute `B'` given only `h(E | c | salt)` and `B` using `B' = ecdh(e + h(E | c | salt), B) * G`. In this way, the Escrow can validate for the Seller that `B'` is what it should be, while learning only a random hash (who's `salt` ensures no information about `c` is revealed), and a temporary public key, neither of which appear in any traceable way during a routed payment; certainly this is worse than no knowledge since the Escrow can compute `b'` and choose to cheat by giving this to the Seller, but I claim that this does not require more trust in the Escrow than is already being put in them. The only information gained by the Escrow is that a payment is happening, and assuming that the Seller contacts them over an onion-routed network (such as TOR), the Escrow doesn't even learn any information about the Buyer or Seller's identities. Although it would certainly be better to have the Escrow not even learn that they are being used, this seems like a pretty acceptable amount of information for them to learn, and has the potential benefit of ensuring that being a trustworthy Escrow platform remains a sustainable (and competitive) endeavor, even in the absence of disputes.\n\nIndeed, this seems acceptable to me also.\nThank you for working this out, it seems feasible to me.\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Escrow Over Lightning?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 21237
        }
    },
    {
        "title": "[Lightning-dev] Proposal for Stuckless Payment",
        "thread_messages": [
            {
                "author": "Hiroki Gondo",
                "date": "2019-06-25T08:20:12",
                "message_text_only": "Problem\n\n===============================\n\nWith the current BOLT 1.x, there exists a theoretical possibility that\npayments get stuck. In the actual network, this problem appears to be\nsignificantly improved due to the maturity of each implementation and the\npreventive ping-before-commitment_signed [1]. However, there is still a\npossibility that payments would get stuck due to an unstable communication\nenvironment, trouble and malice of intermediate nodes, etc., and we need to\nestimate the cost to deal with potential problems in advance.\n\n\nProposal Summary\n\n===============================\n\nThe following proposal is intended to reduce payments getting stuck. Both\nthe payee and the payer provide keys to settle the payment, so it is\npossible to safely retry in each phase that composes one payment. Also, the\ninvolvement of the intermediate nodes can be eliminated.\n\nIn other words, we can assure this problem involves only the parties (the\npayer and the payee). This proposal is not compatible with the BOLT 1.x,\nand it\u2019s assumed to apply to future specifications.\n\n\nHow to deal with payments getting stuck at present?\n\n===============================\n\nIf payments get stuck, we will need additional *trusted* operations by the\nfinal node\u2019s implementation, the application or the service operator. For\nexample, when a payer orders a cup of coffee and attempts to pay for the\ninvoice, but the payment gets stuck, what must we do to correct the problem?\n\nIf an `update_add_htlc` gets stuck on an intermediate node (strictly, the\nabsence of the `revoke_and_ack` for the `commitment_signed` for the\nmessage), the payer cannot ignore the issue. It may be fulfilled or failed,\nbut in the worst case the payer must wait until the `cltv_expiry`. That is\nnot realistic for UX.\n\nThere are obvious problems with retrying the payment by different routes\nusing the same invoice. After a successful retry, if the previous stuck\npayment starts moving again and also succeeds, the payer will pay twice for\nthe same invoice. The payer cannot obtain the information to prove he has\npaid twice (he has only a single preimage). Although the payee may fail the\nsecond arrival payment for the same invoice, that is a *trusted* operation\ndependent upon the final node implementation. Also, if an\n`update_fulfill_htlc` gets stuck on the return, there is no solution.\n\nIf the payer receives another invoice from the payee and pays again, and if\nthe two payments are succeed, the payer must obtain a refund from the payee\nfor the extra payment. This requires additional *trusted* operations\ndependent on the application or the service operator.\n\n\nKey Provided by Payer\n\n===============================\n\nAs I previously mentioned, if an `update_add_htlc` gets stuck, the payer\ncannot ignore that. Because the payee has the key (preimage) to unlock the\nHTLCs in BOLT 1.x, the HTLCs may be fulfilled in unintended timing for the\npayer.\n\nWhat happens if the payer provides the key? For example, in the original\nAMP [2], the payer provides the preimage (this proposal may be useful for\nAMP, but in this example it is not meaningful to be *multi-path*, so please\nimagine a simple *single-path*). The preimage is sent in the onion of the\n`update_add_htlc`s. In other words, the HTLCs (locks) and the preimage\n(key) are sent together.\n\n        A --> B --> C --> D        # update_add_htlc, preimage\n\n        A <-- B <-- C <-- D        # update_fulfill_htlc\n\nI would like to separate the process into two phases; \"add HTLCs (locks)\"\nand \"provide a preimage (key)\". After adding HTLCs along the route by\n`update_add_htlc`s not including the preimage, the payee returns the ACK to\nthe payer. The payer will provide the preimage to the payee in the next\nphase. In this way, the payer simply forgets the payment if an\n`update_add_htlc` gets stuck and the ACK is not returned in a more\nrealistic timeout (e.g. 1 min) than the `cltv_expiry`, and can retry the\npayment with another invoice without worrying about overpayment.\n\n        A --> B --> C --> D        # update_add_htlc\n\n        A <-- B <-- C <-- D        # ACK\n\n        A --> B --> C --> D        # preimage\n\n        A <-- B <-- C <-- D        # update_fulfill_htlc\n\nHowever, this procedure does not yet solve the problem if\n`update_fulfill_htlc`s gets stuck.\n\n\nProof of Payment\n\n===============================\n\nIf the payer provided the preimage, the payer cannot get the proof of\npayment (PoP).\n\nPoP is important. It's important to bring it to the court, but it's also\nnecessary if upper layer applications are willing to proceed to the next\naction based on the payment outcome. However, if we do not need to maintain\ncompatibility with BOLT 1.x, it is possible to add PoP to the above case\n(HTLCs need two keys from both the payee and the payer, not only one key\n(preimage) from the payee).\n\nI have another consideration regarding PoP. In BOLT1.x, a preimage is\nreturned along the route. The payer receives the PoP when he receives the\npreimage by the `update_fulfill_htlc` directly from the peer. Thus, if an\n`update_fulfill_htlc`s gets stuck somewhere in the route, the payer cannot\nobtain the PoP.\n\n        A --> B --> C --> D        # update_add_htlc\n\n        A       B x-- C <-- D        # update_fulfill_htlc (stuck)\n\nHowever, the payee can provide the preimage to the payer earlier. If the\n`update_add_htlc` is irrevocably committed at the payee's own channel and\nthere is no problem with the parameters, it is safe to send the preimage to\nthe payer skipping the intermediate nodes or using an alternate route (if\npossible).\n\n        A --> B --> C --> D        # update_add_htlc\n\n        A <----------------- D        # preimage\n\n        A       B x-- C <-- D        # update_fulfill_htlc (stuck)\n\n\ne.g. Modifications of \u201cMulti-Hop Locks from Scriptless Scripts\u201d\n\n===============================\n\nBased on the above considerations, I will describe the stuckless payment\nprotocol. I will do the work from \"Multi-Hop Locks from Scriptless Scripts\".\n\nMulti-Hop Locks from Scriptless Scripts\n\nhttps://github.com/apoelstra/scriptless-scripts/blob/master/md/multi-hop-locks.md\n\n(commit 94a4e2f961c839bd1b9ca8773abadbf0f198c34b)\n\nI will modify the following sequence.\n\nhttps://raw.githubusercontent.com/apoelstra/scriptless-scripts/master/md/images/multi-hop-locks.png\n\nThe modifications are as follows.\n\nSetup: At the end of this phase, Do NOT send the key (`y0+y1+y2`) from A to\nD yet.\n\nUpdate: At the end of this phase, D returns the ACK to A.\n\n        A <-- B <-- C <-- D        # ACK\n\nPre-Settlement: Add this new phase after the Update phase. Any route can be\nused.\n\n        A --> * --> * --> D        # key (`y0+y1+y2`)\n\n        A <-- * <-- * <-- D        # PoP (`z`)\n\nSettlement: No change.\n\nLet's look at the details.\n\nIn the original sequence, *the payer* provides the key (`y0+y1+y2`) to\nunlock the HTLCs (like the original AMP). The sequence has also introduced\nthe PoP (`z`) provided by *the payee*, which already meets, to some extent,\nthe requirements of what I will describe.\n\nSetup:\n\nIn the original sequence, the resistance to stuck payments is the same as\nin the BOLT 1.x. All we need to do is to separate the process sending the\nkey (`y0+y1+y2`) from the Setup phase and bring it after the Update phase.\nThis prevents the payee from immediately moving to the Settlement phase\nafter the Update phase is complete. Therefore, if a stuck payment in the\nUpdate phase suddenly begins moving, the phase cannot automatically move to\nthe Settlement phase against the will of the payer.\n\nUpdate:\n\nAt the end of this phase, we require the payee return the ACK to the payer\nto notify the completion of this phase. It must be guaranteed that the\npayee himself returns it. This can be achieved by reversing the route and\nwrapping the ACK in the onion sequentially, as the `reason` field of the\n`update_fail_htlc` in BOLT 1.x.\n\nIf the payment gets stuck in this phase, the payer can create a new key and\nreuse the PoP (`z`) to start over from the Setup phase. Since the key of\nthe previous stuck payment has not been sent to the payee, the stuck HTLCs\ncan be left and they will be removed later.\n\nPre-Settlement:\n\nThe new Pre-Settlement phase is the actual settlement phase between the\npayer and the payee. When the payer receives the ACK at the end of the\nUpdate phase, he can send the key to the payee. Since this phase is just\npassing data between two points (unlike adding HTLCs), if it fails we can\nsafely retry and (if possible) not have to use the same route or routing\nprotocol as the Update phase.\n\nAfter the payee receives and verifies the key from the payer, he can send\nthe PoP (`z`) to the payer as the response. The payee can do this before\nthe Settlement phase if he can verify that the received key is for his own\nincoming HTLC.\n\nSettlement:\n\nThe Settlement phase is the same as that of the original sequence. Even if\na message get stucks in this phase, the payment itself is not affected\nsince the settlement between the payer and the payee has already been\nsubstantially completed in the Pre-Settlement phase.\n\nThese modifications add the cost of three new messages (ACK, key, PoP), but\nit is only three (unaccompanied by other messages). These may also reduce\nother preventive messages.\n\n\nConclusion\n\n===============================\n\nIn this proposal, the probability that messages in each phase get stuck is\nat the same level as BOLT 1.x, but even if they get stuck, it is possible\nto safely retry each phase that composes one payment, and the number of\npayments completely stuck will be reduced.\n\nIn fact, the stuck problem will be limited to the Pre-Settlement phase\nbetween the two parties (the payer and the payee). This is the case where\nthe payer sends the key to the payee, but the PoP (`z`) is not returned. I\nhave already mentioned that the payer can safely retry this phase and does\nnot have to use the same route or routing protocol as the Update phase.\n\nAny remaining problems would be caused by the payee's own trouble or\nmalice, which means that no intermediate node is involved in the stuck\nproblem, and this problem becomes one involves only the parties (the payer\nand the payee). This improvement allows us to see the Lightning Network as\nmore trustless.\n\n\nHiroki Gondo\n\n\n\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/508\n\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/ddfd97d2/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-25T10:15:29",
                "message_text_only": "Good morning Hiroki,\n\nThank you for this.\nIt seems a good solution.\nAnd, it seems, yet another reason to move to payment point / scalar from payment hash / preimage.\n\nAs I understand it, the `y0+y1+...` sums are also the blinding tweaks used for payment decorrelation.\nMy understanding, they will be sent in onion packet.\n\n> Pre-Settlement: Add this new phase after the Update phase. Any route can be used.\n>\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0A --> * --> * --> D\u00a0 \u00a0 \u00a0 \u00a0 # key (`y0+y1+y2`)\n>\n> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0A <-- * <-- * <-- D\u00a0 \u00a0 \u00a0 \u00a0 # PoP (`z`)\n\nMy poor suggestion, to use same route ->B->C-> and <-B<-C<-.\nCurrently, destination D does not know who is payer A.\nSo my opinion, it is best to retain this property of \"D does not know payer A\".\n\nOf course, in practice in many case, D knows A already, for example for delivery address of product.\nBut anonymity should be preserved still.\nFor example, perhaps I wish to deliver product to some other entity other than me, and wish to remain anonymous to do so.\n\nHowever, I seem, the detail below, means we should use the same route:\n\n> At the end of this phase, we require the payee return the ACK to the payer to notify the completion of this phase. It must be guaranteed that the payee himself returns it. This can be achieved by reversing the route and wrapping the ACK in the onion sequentially, as the `reason` field of the `update_fail_htlc` in BOLT 1.x.\n\n\n\n> These modifications add the cost of three new messages (ACK, key, PoP), but it is only three (unaccompanied by other messages). These may also reduce other preventive messages.\n\nThe added communication round may allow intermediate node to guess the payer.\n\nAlready in current network, intermediate node can guess the distance to payee.\nDistance to payee can be guessed from timelocks.\nAlso, distance to payee can be guessed by time from `update_add_htlc` to time of `update_fulfill_htlc`/`update_fail_htlc`.\n\nHowever, there is no information that intermediate node can use to guess distance to payer.\n\nWith addition of new ACK-key turnaround, intermediate node can measure time from send of ACK to receive of key, and guess its distance to payer.\n\nI am uncertain how to weigh this.\nI believe, this idea is very good and stuckless is important feature.\nGetting some information about the payer may allow attempts at censorship, however.\nBut maybe the information leaked is not significant enough in practice.\n\nAnother issue is the added latency of payments.\nAlready, because of cooperative signing by use of MuSig, we know that latency of payment point / scalar is worsened.\nBut use of ACK-key turnaround increases latency further.\nOf course, we should consider, most of latency is because of retries.\nWith \"stuckless\" payment, we can (if we have enough money) make multiple tries in parallel.\nSo possibly, this may reduce latency \"in the large\" at the cost of increasing latency \"in the small\".\n\nAnother thought, is that this may also solve the \"American Call Option\" problem.\nIn this case, the key at the final step is the sum of the payer key and the exchange key (`y0 + y1 + y2 + z` where payer knows `y0 + y1 + y2` and exchange knows `z`).\nThen intermediate nodes are unaware that a cross-currency exchange is involved.\nThis thought, I will need to consider further for correctness.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2019-06-25T16:46:38",
                "message_text_only": "This is a very good proposal, thanks Hiroki for all those details it helped\nme learn a lot.\n\nIf I'm not mistaken, https://eprint.iacr.org/2018/472.pdf has shown that we\nMUST add another round\nof communication if we want to avoid the wormhole attacks (and thus\ndecorrelate payments). While\nI agree that this degrades latency, if it provides a way to \"cancel\" stuck\npayments and retry I think it's\nworth it. And I really like the option to make multiple tries in parallel\nas you suggest, which would help\nwith latency (if you have enough outbound capacity).\n\nI agree with ZmnSCPxj that it would be good to keep payer anonymity, and I\nmay have a solution to\nprovide this. As ZmnSCPxj explains, the loss of payer anonymity is due to\nthe ACK message traveling\nvia the same route (D -> C -> B -> A).\n\nHowever, there are two interesting things to note about the ACK message\n(unless I missed something):\n\n   1. It doesn't need any data from D\n   2. It isn't tied to channels and only A needs to receive it (not\n   intermediate nodes)\n   3. It could use a smaller onion packet than the *add_htlc* onion (fixed\n   size but smaller than 1300 bytes)\n\nGiven 1., the ACK onion packet can be constructed by A. Given 2., it can\nuse a different route than the\n*add_htlc* onion packet.\n\nA can select another route (e.g. D -> E -> F -> A) and can create the ACK\nonion packet during the setup phase.\nA can then embed this ACK packet inside the last hop payload of the\n*add_htlc* onion packet.\nWhen D receives it, it simply sends that onion to the indicated recipient\n(E) which will unwrap and forward.\nThis way D doesn't learn anything about A, and intermediate nodes aren't\nincluded in the ACK route so\nthey don't learn anything either.\n\nNote that nodes in the ACK message route don't have an incentive to forward\nACK messages (apart from\nparticipating honestly in the network). But even if a malicious node drops\nan ACK message, it just ends up\nbeing a stuck payment that you can safely retry since you haven't shared\nthe keys yet.\n\nAnd if A doesn't care about anonymity at all, A can provide its information\nin the onion to let D directly send it\nthe ACK. I don't know if we want to provide that option or not, but at\nleast that's possible to do.\n\nWould that be a satisfactory solution to maintain the payer anonymity\nproperty?\n\nCheers,\nBastien\n\nLe mar. 25 juin 2019 \u00e0 12:16, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning Hiroki,\n>\n> Thank you for this.\n> It seems a good solution.\n> And, it seems, yet another reason to move to payment point / scalar from\n> payment hash / preimage.\n>\n> As I understand it, the `y0+y1+...` sums are also the blinding tweaks used\n> for payment decorrelation.\n> My understanding, they will be sent in onion packet.\n>\n> > Pre-Settlement: Add this new phase after the Update phase. Any route can\n> be used.\n> >\n> >         A --> * --> * --> D        # key (`y0+y1+y2`)\n> >\n> >         A <-- * <-- * <-- D        # PoP (`z`)\n>\n> My poor suggestion, to use same route ->B->C-> and <-B<-C<-.\n> Currently, destination D does not know who is payer A.\n> So my opinion, it is best to retain this property of \"D does not know\n> payer A\".\n>\n> Of course, in practice in many case, D knows A already, for example for\n> delivery address of product.\n> But anonymity should be preserved still.\n> For example, perhaps I wish to deliver product to some other entity other\n> than me, and wish to remain anonymous to do so.\n>\n> However, I seem, the detail below, means we should use the same route:\n>\n> > At the end of this phase, we require the payee return the ACK to the\n> payer to notify the completion of this phase. It must be guaranteed that\n> the payee himself returns it. This can be achieved by reversing the route\n> and wrapping the ACK in the onion sequentially, as the `reason` field of\n> the `update_fail_htlc` in BOLT 1.x.\n>\n>\n>\n> > These modifications add the cost of three new messages (ACK, key, PoP),\n> but it is only three (unaccompanied by other messages). These may also\n> reduce other preventive messages.\n>\n> The added communication round may allow intermediate node to guess the\n> payer.\n>\n> Already in current network, intermediate node can guess the distance to\n> payee.\n> Distance to payee can be guessed from timelocks.\n> Also, distance to payee can be guessed by time from `update_add_htlc` to\n> time of `update_fulfill_htlc`/`update_fail_htlc`.\n>\n> However, there is no information that intermediate node can use to guess\n> distance to payer.\n>\n> With addition of new ACK-key turnaround, intermediate node can measure\n> time from send of ACK to receive of key, and guess its distance to payer.\n>\n> I am uncertain how to weigh this.\n> I believe, this idea is very good and stuckless is important feature.\n> Getting some information about the payer may allow attempts at censorship,\n> however.\n> But maybe the information leaked is not significant enough in practice.\n>\n> Another issue is the added latency of payments.\n> Already, because of cooperative signing by use of MuSig, we know that\n> latency of payment point / scalar is worsened.\n> But use of ACK-key turnaround increases latency further.\n> Of course, we should consider, most of latency is because of retries.\n> With \"stuckless\" payment, we can (if we have enough money) make multiple\n> tries in parallel.\n> So possibly, this may reduce latency \"in the large\" at the cost of\n> increasing latency \"in the small\".\n>\n> Another thought, is that this may also solve the \"American Call Option\"\n> problem.\n> In this case, the key at the final step is the sum of the payer key and\n> the exchange key (`y0 + y1 + y2 + z` where payer knows `y0 + y1 + y2` and\n> exchange knows `z`).\n> Then intermediate nodes are unaware that a cross-currency exchange is\n> involved.\n> This thought, I will need to consider further for correctness.\n>\n>\n> Regards,\n> ZmnSCPxj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/28d783f9/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-26T03:19:39",
                "message_text_only": "Good morning list,\n\n\n> Another thought, is that this may also solve the \"American Call Option\" problem.\n> In this case, the key at the final step is the sum of the payer key and the exchange key (`y0 + y1 + y2 + z` where payer knows `y0 + y1 + y2` and exchange knows `z`).\n> Then intermediate nodes are unaware that a cross-currency exchange is involved.\n> This thought, I will need to consider further for correctness.\n\nI apologize for the noise, but after some thought, the free-premium American Call Option problem does not get helped by stuckless payments, at least by itself.\nThe general solution is for the exchange to require that it get paid the premium immediately, with the premium encumbered only by the exchange.\n\nBelow is a basic sketch.\n\n* Payer requests the exchange for a public key `Z` such that `Z = z * G` where `z` is known only by the exchange.\n  This should be done anonymously over Tor.\n* Payer routes a payment via the exchange.\n  * Payer provides a proof (somehow) to the exchange that the payee has to claim `P + Z + (y0 + y1 + y2) * G`, where payee knows `p` such that `P = p * G`, payer knows `(y0 + y1 + y2)`.\n    * Invoice payment points must include a proof-of-knowledge (i.e. a signature using `P` must be included in the invoice, not just a payee signature attesting to the invoice details --- we do not want to give the invoice details and the payee pubkey to the exchange, lest it censor).\n    * Payer can provide a signature with `(y0 + y1 + y2) * G`.\n    * As signatures are involved, should we worry about key cancellation attacks on `Z`?\n      I am not a mathematician.\n    * Exchange should be able to identify the `Z` it released.\n* Exchange validates, then performs the exchange.\n* Payee sends `ACK` message.\n* Payer pays the premium to the exchange, using `Z` as the payee key.\n  It can use stuckless protocol (or not).\n* Exchange claims the premium, making the American Call Option have a premium and thus rational for the exchange to accept.\n  Payee learns `z`.\n* Payer can now provide `key` message to payee, containing `(y0 + y1 + y2) + z`.\n\nIn effect, the proof-of-payment-of-premium is enough to let the exchange issue an American Call Option.\n\nPayer and payee can still lock the exchange funds by not paying the option premium, but it is not an \"option\" since the payee cannot cause the cross-currency swap to push through without the exchange getting paid the premium.\nThe exchange can force a timeout on the premium payment `Z`, such that if it is not paid, the exchange will permanently delete `z`.\nAlternately (and maybe better...) the exchange can force that the premium is paid *before* it performs the swap and propagates the payment onward.\n\n(a detail, but I suspect the payer can also send a `cancel` message instead of `key` in response to `ACK`, for example if multiple parallel attempts are made and one of the other attempts has already completed; in which case if the exchange times out, an honest payee can just send thsi `cancel` message)\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Hiroki Gondo",
                "date": "2019-06-27T09:45:13",
                "message_text_only": "Hi ZmnSCPxj and Bastien,\n\nWhen I was putting together this proposal, I thought it would be difficult\nfor me to consider all the security and privacy issues. I am very glad that\nyou raised the possible issues.\n\n> So my opinion, it is best to retain this property of \"D does not know\npayer A\".\n\nI agree with your opinion too. I thought there was no problem if the ACK\nand the PoP were responses of the HTLCs and the key respectively. But,\n\n> The added communication round may allow intermediate node to guess the\npayer.\n\n> With addition of new ACK-key turnaround, intermediate node can measure\ntime from send of ACK to receive of key, and guess its distance to payer.\n\nRight.\n\n> A can select another route (e.g. D -> E -> F -> A) and can create the ACK\n> onion packet during the setup phase.\n> A can then embed this ACK packet inside the last hop payload of the\n> *add_htlc* onion packet.\n> When D receives it, it simply sends that onion to the indicated recipient\n> (E) which will unwrap and forward.\n> This way D doesn't learn anything about A, and intermediate nodes aren't\n> included in the ACK route so\n> they don't learn anything either.\n\nI think this is likely to be an improvement. This could also be generalized\nas a case where a packet we send goes back to us via a given node. I need\nto understand more precisely the limitations of the onion packet including\nnew specs under development. In the process, I will also consider\ncombination of this proposal with AMP and new routing algorithms\n(Trampoline, Rendezvous).\n\nRegards,\nHiroki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190627/59d0135b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal for Stuckless Payment",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "ZmnSCPxj",
                "Hiroki Gondo"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 24887
        }
    },
    {
        "title": "[Lightning-dev] [PROPOSAL]: FAST - Forked Away Simultaneous Transactions",
        "thread_messages": [
            {
                "author": "Ugam Kamat",
                "date": "2019-06-25T11:06:59",
                "message_text_only": "Hey guys, \n\n \n\nI'm kind of new to this mailing list, so let me know if this has been\nproposed previously. While reading Olaoluwa Osuntokun's Spontaneous Payment\nproposal, I came up with the idea of simultaneous payments to multiple\nparties using the same partial route. In other words, say Alice, Bob,\nCharlie, Dave and Eric have channel opened with one another, and say Dave\nalso has channel with Frank who has channel with Grace. Now, Alice is at a\nrestaurant and wants to pay the bill amount to Eric (the restaurant owner)\nand a tip to Grace (who was her waiter). In the current scenario, Alice\nwould have to send two payments A->B->C->D->E and A->B->C->D->F->G. However,\nif we repurpose the onion blob\n<https://github.com/ElementsProject/lightning/pull/2363>  in the same way as\nis needed for Spontaneous Payments, we can create a scenario where there is\nno path duplication. Dave would split the payments, one to Eric and other\ngoing to Grace through Frank. The preimage PM used in commitments A->B, B->C\nand C->D will be a function of pre-images P1 of D->E and P2 of D->F and F->G\nsuch that PM = f(P1, P2).\n\n \n\nProposal can be implemented by repurposing the onion in similar fashion as\nSpontaneous Payments with slight modification\n\nThis proposal works in similar fashion to Spontaneous Payment proposal, by\npacking in additional data in the unused hops. For B and C the onion blob\nwill be identical to other lightning payments. When D parses the onion, the\n4 MSB of the realm will tell D how much data can be extracted. This data\nwill encode the hashes of the pre-images that would be used for commitment\ntransaction towards Eric and other towards Frank.  For simplicity and\nprivacy, I propose using 2 onion blobs for the data. So the payload can be\n64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are\npacked, so we have 96 bytes for the payload, meaning we can pack a maximum\nof 3 hashes for 3 route payments from D. Now D will split the onion (18 hops\nas it has used the first two for bifurcation data) into number of routes. In\nthe above case it will be 9 hops each. Now these two onions are similar to\nother lightning payments. The first hop tells D the short-channel id, amount\nto forward, CLTV and the padding. Since, the preimage is 32 bytes, we can\npack that in one single hop that is received by the final party. This leaves\nthe remaining 7 hops can be used for routing. Below figure depicts the onion\nsplit in terms of how A will create it. D will add the filler to make each\nonion have 20 hops. Onion data is encoded in the same order in which the\npayment hashes are packed in the bifurcation data for D.\n\n\n\n \n\nCalculating the preimages\n\nEric and Grace will parse the onion and use the pre-images for settlement.\nLet P1 represent the pre-images of D->E and P2 of D->F and F->G. When the\npre-images arrive at node D, it will combine them such that PM = f(P1, P2).\nThe easiest way for both A and D to calculate that will be PM = SHA256(P1 ||\nP2 || ss_d). Where || represents concatenation and ss_d is the shared secret\ncreated using the ephemeral public key of sender (the one generated by\nAlice) and private key of Dave. The need for using shared secret is to\nprevent the vulnerability where one channel operator who has nodes across\nboth branches can use them to calculate the PM. Using shared secret also\nensures that it is in fact D that has parsed them together. \n\n \n\nAdvantages of this proposal:\n\n*\tCommitment transactions between A & B, B & C, and C & D now carry\nonly one HTLC instead of two\n\n*\tThis means lower fees in case of on-chain settlement\n*\tLower routing fees for Alice as Bob and Charlie would not get to\ncharge for two routings\n*\tSince 483 is the max limit of the htlcs nodes can accepts,\npreventing duplication will allow more number of htlcs in flight.\n\n*\tIf each payment of Eric and Grace is below the htlc min B or C\naccepts, but together if it is higher, this route is now usable\n\n \n\nSome thoughts on if this proposal can be misused?\n\n*\tThe probability of transaction failures increases as now the\ntransaction is dependent on 2/3 branches\n\n \n\nDeployment\n\nNot all nodes need to support this feature. For example, B, C, E, F,  and G\ndoes not even know that the payment arrived through branching. The nodes\nthat can handle branching of payments can signal that using global features.\n\n \n\n \n\nUgam\n\n \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/0934469a/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image002.png\nType: image/png\nSize: 7836 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/0934469a/attachment-0001.png>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2019-06-25T11:32:36",
                "message_text_only": "Hey Ugam,\n\nI like the very clearly communicated idea and the fact that we can do crazy\nstuff with the filler of the onions. I have two concerns / questions:\n\n1.) In pathfinding we actually try to make payments smaller (like moving to\nAMP) instead of combining payments. I think it was shown several times that\nthe probability of finding a path (successful route) decreases with larger\namounts. So saving fees might actually not be the metric that we are trying\nto optimize.\n2.) Am I correct that this proposal would only work with the spontaneous\npayment scenario as the payment hashes of Eric and Grace could not just be\nadded up as easy as the preimages can to get the overall payment hash for\nAlice? So in that sense on the invoice based system your proposal is not\nworking and we don't have a proof of payment as Alice already knows the\npreimages? Could one resolve this in the world of scriptless scripts or\nwhen changing to secret / curve point based preimages based on the discrete\nlog?\n\nbest Rene\n\nOn Tue, Jun 25, 2019 at 7:07 AM Ugam Kamat <ugamkamat1 at gmail.com> wrote:\n\n> Hey guys,\n>\n>\n>\n> I\u2019m kind of new to this mailing list, so let me know if this has been\n> proposed previously. While reading Olaoluwa Osuntokun\u2019s Spontaneous\n> Payment proposal, I came up with the idea of simultaneous payments to\n> multiple parties using the same partial route. In other words, say Alice,\n> Bob, Charlie, Dave and Eric have channel opened with one another, and say\n> Dave also has channel with Frank who has channel with Grace. Now, Alice is\n> at a restaurant and wants to pay the bill amount to Eric (the restaurant\n> owner) and a tip to Grace (who was her waiter). In the current scenario,\n> Alice would have to send two payments A->B->C->D->E and A->B->C->D->F->G.\n> However, if we repurpose the onion blob\n> <https://github.com/ElementsProject/lightning/pull/2363> in the same way\n> as is needed for Spontaneous Payments, we can create a scenario where there\n> is no path duplication. Dave would split the payments, one to Eric and\n> other going to Grace through Frank. The preimage PM used in commitments\n> A->B, B->C and C->D will be a function of pre-images P1 of D->E and P2 of\n> D->F and F->G such that PM = f(P1, P2).\n>\n>\n>\n> *Proposal can be implemented by repurposing the onion in similar fashion\n> as Spontaneous Payments with slight modification*\n>\n> This proposal works in similar fashion to Spontaneous Payment proposal, by\n> packing in additional data in the unused hops. For B and C the onion blob\n> will be identical to other lightning payments. When D parses the onion, the\n> 4 MSB of the realm will tell D how much data can be extracted. This data\n> will encode the hashes of the pre-images that would be used for commitment\n> transaction towards Eric and other towards Frank.  For simplicity and\n> privacy, I propose using 2 onion blobs for the data. So the payload can be\n> 64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are\n> packed, so we have 96 bytes for the payload, meaning we can pack a maximum\n> of 3 hashes for 3 route payments from D. Now D will split the onion (18\n> hops as it has used the first two for bifurcation data) into number of\n> routes. In the above case it will be 9 hops each. Now these two onions are\n> similar to other lightning payments. The first hop tells D the\n> short-channel id, amount to forward, CLTV and the padding. Since, the\n> preimage is 32 bytes, we can pack that in one single hop that is received\n> by the final party. This leaves the remaining 7 hops can be used for\n> routing. Below figure depicts the onion split in terms of how A will create\n> it. D will add the filler to make each onion have 20 hops. Onion data is\n> encoded in the same order in which the payment hashes are packed in the\n> bifurcation data for D.\n>\n>\n>\n> *Calculating the preimages*\n>\n> Eric and Grace will parse the onion and use the pre-images for settlement.\n> Let P1 represent the pre-images of D->E and P2 of D->F and F->G. When the\n> pre-images arrive at node D, it will combine them such that PM = f(P1, P2).\n> The easiest way for both A and D to calculate that will be PM = SHA256(P1\n> || P2 || ss_d). Where || represents concatenation and ss_d is the shared\n> secret created using the ephemeral public key of sender (the one generated\n> by Alice) and private key of Dave. The need for using shared secret is to\n> prevent the vulnerability where one channel operator who has nodes across\n> both branches can use them to calculate the PM. Using shared secret also\n> ensures that it is in fact D that has parsed them together.\n>\n>\n>\n> *Advantages of this proposal:*\n>\n>    - Commitment transactions between A & B, B & C, and C & D now carry\n>    only one HTLC instead of two\n>       - This means lower fees in case of on-chain settlement\n>       - Lower routing fees for Alice as Bob and Charlie would not get to\n>       charge for two routings\n>       - Since 483 is the max limit of the htlcs nodes can accepts,\n>       preventing duplication will allow more number of htlcs in flight.\n>    - If each payment of Eric and Grace is below the htlc min B or C\n>    accepts, but together if it is higher, this route is now usable\n>\n>\n>\n> *Some thoughts on if this proposal can be misused?*\n>\n>    - The probability of transaction failures increases as now the\n>    transaction is dependent on 2/3 branches\n>\n>\n>\n> *Deployment*\n>\n> Not all nodes need to support this feature. For example, B, C, E, F,  and\n> G does not even know that the payment arrived through branching. The nodes\n> that can handle branching of payments can signal that using global features.\n>\n>\n>\n>\n>\n> Ugam\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n\nmobile: +49 (0)176 5762 3618\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/c6415a59/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image002.png\nType: image/png\nSize: 7836 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/c6415a59/attachment-0001.png>"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-25T11:56:07",
                "message_text_only": "Hey Rene, thanks for your comments! Regarding, pathfinding I agree, that smaller payments will have higher success rates, but this kind of bundling of payments will make some routes accessible which might not have been previously either due to `htlc_minimum_msat` limit of those nodes. Also, this reduces the number of HTLCs that are added making 483 limit more harder to reach. I think the decision might be a balance that we need to strike and can be an optional feature that can be enabled.\n\n \n\nYes, this proposal can only work for spontaneous payments as I think it would be impossible to bundle the hashes generated by the invoices and extract the pre-image. Regarding, proof of payment, as far as I know, spontaneous payments in itself does not carry that as Alice already knows the pre-images. So, this situation would be similar to that or even AMP for that matter where the user generates the preimages by themselves. \n\n \n\nCould one resolve this in the world of scriptless scripts or when changing to secret / curve point based preimages based on the discrete log? To be frank, I have not done any work on this and will have to read this up before I can comment. Really appreciate your feedback.\n\n \n\nUgam\n\n \n\nFrom: Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com> \nSent: Tuesday, June 25, 2019 5:03 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com>\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] [PROPOSAL]: FAST - Forked Away Simultaneous Transactions\n\n \n\nHey Ugam, \n\n \n\nI like the very clearly communicated idea and the fact that we can do crazy stuff with the filler of the onions. I have two concerns / questions: \n\n \n\n1.) In pathfinding we actually try to make payments smaller (like moving to AMP) instead of combining payments. I think it was shown several times that the probability of finding a path (successful route) decreases with larger amounts. So saving fees might actually not be the metric that we are trying to optimize.\n\n2.) Am I correct that this proposal would only work with the spontaneous payment scenario as the payment hashes of Eric and Grace could not just be added up as easy as the preimages can to get the overall payment hash for Alice? So in that sense on the invoice based system your proposal is not working and we don't have a proof of payment as Alice already knows the preimages? Could one resolve this in the world of scriptless scripts or when changing to secret / curve point based preimages based on the discrete log?\n\n \n\nbest Rene \n\n \n\nOn Tue, Jun 25, 2019 at 7:07 AM Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> > wrote:\n\nHey guys, \n\n \n\nI\u2019m kind of new to this mailing list, so let me know if this has been proposed previously. While reading Olaoluwa Osuntokun\u2019s Spontaneous Payment proposal, I came up with the idea of simultaneous payments to multiple parties using the same partial route. In other words, say Alice, Bob, Charlie, Dave and Eric have channel opened with one another, and say Dave also has channel with Frank who has channel with Grace. Now, Alice is at a restaurant and wants to pay the bill amount to Eric (the restaurant owner) and a tip to Grace (who was her waiter). In the current scenario, Alice would have to send two payments A->B->C->D->E and A->B->C->D->F->G. However, if we repurpose the onion blob <https://github.com/ElementsProject/lightning/pull/2363>  in the same way as is needed for Spontaneous Payments, we can create a scenario where there is no path duplication. Dave would split the payments, one to Eric and other going to Grace through Frank. The preimage PM used in commitments A->B, B->C and C->D will be a function of pre-images P1 of D->E and P2 of D->F and F->G such that PM = f(P1, P2).\n\n \n\nProposal can be implemented by repurposing the onion in similar fashion as Spontaneous Payments with slight modification\n\nThis proposal works in similar fashion to Spontaneous Payment proposal, by packing in additional data in the unused hops. For B and C the onion blob will be identical to other lightning payments. When D parses the onion, the 4 MSB of the realm will tell D how much data can be extracted. This data will encode the hashes of the pre-images that would be used for commitment transaction towards Eric and other towards Frank.  For simplicity and privacy, I propose using 2 onion blobs for the data. So the payload can be 64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are packed, so we have 96 bytes for the payload, meaning we can pack a maximum of 3 hashes for 3 route payments from D. Now D will split the onion (18 hops as it has used the first two for bifurcation data) into number of routes. In the above case it will be 9 hops each. Now these two onions are similar to other lightning payments. The first hop tells D the short-channel id, amount to forward, CLTV and the padding. Since, the preimage is 32 bytes, we can pack that in one single hop that is received by the final party. This leaves the remaining 7 hops can be used for routing. Below figure depicts the onion split in terms of how A will create it. D will add the filler to make each onion have 20 hops. Onion data is encoded in the same order in which the payment hashes are packed in the bifurcation data for D.\n\n\n\n \n\nCalculating the preimages\n\nEric and Grace will parse the onion and use the pre-images for settlement. Let P1 represent the pre-images of D->E and P2 of D->F and F->G. When the pre-images arrive at node D, it will combine them such that PM = f(P1, P2). The easiest way for both A and D to calculate that will be PM = SHA256(P1 || P2 || ss_d). Where || represents concatenation and ss_d is the shared secret created using the ephemeral public key of sender (the one generated by Alice) and private key of Dave. The need for using shared secret is to prevent the vulnerability where one channel operator who has nodes across both branches can use them to calculate the PM. Using shared secret also ensures that it is in fact D that has parsed them together. \n\n \n\nAdvantages of this proposal:\n\n*\tCommitment transactions between A & B, B & C, and C & D now carry only one HTLC instead of two\n\n*\tThis means lower fees in case of on-chain settlement\n*\tLower routing fees for Alice as Bob and Charlie would not get to charge for two routings\n*\tSince 483 is the max limit of the htlcs nodes can accepts, preventing duplication will allow more number of htlcs in flight.\n\n*\tIf each payment of Eric and Grace is below the htlc min B or C accepts, but together if it is higher, this route is now usable\n\n \n\nSome thoughts on if this proposal can be misused?\n\n*\tThe probability of transaction failures increases as now the transaction is dependent on 2/3 branches\n\n \n\nDeployment\n\nNot all nodes need to support this feature. For example, B, C, E, F,  and G does not even know that the payment arrived through branching. The nodes that can handle branching of payments can signal that using global features.\n\n \n\n \n\nUgam\n\n \n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org <mailto:Lightning-dev at lists.linuxfoundation.org> \nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n\n\n\n \n\n-- \n\nhttps://www.rene-pickhardt.de\n\n \n\nSkype: rene.pickhardt \n\n \n\nmobile: +49 (0)176 5762 3618   \n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/edb91a2b/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image001.png\nType: image/png\nSize: 7836 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/edb91a2b/attachment-0001.png>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-25T22:32:42",
                "message_text_only": "Good morning Rene and Ugam,\n\nUnder Scriptless Script (payment point / scalar) this is possible to do while retaining a form of proof-of-payment.\nHowever, note that the proof-of-payment scalar will be the sum of Eric and Grace proof-of-payment scalars.\nI am unsure if that provides undeniable proof that you paid Grace, or that you paid Eric.\n\nGiven payment points / scalars `E`/`e` from Eric and `H`/`h` from Grace, we can show:\n\n   A = E + H\n   a = e + h ; purportedly\n   A = a * G\n\nI am uncertain if there is a form of key cancellation possible here, wherein Grace denies proof-of-payment by claiming that Eric does not in fact exist and was created by the payer to cancel the payment point of Grace.\n\nAnother solution would be to route through Eric and leave Eric with a higher-than-normal fee (the usual spontaneous payment I prefer), which retains an undeniable proof-of-payment of Grace.\nEric would not provide proof-of-payment, but in this scenario given it seems, it is a \"tip\" and the actual payment is to the restauranteur Grace.\n\nIn any case, this is effectively simply creation of fork points and join points along a multipart path.\nThat the payment does not later join is merely a detail, especially once we get to \"high\" AMP (which requires payment points / scalars).\nWe decided at previous dev summit not to implement this due to complexity-of-implementation for payers, as well as how to resolve when one branch fails while the other branch claims the payment.\n\nRegards,\nZmnSCPxj\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Tuesday, June 25, 2019 7:32 PM, Ren\u00e9 Pickhardt via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n> Hey Ugam,\u00a0\n>\n> I like the very clearly communicated idea and the fact that we can do crazy stuff with the filler of the onions. I have two concerns / questions:\u00a0\n>\n> 1.) In pathfinding we actually try to make payments smaller (like moving to AMP) instead of combining payments. I think it was shown several times that the probability of finding a path (successful route) decreases with larger amounts. So saving fees might actually not be the metric that we are trying to optimize.\n> 2.) Am I correct that\u00a0this proposal would only work with the spontaneous payment scenario as the payment hashes of Eric and Grace could not just be added up as easy as the preimages can to get the overall payment hash for Alice? So in that sense on the invoice based system your proposal is not working and we don't have a proof of payment as Alice already knows the preimages? Could one resolve this in the world of scriptless scripts or when changing to secret / curve point based preimages based on the discrete log?\n>\n> best Rene\u00a0\n>\n> On Tue, Jun 25, 2019 at 7:07 AM Ugam Kamat <ugamkamat1 at gmail.com> wrote:\n>\n> > Hey guys,\n> >\n> > I\u2019m kind of new to this mailing list, so let me know if this has been proposed previously. While reading Olaoluwa Osuntokun\u2019s Spontaneous Payment proposal, I came up with the idea of simultaneous payments to multiple parties using the same partial route. In other words, say Alice, Bob, Charlie, Dave and Eric have channel opened with one another, and say Dave also has channel with Frank who has channel with Grace. Now, Alice is at a restaurant and wants to pay the bill amount to Eric (the restaurant owner) and a tip to Grace (who was her waiter). In the current scenario, Alice would have to send two payments A->B->C->D->E and A->B->C->D->F->G. However, if we repurpose the onion blob in the same way as is needed for Spontaneous Payments, we can create a scenario where there is no path duplication. Dave would split the payments, one to Eric and other going to Grace through Frank. The preimage PM used in commitments A->B, B->C and C->D will be a function of pre-images P1 of D->E and P2 of D->F and F->G such that PM = f(P1, P2).\n> >\n> > Proposal can be implemented by repurposing the onion in similar fashion as Spontaneous Payments with slight modification\n> >\n> > This proposal works in similar fashion to Spontaneous Payment proposal, by packing in additional data in the unused hops. For B and C the onion blob will be identical to other lightning payments. When D parses the onion, the 4 MSB of the realm will tell D how much data can be extracted. This data will encode the hashes of the pre-images that would be used for commitment transaction towards Eric and other towards Frank.\u00a0 For simplicity and privacy, I propose using 2 onion blobs for the data. So the payload can be 64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are packed, so we have 96 bytes for the payload, meaning we can pack a maximum of 3 hashes for 3 route payments from D. Now D will split the onion (18 hops as it has used the first two for bifurcation data) into number of routes. In the above case it will be 9 hops each. Now these two onions are similar to other lightning payments. The first hop tells D the short-channel id, amount to forward, CLTV and the padding. Since, the preimage is 32 bytes, we can pack that in one single hop that is received by the final party. This leaves the remaining 7 hops can be used for routing. Below figure depicts the onion split in terms of how A will create it. D will add the filler to make each onion have 20 hops. Onion data is encoded in the same order in which the payment hashes are packed in the bifurcation data for D.\n> >\n> > Calculating the preimages\n> >\n> > Eric and Grace will parse the onion and use the pre-images for settlement. Let P1 represent the pre-images of D->E and P2 of D->F and F->G. When the pre-images arrive at node D, it will combine them such that PM = f(P1, P2). The easiest way for both A and D to calculate that will be PM = SHA256(P1 || P2 || ss_d). Where || represents concatenation and ss_d is the shared secret created using the ephemeral public key of sender (the one generated by Alice) and private key of Dave. The need for using shared secret is to prevent the vulnerability where one channel operator who has nodes across both branches can use them to calculate the PM. Using shared secret also ensures that it is in fact D that has parsed them together.\n> >\n> > Advantages of this proposal:\n> >\n> > -   Commitment transactions between A & B, B & C, and C & D now carry only one HTLC instead of two\n> >\n> > -   This means lower fees in case of on-chain settlement\n> > -   Lower routing fees for Alice as Bob and Charlie would not get to charge for two routings\n> > -   Since 483 is the max limit of the htlcs nodes can accepts, preventing duplication will allow more number of htlcs in flight.\n> >\n> > -   If each payment of Eric and Grace is below the htlc min B or C accepts, but together if it is higher, this route is now usable\n> >\n> > Some thoughts on if this proposal can be misused?\n> >\n> > -   The probability of transaction failures increases as now the transaction is dependent on 2/3 branches\n> >\n> > Deployment\n> >\n> > Not all nodes need to support this feature. For example, B, C, E, F, \u00a0and G does not even know that the payment arrived through branching. The nodes that can handle branching of payments can signal that using global features.\n> >\n> > Ugam\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\u00a0\n>\n> mobile: +49 (0)176 5762 3618"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-25T23:04:54",
                "message_text_only": "Good morning Ugam,\n\n\n> In any case, this is effectively simply creation of fork points and join points along a multipart path.\n> That the payment does not later join is merely a detail, especially once we get to \"high\" AMP (which requires payment points / scalars).\n> We decided at previous dev summit not to implement this due to complexity-of-implementation for payers, as well as how to resolve when one branch fails while the other branch claims the payment.\n\n\nOn reflection, that there is no later join means that this scheme allows attack.\n\nWe have two choices:\n\n1. Both forked branches have to succeed in order for the fork node to claim its incoming payment.\n2. Either forked branch can succeed and the fork node can claim its incoming payment.\n\nIf we go with 1:\n\n* Fork nodes can be attacked by routing a self-payment through a fork node, with the other branch going nowhere (give it an unuseable preimage).\n  Claim the branch that goes to yourself, then wait for your outgoing payment to lapse.\n  The fork node is forced to pay one branch but is unable to claim its incoming payment.\n  Attacker earns free money.\n\nIf we go with 2:\n\n* Fork nodes can attack opportunistically, by only paying out to the smaller-valued branch.\n  Once the smaller-valued branch succeeds, the fork node can claim its incoming payment and forget about the other branch of the payment.\n* This is the choice made for multipart payments.\n  However, note that in multipart, there is always a later join (most likely at the ultimate, *single* destination).\n  The join will not succeed unless both incoming payments arrive, so fork nodes cannot perform this attack opportunistically.\n\nA plausible fix for your scheme would be to take choice 2 (either branch succeeding lets fork node claim incoming payment).\nThen Eric and Grace need to cooperate and only take incoming payment if both of them receive incoming payments.\nThis implies Eric and Grace must trust each other to coordinate.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-26T07:47:12",
                "message_text_only": "Hey ZmnSCPxj, \n\nReally appreciate your efforts in going through the proposal in depth. The two choices you mentioned for the proposal are a really fair analysis of how an attack can be launched on such forked away payments. In the current scheme, it seems it will create problems rather than solve it. I'll try to do some more work and see if I can come up with a more solid way in order to achieve this. Thanks again.\n\nUgam\n\n-----Original Message-----\nFrom: ZmnSCPxj <ZmnSCPxj at protonmail.com> \nSent: Wednesday, June 26, 2019 4:35 AM\nTo: ZmnSCPxj <ZmnSCPxj at protonmail.com>\nCc: Ren\u00e9 Pickhardt <r.pickhardt at googlemail.com>; Ugam Kamat <ugamkamat1 at gmail.com>; lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] [PROPOSAL]: FAST - Forked Away Simultaneous Transactions\n\nGood morning Ugam,\n\n\n> In any case, this is effectively simply creation of fork points and join points along a multipart path.\n> That the payment does not later join is merely a detail, especially once we get to \"high\" AMP (which requires payment points / scalars).\n> We decided at previous dev summit not to implement this due to complexity-of-implementation for payers, as well as how to resolve when one branch fails while the other branch claims the payment.\n\n\nOn reflection, that there is no later join means that this scheme allows attack.\n\nWe have two choices:\n\n1. Both forked branches have to succeed in order for the fork node to claim its incoming payment.\n2. Either forked branch can succeed and the fork node can claim its incoming payment.\n\nIf we go with 1:\n\n* Fork nodes can be attacked by routing a self-payment through a fork node, with the other branch going nowhere (give it an unuseable preimage).\n  Claim the branch that goes to yourself, then wait for your outgoing payment to lapse.\n  The fork node is forced to pay one branch but is unable to claim its incoming payment.\n  Attacker earns free money.\n\nIf we go with 2:\n\n* Fork nodes can attack opportunistically, by only paying out to the smaller-valued branch.\n  Once the smaller-valued branch succeeds, the fork node can claim its incoming payment and forget about the other branch of the payment.\n* This is the choice made for multipart payments.\n  However, note that in multipart, there is always a later join (most likely at the ultimate, *single* destination).\n  The join will not succeed unless both incoming payments arrive, so fork nodes cannot perform this attack opportunistically.\n\nA plausible fix for your scheme would be to take choice 2 (either branch succeeding lets fork node claim incoming payment).\nThen Eric and Grace need to cooperate and only take incoming payment if both of them receive incoming payments.\nThis implies Eric and Grace must trust each other to coordinate.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2019-06-28T17:38:47",
                "message_text_only": "Hi Ugam,\n\nI just wanted to quickly note that the current proposal [1] (implemented\nhere [2]) is to give up on the fixed 65 byte frames altogether and allow\nvariable payloads (reclaiming what previously was padding in the hop\npayloads). Given the low diameter of the network, this gives us a lot of\nfreedom to put additional payloads in the onion :-)\n\nCheers,\nChristian\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/619\n[2] https://github.com/ElementsProject/lightning/pull/2689\n\nOn Tue, Jun 25, 2019 at 1:07 PM Ugam Kamat <ugamkamat1 at gmail.com> wrote:\n\n> Hey guys,\n>\n>\n>\n> I\u2019m kind of new to this mailing list, so let me know if this has been\n> proposed previously. While reading Olaoluwa Osuntokun\u2019s Spontaneous\n> Payment proposal, I came up with the idea of simultaneous payments to\n> multiple parties using the same partial route. In other words, say Alice,\n> Bob, Charlie, Dave and Eric have channel opened with one another, and say\n> Dave also has channel with Frank who has channel with Grace. Now, Alice is\n> at a restaurant and wants to pay the bill amount to Eric (the restaurant\n> owner) and a tip to Grace (who was her waiter). In the current scenario,\n> Alice would have to send two payments A->B->C->D->E and A->B->C->D->F->G.\n> However, if we repurpose the onion blob\n> <https://github.com/ElementsProject/lightning/pull/2363> in the same way\n> as is needed for Spontaneous Payments, we can create a scenario where there\n> is no path duplication. Dave would split the payments, one to Eric and\n> other going to Grace through Frank. The preimage PM used in commitments\n> A->B, B->C and C->D will be a function of pre-images P1 of D->E and P2 of\n> D->F and F->G such that PM = f(P1, P2).\n>\n>\n>\n> *Proposal can be implemented by repurposing the onion in similar fashion\n> as Spontaneous Payments with slight modification*\n>\n> This proposal works in similar fashion to Spontaneous Payment proposal, by\n> packing in additional data in the unused hops. For B and C the onion blob\n> will be identical to other lightning payments. When D parses the onion, the\n> 4 MSB of the realm will tell D how much data can be extracted. This data\n> will encode the hashes of the pre-images that would be used for commitment\n> transaction towards Eric and other towards Frank.  For simplicity and\n> privacy, I propose using 2 onion blobs for the data. So the payload can be\n> 64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are\n> packed, so we have 96 bytes for the payload, meaning we can pack a maximum\n> of 3 hashes for 3 route payments from D. Now D will split the onion (18\n> hops as it has used the first two for bifurcation data) into number of\n> routes. In the above case it will be 9 hops each. Now these two onions are\n> similar to other lightning payments. The first hop tells D the\n> short-channel id, amount to forward, CLTV and the padding. Since, the\n> preimage is 32 bytes, we can pack that in one single hop that is received\n> by the final party. This leaves the remaining 7 hops can be used for\n> routing. Below figure depicts the onion split in terms of how A will create\n> it. D will add the filler to make each onion have 20 hops. Onion data is\n> encoded in the same order in which the payment hashes are packed in the\n> bifurcation data for D.\n>\n>\n>\n> *Calculating the preimages*\n>\n> Eric and Grace will parse the onion and use the pre-images for settlement.\n> Let P1 represent the pre-images of D->E and P2 of D->F and F->G. When the\n> pre-images arrive at node D, it will combine them such that PM = f(P1, P2).\n> The easiest way for both A and D to calculate that will be PM = SHA256(P1\n> || P2 || ss_d). Where || represents concatenation and ss_d is the shared\n> secret created using the ephemeral public key of sender (the one generated\n> by Alice) and private key of Dave. The need for using shared secret is to\n> prevent the vulnerability where one channel operator who has nodes across\n> both branches can use them to calculate the PM. Using shared secret also\n> ensures that it is in fact D that has parsed them together.\n>\n>\n>\n> *Advantages of this proposal:*\n>\n>    - Commitment transactions between A & B, B & C, and C & D now carry\n>    only one HTLC instead of two\n>       - This means lower fees in case of on-chain settlement\n>       - Lower routing fees for Alice as Bob and Charlie would not get to\n>       charge for two routings\n>       - Since 483 is the max limit of the htlcs nodes can accepts,\n>       preventing duplication will allow more number of htlcs in flight.\n>    - If each payment of Eric and Grace is below the htlc min B or C\n>    accepts, but together if it is higher, this route is now usable\n>\n>\n>\n> *Some thoughts on if this proposal can be misused?*\n>\n>    - The probability of transaction failures increases as now the\n>    transaction is dependent on 2/3 branches\n>\n>\n>\n> *Deployment*\n>\n> Not all nodes need to support this feature. For example, B, C, E, F,  and\n> G does not even know that the payment arrived through branching. The nodes\n> that can handle branching of payments can signal that using global features.\n>\n>\n>\n>\n>\n> Ugam\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190628/6b06c3d0/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image002.png\nType: image/png\nSize: 7836 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190628/6b06c3d0/attachment.png>"
            },
            {
                "author": "Ugam Kamat",
                "date": "2019-06-29T06:50:07",
                "message_text_only": "Thanks Christian for the references! As ZmnSCPxj pointed out, there was a loophole in my proposal that could potentially lead to DoS and failure attacks in the channels. These references should help me in working my proposal to circumvent such attacks. Have a great weekend.\n\n \n\nUgam\n\n \n\nFrom: Christian Decker <decker.christian at gmail.com> \nSent: Friday, June 28, 2019 11:09 PM\nTo: Ugam Kamat <ugamkamat1 at gmail.com>\nCc: lightning-dev <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] [PROPOSAL]: FAST - Forked Away Simultaneous Transactions\n\n \n\nHi Ugam,\n\n \n\nI just wanted to quickly note that the current proposal [1] (implemented here [2]) is to give up on the fixed 65 byte frames altogether and allow variable payloads (reclaiming what previously was padding in the hop payloads). Given the low diameter of the network, this gives us a lot of freedom to put additional payloads in the onion :-)\n\n \n\nCheers,\n\nChristian\n\n \n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/619\n\n[2] https://github.com/ElementsProject/lightning/pull/2689\n\n \n\nOn Tue, Jun 25, 2019 at 1:07 PM Ugam Kamat <ugamkamat1 at gmail.com <mailto:ugamkamat1 at gmail.com> > wrote:\n\nHey guys, \n\n \n\nI\u2019m kind of new to this mailing list, so let me know if this has been proposed previously. While reading Olaoluwa Osuntokun\u2019s Spontaneous Payment proposal, I came up with the idea of simultaneous payments to multiple parties using the same partial route. In other words, say Alice, Bob, Charlie, Dave and Eric have channel opened with one another, and say Dave also has channel with Frank who has channel with Grace. Now, Alice is at a restaurant and wants to pay the bill amount to Eric (the restaurant owner) and a tip to Grace (who was her waiter). In the current scenario, Alice would have to send two payments A->B->C->D->E and A->B->C->D->F->G. However, if we repurpose the onion blob <https://github.com/ElementsProject/lightning/pull/2363>  in the same way as is needed for Spontaneous Payments, we can create a scenario where there is no path duplication. Dave would split the payments, one to Eric and other going to Grace through Frank. The preimage PM used in commitments A->B, B->C and C->D will be a function of pre-images P1 of D->E and P2 of D->F and F->G such that PM = f(P1, P2).\n\n \n\nProposal can be implemented by repurposing the onion in similar fashion as Spontaneous Payments with slight modification\n\nThis proposal works in similar fashion to Spontaneous Payment proposal, by packing in additional data in the unused hops. For B and C the onion blob will be identical to other lightning payments. When D parses the onion, the 4 MSB of the realm will tell D how much data can be extracted. This data will encode the hashes of the pre-images that would be used for commitment transaction towards Eric and other towards Frank.  For simplicity and privacy, I propose using 2 onion blobs for the data. So the payload can be 64 + 33 bytes = 97 bytes. The first byte would indicate how many hashes are packed, so we have 96 bytes for the payload, meaning we can pack a maximum of 3 hashes for 3 route payments from D. Now D will split the onion (18 hops as it has used the first two for bifurcation data) into number of routes. In the above case it will be 9 hops each. Now these two onions are similar to other lightning payments. The first hop tells D the short-channel id, amount to forward, CLTV and the padding. Since, the preimage is 32 bytes, we can pack that in one single hop that is received by the final party. This leaves the remaining 7 hops can be used for routing. Below figure depicts the onion split in terms of how A will create it. D will add the filler to make each onion have 20 hops. Onion data is encoded in the same order in which the payment hashes are packed in the bifurcation data for D.\n\n\n\n \n\nCalculating the preimages\n\nEric and Grace will parse the onion and use the pre-images for settlement. Let P1 represent the pre-images of D->E and P2 of D->F and F->G. When the pre-images arrive at node D, it will combine them such that PM = f(P1, P2). The easiest way for both A and D to calculate that will be PM = SHA256(P1 || P2 || ss_d). Where || represents concatenation and ss_d is the shared secret created using the ephemeral public key of sender (the one generated by Alice) and private key of Dave. The need for using shared secret is to prevent the vulnerability where one channel operator who has nodes across both branches can use them to calculate the PM. Using shared secret also ensures that it is in fact D that has parsed them together. \n\n \n\nAdvantages of this proposal:\n\n*\tCommitment transactions between A & B, B & C, and C & D now carry only one HTLC instead of two\n\n*\tThis means lower fees in case of on-chain settlement\n*\tLower routing fees for Alice as Bob and Charlie would not get to charge for two routings\n*\tSince 483 is the max limit of the htlcs nodes can accepts, preventing duplication will allow more number of htlcs in flight.\n\n*\tIf each payment of Eric and Grace is below the htlc min B or C accepts, but together if it is higher, this route is now usable\n\n \n\nSome thoughts on if this proposal can be misused?\n\n*\tThe probability of transaction failures increases as now the transaction is dependent on 2/3 branches\n\n \n\nDeployment\n\nNot all nodes need to support this feature. For example, B, C, E, F,  and G does not even know that the payment arrived through branching. The nodes that can handle branching of payments can signal that using global features.\n\n \n\n \n\nUgam\n\n \n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org <mailto:Lightning-dev at lists.linuxfoundation.org> \nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190629/1e2bb26f/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image001.png\nType: image/png\nSize: 7836 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190629/1e2bb26f/attachment-0001.png>"
            }
        ],
        "thread_summary": {
            "title": ": FAST - Forked Away Simultaneous Transactions",
            "categories": [
                "Lightning-dev",
                "PROPOSAL"
            ],
            "authors": [
                "Christian Decker",
                "Ren\u00e9 Pickhardt",
                "ZmnSCPxj",
                "Ugam Kamat"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 43278
        }
    },
    {
        "title": "[Lightning-dev] Proposal: Lightning Pre-Image Encryption Standard",
        "thread_messages": [
            {
                "author": "Nadav Kohen",
                "date": "2019-06-25T16:54:23",
                "message_text_only": "Hi all,\n\n\nThere are many applications that sell some form of data to users (e.g. a\nblog post, a game, live data, etc.) monetizing with Lightning. This data\ntransfer can (and often should) be made atomic with the payment for that\ndata using the payment pre-image. This basically entails responding to any\nrequest for data with an invoice and data that is encrypted with that\ninvoice's payment pre-image; thus ensuring that the user gets the data if\nand only if they successfully pay that invoice over the lightning network.\nThis scheme is already in use in real applications and will likely be\nfurther adopted as more lapps emerge. It would be beneficial to have an\nindustry standard that would allow for the creation of uniform libraries\nfor standard ln-encryption and ln-decryption.\n\nWe propose the use of AES encryption in CFB mode with no padding to\nplaintext. AES encryption is a widely used standard that has libraries\navailable for most platforms and languages. CFB mode allows the encryption\nof arbitrary sized plaintexts, allowing us to avoid any logic for\npadding/unpadding. Note that with AES in CFB mode you need to provide an\ninitialization vector (IV), and this IV must be random for every encrypted\nplaintext.\n\nA data provider should respond to requests for data over a secure channel\n(e.g. HTTPS) with the requested data encrypted by the payment pre-image\nusing AES in CFB mode. Encrypting with the pre-image ensures that the user\nonly receives the data they pay for and sending over a secure channel\nensures no one else who knows the pre-image receives the data.\n\nWhen encrypting with the preimage, any pre-image that is 16, 24 or 32 bytes\nwill work.\n\nAfter encrypting the desired data with the payment pre-image, serialize the\nencrypted data by prepending the IV to the encrypted data, and then convert\nthe sequence of bytes to a base64 string. This final base64-encoded string\ncan be sent over the wire to the user (securly). Since the IV is a\nfixed-length 16 byte prefix, deserializing the base64 string is simply a\nmatter of converting the base64 string to a sequence of bytes, setting the\nIV to the first 16 bytes and the ciphertext to the rest.\n\nOptimizations:\n\nOnce the payment has been received by the data provider, they may offer the\npayment preimage directly to the data recipient if there is a communication\nchannel to the user (say over a websocket). The data provider can also\nsimply make the payment pre-image publicly available, e.g. via a public\nAPI. This is done to provide for a better user experience by reducing\nlatency as well as reducing the amount of communication a lapp client must\nhave with a lightning node.\n\nReference implementations:\n\n   -\n\n   JavaScript, using the Crypto-JS library:\n   https://gist.github.com/torkelrogstad/4611d73567cdcbc40d1da144169c9b03\n   -\n\n   Python, using the Pycrypto library:\n   https://gist.github.com/torkelrogstad/9f57c9ec2f14322a9c1ce0a863f4ad50\n   -\n\n   Java/Scala:\n   https://github.com/torkelrogstad/bitcoin-s/blob/21f69158de361349a3ef1abe6f94f042af144ea9/core/src/main/scala/org/bitcoins/core/crypto/AesCrypt.scala\n\n\nAcknowledgments:\n\n   -\n\n   Thank you to Alex Bosworth for sharing this idea with us and having a\n   working implementation of this scheme at yalls.org <http://www.yalls.org>\n   -\n\n   Thank you to Torkel Rogstad for the encryption details and reference\n   implementations\n\n\nBest,\nNadav\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/91bd241a/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-25T22:39:54",
                "message_text_only": "Good morning Nadav,\n\nI have had a similar idea (although without any details as to algorithm).\nHowever, it seems to me that the data seller is trusted to actually encrypt the data honestly (rather than, say, encrypting bytes from `/dev/random`).\n\nOn the other hand, this is a good way to obsolete many \"data-monetization\" permissioned blockchains such as datapace, thus I approve.\n(and datapace does not solve the \"really encrypting `/dev/random`\" problem anyway)\n\nRegards,\nZmnSCPXj\n\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, June 26, 2019 12:54 AM, Nadav Kohen <nadav at suredbits.com> wrote:\n\n> Hi all,\n>\n> There are many applications that sell some form of data to users (e.g. a blog post, a game, live data, etc.) monetizing with Lightning. This data transfer can (and often should) be made atomic with the payment for that data using the payment pre-image. This basically entails responding to any request for data with an invoice and data that is encrypted with that invoice's payment pre-image; thus ensuring that the user gets the data if and only if they successfully pay that invoice over the lightning network. This scheme is already in use in real applications and will likely be further adopted as more lapps emerge. It would be beneficial to have an industry standard that would allow for the creation of uniform libraries for standard ln-encryption and ln-decryption.\n>\n> We propose the use of AES encryption in CFB mode with no padding to plaintext. AES encryption is a widely used standard that has libraries available for most platforms and languages. CFB mode allows the encryption of arbitrary sized plaintexts, allowing us to avoid any logic for padding/unpadding. Note that with AES in CFB mode you need to provide an initialization vector (IV), and this IV must be random for every encrypted plaintext.\u00a0\n>\n> A data provider should respond to requests for data over a secure channel (e.g. HTTPS) with the requested data encrypted by the payment pre-image using AES in CFB mode. Encrypting with the pre-image ensures that the user only receives the data they pay for and sending over a secure channel ensures no one else who knows the pre-image receives the data.\n>\n> When encrypting with the preimage, any pre-image that is 16, 24 or 32 bytes will work.\u00a0\n>\n> After encrypting the desired data with the payment pre-image, serialize the encrypted data by prepending the IV to the encrypted data, and then convert the sequence of bytes to a base64 string. This final base64-encoded string can be sent over the wire to the user (securly). Since the IV is a fixed-length 16 byte prefix, deserializing the base64 string is simply a matter of converting the base64 string to a sequence of bytes, setting the IV to the first 16 bytes and the ciphertext to the rest.\u00a0\n>\n> Optimizations:\n>\n> Once the payment has been received by the data provider, they may offer the payment preimage directly to the data recipient if there is a communication channel to the user (say over a websocket). The data provider can also simply make the payment pre-image publicly available, e.g. via a public API. This is done to provide for a better user experience by reducing latency as well as reducing the amount of communication a lapp client must have with a lightning node.\n>\n> Reference implementations:\n>\n> -   JavaScript, using the Crypto-JS library: https://gist.github.com/torkelrogstad/4611d73567cdcbc40d1da144169c9b03\n>\n> -   Python, using the Pycrypto library: https://gist.github.com/torkelrogstad/9f57c9ec2f14322a9c1ce0a863f4ad50\n>\n> -   Java/Scala: https://github.com/torkelrogstad/bitcoin-s/blob/21f69158de361349a3ef1abe6f94f042af144ea9/core/src/main/scala/org/bitcoins/core/crypto/AesCrypt.scala\n>\n>\n> Acknowledgments:\n>\n> -   Thank you to Alex Bosworth for sharing this idea with us and having a working implementation of this scheme at yalls.org\n>\n> -   Thank you to Torkel Rogstad for the encryption details and reference implementations\n>\n>\n> Best,\n> Nadav"
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-26T04:07:50",
                "message_text_only": "Hi Nadav,\n\nNice proposal. There are two suggestions that came to my mind:\n\n1. In your proposal the encrypted data doesn't have any authentication. I\nwould suggest to use authenticated encryption and add HMAC-SHA256 at the\nend of the encrypted data (encrypt-then-mac). Then even if insecure\nconnection is used to pass the encrypted data it cannot be changed by the\nattacker.\n\n2. Any node on the route of the payment knows the preimage and can decrypt\nthe data. It would be nice to tune the protocol in a way that only the\nbuyer can decrypt the data. For example we could use something like this:\n\nLet's say Bob wants to buy data from Sally.\n- Bob generates a random private key `b` and corresponding public key `B`.\nThen he tells Sally what data he is interested in and also tells his public\nkey `B`\n- Sally generates a random private key `s` and corresponding public key\n`S`. She calculates a secret key `k=ECDH(B, S)`, encrypts the data with it\nand sends encrypted (and authenticated) data to Bob.\n- Sally generates the invoice with the preimage `S` (i.e. x-coordinate of\nthis point to make it 32-bytes long)\n- When Bob pays this invoice he learns the value of the public key `S` and\ncan use his private key `b` to derive the encryption key `k=ECDH(B, S)`.\nBob can decrypt the data now.\n- No one else learns the key.\n\nCheers,\nStepan.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/e5363cb8/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-26T05:18:26",
                "message_text_only": "Good morning Stepan, and Nadav,\n\nBoth additions seem good idea to me.\n\n> - Sally generates the invoice with the preimage `S` (i.e. x-coordinate of this point to make it 32-bytes long)\n\nDoes this require Bob to attempt both positive and negative sign for the y-coordinate?\nAlternately we can force Sally to always use a scalar such that generated point has a fixed sign (or some other property to derive the sign of the missing coordinate).\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-26T05:41:59",
                "message_text_only": "Hi ZmnSCPxj,\n\n> Does this require Bob to attempt both positive and negative sign for the\ny-coordinate?\n> Alternately we can force Sally to always use a scalar such that generated\npoint has a fixed sign (or some other property to derive the sign of the\nmissing coordinate).\n\nThe best would be if Sally uses the point with a fixed sign, then Bob\ndoesn't need to try twice and can start decrypting data from stream (for\nexample if it's a DRM key for a movie).\nSimilar approach is used for R-encoding in Schnorr signatures, so we could\nuse the same convention here.\n\n\nOn Tue, Jun 25, 2019 at 10:18 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Stepan, and Nadav,\n>\n> Both additions seem good idea to me.\n>\n> > - Sally generates the invoice with the preimage `S` (i.e. x-coordinate\n> of this point to make it 32-bytes long)\n>\n> Does this require Bob to attempt both positive and negative sign for the\n> y-coordinate?\n> Alternately we can force Sally to always use a scalar such that generated\n> point has a fixed sign (or some other property to derive the sign of the\n> missing coordinate).\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/b95667f9/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-26T06:12:39",
                "message_text_only": "Thank you for your thought.\n\nAnother idea: would it be useful to split up large data (several megabytes long) and FEC-encode it in chunks (with each chunk having a separate MAC)?\n\nThat way even if some error occurs during transmission, it is possible to recover without re-downloading entire dataset.\nEspecially, since we need to decrypt first, before we can confirm the MAC: if the MAC fails for the chunk, it's better if we can use data from nearby chunks to recover, rather than download and re-decrypt again.\nOr is this over-engineering?\n\nRegards,\nZmnSCPxj\n\nSent with ProtonMail Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Wednesday, June 26, 2019 1:41 PM, Stepan Snigirev <snigirev.stepan at gmail.com> wrote:\n\n> Hi\u00a0ZmnSCPxj,\n>\n> > Does this require Bob to attempt both positive and negative sign for the y-coordinate?\n> > Alternately we can force Sally to always use a scalar such that generated point has a fixed sign (or some other property to derive the sign of the missing coordinate).\n>\n> The best would be if Sally uses the point with a fixed sign, then Bob doesn't need to try twice and can start decrypting data from stream (for example if it's a DRM key for a movie).\n> Similar approach is used for R-encoding in Schnorr signatures, so we could use the same convention here.\n>\n> On Tue, Jun 25, 2019 at 10:18 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Stepan, and Nadav,\n> >\n> > Both additions seem good idea to me.\n> >\n> > > - Sally generates the invoice with the preimage `S` (i.e. x-coordinate of this point to make it 32-bytes long)\n> >\n> > Does this require Bob to attempt both positive and negative sign for the y-coordinate?\n> > Alternately we can force Sally to always use a scalar such that generated point has a fixed sign (or some other property to derive the sign of the missing coordinate).\n> >\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Stepan Snigirev",
                "date": "2019-06-26T06:50:57",
                "message_text_only": "> Another idea: would it be useful to split up large data (several\nmegabytes long) and FEC-encode it in chunks (with each chunk having a\nseparate MAC)?\n\nI think it's a great idea. Ideally we want to do error correction and check\nMAC before decryption, so for large data it makes a lot of sense to split\nit into smaller chunks and MAC each of them. Then the receiver should use\nerror correction to deal with errors, check MAC of the chunk and *only\nthen* decrypt it. But it depends on the application and communication\nchannel, so I would leave these details to the app developers.\n\nP.S. It would be nice to have this proposal and other interesting ideas\nfrom the mailing list in some kind of guidelines for different lightning\nuse-cases, but I feel like BOLTs repo is the wrong place to put it. Could\nwe organize some kind of lightning-guidelines repo for lapp developers? I\nthink it would be very useful.\n\nRegards,\nStepan.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190625/a51ee1ba/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-26T09:36:04",
                "message_text_only": "Good morning Stepan,\n\n> But it depends on the application and communication channel, so I would leave these details to the app developers.\n\nI would mildly disagree, as I worry about proliferation of incompatible applications, or applications that can only work with specific wallets.\n\nStill, it can be argued that this is early times for such applications, and the extra creativity may be more important for exploring the space than a premature optimization of working on a single standard.\n\n>\n> P.S. It would be nice to have this proposal and other interesting ideas from the mailing list in some kind of guidelines for different lightning use-cases, but I feel like BOLTs repo is the wrong place to put it. Could we organize some kind of lightning-guidelines repo for lapp developers? I think it would be very useful.\n\nThis seems a good idea.\n\nPerhaps we can add Lightning Application Protocol Proposals (LAPP) repository somewhere.\nThis would be dependent on BOLT, but BOLT would not depend on LAPP.\n\nProbably the existing protocols like WebLN and Thor would be in scope for this.\n\n---\n\nOn the original topic:\n\nA concern I raised is the issue that data providers must be trusted to actually provide the data.\nUnfortunately, I cannot derive a good way for a data consumer to prove that the data given by a data provider is bogus.\nIt becomes an assertion and counter-assertion (the problem with reputation systems).\n\nAn escrow system might be useful, but requires us to have some way of integrating escrow with proof-of-payment.\n(and it seems we need to *really* switch to payment points / scalars to combine proof-of-payment with a lot of features... this is delayed by Bitcoin getting Schnorr, unless we want to step up now and use 2p-ECDSA today, then reimplement under Schnorr when Bitcoin gets it (my understanding is that Schnorr Scriptless Script has more security than 2p-ECDSA Scriptless Script, though I am not a mathist and cannot show this))\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2019-06-26T15:19:29",
                "message_text_only": "Hi ZmnSCPxj and Stepan,\n\nThanks for all the feedback!\n\nI think doing encrypt-then-mac on chunks of the data would be a great\naddition for users to be able to authenticate that they received the\nintended data.\n\n> Any node on the route of the payment knows the preimage and can decrypt\nthe data. It would be nice to tune the protocol in a way that only the\nbuyer can decrypt the data. For example we could use something like this:\n\nIs this not covered by sending over the pre-image encrypted data over a\nsecure channel such as HTTPS? If anyone along the route who learns the\npre-image does intercept the message with the encrypted data, that data\nwill already be encrypted for the intended recipient right?\n\n> Perhaps we can add Lightning Application Protocol Proposals (LAPP)\nrepository somewhere.\n\nI agree that it would be awesome if there was a good place to put these\nkinds of proposals on a git repository someplace!\n\nAnd finally in reply to all things about trusting the data provider, this\nproposal is intended for use cases in which a data provider is trusted (for\nexample, DLC oracle signatures). Of course it would be super interesting if\nthere was any way to do this with any kind of validation on the encrypted\ndata before payment.\n\nBest,\nNadav\n\nOn Wed, Jun 26, 2019 at 4:36 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Stepan,\n>\n> > But it depends on the application and communication channel, so I would\n> leave these details to the app developers.\n>\n> I would mildly disagree, as I worry about proliferation of incompatible\n> applications, or applications that can only work with specific wallets.\n>\n> Still, it can be argued that this is early times for such applications,\n> and the extra creativity may be more important for exploring the space than\n> a premature optimization of working on a single standard.\n>\n> >\n> > P.S. It would be nice to have this proposal and other interesting ideas\n> from the mailing list in some kind of guidelines for different lightning\n> use-cases, but I feel like BOLTs repo is the wrong place to put it. Could\n> we organize some kind of lightning-guidelines repo for lapp developers? I\n> think it would be very useful.\n>\n> This seems a good idea.\n>\n> Perhaps we can add Lightning Application Protocol Proposals (LAPP)\n> repository somewhere.\n> This would be dependent on BOLT, but BOLT would not depend on LAPP.\n>\n> Probably the existing protocols like WebLN and Thor would be in scope for\n> this.\n>\n> ---\n>\n> On the original topic:\n>\n> A concern I raised is the issue that data providers must be trusted to\n> actually provide the data.\n> Unfortunately, I cannot derive a good way for a data consumer to prove\n> that the data given by a data provider is bogus.\n> It becomes an assertion and counter-assertion (the problem with reputation\n> systems).\n>\n> An escrow system might be useful, but requires us to have some way of\n> integrating escrow with proof-of-payment.\n> (and it seems we need to *really* switch to payment points / scalars to\n> combine proof-of-payment with a lot of features... this is delayed by\n> Bitcoin getting Schnorr, unless we want to step up now and use 2p-ECDSA\n> today, then reimplement under Schnorr when Bitcoin gets it (my\n> understanding is that Schnorr Scriptless Script has more security than\n> 2p-ECDSA Scriptless Script, though I am not a mathist and cannot show this))\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190626/9b41edd8/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2019-06-26T23:55:35",
                "message_text_only": "Good morning Nadav et al.,\n\n> > Any node on the route of the payment knows the preimage and can decrypt the data. It would be nice to tune the protocol in a way that only the buyer can decrypt the data. For example we could use something like this:\n>\n> Is this not covered by sending over the pre-image encrypted data over a secure channel such as HTTPS? If anyone along the route who learns the pre-image does intercept the message with the encrypted data, that data will already be encrypted for the intended recipient right?\n\nTrue, but the added protection allows sending the option of sending data over a non-secure channel.\nIn particular, a secure channel like HTTPS would impose an encryption/decryption overhead, and then you will *also* encrypt/decrypt at the application layer i.e. you are encrypting twice.\nIf you have the choice of using an insecure channel, you could take that and only have the encrypt/decrypt overhead only for the preimage-encrypted data.\n\ni.e. with this, you have the option of sending over both secure and insecure channels.\nIt does not hinder use of secure channel, but enables use of insecure channel.\nPutting MAC inside the encryption would help ensure that we can detect data replacement over insecure channel, and use of shared secret ensures only intended recipient can decrypt.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Lightning Pre-Image Encryption Standard",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Nadav Kohen",
                "Stepan Snigirev",
                "ZmnSCPxj"
            ],
            "messages_count": 10,
            "total_messages_chars_count": 20761
        }
    },
    {
        "title": "[Lightning-dev] Proposal: Lightning Application Standards [LAS]",
        "thread_messages": [
            {
                "author": "Chris Stewart",
                "date": "2019-06-27T14:50:58",
                "message_text_only": "Hi all,\n\nWe recently proposed a standard for encrypting data with the pre-image that\nis being revealed over Lightning[1]. After talking with various folks in\nthe ecosystem the consesus seems to be it would be a good idea to create a\nrepository for organizing LAS (Lightning Application Standards)[2]. The\nhope here is that we can start building standards so that Lightning app\ndevelopers can design their LAPPs to be compatible with other LAPPs. This\nshould also make it easier for wallet developers to hook into different\nLAPPs with a standard.\n\nIf this idea gains momentum, I think LAS's should be kept separate from the\nBOLTs. BOLTs should define low level Lightning protocol where it is\n_imperative_ that Lightning implementations comply to the BOLT standards. I\nthink LAS's are more of \"suggestions\" to make it easier for everyone to\ncommunicate and interact with each other in a standardized way. This also\nencourages the idea of segregating \"backbone\" implementations of the\nLightning network with higher level wallet software. This makes it easier\nto distinguish what useful things library developers might want to support\nvs what BOLT compliant implementations need to support. Perhaps for\npragmatic reasons for now we would just reuse the current lightning-rfc\nrepo[3].\n\nIn my opinion, BOLT11 could be thought of as a LAS as it does not talk\nabout the actual Lightning protocol, but rather a canonical way to encode\ninformation about the protocol to end users (similar to bitcoin addresses).\n\n-Chris\n\n[1] -\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002035.html\n[2] -\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002046.html\n[3] - https://github.com/lightningnetwork/lightning-rfc/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20190627/ac1d8972/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposal: Lightning Application Standards ",
            "categories": [
                "Lightning-dev",
                "LAS"
            ],
            "authors": [
                "Chris Stewart"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1924
        }
    }
]