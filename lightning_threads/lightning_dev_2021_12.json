[
    {
        "title": "[Lightning-dev] A Mobile Lightning User Goes to Pay a Mobile Lightning User...",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-12-03T02:59:40",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> The Obvious (tm) solution here is PTLCs - just have the sender always add some random nonce * G to \n> the PTLC they're paying and send the recipient a random nonce in the onion. I'd generally suggest we \n> just go ahead and do this for every PTLC payment, cause why not?\n\nAFAICT we need to do this for decorrelation: each hop has a unique tweak\n(prob derived from the onion share secret).\n\nIn bolt12, we have the additional problem for the tipping case: each\ninvoice contains an amount, so you can't preprint amountless invoices.\n(This plugs a hole in bolt11 for this case, where you get a receipt but\nno amount!).\n\nHowever, I think the best case is a generic authorization mechanism:\n\n1. The offer contains a fallback node.\n2. Fallback either returns you an invoice signed by the node you expect, *or*\n   one signed by itself and an authorization from the node you expect.\n3. The authorization might be only for a particular offer, or amount, or\n   have an expiry.  *handwave*.\n\nThis lets the user choose the trust model they want.  The fallback node\nmay also provide an onion message notification service when the real\nnode comes back, to avoid polling.\n\nCheers,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2021-12-27T19:12:10",
                "message_text_only": "On 12/2/21 21:59, Rusty Russell wrote:\n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n> In bolt12, we have the additional problem for the tipping case: each\n> invoice contains an amount, so you can't preprint amountless invoices.\n> (This plugs a hole in bolt11 for this case, where you get a receipt but\n> no amount!).\n> \n> However, I think the best case is a generic authorization mechanism:\n> \n> 1. The offer contains a fallback node.\n> 2. Fallback either returns you an invoice signed by the node you expect, *or*\n>     one signed by itself and an authorization from the node you expect.\n> 3. The authorization might be only for a particular offer, or amount, or\n>     have an expiry.  *handwave*.\n> \n> This lets the user choose the trust model they want.  The fallback node\n> may also provide an onion message notification service when the real\n> node comes back, to avoid polling.\n\nMissed this mail, but, right, good point about amounts. Indeed, having cross-signing by the fallback \nnode seems like a good idea. For the tipping use-case, allowing a BOLT-12 response with no amount \nincluded under the signature seems fine (with a signed amount from the fallback node).\n\nMatt"
            }
        ],
        "thread_summary": {
            "title": "A Mobile Lightning User Goes to Pay a Mobile Lightning User...",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2410
        }
    },
    {
        "title": "[Lightning-dev] Pawn (chess piece) | Breaking bitcoin by playing chess",
        "thread_messages": [
            {
                "author": "Prayank",
                "date": "2021-12-04T04:36:02",
                "message_text_only": "Hello World,\n\nLink with what, why and how: https://gist.github.com/prayank23/22763f48199ed106e59801be43ad4efc\n\nTwo related things that I found: \n\n1.Koala Studio tried chess on LN in 2019 but shutdown in August 2019\n2.Etleneum still has chess but works differently\n\nPrimary goal of this project can be different and focus on testing Bitcoin transactions. Secondary goal is to have fun and contribute in increasing demand for block space. Maybe an app for developers to play chess, friendly competitions, learn and share new things. \n\nIf chess sounds boring it can be replaced with any 2 player game that works for such setup and can be played with patience over few hours/days.\n\nSpam? Sorry zero fee transactions do not work anymore. In fact, nothing below 1 sat/vbyte fee rate would work and all transactions will pay fees that are required long term. OP_RETURN is used by many projects and excluded from UTXO set. Let me know if something looks wrong. I won't be working on this as busy with another project and recently started contributing in Wasabi.\n\n\n-- \nPrayank\n\nA3B1 E430 2298 178F\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211204/b04a0d5c/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Pawn (chess piece) | Breaking bitcoin by playing chess",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Prayank"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1273
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Pawn (chess piece) | Breaking bitcoin by playing chess",
        "thread_messages": [
            {
                "author": "LORD HIS EXCELLENCY JAMES HRMH",
                "date": "2021-12-04T10:00:13",
                "message_text_only": "The frivolous use of block space - ie. to increase the demand for block space -  is not encouraged. Although it is possible you may write chess moves on a wrap of dollar bills and send them to your friends, nowhere that I know of has this been recorded in a ledger as a valid past time.\n\nKING JAMES HRMH\nGreat British Empire\n\nRegards,\nThe Australian\nLORD HIS EXCELLENCY JAMES HRMH (& HMRH)\nof Hougun Manor & Glencoe & British Empire\nMR. Damian A. James Williamson\nWills\n\net al.\n\n\nWilltech\nwww.willtech.com.au\nwww.go-overt.com\nduigco.org DUIGCO API\nand other projects\n\n\nm. 0487135719\nf. +61261470192\n\n\nThis email does not constitute a general advice. Please disregard this email if misdelivered.\n________________________________\n\nFrom: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Prayank via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\nSent: Saturday, 4 December 2021 3:36 PM\nTo: Lightning Dev <lightning-dev at lists.linuxfoundation.org>\nCc: Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\nSubject: [bitcoin-dev] Pawn (chess piece) | Breaking bitcoin by playing chess\n\nHello World,\n\nLink with what, why and how: https://gist.github.com/prayank23/22763f48199ed106e59801be43ad4efc\n\nTwo related things that I found:\n\n1.Koala Studio tried chess on LN in 2019 but shutdown in August 2019\n2.Etleneum still has chess but works differently\n\nPrimary goal of this project can be different and focus on testing Bitcoin transactions. Secondary goal is to have fun and contribute in increasing demand for block space. Maybe an app for developers to play chess, friendly competitions, learn and share new things.\n\nIf chess sounds boring it can be replaced with any 2 player game that works for such setup and can be played with patience over few hours/days.\n\nSpam? Sorry zero fee transactions do not work anymore. In fact, nothing below 1 sat/vbyte fee rate would work and all transactions will pay fees that are required long term. OP_RETURN is used by many projects and excluded from UTXO set. Let me know if something looks wrong. I won't be working on this as busy with another project and recently started contributing in Wasabi.\n\n\n--\nPrayank\n\nA3B1 E430 2298 178F\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211204/0a21b13b/attachment.html>"
            },
            {
                "author": "Prayank",
                "date": "2021-12-04T15:28:32",
                "message_text_only": "Can you share the email address to get approval or permission for this type of bitcoin transactions? i.e. opening and closing of LN channels or OP_RETURN. I will keep that in Cc next time.\n\nI can write chess moves on a dollar bill and send to my friends but it does not solve any of the problems. Bitcoin's blockchain or ledger is for transactions. As long as a transaction is valid, standard and paying fees nobody should have issues with what is being achieved with the transaction.\n\nThanks\n\n-- \nPrayank\n\nA3B1 E430 2298 178F\n\n\n\nDec 4, 2021, 15:30 by willtech at live.com.au:\n\n> The frivolous use of block space - ie. to increase the demand for block space -\u00a0 is not encouraged. Although it is possible you may write chess moves on a wrap of dollar bills and send them to your friends, nowhere that I know of has this been recorded in a ledger as a valid past time.\n>\n> KING JAMES HRMH \n> Great British Empire\n>\n> Regards,\n> The Australian\n> LORD HIS EXCELLENCY JAMES HRMH (& HMRH)\n> of Hougun Manor & Glencoe & British Empire\n> MR. Damian A. James Williamson\n> Wills\n>\n> et al.\n>\n> \u00a0\n> Willtech\n> www.willtech.com.au\n> www.go-overt.com\n> duigco.org DUIGCO API\n> and other projects\n> \u00a0\n>\n> m. 0487135719\n> f. +61261470192\n>\n>\n> This email does not constitute a general advice. Please disregard this email if misdelivered.\n>  \n>\n>\n> From:>  bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Prayank via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>\n>  \n> Sent:>  Saturday, 4 December 2021 3:36 PM\n>  > To:>  Lightning Dev <lightning-dev at lists.linuxfoundation.org>\n>  > Cc:>  Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>\n>  > Subject:>  [bitcoin-dev] Pawn (chess piece) | Breaking bitcoin by playing chess>  > \u00a0\n> Hello World,\n>\n> Link with what, why and how: https://gist.github.com/prayank23/22763f48199ed106e59801be43ad4efc\n>\n> Two related things that I found: \n>\n> 1.> Koala Studio tried chess on LN in 2019 but shutdown in August 2019\n> 2.Etleneum still has chess but works differently\n>\n> Primary goal of this project can be different and focus on testing Bitcoin transactions. Secondary goal is to have fun and contribute in increasing demand for block space. Maybe an app for developers to play chess, friendly competitions, learn and share new things. \n>\n> If chess sounds boring it can be replaced with any 2 player game that works for such setup and can be played with patience over few hours/days.\n>\n> Spam? Sorry zero fee transactions do not work anymore. In fact, nothing below 1 sat/vbyte fee rate would work and all transactions will pay fees that are required long term. OP_RETURN is used by many projects and excluded from UTXO set. Let me know if something looks wrong. I won't be working on this as busy with another project and recently started contributing in Wasabi.\n>\n>\n> -- \n> Prayank\n>\n> A3B1 E430 2298 178F\n>\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211204/0788929e/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Pawn (chess piece) | Breaking bitcoin by playing chess",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "LORD HIS EXCELLENCY JAMES HRMH",
                "Prayank"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5457
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Sending OP_RETURN via Bitcoin Lightning",
        "thread_messages": [
            {
                "author": "Karl",
                "date": "2021-12-06T10:20:55",
                "message_text_only": "Hi,\n\nI'm not a bitcoin developer.\n\nOn Mon, Dec 6, 2021, 5:05 AM H\u00e9ctor Jos\u00e9 C\u00e1rdenas Pacheco via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hello all,\n>\n> I\u2019ve been thinking about how OP_RETURN is being used to create and trade\n> NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was wondering\n> if it\u2019s possible to\n>\n\nDo you have a link to any of these protocols?\n\nmake transactions with this opcode via Lightning.\n>\n> More specific questions could be:\n>\n>    1. Can opcodes like OP_RETURN be inside a channel\u2019s opening or closing\n>    transaction?\n>    2. If so, could that OP_RETURN change hands within that channel or\n>    network of channels?\n>\n> OP_RETURNs do not have ownership according to the bitcoin network.  It is\nnot hard to define a protocol that associates an OP_RETURN with ownership,\nand ownership could then be transferred via lightning by sending associated\ncurrency via lightning.  Robustness improvements seem possible.\n\n\n>    1. If possible, could the OP_RETURN be divisible? Could one person\n>    send a piece of a OP_RETURN just like one can do right now on the primary\n>    ledger or would it need to maintain the OP_RETURN code intact?\n>\n> OP_RETURNs themselves do not have ownership, but you can define a protocol\nthat gives them divisible ownership, including via lightning.\n\nI\u2019m assuming that, if possible, this would need a protocol layer parallel\n> to Bitcoin/Lightning that stores and reads all Bitcoin transactions and the\n> ones which involve the node's channels as well as the ones with the\n> OP_RETURN, just like CounterParty does right now with the primary ledger.\n>\n> Thank in advance.\n> \u2014\u2014\n>\n> *H\u00e9ctor C\u00e1rdenas*@hcarpach\n>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/f3253ec4/attachment.html>"
            },
            {
                "author": "Martin Habov\u0161tiak",
                "date": "2021-12-06T11:31:29",
                "message_text_only": "I recommend you researching RGB: https://rgb-org.github.io/\n\nOn Mon, Dec 6, 2021, 11:21 Karl <gmkarl at gmail.com> wrote:\n\n> Hi,\n>\n> I'm not a bitcoin developer.\n>\n> On Mon, Dec 6, 2021, 5:05 AM H\u00e9ctor Jos\u00e9 C\u00e1rdenas Pacheco via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello all,\n>>\n>> I\u2019ve been thinking about how OP_RETURN is being used to create and trade\n>> NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was wondering\n>> if it\u2019s possible to\n>>\n>\n> Do you have a link to any of these protocols?\n>\n> make transactions with this opcode via Lightning.\n>>\n>> More specific questions could be:\n>>\n>>    1. Can opcodes like OP_RETURN be inside a channel\u2019s opening or\n>>    closing transaction?\n>>    2. If so, could that OP_RETURN change hands within that channel or\n>>    network of channels?\n>>\n>> OP_RETURNs do not have ownership according to the bitcoin network.  It is\n> not hard to define a protocol that associates an OP_RETURN with ownership,\n> and ownership could then be transferred via lightning by sending associated\n> currency via lightning.  Robustness improvements seem possible.\n>\n>\n>>    1. If possible, could the OP_RETURN be divisible? Could one person\n>>    send a piece of a OP_RETURN just like one can do right now on the primary\n>>    ledger or would it need to maintain the OP_RETURN code intact?\n>>\n>> OP_RETURNs themselves do not have ownership, but you can define a\n> protocol that gives them divisible ownership, including via lightning.\n>\n> I\u2019m assuming that, if possible, this would need a protocol layer parallel\n>> to Bitcoin/Lightning that stores and reads all Bitcoin transactions and the\n>> ones which involve the node's channels as well as the ones with the\n>> OP_RETURN, just like CounterParty does right now with the primary ledger.\n>>\n>> Thank in advance.\n>> \u2014\u2014\n>>\n>> *H\u00e9ctor C\u00e1rdenas*@hcarpach\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/d86e56cb/attachment.html>"
            },
            {
                "author": "Christian Moss",
                "date": "2021-12-06T16:35:19",
                "message_text_only": "As far as I understand it, RGB doesn't scale NFTs as each\ntransaction to transfer ownership of an NFT would require an onchain\ntransaction\n\nOn Mon, Dec 6, 2021 at 3:44 PM Martin Habov\u0161tiak via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> I recommend you researching RGB: https://rgb-org.github.io/\n>\n> On Mon, Dec 6, 2021, 11:21 Karl <gmkarl at gmail.com> wrote:\n>\n>> Hi,\n>>\n>> I'm not a bitcoin developer.\n>>\n>> On Mon, Dec 6, 2021, 5:05 AM H\u00e9ctor Jos\u00e9 C\u00e1rdenas Pacheco via bitcoin-dev\n>> <bitcoin-dev at lists.linuxfoundation.org> wrote:\n>>\n>>> Hello all,\n>>>\n>>> I\u2019ve been thinking about how OP_RETURN is being used to create and trade\n>>> NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was wondering\n>>> if it\u2019s possible to\n>>>\n>>\n>> Do you have a link to any of these protocols?\n>>\n>> make transactions with this opcode via Lightning.\n>>>\n>>> More specific questions could be:\n>>>\n>>>    1. Can opcodes like OP_RETURN be inside a channel\u2019s opening or\n>>>    closing transaction?\n>>>    2. If so, could that OP_RETURN change hands within that channel or\n>>>    network of channels?\n>>>\n>>> OP_RETURNs do not have ownership according to the bitcoin network.  It\n>> is not hard to define a protocol that associates an OP_RETURN with\n>> ownership, and ownership could then be transferred via lightning by sending\n>> associated currency via lightning.  Robustness improvements seem possible.\n>>\n>>\n>>>    1. If possible, could the OP_RETURN be divisible? Could one person\n>>>    send a piece of a OP_RETURN just like one can do right now on the primary\n>>>    ledger or would it need to maintain the OP_RETURN code intact?\n>>>\n>>> OP_RETURNs themselves do not have ownership, but you can define a\n>> protocol that gives them divisible ownership, including via lightning.\n>>\n>> I\u2019m assuming that, if possible, this would need a protocol layer parallel\n>>> to Bitcoin/Lightning that stores and reads all Bitcoin transactions and the\n>>> ones which involve the node's channels as well as the ones with the\n>>> OP_RETURN, just like CounterParty does right now with the primary ledger.\n>>>\n>>> Thank in advance.\n>>> \u2014\u2014\n>>>\n>>> *H\u00e9ctor C\u00e1rdenas*@hcarpach\n>>>\n>>> _______________________________________________\n>>> bitcoin-dev mailing list\n>>> bitcoin-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/c62a093a/attachment-0001.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2021-12-09T09:12:59",
                "message_text_only": "On Mon, Dec 06, 2021 at 04:35:19PM +0000, Christian Moss via bitcoin-dev wrote:\n> As far as I understand it, RGB doesn't scale NFTs as each\n> transaction to transfer ownership of an NFT would require an onchain\n> transaction\n\nRGB intends to scale NFTs and similar things in the future via scalable\nsingle-use-seals: https://petertodd.org/2017/scalable-single-use-seal-asset-transfer\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/468e4620/attachment.sig>"
            },
            {
                "author": "Christian Moss",
                "date": "2021-12-09T09:49:11",
                "message_text_only": "pete at petertodd.org, so single use seals require an onchain transaction to\npost the proof of publication to the ledger (assuming bitcoin is used as\nthe ledger) when an asset is transferred, but it can scale because you can\nbatch many proofs (transfer of ownerships) into a merkle tree and just add\nthe merkle root into the single tx going into the ledger?\n\nOn Thu, Dec 9, 2021 at 9:13 AM Peter Todd <pete at petertodd.org> wrote:\n\n> On Mon, Dec 06, 2021 at 04:35:19PM +0000, Christian Moss via bitcoin-dev\n> wrote:\n> > As far as I understand it, RGB doesn't scale NFTs as each\n> > transaction to transfer ownership of an NFT would require an onchain\n> > transaction\n>\n> RGB intends to scale NFTs and similar things in the future via scalable\n> single-use-seals:\n> https://petertodd.org/2017/scalable-single-use-seal-asset-transfer\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/9c5f1126/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2021-12-09T10:07:37",
                "message_text_only": "On Thu, Dec 09, 2021 at 09:49:11AM +0000, Christian Moss wrote:\n> pete at petertodd.org, so single use seals require an onchain transaction to\n> post the proof of publication to the ledger (assuming bitcoin is used as\n> the ledger) when an asset is transferred, but it can scale because you can\n> batch many proofs (transfer of ownerships) into a merkle tree and just add\n> the merkle root into the single tx going into the ledger?\n\nExactly. And since the aggregation is trustless with respect to validity, users\ncan choose what kind of censorship risk they're willing to take (as well as\nmitigate it with \"multisig\" schemes that use multiple aggregators in parallel).\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/1f650ac2/attachment.sig>"
            },
            {
                "author": "Alex Schoof",
                "date": "2021-12-09T12:12:45",
                "message_text_only": "The multisig scheme is interesting. From my understanding of Single Use\nSeals, since seal n commits to seal n+1, for the on-chain aggregation seals\nyou would want to pick some common aggregation service provider ahead of\ntime and if that provider disappears, you\u2019re stuck and cant close the next\nseal. If instead you say \u201cthis seal commits to three of the five of these\nnext seals\u201d then you mitigate both availability and censorship risk. Am I\ngetting that right?\n\nAlex\n\nOn Thu, Dec 9, 2021 at 5:23 AM Peter Todd <pete at petertodd.org> wrote:\n\n> On Thu, Dec 09, 2021 at 09:49:11AM +0000, Christian Moss wrote:\n> > pete at petertodd.org, so single use seals require an onchain transaction\n> to\n> > post the proof of publication to the ledger (assuming bitcoin is used as\n> > the ledger) when an asset is transferred, but it can scale because you\n> can\n> > batch many proofs (transfer of ownerships) into a merkle tree and just\n> add\n> > the merkle root into the single tx going into the ledger?\n>\n> Exactly. And since the aggregation is trustless with respect to validity,\n> users\n> can choose what kind of censorship risk they're willing to take (as well as\n> mitigate it with \"multisig\" schemes that use multiple aggregators in\n> parallel).\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-- \n\n\nAlex Schoof\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/0a9cde55/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2021-12-09T12:56:19",
                "message_text_only": "On Thu, Dec 09, 2021 at 07:12:45AM -0500, Alex Schoof wrote:\n> The multisig scheme is interesting. From my understanding of Single Use\n> Seals, since seal n commits to seal n+1, for the on-chain aggregation seals\n> you would want to pick some common aggregation service provider ahead of\n> time and if that provider disappears, you\u2019re stuck and cant close the next\n> seal. If instead you say \u201cthis seal commits to three of the five of these\n> next seals\u201d then you mitigate both availability and censorship risk. Am I\n> getting that right?\n\nRe: \"some common aggregation service provider\", you might be misunderstanding\nthe protocol: since seals are trustless with regard to validity, I can validate\nyour seal, regardless of which aggregation service you use.\n\nBut other than that, I think we're on the same page!\n\nA concrete example would be an exchange: they do a lot of transactions, so they\ncould choose to be their own aggregator, and wouldn't need any multisig at all\nbecause they can trust themselves not to censor themselves. :) Meanwhile, one\nof their customers might use 3-of-5 as you suggest, as they only do a few\ntransactions a month.\n\nInterestingly, in some scenarios it might be worthwhile to both run your own\naggregator, and use multisig. Eg Alice could use a 2-of-3 with two third-party\naggregators, and her own aggregation chain. If both third-parties are up, she\ndoes no on-chain transactions at all; if one third-party is down, she can use\nher own, and the remaining third-party. Thus she would only do an on-chain\ntransaction to defeat censorship/failure.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/6edd19ec/attachment.sig>"
            },
            {
                "author": "Christian Moss",
                "date": "2021-12-06T12:38:30",
                "message_text_only": "Hi, it is not really possible in the way you think, mainly because\nlightning relies on liquidity to work, i.,e. lots of bitcoin locked up in\nchannels to allow liquidity, NFTs are not liquid, so if you have 1 NFT then\nit would be impossible to send on the network\n\nI think the best off chain solution to NFTs on bitcoin is using Ruben\nSomsens state chain protocol, which allows you to swap utxos off chain, and\nthose off chain utxos could harbour an op return/nft\n\nOn Mon, Dec 6, 2021 at 10:36 AM Karl via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> wrote:\n\n> Hi,\n>\n> I'm not a bitcoin developer.\n>\n> On Mon, Dec 6, 2021, 5:05 AM H\u00e9ctor Jos\u00e9 C\u00e1rdenas Pacheco via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n>> Hello all,\n>>\n>> I\u2019ve been thinking about how OP_RETURN is being used to create and trade\n>> NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was wondering\n>> if it\u2019s possible to\n>>\n>\n> Do you have a link to any of these protocols?\n>\n> make transactions with this opcode via Lightning.\n>>\n>> More specific questions could be:\n>>\n>>    1. Can opcodes like OP_RETURN be inside a channel\u2019s opening or\n>>    closing transaction?\n>>    2. If so, could that OP_RETURN change hands within that channel or\n>>    network of channels?\n>>\n>> OP_RETURNs do not have ownership according to the bitcoin network.  It is\n> not hard to define a protocol that associates an OP_RETURN with ownership,\n> and ownership could then be transferred via lightning by sending associated\n> currency via lightning.  Robustness improvements seem possible.\n>\n>\n>>    1. If possible, could the OP_RETURN be divisible? Could one person\n>>    send a piece of a OP_RETURN just like one can do right now on the primary\n>>    ledger or would it need to maintain the OP_RETURN code intact?\n>>\n>> OP_RETURNs themselves do not have ownership, but you can define a\n> protocol that gives them divisible ownership, including via lightning.\n>\n> I\u2019m assuming that, if possible, this would need a protocol layer parallel\n>> to Bitcoin/Lightning that stores and reads all Bitcoin transactions and the\n>> ones which involve the node's channels as well as the ones with the\n>> OP_RETURN, just like CounterParty does right now with the primary ledger.\n>>\n>> Thank in advance.\n>> \u2014\u2014\n>>\n>> *H\u00e9ctor C\u00e1rdenas*@hcarpach\n>>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/7533655c/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Sending OP_RETURN via Bitcoin Lightning",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Christian Moss",
                "Alex Schoof",
                "Peter Todd",
                "Karl",
                "Martin Habov\u0161tiak"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 16754
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Sending OP_RETURN via Bitcoin",
        "thread_messages": [
            {
                "author": "Bitcoin Error Log",
                "date": "2021-12-06T12:32:07",
                "message_text_only": "Omni Layer already does this, on Bitcoin, and recently added NFT support,\nbut I don't know much about that aspect.\n\nOmniBOLT also exists as a LN layer for Omni assets. OB is being audited\nright now.\n\nSending NFTs using Lightning is generally impractical, as it is a\nliquidity-based routing network, thus requires a whole new network for each\nnew asset. But fungible assets should be doable by any popular token asset.\n\nI don't think RGB is practically usable by anyone yet, and still needs\nsevere attention paid to auditing the design, if it is ever completed at\nall...\n\n\nOn Mon, Dec 6, 2021 at 7:00 AM <\nlightning-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send Lightning-dev mailing list submissions to\n>         lightning-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> or, via email, send a message with subject or body 'help' to\n>         lightning-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         lightning-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: [bitcoin-dev] Sending OP_RETURN via Bitcoin   Lightning (Karl)\n>    2. Re: [bitcoin-dev] Sending OP_RETURN via Bitcoin   Lightning\n>       (Martin Habov?tiak)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Mon, 6 Dec 2021 05:20:55 -0500\n> From: Karl <gmkarl at gmail.com>\n> To: H?ctor Jos? C?rdenas Pacheco  <hcarpach at gmail.com>,  Bitcoin\n>         Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>\n> Cc: lightning-dev at lists.linuxfoundation.org\n> Subject: Re: [Lightning-dev] [bitcoin-dev] Sending OP_RETURN via\n>         Bitcoin Lightning\n> Message-ID:\n>         <CALL-=e5mF9TqbbD=\n> Cf-bawbw4dq2PGjC9W_nqAQeHsB829ZpNg at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Hi,\n>\n> I'm not a bitcoin developer.\n>\n> On Mon, Dec 6, 2021, 5:05 AM H?ctor Jos? C?rdenas Pacheco via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> wrote:\n>\n> > Hello all,\n> >\n> > I?ve been thinking about how OP_RETURN is being used to create and trade\n> > NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was\n> wondering\n> > if it?s possible to\n> >\n>\n> Do you have a link to any of these protocols?\n>\n> make transactions with this opcode via Lightning.\n> >\n> > More specific questions could be:\n> >\n> >    1. Can opcodes like OP_RETURN be inside a channel?s opening or closing\n> >    transaction?\n> >    2. If so, could that OP_RETURN change hands within that channel or\n> >    network of channels?\n> >\n> > OP_RETURNs do not have ownership according to the bitcoin network.  It is\n> not hard to define a protocol that associates an OP_RETURN with ownership,\n> and ownership could then be transferred via lightning by sending associated\n> currency via lightning.  Robustness improvements seem possible.\n>\n>\n> >    1. If possible, could the OP_RETURN be divisible? Could one person\n> >    send a piece of a OP_RETURN just like one can do right now on the\n> primary\n> >    ledger or would it need to maintain the OP_RETURN code intact?\n> >\n> > OP_RETURNs themselves do not have ownership, but you can define a\n> protocol\n> that gives them divisible ownership, including via lightning.\n>\n> I?m assuming that, if possible, this would need a protocol layer parallel\n> > to Bitcoin/Lightning that stores and reads all Bitcoin transactions and\n> the\n> > ones which involve the node's channels as well as the ones with the\n> > OP_RETURN, just like CounterParty does right now with the primary ledger.\n> >\n> > Thank in advance.\n> > ??\n> >\n> > *H?ctor C?rdenas*@hcarpach\n> >\n> > _______________________________________________\n> > bitcoin-dev mailing list\n> > bitcoin-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/f3253ec4/attachment-0001.html\n> >\n>\n> ------------------------------\n>\n> Message: 2\n> Date: Mon, 6 Dec 2021 12:31:29 +0100\n> From: Martin Habov?tiak <martin.habovstiak at gmail.com>\n> To: Karl <gmkarl at gmail.com>\n> Cc: Bitcoin Protocol Discussion\n>         <bitcoin-dev at lists.linuxfoundation.org>, lightning-dev\n>         <lightning-dev at lists.linuxfoundation.org>, H?ctor Jos? C?rdenas\n>         Pacheco <hcarpach at gmail.com>\n> Subject: Re: [Lightning-dev] [bitcoin-dev] Sending OP_RETURN via\n>         Bitcoin Lightning\n> Message-ID:\n>         <\n> CALkkCJas_pf7Un45CJyFg8j9cBk8PtKN4iYAL81TtLSRNnKqeg at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> I recommend you researching RGB: https://rgb-org.github.io/\n>\n> On Mon, Dec 6, 2021, 11:21 Karl <gmkarl at gmail.com> wrote:\n>\n> > Hi,\n> >\n> > I'm not a bitcoin developer.\n> >\n> > On Mon, Dec 6, 2021, 5:05 AM H?ctor Jos? C?rdenas Pacheco via\n> bitcoin-dev <\n> > bitcoin-dev at lists.linuxfoundation.org> wrote:\n> >\n> >> Hello all,\n> >>\n> >> I?ve been thinking about how OP_RETURN is being used to create and trade\n> >> NFTs on Bitcoin (think RarePepes, SoG and other new ones) and was\n> wondering\n> >> if it?s possible to\n> >>\n> >\n> > Do you have a link to any of these protocols?\n> >\n> > make transactions with this opcode via Lightning.\n> >>\n> >> More specific questions could be:\n> >>\n> >>    1. Can opcodes like OP_RETURN be inside a channel?s opening or\n> >>    closing transaction?\n> >>    2. If so, could that OP_RETURN change hands within that channel or\n> >>    network of channels?\n> >>\n> >> OP_RETURNs do not have ownership according to the bitcoin network.  It\n> is\n> > not hard to define a protocol that associates an OP_RETURN with\n> ownership,\n> > and ownership could then be transferred via lightning by sending\n> associated\n> > currency via lightning.  Robustness improvements seem possible.\n> >\n> >\n> >>    1. If possible, could the OP_RETURN be divisible? Could one person\n> >>    send a piece of a OP_RETURN just like one can do right now on the\n> primary\n> >>    ledger or would it need to maintain the OP_RETURN code intact?\n> >>\n> >> OP_RETURNs themselves do not have ownership, but you can define a\n> > protocol that gives them divisible ownership, including via lightning.\n> >\n> > I?m assuming that, if possible, this would need a protocol layer parallel\n> >> to Bitcoin/Lightning that stores and reads all Bitcoin transactions and\n> the\n> >> ones which involve the node's channels as well as the ones with the\n> >> OP_RETURN, just like CounterParty does right now with the primary\n> ledger.\n> >>\n> >> Thank in advance.\n> >> ??\n> >>\n> >> *H?ctor C?rdenas*@hcarpach\n> >>\n> >> _______________________________________________\n> >> bitcoin-dev mailing list\n> >> bitcoin-dev at lists.linuxfoundation.org\n> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n> >>\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/d86e56cb/attachment-0001.html\n> >\n>\n> ------------------------------\n>\n> Subject: Digest Footer\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> ------------------------------\n>\n> End of Lightning-dev Digest, Vol 76, Issue 4\n> ********************************************\n>\n-- \n~ John Carvalho\n\nSchedule: https://calendly.com/bitcoinerrorlog\nChat: https://t.me/bitcoinerrorlog\nSocial: https://twitter.com/bitcoinerrorlog\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/e4816d2d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Sending OP_RETURN via Bitcoin",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Bitcoin Error Log"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 8210
        }
    },
    {
        "title": "[Lightning-dev] PTLCs early draft specification",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-06T17:21:12",
                "message_text_only": "Good morning list,\n\nThere was a great recent post on the mailing list detailing how we could\ndo PTLCs on lightning with a lot of other goodies [0]. This proposal\ncontained heavy changes to the transaction structure and the update\nprotocol. While it's certainly something we'll want to do in the long\nrun, I wanted to explore the minimal set of changes we would need to be\nable to deploy PTLCs as soon as possible.\n\nThe current result is a somewhat high-level article, where each section\ncould be a separate update of the lightning protocol [1].\n\nI tried to make PTLCs work with minimal changes to the transaction\nstructure and the update protocol, but they introduce a fundamental\nchange which forces us to make more changes than I'd like.\n\nWith HTLCs, the payment secret (the preimage of the payment hash) was\ndirectly revealed in the witness of a spending transaction.\n\nWith PTLCs, this isn't the case anymore. The payment secret is a private\nkey, and a spending transaction only reveals that key if you have a\nmatching adaptor signature. This forces us to make two changes:\n\n1. We must obtain adaptor signatures before sending our commit_sig\n2. We must use a pre-signed HTLC-success transaction not only with our\nlocal commit, but also with the remote commit\n\nThis means that we will need more round-trips whenever we update our\ncommitment. I'd like to find the right design trade-off where we don't\nintroduce too many changes in the protocol while minimizing the number\nof additional round-trips.\n\nWe currently exchange the following messages:\n\nAlice                       Bob\n      update_add_htlc\n  --------------------------->\n      update_add_htlc\n  --------------------------->\n      update_add_htlc\n  --------------------------->\n        commit_sig\n  --------------------------->\n       revoke_and_ack\n  <---------------------------\n        commit_sig\n  <---------------------------\n       revoke_and_ack\n  --------------------------->\n\nIt works well because the commit_sig sent by Alice only contains signatures\nfor Bob's transactions (commit and htlc transactions), and the commit_sig\nsent by Bob only contains signatures for Alice's transactions, and Alice\nand Bob don't need anything else to spend outputs from either commitment.\n\nBut with PTLCs, Bob needs a signature from Alice to be able to fulfill a\nPTLC from Alice's commitment. And Alice needs Bob to provide an adaptor\nsignature for that transaction before she can give him her signature.\nWe don't have the clean ordering that we had before.\n\nThe designs I came up with that keep the current messages and just insert\nnew ones are either too costly (too many additional round-trips) or too\ncomplex (most likely broken in some edge cases).\n\nI believe we need to change the commit_sig / revoke_and_ack protocol if\nwe want to find the sweet spot I'm looking for. I'd like to collect ideas\nfrom this list's participants on how we could do that. This is probably\nsomething that should be bundled with option_simplified_commitment [2]\n(or at least we must ensure that option_simplified_commitment is a first\nstep towards the protocol we'll need for PTLCs). It's also important to\nnote that the protocol changes must work for both HTLCs and PTLCs, and\nshouldn't change the structure of the transactions (not more than the\nsimple addition of PTLC outputs done in [1]).\n\nCheers,\nBastien\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-October/003278.html\n[1] https://github.com/t-bast/lightning-docs/pull/16\n[2] https://github.com/lightning/bolts/pull/867\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211206/c474a332/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-07T00:08:24",
                "message_text_only": "Good morning t-bast,\n\nLong ago: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002385.html\n\nAnd I quote:\n\n>> A potential issue with MuSig is the increased number of communication rounds needed to generate signatures.\n>\n>I think you can reduce this via an alternative script path. In\n>particular, if you want a script that the other guy can spend if they\n>reveal the discrete log of point X, with musig you do:\n>\n>   P = H(H(A,B),1)*A + H(H(A,B),2)*B\n>   [exchange H(RA),H(RB),RA,RB]\n>\n>   [send X]\n>\n>   sb = rb + H(RA+RB+X,P,m)*H(H(A,B),2)*b\n>\n>   [wait for sb]\n>\n>   sa = ra + H(RA+RB+X,P,m)*H(H(A,B),1)*a\n>\n>   [store RA+RB+X, sa+sb, supply sa, watch for sig]\n>\n>   sig = (RA+RB+X, sa+sb+x)\n>\n>So the 1.5 round trips are \"I want to do a PTLC for X\", \"okay here's\n>sb\", \"great, here's sa\".\n>\n>But with taproot you can have a script path as well, so you could have a\n>script:\n>\n>   A CHECKSIGVERIFY B CHECKSIG\n>\n>and supply a partial signature:\n>\n>   R+X,s,X where s = r + H(R+X,A,m)*a\n>\n>to allow them to satisfy \"A CHECKSIGVERIFY\" if they know the discrete\n>log of X, and of course they can sign with B at any time. This is only\n>half a round trip, and can be done at the same time as sending the \"I\n>want to do a PTLC for X\" message to setup the (ultimately cheaper) MuSig\n>spend. It's an extra signature on the sender's side and an extra verification\n>on the receiver's side, but I think it works out fine.\n\nIt has been a while since I read that post, so my details may be fuzzy, but it looks possible as a way to reduce roundtrips, maybe?\n\nBasically, if my memory and understanding are accurate, in the above, it is the *PTLC-offerrer* which provides an adaptor signature.\nThat adaptor signature would be included in the `update_add_ptlc` message.\n\nDoes it become more workable that way?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-12-07T06:09:06",
                "message_text_only": "I was thinking along the same lines as Z. With MuSig2 and pre-sharing of\nsignature nonces it should stay three rounds and share a similar structure.\n\nOn Tue, 7 Dec 2021 at 11:08, ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Basically, if my memory and understanding are accurate, in the above, it\n> is the *PTLC-offerrer* which provides an adaptor signature.\n> That adaptor signature would be included in the `update_add_ptlc` message.\n>\n\nIsn't it the case that all previous PTLC adaptor signatures need to be\nre-sent for each update_add_ptlc message because the signatures would no\nlonger be valid once the commit tx changes. I think it's better to put it\nin `commitment_signed` if possible. This is what is done with pre-signed\nHTLC signatures at the moment anyway.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211207/894e2b77/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-07T08:04:09",
                "message_text_only": "Good morning LL, and t-bast,\n\n> > Basically, if my memory and understanding are accurate, in the above, it is the *PTLC-offerrer* which provides an adaptor signature.\n> > That adaptor signature would be included in the `update_add_ptlc` message.\n>\n> Isn't it the case that all previous PTLC adaptor signatures need to be re-sent for each update_add_ptlc message because the signatures would no longer be valid once the commit tx changes. I think it's better to put it in `commitment_signed` if possible. This is what is done with pre-signed HTLC signatures at the moment anyway.\n\nAgreed.\n\nThis is also avoided by fast-forwards, BTW, simply because fast-forwards delay the change of the commitment tx.\nIt is another reason to consider fast-forwards, too....\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-07T13:11:00",
                "message_text_only": "Hi Z, Lloyd,\n\nLet's ignore the musig nonce exchanges for now. I believe these can be\neasily included in existing messages: they probably aren't the reason we\nneed more round-trips (at least not the one I'm concerned about for now).\n\nBasically, if my memory and understanding are accurate, in the above,\n> it is the *PTLC-offerrer* which provides an adaptor signature.\n> That adaptor signature would be included in the `update_add_ptlc` message.\n\n\nNeat, you're completely right, I didn't realize that the adaptor signature\ncould be completed by the other party, this is a great property I had\nmissed.\nThanks for pointing it out, it does simplify the protocol a lot!\n\nI don't think you can include it in `update_add_ptlc` though, it has to\nbe in `commitment_signed`, because if you do a batch of updates before\nsigning, you would immediately invalidate the adaptor signatures you\npreviously sent.\n\nBut it would be a simple change, where the signatures in `commitment_signed`\nwould actually be adaptor signatures for PTLC-success transactions and\nnormal signatures for PTLC-timeout transactions.\n\nIsn't it the case that all previous PTLC adaptor signatures need to be\n> re-sent for each update_add_ptlc message because the signatures would\n> no longer be valid once the commit tx changes\n\n\nYes indeed, whenever the commitment changes, peers need to create new\nsignatures and adaptor signatures for all pending PTLCs.\n\nThis is completely fine for PTLC-success and PTLC-timeout transactions,\nbut we also need to exchange signatures for the new pre-signed transactions\nthat spend a PTLC from the remote commitment. Let's call this new pre-signed\ntransaction PTLC-remote-success (not a great name).\n\nI believe these new transactions may require an additional round-trip.\nLet's take a very simple example, where we have one pending PTLC in each\ndirection: PTLC_AB was offered by A to B and PTLC_BA was offered by B to A.\n\nNow A makes some unrelated updates and wants to sign a new commitment.\nA cannot immediately send her `commitment_signed` to B.\nIf she did, B would be able to broadcast this new commitment, and A would\nnot be able to claim PTLC_BA from B's new commitment (even if she knew\nthe payment secret) because she wouldn't have B's signature for the new\nPTLC-remote-success transaction.\n\nSo we first need B to send a new message `remote_ptlcs_signed` to A that\ncontains B's adaptor signatures for the PTLC-remote-success transactions\nthat would spend B's future commitment. After that A can safely send her\n`commitment_signed`. Similarly, A must send `remote_ptlcs_signed` to B\nbefore B can send its `commitment_signed`.\n\nIt's actually not that bad, we're only adding one message in each direction,\nand we're not adding more data (apart from nonces) to existing messages.\n\nIf you have ideas on how to avoid this new message, I'd be glad to hear\nthem, hopefully I missed something again and we can make it better!\n\nThanks,\nBastien\n\nLe mar. 7 d\u00e9c. 2021 \u00e0 09:04, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning LL, and t-bast,\n>\n> > > Basically, if my memory and understanding are accurate, in the above,\n> it is the *PTLC-offerrer* which provides an adaptor signature.\n> > > That adaptor signature would be included in the `update_add_ptlc`\n> message.\n> >\n> > Isn't it the case that all previous PTLC adaptor signatures need to be\n> re-sent for each update_add_ptlc message because the signatures would no\n> longer be valid once the commit tx changes. I think it's better to put it\n> in `commitment_signed` if possible. This is what is done with pre-signed\n> HTLC signatures at the moment anyway.\n>\n> Agreed.\n>\n> This is also avoided by fast-forwards, BTW, simply because fast-forwards\n> delay the change of the commitment tx.\n> It is another reason to consider fast-forwards, too....\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211207/55feef47/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-07T23:52:04",
                "message_text_only": "Good morning t-bast,\n\n\n> I believe these new transactions may require an additional round-trip.\n> Let's take a very simple example, where we have one pending PTLC in each\n> direction: PTLC_AB was offered by A to B and PTLC_BA was offered by B to A.\n>\n> Now A makes some unrelated updates and wants to sign a new commitment.\n> A cannot immediately send her `commitment_signed` to B.\n> If she did, B would be able to broadcast this new commitment, and A would\n> not be able to claim PTLC_BA from B's new commitment (even if she knew\n> the payment secret) because she wouldn't have B's signature for the new\n> PTLC-remote-success transaction.\n>\n> So we first need B to send a new message `remote_ptlcs_signed` to A that\n> contains B's adaptor signatures for the PTLC-remote-success transactions\n> that would spend B's future commitment. After that A can safely send her\n> `commitment_signed`. Similarly, A must send `remote_ptlcs_signed` to B\n> before B can send its `commitment_signed`.\n>\n> It's actually not that bad, we're only adding one message in each direction,\n> and we're not adding more data (apart from nonces) to existing messages.\n>\n> If you have ideas on how to avoid this new message, I'd be glad to hear\n> them, hopefully I missed something again and we can make it better!\n\n`SIGHASH_NONE | SIGHASH_NOINPUT` (which will take another what, four years?) or a similar \"covenant\" opcode, such as `OP_CHECKTEMPLATEVERIFY` without any commitments or an `OP_CHECKSIGFROMSTACK` on an empty message.\nAll you really need is a signature for an empty message, really...\n\nAlternately, fast-forwards, which avoid this because it does not change commitment transactions on the payment-forwarding path.\nYou only change commitment transactions once you have enough changes to justify collapsing them.\nEven in the aj formulation, when A adds a PTLC it only changes the transaction that hosts **only** A->B PTLCs as well as the A main output, all of which can be sent outright by A without changing any B->A PTLCs.\n\nBasically... instead of a commitment tx like this:\n\n                        +-------+\n    funding outpoint -->|       |--> A main\n                        |       |--> B main\n                        |       |--> A->B PTLC\n                        |       |--> B->A PTLC\n                        +-------+\n\nWe could do this instead:\n\n                        +-------+2of2  +-----+\n    funding outpoint -->|       |----->|     |--> A main\n                        |       |      |     |--> A->B PTLC\n                        |       |      +-----+\n                        |       |2or2  +-----+\n                        |       |----->|     |--> B main\n                        |       |      |     |--> B->A PTLC\n                        +-------+      +-----+\n\nThen whenever A wants to add a new A->B PTLC it only changes the tx inputs of the *other* A->B PTLCs without affecting the B->A PTLCs.\nPayment forwarding is fast, and you only change the \"big\" commitment tx rarely to clean up claimed and failed PTLCs, moving the extra messages out of the forwarding hot path.\n\nBut this is basically highly similar to what aj designed anyway, so...\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-08T08:40:35",
                "message_text_only": "Hi Z,\n\n`SIGHASH_NONE | SIGHASH_NOINPUT` (which will take another what, four\n> years?) or a similar \"covenant\" opcode,\n\nsuch as `OP_CHECKTEMPLATEVERIFY` without any commitments or an\n> `OP_CHECKSIGFROMSTACK` on an empty message.\n> All you really need is a signature for an empty message, really...\n>\n\nThat fails my requirement of \"deployable in 2022\" :)\n\nSame thing applies to fast-forwards: I do see their value, but I'd like to\nfocus on a first version with minimal changes to the transaction structure\nand the update protocol, to ensure we can actually get agreement on it\nsomewhat quickly and ship it in 2022. Then we can start working on a\nmore ambitious rework of the protocol that adds a lot of cool features,\nsuch as what AJ proposed recently.\n\nCheers,\nBastien\n\nLe mer. 8 d\u00e9c. 2021 \u00e0 00:52, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning t-bast,\n>\n>\n> > I believe these new transactions may require an additional round-trip.\n> > Let's take a very simple example, where we have one pending PTLC in each\n> > direction: PTLC_AB was offered by A to B and PTLC_BA was offered by B to\n> A.\n> >\n> > Now A makes some unrelated updates and wants to sign a new commitment.\n> > A cannot immediately send her `commitment_signed` to B.\n> > If she did, B would be able to broadcast this new commitment, and A would\n> > not be able to claim PTLC_BA from B's new commitment (even if she knew\n> > the payment secret) because she wouldn't have B's signature for the new\n> > PTLC-remote-success transaction.\n> >\n> > So we first need B to send a new message `remote_ptlcs_signed` to A that\n> > contains B's adaptor signatures for the PTLC-remote-success transactions\n> > that would spend B's future commitment. After that A can safely send her\n> > `commitment_signed`. Similarly, A must send `remote_ptlcs_signed` to B\n> > before B can send its `commitment_signed`.\n> >\n> > It's actually not that bad, we're only adding one message in each\n> direction,\n> > and we're not adding more data (apart from nonces) to existing messages.\n> >\n> > If you have ideas on how to avoid this new message, I'd be glad to hear\n> > them, hopefully I missed something again and we can make it better!\n>\n> `SIGHASH_NONE | SIGHASH_NOINPUT` (which will take another what, four\n> years?) or a similar \"covenant\" opcode, such as `OP_CHECKTEMPLATEVERIFY`\n> without any commitments or an `OP_CHECKSIGFROMSTACK` on an empty message.\n> All you really need is a signature for an empty message, really...\n>\n> Alternately, fast-forwards, which avoid this because it does not change\n> commitment transactions on the payment-forwarding path.\n> You only change commitment transactions once you have enough changes to\n> justify collapsing them.\n> Even in the aj formulation, when A adds a PTLC it only changes the\n> transaction that hosts **only** A->B PTLCs as well as the A main output,\n> all of which can be sent outright by A without changing any B->A PTLCs.\n>\n> Basically... instead of a commitment tx like this:\n>\n>                         +-------+\n>     funding outpoint -->|       |--> A main\n>                         |       |--> B main\n>                         |       |--> A->B PTLC\n>                         |       |--> B->A PTLC\n>                         +-------+\n>\n> We could do this instead:\n>\n>                         +-------+2of2  +-----+\n>     funding outpoint -->|       |----->|     |--> A main\n>                         |       |      |     |--> A->B PTLC\n>                         |       |      +-----+\n>                         |       |2or2  +-----+\n>                         |       |----->|     |--> B main\n>                         |       |      |     |--> B->A PTLC\n>                         +-------+      +-----+\n>\n> Then whenever A wants to add a new A->B PTLC it only changes the tx inputs\n> of the *other* A->B PTLCs without affecting the B->A PTLCs.\n> Payment forwarding is fast, and you only change the \"big\" commitment tx\n> rarely to clean up claimed and failed PTLCs, moving the extra messages out\n> of the forwarding hot path.\n>\n> But this is basically highly similar to what aj designed anyway, so...\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/531e3f1e/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-12-08T09:28:53",
                "message_text_only": "On Tue, Dec 07, 2021 at 11:52:04PM +0000, ZmnSCPxj via Lightning-dev wrote:\n> Alternately, fast-forwards, which avoid this because it does not change commitment transactions on the payment-forwarding path.\n> You only change commitment transactions once you have enough changes to justify collapsing them.\n\nI think the problem t-bast describes comes up here as well when you\ncollapse the fast-forwards (or, anytime you update the commitment\ntransaction even if you don't collapse them).\n\nThat is, if you have two PTLCs, one from A->B conditional on X, one\nfrom B->A conditional on Y. Then if A wants to update the commitment tx,\nshe needs to\n\n  1) produce a signature to give to B to spend the funding tx\n  2) produce an adaptor signature to authorise B to spend via X from his\n     commitment tx\n  3) produce a signature to allow B to recover Y after timeout from his\n     commitment tx spending to an output she can claim if he cheats\n  4) *receive* an adaptor signature from B to be able to spend the Y output\n     if B posts his commitment tx using A's signature in (1)\n\nThe problem is, she can't give B the result of (1) until she's received\n(4) from B.\n\nIt doesn't matter if the B->A PTLC conditional on Y is in the commitment\ntx itself or within a fast-forward child-transaction -- any previous\nadaptor sig will be invalidated because there's a new commitment\ntransaction, and if you allowed any way of spending without an adaptor\nsig, B wouldn't be able to recover the secret and would lose funds.\n\nIt also doesn't matter if the commitment transaction that A and B will\npublish is the same or different, only that it's different from the\ncommitment tx that previous adaptor sigs committed to. (So ANYPREVOUT\nwould fix this if it were available)\n\nSo I think this is still a relevant question, even if fast-forwards\nmake it a rare problem, that perhaps is only applicable to very heavily\nused channels.\n\n(I said the following in email to t-bast already)\n\nI think doing a synchronous update of commitments to the channel state,\nsomething like:\n\n   Alice -> Bob: propose_new_commitment\n       channel id\n       adaptor sigs for PTLCs to Bob\n\n   Bob -> Alice: agree_new_commitment\n       channel id\n       adaptor sigs for PTLCs to Alice\n       sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n         commitment tx\n       signature for Alice to spend funding tx\n\n   Alice -> Bob: finish_new_commitment_1\n       channel id\n       sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n         commitment tx\n       signature for Bob to spend funding tx\n       reveal old prior commitment secret\n       new commitment nonce\n\n   Bob -> Alice: finish_new_commitment_2\n       reveal old prior commitment secret\n       new commitment nonce\n\nwould work pretty well.\n\nThis adds half a round-trip compared to now:\n\n   Alice -> Bob: commitment_signed\n   Bob -> Alice: revoke_and_ack, commitment_signed\n   Alice -> Bob: revoke_and_ack\n\nThe timings change like so:\n\n  Bob can use the new commitment after 1.5 round-trips (previously 0.5)\n\n  Alice can be sure Bob won't use the old commitment after 2 round-trips\n  (previously 1)\n\n  Alice can use the new commitment after 1 round-trip (unchanged)\n\n  Bob can be sure Alice won't use the old commitment after 1.5 round-trips\n  (unchanged -- note: this is what's relevant for forwarding)\n\nMaking the funding tx a musig setup would mean also supplying 64B\nof musig2 nonces along with the \"adaptor sigs\" in one direction,\nand providing the other side's 64B of musig2 nonces back along with the\n(now partial) signature for spending the funding tx (a total of 256B of\nnonce data, not 128B).\n\nBecause it keeps both peers' commitments synchronised to a single channel\nstate, I think the same protocol should work fine with the revocable\nsignatures on a single tx approach too, though I haven't tried working\nthrough the details.\n\nFast forwards would then be reducing the 2 round-trip protocol to\nupdate the state commitment to a 0.5 round-trip update, to reduce\nlatency when forwarding by the same amount as before (1.5 round-trips\nto 0.5 round-trips).\n\nCheers,\naj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-08T10:00:18",
                "message_text_only": "Hi AJ,\n\nI think the problem t-bast describes comes up here as well when you\n> collapse the fast-forwards (or, anytime you update the commitment\n> transaction even if you don't collapse them).\n\n\nYes, exactly.\n\nI think doing a synchronous update of commitments to the channel state,\n> something like:\n\n\n\nAlice -> Bob: propose_new_commitment\n> channel id\n> adaptor sigs for PTLCs to Bob\n\n\n> Bob -> Alice: agree_new_commitment\n> channel id\n> adaptor sigs for PTLCs to Alice\n> sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n> commitment tx\n> signature for Alice to spend funding tx\n>\n> Alice -> Bob: finish_new_commitment_1\n> channel id\n> sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n> commitment tx\n> signature for Bob to spend funding tx\n> reveal old prior commitment secret\n> new commitment nonce\n>\n> Bob -> Alice: finish_new_commitment_2\n> reveal old prior commitment secret\n> new commitment nonce\n>\n> would work pretty well.\n\n\nI agree, this is better than my naive addition of a `remote_ptlcs_signed`\nmessage in both directions, and even though it changes the protocol messages\nit stays very close to the mechanisms we currently have.\n\nI'll spend some time specifying this in more details, to verify that we're\nnot missing anything. What I really like about this proposal is that we\ncan probably bundle that protocol change with `option_simplified_update` [0]\nwithout the adaptor sigs, and simply add the adaptor sigs as tlvs when we\ndo PTLCs. That lets us deploy this new update protocol separately from PTLCs\nand ensure it also simplifies the state machine and makes other features\nsuch as splicing [1] and dynamic channel upgrades [2] easier.\n\nThanks,\nBastien\n\n[0] https://github.com/lightning/bolts/pull/867\n[1] https://github.com/lightning/bolts/pull/863\n[2] https://github.com/lightning/bolts/pull/868\n\nLe mer. 8 d\u00e9c. 2021 \u00e0 10:29, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Tue, Dec 07, 2021 at 11:52:04PM +0000, ZmnSCPxj via Lightning-dev wrote:\n> > Alternately, fast-forwards, which avoid this because it does not change\n> commitment transactions on the payment-forwarding path.\n> > You only change commitment transactions once you have enough changes to\n> justify collapsing them.\n>\n> I think the problem t-bast describes comes up here as well when you\n> collapse the fast-forwards (or, anytime you update the commitment\n> transaction even if you don't collapse them).\n>\n> That is, if you have two PTLCs, one from A->B conditional on X, one\n> from B->A conditional on Y. Then if A wants to update the commitment tx,\n> she needs to\n>\n>   1) produce a signature to give to B to spend the funding tx\n>   2) produce an adaptor signature to authorise B to spend via X from his\n>      commitment tx\n>   3) produce a signature to allow B to recover Y after timeout from his\n>      commitment tx spending to an output she can claim if he cheats\n>   4) *receive* an adaptor signature from B to be able to spend the Y output\n>      if B posts his commitment tx using A's signature in (1)\n>\n> The problem is, she can't give B the result of (1) until she's received\n> (4) from B.\n>\n> It doesn't matter if the B->A PTLC conditional on Y is in the commitment\n> tx itself or within a fast-forward child-transaction -- any previous\n> adaptor sig will be invalidated because there's a new commitment\n> transaction, and if you allowed any way of spending without an adaptor\n> sig, B wouldn't be able to recover the secret and would lose funds.\n>\n> It also doesn't matter if the commitment transaction that A and B will\n> publish is the same or different, only that it's different from the\n> commitment tx that previous adaptor sigs committed to. (So ANYPREVOUT\n> would fix this if it were available)\n>\n> So I think this is still a relevant question, even if fast-forwards\n> make it a rare problem, that perhaps is only applicable to very heavily\n> used channels.\n>\n> (I said the following in email to t-bast already)\n>\n> I think doing a synchronous update of commitments to the channel state,\n> something like:\n>\n>    Alice -> Bob: propose_new_commitment\n>        channel id\n>        adaptor sigs for PTLCs to Bob\n>\n>    Bob -> Alice: agree_new_commitment\n>        channel id\n>        adaptor sigs for PTLCs to Alice\n>        sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n>          commitment tx\n>        signature for Alice to spend funding tx\n>\n>    Alice -> Bob: finish_new_commitment_1\n>        channel id\n>        sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n>          commitment tx\n>        signature for Bob to spend funding tx\n>        reveal old prior commitment secret\n>        new commitment nonce\n>\n>    Bob -> Alice: finish_new_commitment_2\n>        reveal old prior commitment secret\n>        new commitment nonce\n>\n> would work pretty well.\n>\n> This adds half a round-trip compared to now:\n>\n>    Alice -> Bob: commitment_signed\n>    Bob -> Alice: revoke_and_ack, commitment_signed\n>    Alice -> Bob: revoke_and_ack\n>\n> The timings change like so:\n>\n>   Bob can use the new commitment after 1.5 round-trips (previously 0.5)\n>\n>   Alice can be sure Bob won't use the old commitment after 2 round-trips\n>   (previously 1)\n>\n>   Alice can use the new commitment after 1 round-trip (unchanged)\n>\n>   Bob can be sure Alice won't use the old commitment after 1.5 round-trips\n>   (unchanged -- note: this is what's relevant for forwarding)\n>\n> Making the funding tx a musig setup would mean also supplying 64B\n> of musig2 nonces along with the \"adaptor sigs\" in one direction,\n> and providing the other side's 64B of musig2 nonces back along with the\n> (now partial) signature for spending the funding tx (a total of 256B of\n> nonce data, not 128B).\n>\n> Because it keeps both peers' commitments synchronised to a single channel\n> state, I think the same protocol should work fine with the revocable\n> signatures on a single tx approach too, though I haven't tried working\n> through the details.\n>\n> Fast forwards would then be reducing the 2 round-trip protocol to\n> update the state commitment to a 0.5 round-trip update, to reduce\n> latency when forwarding by the same amount as before (1.5 round-trips\n> to 0.5 round-trips).\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/e5173822/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-08T15:02:02",
                "message_text_only": "Hi again AJ and list,\n\nI have slightly re-worked your proposal, and came up with the following\n(I also added the musig2 nonces for completeness):\n\nAlice -> Bob: commitment_proposed\n    channel id\n    adaptor sigs for PTLCs to Bob in Alice's next commitment\n    musig nonces for Alice to spend funding tx\n    musig nonces for Bob to spend funding tx\n\nBob -> Alice: commitment_proposed\n    channel id\n    adaptor sigs for PTLCs to Alice in Bob's next commitment\n    musig nonces for Alice to spend funding tx\n    musig nonces for Bob to spend funding tx\n\nBob -> Alice: commitment_signed\n    channel id\n    signature for Alice to spend funding tx\n    sigs for Alice to spend HTLCs and PTLCs from her next commitment\n\nAlice -> Bob: revoke_and_ack\n    channel id\n    reveal previous commitment secret\n    next commitment point\n\nAlice -> Bob: commitment_signed\n    channel id\n    signature for Bob to spend funding tx\n    sigs for Bob to spend HTLCs and PTLCs from his next commitment\n\nBob -> Alice: revoke_and_ack\n    channel id\n    reveal previous commitment secret\n    next commitment point\n\nI believe it's exactly the same flow of data between peers as your\nproposal, but I simply split the data into several messages. Let me\nknow if that's incorrect or if I missed a subtlety in your proposal.\n\nThis has some small advantages:\n\n* commitment_signed and revoke_and_ack are mostly unchanged, we just\nadd a new message before the commit / revoke dance. The only change\nhappens in commitment_signed, where the signatures for PTLC-success\ntransactions will actually become adaptor signatures.\n* the new adaptor signatures are in commitment_proposed instead of being\nin commitment_signed, which ensures that we can still have 2*483\npending (H|P)TLCs: since the message size is limited to 65kB, we would\notherwise decrease our maximum to ~2*335 with your proposal (very rough\ncalculation)\n* the messages are now symmetrical, which may be easier to reason about\n\nOne thing to note is that we reversed the order in which participants\nsign new commitments. We previously had Alice sign first, whereas now\nif Alice initiates, Bob will sign the updated commitment first. This is\nwhy we add only 0.5 RTT instead of 1 RTT compared to the current protocol.\nI don't think this is an issue, but if someone sees a way to maliciously\nexploit this, please share it!\n\nI updated my article [0], people jumping on the thread now may find it\nhelpful to better understand this discussion.\n\nThanks,\nBastien\n\n[0] https://github.com/t-bast/lightning-docs/pull/16\n\nLe mer. 8 d\u00e9c. 2021 \u00e0 11:00, Bastien TEINTURIER <bastien at acinq.fr> a \u00e9crit :\n\n> Hi AJ,\n>\n> I think the problem t-bast describes comes up here as well when you\n>> collapse the fast-forwards (or, anytime you update the commitment\n>> transaction even if you don't collapse them).\n>\n>\n> Yes, exactly.\n>\n> I think doing a synchronous update of commitments to the channel state,\n>> something like:\n>\n>\n>\n> Alice -> Bob: propose_new_commitment\n>> channel id\n>> adaptor sigs for PTLCs to Bob\n>\n>\n>> Bob -> Alice: agree_new_commitment\n>> channel id\n>> adaptor sigs for PTLCs to Alice\n>> sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n>> commitment tx\n>> signature for Alice to spend funding tx\n>>\n>> Alice -> Bob: finish_new_commitment_1\n>> channel id\n>> sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n>> commitment tx\n>> signature for Bob to spend funding tx\n>> reveal old prior commitment secret\n>> new commitment nonce\n>>\n>> Bob -> Alice: finish_new_commitment_2\n>> reveal old prior commitment secret\n>> new commitment nonce\n>>\n>> would work pretty well.\n>\n>\n> I agree, this is better than my naive addition of a `remote_ptlcs_signed`\n> message in both directions, and even though it changes the protocol\n> messages\n> it stays very close to the mechanisms we currently have.\n>\n> I'll spend some time specifying this in more details, to verify that we're\n> not missing anything. What I really like about this proposal is that we\n> can probably bundle that protocol change with `option_simplified_update`\n> [0]\n> without the adaptor sigs, and simply add the adaptor sigs as tlvs when we\n> do PTLCs. That lets us deploy this new update protocol separately from\n> PTLCs\n> and ensure it also simplifies the state machine and makes other features\n> such as splicing [1] and dynamic channel upgrades [2] easier.\n>\n> Thanks,\n> Bastien\n>\n> [0] https://github.com/lightning/bolts/pull/867\n> [1] https://github.com/lightning/bolts/pull/863\n> [2] https://github.com/lightning/bolts/pull/868\n>\n> Le mer. 8 d\u00e9c. 2021 \u00e0 10:29, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n>\n>> On Tue, Dec 07, 2021 at 11:52:04PM +0000, ZmnSCPxj via Lightning-dev\n>> wrote:\n>> > Alternately, fast-forwards, which avoid this because it does not change\n>> commitment transactions on the payment-forwarding path.\n>> > You only change commitment transactions once you have enough changes to\n>> justify collapsing them.\n>>\n>> I think the problem t-bast describes comes up here as well when you\n>> collapse the fast-forwards (or, anytime you update the commitment\n>> transaction even if you don't collapse them).\n>>\n>> That is, if you have two PTLCs, one from A->B conditional on X, one\n>> from B->A conditional on Y. Then if A wants to update the commitment tx,\n>> she needs to\n>>\n>>   1) produce a signature to give to B to spend the funding tx\n>>   2) produce an adaptor signature to authorise B to spend via X from his\n>>      commitment tx\n>>   3) produce a signature to allow B to recover Y after timeout from his\n>>      commitment tx spending to an output she can claim if he cheats\n>>   4) *receive* an adaptor signature from B to be able to spend the Y\n>> output\n>>      if B posts his commitment tx using A's signature in (1)\n>>\n>> The problem is, she can't give B the result of (1) until she's received\n>> (4) from B.\n>>\n>> It doesn't matter if the B->A PTLC conditional on Y is in the commitment\n>> tx itself or within a fast-forward child-transaction -- any previous\n>> adaptor sig will be invalidated because there's a new commitment\n>> transaction, and if you allowed any way of spending without an adaptor\n>> sig, B wouldn't be able to recover the secret and would lose funds.\n>>\n>> It also doesn't matter if the commitment transaction that A and B will\n>> publish is the same or different, only that it's different from the\n>> commitment tx that previous adaptor sigs committed to. (So ANYPREVOUT\n>> would fix this if it were available)\n>>\n>> So I think this is still a relevant question, even if fast-forwards\n>> make it a rare problem, that perhaps is only applicable to very heavily\n>> used channels.\n>>\n>> (I said the following in email to t-bast already)\n>>\n>> I think doing a synchronous update of commitments to the channel state,\n>> something like:\n>>\n>>    Alice -> Bob: propose_new_commitment\n>>        channel id\n>>        adaptor sigs for PTLCs to Bob\n>>\n>>    Bob -> Alice: agree_new_commitment\n>>        channel id\n>>        adaptor sigs for PTLCs to Alice\n>>        sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n>>          commitment tx\n>>        signature for Alice to spend funding tx\n>>\n>>    Alice -> Bob: finish_new_commitment_1\n>>        channel id\n>>        sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n>>          commitment tx\n>>        signature for Bob to spend funding tx\n>>        reveal old prior commitment secret\n>>        new commitment nonce\n>>\n>>    Bob -> Alice: finish_new_commitment_2\n>>        reveal old prior commitment secret\n>>        new commitment nonce\n>>\n>> would work pretty well.\n>>\n>> This adds half a round-trip compared to now:\n>>\n>>    Alice -> Bob: commitment_signed\n>>    Bob -> Alice: revoke_and_ack, commitment_signed\n>>    Alice -> Bob: revoke_and_ack\n>>\n>> The timings change like so:\n>>\n>>   Bob can use the new commitment after 1.5 round-trips (previously 0.5)\n>>\n>>   Alice can be sure Bob won't use the old commitment after 2 round-trips\n>>   (previously 1)\n>>\n>>   Alice can use the new commitment after 1 round-trip (unchanged)\n>>\n>>   Bob can be sure Alice won't use the old commitment after 1.5 round-trips\n>>   (unchanged -- note: this is what's relevant for forwarding)\n>>\n>> Making the funding tx a musig setup would mean also supplying 64B\n>> of musig2 nonces along with the \"adaptor sigs\" in one direction,\n>> and providing the other side's 64B of musig2 nonces back along with the\n>> (now partial) signature for spending the funding tx (a total of 256B of\n>> nonce data, not 128B).\n>>\n>> Because it keeps both peers' commitments synchronised to a single channel\n>> state, I think the same protocol should work fine with the revocable\n>> signatures on a single tx approach too, though I haven't tried working\n>> through the details.\n>>\n>> Fast forwards would then be reducing the 2 round-trip protocol to\n>> update the state commitment to a 0.5 round-trip update, to reduce\n>> latency when forwarding by the same amount as before (1.5 round-trips\n>> to 0.5 round-trips).\n>>\n>> Cheers,\n>> aj\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/3072a12d/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-12-09T01:34:00",
                "message_text_only": "Hi thread,\n\nI was indeed mistaken. It does require four rounds for both parties to\nfully transition to the next comimit tx and I don't think there is any easy\nway around this. As you've pointed out there it's still only three rounds\nbefore the message is forwarded so no performance decrease for forwarding.\n\nI wanted to add a theoretical note that you might be aware of. The final\nmessage \"Bob -> Alice: revoke_and_ack\" is not strictly necessary. Alice\ndoes not care about Bob revoking a commit tx that gives her strictly more\ncoins. Bob's new commit tx can use the same revocation key as the previous\none i.e. only the offerer of the PTLC/HTLC does a revocation and increments\ntheir revocation key. Not sending messages you don't need to is usually\nboth more performant and simpler but given that it introduces some\nasymmetry so I'm not sure if it's worth it. It's also worth noting that\nwith fast forwards + symmetric commit tx you will need to do the full four\nrounds always I think.\n\nCheers,\n\nLL\n\nOn Thu, 9 Dec 2021 at 02:03, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Hi again AJ and list,\n>\n> I have slightly re-worked your proposal, and came up with the following\n> (I also added the musig2 nonces for completeness):\n>\n> Alice -> Bob: commitment_proposed\n>     channel id\n>     adaptor sigs for PTLCs to Bob in Alice's next commitment\n>     musig nonces for Alice to spend funding tx\n>     musig nonces for Bob to spend funding tx\n>\n> Bob -> Alice: commitment_proposed\n>     channel id\n>     adaptor sigs for PTLCs to Alice in Bob's next commitment\n>     musig nonces for Alice to spend funding tx\n>     musig nonces for Bob to spend funding tx\n>\n> Bob -> Alice: commitment_signed\n>     channel id\n>     signature for Alice to spend funding tx\n>     sigs for Alice to spend HTLCs and PTLCs from her next commitment\n>\n> Alice -> Bob: revoke_and_ack\n>     channel id\n>     reveal previous commitment secret\n>     next commitment point\n>\n> Alice -> Bob: commitment_signed\n>     channel id\n>     signature for Bob to spend funding tx\n>     sigs for Bob to spend HTLCs and PTLCs from his next commitment\n>\n> Bob -> Alice: revoke_and_ack\n>     channel id\n>     reveal previous commitment secret\n>     next commitment point\n>\n> I believe it's exactly the same flow of data between peers as your\n> proposal, but I simply split the data into several messages. Let me\n> know if that's incorrect or if I missed a subtlety in your proposal.\n>\n> This has some small advantages:\n>\n> * commitment_signed and revoke_and_ack are mostly unchanged, we just\n> add a new message before the commit / revoke dance. The only change\n> happens in commitment_signed, where the signatures for PTLC-success\n> transactions will actually become adaptor signatures.\n> * the new adaptor signatures are in commitment_proposed instead of being\n> in commitment_signed, which ensures that we can still have 2*483\n> pending (H|P)TLCs: since the message size is limited to 65kB, we would\n> otherwise decrease our maximum to ~2*335 with your proposal (very rough\n> calculation)\n> * the messages are now symmetrical, which may be easier to reason about\n>\n> One thing to note is that we reversed the order in which participants\n> sign new commitments. We previously had Alice sign first, whereas now\n> if Alice initiates, Bob will sign the updated commitment first. This is\n> why we add only 0.5 RTT instead of 1 RTT compared to the current protocol.\n> I don't think this is an issue, but if someone sees a way to maliciously\n> exploit this, please share it!\n>\n> I updated my article [0], people jumping on the thread now may find it\n> helpful to better understand this discussion.\n>\n> Thanks,\n> Bastien\n>\n> [0] https://github.com/t-bast/lightning-docs/pull/16\n>\n> Le mer. 8 d\u00e9c. 2021 \u00e0 11:00, Bastien TEINTURIER <bastien at acinq.fr> a\n> \u00e9crit :\n>\n>> Hi AJ,\n>>\n>> I think the problem t-bast describes comes up here as well when you\n>>> collapse the fast-forwards (or, anytime you update the commitment\n>>> transaction even if you don't collapse them).\n>>\n>>\n>> Yes, exactly.\n>>\n>> I think doing a synchronous update of commitments to the channel state,\n>>> something like:\n>>\n>>\n>>\n>> Alice -> Bob: propose_new_commitment\n>>> channel id\n>>> adaptor sigs for PTLCs to Bob\n>>\n>>\n>>> Bob -> Alice: agree_new_commitment\n>>> channel id\n>>> adaptor sigs for PTLCs to Alice\n>>> sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n>>> commitment tx\n>>> signature for Alice to spend funding tx\n>>>\n>>> Alice -> Bob: finish_new_commitment_1\n>>> channel id\n>>> sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n>>> commitment tx\n>>> signature for Bob to spend funding tx\n>>> reveal old prior commitment secret\n>>> new commitment nonce\n>>>\n>>> Bob -> Alice: finish_new_commitment_2\n>>> reveal old prior commitment secret\n>>> new commitment nonce\n>>>\n>>> would work pretty well.\n>>\n>>\n>> I agree, this is better than my naive addition of a `remote_ptlcs_signed`\n>> message in both directions, and even though it changes the protocol\n>> messages\n>> it stays very close to the mechanisms we currently have.\n>>\n>> I'll spend some time specifying this in more details, to verify that we're\n>> not missing anything. What I really like about this proposal is that we\n>> can probably bundle that protocol change with `option_simplified_update`\n>> [0]\n>> without the adaptor sigs, and simply add the adaptor sigs as tlvs when we\n>> do PTLCs. That lets us deploy this new update protocol separately from\n>> PTLCs\n>> and ensure it also simplifies the state machine and makes other features\n>> such as splicing [1] and dynamic channel upgrades [2] easier.\n>>\n>> Thanks,\n>> Bastien\n>>\n>> [0] https://github.com/lightning/bolts/pull/867\n>> [1] https://github.com/lightning/bolts/pull/863\n>> [2] https://github.com/lightning/bolts/pull/868\n>>\n>> Le mer. 8 d\u00e9c. 2021 \u00e0 10:29, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n>>\n>>> On Tue, Dec 07, 2021 at 11:52:04PM +0000, ZmnSCPxj via Lightning-dev\n>>> wrote:\n>>> > Alternately, fast-forwards, which avoid this because it does not\n>>> change commitment transactions on the payment-forwarding path.\n>>> > You only change commitment transactions once you have enough changes\n>>> to justify collapsing them.\n>>>\n>>> I think the problem t-bast describes comes up here as well when you\n>>> collapse the fast-forwards (or, anytime you update the commitment\n>>> transaction even if you don't collapse them).\n>>>\n>>> That is, if you have two PTLCs, one from A->B conditional on X, one\n>>> from B->A conditional on Y. Then if A wants to update the commitment tx,\n>>> she needs to\n>>>\n>>>   1) produce a signature to give to B to spend the funding tx\n>>>   2) produce an adaptor signature to authorise B to spend via X from his\n>>>      commitment tx\n>>>   3) produce a signature to allow B to recover Y after timeout from his\n>>>      commitment tx spending to an output she can claim if he cheats\n>>>   4) *receive* an adaptor signature from B to be able to spend the Y\n>>> output\n>>>      if B posts his commitment tx using A's signature in (1)\n>>>\n>>> The problem is, she can't give B the result of (1) until she's received\n>>> (4) from B.\n>>>\n>>> It doesn't matter if the B->A PTLC conditional on Y is in the commitment\n>>> tx itself or within a fast-forward child-transaction -- any previous\n>>> adaptor sig will be invalidated because there's a new commitment\n>>> transaction, and if you allowed any way of spending without an adaptor\n>>> sig, B wouldn't be able to recover the secret and would lose funds.\n>>>\n>>> It also doesn't matter if the commitment transaction that A and B will\n>>> publish is the same or different, only that it's different from the\n>>> commitment tx that previous adaptor sigs committed to. (So ANYPREVOUT\n>>> would fix this if it were available)\n>>>\n>>> So I think this is still a relevant question, even if fast-forwards\n>>> make it a rare problem, that perhaps is only applicable to very heavily\n>>> used channels.\n>>>\n>>> (I said the following in email to t-bast already)\n>>>\n>>> I think doing a synchronous update of commitments to the channel state,\n>>> something like:\n>>>\n>>>    Alice -> Bob: propose_new_commitment\n>>>        channel id\n>>>        adaptor sigs for PTLCs to Bob\n>>>\n>>>    Bob -> Alice: agree_new_commitment\n>>>        channel id\n>>>        adaptor sigs for PTLCs to Alice\n>>>        sigs for Alice to spend HTLCs and PTLCs to Bob from her own\n>>>          commitment tx\n>>>        signature for Alice to spend funding tx\n>>>\n>>>    Alice -> Bob: finish_new_commitment_1\n>>>        channel id\n>>>        sigs for Bob to spend HTLCs and PTLCs to Alice from his own\n>>>          commitment tx\n>>>        signature for Bob to spend funding tx\n>>>        reveal old prior commitment secret\n>>>        new commitment nonce\n>>>\n>>>    Bob -> Alice: finish_new_commitment_2\n>>>        reveal old prior commitment secret\n>>>        new commitment nonce\n>>>\n>>> would work pretty well.\n>>>\n>>> This adds half a round-trip compared to now:\n>>>\n>>>    Alice -> Bob: commitment_signed\n>>>    Bob -> Alice: revoke_and_ack, commitment_signed\n>>>    Alice -> Bob: revoke_and_ack\n>>>\n>>> The timings change like so:\n>>>\n>>>   Bob can use the new commitment after 1.5 round-trips (previously 0.5)\n>>>\n>>>   Alice can be sure Bob won't use the old commitment after 2 round-trips\n>>>   (previously 1)\n>>>\n>>>   Alice can use the new commitment after 1 round-trip (unchanged)\n>>>\n>>>   Bob can be sure Alice won't use the old commitment after 1.5\n>>> round-trips\n>>>   (unchanged -- note: this is what's relevant for forwarding)\n>>>\n>>> Making the funding tx a musig setup would mean also supplying 64B\n>>> of musig2 nonces along with the \"adaptor sigs\" in one direction,\n>>> and providing the other side's 64B of musig2 nonces back along with the\n>>> (now partial) signature for spending the funding tx (a total of 256B of\n>>> nonce data, not 128B).\n>>>\n>>> Because it keeps both peers' commitments synchronised to a single channel\n>>> state, I think the same protocol should work fine with the revocable\n>>> signatures on a single tx approach too, though I haven't tried working\n>>> through the details.\n>>>\n>>> Fast forwards would then be reducing the 2 round-trip protocol to\n>>> update the state commitment to a 0.5 round-trip update, to reduce\n>>> latency when forwarding by the same amount as before (1.5 round-trips\n>>> to 0.5 round-trips).\n>>>\n>>> Cheers,\n>>> aj\n>>>\n>>> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/dcadd171/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-12-09T05:00:16",
                "message_text_only": "On Thu, Dec 09, 2021 at 12:34:00PM +1100, Lloyd Fournier wrote:\n> I wanted to add a theoretical note that you might be aware of. The final\n> message \"Bob -> Alice: revoke_and_ack\" is not strictly necessary. Alice\n> does not care about Bob revoking a commit tx that gives her strictly more\n> coins.\n\nThat's true if Alice is only sending new tx's paying Bob; and Rusty's\nexamples in the `option_simplified_update` proposal do only include new\nHTLCs...\n\nBut I think it's intended to cover *all* update messages, and if Alice is\nalso including any `update_fulfill_htlc` or `update_fail_htlc` messages in\nthe commitment, she's potentially gaining funds, both for the amount of\nfees she saves by avoiding extra transactions, but for the fulfill case,\npotentially also because she doesn't need to worry about the fulfilled\nhtlc reaching its timeout.\n\nActually, as an alternative to the `option_simplified_update` approach,\nhas anyone considered an approach more like this:\n\n * each node can unilaterally send various messages that always update\n   the state, eg:\n     + new htlc/ptlc paying the other node (update_add_htlc)\n     + secret reveal of htlc/ptlc paying self (update_fulfil_htlc)\n     + rejection of htlc/ptlc paying self (update_fail_htlc)\n     + timeout of htlc/ptlc paying the other node (not currently allowed?)\n     + update the channel fee rate (update_fee)\n\n * continue to allow these to occur at any time, asynchronously, but\n   to make it easier to keep track of them, add a uint64_t counter\n   to each message, that each peer increments by 1 for each message.\n\n * each channel state (n) then corresponds to the accumulation of\n   updates from each each peer, up to message (a) for Alice, and message\n   (b) for Bob.\n\n * so when updating to a new commitment (n+1), the proposal message\n   should just include both update values (a') and (b')\n\n * nodes can then track the state by having a list of\n   htlcs/ptlcs/balances, etc for state (n), and a list of unapplied\n   update messages for themselves and the other party (a+1,...,a') and\n   (b+1,...,b'), and apply them in order when constructing the new state\n   (n+1) for a new commitment signing round\n\nI think that retains both the interesting async bits (anyone can queue\nstate updates immediately) but also makes it fairly simple to maintain\nthe state?\n\n> Bob's new commit tx can use the same revocation key as the previous\n> one\n\nThat's a neat idea, but I think the fail/fulfill messages break it.\n_But_ I think that means it would still be an interesting technique to\nuse for fast forwards which get updated for every add message...\n\n> Not sending messages you don't need to is usually\n> both more performant and simpler \n\nThe extra message from Bob allows Alice to discard the adaptor sigs\nassociated with the old state, which I think is probably worthwhile\nanyway?\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-12-19T22:23:44",
                "message_text_only": "On Wed, Dec 08, 2021 at 04:02:02PM +0100, Bastien TEINTURIER wrote:\n> I updated my article [0], people jumping on the thread now may find it\n> helpful to better understand this discussion.\n> [0] https://github.com/t-bast/lightning-docs/pull/16\n\nSince merged, so https://github.com/t-bast/lightning-docs/blob/master/taproot-updates.md\n\nSo imagine that this proposal is finished and widely adopted/deployed\nand someone adds an additional feature bit that allows a channel to\nforward PTLCs only, no HTLCs.\n\nThen suppose that you forget every old PTLC, because you don't like\nhaving your channel state grow without bound. What happens if your\ncounterparty broadcasts an old state?\n\n * the musig2 channel funding is irrelevant -- the funding tx has been\n   spend at this point\n \n * the unspent commitment outputs pay to:\n     to_local: ipk = musig(revkey, mykey) -- known ; scripts also known\n     to_remote: claimable in 1 block, would be better if ipk was also musig\n     *_anchor: dust, who cares -- might be better if local_anchor used\n        key = revkey\n     *_htlc: irrelevant by definition\n     local_ptlc: ipk = musig(revkey, mykey) -- known; scripts also known\n\n * commitment outputs may be immediately spent via layered txs. if so,\n   their outputs are: ipk = musig(revkey, mykey); with fixed scripts,\n   that include a relative timelock\n\nSo provided you know the revocation key (which you do, because it's an\nold transaction and that only requires log(states) data to reconstruct)\nand your own private key, you can reconstruct all the scripts and use\nkey path spends for every output immediately (excepting the local_anchor,\nand to_remote is delayed by a block).\n\nSo while this doesn't achieve eltoo's goal of \"no toxic waste\", I believe\nit does achieve the goal of \"state information is bounded no matter\nhow long you leave the channel open / how many transactions travel over\nthe channel\".\n\n(Provided you're willing to wait for the other party to attempt to claim\na htlc via their layered transaction, you can use this strategy for\nhtlcs as well as ptlcs -- however this leaves you the risk that they\nnever attempt to claim the funds, which may leave you out of pocket,\nand may give them the opportunity to do an attack along the lines of\n\"you don't get access to the $10,000 locked in old HTLCs unless you pay\nme $1,000\".  So I don't think that's really a smart thing to do)\n\nCheers,\naj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-21T15:25:41",
                "message_text_only": "Hey AJ and list,\n\nThat's a very good point, it's really worth highlighting!\n\nThe reason we have \"toxic waste\" with HTLCs is because we commit to the\npayment_hash directly inside the transaction scripts, so we need to\nremember all the payment_hash we've seen to be able to recreate the\nscripts (and spend the outputs, even if they are revoked).\n\nBut with PTLCs, we commit to a payment_point outside of the scripts (in\nthe adaptor signature that is exchanged), so we're able to recreate the\nscripts independently of the payment details! This also means that the\npayment_point never appears on-chain (which is good for privacy) whereas\nthe payment_hash does appear on-chain for HTLCs.\n\n*_anchor: dust, who cares -- might be better if local_anchor used key =\n> revkey\n\n\nI don't think we can use revkey, this would prevent us from bumping the\ncurrent remote commitment if it appears on-chain (because we don't know\nthe private revkey yet if this is the latest commitment). Usually the\nremote peer should bump it, but if they don't, we may want to bump it\nourselves instead of publishing our own commitment (where our main\noutput has a long CSV).\n\nBut as you already mentioned, who cares, it's dust and we don't even need\nit to CPFP the revoked commitment, we can use any other output since the\nrevocation path isn't encumbered with a CSV 1.\n\nCheers,\nBastien\n\nLe dim. 19 d\u00e9c. 2021 \u00e0 23:23, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Wed, Dec 08, 2021 at 04:02:02PM +0100, Bastien TEINTURIER wrote:\n> > I updated my article [0], people jumping on the thread now may find it\n> > helpful to better understand this discussion.\n> > [0] https://github.com/t-bast/lightning-docs/pull/16\n>\n> Since merged, so\n> https://github.com/t-bast/lightning-docs/blob/master/taproot-updates.md\n>\n> So imagine that this proposal is finished and widely adopted/deployed\n> and someone adds an additional feature bit that allows a channel to\n> forward PTLCs only, no HTLCs.\n>\n> Then suppose that you forget every old PTLC, because you don't like\n> having your channel state grow without bound. What happens if your\n> counterparty broadcasts an old state?\n>\n>  * the musig2 channel funding is irrelevant -- the funding tx has been\n>    spend at this point\n>\n>  * the unspent commitment outputs pay to:\n>      to_local: ipk = musig(revkey, mykey) -- known ; scripts also known\n>      to_remote: claimable in 1 block, would be better if ipk was also musig\n>      *_anchor: dust, who cares -- might be better if local_anchor used\n>         key = revkey\n>      *_htlc: irrelevant by definition\n>      local_ptlc: ipk = musig(revkey, mykey) -- known; scripts also known\n>\n>  * commitment outputs may be immediately spent via layered txs. if so,\n>    their outputs are: ipk = musig(revkey, mykey); with fixed scripts,\n>    that include a relative timelock\n>\n> So provided you know the revocation key (which you do, because it's an\n> old transaction and that only requires log(states) data to reconstruct)\n> and your own private key, you can reconstruct all the scripts and use\n> key path spends for every output immediately (excepting the local_anchor,\n> and to_remote is delayed by a block).\n>\n> So while this doesn't achieve eltoo's goal of \"no toxic waste\", I believe\n> it does achieve the goal of \"state information is bounded no matter\n> how long you leave the channel open / how many transactions travel over\n> the channel\".\n>\n> (Provided you're willing to wait for the other party to attempt to claim\n> a htlc via their layered transaction, you can use this strategy for\n> htlcs as well as ptlcs -- however this leaves you the risk that they\n> never attempt to claim the funds, which may leave you out of pocket,\n> and may give them the opportunity to do an attack along the lines of\n> \"you don't get access to the $10,000 locked in old HTLCs unless you pay\n> me $1,000\".  So I don't think that's really a smart thing to do)\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211221/471cbd0d/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2021-12-21T16:04:03",
                "message_text_only": "On Tue, Dec 21, 2021 at 04:25:41PM +0100, Bastien TEINTURIER wrote:\n> The reason we have \"toxic waste\" with HTLCs is because we commit to the\n> payment_hash directly inside the transaction scripts, so we need to\n> remember all the payment_hash we've seen to be able to recreate the\n> scripts (and spend the outputs, even if they are revoked).\n\nI think \"toxic waste\" refers to having old data around that, if used,\ncould cause you to lose all the funds in your channel -- that's why it's\ntoxic. This is more just regular landfill :)\n\n> *_anchor: dust, who cares -- might be better if local_anchor used key =\n> > revkey\n> I don't think we can use revkey, \n\nmusig(revkey, remote_key) \n  --> allows them to spend after you've revealed the secret for revkey\n      you can never spend because you'll never know the secret for\n      remote_key\n\nbut if you just say:\n\n(revkey)\n\nthen you can spend (because you know revkey) immediately (because it's\nan anchor output, so intended to be immediately spent) or they can spend\nif it's an obsolete commitment and you've revealed the revkey secret.\n\n> this would prevent us from bumping the\n> current remote commitment if it appears on-chain (because we don't know\n> the private revkey yet if this is the latest commitment). Usually the\n> remote peer should bump it, but if they don't, we may want to bump it\n> ourselves instead of publishing our own commitment (where our main\n> output has a long CSV).\n\nIf we're going to bump someone else's commitment, we'll use the\nremote_anchor they provided, not the local_anchor, so I think this is\nfine (as long as I haven't gotten local/remote confused somewhere along\nthe way).\n\nCheers,\naj"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-22T08:02:23",
                "message_text_only": "Hey AJ,\n\nRight, I was probably confused between local/remote, especially when\nwe're talking about our anchor in the remote commitment (should it be\ncalled local anchor, which is from our point of view, or remote?).\n\nLet's call them Alice and Bob, and Bob is publishing a commitment.\nCorrect me if I'm wrong there, what you're suggesting is that:\n\n* Bob's anchor on Bob's commitment can be spent with revkey\n* Alice's anchor on Bob's commitment can be spent with Alice's pubkey\n\nThis does ensure that each participant is able to claim their anchor in\nthe latest commitment, and Alice is able to claim both anchors in any of\nBob's outdated commitments.\n\nBut I think it defeats the `OP_16 OP_CHECKSEQUENCEVERIFY` script branch.\nWe have that branch to allow anyone to spend anchor outputs *after* the\ncommitment is confirmed, to avoid keeping them around in the utxo set\nforever. However, the trick is that the internal pubkey must be set to\nsomething that is publicly revealed when the channel closes. Now that we\nput the revkey in internal pubkeys everywhere instead of script branches,\nthat revkey is *not* revealed when channels close with the latest commit.\nSo it would prevent people from using that script branch to clean up the\nutxo set...\n\nI have currently used <local_delayedpubkey> and <remote_pubkey> because\nthey're revealed whenever main outputs are claimed, but there is probably\na smarter solution (maybe one that would let us use revkey here as you\nsuggest), this will be worth thinking about a bit more.\n\nThanks,\nBastien\n\nLe mar. 21 d\u00e9c. 2021 \u00e0 17:04, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Tue, Dec 21, 2021 at 04:25:41PM +0100, Bastien TEINTURIER wrote:\n> > The reason we have \"toxic waste\" with HTLCs is because we commit to the\n> > payment_hash directly inside the transaction scripts, so we need to\n> > remember all the payment_hash we've seen to be able to recreate the\n> > scripts (and spend the outputs, even if they are revoked).\n>\n> I think \"toxic waste\" refers to having old data around that, if used,\n> could cause you to lose all the funds in your channel -- that's why it's\n> toxic. This is more just regular landfill :)\n>\n> > *_anchor: dust, who cares -- might be better if local_anchor used key =\n> > > revkey\n> > I don't think we can use revkey,\n>\n> musig(revkey, remote_key)\n>   --> allows them to spend after you've revealed the secret for revkey\n>       you can never spend because you'll never know the secret for\n>       remote_key\n>\n> but if you just say:\n>\n> (revkey)\n>\n> then you can spend (because you know revkey) immediately (because it's\n> an anchor output, so intended to be immediately spent) or they can spend\n> if it's an obsolete commitment and you've revealed the revkey secret.\n>\n> > this would prevent us from bumping the\n> > current remote commitment if it appears on-chain (because we don't know\n> > the private revkey yet if this is the latest commitment). Usually the\n> > remote peer should bump it, but if they don't, we may want to bump it\n> > ourselves instead of publishing our own commitment (where our main\n> > output has a long CSV).\n>\n> If we're going to bump someone else's commitment, we'll use the\n> remote_anchor they provided, not the local_anchor, so I think this is\n> fine (as long as I haven't gotten local/remote confused somewhere along\n> the way).\n>\n> Cheers,\n> aj\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211222/84da9f4a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "PTLCs early draft specification",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Anthony Towns",
                "ZmnSCPxj",
                "Lloyd Fournier"
            ],
            "messages_count": 16,
            "total_messages_chars_count": 63952
        }
    },
    {
        "title": "[Lightning-dev] Take 2: Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-12-08T01:28:42",
                "message_text_only": "Bitcoin Devs (+cc lightning-dev),\n\nEarlier this year I proposed allowing 0 value outputs and that was shot\ndown for various reasons, see\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-August/019307.html\n\nI think that there can be a simple carve out now that package relay is\nbeing launched based on my research into covenants from 2017\nhttps://rubin.io/public/pdfs/multi-txn-contracts.pdf.\n\nEssentially, if we allow 0 value outputs BUT require as a matter of policy\n(or consensus, but policy has major advantages) that the output be used as\nan Intermediate Output (that is, in order for the transaction to be\ncreating it to be in the mempool it must be spent by another tx)  with the\nadditional rule that the parent must have a higher feerate after CPFP'ing\nthe parent than the parent alone we can both:\n\n1) Allow 0 value outputs for things like Anchor Outputs (very good for not\ngetting your eltoo/Decker channels pinned by junk witness data using Anchor\nInputs, very good for not getting your channels drained by at-dust outputs)\n2) Not allow 0 value utxos to proliferate long\n3) It still being valid for a 0 value that somehow gets created to be spent\nby the fee paying txn later\n\nJust doing this as a mempool policy also has the benefits of not\nintroducing any new validation rules. Although in general the IUTXO concept\nis very attractive, it complicates mempool :(\n\nI understand this may also be really helpful for CTV based contracts (like\nvault continuation hooks) as well as things like spacechains.\n\nSuch a rule -- if it's not clear -- presupposes a fully working package\nrelay system.\n\nI believe that this addresses all the issues with allowing 0 value outputs\nto be created for the narrow case of immediately spendable outputs.\n\nCheers,\n\nJeremy\n\np.s. why another post today? Thank Greg\nhttps://twitter.com/JeremyRubin/status/1468390561417547780\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211207/1a309947/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Take 2: Removing the Dust Limit",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2146
        }
    },
    {
        "title": "[Lightning-dev] [bitcoin-dev] Take 2: Removing the Dust Limit",
        "thread_messages": [
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-08T08:34:32",
                "message_text_only": "Hi Jeremy,\n\nRight now, lightning anchor outputs use a 330 sats amount. Each commitment\ntransaction has two such outputs, and only one of them is spent to help the\ntransaction get confirmed, so the other stays there and bloats the utxo set.\nWe allow anyone to spend them after a csv of 16 blocks, in the hope that\nsomeone will claim a batch of them when the fees are low and remove them\nfrom the utxo set. However, that trick wouldn't work with 0-value outputs,\nas\nno-one would ever claim them (doesn't make economical sense).\n\nWe actually need to have two of them to avoid pinning: each participant is\nable to spend only one of these outputs while the parent tx is unconfirmed.\nI believe N-party protocols would likely need N such outputs (not sure).\n\nYou mention a change to the carve-out rule, can you explain it further?\nI believe it would be a necessary step, otherwise 0-value outputs for\nCPFP actually seem worse than low-value ones...\n\nThanks,\nBastien\n\nLe mer. 8 d\u00e9c. 2021 \u00e0 02:29, Jeremy via bitcoin-dev <\nbitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Bitcoin Devs (+cc lightning-dev),\n>\n> Earlier this year I proposed allowing 0 value outputs and that was shot\n> down for various reasons, see\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-August/019307.html\n>\n> I think that there can be a simple carve out now that package relay is\n> being launched based on my research into covenants from 2017\n> https://rubin.io/public/pdfs/multi-txn-contracts.pdf.\n>\n> Essentially, if we allow 0 value outputs BUT require as a matter of policy\n> (or consensus, but policy has major advantages) that the output be used as\n> an Intermediate Output (that is, in order for the transaction to be\n> creating it to be in the mempool it must be spent by another tx)  with the\n> additional rule that the parent must have a higher feerate after CPFP'ing\n> the parent than the parent alone we can both:\n>\n> 1) Allow 0 value outputs for things like Anchor Outputs (very good for not\n> getting your eltoo/Decker channels pinned by junk witness data using Anchor\n> Inputs, very good for not getting your channels drained by at-dust outputs)\n> 2) Not allow 0 value utxos to proliferate long\n> 3) It still being valid for a 0 value that somehow gets created to be\n> spent by the fee paying txn later\n>\n> Just doing this as a mempool policy also has the benefits of not\n> introducing any new validation rules. Although in general the IUTXO concept\n> is very attractive, it complicates mempool :(\n>\n> I understand this may also be really helpful for CTV based contracts (like\n> vault continuation hooks) as well as things like spacechains.\n>\n> Such a rule -- if it's not clear -- presupposes a fully working package\n> relay system.\n>\n> I believe that this addresses all the issues with allowing 0 value outputs\n> to be created for the narrow case of immediately spendable outputs.\n>\n> Cheers,\n>\n> Jeremy\n>\n> p.s. why another post today? Thank Greg\n> https://twitter.com/JeremyRubin/status/1468390561417547780\n>\n>\n> --\n> @JeremyRubin <https://twitter.com/JeremyRubin>\n> <https://twitter.com/JeremyRubin>\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/58427839/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2021-12-08T10:46:22",
                "message_text_only": "Hi Jeremy,\n\nI brought up the exact same thing at coredev, but unfortunately I came up\nwith a way in which the 0 sat output could still enter the UTXO set under\nthose rules:\n\n- Parent P1 (0 sat per byte) has 2 outputs, one is 0 sat\n- Child C1 spends the 0 sat output for a combined feerate of 1 sat per byte\nand they enter the mempool as a package\n- Child C2 spends the other output of P1 with a really high feerate and\nenters the mempool\n- Fees rise and child C1 falls out of the mempool, leaving the 0 sat output\nunspent\n\nFor this to not be a problem, the 0 sat output needs to provably be the\nonly spendable output. As you pointed out to me a few days ago, having a\nrelative timelock on the other outputs would do the trick (and this happens\nto be true for spacechains), but that will only be provable if all script\nconditions are visible prior to spending time (ruling out p2sh and taproot,\nand conflicting with standardness rules for transactions).\n\nIt's worth noting out that you can't really make a policy rule that says\nthe 0 sat output can't be left unspent (i.e. C1 can't be evicted without\nalso evicting P1), as this would not mirror economically rational behavior\nfor miners (they would get more fees if they evicted C1, so we must assume\nthey will, if the transaction ever reaches them).\n\nThis last example really points out the tricky situation we're dealing\nwith. In my opinion, we'd only want to relay 0 sat outputs if we can\nguarantee that it's never economically profitable to mine them without them\ngetting spent in the same block.\n\nFinally, here's a timestamped link to a diagram that shows where 0 sat\noutputs would be helpful for spacechains (otherwise someone would have to\npay the dust up front for countless outputs):\nhttps://youtu.be/N2ow4Q34Jeg?t=2556\n\nCheers,\nRuben\n\n\n\n\nOn Wed, Dec 8, 2021 at 9:35 AM Bastien TEINTURIER <bastien at acinq.fr> wrote:\n\n> Hi Jeremy,\n>\n> Right now, lightning anchor outputs use a 330 sats amount. Each commitment\n> transaction has two such outputs, and only one of them is spent to help the\n> transaction get confirmed, so the other stays there and bloats the utxo\n> set.\n> We allow anyone to spend them after a csv of 16 blocks, in the hope that\n> someone will claim a batch of them when the fees are low and remove them\n> from the utxo set. However, that trick wouldn't work with 0-value outputs,\n> as\n> no-one would ever claim them (doesn't make economical sense).\n>\n> We actually need to have two of them to avoid pinning: each participant is\n> able to spend only one of these outputs while the parent tx is unconfirmed.\n> I believe N-party protocols would likely need N such outputs (not sure).\n>\n> You mention a change to the carve-out rule, can you explain it further?\n> I believe it would be a necessary step, otherwise 0-value outputs for\n> CPFP actually seem worse than low-value ones...\n>\n> Thanks,\n> Bastien\n>\n> Le mer. 8 d\u00e9c. 2021 \u00e0 02:29, Jeremy via bitcoin-dev <\n> bitcoin-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Bitcoin Devs (+cc lightning-dev),\n>>\n>> Earlier this year I proposed allowing 0 value outputs and that was shot\n>> down for various reasons, see\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-August/019307.html\n>>\n>> I think that there can be a simple carve out now that package relay is\n>> being launched based on my research into covenants from 2017\n>> https://rubin.io/public/pdfs/multi-txn-contracts.pdf.\n>>\n>> Essentially, if we allow 0 value outputs BUT require as a matter of\n>> policy (or consensus, but policy has major advantages) that the output be\n>> used as an Intermediate Output (that is, in order for the transaction to be\n>> creating it to be in the mempool it must be spent by another tx)  with the\n>> additional rule that the parent must have a higher feerate after CPFP'ing\n>> the parent than the parent alone we can both:\n>>\n>> 1) Allow 0 value outputs for things like Anchor Outputs (very good for\n>> not getting your eltoo/Decker channels pinned by junk witness data using\n>> Anchor Inputs, very good for not getting your channels drained by at-dust\n>> outputs)\n>> 2) Not allow 0 value utxos to proliferate long\n>> 3) It still being valid for a 0 value that somehow gets created to be\n>> spent by the fee paying txn later\n>>\n>> Just doing this as a mempool policy also has the benefits of not\n>> introducing any new validation rules. Although in general the IUTXO concept\n>> is very attractive, it complicates mempool :(\n>>\n>> I understand this may also be really helpful for CTV based contracts\n>> (like vault continuation hooks) as well as things like spacechains.\n>>\n>> Such a rule -- if it's not clear -- presupposes a fully working package\n>> relay system.\n>>\n>> I believe that this addresses all the issues with allowing 0 value\n>> outputs to be created for the narrow case of immediately spendable outputs.\n>>\n>> Cheers,\n>>\n>> Jeremy\n>>\n>> p.s. why another post today? Thank Greg\n>> https://twitter.com/JeremyRubin/status/1468390561417547780\n>>\n>>\n>> --\n>> @JeremyRubin <https://twitter.com/JeremyRubin>\n>> <https://twitter.com/JeremyRubin>\n>> _______________________________________________\n>> bitcoin-dev mailing list\n>> bitcoin-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/7634150b/attachment-0001.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-12-08T17:41:34",
                "message_text_only": "IMO this is not a big problem. The problem is not if a 0 value ever enters\nthe mempool, it's if it is never spent. And even if C2/P1 goes in, C1 still\ncan be spent. In fact, it increases it's feerate with P1's confirmation so\nit's somewhat likely it would go in. C2 further has to be pretty expensive\ncompared to C1 in order to be mined when C2 would not be, so the user\ntrying to do this has to pay for it.\n\nIf we're worried it might never be spent again since no incentive, it's\nrational for miners *and users who care about bloat* to save to disk the\ntransaction spending it to resurrect it. The way this can be broken is if\nthe txn has two inputs and that input gets spent separately.\n\nThat said, I think if we can say that taking advantage of keeping the 0\nvalue output will cost you more than if you just made it above dust\nthreshold, it shouldn't be economically rational to not just do a dust\nthreshold value output instead.\n\nSo I'm not sure the extent to which we should bend backwards to make 0\nvalue outputs impossible v.s. making them inconvenient enough to not be\npopular.\n\n\n\n-------------------------------------\nConsensus changes below:\n-------------------------------------\n\nAnother possibility is to have a utxo with drop semantics; if UTXO X with\nsome flag on it is not spent in the block it is created, it expires and can\nnever be spent. This is essentially an inverse timelock, but severely\nlimited to one block and mempool evictions can be handled as if a conflict\nwere mined.\n\nThese types of 0 value outputs could be present just for attaching fee in\nthe mempool but be treated like an op_return otherwise. We could add two\ncases for this: one bare segwit version (just the number, no data) and one\nthat's equivalent to taproot. This covers OP_TRUE anchors very efficiently\nand ones that require a signature as well.\n\nThis is relatively similar to how Transaction Sponsors works, but without\nfull tx graph de-linkage... obviously I think if we'll entertain a\nconsensus change, sponsors makes more sense, but expiring utxos doesn't\nchange as many properties of the tx-graph validation so might be simpler.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/5bf1bd84/attachment.html>"
            },
            {
                "author": "Ruben Somsen",
                "date": "2021-12-08T22:51:50",
                "message_text_only": "Hi Jeremy,\n\nThanks for sharing your thoughts.\n\nTo summarize your arguments: the intentionally malicious path to getting\nthe 0 sat output confirmed without being spent is uneconomical compared to\nsimply creating dust outputs. And even if it does happen, the tx spending\nfrom the 0 sat output may still be valid (as long as none of its inputs get\nspent elsewhere) and could eventually get confirmed.\n\nI think those are good points. I do still see a possibility where a user\nnon-maliciously happens to behave in a way that causes all of the above to\nhappen, but it does seem somewhat unlikely.\n\nIt could happen if all of the following occurs:\n1. Another output happens to get spent at a higher feerate (e.g. because an\nabsolute timelock expires and the output gets used)\n2. The tx spending the 0 sat output then happens to not make it into the\nblock due to the lower fees\n3. The user then happens to invalidate the tx that was spending from the 0\nsat output (seems rational at that point)\n\nAssuming this is the only scenario (I am at least not currently aware of\nothers), the question then becomes whether the above is acceptable in order\nto avoid a soft fork.\n\nCheers,\nRuben\n\n\nOn Wed, Dec 8, 2021 at 6:41 PM Jeremy <jlrubin at mit.edu> wrote:\n\n> IMO this is not a big problem. The problem is not if a 0 value ever enters\n> the mempool, it's if it is never spent. And even if C2/P1 goes in, C1 still\n> can be spent. In fact, it increases it's feerate with P1's confirmation so\n> it's somewhat likely it would go in. C2 further has to be pretty expensive\n> compared to C1 in order to be mined when C2 would not be, so the user\n> trying to do this has to pay for it.\n>\n> If we're worried it might never be spent again since no incentive, it's\n> rational for miners *and users who care about bloat* to save to disk the\n> transaction spending it to resurrect it. The way this can be broken is if\n> the txn has two inputs and that input gets spent separately.\n>\n> That said, I think if we can say that taking advantage of keeping the 0\n> value output will cost you more than if you just made it above dust\n> threshold, it shouldn't be economically rational to not just do a dust\n> threshold value output instead.\n>\n> So I'm not sure the extent to which we should bend backwards to make 0\n> value outputs impossible v.s. making them inconvenient enough to not be\n> popular.\n>\n>\n>\n> -------------------------------------\n> Consensus changes below:\n> -------------------------------------\n>\n> Another possibility is to have a utxo with drop semantics; if UTXO X with\n> some flag on it is not spent in the block it is created, it expires and can\n> never be spent. This is essentially an inverse timelock, but severely\n> limited to one block and mempool evictions can be handled as if a conflict\n> were mined.\n>\n> These types of 0 value outputs could be present just for attaching fee in\n> the mempool but be treated like an op_return otherwise. We could add two\n> cases for this: one bare segwit version (just the number, no data) and one\n> that's equivalent to taproot. This covers OP_TRUE anchors very efficiently\n> and ones that require a signature as well.\n>\n> This is relatively similar to how Transaction Sponsors works, but without\n> full tx graph de-linkage... obviously I think if we'll entertain a\n> consensus change, sponsors makes more sense, but expiring utxos doesn't\n> change as many properties of the tx-graph validation so might be simpler.\n>\n>\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/8f8b4e60/attachment.html>"
            },
            {
                "author": "damian at willtech.com.au",
                "date": "2021-12-09T06:27:04",
                "message_text_only": "Good Afternoon,\n\n'Avoiding a soft-fork' is a political concession. Consensus is none of \nthat.\n\nKING JAMES HRMH\nGreat British Empire\n\nRegards,\nThe Australian\nLORD HIS EXCELLENCY JAMES HRMH (& HMRH)\nof Hougun Manor & Glencoe & British Empire\nMR. Damian A. James Williamson\nWills\n\net al.\n\n\nWilltech\nwww.willtech.com.au\nwww.go-overt.com\nand other projects\n\nearn.com/willtech\nlinkedin.com/in/damianwilliamson\n\n\nm. 0487135719\nf. +61261470192\n\n\nThis email does not constitute a general advice. Please disregard this \nemail if misdelivered.\nOn 2021-12-08 14:51, Ruben Somsen via bitcoin-dev wrote:\n> Hi Jeremy,\n> \n> Thanks for sharing your thoughts.\n> \n> To summarize your arguments: the intentionally malicious path to\n> getting the 0 sat output confirmed without being spent is uneconomical\n> compared to simply creating dust outputs. And even if it does happen,\n> the tx spending from the 0 sat output may still be valid (as long as\n> none of its inputs get spent elsewhere) and could eventually get\n> confirmed.\n> \n> I think those are good points. I do still see a possibility where a\n> user non-maliciously happens to behave in a way that causes all of the\n> above to happen, but it does seem somewhat unlikely.\n> \n> It could happen if all of the following occurs:\n> 1. Another output happens to get spent at a higher feerate (e.g.\n> because an absolute timelock expires and the output gets used)\n> 2. The tx spending the 0 sat output then happens to not make it into\n> the block due to the lower fees\n> 3. The user then happens to invalidate the tx that was spending from\n> the 0 sat output (seems rational at that point)\n> \n> Assuming this is the only scenario (I am at least not currently aware\n> of others), the question then becomes whether the above is acceptable\n> in order to avoid a soft fork.\n> \n> Cheers,\n> Ruben\n> \n> On Wed, Dec 8, 2021 at 6:41 PM Jeremy <jlrubin at mit.edu> wrote:\n> \n>> IMO this is not a big problem. The problem is not if a 0 value ever\n>> enters the mempool, it's if it is never spent. And even if C2/P1\n>> goes in, C1 still can be spent. In fact, it increases it's feerate\n>> with P1's confirmation so it's somewhat likely it would go in. C2\n>> further has to be pretty expensive compared to C1 in order to be\n>> mined when C2 would not be, so the user trying to do this has to pay\n>> for it.\n>> \n>> If we're worried it might never be spent again since no incentive,\n>> it's rational for miners *and users who care about bloat* to save to\n>> disk the transaction spending it to resurrect it. The way this can\n>> be broken is if the txn has two inputs and that input gets spent\n>> separately.\n>> \n>> That said, I think if we can say that taking advantage of keeping\n>> the 0 value output will cost you more than if you just made it above\n>> dust threshold, it shouldn't be economically rational to not just do\n>> a dust threshold value output instead.\n>> \n>> So I'm not sure the extent to which we should bend backwards to make\n>> 0 value outputs impossible v.s. making them inconvenient enough to\n>> not be popular.\n>> \n>> -------------------------------------\n>> Consensus changes below:\n>> -------------------------------------\n>> \n>> Another possibility is to have a utxo with drop semantics; if UTXO X\n>> with some flag on it is not spent in the block it is created, it\n>> expires and can never be spent. This is essentially an inverse\n>> timelock, but severely limited to one block and mempool evictions\n>> can be handled as if a conflict were mined.\n>> \n>> These types of 0 value outputs could be present just for attaching\n>> fee in the mempool but be treated like an op_return otherwise. We\n>> could add two cases for this: one bare segwit version (just the\n>> number, no data) and one that's equivalent to taproot. This covers\n>> OP_TRUE anchors very efficiently and ones that require a signature\n>> as well.\n>> \n>> This is relatively similar to how Transaction Sponsors works, but\n>> without full tx graph de-linkage... obviously I think if we'll\n>> entertain a consensus change, sponsors makes more sense, but\n>> expiring utxos doesn't change as many properties of the tx-graph\n>> validation so might be simpler.\n> _______________________________________________\n> bitcoin-dev mailing list\n> bitcoin-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev"
            },
            {
                "author": "Jeremy",
                "date": "2021-12-08T17:18:49",
                "message_text_only": "Bastien,\n\nThe issue is that with Decker Channels you either use SIGHASH_ALL / APO and\ndon't allow adding outs (this protects against certain RBF pinning on the\nroot with bloated wtxid data) and have anchor outputs or you do allow them\nand then are RBF pinnable (but can have change).\n\nAssuming you use anchor outs, then you really can't use dust-threshold\noutputs as it either breaks the ratcheting update validity (if the specific\namount paid to output matters) OR it allows many non-latest updates to\nfully drain the UTXO of any value.\n\nYou can get around the needing for N of them by having a congestion-control\ntree setup in theory; then you only need log(n) data for one bumper, and\n(say) 1.25x the data if all N want to bump. This can be a nice trade-off\nbetween letting everyone bump and not. Since these could be chains of\nIUTXO, they don't need to carry any weight directly.\n\nThe carve out would just be to ensure that CPFP 0 values are known how to\nbe spent.\n\n\n\n\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211208/8dfaefad/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Take 2: Removing the Dust Limit",
            "categories": [
                "Lightning-dev",
                "bitcoin-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "damian at willtech.com.au",
                "Jeremy",
                "Ruben Somsen"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 20637
        }
    },
    {
        "title": "[Lightning-dev] BOLT 2 question",
        "thread_messages": [
            {
                "author": "Benjamin Weintraub",
                "date": "2021-12-09T20:10:10",
                "message_text_only": "Hi all,\n\nI have a question about BOLT #2. What exactly does it mean to \"fail the channel\"? In the section for \"update_add_htlc,\" the follwing text is written:\n\n  *   receiving an amount_msat equal to 0, OR less than its own htlc_minimum_msat:\n     *   SHOULD fail the channel.\n  *   receiving an amount_msat that the sending node cannot afford at the current feerate_per_kw (while maintaining its channel reserve and any to_local_anchor and to_remote_anchor costs):\n     *   SHOULD fail the channel.\n  *   if a sending node adds more than receiver max_accepted_htlcs HTLCs to its local commitment transaction, OR adds more than receiver max_htlc_value_in_flight_msat worth of offered HTLCs to its local commitment transaction:\n     *   SHOULD fail the channel.\n  *   if sending node sets cltv_expiry to greater or equal to 500000000:\n     *   SHOULD fail the channel.\n\nDoes it mean closing the channel (unilaterally or mutually)? Or ending the TCP connection? Something else?\n\nThanks,\nBen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/b7241bfc/attachment-0001.html>"
            },
            {
                "author": "lightning developer",
                "date": "2021-12-09T21:01:27",
                "message_text_only": "Dear Ben,\n\nBOLT 5 has a section called \"Failing a channel\" which you can find at https://github.com/lightning/bolts/blob/master/05-onchain.md#failing-a-channel\n\nThere you can find everything that is supposed to happen when the protocol spec says that a peer should fail a channel. This often happens when an `error` was sent. Roughly speaking \"failing a channel\" means closing the channel. In that case a peer should first try to mutually close the channel and only as a last resort resolve to a unilateral force close. The reasons are that force closes might include pending HTLCs and have higher fees in general.\n\nThere is also the common term of \"failing the connection\" which means closing the TCP connection.\n\nIf you are interested to dig a bit deeper you will see that there is the discussion about introducing warning messages at https://github.com/lightning/bolts/pull/834. The reason is to relax situations where we send `error` so that channels might not be closed as quickly as it is the case right now.\n\nThe semantics of failing the channel and what exactly should be done are also being discussed. I recently opened a pull request at https://github.com/lightning/bolts/pull/942 which resulted from the discussion around the warning messages and the idea to relax what happens in case issues arise during `channel_reestablish` which is discussed at https://github.com/lightning/bolts/pull/932\n\nSincerely Lightning Developer\n\nSent with [ProtonMail](https://protonmail.com/) Secure Email.\n\n\u2010\u2010\u2010\u2010\u2010\u2010\u2010 Original Message \u2010\u2010\u2010\u2010\u2010\u2010\u2010\nOn Thursday, December 9th, 2021 at 21:10, Benjamin Weintraub <weintraub.b at northeastern.edu> wrote:\n\n> Hi all,\n>\n> I have a question about BOLT #2. What exactly does it mean to \"fail the channel\"? In the section for \"update_add_htlc,\" the follwing text is written:\n>\n> - receiving an amount_msat equal to 0, OR less than its own  htlc_minimum_msat:\n>\n> - SHOULD fail the channel.\n>\n> - receiving an amount_msat that the sending node cannot afford at the current feerate_per_kw (while maintaining its channel reserve and any  to_local_anchor and to_remote_anchor costs):\n>\n> - SHOULD fail the channel.\n>\n> - if a sending node adds more than receiver max_accepted_htlcs HTLCs to its local commitment transaction, OR adds more than receiver max_htlc_value_in_flight_msat worth of offered HTLCs to its local commitment transaction:\n>\n> - SHOULD fail the channel.\n>\n> - if sending node sets cltv_expiry to greater or equal to 500000000:\n>\n> - SHOULD fail the channel.\n>\n> Does it mean closing the channel (unilaterally or mutually)? Or ending the TCP connection? Something else?\n>\n> Thanks,\n> Ben\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211209/8f5b3b25/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "BOLT 2 question",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Benjamin Weintraub",
                "lightning developer"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 3989
        }
    },
    {
        "title": "[Lightning-dev] bLIPs are Open for Business!",
        "thread_messages": [
            {
                "author": "Ryan Gentry",
                "date": "2021-12-10T16:28:15",
                "message_text_only": "Hi all,\n\nEarlier this year, I emailed this mailing list about bitcoin Lightning\nImprovement Proposals (bLIPs) [1] as a way to help standardize\ncommunity-driven app layer and protocol extension development. Today, I am\nexcited to let you know that the first two bLIPs specifying the process\nhave been merged [2] and that we are ready to start receiving proposals!\n\nHere are few example proposals I have my eyes on: Val's Keysend bLIP [3],\nthe Sphinx team's LUMO messaging format [4], Satoshi's Stream's TLV\nregistry [5], Lightning Node Connect [6], niftynei's accounting\nstandardization work, some of Impervious's LN-native communications\nwork, LND's Static Channel Backup system... and I am sure there are many\nmore!\n\nPlease don't hesitate to reach out if you're interested in writing a bLIP\nand want help. We're excited about getting this process going!\n\nAs a reminder, a bLIP is a design document providing information to the\nLightning community, or describing a new feature for the Lightning Network,\nand should provide a concise technical specification of the feature and a\nrationale for the feature. Importantly, if a feature is intended to become\nuniversal or near universal, it must be a BOLT [7].\n\nBecause of this distinction, the bLIP editors do not pass judgment on\nbLIPs, but only monitor bLIP changes, and update bLIP headers as\nappropriate. So long as you check the mailing list to ensure nobody has\nmade a similar proposal before, fill out the required sections specified in\nbLIP-0001, and reserve the required feature bit, message type, or TLV in\nthe bLIP-0002 registry, we are more than happy to merge proposals into the\nrepo.\n\nBest,\nRyan\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2021-June/003086.html\n[2] https://github.com/lightning/blips\n[3] https://github.com/lightning/blips/pull/5\n[4] https://github.com/stakwork/lumo-spec\n[5]\nhttps://github.com/satoshisstream/satoshis.stream/blob/main/TLV_registry.md\n[6]\nhttps://lightning.engineering/posts/2021-11-30-lightning-node-connect-deep-dive/\n[7] https://github.com/lightning/bolts\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211210/2d4236c5/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "bLIPs are Open for Business!",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ryan Gentry"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2255
        }
    },
    {
        "title": "[Lightning-dev] 1 bitcoin grant: design a privacy focused lightning network wallet",
        "thread_messages": [
            {
                "author": "Max Hillebrand",
                "date": "2021-12-11T11:46:47",
                "message_text_only": "Good morning list,\n\nI would like to highlight a 1 bitcoin research grant to design a privacy\nfocused lightning network wallet.\u00a0 This design should build ontop of the\nnumerous existing privacy improvements, like Tor, Taproot, and WabiSabi\nCoinJoin.\n\n0.5 BTC will be given out to the selected research team up front, while\nthe other...\n0.5 BTC will be split between 3 selected individuals to form another\nresearch team\n\nIf you're interested, please write rafe at zksnacks.com\n\nRead more here. https://blog.wasabiwallet.io/1-btc-ln-privacy-grant/\n\nThanks for all your great work!\n\nSkol\nMax"
            }
        ],
        "thread_summary": {
            "title": "1 bitcoin grant: design a privacy focused lightning network wallet",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Max Hillebrand"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 586
        }
    },
    {
        "title": "[Lightning-dev] [Bitcoin Advent Calendar] Payment Channels in a CTV+Sapio World",
        "thread_messages": [
            {
                "author": "Jeremy",
                "date": "2021-12-11T18:01:31",
                "message_text_only": "hola devs,\n\nThis post details more formally a basic version of payment channels built\non top of CTV/Sapio and the implications of having non-interactive channel\ncreation.\n\nhttps://rubin.io/bitcoin/2021/12/11/advent-14/\n\nI'm personally incredibly bullish on where this concept can go since it\nwould make channel opening much more efficient, especially when paired with\nthe payment pool concept shared the other day.\n\nBest,\n\nJeremy\n\n--\n@JeremyRubin <https://twitter.com/JeremyRubin>\n<https://twitter.com/JeremyRubin>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211211/1e9e50c8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Payment Channels in a CTV+Sapio World",
            "categories": [
                "Lightning-dev",
                "Bitcoin Advent Calendar"
            ],
            "authors": [
                "Jeremy"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 699
        }
    },
    {
        "title": "[Lightning-dev] A blame ascribing protocol towards ensuring time limitation of stuck HTLCs in flight.",
        "thread_messages": [
            {
                "author": "lightning developer",
                "date": "2021-12-15T01:07:42",
                "message_text_only": "Good morning list,\n\nI have just published a proposal to address (but unfortunately not solve) the old issue of HTLC spam via onions: https://github.com/lightning-developer/lightning-network-documents/blob/main/A%20blame%20ascribing%20protocol%20to%20mitigate%20HTLC%20spam.md\n\nThe proposal picks up the early idea by Rusty, AJ and others to ascribe blame to a malicious actor but hopefully in a cheaper way than providing proof of a channel close by making use of a new lightning message `blame_channel` in combination with the proposed onion messages. I guess similar ideas and follow ups are already community knowledge (for example the local reputation tracking by Jim Posen at: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001232.html) However I had the feeling that the current write up might provide some additional value to the community.\n\nThe proposal also ensures that blame can be ascribed quickly by requiring a reply from the downstream onion that is proportional to the `cltv delta` at the hop. In this way a sending node will quickly know that a (and more importantly which) downstream channel is not working properly.\n\nI will be delighted to read your feedback, thoughts and criticism. For your convenience and archiving I also copied the raw markdown file of the proposal to the end of this Mail.\n\nSincerely Lighting Developer\n\n--------- Begin Proposal ----------\n\n# A blame ascribing protocol towards ensuring time limitation of stuck HTLCs in flight.\n\nI was reviewing the [HOLD fee proposal by Joost](https://github.com/lightning/bolts/pull/843) and the [excellent summary of known mitigation techniques by t-bast](https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md) when I revisited the very [first idea to mitigate HTLC spam via onions](https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html) that was discussed back in 2015 by Rusty, AJ and a few others. At that time the idea was to ascribe blame to a malicious actor by triggering a force close and proofing ones own honesty by providing the force close transaction. I think there is a lot of merit to the idea of ascribing blame and I think it might be possible with the help of [onion messages](https://github.com/lightning/bolts/pull/759) without the necessity to trigger full force closes.\n\nAs I am not entirely sure if this suggestion is a reasonable improvement (it certainly does not resolve all the issues we have) I did not spec out the details and message formats and fields but only described the high level idea. I hope this is sufficient to discuss the principles and get the feedback from you if you consider this to be of use and if you think we should work on the details.\n\nIdea / Obervation:\n=============\nThe key idea is to set a fixed time in seconds (the `reply_interval`) after successfully negotiating an HTLC until when a node requires a resultion or reply from its peer to which it previously has forwarded a downstream onion. If the HTLC is not resolved and no reply was sent the downstream peer is considered to be acting maliciously.\n\nThe amount in seconds can be proportional to the `cltv_delta` of that hop. To me the arbitrary choice of translating 10 blocks of `cltv_delta` to `1` second of expected reply time seems reasonable for now but could be chosen differently as long as the entire network (or at least every node included to the payment attempt) agrees upon the same conversion rate from `cltv_delta` to expected response time from downstream nodes.\n\nThere are three cases for the reply:\n\nThe Good reply case (HTLC resolution):\n==============================\nThe good case is if the payment will succesfully settle or fail within the `reply_interval`. Thus the reply comes in the form of either an `update_fulfill_htlc` or an `update_fail_htlc`. In any case the HTLC will be removed quickly and the reply can propagate back to the upstream peers.\n\nThe bad reply case:\n===============\nIf a node `N` is not able to send one of those two `update_` messages because the HTLC was not resolved from the downstream channels it MUST send back a new message called `blame_channel`.\n\nThe `blame_channel` includes a proof that `N` has previously successfully set up the HTLC with the next peer. This may for example be done by including the `commitment_signed` message that the node has received from the next peer as this commits to this (and potentially other) HTLCs. (Alternatively one could extract the relevant `htlc_signature` or adopt `commitment_signed` to include a signature to the `payment_hash` that can be verified with the node's pubkey)\n\nThe propagated bad reply case:\n========================\nA node might have received an `blame_channel` message from a downstream channel and can propagate this back. To disallow spoofing, nodes might always have to extend the message with their own signature. (I have not thought about this extensively yet). This will make the downstream path of the payment transparent to every node on the upstream path (until the slow /misbehaving node). Nodes SHOULD propagate the `blame_channel` back in a timely manner unless they want to be blamed for the delay themselves.\n\nExtensions:\n=========\nOf course a malicious node `M` might after receiving an `update_add_htlc` from a node `N` interrupt the channel state machine at various moments before the state successfully moved forward. This would prevent the honest node `N` to ascribe blame to the malicious node `M` as it cannot include proof that it forwarded the HTLC successfully. Thus instead of including the proof of successfully having set up the HTLC the node `N` ascribing blame to `M` might include to the `blame_channel` the last messages it sent to the downstream peer that have not been acknowledged to be able to proof that it tried to move the state machine forward and set up the HTLC.\n\nA node on an upstream channel could verify that `N` was indeed honest and has also delivered these messages to `M` by sending these messages via a different path as an onion message to `M`.\n\nNow if `M` was indeed dishonest `M` would not respond to the onion message indicating to the upstream node that `N` was honestly ascribing blame to `M`. Otherwise `M` could try to move the state forward and proof this to the upstream node in the onion reply indicating that it was actually `N` who tried to act malicious. In any case if there was a disagreement the upstream nodes would in any case learn that there is a problem on the channel between `N` and `M`.\n\nLimitations:\n=========\nThere are two limitations that I am currently aware of:\n\n1. Being able to ascribe blame does not directly prevent spam via HTLCs\n2. With MPP the short `reply_interval` might be an issue as the honest recipient of a partial payment might just not have received enough parts of the entire payment and just can't fulfill the payment yet. In this case the blame is being ascribed to the recipient and nodes would learn the recipient. I hope we could resolve such issues by selecting a higher grace period until we ascribe blame. For example if all the times above are are added to the 60 seconds of timeout that recipients of MPP payments currently have this would not trigger if the sender just needs more time to send partial payments.\n\nAdvantages:\n==========\n1. Through the mechanism to ascribe blame several nodes will learn about an malicious or slow actor on the network and can take other preventive measures especially if they also have direct channels with that peer\n2. Once we have PTLCs and a protocol for stuckless payments an honest sender of the payment may quickly discard this stuck HTLC (PTLC) and try another path without including the malicious node.\n\nConclusion:\n=========\nI am not sure if the suggestions in this proposal are as secure as we need them to be but I wasn't able to detect any obvious flaws which is why I would like to kindly ask you to review and criticize them. What I propose is not the full solution to nodes abusing the possibilities of onion routing and HTLCs spam but I believe it is a step in the right direction towards mitigation by presenting a collection of a few observations which are hopefully useful to bring us a step closer towards guaranteeing fast settlement of payments.\n\nSent with [ProtonMail](https://protonmail.com/) Secure Email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211215/d50cd57c/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-15T08:01:37",
                "message_text_only": "Good morning,\n\nThanks for looking into this!\n\nI believe there is another limitation that you're not mentioning: it's\neasy for a malicious node to blame an honest node. I'm afraid this is a\nserious limitation of the proposal.\n\nIf we have a payment: A -> B -> C -> D and C is malicious.\nC can forward the payment to D, and even wait for D to correctly settle it\n(with `update_fulfill_htlc` or `update_fail_htlc`), but then withhold that\nmessage instead of forwarding it to B. Then C blames D, everyone agrees that\nD is bad node that must be avoided. Later, C unblocks the `update_*_htlc`\nand everyone thinks that D hodled the HTLC for a long time, which is bad.\n\nApart from this, I think the blame proof isn't that easy to build.\nIt cannot simply use `commitment_signed`, because HTLCs are relayed only\nonce the previous commitment has been revoked (through `revoke_and_ack`).\nSo the proof should contain data from `commitment_signed` and a proof that\nthe previous commitment was revoked (and that it was indeed the previous\ncommitment) which is likely very hard to do securely without disclosing\ntoo much about your channel.\n\nCheers,\nBastien\n\nLe mer. 15 d\u00e9c. 2021 \u00e0 02:08, lightning developer via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> Good morning list,\n>\n> I have just published a proposal to address (but unfortunately not solve)\n> the old issue of HTLC spam via onions:\n> https://github.com/lightning-developer/lightning-network-documents/blob/main/A%20blame%20ascribing%20protocol%20to%20mitigate%20HTLC%20spam.md\n>\n> The proposal picks up the early idea by Rusty, AJ and others to ascribe\n> blame to a malicious actor but hopefully in a cheaper way than providing\n> proof of a channel close by making use of a new lightning message\n> `blame_channel` in combination with the proposed onion messages. I guess\n> similar ideas and follow ups are already community knowledge (for example\n> the local reputation tracking by Jim Posen at:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001232.html)\n> However I had the feeling that the current write up might provide some\n> additional value to the community.\n>\n> The proposal also ensures that blame can be ascribed quickly by requiring\n> a reply from the downstream onion that is proportional to the `cltv delta`\n> at the hop. In this way a sending node will quickly know that a (and more\n> importantly which) downstream channel is not working properly.\n>\n> I will be delighted to read your feedback, thoughts and criticism. For\n> your convenience and archiving I also copied the raw markdown file of the\n> proposal to the end of this Mail.\n>\n> Sincerely Lighting Developer\n>\n>\n> --------- Begin Proposal ----------\n>\n> # A blame ascribing protocol towards ensuring time limitation of stuck\n> HTLCs in flight.\n>\n> I was reviewing the [HOLD fee proposal by Joost](\n> https://github.com/lightning/bolts/pull/843) and the [excellent summary\n> of known mitigation techniques by t-bast](\n> https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md)\n> when I revisited the very [first idea to mitigate HTLC spam via onions](\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html)\n> that was discussed back in 2015 by Rusty, AJ and a few others. At that time\n> the idea was to ascribe blame to a malicious actor by triggering a force\n> close and proofing ones own honesty by providing the force close\n> transaction. I think there is a lot of merit to the idea of ascribing blame\n> and I think it might be possible with the help of [onion messages](\n> https://github.com/lightning/bolts/pull/759) without the necessity to\n> trigger full force closes.\n>\n> As I am not entirely sure if this suggestion is a reasonable improvement\n> (it certainly does not resolve all the issues we have) I did not spec out\n> the details and message formats and fields but only described the high\n> level idea. I hope this is sufficient to discuss the principles and get the\n> feedback from you if you consider this to be of use and if you think we\n> should work on the details.\n>\n> Idea / Obervation:\n> =============\n> The key idea is to set a fixed time in seconds (the `reply_interval`)\n> after successfully negotiating an HTLC until when a node requires a\n> resultion or reply from its peer to which it previously has forwarded a\n> downstream onion. If the HTLC is not resolved and no reply was sent the\n> downstream peer is considered to be acting maliciously.\n>\n> The amount in seconds can be proportional to the `cltv_delta` of that hop.\n> To me the arbitrary choice of translating 10 blocks of `cltv_delta` to `1`\n> second of expected reply time seems reasonable for now but could be chosen\n> differently as long as the entire network (or at least every node included\n> to the payment attempt) agrees upon the same conversion rate from\n> `cltv_delta` to expected response time from downstream nodes.\n>\n> There are three cases for the reply:\n>\n> The Good reply case (HTLC resolution):\n> ==============================\n> The good case is if the payment will succesfully settle or fail within the\n> `reply_interval`. Thus the reply comes in the form of either an\n> `update_fulfill_htlc` or an `update_fail_htlc`. In any case the HTLC will\n> be removed quickly and the reply can propagate back to the upstream peers.\n>\n> The bad reply case:\n> ===============\n> If a node `N` is not able to send one of those two `update_` messages\n> because the HTLC was not resolved from the downstream channels it MUST send\n> back a new message called `blame_channel`.\n>\n> The `blame_channel` includes a proof that `N` has previously successfully\n> set up the HTLC with the next peer. This may for example be done by\n> including the `commitment_signed` message that the node has received from\n> the next peer as this commits to this (and potentially other) HTLCs.\n> (Alternatively one could extract the relevant `htlc_signature` or adopt\n> `commitment_signed` to include a signature to the `payment_hash` that can\n> be verified with the node's pubkey)\n>\n> The propagated bad reply case:\n> ========================\n> A node might have received an `blame_channel` message from a downstream\n> channel and can propagate this back. To disallow spoofing, nodes might\n> always have to extend the message with their own signature. (I have not\n> thought about this extensively yet). This will make the downstream path of\n> the payment transparent to every node on the upstream path (until the slow\n> /misbehaving node). Nodes SHOULD propagate the `blame_channel` back in a\n> timely manner unless they want to be blamed for the delay themselves.\n>\n> Extensions:\n> =========\n> Of course a malicious node `M` might after receiving an `update_add_htlc`\n> from a node `N` interrupt the channel state machine at various moments\n> before the state successfully moved forward. This would prevent the honest\n> node `N` to ascribe blame to the malicious node `M` as it cannot include\n> proof that it forwarded the HTLC successfully. Thus instead of including\n> the proof of successfully having set up the HTLC the node `N` ascribing\n> blame to `M` might include to the `blame_channel` the last messages it sent\n> to the downstream peer that have not been acknowledged to be able to proof\n> that it tried to move the state machine forward and set up the HTLC.\n>\n> A node on an upstream channel could verify that `N` was indeed honest and\n> has also delivered these messages to `M` by sending these messages via a\n> different path as an onion message to `M`.\n>\n> Now if `M` was indeed dishonest `M` would not respond to the onion message\n> indicating to the upstream node that `N` was honestly ascribing blame to\n> `M`. Otherwise `M` could try to move the state forward and proof this to\n> the upstream node in the onion reply indicating that it was actually `N`\n> who tried to act malicious. In any case if there was a disagreement the\n> upstream nodes would in any case learn that there is a problem on the\n> channel between `N` and `M`.\n>\n>\n> Limitations:\n> =========\n> There are two limitations that I am currently aware of:\n>\n> 1. Being able to ascribe blame does not directly prevent spam via HTLCs\n> 2. With MPP the short `reply_interval` might be an issue as the honest\n> recipient of a partial payment might just not have received enough parts of\n> the entire payment and just can't fulfill the payment yet. In this case the\n> blame is being ascribed to the recipient and nodes would learn the\n> recipient. I hope we could resolve such issues by selecting a higher grace\n> period until we ascribe blame. For example if all the times above are are\n> added to the 60 seconds of timeout that recipients of MPP payments\n> currently have this would not trigger if the sender just needs more time to\n> send partial payments.\n>\n> Advantages:\n> ==========\n> 1. Through the mechanism to ascribe blame several nodes will learn about\n> an malicious or slow actor on the network and can take other preventive\n> measures especially if they also have direct channels with that peer\n> 2. Once we have PTLCs and a protocol for stuckless payments an honest\n> sender of the payment may quickly discard this stuck HTLC (PTLC) and try\n> another path without including the malicious node.\n>\n> Conclusion:\n> =========\n> I am not sure if the suggestions in this proposal are as secure as we need\n> them to be but I wasn't able to detect any obvious flaws which is why I\n> would like to kindly ask you to review and criticize them. What I propose\n> is not the full solution to nodes abusing the possibilities of onion\n> routing and HTLCs spam but I believe it is a step in the right direction\n> towards mitigation by presenting a collection of a few observations which\n> are hopefully useful to bring us a step closer towards guaranteeing fast\n> settlement of payments.\n>\n>\n>\n>\n> Sent with ProtonMail <https://protonmail.com/> Secure Email.\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211215/67451838/attachment-0001.html>"
            },
            {
                "author": "lightning developer",
                "date": "2021-12-16T00:50:11",
                "message_text_only": "Good Morning Bastien,\n\n> I believe there is another limitation that you're not mentioning: it's\n> easy for a malicious node to blame an honest node. I'm afraid this is a\n> serious limitation of the proposal.\n\nThank you very much for your review and comments. I have just updated the proposal on github with a section \"Security Considerations\" that is equivalent to what I will send in this mail as I believe that the \"serious limitation\" that you pointed out can be resolved with the help of onion messages similar to what I tried to communicate in the already existing \"Extensions\" section. BTW before I sent my initial mail I was thinking exactly about the example that you mentioned! I elected to not include it to keep the text concise and short. Of course I might have back then and still a mistake in my thinking and in that case I apologize for asking you to review the proposal and my rebuttal.\n\n> If we have a payment: A -> B -> C -> D and C is malicious.\n> C can forward the payment to D, and even wait for D to correctly settle it\n> (with `update_fulfill_htlc` or `update_fail_htlc`), but then withhold that\n> message instead of forwarding it to B. Then C blames D, everyone agrees that\n> D is bad node that must be avoided. Later, C unblocks the `update_*_htlc`\n> and everyone thinks that D hodled the HTLC for a long time, which is bad.\n\nThe above issue can be addressed by `B` verifying the proof it received from `C`. This can be done by presenting the proof to `D` via an onion message along a different node than `C`. If `D` cannot refute the proof by presenting a newer state to `B` then `B` knows that `D` was indeed dishonest. Otherwise `D` and `B` have discovered that `C` was misbehaving and tried to frame `D`.\n\n`B` indicates to `D` that it is allowed to ask such verification question by include the received proof from `C`. Note that `B` could never own such proof if `C` has not communicated with `B`. Of course if `C` has never talked to `B` in the first place `B` would have send a `TEMPORARY_CHANNEL_FAILURE` and if `C` stopped during the update of the statemachine to communicate to `B` then `B` can blame `C` via the above mechanism and `A` can verify the claim it received from `B`.\n\nAlso `B` cannot just send garbage to `D` and try to frame `C` because as soon as `B` would frame `C` the upstream node `A` would talk to `C` and recognize that it was `B` who was dishonest.\n\nGoing back to the situation assuming that `C` and `D` have indeed already successfully resolved the HTLC then the node `D` could in the reply to `B` even securely include the preimage allowing `B` to reclaim the funds from `A` and settle the HTLC in the A->B channel. Only the HTLC in the B->C channel would be locked which doesn't have to bother `B` as `B` expects that `C` is pulling / settling the HTLC anyway. Only `C` would have the disadvantage as it is not pulling its liquidity as soon as it can.\n\nSo far - besides a rather complicated flow of information - I do not see why the principles of my suggestion would not be possible to work at any other point of the channel state machine. So when queried by `B` the node `D` could always replay with the latest state it has in the C->D channel indicating to `B` that `C` was dishonest.\n\nOf course we could ask now what is if `B` is also malicious? In this case `B` could propagate the `blame_channel` back but `A` could again use the onion trick to verify and discover that `B` and `C` are not following the protocol.\n\n> Apart from this, I think the blame proof isn't that easy to build.\n> It cannot simply use `commitment_signed`, because HTLCs are relayed only\n> once the previous commitment has been revoked (through `revoke_and_ack`).\n> So the proof should contain data from `commitment_signed` and a proof that\n> the previous commitment was revoked (and that it was indeed the previous\n> commitment) which is likely very hard to do securely without disclosing\n> too much about your channel.\n\nI agree the details for the construction of the blame proofs might be more tricky than in my naive and high level description. Never the less I think they should be possible to construct. I didn't work them out on purpose yet given the current state of the proposal to make it easy to understand and discuss the concept without getting distracted by details at this stage. I think the details of the blame proofs and the communication flow can be worked out if we believe that such a mechanism is an overall improvement for the protocol.\n\nAlso on a side note: I chose `commitment_signed `as the example as this would be sufficient to see that the `HTLC` was being processed. If `D` does not send `revoke_and_ack` D cannot forward / settle the HTLC and will be the malicious node and it is fair for `C` to blame `D`. If on the other hand `C` does not move the state forward by not sending `revoke_and_ack` and preventing `D` from relaying the HTLC the node `D` can present to `B` its own `revoke_and_ack` in the above mentioned onion message reply. This would indicate yet again that `C` is dishonest.\n\nSincerely Lightning Developer\n\n> Le mer. 15 d\u00e9c. 2021 \u00e0 02:08, lightning developer via Lightning-dev <lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Good morning list,\n>>\n>> I have just published a proposal to address (but unfortunately not solve) the old issue of HTLC spam via onions: https://github.com/lightning-developer/lightning-network-documents/blob/main/A%20blame%20ascribing%20protocol%20to%20mitigate%20HTLC%20spam.md\n>>\n>> The proposal picks up the early idea by Rusty, AJ and others to ascribe blame to a malicious actor but hopefully in a cheaper way than providing proof of a channel close by making use of a new lightning message `blame_channel` in combination with the proposed onion messages. I guess similar ideas and follow ups are already community knowledge (for example the local reputation tracking by Jim Posen at: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001232.html) However I had the feeling that the current write up might provide some additional value to the community.\n>>\n>> The proposal also ensures that blame can be ascribed quickly by requiring a reply from the downstream onion that is proportional to the `cltv delta` at the hop. In this way a sending node will quickly know that a (and more importantly which) downstream channel is not working properly.\n>>\n>> I will be delighted to read your feedback, thoughts and criticism. For your convenience and archiving I also copied the raw markdown file of the proposal to the end of this Mail.\n>>\n>> Sincerely Lighting Developer\n>>\n>> --------- Begin Proposal ----------\n>>\n>> # A blame ascribing protocol towards ensuring time limitation of stuck HTLCs in flight.\n>>\n>> I was reviewing the [HOLD fee proposal by Joost](https://github.com/lightning/bolts/pull/843) and the [excellent summary of known mitigation techniques by t-bast](https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md) when I revisited the very [first idea to mitigate HTLC spam via onions](https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html) that was discussed back in 2015 by Rusty, AJ and a few others. At that time the idea was to ascribe blame to a malicious actor by triggering a force close and proofing ones own honesty by providing the force close transaction. I think there is a lot of merit to the idea of ascribing blame and I think it might be possible with the help of [onion messages](https://github.com/lightning/bolts/pull/759) without the necessity to trigger full force closes.\n>>\n>> As I am not entirely sure if this suggestion is a reasonable improvement (it certainly does not resolve all the issues we have) I did not spec out the details and message formats and fields but only described the high level idea. I hope this is sufficient to discuss the principles and get the feedback from you if you consider this to be of use and if you think we should work on the details.\n>>\n>> Idea / Obervation:\n>> =============\n>> The key idea is to set a fixed time in seconds (the `reply_interval`) after successfully negotiating an HTLC until when a node requires a resultion or reply from its peer to which it previously has forwarded a downstream onion. If the HTLC is not resolved and no reply was sent the downstream peer is considered to be acting maliciously.\n>>\n>> The amount in seconds can be proportional to the `cltv_delta` of that hop. To me the arbitrary choice of translating 10 blocks of `cltv_delta` to `1` second of expected reply time seems reasonable for now but could be chosen differently as long as the entire network (or at least every node included to the payment attempt) agrees upon the same conversion rate from `cltv_delta` to expected response time from downstream nodes.\n>>\n>> There are three cases for the reply:\n>>\n>> The Good reply case (HTLC resolution):\n>> ==============================\n>> The good case is if the payment will succesfully settle or fail within the `reply_interval`. Thus the reply comes in the form of either an `update_fulfill_htlc` or an `update_fail_htlc`. In any case the HTLC will be removed quickly and the reply can propagate back to the upstream peers.\n>>\n>> The bad reply case:\n>> ===============\n>> If a node `N` is not able to send one of those two `update_` messages because the HTLC was not resolved from the downstream channels it MUST send back a new message called `blame_channel`.\n>>\n>> The `blame_channel` includes a proof that `N` has previously successfully set up the HTLC with the next peer. This may for example be done by including the `commitment_signed` message that the node has received from the next peer as this commits to this (and potentially other) HTLCs. (Alternatively one could extract the relevant `htlc_signature` or adopt `commitment_signed` to include a signature to the `payment_hash` that can be verified with the node's pubkey)\n>>\n>> The propagated bad reply case:\n>> ========================\n>> A node might have received an `blame_channel` message from a downstream channel and can propagate this back. To disallow spoofing, nodes might always have to extend the message with their own signature. (I have not thought about this extensively yet). This will make the downstream path of the payment transparent to every node on the upstream path (until the slow /misbehaving node). Nodes SHOULD propagate the `blame_channel` back in a timely manner unless they want to be blamed for the delay themselves.\n>>\n>> Extensions:\n>> =========\n>> Of course a malicious node `M` might after receiving an `update_add_htlc` from a node `N` interrupt the channel state machine at various moments before the state successfully moved forward. This would prevent the honest node `N` to ascribe blame to the malicious node `M` as it cannot include proof that it forwarded the HTLC successfully. Thus instead of including the proof of successfully having set up the HTLC the node `N` ascribing blame to `M` might include to the `blame_channel` the last messages it sent to the downstream peer that have not been acknowledged to be able to proof that it tried to move the state machine forward and set up the HTLC.\n>>\n>> A node on an upstream channel could verify that `N` was indeed honest and has also delivered these messages to `M` by sending these messages via a different path as an onion message to `M`.\n>>\n>> Now if `M` was indeed dishonest `M` would not respond to the onion message indicating to the upstream node that `N` was honestly ascribing blame to `M`. Otherwise `M` could try to move the state forward and proof this to the upstream node in the onion reply indicating that it was actually `N` who tried to act malicious. In any case if there was a disagreement the upstream nodes would in any case learn that there is a problem on the channel between `N` and `M`.\n>>\n>> Limitations:\n>> =========\n>> There are two limitations that I am currently aware of:\n>>\n>> 1. Being able to ascribe blame does not directly prevent spam via HTLCs\n>> 2. With MPP the short `reply_interval` might be an issue as the honest recipient of a partial payment might just not have received enough parts of the entire payment and just can't fulfill the payment yet. In this case the blame is being ascribed to the recipient and nodes would learn the recipient. I hope we could resolve such issues by selecting a higher grace period until we ascribe blame. For example if all the times above are are added to the 60 seconds of timeout that recipients of MPP payments currently have this would not trigger if the sender just needs more time to send partial payments.\n>>\n>> Advantages:\n>> ==========\n>> 1. Through the mechanism to ascribe blame several nodes will learn about an malicious or slow actor on the network and can take other preventive measures especially if they also have direct channels with that peer\n>> 2. Once we have PTLCs and a protocol for stuckless payments an honest sender of the payment may quickly discard this stuck HTLC (PTLC) and try another path without including the malicious node.\n>>\n>> Conclusion:\n>> =========\n>> I am not sure if the suggestions in this proposal are as secure as we need them to be but I wasn't able to detect any obvious flaws which is why I would like to kindly ask you to review and criticize them. What I propose is not the full solution to nodes abusing the possibilities of onion routing and HTLCs spam but I believe it is a step in the right direction towards mitigation by presenting a collection of a few observations which are hopefully useful to bring us a step closer towards guaranteeing fast settlement of payments.\n>>\n>> Sent with [ProtonMail](https://protonmail.com/) Secure Email.\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211216/ef77ff5e/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-12-16T07:45:29",
                "message_text_only": "Good morning,\n\nI agree, this onion message trick could let us work around this kind of\ncheating\nattempt. However, it becomes quite a complex protocol, and it's likely that\nthe more we progress towards specifying it, the more subtle issues we will\nfind that will require making it even more complex.\n\nI'm more hopeful that we'll find channel jamming mitigations that work for\nboth\nfast spam and slow spam, and will remove the need for this protocol (which\ndoesn't protect against fast spam, only against slow spam).\n\n`D` can present to `B` its own `revoke_and_ack` in the above mentioned\n> onion message reply.\n>\n\nA few high-level notes on why I think this is still harder than it looks:\n\n* even if `D` shows B its `revoke_and_ack`, it doesn't prove that D sent it\nto C\n* it's impossible for a node to prove that it did *not* receive a message:\nyou can prove knowledge,\n  but proving lack of knowledge is much harder (impossible?)\n\nCheers,\nBastien\n\nLe jeu. 16 d\u00e9c. 2021 \u00e0 01:50, lightning developer <\nlightning-developer at protonmail.com> a \u00e9crit :\n\n> Good Morning Bastien,\n>\n> I believe there is another limitation that you're not mentioning: it's\n> easy for a malicious node to blame an honest node. I'm afraid this is a\n> serious limitation of the proposal.\n>\n>\n> Thank you very much for your review and comments. I have just updated the\n> proposal on github with a section \"Security Considerations\" that is\n> equivalent to what I will send in this mail as I believe that the \"serious\n> limitation\" that you pointed out can be resolved with the help of onion\n> messages similar to what I tried to communicate in the already existing\n> \"Extensions\" section. BTW before I sent my initial mail I was thinking\n> exactly about the example that you mentioned! I elected to not include it\n> to keep the text concise and short. Of course I might have back then and\n> still a mistake in my thinking and in that case I apologize for asking you\n> to review the proposal and my rebuttal.\n>\n> If we have a payment: A -> B -> C -> D and C is malicious.\n> C can forward the payment to D, and even wait for D to correctly settle it\n> (with `update_fulfill_htlc` or `update_fail_htlc`), but then withhold that\n> message instead of forwarding it to B. Then C blames D, everyone agrees\n> that\n> D is bad node that must be avoided. Later, C unblocks the `update_*_htlc`\n> and everyone thinks that D hodled the HTLC for a long time, which is bad.\n>\n>\n> The above issue can be addressed by `B` verifying the proof it received\n> from `C`. This can be done by presenting the proof to `D` via an onion\n> message along a different node than `C`. If `D` cannot refute the proof by\n> presenting a newer state to `B` then `B` knows that `D` was indeed\n> dishonest. Otherwise `D` and `B` have discovered that `C` was misbehaving\n> and tried to frame `D`.\n>\n> `B` indicates to `D` that it is allowed to ask such verification question\n> by include the received proof from `C`. Note that `B` could never own such\n> proof if `C` has not communicated with `B`. Of course if `C` has never\n> talked to `B` in the first place `B` would have send a\n> `TEMPORARY_CHANNEL_FAILURE` and if `C` stopped during the update of the\n> statemachine to communicate to `B` then `B` can blame `C` via the above\n> mechanism and `A` can verify the claim it received from `B`.\n>\n> Also `B` cannot just send garbage to `D` and try to frame `C` because as\n> soon as `B` would frame `C` the upstream node `A` would talk to `C` and\n> recognize that it was `B` who was dishonest.\n>\n> Going back to the situation assuming that `C` and `D` have indeed already\n> successfully resolved the HTLC then the node `D` could in the reply to `B`\n> even securely include the preimage allowing `B` to reclaim the funds from\n> `A` and settle the HTLC in the A->B channel. Only the HTLC in the B->C\n> channel would be locked which doesn't have to bother `B` as `B` expects\n> that `C` is pulling / settling the HTLC anyway.  Only `C` would have the\n> disadvantage as it is not pulling its liquidity as soon as it can.\n>\n> So far - besides a rather complicated flow of information - I do not see\n> why the principles of my suggestion would not be possible to work at any\n> other point of the channel state machine. So when queried by `B` the node\n>  `D` could always replay with the latest state it has in the C->D channel\n> indicating to `B` that `C` was dishonest.\n>\n> Of course we could ask now what is if `B` is also malicious? In this case\n> `B` could propagate the `blame_channel` back but `A` could again use the\n> onion trick to verify and discover that `B` and `C` are not following the\n> protocol.\n>\n>\n> Apart from this, I think the blame proof isn't that easy to build.\n> It cannot simply use `commitment_signed`, because HTLCs are relayed only\n> once the previous commitment has been revoked (through `revoke_and_ack`).\n> So the proof should contain data from `commitment_signed` and a proof that\n> the previous commitment was revoked (and that it was indeed the previous\n> commitment) which is likely very hard to do securely without disclosing\n> too much about your channel.\n>\n>\n> I agree the details for the construction of the blame proofs might be more\n> tricky than in my naive and high level description. Never the less I think\n> they should be possible to construct. I didn't work them out on purpose yet\n> given the current state of the proposal to make it easy to understand and\n> discuss the concept without getting distracted by details at this stage. I\n> think the details of the blame proofs and the communication flow can be\n> worked out if we believe that such a mechanism is an overall improvement\n> for the protocol.\n>\n> Also on a side note: I chose `commitment_signed `as the example as this\n> would be sufficient to see that the `HTLC` was being processed. If `D` does\n> not send `revoke_and_ack` D cannot forward / settle the HTLC and will be\n> the malicious node and it is fair for `C` to blame `D`. If on the other\n> hand `C` does not move the state forward by not sending `revoke_and_ack`\n> and preventing `D` from relaying the HTLC the node `D` can present to `B`\n> its own `revoke_and_ack` in the above mentioned onion message reply. This\n> would indicate yet again that `C` is dishonest.\n>\n> Sincerely Lightning Developer\n>\n> Le mer. 15 d\u00e9c. 2021 \u00e0 02:08, lightning developer via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n>\n>> Good morning list,\n>>\n>> I have just published a proposal to address (but unfortunately not solve)\n>> the old issue of HTLC spam via onions:\n>> https://github.com/lightning-developer/lightning-network-documents/blob/main/A%20blame%20ascribing%20protocol%20to%20mitigate%20HTLC%20spam.md\n>>\n>> The proposal picks up the early idea by Rusty, AJ and others to ascribe\n>> blame to a malicious actor but hopefully in a cheaper way than providing\n>> proof of a channel close by making use of a new lightning message\n>> `blame_channel` in combination with the proposed onion messages. I guess\n>> similar ideas and follow ups are already community knowledge (for example\n>> the local reputation tracking by Jim Posen at:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001232.html)\n>> However I had the feeling that the current write up might provide some\n>> additional value to the community.\n>>\n>> The proposal also ensures that blame can be ascribed quickly by requiring\n>> a reply from the downstream onion that is proportional to the `cltv delta`\n>> at the hop. In this way a sending node will quickly know that a (and more\n>> importantly which) downstream channel is not working properly.\n>>\n>> I will be delighted to read your feedback, thoughts and criticism. For\n>> your convenience and archiving I also copied the raw markdown file of the\n>> proposal to the end of this Mail.\n>>\n>> Sincerely Lighting Developer\n>>\n>>\n>> --------- Begin Proposal ----------\n>>\n>> # A blame ascribing protocol towards ensuring time limitation of stuck\n>> HTLCs in flight.\n>>\n>> I was reviewing the [HOLD fee proposal by Joost](\n>> https://github.com/lightning/bolts/pull/843) and the [excellent summary\n>> of known mitigation techniques by t-bast](\n>> https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md)\n>> when I revisited the very [first idea to mitigate HTLC spam via onions](\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html)\n>> that was discussed back in 2015 by Rusty, AJ and a few others. At that time\n>> the idea was to ascribe blame to a malicious actor by triggering a force\n>> close and proofing ones own honesty by providing the force close\n>> transaction. I think there is a lot of merit to the idea of ascribing blame\n>> and I think it might be possible with the help of [onion messages](\n>> https://github.com/lightning/bolts/pull/759) without the necessity to\n>> trigger full force closes.\n>>\n>> As I am not entirely sure if this suggestion is a reasonable improvement\n>> (it certainly does not resolve all the issues we have) I did not spec out\n>> the details and message formats and fields but only described the high\n>> level idea. I hope this is sufficient to discuss the principles and get the\n>> feedback from you if you consider this to be of use and if you think we\n>> should work on the details.\n>>\n>> Idea / Obervation:\n>> =============\n>> The key idea is to set a fixed time in seconds (the `reply_interval`)\n>> after successfully negotiating an HTLC until when a node requires a\n>> resultion or reply from its peer to which it previously has forwarded a\n>> downstream onion. If the HTLC is not resolved and no reply was sent the\n>> downstream peer is considered to be acting maliciously.\n>>\n>> The amount in seconds can be proportional to the `cltv_delta` of that\n>> hop. To me the arbitrary choice of translating 10 blocks of `cltv_delta` to\n>> `1` second of expected reply time seems reasonable for now but could be\n>> chosen differently as long as the entire network (or at least every node\n>> included to the payment attempt) agrees upon the same conversion rate from\n>> `cltv_delta` to expected response time from downstream nodes.\n>>\n>> There are three cases for the reply:\n>>\n>> The Good reply case (HTLC resolution):\n>> ==============================\n>> The good case is if the payment will succesfully settle or fail within\n>> the `reply_interval`. Thus the reply comes in the form of either an\n>> `update_fulfill_htlc` or an `update_fail_htlc`. In any case the HTLC will\n>> be removed quickly and the reply can propagate back to the upstream peers.\n>>\n>> The bad reply case:\n>> ===============\n>> If a node `N` is not able to send one of those two `update_` messages\n>> because the HTLC was not resolved from the downstream channels it MUST send\n>> back a new message called `blame_channel`.\n>>\n>> The `blame_channel` includes a proof that `N` has previously successfully\n>> set up the HTLC with the next peer. This may for example be done by\n>> including the `commitment_signed` message that the node has received from\n>> the next peer as this commits to this (and potentially other) HTLCs.\n>> (Alternatively one could extract the relevant `htlc_signature` or adopt\n>> `commitment_signed` to include a signature to the `payment_hash` that can\n>> be verified with the node's pubkey)\n>>\n>> The propagated bad reply case:\n>> ========================\n>> A node might have received an `blame_channel` message from a downstream\n>> channel and can propagate this back. To disallow spoofing, nodes might\n>> always have to extend the message with their own signature. (I have not\n>> thought about this extensively yet). This will make the downstream path of\n>> the payment transparent to every node on the upstream path (until the slow\n>> /misbehaving node). Nodes SHOULD propagate the `blame_channel` back in a\n>> timely manner unless they want to be blamed for the delay themselves.\n>>\n>> Extensions:\n>> =========\n>> Of course a malicious node `M` might after receiving an `update_add_htlc`\n>> from a node `N` interrupt the channel state machine at various moments\n>> before the state successfully moved forward. This would prevent the honest\n>> node `N` to ascribe blame to the malicious node `M` as it cannot include\n>> proof that it forwarded the HTLC successfully. Thus instead of including\n>> the proof of successfully having set up the HTLC the node `N` ascribing\n>> blame to `M` might include to the `blame_channel` the last messages it sent\n>> to the downstream peer that have not been acknowledged to be able to proof\n>> that it tried to move the state machine forward and set up the HTLC.\n>>\n>> A node on an upstream channel could verify that `N` was indeed honest and\n>> has also delivered these messages to `M` by sending these messages via a\n>> different path as an onion message to `M`.\n>>\n>> Now if `M` was indeed dishonest `M` would not respond to the onion\n>> message indicating to the upstream node that `N` was honestly ascribing\n>> blame to `M`. Otherwise `M` could try to move the state forward and proof\n>> this to the upstream node in the onion reply indicating that it was\n>> actually `N` who tried to act malicious. In any case if there was a\n>> disagreement the upstream nodes would in any case learn that there is a\n>> problem on the channel between `N` and `M`.\n>>\n>>\n>> Limitations:\n>> =========\n>> There are two limitations that I am currently aware of:\n>>\n>> 1. Being able to ascribe blame does not directly prevent spam via HTLCs\n>> 2. With MPP the short `reply_interval` might be an issue as the honest\n>> recipient of a partial payment might just not have received enough parts of\n>> the entire payment and just can't fulfill the payment yet. In this case the\n>> blame is being ascribed to the recipient and nodes would learn the\n>> recipient. I hope we could resolve such issues by selecting a higher grace\n>> period until we ascribe blame. For example if all the times above are are\n>> added to the 60 seconds of timeout that recipients of MPP payments\n>> currently have this would not trigger if the sender just needs more time to\n>> send partial payments.\n>>\n>> Advantages:\n>> ==========\n>> 1. Through the mechanism to ascribe blame several nodes will learn about\n>> an malicious or slow actor on the network and can take other preventive\n>> measures especially if they also have direct channels with that peer\n>> 2. Once we have PTLCs and a protocol for stuckless payments an honest\n>> sender of the payment may quickly discard this stuck HTLC (PTLC) and try\n>> another path without including the malicious node.\n>>\n>> Conclusion:\n>> =========\n>> I am not sure if the suggestions in this proposal are as secure as we\n>> need them to be but I wasn't able to detect any obvious flaws which is why\n>> I would like to kindly ask you to review and criticize them. What I propose\n>> is not the full solution to nodes abusing the possibilities of onion\n>> routing and HTLCs spam but I believe it is a step in the right direction\n>> towards mitigation by presenting a collection of a few observations which\n>> are hopefully useful to bring us a step closer towards guaranteeing fast\n>> settlement of payments.\n>>\n>>\n>>\n>>\n>>\n>> Sent with ProtonMail <https://protonmail.com/> Secure Email.\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211216/e0da1706/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-16T14:12:43",
                "message_text_only": "Good morning Bastien,\n\n\n\n> * it's impossible for a node to prove that it did *not* receive a message: you can prove knowledge,\n> \u00a0 but proving lack of knowledge is much harder (impossible?)\n\nYes, it is impossible.\n\nIf there could exist a proof-of-lack-of-knowledge, then even if I personally knew some fact, I could simply run a virtual machine that knows everything I know *except* for that piece of knowledge, and generate the proof-of-lack-of-knowledge there.\nThis leads to a contradiction, as I myself *actually* know the fact, but I can present the proof-of-lack-of-knowledge by pretending to be somebody ignorant.\n\nRegards,\nZmnSCPxj (I definitely do not know that I am an AI)"
            }
        ],
        "thread_summary": {
            "title": "A blame ascribing protocol towards ensuring time limitation of stuck HTLCs in flight.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "ZmnSCPxj",
                "lightning developer"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 49250
        }
    },
    {
        "title": "[Lightning-dev] Split payments within one LN invoice",
        "thread_messages": [
            {
                "author": "Ronan McGovern",
                "date": "2021-12-15T17:33:51",
                "message_text_only": "Hi folks, I'm Ronan - based in Dublin and building Trelis.com (simple\npayment links to accept Lightning).\n\nI'm wondering if there is a way to create an invoice that splits the\npayment to two lightning addresses?\n\nIf not, what would be required to develop this?\n* A protocol change?\n* Could it be built with the current protocol (I see an app on LN Bits to\nsplit but it doesn't seem to work).\n\nMany thanks, Ronan\n\nRonan McGovern\nwww.Trelis.com\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211215/accda31a/attachment.html>"
            },
            {
                "author": "William Casarin",
                "date": "2021-12-15T21:59:49",
                "message_text_only": "Hey Ronan,\n\nOn Wed, Dec 15, 2021 at 05:33:51PM +0000, Ronan McGovern wrote:\n>Hi folks, I'm Ronan - based in Dublin and building Trelis.com (simple\n>payment links to accept Lightning).\n>\n>I'm wondering if there is a way to create an invoice that splits the\n>payment to two lightning addresses?\n>\n>If not, what would be required to develop this?\n>* A protocol change?\n>* Could it be built with the current protocol (I see an app on LN Bits to\n>split but it doesn't seem to work).\n\nThis is typically done at the application level. The fountain podcasting\napp works this way and it seems to work okish."
            },
            {
                "author": "William Casarin",
                "date": "2021-12-15T22:13:06",
                "message_text_only": "On Wed, Dec 15, 2021 at 01:59:49PM -0800, William Casarin wrote:\n>Hey Ronan,\n>\n>On Wed, Dec 15, 2021 at 05:33:51PM +0000, Ronan McGovern wrote:\n>>If not, what would be required to develop this?\n>>* A protocol change?\n>>* Could it be built with the current protocol (I see an app on LN Bits to\n>>split but it doesn't seem to work).\n>\n>This is typically done at the application level. The fountain podcasting\n>app works this way and it seems to work okish.\n\nThe tricky part is what to do when the payment partially fails. Perhaps\nyou keep trying with exponential backoff until the payment completes for\nall parties. If this was handled at the protocol level, would you fail\nthe entire transaction if one of the channels failed? This is the kind\nof business logic that would be tricky when designing a protocol-level\nsolution to this.\n\nI think it's reasonable to handle this at the application level for now,\nbut perhaps some standard protocols might be useful in the future.\n\nCheers,\nWill"
            },
            {
                "author": "Christian Decker",
                "date": "2021-12-16T10:27:33",
                "message_text_only": "This is quite a common request, and we've used a solution I like to call\nthe \"Poor man's rendez-vous\". It basically routes a payment through all\nthe parties that are to be paid, with the last one accepting the payment\nfor all participants.\n\nThe payment is atomic, once the circuit is set up no participant can\ncheat the others and it's seamless from the payer's perspective.\n\nLet's say user `A` wants to pay `B` and `C` atomically. `B` gets 10ksat\nand `C` gets 90ksat out of a total of 100ksat:\n\n 1) `C` creates an invoice with payment hash `H` for 90ksat and sends it\n    to `B`\n 2) `B` creates an invoice with payment hash `H` (same as the first\n    invoice, but `B` doesn't know the preimage) for 100ksat (maybe plus\n    a tiny bit for routing fees between `B` and `C`).\n 3) `A` receives an invoice which appears to be from `B` for the\n    expected total of 100ksat.\n 4) `A` proceeds to pay the invoice to `B` like normal\n 5) `B` receives the incoming payment, but doesn't have the preimage for\n    `H`, so they must forward to `C` if they want to receive their\n    share. `B` then proceeds to pay the 90ksat invoice from `C`, which\n    reveals the preimage to them, and they can turn around and claim\n    the incoming `100ksat` (covering both `B` and `C` share)\n\nIt's a poor man's version because it requires creating two invoices and\n`B` sees two payments (100ksat incoming, 90ksat outgoing), but the\noverall outcome is the desired one: either both parties get paid or\nnoone gets paid. This can trivially be extended to any number of parties\n(with reduced success probability), and will remain atomic. It also\ndoesn't require any changes on the sender side, and only minimal setup\nbetween the payees. The crux here is that we somehow need to ensure `H`\nis always the same along the entire chain of payments, but with a good\ncoordination protocol that should be feasible.\n\nRegards,\nChristian\n\nRonan McGovern <Ronan at trelis.com> writes:\n> Hi folks, I'm Ronan - based in Dublin and building Trelis.com (simple\n> payment links to accept Lightning).\n>\n> I'm wondering if there is a way to create an invoice that splits the\n> payment to two lightning addresses?\n>\n> If not, what would be required to develop this?\n> * A protocol change?\n> * Could it be built with the current protocol (I see an app on LN Bits to\n> split but it doesn't seem to work).\n>\n> Many thanks, Ronan\n>\n> Ronan McGovern\n> www.Trelis.com\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "William Casarin",
                "date": "2021-12-16T17:05:42",
                "message_text_only": "Hey Christian,\n\nOn Thu, Dec 16, 2021 at 11:27:33AM +0100, Christian Decker wrote:\n>This is quite a common request, and we've used a solution I like to call\n>the \"Poor man's rendez-vous\". It basically routes a payment through all\n>the parties that are to be paid, with the last one accepting the payment\n>for all participants.\n>\n>The payment is atomic, once the circuit is set up no participant can\n>cheat the others and it's seamless from the payer's perspective.\n>\n>Let's say user `A` wants to pay `B` and `C` atomically. `B` gets 10ksat\n>and `C` gets 90ksat out of a total of 100ksat:\n>\n> 1) `C` creates an invoice with payment hash `H` for 90ksat and sends it\n>    to `B`\n> 2) `B` creates an invoice with payment hash `H` (same as the first\n>    invoice, but `B` doesn't know the preimage) for 100ksat (maybe plus\n>    a tiny bit for routing fees between `B` and `C`).\n> 3) `A` receives an invoice which appears to be from `B` for the\n>    expected total of 100ksat.\n> 4) `A` proceeds to pay the invoice to `B` like normal\n> 5) `B` receives the incoming payment, but doesn't have the preimage for\n>    `H`, so they must forward to `C` if they want to receive their\n>    share. `B` then proceeds to pay the 90ksat invoice from `C`, which\n>    reveals the preimage to them, and they can turn around and claim\n>    the incoming `100ksat` (covering both `B` and `C` share)\n>\n>It's a poor man's version because it requires creating two invoices and\n>`B` sees two payments (100ksat incoming, 90ksat outgoing), but the\n>overall outcome is the desired one: either both parties get paid or\n>noone gets paid. This can trivially be extended to any number of parties\n>(with reduced success probability), and will remain atomic. It also\n>doesn't require any changes on the sender side, and only minimal setup\n>between the payees. The crux here is that we somehow need to ensure `H`\n>is always the same along the entire chain of payments, but with a good\n>coordination protocol that should be feasible.\n\nThis is very cool, at least for a small number of parties. When I was\nworking at a record label it was very common to split between 1-5 people\non a given track, being able to atomically payout to individual artist's\nlightning nodes would have been super useful at the time (assuming a\nworld where our artists ran lightning nodes). At some point I was\ntesting 600-output bitcoin transactions as a payout method, but that\nlooked like it was going to be economically infeasible sometime in the\nfuture.\n\nHas anyone coded up a 'Poor man's rendez-vous' demo yet? How hard would\nit be, could it be done with a clightning plugin perhaps?\n\nCheers,\nWill"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-16T23:44:12",
                "message_text_only": "Good morning William,\n\n\n> Has anyone coded up a 'Poor man's rendez-vous' demo yet? How hard would\n> it be, could it be done with a clightning plugin perhaps?\n\nProbably not *yet*; it needs each intermediate payee (i.e. the one that is not the last one) to sign an invoice for which it does not know the preimage.\nMaybe call such a command `signfakeinvoice`.\n\nHowever, if a command to do the above is implemented (it would have to generate and sign the invoice, but not insert it into the database at all), then intermediate payees can use `htlc_accepted` hook for the \"rendez-vous\".\n\nSo to generate the invoice:\n\n* Arrange the payees in some agreed fixed order.\n* Last payee generates a normal invoice.\n* From last payee to second, each one:\n  * Passes its invoice to the previous payee.\n  * The previous payee then creates its own signed invoice with `signfakeinvoice` to itself, adding its payout plus a fee budget, as well as adding its own delay budget.\n  * The previous payee plugin stores the next-payee invoice and the details of its own invoice to db, such as by `datastore` command.\n* The first payee sends the sender the invoice.\n\nOn payment:\n\n* The sender sends the payment to the first hop.\n* From first payee to second-to-last:\n  * Triggers `htlc_accepted` hook, and plugin checks if the incoming payment has a hash that is in this scheme stored in the database.\n  * The plugin gathers `htlc_accepted` hook invocations until they sum up to the expected amount (this handles multipath between payees).\n  * The plugin marks that it has gathered all `htlc_accepted` hooks for that hash in durable storage a.k.a. `datastore` (this handles a race condition where the plugin is able to respond to some `htlc_accepted` hooks, but the node is restarted before all of them were able to be recorded by C-Lightning in its own database --- this makes the plugin skip the \"gathering\" step above, once it has already gathered them all before).\n  * The plugin checks if there is already an outgoing payment for that hash (this handles the case where our node gets restarted in the meantime --- C-Lightning will reissue `htlc_accepted` on startup)\n    * If the outgoing payment exists and is pending, wait for it to resolve to either success or failure.\n    * If the outgoing payment exists and succeeded, resolve all the gathered `htlc_accepted` hooks.\n    * If the outgoing payment exists and failed, fail all the gathered `htlc_accepted` hooks.\n    * Otherwise, perform a `pay`, giving `maxfeepercent` and `maxdelay` based on its fee budget and delay budget.\n      When the `pay` succeeds or fails, propagate it to the gathered `htlc_accepted` hooks.\n* The last payee just receives a normal payment using the normal invoice-receive scheme.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ronan McGovern",
                "date": "2021-12-17T10:21:53",
                "message_text_only": "Hi ZmnSCPxj,\n\nSo, are you saying there needs to be a new command \"signfakeinvoice\" at the\nprotocol level?\n\nIf that was there, how much work/hours would it be to build the poor man's\nrendez-vous at the application level?\n\nIf the above were to be implemented, when the payer pays the invoice, it's\nthen automatically split and sent to two (or more) recipients?\n\nLastly, would it make more sense to have split payments at the protocol\nlevel?\n\nThanks, Ronan\n\nOn Thu, Dec 16, 2021 at 11:44 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning William,\n>\n>\n> > Has anyone coded up a 'Poor man's rendez-vous' demo yet? How hard would\n> > it be, could it be done with a clightning plugin perhaps?\n>\n> Probably not *yet*; it needs each intermediate payee (i.e. the one that is\n> not the last one) to sign an invoice for which it does not know the\n> preimage.\n> Maybe call such a command `signfakeinvoice`.\n>\n> However, if a command to do the above is implemented (it would have to\n> generate and sign the invoice, but not insert it into the database at all),\n> then intermediate payees can use `htlc_accepted` hook for the \"rendez-vous\".\n>\n> So to generate the invoice:\n>\n> * Arrange the payees in some agreed fixed order.\n> * Last payee generates a normal invoice.\n> * From last payee to second, each one:\n>   * Passes its invoice to the previous payee.\n>   * The previous payee then creates its own signed invoice with\n> `signfakeinvoice` to itself, adding its payout plus a fee budget, as well\n> as adding its own delay budget.\n>   * The previous payee plugin stores the next-payee invoice and the\n> details of its own invoice to db, such as by `datastore` command.\n> * The first payee sends the sender the invoice.\n>\n> On payment:\n>\n> * The sender sends the payment to the first hop.\n> * From first payee to second-to-last:\n>   * Triggers `htlc_accepted` hook, and plugin checks if the incoming\n> payment has a hash that is in this scheme stored in the database.\n>   * The plugin gathers `htlc_accepted` hook invocations until they sum up\n> to the expected amount (this handles multipath between payees).\n>   * The plugin marks that it has gathered all `htlc_accepted` hooks for\n> that hash in durable storage a.k.a. `datastore` (this handles a race\n> condition where the plugin is able to respond to some `htlc_accepted`\n> hooks, but the node is restarted before all of them were able to be\n> recorded by C-Lightning in its own database --- this makes the plugin skip\n> the \"gathering\" step above, once it has already gathered them all before).\n>   * The plugin checks if there is already an outgoing payment for that\n> hash (this handles the case where our node gets restarted in the meantime\n> --- C-Lightning will reissue `htlc_accepted` on startup)\n>     * If the outgoing payment exists and is pending, wait for it to\n> resolve to either success or failure.\n>     * If the outgoing payment exists and succeeded, resolve all the\n> gathered `htlc_accepted` hooks.\n>     * If the outgoing payment exists and failed, fail all the gathered\n> `htlc_accepted` hooks.\n>     * Otherwise, perform a `pay`, giving `maxfeepercent` and `maxdelay`\n> based on its fee budget and delay budget.\n>       When the `pay` succeeds or fails, propagate it to the gathered\n> `htlc_accepted` hooks.\n> * The last payee just receives a normal payment using the normal\n> invoice-receive scheme.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/f105a9e5/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2021-12-17T11:02:02",
                "message_text_only": "I was looking into the docs [1] and stumbled over `createinvoice` which\ndoes almost what you need. However it requires the preimage, and stores the\ninvoice in the database which you don't want.\n\nHowever if you have access to the `hsm_secret` you could sign in the plugin\nitself, completely sidestepping `lightningd`. Once you have that it should\nbe a couple of days work to get a PoC plugin for the coordination and\ntesting. From there it depends on how much polish you want to apply and\nwhat other systems you want to embed it into.\n\nEach recipient will have to run the plugin otherwise they'd not understand\nhow to handle the payment, and creating an invoice requires a bit more work\n(each payee needs to coordinate to be part of the Rendez-vous), but from\nthe senders point of view it's all seamless.\n\nAs for whether this is better suited for the protocol itself: could be,\nprobably not though. We let everybody experiment and then formalize and\nstandardize the best ideas from the community, so it may make its way into\nthe spec, but would need to be implemented, tested and popular enough to\nwarrant everybody having to implement yet another feature. In this case\nit's more for a bLiP, which are less formal and better match the fact that\nonly a small part of the network needs to implement it (only payees need to\ncoordinate and forward, senders and everybody else doesn't care).\n\nCheers,\nChristian\n\n[1] https://lightning.readthedocs.io/lightning-createinvoice.7.html\n\n\nOn Fri, 17 Dec 2021, 11:22 Ronan McGovern, <Ronan at trelis.com> wrote:\n\n> Hi ZmnSCPxj,\n>\n> So, are you saying there needs to be a new command \"signfakeinvoice\" at\n> the protocol level?\n>\n> If that was there, how much work/hours would it be to build the poor man's\n> rendez-vous at the application level?\n>\n> If the above were to be implemented, when the payer pays the invoice, it's\n> then automatically split and sent to two (or more) recipients?\n>\n> Lastly, would it make more sense to have split payments at the protocol\n> level?\n>\n> Thanks, Ronan\n>\n> On Thu, Dec 16, 2021 at 11:44 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning William,\n>>\n>>\n>> > Has anyone coded up a 'Poor man's rendez-vous' demo yet? How hard would\n>> > it be, could it be done with a clightning plugin perhaps?\n>>\n>> Probably not *yet*; it needs each intermediate payee (i.e. the one that\n>> is not the last one) to sign an invoice for which it does not know the\n>> preimage.\n>> Maybe call such a command `signfakeinvoice`.\n>>\n>> However, if a command to do the above is implemented (it would have to\n>> generate and sign the invoice, but not insert it into the database at all),\n>> then intermediate payees can use `htlc_accepted` hook for the \"rendez-vous\".\n>>\n>> So to generate the invoice:\n>>\n>> * Arrange the payees in some agreed fixed order.\n>> * Last payee generates a normal invoice.\n>> * From last payee to second, each one:\n>>   * Passes its invoice to the previous payee.\n>>   * The previous payee then creates its own signed invoice with\n>> `signfakeinvoice` to itself, adding its payout plus a fee budget, as well\n>> as adding its own delay budget.\n>>   * The previous payee plugin stores the next-payee invoice and the\n>> details of its own invoice to db, such as by `datastore` command.\n>> * The first payee sends the sender the invoice.\n>>\n>> On payment:\n>>\n>> * The sender sends the payment to the first hop.\n>> * From first payee to second-to-last:\n>>   * Triggers `htlc_accepted` hook, and plugin checks if the incoming\n>> payment has a hash that is in this scheme stored in the database.\n>>   * The plugin gathers `htlc_accepted` hook invocations until they sum up\n>> to the expected amount (this handles multipath between payees).\n>>   * The plugin marks that it has gathered all `htlc_accepted` hooks for\n>> that hash in durable storage a.k.a. `datastore` (this handles a race\n>> condition where the plugin is able to respond to some `htlc_accepted`\n>> hooks, but the node is restarted before all of them were able to be\n>> recorded by C-Lightning in its own database --- this makes the plugin skip\n>> the \"gathering\" step above, once it has already gathered them all before).\n>>   * The plugin checks if there is already an outgoing payment for that\n>> hash (this handles the case where our node gets restarted in the meantime\n>> --- C-Lightning will reissue `htlc_accepted` on startup)\n>>     * If the outgoing payment exists and is pending, wait for it to\n>> resolve to either success or failure.\n>>     * If the outgoing payment exists and succeeded, resolve all the\n>> gathered `htlc_accepted` hooks.\n>>     * If the outgoing payment exists and failed, fail all the gathered\n>> `htlc_accepted` hooks.\n>>     * Otherwise, perform a `pay`, giving `maxfeepercent` and `maxdelay`\n>> based on its fee budget and delay budget.\n>>       When the `pay` succeeds or fails, propagate it to the gathered\n>> `htlc_accepted` hooks.\n>> * The last payee just receives a normal payment using the normal\n>> invoice-receive scheme.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/ad84b53b/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-17T15:06:44",
                "message_text_only": "Good morning cdecker,\n\n> I was looking into the docs [1] and stumbled over `createinvoice` which does almost what you need. However it requires the preimage, and stores the invoice in the database which you don't want.\n\nIndeed, that is precisely the issue, we need a `signfakeinvoice` command, as we cannot know at invoice creation time the preimage, and our invoice database currently assumes every invoice has a preimage known and recorded in the database.\n\n>\n> However if you have access to the `hsm_secret` you could sign in the plugin itself, completely sidestepping `lightningd`. Once you have that it should be a couple of days work to get a PoC plugin for the coordination and testing. From there it depends on how much polish you want to apply and what other systems you want to embed it into.\n\nWell, the point of an `hsmd` is that it might be replaced with a driver to an actual hardware signing module (H S M).\nThe `lightningd`<->`hsmd` interface includes commands for invoice signing, and `signfakeinvoice` would essentially just expose that interface, so an HSM has to support that interface.\nSo a plugin cannot rely on `hsm_secret` existing, as the signer might not be emulated in software (i.e. what we do now) but be an actual hardware signer that does not keep the secret keys on the same disk.\nThis is the reason why we (well, I) created and exposed `getsharedsecret`, in theory a plugin could just read `hsm_secret`, but we want to consider a future where the HSM is truly a hardware module.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Ronan McGovern",
                "date": "2021-12-17T18:29:39",
                "message_text_only": "If there is a payment to go from party A to be split between parties B & C,\nis it possible that only one of B or C would need a plugin?\n\nIf all receiving parties need a plugin that is quite limiting. Thanks, Ronan\n\nOn Fri, Dec 17, 2021 at 3:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning cdecker,\n>\n> > I was looking into the docs [1] and stumbled over `createinvoice` which\n> does almost what you need. However it requires the preimage, and stores the\n> invoice in the database which you don't want.\n>\n> Indeed, that is precisely the issue, we need a `signfakeinvoice` command,\n> as we cannot know at invoice creation time the preimage, and our invoice\n> database currently assumes every invoice has a preimage known and recorded\n> in the database.\n>\n> >\n> > However if you have access to the `hsm_secret` you could sign in the\n> plugin itself, completely sidestepping `lightningd`. Once you have that it\n> should be a couple of days work to get a PoC plugin for the coordination\n> and testing. From there it depends on how much polish you want to apply and\n> what other systems you want to embed it into.\n>\n> Well, the point of an `hsmd` is that it might be replaced with a driver to\n> an actual hardware signing module (H S M).\n> The `lightningd`<->`hsmd` interface includes commands for invoice signing,\n> and `signfakeinvoice` would essentially just expose that interface, so an\n> HSM has to support that interface.\n> So a plugin cannot rely on `hsm_secret` existing, as the signer might not\n> be emulated in software (i.e. what we do now) but be an actual hardware\n> signer that does not keep the secret keys on the same disk.\n> This is the reason why we (well, I) created and exposed `getsharedsecret`,\n> in theory a plugin could just read `hsm_secret`, but we want to consider a\n> future where the HSM is truly a hardware module.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/03842abd/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-12-18T00:22:56",
                "message_text_only": "Good morning Ronan,\n\n> If there is a payment to go from party A to be split between parties B & C, is it possible that only one of B or C would need a plugin?\n>\n> If all receiving parties need a plugin that is quite limiting. Thanks, Ronan\n\nGiven N payees, only N - 1 need the plugin.\n\nThe last payee in a chain of payees issues a normal invoice (C-Lightning plugin not needed).\nThen the previous payee takes in that invoice, and emits a new invoice, using the plugin.\nThis goes on until the first payee is reached.\nThe first payee then issues its invoice to the payer.\n\nTo follow your example, where A pays to both B and C:\n\n* C issues a normal invoice (no plugin needed).\n* C hands its invoice over to B.\n* B receives the invoice from C and issues a plugin-provided command (`addtoinvoice`?), which creates another invoice\n* B hands its invoice over to A.\n* A pays the invoice (no plugin needed).\n\nAs another example, suppose we have you paying cdecker, jb55, and ZmnSCPxj.\nLet us sort them in alphabetical order.\n\n* ZmnSCPxj issues a normal invoice (no plugin needed).\n* ZmnSCPxj hands its invoice over to jb55.\n* jb55 issues a plugin-provided command, giving it the invoice from ZmnSCPxj and getting out a larger invoice.\n* jb55 hands its invoice over to cdecker.\n* cdecker issues a plugin-provided command, giving it the invoice from jb55 and getting  out a larger invoice.\n* cdecker hands over its invoice to Ronan.\n* Ronan pays the invoice (no plugin needed).\n\nRegards,\nZmnSCPxj\n\n\n>\n> On Fri, Dec 17, 2021 at 3:06 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning cdecker,\n> >\n> > > I was looking into the docs [1] and stumbled over `createinvoice` which does almost what you need. However it requires the preimage, and stores the invoice in the database which you don't want.\n> >\n> > Indeed, that is precisely the issue, we need a `signfakeinvoice` command, as we cannot know at invoice creation time the preimage, and our invoice database currently assumes every invoice has a preimage known and recorded in the database.\n> >\n> > >\n> > > However if you have access to the `hsm_secret` you could sign in the plugin itself, completely sidestepping `lightningd`. Once you have that it should be a couple of days work to get a PoC plugin for the coordination and testing. From there it depends on how much polish you want to apply and what other systems you want to embed it into.\n> >\n> > Well, the point of an `hsmd` is that it might be replaced with a driver to an actual hardware signing module (H S M).\n> > The `lightningd`<->`hsmd` interface includes commands for invoice signing, and `signfakeinvoice` would essentially just expose that interface, so an HSM has to support that interface.\n> > So a plugin cannot rely on `hsm_secret` existing, as the signer might not be emulated in software (i.e. what we do now) but be an actual hardware signer that does not keep the secret keys on the same disk.\n> > This is the reason why we (well, I) created and exposed `getsharedsecret`, in theory a plugin could just read `hsm_secret`, but we want to consider a future where the HSM is truly a hardware module.\n> >\n> > Regards,\n> > ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Split payments within one LN invoice",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Christian Decker",
                "Ronan McGovern",
                "William Casarin"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 25785
        }
    },
    {
        "title": "[Lightning-dev] Route reliability<->fee trade-off control parameter",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2021-12-17T08:31:15",
                "message_text_only": "On Mon, Nov 22, 2021 at 7:53 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Dave,\n>\n> > If LN software speculatively chooses a series of attempts with a similar\n> > 95%, accounting for things like the probability of a stuck payment (made\n> > worse by longer CLTV timeouts on some paths), it could present users\n> > with the same sort of options:\n> >\n> > ~1 second, x fee\n> > ~3 seconds, y fee\n> > ~10 seconds, z fee\n> >\n> > This allows the software to use its reliability scoring efficiently in\n> > choosing what series of payment attempts to make and presents to the\n> > user the information they need to make a choice appropriate for their\n> > situation. As a bonus, it makes it easier for wallet software to move\n> > towards a world where there is no user-visible difference between\n> > onchain and offchain payments, e.g.:\n> >\n> > ~1 second, w fee\n> > ~15 seconds, x fee\n> > ~10 minutes, y fee\n> > ~60 minutes, z fee\n>\n> This may not match ideally, as in the worst case a forwarding might be\n> struck by literal lightning and dropped off the network while your HTLC is\n> on that node, only for the relevant channel to be dropped onchain days\n> later when the timeout comes due.\n> Providing this \"seconds\" estimate does not prepare users for the\n> possibility of such black swan events where a high fee transaction gets\n> stalled due to an accident on the network.\n>\n\nI like the idea of providing the user with such choices, similar to how for\nexample Uber presents its options. But I also agree with Z that it is\nprobably impossible to get a number of seconds there that comes close to\nthe actual time it would take.\n\nFor LND, I am currently proposing a fuzzy \"time preference\" parameter that\nis vaguely indicative of the time that the payment is expected to take (\nhttps://github.com/lightningnetwork/lnd/pull/6024). On the UI level this\ncan either be surfaced as a slider or the cost for three predefined values\nfor time preference can be shown:\n\nSlow: 10 msat\nNormal: 150 msat\nFast: 4000 msat\n\n\n> Why not just ask for a fee budget for a payment, and avoid committing\n> ourselves to paying within some number of seconds, given that the seconds\n> estimate may very well vary depending on local CPU load?\n>\nWould users really complain overmuch if the number of seconds is not\n> provided, given that we cannot really estimate this well?\n>\n\nA fee budget indeed expresses the time preference indirectly. But how does\nthe user know what a reasonable value is to set this to? It is depend on\nnetwork conditions. They may accidentally set it to a value that is too low\nand get an unexpectedly slow payment.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/745a7613/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-12-17T08:49:51",
                "message_text_only": "On Mon, Nov 22, 2021 at 5:11 PM Stefan Richter <richter at cs.rwth-aachen.de>\nwrote:\n\n> I also don't believe putting a choice of more or less seconds expectation\n> in the UI makes for a great user experience. IMHO the goal should just be:\n> give the user an estimate of fees necessary to succeed within a reasonable\n> time. Maybe give them an option to optimize for fees only if they are\n> really cheap and don't care at all if the payment succeeds.\n>\n\nIn the ideal world, I'd agree to this. But how close to that are we today?\nSuppose we'd define reasonable time as 3 seconds to complete the payment.\nAnd to stay below that, we need to use a short, expensive, high success\nprobability route that amounts to a fee of 1%. Would users be happy with a\ntake it or leave it approach or rather pay 0.1% and wait 30 seconds?\n\nI think that for the state of Lightning as it is currently, some kind of\ncontrol lever is useful to bridge the gap to payments that are always fast\nand cheap. The checkbox that you propose is also a control lever, but it is\npretty minimalistic.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/df17d14a/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Route reliability<->fee trade-off control parameter",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Joost Jager"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4073
        }
    },
    {
        "title": "[Lightning-dev] Payment sender authentication",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2021-12-17T10:37:12",
                "message_text_only": "Hello list,\n\nIn Lightning we have a great scheme to protect the identity of the sender\nof a payment. This is awesome, but there are also use cases where opt-in\nsender authentication is desired.\n\nAn example of such a use case is chat over lightning. If you receive a text\nmessage, you generally want to know whom it originates from. For whatsat\n[1], I added a custom record containing an ECDSA signature over `sender |\nrecipient | timestamp | msg`. I believe other chat protocols on lightning\nuse a similar construction.\n\nFor regular payments however, sender authentication can be useful too. A\ndonation for example doesn't always need to be anonymous. A donor may want\nto reveal themselves. In other cases, sender authentication can add a layer\nof protection against payments getting lost. It provides the receiver with\nanother field that they can use to retrieve lost payment information.\n\nOn the receiver side, sender authentication also creates new possibilities.\nA receiver could for example create an invoice that is locked to a specific\nsource node.\n\nAlso wanted to note that the sender identity doesn't need to be the actual\nnode identity. It can also be an unrelated key that could for example be\nspecific to the service that is being paid to. For example, one registers\nthe public part of a dedicated key pair with an exchange and the exchange\nthen only accepts deposits authenticated with that key.\n\nThe reason for bringing this up on the list is that I wanted to see what\npeople think is the best way to do it technically. The whatsat approach\nwith an ECDSA signature doesn't look ideal to me because of the\nnon-repudiation property. Also care needs to be taken that whatever data\nthe sender includes, cannot be reused.\n\nAnother option that I can think of is to derive a shared secret using ECDH\nwith the sender and receiver node keys and then attach a custom record to\nthe payment containing the sender node key and an HMAC of the payment hash\nusing the shared secret as a key.\n\nI am sure there people better versed in cryptography than me who have an\nopinion on this. Thoughts?\n\nJoost\n\n[1] https://github.com/joostjager/whatsat\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211217/cdda3204/attachment.html>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-12-18T13:07:56",
                "message_text_only": "Good morning, Joost.\n\nAs a temporary solution, I suggest taking a look at\nhttps://github.com/fiatjaf/lnurl-rfc/blob/luds/18.md. The idea is that you\ncan either provide\n - a lone pubkey (to be used for manually identifying the payer later if\nnecessary);\n - a domain-specific pubkey along with a signature of a challenge provided\nby the receiver; or\n - an unauthenticated name or email (for light things like donations for\nwhich one may not care very much about cryptographic authentication).\nAnd then you commit these things, whatever they are, inside the BOLT11\npayment request using the 'h' tag.\n\nfiatjaf\n\n\n\nOn Fri, Dec 17, 2021 at 7:37 AM Joost Jager <joost.jager at gmail.com> wrote:\n\n> Hello list,\n>\n> In Lightning we have a great scheme to protect the identity of the sender\n> of a payment. This is awesome, but there are also use cases where opt-in\n> sender authentication is desired.\n>\n> An example of such a use case is chat over lightning. If you receive a\n> text message, you generally want to know whom it originates from. For\n> whatsat [1], I added a custom record containing an ECDSA signature over\n> `sender | recipient | timestamp | msg`. I believe other chat protocols on\n> lightning use a similar construction.\n>\n> For regular payments however, sender authentication can be useful too. A\n> donation for example doesn't always need to be anonymous. A donor may want\n> to reveal themselves. In other cases, sender authentication can add a layer\n> of protection against payments getting lost. It provides the receiver with\n> another field that they can use to retrieve lost payment information.\n>\n> On the receiver side, sender authentication also creates new\n> possibilities. A receiver could for example create an invoice that is\n> locked to a specific source node.\n>\n> Also wanted to note that the sender identity doesn't need to be the actual\n> node identity. It can also be an unrelated key that could for example be\n> specific to the service that is being paid to. For example, one registers\n> the public part of a dedicated key pair with an exchange and the exchange\n> then only accepts deposits authenticated with that key.\n>\n> The reason for bringing this up on the list is that I wanted to see what\n> people think is the best way to do it technically. The whatsat approach\n> with an ECDSA signature doesn't look ideal to me because of the\n> non-repudiation property. Also care needs to be taken that whatever data\n> the sender includes, cannot be reused.\n>\n> Another option that I can think of is to derive a shared secret using ECDH\n> with the sender and receiver node keys and then attach a custom record to\n> the payment containing the sender node key and an HMAC of the payment hash\n> using the shared secret as a key.\n>\n> I am sure there people better versed in cryptography than me who have an\n> opinion on this. Thoughts?\n>\n> Joost\n>\n> [1] https://github.com/joostjager/whatsat\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211218/014f1a00/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-12-20T08:01:37",
                "message_text_only": "Hi fiatjaf and peter,\n\nOn Sat, Dec 18, 2021 at 2:08 PM fiatjaf <fiatjaf at gmail.com> wrote:\n\n> As a temporary solution, I suggest taking a look at\n> https://github.com/fiatjaf/lnurl-rfc/blob/luds/18.md. The idea is that\n> you can either provide\n>  - a lone pubkey (to be used for manually identifying the payer later if\n> necessary);\n>  - a domain-specific pubkey along with a signature of a challenge provided\n> by the receiver; or\n>  - an unauthenticated name or email (for light things like donations for\n> which one may not care very much about cryptographic authentication).\n> And then you commit these things, whatever they are, inside the BOLT11\n> payment request using the 'h' tag.\n>\n\nInteresting read. I see it uses a signature, but is that a good idea? It\ncould allow the receiver to prove to a 3rd party that the payment was made.\nI guess it depends on the application if that is desired or not. The more\nprivacy conscious users would probably try to avoid committing to data via\na signature.\n\nOn Sat, Dec 18, 2021 at 6:56 PM Peter Todd <pete at petertodd.org> wrote:\n\n> Lightning already has sender authentication: you simply give someone a\n> pre-image hash over an authenticated channel, and the fact that the\n> payment was\n> made means only they could have realistically made it as they were the only\n> person who knew that pre-image hash.\n>\n\nThis sounds quite similar to what is described above in lnurl-18. I can see\nthat that works, but I should have added that I was looking for a solution\nthat exists completely within the protocol without using an additional\nchannel. Also, routing nodes learn the preimage hash too, so the sender\nisn't the only person. But that is solved by the payment secret that is\nalso part of the invoice.\n\n\n> Going beyond that is dangerous as you're creating the ability to prove to a\n> *third* party who made a particular payment. That raises serious problems\n> in\n> cases like government raids that need to be considered very carefully.\n\n\nThis is why I proposed to use diffie-hellman to generate a shared secret.\nThe receiver could then have made up all the proofs themselves and are\ntherefore of no value to a third party.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211220/94125b03/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2021-12-20T12:56:28",
                "message_text_only": "On Mon, Dec 20, 2021 at 09:01:37AM +0100, Joost Jager wrote:\n> On Sat, Dec 18, 2021 at 6:56 PM Peter Todd <pete at petertodd.org> wrote:\n> \n> > Lightning already has sender authentication: you simply give someone a\n> > pre-image hash over an authenticated channel, and the fact that the\n> > payment was\n> > made means only they could have realistically made it as they were the only\n> > person who knew that pre-image hash.\n> >\n> \n> This sounds quite similar to what is described above in lnurl-18. I can see\n> that that works, but I should have added that I was looking for a solution\n> that exists completely within the protocol without using an additional\n> channel. Also, routing nodes learn the preimage hash too, so the sender\n> isn't the only person. But that is solved by the payment secret that is\n> also part of the invoice.\n\nThe key thing is the invoice has to get to the sender somehow in the first\nplace. So I don't think there's any reason to use the lightning protocol itself\nfor additional authentication.\n\n> > Going beyond that is dangerous as you're creating the ability to prove to a\n> > *third* party who made a particular payment. That raises serious problems\n> > in\n> > cases like government raids that need to be considered very carefully.\n> \n> \n> This is why I proposed to use diffie-hellman to generate a shared secret.\n> The receiver could then have made up all the proofs themselves and are\n> therefore of no value to a third party.\n\nThe purpose of diffie-hellman is to generate a shared secret in the absense of\na secure channel. Once you have a secure channel there's no reason to use it.\nSimply giving the sender the payment info is sufficient.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211220/3d42edd8/attachment.sig>"
            },
            {
                "author": "fiatjaf",
                "date": "2021-12-20T16:06:41",
                "message_text_only": "Hi Joost,\n\nOn Mon, Dec 20, 2021 at 5:02 AM Joost Jager <joost.jager at gmail.com> wrote:\n\n> Hi fiatjaf and peter,\n>\n> On Sat, Dec 18, 2021 at 2:08 PM fiatjaf <fiatjaf at gmail.com> wrote:\n>\n>> As a temporary solution, I suggest taking a look at\n>> https://github.com/fiatjaf/lnurl-rfc/blob/luds/18.md. The idea is that\n>> you can either provide\n>>  - a lone pubkey (to be used for manually identifying the payer later if\n>> necessary);\n>>  - a domain-specific pubkey along with a signature of a challenge\n>> provided by the receiver; or\n>>  - an unauthenticated name or email (for light things like donations for\n>> which one may not care very much about cryptographic authentication).\n>> And then you commit these things, whatever they are, inside the BOLT11\n>> payment request using the 'h' tag.\n>>\n>\n> Interesting read. I see it uses a signature, but is that a good idea? It\n> could allow the receiver to prove to a 3rd party that the payment was made.\n> I guess it depends on the application if that is desired or not. The more\n> privacy conscious users would probably try to avoid committing to data via\n> a signature.\n>\n\nJust to clarify:\n\nFor the lone pubkey method there are no privacy implications I think, since\nit's just a random pubkey and can be used later only if needed in some\ncustom way.\n\nFor the signature method the privacy implications are close to none (unless\nI'm missing something) because the key used to sign is (supposed to be)\ngenerated by a method that makes it specific to the DNS domain of the\nservice being paid. Since this assumes an LNURL request that has a domain,\nthe key will be generated with something like `HMAC(domain, seed_key)` (the\nspecifics don't matter) so it will not be possible for anyone to relate\nthat signature to anyone. Only the receiver service will be able to relate\nit to other payments (or logins) to that same exact service -- which can\nprove quite handy in many cases.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211220/d98a888e/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2021-12-18T17:56:09",
                "message_text_only": "On Fri, Dec 17, 2021 at 11:37:12AM +0100, Joost Jager wrote:\n> Hello list,\n> \n> In Lightning we have a great scheme to protect the identity of the sender\n> of a payment. This is awesome, but there are also use cases where opt-in\n> sender authentication is desired.\n\nLightning already has sender authentication: you simply give someone a\npre-image hash over an authenticated channel, and the fact that the payment was\nmade means only they could have realistically made it as they were the only\nperson who knew that pre-image hash.\n\nGoing beyond that is dangerous as you're creating the ability to prove to a\n*third* party who made a particular payment. That raises serious problems in\ncases like government raids that need to be considered very carefully.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20211218/328206a3/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Payment sender authentication",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Peter Todd",
                "fiatjaf",
                "Joost Jager"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 13170
        }
    }
]