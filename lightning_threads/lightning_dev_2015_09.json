[
    {
        "title": "[Lightning-dev] Loop attack with onion routing..",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2015-09-01T07:07:30",
                "message_text_only": "Anthony Towns schreef op di 01-09-2015 om 07:08 [+1000]:\n> On 31 August 2015 at 04:01, CJP <cjp at ultimatestunts.nl> wrote:\n>         >         A - b - c - D - e - F - g - H\n>         >         H pays 0.003 mBTC to F (explicit source routing fee;\n>         H\n>         >         selected F for\n>         >         onion-routing towards D, without A's knowledge)\n>         > You mean \"D selected F for onion-routing towards H\" here,\n>         surely?\n>         No :-)\n>         Both sides of a payment may value their privacy, so both sides\n>         may want\n>         to perform onion routing independently.\n>         \u200b \u200b\n>         It's a bit similar to TOR hidden\n>         services: you route from both sides towards a \"meeting point\"\n>         somewhere\n>         on the route, which is not necessarily one of the end points.\n> \n> \n> Hmm. I would look at that more like:\n> \n> \n> Setup:\n>  - H wants to be secretive.\n>  - H establishes a channel with g\n\nYes.\n\n>  - H tells F he can route to H via g\n>  - H tells D he can route to H via F\n\nNo. If H has a routable address (which is optional in this scenario,\nsince it's not used here), it would be \"g tells F he can route to H via\ng\". But that information isn't used here, and the transaction isn't tied\nto H's routable address, since there is no \"routing to H\" in this\nscenario: there is only routing from A to D and from H to D through F.\n\n> Announcement:\n>  - H tells other people (such as A) they can route to H via D\n\nNo. H just tells A he can route this particular transaction to D. A\ndoesn't know H.\n> \n> Then A sends a txn for H to D as instructed, and D chooses to forward\n> it on via F.\n\nNo. The sequence is:\n- A establishes a route to D as instructed\n- H establishes a route to F, and instructs F to establish a route to D\n- F establishes a route to D as instructed\n- D matches the two sides, and informs both sides that a route is\npresent. \n- The transaction is locked (HTLC created), starting on the A-b link,\nthen b-c, and so on, all the way to the g-H link.\n> \n> (Hmm. In that scenario, if e tried to send a txn to H, she would route\n> via D, then find D routed the txn back to it -- using the same R --\n> and that F was the next destination. This would be an information\n> leak, arguably. Likewise for anyone whose cheapest path to D was\n> through e)\n\nDoes not apply to the way I describe how it should work.\n> \n>         Note that, because locking of transaction funds is always done\n>         in payer\n>         -> payee direction, this requires a separate routing phase\n>         before the\n>         locking. So, first you find a route (where all parties say\n>         they agree to\n>         fees, tx amount, timeouts and other conditions), and then you\n>         start\n>         performing transaction-channel actions.\n> \n> \n> Isn't that a bit circular -- \"you obtain the route by sending messages\n> along the route\" ? \n\nNo. Route finding can consist of several attempts, and each attempt\nconsists of sending messages between nodes. Once you find a route\n(probably the first attempt in a well-optimized routing system), you can\nsend further messages along the route, but you did in fact already send\nmessages along the route prior to knowing that it will become your\nroute.\n> \n> It also relies on end-to-end communication in realtime, which wouldn't\n> work for paying to a cold-wallet lightning channel that's only\n> occassionally online.\n\nI don't see how lightning could pay to a cold wallet. I assume that, at\nleast when starting a transaction, all nodes on the route are online.\n> \n> If you *did* assume everything is in realtime, you could avoid fines\n> entirely just by having the protocol be something like:\n> \n> \n>  - the official timeout was 4 days, the unofficial timeout is 4\n> minutes\n>  - ...\n>  - okay 4 minutes is up, do you know R?\n>  - no, okay, we're revoking the transaction.\n>  - you don't want to? fine, channel is closed.\n\nI assume the \"official\" timeout is the one mentioned in the HTLC; it has\nto be large (several days) to avoid nodes becoming vulnerable due to\nloss of connectivity in the middle of a transaction: it might take you\nsome time to establish an alternative internet connection, and it has to\nhappen before the official timeout.\n\nNeighbors can always try to impose shorter unofficial time-outs, with\nthe sanction that the channel will be closed. The consequence is that\nboth sides, and the network as a whole, lose a link, so it should be\navoided if possible.\n> \n> Maybe that's what the default protocol should be anyway, and fines are\n> just an extension to that to bribe the payer not to close the\n> channel...\n\nYes.\n\n>         You could of course ignore source routing for the fines, and\n>         distribute\n>         the fines as if it is only a non-source routing path. The\n>         problem is\n>         that an attacker can create an arbitrarily long path with\n>         source\n>         routing, thereby creating arbitrarily large total damage to\n>         the network,\n>         corresponding to arbitrarily large total fines. \n> \n> \n> \u200bI don't think it can go arbitrarily large -- if the recipient is\n> paying the fines at each point, then the scenario is:\n\nI don't understand how an intermediate point (D or F) can enforce\npayment of fines by A or H.\n\nYou could of course pre-pay the fines with a separate transaction, which\nhas D or F as payee endpoint, and send the fines back in case of a\nsuccessful transaction. This assumes the intermediate nodes are trusted\nwith the fine amounts.\n\nCJP"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-01T07:56:54",
                "message_text_only": "On 1 September 2015 at 17:07, CJP <cjp at ultimatestunts.nl> wrote:\n\n> Anthony Towns schreef op di 01-09-2015 om 07:08 [+1000]:\n> > On 31 August 2015 at 04:01, CJP <cjp at ultimatestunts.nl> wrote:\n> >         >         A - b - c - D - e - F - g - H\n> No. H just tells A he can route this particular transaction to D. A\n> doesn't know H.\n>\n\n\u200bThat doesn't make sense to me -- if A doesn't know H, how can H tell A\nanything?\n\n\n> > Then A sends a txn for H to D as instructed, and D chooses to forward\n> > it on via F.\n>\n> No. The sequence is:\n> - A establishes a route to D as instructed\n> - H establishes a route to F, and instructs F to establish a route to D\n>\n\n\u200bSame here; how does H know to do anything? A doesn't know H, so A can't\ntell them. If D's telling H, then isn't D already using the F/g route to do\nso?\u200b\n\n- F establishes a route to D as instructed\n> - D matches the two sides, and informs both sides that a route is\n> present.\n> - The transaction is locked (HTLC created), starting on the A-b link,\n> then b-c, and so on, all the way to the g-H link.\n>\n\n\n> > It also relies on end-to-end communication in realtime, which wouldn't\n> > work for paying to a cold-wallet lightning channel that's only\n> > occassionally online.\n\nI don't see how lightning could pay to a cold wallet.\n\n\n\u200bMaybe. The case I'm thinking about is if you're doing most of your\nday-to-day transactions over lightning (buying coffee and lunch and\ngroceries and bus tickets and fuel and whatnot), then your channels will\nempty out pretty quickly; so you'll want to have some way to \"get money\nfrom the ATM\" once a week or so. And conversely you'll want some way to put\nyour salary into the \"ATM\" as well. Doing that via the blockchain works\nfine of course, but then your average lightning user is doing a blockchain\ntransaction once every week or three, rather than once every two years,\n\n>         You could of course ignore source routing for the fines, and\n> >         distribute\n> >         the fines as if it is only a non-source routing path. The\n> >         problem is\n> >         that an attacker can create an arbitrarily long path with\n> >         source\n> >         routing, thereby creating arbitrarily large total damage to\n> >         the network,\n> >         corresponding to arbitrarily large total fines.\n> > \u200bI don't think it can go arbitrarily large -- if the recipient is\n> > paying the fines at each point, then the scenario is:\n> I don't understand how an intermediate point (D or F) can enforce\n> payment of fines by A or H.\n>\n\nI think fines have to be paid on the payee side, so H not A -- it's the\npayee that can close the transaction early, so if they choose not to, it's\ntheir responsibility. I think that's independent of whether the routing was\nsource/non-source (though for source routing, the original payer might add\nsome fees to cover the potential fines).\n\nThen doesn't it just reduce to enforcing payments from your direct\nneighbour, and relying on them transitively doing the same? ie, D forces e\nto pay a fine, and in order to cover those costs e forces F to pay a larger\nfine, F forces g to pay an even larger fine, and g forces H to cover all of\nthat.\n\nCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150901/b6387f72/attachment.html>"
            },
            {
                "author": "CJP",
                "date": "2015-09-01T19:48:38",
                "message_text_only": "Anthony Towns schreef op di 01-09-2015 om 17:56 [+1000]:\n> On 1 September 2015 at 17:07, CJP <cjp at ultimatestunts.nl> wrote:\n> \n>         Anthony Towns schreef op di 01-09-2015 om 07:08 [+1000]:\n>         > On 31 August 2015 at 04:01, CJP <cjp at ultimatestunts.nl>\n>         wrote:\n>         >         >         A - b - c - D - e - F - g - H\n>         No. H just tells A he can route this particular transaction to\n>         D. A\n>         doesn't know H.\n> \n> \n> \u200bThat doesn't make sense to me -- if A doesn't know H, how can H tell\n> A anything?\n\nSorry, that must have been confusing.\n\nThe way I see it (and the way it's implemented in Amiko Pay), payer and\npayee (A and H in the scenario) have a direct communication link between\neach other (temporary, for the duration of the payment), to coordinate\nthe payment. They exchange things like the hash of R, the to-be-paid\namount and the address of the meeting point (D).\n\nCurrently, it's a normal TCP connection, so they know each others' IP\naddress, but I guess that, even without changes to the Amiko Pay code,\nyou could run Amiko Pay as a TOR hidden service (payer connects to\npayee, so payee has to be the hidden service). Or they could meet each\nother physically (without knowing each other), and communicate over a\ntemporary link (WiFi, Bluetooth or something else).\n\nThere is no technical reason why they should know each others' identity,\nIP address or any routable address on the Lightning / Amiko network.\n\nI guess your further questions followed from this issue. Is it all clear\nnow?\n\nCJP\n\n>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-01T22:01:58",
                "message_text_only": "On 2 September 2015 at 05:48, CJP <cjp at ultimatestunts.nl> wrote:\n\n> The way I see it (and the way it's implemented in Amiko Pay), payer and\n> payee (A and H in the scenario) have a direct communication link between\n> each other (temporary, for the duration of the payment), to coordinate\n> the payment. They exchange things like the hash of R, the to-be-paid\n> amount and the address of the meeting point (D).\n>\n\n\u200bOkay, I was figuring a *much* more lightweight initiation, essentially\njust a one-way \u200bpacket from H (or someone representing H) to A giving hash\nof R, amount, and the routable lightning address it needs to get to (\"H via\nD\" maybe). That way you can kick a lightning transaction off by QR code or\nNFC as well as over TCP, which I think would be nice. (A printed price tag\ncould literally be all you need to pay for an item!)\n\nAlso, I think it makes it easier for you to add payment-by-lightning to\nother protocols; eg if you want your bittorrent client to demand a\nlightning payment every 10MB, you can just set it up with a bunch of hashes\nto send to peers, and preimages to check to confirm payment, and otherwise\nhave it operate completely independent of the lightning protocol. ie, it's\njust:\n\n  if (peer->balance < 100kb) {\n    choose_hash(&peer->payment);\n    send(\"Payment required: R=%s A=%d H=%s\", peer->payment.hash, std_amt(),\nlightning_route);\n    wait_for_preimage(peer->payment.preimage);\n    peer->balance += 1MB;\n  }\n  sent_len = send_block();\n  peer->balance -= sent_len\n\nand the lightning stuff can happen entirely out of band -- it only needs to\nshare the list of hashes and preimages, and agree on the amounts to accept.\n\n\u200bThere might be a security benefit there too; even having a tor connection\nopen to someone gives you more chance of finding a buffer overflow and\ntaking control of their system than just viewing a QR code they present to\nyou?\u200b\n\n\u200bCheers,\naj\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150902/3a5e66a8/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-02T05:42:52",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> In that case $1 uBTC is $4.80, and 1 satoshi is about 5c; so you couldn't\n> charge a fee less than 1% for a $5 coffee, and couldn't spend less than 5c\n> when doing microtransactions.\n\nI was momentarily tempted to make HTLCs in thousandths of satoshi.\nObviously, you'd have some agreed rounding for the on-chain versions.\n\nThis has the advantage that you can only have 0.042 BTC (~$10) per HTLC.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Loop attack with onion routing..",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "CJP"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13063
        }
    },
    {
        "title": "[Lightning-dev] A state machine.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-09-01T07:32:49",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 31 August 2015 at 11:04, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> > I was thinking it would be possible to update many HTLCs at once, so\n>> > I was expecting a single PKT_UPDATE_CHANNEL rather than the ADD_HTLC,\n>> > COMPLETE_HTLC, TIMEOUT_HTLC, etc variants. From a protocol POV, I guess\n>> > that's something like:\n>> This is the kind of optimization we may see later, but I really shy away\n>> from doing it now.  Your diagram looks simpler because you removed all\n>> the rest of the handshaking.  Try this:\n>>\n>\n> \u200bI think the statepy.svg includes all the handshaking (including errors,\n> but I think excluding internal errors) apart from the nop state\n> transitions. Having a single PKT_UPDATE_CHANNEL would just combine those\n> into one subgraph / one edge.\n\nMy instinct is to encode as much in the state itself as possible,\nbecause it simplifies verification.\n\n> I'm a bit surprised that CMD_CLOSE isn't a valid option when proposing an\n> update -- it's valid during WAIT_FOR_UPDATE_SIG but not\n> WAIT_FOR_HTLC_ACCEPT/WAIT_FOR_UPDATE_COMPLETE.\n\nLooking at that git tree (I've done some work since then)...  Ah, you\ncan't send a command while processing an existing command.  Seems a\nlogical simplification.\n\n> (Correspondingly, PKT_CLOSE\n> doesn't seem valid during WAIT_FOR_UPDATE_SIG)\n\nIt's a corrollary of the above.\n\n> A: ADD_HTLC --> B: DECLINE_HTLC\n>>   OR\n>> A: ADD_HTLC --> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n>>\n>> After success:\n>>\n>> B: FULFILL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n>>   OR\n>> B: ROUTEFAIL_HTLC -> A: ACCEPT --> B: SIGNATURE --> A: COMPLETE\n>>   OR\n>> A: TIMEDOUT_HTLC -> B: ACCEPT --> A: SIGNATURE --> B: COMPLETE\n>>\n>> This makes the constraints clearer, eg. you can't DECLINE_HTLC anything\n>> but an ADD_HTLC.\n>>\n>\n> \u200bYour states currently allow declining those though:\n\nNot at all (or if it does, it's a bug).  Each state is defined as\nsomething which can accept inputs, and for which all those inputs are\nalways valid.\n\n> If your counterparty proposes a broken HTLC update, I'm not sure there's\n> harm in being allowed to decline it? They can choose to close the channel\n> if they think you're unreasonable, retry the update if they found a\n> mistake, or just forget it and not worry (if they were issuing a ROUTEFAIL,\n> it's not /their/ funds that are on the line eg).\n\nThe simplest (and safest) system is always to error and close when they\nbreak protocol.  There's some game theory involved in whether you should\nwait or not, but in the end, they're broken and there's not much you can\ndo.\n\n> I also wonder if\n>\n>   A: TIMEDOUT_HTLC -> B: DECLINE (err_time_sync_lost)\n>\n> might be useful.\n\nI don't think it's useful, though if you disagree on time you might get\nan error packet.  (What else can you do?)\n\nPerhaps we should add a current time field to UPDATE_ADD_HTLC so you can\ndefuse clock sync problems earlier?\n\n>> AFAICS, you still have a potential deadlock atm if you think you're\n>> > high priority but your counterparty also thinks they're high priority,\n>> > or just missed your update packet. I think there might be a similar\n>> > deadlock if both systems think they're low priority.\n>> They can't get into that state.\n>\n> \u200bSorry, I was assuming that one or both implementations were buggy. I meant\n> to make that explicit.\u200b You're talking with strangers on the network, so\n> you can't assume their software is bug free, right?\n\nThat applies to any scheme you come up with, though.  Propose something\nsimpler, and I'll gladly rewrite.\n\n> BTW, your states currently switch priority even when an update is declined,\n> so the low bit of the current commitment id (which obviously isn't changed\n> on a declined update) doesn't actually give you the priority afaics.\n\nTrue!  I will change that, since it's conceptually simpler.\n\nThanks,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-01T22:32:42",
                "message_text_only": "On 1 September 2015 at 17:32, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Looking at that git tree (I've done some work since then)...\n\n\n\u200bOh, github hasn't been updated since Aug 20? That's forever ago!\u200b\n\n\n> Ah, you\n> can't send a command while processing an existing command.  Seems a\n> logical simplification.\n>\n\nI'm thinking of CMD_CLOSE like \"Ctrl-C\"; why wouldn't you want it to work\nanytime?\u200b\n\n\n> >> This makes the constraints clearer, eg. you can't DECLINE_HTLC anything\n> >> but an ADD_HTLC.\n> > \u200bYour states currently allow declining those though:\n> Not at all (or if it does, it's a bug).\n\n\n\u200bRight, it's a bug as of \u200b52cda01 then :)\n\n\u200b\u200b\n> The simplest (and safest) system is always to error and close when they\n> break protocol.  There's some game theory involved in whether you should\n> wait or not, but in the end, they're broken and there's not much you can\n> do.\n>\n\n\u200bWell, you can ignore some errors -- time sync problems might resolve\nthemselves, eg. And the \"error\" might be because of an error on your side\n(your admin ran the wrong date command, there's a bug in your code), that\nmight well be fixable. I guess what I'm thinking is that closing a channel\nis a real cost; if they're not actively cheating -- by not completing an\nHTLC update once they agree to it eg -- I'd probably rather it stay open\n(in degraded mode perhaps) than automatically close.\n\n> I also wonder if\n> >   A: TIMEDOUT_HTLC -> B: DECLINE (err_time_sync_lost)\n> > might be useful.\n> I don't think it's useful, though if you disagree on time you might get\n> an error packet.  (What else can you do?)\n>\n\n\u200bHow is \"an error packet\" different to a decline packet or a channel close?\u200b\n\nPerhaps we should add a current time field to UPDATE_ADD_HTLC so you can\n> defuse clock sync problems earlier?\n>\n\nOr maybe time sync is part of the p2p protocol?\u200b I guess channel\ncounterparties are always peers?\n\n> \u200bSorry, I was assuming that one or both implementations were buggy. I\n> meant\n> > to make that explicit.\u200b You're talking with strangers on the network, so\n> > you can't assume their software is bug free, right?\n> That applies to any scheme you come up with, though.  Propose something\n> simpler, and I'll gladly rewrite.\n\n\u200b\n\u200b\n\u200bI'll have another look when I can see current code :)\u200b\n\u200b\n\n\u200bCheers,\naj\u200b\n\n-- \nAnthony Towns <aj at erisian.com.au>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150902/447c3f60/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-02T05:55:44",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 1 September 2015 at 17:32, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> Looking at that git tree (I've done some work since then)...\n>\n> \u200bOh, github hasn't been updated since Aug 20? That's forever ago!\u200b\n>\n>\n>> Ah, you\n>> can't send a command while processing an existing command.  Seems a\n>> logical simplification.\n>>\n>\n> I'm thinking of CMD_CLOSE like \"Ctrl-C\"; why wouldn't you want it to work\n> anytime?\u200b\n\nYes, I think you do.  And the other side can CMD_CLOSE during an HTLC\nnegotiation (for example), so this should be allowed.\n\nI will update it to allow CMD_CLOSE at any time (except when already\nclosing).\n\n>> >> This makes the constraints clearer, eg. you can't DECLINE_HTLC anything\n>> >> but an ADD_HTLC.\n>> > \u200bYour states currently allow declining those though:\n>> Not at all (or if it does, it's a bug).\n>\n> \u200bRight, it's a bug as of \u200b52cda01 then :)\n\nWeird, my tester should have found that (every tested-for input must be\ngiven).\n\nAh, yes, it did, once I enhanced the tester to actually track htlcs.\nAnd I've fixed it :)\n\n(Those should be going to STATE_WAIT_FOR_UPDATE_ACCEPT).\n\n>> The simplest (and safest) system is always to error and close when they\n>> break protocol.  There's some game theory involved in whether you should\n>> wait or not, but in the end, they're broken and there's not much you can\n>> do.\n>>\n>\n> \u200bWell, you can ignore some errors -- time sync problems might resolve\n> themselves, eg. And the \"error\" might be because of an error on your side\n> (your admin ran the wrong date command, there's a bug in your code), that\n> might well be fixable. I guess what I'm thinking is that closing a channel\n> is a real cost; if they're not actively cheating -- by not completing an\n> HTLC update once they agree to it eg -- I'd probably rather it stay open\n> (in degraded mode perhaps) than automatically close.\n\nWe could add such things later, but it's really hard to know in advance\nwhat bugs will lose money and which can be ignored.\n\n>> I also wonder if\n>> >   A: TIMEDOUT_HTLC -> B: DECLINE (err_time_sync_lost)\n>> > might be useful.\n>> I don't think it's useful, though if you disagree on time you might get\n>> an error packet.  (What else can you do?)\n>>\n>\n> \u200bHow is \"an error packet\" different to a decline packet or a channel close?\u200b\n\nIt carries an ascii message giving you a clue :)\n\n> Perhaps we should add a current time field to UPDATE_ADD_HTLC so you can\n>> defuse clock sync problems earlier?\n>>\n>\n> Or maybe time sync is part of the p2p protocol?\u200b I guess channel\n> counterparties are always peers?\n\nYes, that makes sense.\n\n>> \u200bSorry, I was assuming that one or both implementations were buggy. I\n>> meant\n>> > to make that explicit.\u200b You're talking with strangers on the network, so\n>> > you can't assume their software is bug free, right?\n>> That applies to any scheme you come up with, though.  Propose something\n>> simpler, and I'll gladly rewrite.\n> \u200b\n> \u200bI'll have another look when I can see current code :)\u200b\n\nNW, just running the now-glacial state tester.  I'm sure there's only 1\nbug left!\n\nCheers,\nRusty."
            },
            {
                "author": "Jasper Hugunin",
                "date": "2015-09-02T19:36:44",
                "message_text_only": "I had an idea regarding an alternative to the high/low priority. My\nunderstanding is that the problem is this case:\nAlice sends PKT_UPDATE and transitions to WAIT_FOR_UPDATE_ACCEPT.\nBob sends PKT_UPDATE, and also transitions to WAIT_FOR_UPDATE_ACCEPT.\nThen Bob receives Alice's PKT_UPDATE. Since he is waiting for his own\nupdate, he doesn't know which *single* update is the official one. Same for\nAlice.\n\nWhat if Bob and Alice agree on a new update that combines both updates. The\nprotocol can only handle one update at a time, but the update doesn't have\nto happen one-way.\nThis would be similar to TCP Simultaneous Open/Close.\nSo Alice and Bob would exchange PKT_SIMULTANEOUS_ACCEPT containing\nsignatures, and then exchange PKT_SIMULTANEOUS_COMPLETE containing revoking\npre-images.\nContinuing my example above, Bob would receive PKT_UPDATE, send\nPKT_SIMULTANEOUS_ACCEPT and transition to WAIT_FOR_SIMULTANEOUS_ACCEPT.\nAlice would receive Bob's PKT_UPDATE, send PKT_SIMULTANEOUS_ACCEPT and\ntransition to WAIT_FOR_SIMULTANEOUS_ACCEPT.\nBob would recieve Alice's PKT_SIMULTANEOUS_ACCEPT, send\nPKT_SIMULTANEOUS_COMPLETE, and transition to NORMAL.\nSame for Alice.\n\nI think that avoids either deadlock or livelock, and does not require\nduplicating states for priority.\n\n- Jasper\n\nOn Tue, Sep 1, 2015 at 10:55 PM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On 1 September 2015 at 17:32, Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n> >\n> >> Looking at that git tree (I've done some work since then)...\n> >\n> > \u200bOh, github hasn't been updated since Aug 20? That's forever ago!\u200b\n> >\n> >\n> >> Ah, you\n> >> can't send a command while processing an existing command.  Seems a\n> >> logical simplification.\n> >>\n> >\n> > I'm thinking of CMD_CLOSE like \"Ctrl-C\"; why wouldn't you want it to work\n> > anytime?\u200b\n>\n> Yes, I think you do.  And the other side can CMD_CLOSE during an HTLC\n> negotiation (for example), so this should be allowed.\n>\n> I will update it to allow CMD_CLOSE at any time (except when already\n> closing).\n>\n> >> >> This makes the constraints clearer, eg. you can't DECLINE_HTLC\n> anything\n> >> >> but an ADD_HTLC.\n> >> > \u200bYour states currently allow declining those though:\n> >> Not at all (or if it does, it's a bug).\n> >\n> > \u200bRight, it's a bug as of \u200b52cda01 then :)\n>\n> Weird, my tester should have found that (every tested-for input must be\n> given).\n>\n> Ah, yes, it did, once I enhanced the tester to actually track htlcs.\n> And I've fixed it :)\n>\n> (Those should be going to STATE_WAIT_FOR_UPDATE_ACCEPT).\n>\n> >> The simplest (and safest) system is always to error and close when they\n> >> break protocol.  There's some game theory involved in whether you should\n> >> wait or not, but in the end, they're broken and there's not much you can\n> >> do.\n> >>\n> >\n> > \u200bWell, you can ignore some errors -- time sync problems might resolve\n> > themselves, eg. And the \"error\" might be because of an error on your side\n> > (your admin ran the wrong date command, there's a bug in your code), that\n> > might well be fixable. I guess what I'm thinking is that closing a\n> channel\n> > is a real cost; if they're not actively cheating -- by not completing an\n> > HTLC update once they agree to it eg -- I'd probably rather it stay open\n> > (in degraded mode perhaps) than automatically close.\n>\n> We could add such things later, but it's really hard to know in advance\n> what bugs will lose money and which can be ignored.\n>\n> >> I also wonder if\n> >> >   A: TIMEDOUT_HTLC -> B: DECLINE (err_time_sync_lost)\n> >> > might be useful.\n> >> I don't think it's useful, though if you disagree on time you might get\n> >> an error packet.  (What else can you do?)\n> >>\n> >\n> > \u200bHow is \"an error packet\" different to a decline packet or a channel\n> close?\u200b\n>\n> It carries an ascii message giving you a clue :)\n>\n> > Perhaps we should add a current time field to UPDATE_ADD_HTLC so you can\n> >> defuse clock sync problems earlier?\n> >>\n> >\n> > Or maybe time sync is part of the p2p protocol?\u200b I guess channel\n> > counterparties are always peers?\n>\n> Yes, that makes sense.\n>\n> >> \u200bSorry, I was assuming that one or both implementations were buggy. I\n> >> meant\n> >> > to make that explicit.\u200b You're talking with strangers on the network,\n> so\n> >> > you can't assume their software is bug free, right?\n> >> That applies to any scheme you come up with, though.  Propose something\n> >> simpler, and I'll gladly rewrite.\n> > \u200b\n> > \u200bI'll have another look when I can see current code :)\u200b\n>\n> NW, just running the now-glacial state tester.  I'm sure there's only 1\n> bug left!\n>\n> Cheers,\n> Rusty.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150902/e41ada10/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-04T05:35:37",
                "message_text_only": "Jasper Hugunin <jasper at hashplex.com> writes:\n> I had an idea regarding an alternative to the high/low priority. My\n> understanding is that the problem is this case:\n> Alice sends PKT_UPDATE and transitions to WAIT_FOR_UPDATE_ACCEPT.\n> Bob sends PKT_UPDATE, and also transitions to WAIT_FOR_UPDATE_ACCEPT.\n> Then Bob receives Alice's PKT_UPDATE. Since he is waiting for his own\n> update, he doesn't know which *single* update is the official one. Same for\n> Alice.\n>\n> What if Bob and Alice agree on a new update that combines both updates. The\n> protocol can only handle one update at a time, but the update doesn't have\n> to happen one-way.\n\nWe could, but it makes things more complex.\n\nWe might eventually want to batch updates for performance (which we\ncertainly can do), which would also solve this problem.\n\nThe duplicated state is really an artifact of the artificial and\nexhaustive way I coded state.c.  I did that because I wanted as much\nstate to be expressed in the \"enum state\" for simpler testing.\n\nIn practice, it's a one-liner.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "A state machine.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Jasper Hugunin"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15589
        }
    },
    {
        "title": "[Lightning-dev] Standardization",
        "thread_messages": [
            {
                "author": "CJP",
                "date": "2015-09-21T17:43:48",
                "message_text_only": "On returning home from the Scaling Bitcoin workshop, I thought it was\ngreat meeting some people in real life and discovering we basically all\nwant to achieve the same things. Still, I think there are some\ndifferences in how we think certain problems should be addressed.\n\nDesign decisions in Lightning don't suffer from the same \"consensus\"\nnecessity as the block validity rules in Bitcoin, but still, some\ndecisions carry a strong network effect, and might be hard to reverse\nonce made. The people I talked to felt the need to make no mistakes on\nthese design decisions, but at the same time I feel the need to make\nthem ASAP, so we can quickly launch a prototype and convince the world\nof how great this is.\n\nBecause of this, I'd like to have a well-organized process of collecting\nand documenting design ideas and trade-off argumentation, and hopefully\nreach some consensus on what are good and bad ideas. This should also\nserve to increase interoperability between the several pieces of\nsoftware that are being developed. Some of my ideas on how to shape\nthis:\n\nWe could have a Git repository, containing all concepts and standards.\nNew ideas, amendments & so on can be exchanged like pull requests. We\nmay / may not also need a process to make actual design decisions, but\nassigning one Git clone to be the \"true\" one might be too simplistic (I\ndon't want to have a dictator). As long as the Lightning dev community\nis small, a \"100% consensus\" rule might still be workable though.\n\nI'd like to make a distinction between concepts and standards. The idea\nis that a concept is a non-trivial design decision; typically people can\nhave strong preference between different alternative, mutually\nincompatible concepts. Standards are based on concepts, and fill in all\nthe trivial design decisions that have to be made to make different\npieces of software inter-operable. For concept choices, I made the\nfollowing template:\n\nhttps://gist.github.com/anonymous/51631fe56f1f83e4af0a\n\nWhat do you think?\n\nCJP\n\nPS. Rusty suggested something like an RFC-like process for Lightning.\nI'm not an expert on RFCs, and my proposal is probably a bit different\nfrom the RFC process. I'm open to other ideas and I'd like to be\ninformed about why we should use an RFC-like process or something else."
            },
            {
                "author": "Pierre",
                "date": "2015-09-22T10:43:31",
                "message_text_only": "Hi CJP,\n\n> [...] I'd like to have a well-organized process of collecting\n> and documenting design ideas and trade-off argumentation[...]. This should [...]\n> serve to increase interoperability between the several pieces of\n> software that are being developed.\n\n> What do you think?\nHaving never contributed to any significant open-source project so far\n(only closed-source dictatorships), I have no idea what would be best,\nbut I just wanted to say that I share your concerns.\n\nAlso, I am currently using Rusty's repo at ElementsProject as the\nreference implementation and it is perfectly fine, but I really hope\nwe won't end up \"Bitcoin style\", with specification=implementation !\n\nCheers,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-23T04:43:09",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hi CJP,\n>\n>> [...] I'd like to have a well-organized process of collecting\n>> and documenting design ideas and trade-off argumentation[...]. This should [...]\n>> serve to increase interoperability between the several pieces of\n>> software that are being developed.\n>\n>> What do you think?\n> Having never contributed to any significant open-source project so far\n> (only closed-source dictatorships), I have no idea what would be best,\n> but I just wanted to say that I share your concerns.\n>\n> Also, I am currently using Rusty's repo at ElementsProject as the\n> reference implementation and it is perfectly fine, but I really hope\n> we won't end up \"Bitcoin style\", with specification=implementation !\n\nYes, that would mean I've failed to do decent design :(\n\nI always make sure that my code contains subtle flaws, to encourage\nalternate implementations.  In fact, I've never produced bug-free code.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-23T04:40:53",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n> On returning home from the Scaling Bitcoin workshop, I thought it was\n> great meeting some people in real life and discovering we basically all\n> want to achieve the same things. Still, I think there are some\n> differences in how we think certain problems should be addressed.\n\nIndeed.  And it was great to meet you, too!\n\n> Design decisions in Lightning don't suffer from the same \"consensus\"\n> necessity as the block validity rules in Bitcoin, but still, some\n> decisions carry a strong network effect, and might be hard to reverse\n> once made. The people I talked to felt the need to make no mistakes on\n> these design decisions, but at the same time I feel the need to make\n> them ASAP, so we can quickly launch a prototype and convince the world\n> of how great this is.\n\nYeah.  I feel torn between the desire to code, and the desire to write\nan RFC so we can argue properly.\n\n> Because of this, I'd like to have a well-organized process of collecting\n> and documenting design ideas and trade-off argumentation, and hopefully\n> reach some consensus on what are good and bad ideas. This should also\n> serve to increase interoperability between the several pieces of\n> software that are being developed. Some of my ideas on how to shape\n> this:\n\nYes, it would also help newcomers get up to speed with ideas we've\nalready thrown around on-list.  Preferably avoid the bitcoin problem\nwhere you need to ask gmaxwell for a reference to an ancient bitcointalk\npost where a solution was previously presented.\n\n> We could have a Git repository, containing all concepts and standards.\n> New ideas, amendments & so on can be exchanged like pull requests. We\n> may / may not also need a process to make actual design decisions, but\n> assigning one Git clone to be the \"true\" one might be too simplistic (I\n> don't want to have a dictator). As long as the Lightning dev community\n> is small, a \"100% consensus\" rule might still be workable though.\n\nA wiki?  This seems closer to what we want, at least for now.\n\n> I'd like to make a distinction between concepts and standards. The idea\n> is that a concept is a non-trivial design decision; typically people can\n> have strong preference between different alternative, mutually\n> incompatible concepts. Standards are based on concepts, and fill in all\n> the trivial design decisions that have to be made to make different\n> pieces of software inter-operable. For concept choices, I made the\n> following template:\n>\n> https://gist.github.com/anonymous/51631fe56f1f83e4af0a\n>\n> What do you think?\n\nI love separating concepts and standards.  There are plenty of\ninteresting concepts which may eventually percolate into standards once\nwe get some kind of consensus; and I don't want to lose track of them\nall because they're not an immediate priority.\n\n> PS. Rusty suggested something like an RFC-like process for Lightning.\n> I'm not an expert on RFCs, and my proposal is probably a bit different\n> from the RFC process. I'm open to other ideas and I'd like to be\n> informed about why we should use an RFC-like process or something else.\n\nRFCs are good for when you want to nail down proposal details.  You can\nquote them in emails, code comments, and ideally implement the protocol\noff them.  For example, an RFC describing the exact transactions used in\nlightning, or one describing the inter-node protocol.  New ones appear\nover time as the protocols get extended.  They're best when you have at\nleast two independent implementations to make sure they're sane.\n\nThey're not so good with concepts, or brainstorming future stuff.  But\nthat stuff, too, is vital.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Standardization",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre",
                "CJP"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 7590
        }
    },
    {
        "title": "[Lightning-dev] Timeframes for refunds and revocation",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-09-03T11:18:39",
                "message_text_only": "I just messed around, thinking about reasonable timeframes for\npayments and revocation. I ended up thinking that 7 days would be\nokayish as the revocation timeframe for most usecases, as we also have\nto think about the everyday users that are not online (or don't even\nhave access to their computer) for a couple of days..\n\nI further think 1 day is plenty of time to reveal R. We really don't\nwant to give the receiver too much time to accept and clear the\npayment. (It locks up funds for everyone else in the route..)\n\nConsidering these values with the HTLC Receiver Redeemscript\n\nHTLC Receiver\nOP_HASH160 OP_DUP\n<R-HASH> OP_EQUAL\nOP_IF\n    <7 DAYS> OP_CSV\n    OP_2DROP\n    <KEY-B>\nOP_ELSE\n    <REVOKE-HASH> OP_EQUAL\n    OP_NOTIF\n        <8 DAYS> OP_CLTV OP_DROP\n    OP_ENDIF\n    <KEY-A>\nOP_ENDIF\nOP_CHECKSIG\n\nSo if A has REVOKE-PREIMAGE he can claim the payment anytime.\nIf B has R he has to wait 7 days until he can claim the output (and\nreveal R doing so..)\nFurthermore, if he has R and wants to clear the payment, he has to act\nwithin one day. He has to either settle the payment with the other\nparty or broadcast the channel within this time.\n\nIf he broadcasts the channel within one day, B can claim the output,\nbut A has to wait for full 7 days until he learns R. However, A might\nnot be the original sender, but just one of the nodes on the route,\nand if A does not provide R to the node before him within 2 days (we\nhave 1 day per hop), he cannot pull the funds, although B can pull\nhis. This means all nodes along the route has to broadcast their\nchannel in order to not lose money.\n\nIn conclusion the payment-timeout and the revoke-time must be the same\nin this channel design (which is inconvenient I think..). While the\npayment-timeout should be as short as possible, a long revoke-time is\nhealthy in many instances.. 1 or maybe 2 days will probably be the\noptimal trade-off then, although this can also be dangerously short in\ncase of full blocks..\n\nAny thoughts?"
            }
        ],
        "thread_summary": {
            "title": "Timeframes for refunds and revocation",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Mats Jerratsch"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1978
        }
    },
    {
        "title": "[Lightning-dev] Atomic swap",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2015-09-14T13:35:02",
                "message_text_only": "Hello there,\n\nI've been thinking about how we could implement the idea some brilliant\npeople had here :\nhttps://bitcointalk.org/index.php?topic=1134319.msg11966748#msg11966748.\n\nBasically it would allow to securely move funds in/out an existing channel.\n\nThe main use cases would include:\n1) funding balanced channels\n2) provide a way for merchants to seamlessy cash out their funds\n\nI can't see why we couldn't use the existing htlc contracts to implement\nthis, it is just another payment after all. But I am certainly missing\nsomething ;-)\n\nHere is what it would look like with rusty-style protobuf messages (swap\nin/out are pretty much symmetrical) :\n\n* SWAP IN *\n\n// Whoever wishes to increase her balance in the channel sends this\nswap_in_offer {\n    // How much I would like to increase my balance\n    required uint32 amount = 1;\n    // The hash that will be used to do the atomic swap\n    required sha256_hash r_hash = 2;\n    // txid of the swap tx, should that be mutated the sender would only be\nscrewing over himself\n    required sha256_hash txid = 3;\n}\n\nswap_in_accept {\n    // Maybe we should specify a mindepth here\n}\n\nswap_in_decline {\n    oneof reason {\n        // the other party needs to be able to compensate the swap in the\nchannel\n        bool cannot_swap_more_than_balance = 1;\n    };\n}\n\nregular swap in flow :\n\nBob -> Alice : swap_in_offer\nAlice -> Bob : swap_in_accept\n(Bob publishes the swap tx, which pays <amount> BTC to (<alice_final_key> &\nr) OR (refund & TIMEOUT))\n(tx reaches mindepth)\n(alice makes sure the scriptpubkey of this tx indeeds pays her providing r)\nAlice -> Bob : update_add_htlc (with same amount and r_hash)\nBob -> Alice : update_accept\nBob -> Alice : update_fulfill_htlc  (reveals the r)\n(Alice spends the swap tx)\n\n----------------------------------------------------------\n\n* SWAP OUT *\n\n// Whoever wishes to move funds outside the channel sends this\nswap_out_offer {\n    // I would like to cash out this amount\n    required uint32 amount = 1;\n}\n\nswap_out_accept {\n    // The hash that will be used to do the atomic swap\n    required sha256_hash r_hash = 1;\n    // txid of the swap tx, should that be mutated the sender would only be\nscrewing over himself\n    required sha256_hash txid = 2;\n}\n\nswap_out_decline {\n    oneof reason {\n        // you can't get more than your balance !\n        bool cannot_swap_more_than_balance = 1;\n        // the other party needs to have corresponding funds available\noutside of the channel (meaning it has in fact twice the funds)\n        bool funds_not_available = 2;\n  };\n}\n\nregular swap out flow :\n\nBob -> Alice : swap_out_offer\nAlice -> Bob : swap_out_accept\n(Alice publishes the swap tx, which pays <amount> BTC to (<bob_final_key> &\nr) OR (refund & TIMEOUT))\n(tx reached mindepth)\n(bob makes sure the scriptpubkey of this tx indeeds pays him providing r)\nBob -> Alice : update_add_htlc (with same amount and r_hash)\nAlice -> Bob : update_accept\nAlice -> Bob : update_fulfill_htlc (reveals the r)\n(Bob spends the swap tx)\n\n\nCheers,\n\nPierre\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150914/4638a33b/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-14T18:46:10",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hello there,\n>\n> I've been thinking about how we could implement the idea some brilliant\n> people had here :\n> https://bitcointalk.org/index.php?topic=1134319.msg11966748#msg11966748.\n\nYes!\n\nCaveats:\n1) We still need some way of adding another anchor to a channel, since\n   the atomic swap can't increase channel *capacity*.\n2) This is a routing question :)\n\nSo, they're normal HTLCs, but the \"next hop\" is not \"lightning node X\"\nbut \"bitcoin address X\".\n\nNo protocol changes required, except the FIXME here:\n\n// Start a new commitment tx to add an HTLC me -> you.\nmessage update_add_htlc {\n  // Hash for which I will supply preimage to revoke this commitment tx.\n  required sha256_hash revocation_hash = 1;\n  // Amount for htlc\n  required uint32 amount = 2;\n  // Hash for HTLC R value.\n  required sha256_hash r_hash = 3;\n  // Time at which HTLC expires (absolute)\n  required locktime expiry = 4;\n  // FIXME: Routing information.\n}\n\n:)\n\nCheers,\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2015-09-14T21:44:26",
                "message_text_only": "> Caveats:\n> 1) We still need some way of adding another anchor to a channel, since\n>    the atomic swap can't increase channel *capacity*.\n\nYes. I think updating channel capacity is maybe less important for now, but\nthat's just my opinion.\n\n> 2) This is a routing question :)\n\nHuh ?\n\n> So, they're normal HTLCs, but the \"next hop\" is not \"lightning node X\"\n> but \"bitcoin address X\".\n\nRiiiight ! Awesome\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150914/f46419d8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Atomic swap",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Pierre"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4791
        }
    },
    {
        "title": "[Lightning-dev] network topology and routing",
        "thread_messages": [
            {
                "author": "Pierre",
                "date": "2015-09-15T12:10:18",
                "message_text_only": "Hello,\n\nI know there hasn't been much work on routing yet (not that I am aware of\nat least), but it seems there is a consensus around the fact that the\ntarget network topology would look like this :\nhttps://s3-eu-west-1.amazonaws.com/acinq/public/lightning_network_1.svg\n\nimplying that :\n- there would exist multiple paths to a target user\n- reaching a target user would require several hops\n- some nodes might even be connected only to nodes\n\nThis puzzles me because the network topology I expected would look more\nlike this :\nhttps://s3-eu-west-1.amazonaws.com/acinq/public/lightning_network_2.svg\n\nI am not saying each node should be aware of every other node, but that :\n- nodes connected only to nodes shouldn't exist\n- when user A sends a payment to user B, it goes through at most 2 nodes,\nor just 1 if A and B are connected to the same node\n\nThe reason for that is there is an incentive for reducing the number of\nhops right ? Because it is faster (each hop adds latency) and cheaper (each\nhop adds a fee).\n\nWith that in mind, why would routing be more complicated than just\n<user-id>@<node> ? Then we just agree on a standard port and that's it !\nIsn't it how the internet works already ? Why do we need an\napplication-level routing on top of the IP routing ?\n\nNow that I made a fool of myself, please correct me :-)\n\nCheers\n\nPierre\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150915/90a42603/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-15T13:17:21",
                "message_text_only": "On Tue, Sep 15, 2015 at 02:10:18PM +0200, Pierre wrote:\n> Now that I made a fool of myself, please correct me :-)\n\nNone of what you said seems foolish to me; routing's an open problem...\n\n> I know there hasn't been much work on routing yet (not that I am aware of\n> at least), but it seems there is a consensus around the fact that the\n> target network topology would look like this :\n> [a] https://s3-eu-west-1.amazonaws.com/acinq/public/lightning_network_1.svg\n> [b] https://s3-eu-west-1.amazonaws.com/acinq/public/lightning_network_2.svg\n\nBoth these indicate each wallet (end-user) is connected to just one node;\nI'd expect the usual case to be two or three so you can more easily deal\nwith downtime by a node.\n\n> [a] implying that :\n> - there would exist multiple paths to a target user\n> - reaching a target user would require several hops\n> - some nodes might even be connected only to nodes\n> \n> This puzzles me because the network topology I expected would look more\n> like [b]:\n> I am not saying each node should be aware of every other node, but that :\n> - nodes connected only to nodes shouldn't exist\n\nIf I'm an end-user with a wallet with two channels; and I switch my\nsoftware to being a full lightning node with the same two channels, I'd\nend up in this state. Likewise if I was a new node trying to establish\nmyself on the network.\n\nAlso, if there's a lot of traffic from node A to node B, their channel\nwill become lopsided (B will own all the coins), if it turns out that\nC has channels with both A and B, a circular transaction A -> C -> B ->\nA would allow those channels to rebalance (and x->A->C->B->y would allow\nx and y to continue to transact despite A->B being full). If that happens\na lot, it might be profitable for everyone concerned if \"C\" sets up a\nnode that only does that, and doesn't deal with end-users directly.\n\n> - when user A sends a payment to user B, it goes through at most 2 nodes,\n> or just 1 if A and B are connected to the same node\n\nThat's optimal for efficiency, but probably pessimal for privacy. If\nlightning is fast and cheap enough, delaying things slightly for a\nsignificant increase in privacy would be worthwhile.\n\n> The reason for that is there is an incentive for reducing the number of\n> hops right ? Because it is faster (each hop adds latency) and cheaper (each\n> hop adds a fee).\n> With that in mind, why would routing be more complicated than just\n> <user-id>@<node> ?\n\nSetting up channels isn't free, though -- it costs a blockchain\ntransaction, and locks up bitcoins for no value if the channel's idle --\nso you also want to minimise the number of channels, not just the number\nof hops for a transaction.\n\nI think this means you actually want to optimise a formula more like\n\n   ALPHA * (d/2 * N^2) + BETA * log_d( N )\n\nwhere N is number of nodes, and d is the average number of channels a\nnode has open, and ALPHA and BETA are (roughly) the costs of having a\nchannel, and adding a hop to the average transaction respectively.\n\n> Then we just agree on a standard port and that's it !\n> Isn't it how the internet works already ? Why do we need an\n> application-level routing on top of the IP routing ?\n\n1) It'd be expensive to join the lightning network (if I wanted to be\nable to send up to $5 to anyone, and there were 100 nodes on the\nnetwork, I'd need to commit $500 to lightning channels up front).\n\n2) It'd be easy to block payments (USA bans anyone from setting up\nchannels with anyone in Cuba; Cubans can't run nodes)\n\n3) If there's a communications blockage, there's no ability to route\naround it.\n\nThat said, no routing might still result in a functional system when\nwe're just trying things out and there's only a handful of people\nrunning nodes?\n\nCheers,\naj"
            },
            {
                "author": "Pierre",
                "date": "2015-09-16T10:27:32",
                "message_text_only": "> Both these indicate each wallet (end-user) is connected to just one node;\n> I'd expect the usual case to be two or three so you can more easily deal\n> with downtime by a node.\nYes, I skipped that.\n\n> If I'm an end-user with a wallet with two channels; and I switch my\n> software to being a full lightning node with the same two channels, I'd\n> end up in this state. Likewise if I was a new node trying to establish\n> myself on the network.\nI understand the idea and advantages of everybody running a node, to\nbe honest I implicitely discarded this possibility in favor of a\nlimited (10s ? 100s ?) number of specialized supernodes. I feel like\nhaving a lot of small nodes that constantly appear and disappear is\nsomewhat incompatible with a reliable and low latency (<1s ?) payment\nnetwork, but I admit I am probably too pessimistic !\n\n> Also, if there's a lot of traffic from node A to node B, their channel\n> will become lopsided (B will own all the coins), if it turns out that\n> C has channels with both A and B, a circular transaction A -> C -> B ->\n> A would allow those channels to rebalance (and x->A->C->B->y would allow\n> x and y to continue to transact despite A->B being full). If that happens\n> a lot, it might be profitable for everyone concerned if \"C\" sets up a\n> node that only does that, and doesn't deal with end-users directly.\nThis makes sense, although if I am not mistaken it can only be done\nonce, because then C will own all the coins in the channel A-C, and if\nA-B becomes lopsided again A will need to find yet another circular\nroute. I would think in that case B would be more likely to cash out\nas mentioned here :\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-September/000185.html.\nIn fact, I think that members of the lightning network will be\n\"strongly typed\": overall they will either mainly send or mainly\nreceive money.\n\n> That's optimal for efficiency, but probably pessimal for privacy. If\n> lightning is fast and cheap enough, delaying things slightly for a\n> significant increase in privacy would be worthwhile.\nAgreed.\n\n> Setting up channels isn't free, though -- it costs a blockchain\n> transaction, and locks up bitcoins for no value if the channel's idle --\n> so you also want to minimise the number of channels, not just the number\n> of hops for a transaction.\nThis actually leads me to the \"supernode\" conclusion. End user would\nonly have a handful of channels set up with a few of those large,\nwell-connected nodes.\nJust one remark on the fact that funds would be locked in a channel:\nif lightning is widely successful and becomes the primary way of doing\npayments, don't you think that this would change our perception of\nwhich funds (in a wallet or in an open channel) are actually more\nusable ?\n\n>> Then we just agree on a standard port and that's it !\n>> Isn't it how the internet works already ? Why do we need an\n>> application-level routing on top of the IP routing ?\n>\n> 1) It'd be expensive to join the lightning network (if I wanted to be\n> able to send up to $5 to anyone, and there were 100 nodes on the\n> network, I'd need to commit $500 to lightning channels up front).\nIn my view you would just be connected to a few nodes which would\nhandle the rest.\n\n> 2) It'd be easy to block payments (USA bans anyone from setting up\n> channels with anyone in Cuba; Cubans can't run nodes)\nGood point...\n\n> 3) If there's a communications blockage, there's no ability to route\n> around it.\nTrue, but this is mitigated by the fact that every participant of the\nnetwork would be connected to a few nodes, so we can imagine that a\nmerchant would require to be paid at id1 at node1 or id2 at node2 ?\n\nCheers,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-17T21:30:17",
                "message_text_only": "Hi Pierre,\n\n        Sorry for the delay; Blockstream had a big meeting after the\nMontreal Scaling Bitcoin workshop, so I've been distracted.\n\nPierre <pm+lists at acinq.fr> writes:\n>> If I'm an end-user with a wallet with two channels; and I switch my\n>> software to being a full lightning node with the same two channels, I'd\n>> end up in this state. Likewise if I was a new node trying to establish\n>> myself on the network.\n> I understand the idea and advantages of everybody running a node, to\n> be honest I implicitely discarded this possibility in favor of a\n> limited (10s ? 100s ?) number of specialized supernodes. I feel like\n> having a lot of small nodes that constantly appear and disappear is\n> somewhat incompatible with a reliable and low latency (<1s ?) payment\n> network, but I admit I am probably too pessimistic !\n\nMe too.  Initially I was thinking of hub and spokes like this.  It's\ncertainly far simpler to organize routing among a few thousand\nsupernodes.\n\nBut the interests of robustness privacy, decentralization, and the\ntantalizing possibility of negative fees all point to a flatter\ndesign (though I expect some power law to emerge).\n\n>> Setting up channels isn't free, though -- it costs a blockchain\n>> transaction, and locks up bitcoins for no value if the channel's idle --\n>> so you also want to minimise the number of channels, not just the number\n>> of hops for a transaction.\n> This actually leads me to the \"supernode\" conclusion. End user would\n> only have a handful of channels set up with a few of those large,\n> well-connected nodes.\n> Just one remark on the fact that funds would be locked in a channel:\n> if lightning is widely successful and becomes the primary way of doing\n> payments, don't you think that this would change our perception of\n> which funds (in a wallet or in an open channel) are actually more\n> usable ?\n\nPossibly.  But if it's the primary method of payments, you won't think\nof them as \"locked in a channel\".\n\n>>> Then we just agree on a standard port and that's it !\n>>> Isn't it how the internet works already ? Why do we need an\n>>> application-level routing on top of the IP routing ?\n\nYou still need non-IP routing, unfortunately.  It's an overlay network\nof channels (probably across multiple networks, like TOR, UDP etc),\nand there's no logical grouping to make routing tables smaller than\n\"every node\".\n\n>> 1) It'd be expensive to join the lightning network (if I wanted to be\n>> able to send up to $5 to anyone, and there were 100 nodes on the\n>> network, I'd need to commit $500 to lightning channels up front).\n> In my view you would just be connected to a few nodes which would\n> handle the rest.\n\nDefinitely.\n\n>> 2) It'd be easy to block payments (USA bans anyone from setting up\n>> channels with anyone in Cuba; Cubans can't run nodes)\n> Good point...\n>\n>> 3) If there's a communications blockage, there's no ability to route\n>> around it.\n> True, but this is mitigated by the fact that every participant of the\n> network would be connected to a few nodes, so we can imagine that a\n> merchant would require to be paid at id1 at node1 or id2 at node2 ?\n\nI started exactly where you are!  I was forced to throw it away to try\nto make it as distributed-by-default as possible.  That all nodes are\nequal to by design, and we try to be clever with routing.\n\nI think I have a method, too.  It won't scale infinitely, but might work\nfor a few million nodes...\n\nCheers,\nRusty."
            },
            {
                "author": "Pierre",
                "date": "2015-09-22T08:31:28",
                "message_text_only": ">         Sorry for the delay; Blockstream had a big meeting after the\n> Montreal Scaling Bitcoin workshop, so I've been distracted.\n\nNo problem! I think you met Fabrice there, he told me the whole thing\nwas pretty interesting. I'll probably attend the Hong Kong event.\n\n> I started exactly where you are!  I was forced to throw it away to try\n> to make it as distributed-by-default as possible.  That all nodes are\n> equal to by design, and we try to be clever with routing.\n\nWell, if I had done my homework properly I would have stumbled upon\nthis discussion\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000019.html\nbefore... I still think the path we are taking is very ambitious, but\nwhat the hell! Let's do this!\n\n> I think I have a method, too.  It won't scale infinitely, but might work\n> for a few million nodes...\n\nLooking forward to see that.\n\nCheers,\n\nPierre"
            }
        ],
        "thread_summary": {
            "title": "network topology and routing",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Rusty Russell",
                "Pierre"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 13270
        }
    },
    {
        "title": "[Lightning-dev] Onion routing design.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-09-18T23:39:44",
                "message_text_only": "Hi all!\n\n        So, we've handwaved that we're going to have onion routing, so\neach node can only see the immediate neighbors.\n\nHere's my first attempt; please fix :)\n\nThe format of a route looks like so:\n\n        required bytes route;\n\nA node decrypts that using its pubkey (probably some counter mode\nscheme, but that's for a different post!), expecting:\n\n        // Sum of this whole thing after decryption.\n        required sha256_hash sum = 1;\n\n        // Where to next?\n        oneof next {\n                // Actually, this is the last one\n                bool end = 2;\n                // Next lightning node.\n                pubkey lightning = 3;\n                // Other realms go here...\n        }\n        \n        // How much fee you can take (== all, if last node)\n        required int32 fee = 4;\n\n        // Remainder (route blob for next node).\n        required bytes route = 5;\n\nIf the sum is wrong, the routing has failed (it's been corrupted or was\nmalformed to start).\n\nNodes create the route backwards, to calculate the size.  Then picks a\ntotal size randomly between 1024 and 4096, and pads to that size (at\nleast 32 bytes of random padding).  Then walks backwards to wrap and\nencrypt it.\n\nThis offers some protection from guessing the route length.\n\nRoute Probing Attacks\n=====================\nNow, there's a weakness here: No MAC!  A nosy node can't corrupt the\nrouting past the next hop, but it could replace it entirely (this is\nfundamental to the scheme of R values).  If it guesses the final\ndestination right, the HTLC will succeed, otherwise it will fail, so it\ncan use this to probe.\n\nOne partial defence is to fail to allow two HTLCs with the same R value,\nforcing probe serialization.  Unfortunately that allows a simple way to\nprobe back to the source, so we shouldn't do this!\n\nWe may be able to do some probabalistic backoff of duplicate R values,\nsuch that you can't tell if I've received one before?  A more\nsophisticated probe sequence could get a probability though...\n\nI can't see a fix for this in general. :(\n\nError Messages\n==============\nAnother issue is that we should try not to leak information to passive\nobservers on the route due to errors, so signing errors and using the\n'sum' field as a secret key seems sensible.  This means your padding in\nthe original message needs to be \"random\" so 'sum' is random.\n\nThoughts welcome!\nRusty.\nPS.  As noted before, nodes can trivially correlate HTLCs by R value, so\n     onioning the routing only gets you so far..."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-19T01:27:16",
                "message_text_only": "On 19 September 2015 9:39:44 am AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>Route Probing Attacks\n>=====================\n>Now, there's a weakness here: No MAC!  A nosy node can't corrupt the\n>routing past the next hop, but it could replace it entirely (this is\n>fundamental to the scheme of R values).  If it guesses the final\n>destination right, the HTLC will succeed, otherwise it will fail, so it\n>can use this to probe.\n>\n>One partial defence is to fail to allow two HTLCs with the same R\n>value,\n>forcing probe serialization.  Unfortunately that allows a simple way to\n>probe back to the source, so we shouldn't do this!\n>\n>We may be able to do some probabalistic backoff of duplicate R values,\n>such that you can't tell if I've received one before?  A more\n>sophisticated probe sequence could get a probability though...\n>\n>I can't see a fix for this in general. :(\n\nI don't think parallel probes work well - if any of your probes succeed, your neighbour knows R and can claim all of your probes. Parallelization is also limited by channel capacity, assuming the payee knows how much to expect.\n\nI'm not sure probing is really plausible given mass deployment, is it? You have to guess the eventual recipient but given randomised routing you have every person or business using lightning as a potential candidate with possibly equal probability?\n\nFor a general solution, I think you could completely rule out probing by having two R values, one known only by the recipient, and one by the sender (call it S say). Then make the htlcs payable on presentation of both R and S and include S encrypted to the final recipient in the onion payload. Munging the payload then makes the htlc irredeemable so misrouting it gives no information.\n\n(Please let me know if the formatting of this mail is too hopeless; trying out a new setup)\n\nCheers,\naj\n\n\n\n-- \nSent from my phone."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-20T20:48:37",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 19 September 2015 9:39:44 am AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>Route Probing Attacks\n>>=====================\n>>Now, there's a weakness here: No MAC!  A nosy node can't corrupt the\n>>routing past the next hop, but it could replace it entirely (this is\n>>fundamental to the scheme of R values).  If it guesses the final\n>>destination right, the HTLC will succeed, otherwise it will fail, so it\n>>can use this to probe.\n...\n>>I can't see a fix for this in general. :(\n>\n> I don't think parallel probes work well - if any of your probes succeed, your neighbour knows R and can claim all of your probes. Parallelization is also limited by channel capacity, assuming the payee knows how much to expect.\n\nChannel capacity might not be an issue for tiny micropayments, but\nthe reveal of R is a good point: such probing should have a real cost\non success.  I'll be sure to implement that properly :)\n\n> I'm not sure probing is really plausible given mass deployment, is it? You have to guess the eventual recipient but given randomised routing you have every person or business using lightning as a potential candidate with possibly equal probability?\n\nIf someone wants to know whether I'm sending money to you, it would\nwork.  Get a cheap hub near you, and one near me, and probe every\npayment which passes through both.\n\nBut I guess it's a fairly boutique surveillance, which doesn't scale.\n\n> For a general solution, I think you could completely rule out probing by having two R values, one known only by the recipient, and one by the sender (call it S say). Then make the htlcs payable on presentation of both R and S and include S encrypted to the final recipient in the onion payload. Munging the payload then makes the htlc irredeemable so misrouting it gives no information.\n\nThat's clever.  And I think it works.  I will need more coffee to figure\nout if we should revise the transaction structure to include this.\n\n> (Please let me know if the formatting of this mail is too hopeless; trying out a new setup)\n\nNo work wrap, but it seemed to work fine.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-22T05:25:44",
                "message_text_only": "On Tue, Sep 22, 2015 at 11:22:57AM +1000, Anthony Towns wrote:\n> If you use OFB or CTR mode for the symmetric cypher, you can calculate\n> D_KD() of all the padding and use that to work out the hash H of the\n> plaintex message:\n>   here's $15\n>   grbg grbg ... grbg\n>   D_KD(\n>         D_KC( D_KB( E_KA( 0000 ) ) )\n>         D_KC( E_KB( 0000 ) )\n>         E_KC( 0000 )\n>       )\n\nOn Mon, Sep 21, 2015 at 06:18:37AM +0930, Rusty Russell wrote:\n> > For a general solution, I think you could completely rule out probing\n> > by having two R values, one known only by the recipient, and one by\n> > the sender (call it S say). Then make the htlcs payable on\n> > presentation of both R and S and include S encrypted to the final\n> > recipient in the onion payload. Munging the payload then makes the\n> > htlc irredeemable so misrouting it gives no information.\n> That's clever.  And I think it works.\n\nYou could combine these two approaches actually. If X is the plaintext\nrouting message the payee gets (\"here's $15 grbg grbg ...\"), and H is\nits hash that was prefixed to the plaintext, then set S=sha256(H+X),\nand require revealing S as well as R for payment redemption (ie, include\n\"OP_SHA256 sha256(S) OP_EQ\" in the HTLC).\n\nThat way *any* attempt to garble the padding makes S unrecoverable\nand renders the payment unredeemable, without relying on any\nverification/cooperation from anyone else on the network.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-19T01:44:18",
                "message_text_only": "On 19 September 2015 9:39:44 am AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>        // Sum of this whole thing after decryption.\n>        required sha256_hash sum = 1;\n>\n>        // Where to next?\n>        oneof next {\n>                // Actually, this is the last one\n>                bool end = 2;\n>                // Next lightning node.\n>                pubkey lightning = 3;\n>                // Other realms go here...\n>        }\n>        \n>        // How much fee you can take (== all, if last node)\n>        required int32 fee = 4;\n>\n>        // Remainder (route blob for next node).\n>        required bytes route = 5;\n\n>Nodes create the route backwards, to calculate the size.  Then picks a\n>total size randomly between 1024 and 4096, and pads to that size (at\n>least 32 bytes of random padding).  Then walks backwards to wrap and\n>encrypt it.\n>\n>This offers some protection from guessing the route length.\nWouldn't it be better to store the expected balance to be forwarded rather than the fee? That way if someone takes too much, the next node can immediately abort the transaction.\n\nShouldn't the onion blob be re-padded when forwarded? Otherwise it'd sometimes drop below 1024 bytes and you'd be able to tell you're near the end of the chain. Just adding random bytes on to the end should work I think - they'll just be treated as extra padding and ignored. Alternatively, maybe you could just append the encrypted bytes that made up your post of the payload from your incoming message: it was encrypted to you so should be effectively random to anyone else and will be garbled further when the next node \"decrypts\" it. That would save on entropy/crypto ops, and a constant message size would leak minimal info I think.\n\nCheers,\naj\n-- \nSent from my phone."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-20T21:05:58",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On 19 September 2015 9:39:44 am AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>        // Sum of this whole thing after decryption.\n>>        required sha256_hash sum = 1;\n>>\n>>        // Where to next?\n>>        oneof next {\n>>                // Actually, this is the last one\n>>                bool end = 2;\n>>                // Next lightning node.\n>>                pubkey lightning = 3;\n>>                // Other realms go here...\n>>        }\n>>        \n>>        // How much fee you can take (== all, if last node)\n>>        required int32 fee = 4;\n>>\n>>        // Remainder (route blob for next node).\n>>        required bytes route = 5;\n>\n>>Nodes create the route backwards, to calculate the size.  Then picks a\n>>total size randomly between 1024 and 4096, and pads to that size (at\n>>least 32 bytes of random padding).  Then walks backwards to wrap and\n>>encrypt it.\n>>\n>>This offers some protection from guessing the route length.\n> Wouldn't it be better to store the expected balance to be forwarded rather than the fee? That way if someone takes too much, the next node can immediately abort the transaction.\n\nYes, excellent point.  I flip-flopped on that; so I flipped again.\n\n> Shouldn't the onion blob be re-padded when forwarded? Otherwise it'd\n> sometimes drop below 1024 bytes and you'd be able to tell you're near\n> the end of the chain.\n\nYes and this applies for almost any length selection method.\n\n> Just adding random bytes on to the end should\n> work I think - they'll just be treated as extra padding and ignored.\n\nMy original plan.  But it enables a probing attack where you corrupt the\npacket and if it succeeds anyway you know those bytes weren't used.\n\n> Alternatively, maybe you could just append the encrypted bytes that made up your post of the payload from your incoming message: it was encrypted to you so should be effectively random to anyone else and will be garbled further when the next node \"decrypts\" it. That would save on entropy/crypto ops, and a constant message size would leak minimal info I think.\n\nSo rotate the payload?  I don't think that's verifiable by the\nrecipient, so has the same probing attack issue as above.\n\nHmm, what if we include a pubkey, and you use that to encrypt 0 padding?\nThe last hop gets the privkey (and boundary information), and she can\nverify the padding.\n\nOff the top of my head, that solves both the length problem, and the\n\"route replacement\" problem.\n\nBut I've not had coffee yet, plus jetlag.  Could be missing a flaw or\nsimplification!\n\nThanks,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-22T01:22:57",
                "message_text_only": "On Mon, Sep 21, 2015 at 06:35:58AM +0930, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On 19 September 2015 9:39:44 am AEST, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> >>        // Sum of this whole thing after decryption.\n> >>        required sha256_hash sum = 1;\n\n> > Just adding random bytes on to the end should\n> > work I think - they'll just be treated as extra padding and ignored.\n> My original plan.  But it enables a probing attack where you corrupt the\n> packet and if it succeeds anyway you know those bytes weren't used.\n\nActually, any random bytes on the end would be included (after decryption)\nwhen calculating the sha256_hash sum by the next node, no? Otherwise\nyou'd at least need a length field to tell how much of the packet needs\nverifying.\n\nHmm, I'm not sure it's possible to have the hash actually work at the\nsame time as letting nodes add padding?\n\nYou could have the hash only verify the current message and the following\n(encrypted) message. None of the hashes would ever then verify the added\npadding; but you'd still be vulnerable to probing attacks.\n\nProbing attacks only reveal the length of the chain, of course. AFAICS\ntor is vulnerable to this sort of probing attack? Weird.\n\n> Hmm, what if we include a pubkey, and you use that to encrypt 0 padding?\n> The last hop gets the privkey (and boundary information), and she can\n> verify the padding.\n\nActually, this is missing a step isn't it? Don't we have to generate\nsymmetric keys for each step in an onion route, transmitting to Bob:\n\n  E_B( KB ) E_KB( forward $20 to Carol; E_C( KC ) E_KC( ... ) )\n\nIn which case, I think Bob can append E_KB(00000..) as padding, which\nwe can predict, and eg, the final message to Dave will look like:\n\n  E_D( KD ) E_KD( H; here's $15 )\n    E_KD( grbg grbg ... grbg )\n    D_KC( D_KB( E_KA( 0000 ) ) )\n    D_KC( E_KB( 0000 ) )\n    E_KC( 0000 )\n\nIf you use OFB or CTR mode for the symmetric cypher, you can calculate\nD_KD() of all the padding and use that to work out the hash H of the\nplaintex message:\n\n  here's $15\n  grbg grbg ... grbg\n  D_KD(\n        D_KC( D_KB( E_KA( 0000 ) ) )\n        ...\n      )\n\nI don't think you can use CBC mode, because you'd need to know E_KD(grbg)\nin order to know D_KD( padding ), but you need to know grbg in order\nto know H, and you need to know E_KD(H + ...) in order to work out\nE_KD(grbg).\n\nYou can't use sum for Kx because you need to know Kx before working out\nthe sum...\n\nI think that means that:\n\n>>> The format of a route looks like so:\n>>>        required bytes route;\n\nshould actually be something like:\n\n       required bytes hop_key; // encrypted with public key\n       required bytes route;   // encrypted with hop_key\n\n(possibly with an IV as well, if the block cypher mode doesn't just\ninclude that in the cyphertext)\n\n> But I've not had coffee yet, plus jetlag.  Could be missing a flaw or\n> simplification!\n\nIt's crypto protocols; it's almost always safe to assume you're missing\na flaw...\n\nCheers,\naj"
            },
            {
                "author": "Zooko Wilcox-OHearn",
                "date": "2015-09-22T01:27:03",
                "message_text_only": "Could you please point me to any notes about requirements/desiderata?\n\nThanks!\n\n--Zooko\nOn Sep 18, 2015 5:47 PM, \"Rusty Russell\" <rusty at rustcorp.com.au> wrote:\n\n> Hi all!\n>\n>         So, we've handwaved that we're going to have onion routing, so\n> each node can only see the immediate neighbors.\n>\n> Here's my first attempt; please fix :)\n>\n> The format of a route looks like so:\n>\n>         required bytes route;\n>\n> A node decrypts that using its pubkey (probably some counter mode\n> scheme, but that's for a different post!), expecting:\n>\n>         // Sum of this whole thing after decryption.\n>         required sha256_hash sum = 1;\n>\n>         // Where to next?\n>         oneof next {\n>                 // Actually, this is the last one\n>                 bool end = 2;\n>                 // Next lightning node.\n>                 pubkey lightning = 3;\n>                 // Other realms go here...\n>         }\n>\n>         // How much fee you can take (== all, if last node)\n>         required int32 fee = 4;\n>\n>         // Remainder (route blob for next node).\n>         required bytes route = 5;\n>\n> If the sum is wrong, the routing has failed (it's been corrupted or was\n> malformed to start).\n>\n> Nodes create the route backwards, to calculate the size.  Then picks a\n> total size randomly between 1024 and 4096, and pads to that size (at\n> least 32 bytes of random padding).  Then walks backwards to wrap and\n> encrypt it.\n>\n> This offers some protection from guessing the route length.\n>\n> Route Probing Attacks\n> =====================\n> Now, there's a weakness here: No MAC!  A nosy node can't corrupt the\n> routing past the next hop, but it could replace it entirely (this is\n> fundamental to the scheme of R values).  If it guesses the final\n> destination right, the HTLC will succeed, otherwise it will fail, so it\n> can use this to probe.\n>\n> One partial defence is to fail to allow two HTLCs with the same R value,\n> forcing probe serialization.  Unfortunately that allows a simple way to\n> probe back to the source, so we shouldn't do this!\n>\n> We may be able to do some probabalistic backoff of duplicate R values,\n> such that you can't tell if I've received one before?  A more\n> sophisticated probe sequence could get a probability though...\n>\n> I can't see a fix for this in general. :(\n>\n> Error Messages\n> ==============\n> Another issue is that we should try not to leak information to passive\n> observers on the route due to errors, so signing errors and using the\n> 'sum' field as a secret key seems sensible.  This means your padding in\n> the original message needs to be \"random\" so 'sum' is random.\n>\n> Thoughts welcome!\n> Rusty.\n> PS.  As noted before, nodes can trivially correlate HTLCs by R value, so\n>      onioning the routing only gets you so far...\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150922/1abdd47c/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-22T10:38:08",
                "message_text_only": "Zooko Wilcox-OHearn <zooko at leastauthority.com> writes:\n> Could you please point me to any notes about requirements/desiderata?\n\nThey're mainly spread out over the mailing list discussions, but it's\npretty simple:\n\n1) It's a source routing network, so the sender details the payment path.\n   Since fees vary with path, and the sender pays, this is the simplest.\n\n2) For financial privacy reasons, minimizing the knowledge of any part\n   of the network makes sense.\n\nThus, an onion routing-style setup where each node only knows prev and\nnext seems most sensible.  It's not quite as good as you might expect,\nbecause the payment is trivially correlated (it requires the same R\nvalue) so if you control two nodes on the path you can connect them.\n\nI am currently working on some test code which works like so:\n\n  #define MESSAGE_SIZE 128\n  #define MAX_HOPS 20\n\n  // One node hop\n  struct hop {\n\tunsigned char hmac[SHA256_DIGEST_LENGTH];\n\t/* FIXME: Must use parse/serialize functions. */\n\tsecp256k1_pubkey_type pubkey;\n\tunsigned char msg[MESSAGE_SIZE];\n  };\n\n  // Full route description.\n  struct onion {\n\tstruct hop hop[MAX_HOPS];\n  };\n\nReceive on a node works like so:\n1) Use ECDH on onion->hop[0].pubkey and my privkey to extract secret key.\n2) Use this to derive\n   - enckey (SHA256(seckey || 0)\n   - hmackey (SHA256(seckey || 1)\n   - iv (SHA256(seckey || 2)\n   - pad_iv (SHA256(seckey || 3)\n3) Check HMAC of every part of struct onion after hmac (including pubkey,\n   why not?).  If wrong, stop.\n4) Decrypt (AES 256 CTR mode, using enckey and iv above) struct onion\n   from pubkey onwards.\n5) First struct hop is for us.\n6) To forward, remove first hop, and append padding (thus keeping total\n   length the same).\n7) Padding is generated by AES-256-CTR encrypting all-zeroes with enckey\n   and pad_iv.\n\nThe result should be that even final node has no idea of path length.\n\nIt's a bit tricky to generate this onion correctly (I know, my code is\nstill buggy!).  But it's perfectly possible.  Unused hops are filled\nwith random garbage.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Onion routing design.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Zooko Wilcox-OHearn"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 20345
        }
    },
    {
        "title": "[Lightning-dev] Decker&Wattenhofer channels",
        "thread_messages": [
            {
                "author": "Andrew Miller",
                "date": "2015-09-19T00:14:52",
                "message_text_only": "Are there any downsides of the alternative proposed in this paper? There\nwas a discussion on Bitcoin subreddit but it got derailed\nhttps://m.reddit.com/r/compscipapers/comments/3at959/a_fast_and_scalable_payment_network_with_bitcoin/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150918/c4acb75b/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-19T02:30:33",
                "message_text_only": "On 19 September 2015 10:14:52 am AEST, Andrew Miller <amiller at cs.umd.edu> wrote:\n>Are there any downsides of the alternative proposed in this paper?\n>There\n>was a discussion on Bitcoin subreddit but it got derailed\n>https://m.reddit.com/r/compscipapers/comments/3at959/a_fast_and_scalable_payment_network_with_bitcoin/\n\n\nThe main difference between this and the lightning paper seems to be using timelocks to guarantee revocability rather than a key/hash scheme. To me Rusty's hash scheme seems fine, so I don't see the point.\n\nDrawbacks to this scheme afaics are that it requires stronger malleability fixes than are likely anytime soon, and it sets a decreasing timelock on the channel, so the channel starts with a deadline then progressively reduces it. That time lock needs to be both large to give the channel as long a lifetime as possible, but also small because every HTLC on the channel has to have a larger timelock on the refund side. I think that greatly limits the lifetime of a channel compared to relative lock time lightning channels. (The refresh operation hits the block chain, so is effectively opening a new channel IMO)\n\nIf the chained revocation secrets turn out to be insecure or too heavyweight, this seems worth looking into further, but otherwise not afaics.\n\nSetting Delta T to 1 hour seems bogus, but I don't think that had any effect on the rest of the proposal.\n\nFor reference, I think the reddit comment thread was \n\nhttps://www.reddit.com/r/Bitcoin/comments/3aohkv/olaoluwa_osuntokun_on_twitter_a_simpler/\n\nCheers,\naj\n-- \nSent from my phone."
            }
        ],
        "thread_summary": {
            "title": "Decker&Wattenhofer channels",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Andrew Miller"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 1995
        }
    },
    {
        "title": "[Lightning-dev] Ionization Protocol: Flood Routing",
        "thread_messages": [
            {
                "author": "Amos Bairn",
                "date": "2015-09-19T20:13:03",
                "message_text_only": "Here is a scheme I thought of for flood based route finding. If it can be\npulled off it would allow efficient route finding while keeping the shape\nof the network hidden, as well as giving onion like anonymity.\n\nAfter writing it up a realized that it has a trivial denial of service\nattack, that could render it a non-starter.\n\nI'm throwing it out there anyway, because this could have significant\npotential if the DoS problem can be solved.\n\nhttps://github.com/Eylrid/ionization/blob/master/ionization.mediawiki\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150919/7b6aef62/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-21T02:16:13",
                "message_text_only": "Hi Amos,\n\n   I'm delighted that someone else is thinking about routing!\n\nI like the information hiding features, but I don't think this will\nscale if everyone floods the network before sending a transaction.\n\nI do, however, have an alternate scheme which is something of a\nmiddleman, which I'd appreciate your feedback on.\n\nWe regularly choose a dozen \"beacon\" nodes at random (using proximity to\nthe SHA of latest block hash or something).  Everyone propagates the\ncheapest route to & from those nodes (which is pretty efficient, similar\nto your scheme).\n\nTo receive a payment, B picks a few beacon nodes at random and sends\nthose routes (beacons -> B) to A.  Presumably A knows its route to all\nthe beacon nodes and thus can choose the best.\n\nThere are some twisty details here:\n\n1) How many beacon nodes?\n   12, and increase on a log scale with network size.  That size can\n   be derived from previous beacons.\n\n2) How long between selection and a beacon becoming active?\n   10 blocks.  That gives time for others to connect to beacon node.\n\n3) How long before a beacon node is invalid?\n   No idea.  Let's keep a day's worth for the moment?\n\n4) How to avoid fake beacons?\n   Require a signature attached to an unspent bitcoin TX from before\n   beacon selection?  That TXID is actually what competes to be close\n   to the beacon selector.\n\n5) How to update beacon routing?\n   Particularly for fee changes, this is important.  Best effort,\n   with ratelimiting.  I hope eventually we'll have reasonable traffic\n   models so a node can say \"I'm going to ramp up/down my fees for\n   this long at this rate\" and have a reasonable chance that it's true.\n\nCheers,\nRusty.\nPS.  For the immediate term, we'll use a global comms mechanism like\n     IRC, but that's just a prototype hack.\n\nAmos Bairn <eylrid at gmail.com> writes:\n> Here is a scheme I thought of for flood based route finding. If it can be\n> pulled off it would allow efficient route finding while keeping the shape\n> of the network hidden, as well as giving onion like anonymity.\n>\n> After writing it up a realized that it has a trivial denial of service\n> attack, that could render it a non-starter.\n>\n> I'm throwing it out there anyway, because this could have significant\n> potential if the DoS problem can be solved.\n>\n> https://github.com/Eylrid/ionization/blob/master/ionization.mediawiki\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-21T11:08:44",
                "message_text_only": "On Mon, Sep 21, 2015 at 11:46:13AM +0930, Rusty Russell wrote:\n> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n> the SHA of latest block hash or something).  Everyone propagates the\n> cheapest route to & from those nodes (which is pretty efficient, similar\n> to your scheme).\n\nI think what you're implicitly assuming here is:\n\n a) global p2p network of lightning nodes; at a minimum each node has\n    a connection to every node it has a channel open with\n\n b) consensus protocol for choosing an ordering of potential beacons\n\n c) potential beacons have to have committed to a beacon id prior to\n    ordering being chosen (with spam/flooding protection)\n\n d) gossip protocol to announce potential beacons and compare against\n    ordering, keeping the top few in memory.\n\n e) sharing routes to beacons with direct neighbours\n\n f) distributed hash to store/lookup route recommendations, keyed by\n    beacon/endpoint\n\n g) distributed hash to lookup fees for hops keyed by hop ends\n\n\nI think (a) is trivial; and you already called out (b).\n\nFor (c), not having a commitment means that people could generate a new\nnode id that does well in the ordering algorithm after the fact; if it's\nSHA comparisons, that means miners would likely monopolise being a beacon.\n\n> 4) How to avoid fake beacons?\n>    Require a signature attached to an unspent bitcoin TX from before\n>    beacon selection?  That TXID is actually what competes to be close\n>    to the beacon selector.\n\nThis might as well be the (an) anchor transaction. It's already in the\nblockchain, it's already associated with a channel. You couldn't just\nuse the txid directly, because that wouldn't differentiate between\nendpoints though. This would give an advantage to nodes with lots of\nchannels open; not sure whether that's desirable? Probably it is?\n\nFor (d), once you've got the ordering, nodes tell each other about their\n12 favourite beacons, and if they hear about better ones, they pass those\non too. That needs to be global knowledge, but it doesn't matter too much\nif we have slightly different sets of 12 beacons at any point.  12 beacon\nids is a fine amount of information to pass around globally, too.\n\nFor (e), I don't think you want to gossip globally about routes --\nthat's too much information to pass around if it's not necessary; but\nyou still have to share your routes to beacons with your neighbours in\norder to figure anything out. Nodes announcing their best routes to their\nneighbours is basically just Dijkstra's algorithm in parallel I think.\n\nBut just knowing your neighbours' routes isn't enough; you need to be\nable to lookup a route for anyone, and that (by definition I think)\nmeans you need (f) a DHT of routes-to-beacons. Note that looking up a\nroute has privacy implications, in that it implies you're probably going\nto make a payment along that route!\n\n> To receive a payment, B picks a few beacon nodes at random and sends\n> those routes (beacons -> B) to A.  Presumably A knows its route to all\n> the beacon nodes and thus can choose the best.\n\nA trivial DHT would be to have each node store its routes locally,\nand just make a TCP/IP connection to the node directly to ask for its\nroutes. That seems like it'd be pretty bad for privacy though. I'm a\nfan of being able to route to/through nodes you can't reach via IP, and\nthis would prevent that too.\n\nFinally for (g), I don't think you want to store fees in the routes\ndirectly, since updating fees would require updating an unknown number\nof routes; but fees have to be queryable, so that's a separate DHT. This\none doesn't need to be updated when new beacons are elected though. This\nDHT would want to be fairly high performance, because you're doing 2*B*L\nlookups everytime you want to find a route, and it has to accept and\npropogate updates fairly quickly if fees change.\n\n> There are some twisty details here:\n> 1) How many beacon nodes?\n>    12, and increase on a log scale with network size.  That size can\n>    be derived from previous beacons.\n\nI think it's also something you could set per-node, like the\nminrelaytxfee.\n\n> 2) How long between selection and a beacon becoming active?\n>    10 blocks.  That gives time for others to connect to beacon node.\n\nBeacons can be \"active\" as soon as you can route through them, and that's\njust a DHT lookup to determine, and then a matter of comparing fees to\nwhat the old beacons give you. So I think no artificial delay is needed,\nand the real question is just when you expire your routes to/from the\nold beacons?\n\n> 3) How long before a beacon node is invalid?\n>    No idea.  Let's keep a day's worth for the moment?\n\nSounds fine; also mostly a client side parameter. (Though if the routing\nDHT is non-trivial, old beacons should expire from there after some\ninterval too to deal with nodes that disappear)\n\n> 5) How to update beacon routing?\n>    Particularly for fee changes, this is important.  Best effort,\n>    with ratelimiting.  I hope eventually we'll have reasonable traffic\n>    models so a node can say \"I'm going to ramp up/down my fees for\n>    this long at this rate\" and have a reasonable chance that it's true.\n\nI think this is reinventing DHTs, though maybe none of the existing ones\nwork well enough for this use case?\n\nI think rate limiting decreases in fees is always safe (it won't prevent\nany transactions going through, it will only prevent them being started).\n\n(I'm not sure a programmed ramp-up/down of fees makes sense; though\nmaybe it would be a good way to perform price discovery)\n\n> PS.  For the immediate term, we'll use a global comms mechanism like\n>      IRC, but that's just a prototype hack.\n\nHmm. Counterproposal: no beacons or routing DHT, just fees by gossip\nprotocol (or IRC channel as prototype hack). Everyone has a complete\n(but possibly slightly out of date) database of node-node (but not\nnode-wallet) channel fees, and changes are propogated by gossip. Back\nof the envelope maths:\n\n  everyone uses lightning ==> 8B wallets (5B teens/adults, 3B businesses)\n  every wallet has ~4 channels ==> 32B node-wallet channels\n  100k wallet channels per node on average ==> 320k nodes\n  16 channels to other nodes per node ==> 2.5M node-node channels\n  (average path length between nodes ~= 4 hops)\n  128b id per node, 32b fee per direction ==> ~100MB of graph data\n\nAn update rate of 10kB/s allows fees to update up to once every three\nhours on average; 100kB/s would be once every 20 minutes or so. Those\nnumbers aren't /great/ but don't seem completely infeasible. Probably\nneeds some signatures or similar to avoid DoS by spam which would slow\nthings down by maybe a factor of two.\n\nIf you do know the entire graph, you don't need to give away any\ninformation about who you want to pay prior to sending the transaction.\nKnowing the graph is potentially interesting for commercial and academic\nreasons beyond wanting privacy. (Knowing the fees others charge helps you\nwork out what fees you should charge; but just querying your neighbours'\nroutes is probably sufficient to work that out too)\n\nYou can even do it so that only nodes (not wallets) need to know the\nfull graph, I think. If you're running a wallet without the full graph,\nwhen finding a route, you:\n\n - get a list of most/all nodes (about 5MB; maybe you already have this,\n   or can just rsync changes)\n - determine how oniony you want to be, picking n nodes, including your\n   desired destination, and one or more of the nodes you have channels\n   open with\n - ask for the shortest path between each pair of those nodes\n - build a cheap path out of that data\n\nEven if n=2 (your node and their node), you only reveal you're paying\none of 100k wallets; and with larger n, any particular node could just be\nbeing used for onion routing, so you're adding ~100k potential recipient\nwallets with each additional node. (Initially, it won't be \"100k\" per\nnode so that doesn't work so well, but initially you could happily run\na full node rather than a wallet anyway)\n\nWhen asking for payment, you just indicate your id, and one or more nodes\nyou have a channel open to. You probably have to indicate the final hop\nfee for each node as well, since that can't be looked up in the graph.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-23T02:42:57",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Mon, Sep 21, 2015 at 11:46:13AM +0930, Rusty Russell wrote:\n>> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n>> the SHA of latest block hash or something).  Everyone propagates the\n>> cheapest route to & from those nodes (which is pretty efficient, similar\n>> to your scheme).\n>\n> I think what you're implicitly assuming here is:\n>\n>  a) global p2p network of lightning nodes; at a minimum each node has\n>     a connection to every node it has a channel open with\n>\n>  b) consensus protocol for choosing an ordering of potential beacons\n>\n>  c) potential beacons have to have committed to a beacon id prior to\n>     ordering being chosen (with spam/flooding protection)\n>\n>  d) gossip protocol to announce potential beacons and compare against\n>     ordering, keeping the top few in memory.\n>\n>  e) sharing routes to beacons with direct neighbours\n>\n>  f) distributed hash to store/lookup route recommendations, keyed by\n>     beacon/endpoint\n>\n>  g) distributed hash to lookup fees for hops keyed by hop ends\n>\n>\n> I think (a) is trivial; and you already called out (b).\n>\n> For (c), not having a commitment means that people could generate a new\n> node id that does well in the ordering algorithm after the fact; if it's\n> SHA comparisons, that means miners would likely monopolise being a beacon.\n>\n>> 4) How to avoid fake beacons?\n>>    Require a signature attached to an unspent bitcoin TX from before\n>>    beacon selection?  That TXID is actually what competes to be close\n>>    to the beacon selector.\n>\n> This might as well be the (an) anchor transaction. It's already in the\n> blockchain, it's already associated with a channel. You couldn't just\n> use the txid directly, because that wouldn't differentiate between\n> endpoints though. This would give an advantage to nodes with lots of\n> channels open; not sure whether that's desirable? Probably it is?\n>\n> For (d), once you've got the ordering, nodes tell each other about their\n> 12 favourite beacons, and if they hear about better ones, they pass those\n> on too. That needs to be global knowledge, but it doesn't matter too much\n> if we have slightly different sets of 12 beacons at any point.  12 beacon\n> ids is a fine amount of information to pass around globally, too.\n>\n> For (e), I don't think you want to gossip globally about routes --\n> that's too much information to pass around if it's not necessary; but\n> you still have to share your routes to beacons with your neighbours in\n> order to figure anything out. Nodes announcing their best routes to their\n> neighbours is basically just Dijkstra's algorithm in parallel I think.\n\nIndeed, it's trivial (and I've already implemented a simple simulator to\ndo it).  The initial spamminess can be mitigated by waiting before\nbroadcasting depending on how likely you are a beacon.\n\n> But just knowing your neighbours' routes isn't enough; you need to be\n> able to lookup a route for anyone, and that (by definition I think)\n> means you need (f) a DHT of routes-to-beacons. Note that looking up a\n> route has privacy implications, in that it implies you're probably going\n> to make a payment along that route!\n\nThat's why the recipient provides a set of routes from (some subset of)\nbeacons to them.  You know routes to all beacons, so pathfinding solved.\n\n>> To receive a payment, B picks a few beacon nodes at random and sends\n>> those routes (beacons -> B) to A.  Presumably A knows its route to all\n>> the beacon nodes and thus can choose the best.\n>\n> A trivial DHT would be to have each node store its routes locally,\n> and just make a TCP/IP connection to the node directly to ask for its\n> routes. That seems like it'd be pretty bad for privacy though. I'm a\n> fan of being able to route to/through nodes you can't reach via IP, and\n> this would prevent that too.\n\nYes, that's a bad idea.  And I'm not sure why you need this?\n\n> Finally for (g), I don't think you want to store fees in the routes\n> directly, since updating fees would require updating an unknown number\n> of routes; but fees have to be queryable, so that's a separate DHT. This\n> one doesn't need to be updated when new beacons are elected though. This\n> DHT would want to be fairly high performance, because you're doing 2*B*L\n> lookups everytime you want to find a route, and it has to accept and\n> propogate updates fairly quickly if fees change.\n\nWell, propagating fee updates for (say) 1200 routes isn't too bad,\nas long as they're not changing too fast.\n\n>> There are some twisty details here:\n>> 1) How many beacon nodes?\n>>    12, and increase on a log scale with network size.  That size can\n>>    be derived from previous beacons.\n>\n> I think it's also something you could set per-node, like the\n> minrelaytxfee.\n\nThat doesn't make sense, since we need to agree on who is a beacon.\n\n>> 2) How long between selection and a beacon becoming active?\n>>    10 blocks.  That gives time for others to connect to beacon node.\n>\n> Beacons can be \"active\" as soon as you can route through them, and that's\n> just a DHT lookup to determine, and then a matter of comparing fees to\n> what the old beacons give you. So I think no artificial delay is needed,\n> and the real question is just when you expire your routes to/from the\n> old beacons?\n\nNo.  Beacons will get saturated fast unless they have a chance to\nprepare.  In particular, the network will want to establish channels\nwith new beacons, and beacons may well want to bring offline funds\nonline to handle the anticipated capacity.\n\n>> 3) How long before a beacon node is invalid?\n>>    No idea.  Let's keep a day's worth for the moment?\n>\n> Sounds fine; also mostly a client side parameter. (Though if the routing\n> DHT is non-trivial, old beacons should expire from there after some\n> interval too to deal with nodes that disappear)\n>\n>> 5) How to update beacon routing?\n>>    Particularly for fee changes, this is important.  Best effort,\n>>    with ratelimiting.  I hope eventually we'll have reasonable traffic\n>>    models so a node can say \"I'm going to ramp up/down my fees for\n>>    this long at this rate\" and have a reasonable chance that it's true.\n>\n> I think this is reinventing DHTs, though maybe none of the existing ones\n> work well enough for this use case?\n\nWhat's the fascination with DHTs?\n\n> I think rate limiting decreases in fees is always safe (it won't prevent\n> any transactions going through, it will only prevent them being started).\n>\n> (I'm not sure a programmed ramp-up/down of fees makes sense; though\n> maybe it would be a good way to perform price discovery)\n>\n>> PS.  For the immediate term, we'll use a global comms mechanism like\n>>      IRC, but that's just a prototype hack.\n>\n> Hmm. Counterproposal: no beacons or routing DHT, just fees by gossip\n> protocol (or IRC channel as prototype hack). Everyone has a complete\n> (but possibly slightly out of date) database of node-node (but not\n> node-wallet) channel fees, and changes are propogated by gossip. Back\n> of the envelope maths:\n>\n>   everyone uses lightning ==> 8B wallets (5B teens/adults, 3B businesses)\n>   every wallet has ~4 channels ==> 32B node-wallet channels\n>   100k wallet channels per node on average ==> 320k nodes\n\nUm, so each wallet isn't a node?  That's a very different architecture,\nwhich uses hosted wallets or something?  I don't think that's very\ninteresting.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-23T05:42:40",
                "message_text_only": "On Wed, Sep 23, 2015 at 12:12:57PM +0930, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On Mon, Sep 21, 2015 at 11:46:13AM +0930, Rusty Russell wrote:\n> >> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n> >> the SHA of latest block hash or something).  Everyone propagates the\n> >> cheapest route to & from those nodes (which is pretty efficient, similar\n> >> to your scheme).\n> > I think what you're implicitly assuming here is:\n> >  a) global p2p network of lightning nodes; at a minimum each node has\n> >     a connection to every node it has a channel open with\n> >  b) consensus protocol for choosing an ordering of potential beacons\n> >  c) potential beacons have to have committed to a beacon id prior to\n> >     ordering being chosen (with spam/flooding protection)\n> >  d) gossip protocol to announce potential beacons and compare against\n> >     ordering, keeping the top few in memory.\n> >  e) sharing routes to beacons with direct neighbours\n\n> >  f) distributed hash to store/lookup route recommendations, keyed by\n> >     beacon/endpoint\n\nSo this one's incorrect. I think instead you're assuming:\n\n f) when asking for a payment to be made to you, you provide your\n    lightning public key, and a set of low-cost paths from the current\n    beacons to you. (ie, your \"address\" for payments includes full\n    routing and fee info)\n\n> >  g) distributed hash to lookup fees for hops keyed by hop ends\n\nWhen fees change, which path to a beacon is low cost will often change\ntoo, so this really doesn't do you any good.\n\n> > Finally for (g), I don't think you want to store fees in the routes\n> Well, propagating fee updates for (say) 1200 routes isn't too bad,\n> as long as they're not changing too fast.\n\nSo forgetting the DHTs, then fee updates take effect via the\ndijkstra-routing-gossip protocol. I don't have any idea how well that\nwould perform... If an average channel's fee updates U times per day,\nthere are C channels, and N nodes, does that mean a background noise of\nO(log(N)*U*C) fee update traffic or something? (dividing by N to get the\ntraffic an individual node sees)\n\nIt does mean that the \"payment info\" has to be provided by the payee\n\"shortly\" before the transaction; otherwise the route and fee information\nwould be out of date and the payment becomes \"likely\" to fail due to\nclosed channels or raised fees.\n\n> >> There are some twisty details here:\n> >> 1) How many beacon nodes?\n> >>    12, and increase on a log scale with network size.  That size can\n> >>    be derived from previous beacons.\n> > I think it's also something you could set per-node, like the\n> > minrelaytxfee.\n> That doesn't make sense, since we need to agree on who is a beacon.\n\nIf you have the top 10 beacons and I have the top 14 beacons, we have\nthe top 10 beacons in common. During the gossip phase, if either of us\nsee someone in the top 10, we pass it along; I pass along a few more as\nwell.\n\n> >> 2) How long between selection and a beacon becoming active?\n> >>    10 blocks.  That gives time for others to connect to beacon node.\n> > Beacons can be \"active\" as soon as you can route through them, and that's\n> > just a DHT lookup to determine, and then a matter of comparing fees to\n> > what the old beacons give you. So I think no artificial delay is needed,\n> > and the real question is just when you expire your routes to/from the\n> > old beacons?\n> No.  Beacons will get saturated fast unless they have a chance to\n> prepare.  \n\nSure. I was thinking you have to volunteer to be a beacon, ie something\nlike:\n\n  1) commit to node id (anchor transaction in blockchain)\n  2) commit to ordering (abs difference of node id versus \n     sha of latest blockchain block with (depth % 2016 == 0))\n  3) volunteer to be a beacon (sign \"imma beacon! depth $n anchor\n     $txid\")\n  4) gossip (including your signed volunteer statement) and hope you're\n     in the top 12\n\nAny preparation (opening new channels etc happens between (2) and (3)),\ntransactions happen immediately after (4).\n\nIf other nodes can \"force\" you to be a beacon, I think that causes\nproblems anyway (maybe you just don't have the bandwidth to deal with\na high transaction volume), so I think the \"volunteering\" step is needed.\n\n> In particular, the network will want to establish channels\n> with new beacons, and beacons may well want to bring offline funds\n> online to handle the anticipated capacity.\n\nSo... doesn't this provide a /really/ juicy target for hackers? Either\nof the \"let's steal funds\" variety, or of the \"let's find out as much\ninfo about every transaction as we can\" type?\n\nIf you just have to hack 12 systems to observe/DoS 100% of lightning\nnetwork transactions, that seems worrying to me. I think I'd want to avoid\nbeing a beacon in that case, just to avoid painting a target on my system.\n\nI'm not sure if it's a realistic attack model, but if you can observe:\n\n  Bob -> Alice: pay me $20 to R (routes to current beacons: ...)\n\nand have control of the beacon Alice ends up using, then you can both\nobserve that Alice is trying to make the payment (you see an HTLC with\n$20 and R), and prevent Alice from making the payment (you can just not\nforward any transactions involving R).\n\nWithout beacons (but routing still being possible somehow!), Bob could\nanonymously post prices and R values in public; Alice could observe them\nanonymously without giving away that she was observing them, and Mallory\ncould not prevent Alice from paying Bob, without controlling Alice or Bob,\nor a large proportion of the lightning network as a whole. Bob could be\na dissident asking for donations in this scenario, eg.\n\nWith beacons, Mallory could somewhat plausibly gain control of the beacons\nBob is advertising, and then block any payments with those published\nR values from going through. This could happen by subpoena or national\nsecurity letter rather than buffer overflow too.\n\n> > Hmm. Counterproposal: no beacons or routing DHT, just fees by gossip\n> > protocol (or IRC channel as prototype hack). Everyone has a complete\n> > (but possibly slightly out of date) database of node-node (but not\n> > node-wallet) channel fees, and changes are propogated by gossip. Back\n> > of the envelope maths:\n> >\n> >   everyone uses lightning ==> 8B wallets (5B teens/adults, 3B businesses)\n> >   every wallet has ~4 channels ==> 32B node-wallet channels\n> >   100k wallet channels per node on average ==> 320k nodes\n> Um, so each wallet isn't a node?\n\nErr, yeah; I've been using those terms mutually exclusively, ie \"you're\nrunning a full node, or you're just a wallet, you're never both\":\n\n13:47 <rusty> kanzure: Aside: Joseph has been avoiding the term hub in\n        favour of simply \"nodes\".  I've been following suit, since I\n        think it directs thinking in the right non-centralized direction.\n13:47 <kanzure> but hub is more fun to pronounce\n13:47 <kanzure> bah fine i'll use node then\n13:48 <rusty> kanzure: Me too.  I have a bub, he likes to say hub.\n        But I'll just have to teach him....\n13:48 <aj> rusty: i feel like \"just spending/receiving money with as\n        little thought/effort as possible\" and \"being an active\n        participant\" needs different words... leaf node and node\n        don't really work for me\n13:48 <kanzure> \"wallet\"\n13:49 <aj> wallets and nodes? hmm\n\nie, nodes do payment forwarding; wallets just spend/recieve. You'd use\nyour phone as just a wallet, but you might run a node at home or in\nthe cloud. Wallets still do the lightning protocol themselves, they just\ndon't earn fees by forwarding payments.\n\nAside: \"mesh network\" seems to be a much better description than\nhub-and-spoke... cf\n\nhttps://www.reddit.com/r/Bitcoin/comments/3lo8mb/serious_question_for_blockstreamcom_will_you_let/\n\n> That's a very different architecture,\n\nI'm just using it as terminology (I think...).\n\nThe only architectural implication is that I'm assuming \"most\" people\n(24999 out of 25000) don't end up doing routing. Given routing nodes\nhave to be online with hot keys and thus risk being hacked and having\ntheir funds drained, I think that's fairly plausible?\n\n(Or going the other way; if you're making money running a node, I think\nit's pretty reasonable you'll try to serve on the order of 100k users\n-- much less than that and you'll be under utilising your hardware. But\nwith only 8B potential customers, there's a limit on the number of nodes\nthat can actually do that, as calculated above. I'm assuming economics\nsomehow ends up enforcing that limit effectively)\n\n> which uses hosted wallets or something?  I don't think that's very\n> interesting.\n\nNot hosted wallets; more along the lines of SPV clients, where you're\nrelying on the network to do most of the work (in this case working out\na cheap route, rather than verifying txns)?\n\nDoes that make it more interesting?\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-24T20:56:55",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n>> > Finally for (g), I don't think you want to store fees in the routes\n>> Well, propagating fee updates for (say) 1200 routes isn't too bad,\n>> as long as they're not changing too fast.\n>\n> So forgetting the DHTs, then fee updates take effect via the\n> dijkstra-routing-gossip protocol. I don't have any idea how well that\n> would perform... If an average channel's fee updates U times per day,\n> there are C channels, and N nodes, does that mean a background noise of\n> O(log(N)*U*C) fee update traffic or something? (dividing by N to get the\n> traffic an individual node sees)\n\nThat sounds about right.  There's a tradeoff between redundancy,\nbandwidth and latency.\n\n> It does mean that the \"payment info\" has to be provided by the payee\n> \"shortly\" before the transaction; otherwise the route and fee information\n> would be out of date and the payment becomes \"likely\" to fail due to\n> closed channels or raised fees.\n\nTrue.  Though in the case of raised fees you get feedback, and can\nadjust.\n\n>> >> There are some twisty details here:\n>> >> 1) How many beacon nodes?\n>> >>    12, and increase on a log scale with network size.  That size can\n>> >>    be derived from previous beacons.\n>> > I think it's also something you could set per-node, like the\n>> > minrelaytxfee.\n>> That doesn't make sense, since we need to agree on who is a beacon.\n>\n> If you have the top 10 beacons and I have the top 14 beacons, we have\n> the top 10 beacons in common. During the gossip phase, if either of us\n> see someone in the top 10, we pass it along; I pass along a few more as\n> well.\n\nIf I want to pay you, and you give me those 4 beacons I don't accept, we\nbreak down.\n\n>> >> 2) How long between selection and a beacon becoming active?\n>> >>    10 blocks.  That gives time for others to connect to beacon node.\n>> > Beacons can be \"active\" as soon as you can route through them, and that's\n>> > just a DHT lookup to determine, and then a matter of comparing fees to\n>> > what the old beacons give you. So I think no artificial delay is needed,\n>> > and the real question is just when you expire your routes to/from the\n>> > old beacons?\n>> No.  Beacons will get saturated fast unless they have a chance to\n>> prepare.  \n>\n> Sure. I was thinking you have to volunteer to be a beacon, ie something\n> like:\n>\n>   1) commit to node id (anchor transaction in blockchain)\n>   2) commit to ordering (abs difference of node id versus \n>      sha of latest blockchain block with (depth % 2016 == 0))\n>   3) volunteer to be a beacon (sign \"imma beacon! depth $n anchor\n>      $txid\")\n>   4) gossip (including your signed volunteer statement) and hope you're\n>      in the top 12\n>\n> Any preparation (opening new channels etc happens between (2) and (3)),\n> transactions happen immediately after (4).\n\nWe don't want to have to maintain a table of volunteers, hence 3 & 4 are\nmerged (simple optimization: delay advertising yourself as a beacon\nlonger if it's less likely).\n\nThen by convention you delay 10 blocks before using a beacon.  By that\ntime, routes should be sufficient.\n\nSo, it comes down to the following if you want to be a beacon:\n\n1) Use same key anchor tx to sign a message linking your node id to the\n   tx.\n2) Broadcast that, and signed routes as normal.\n\n>> In particular, the network will want to establish channels\n>> with new beacons, and beacons may well want to bring offline funds\n>> online to handle the anticipated capacity.\n>\n> So... doesn't this provide a /really/ juicy target for hackers? Either\n> of the \"let's steal funds\" variety, or of the \"let's find out as much\n> info about every transaction as we can\" type?\n>\n> If you just have to hack 12 systems to observe/DoS 100% of lightning\n> network transactions, that seems worrying to me. I think I'd want to avoid\n> being a beacon in that case, just to avoid painting a target on my system.\n>\n> I'm not sure if it's a realistic attack model, but if you can observe:\n>\n>   Bob -> Alice: pay me $20 to R (routes to current beacons: ...)\n>\n> and have control of the beacon Alice ends up using, then you can both\n> observe that Alice is trying to make the payment (you see an HTLC with\n> $20 and R), and prevent Alice from making the payment (you can just not\n> forward any transactions involving R).\n\nSure.  But if you can observe the private conversation between Bob and\nAlice, *and* you control enough nodes that you're likely to be the\nbeacon they choose, you don't need to be a beacon to block them :)\n\n> Without beacons (but routing still being possible somehow!), Bob could\n> anonymously post prices and R values in public; Alice could observe them\n> anonymously without giving away that she was observing them, and Mallory\n> could not prevent Alice from paying Bob, without controlling Alice or Bob,\n> or a large proportion of the lightning network as a whole. Bob could be\n> a dissident asking for donations in this scenario, eg.\n\nYes!  I've been wondering about this kind of \"donation address\"\nscenario.  Turns out you can encode the R value in the onion routed\nmessage you send, too.  Only the final recipient can read it anyway.\n\nThat doesn't help with routing to the donation address; maybe we will\nneed a best-effort DHT for that?\n\n> ie, nodes do payment forwarding; wallets just spend/recieve. You'd use\n> your phone as just a wallet, but you might run a node at home or in\n> the cloud. Wallets still do the lightning protocol themselves, they just\n> don't earn fees by forwarding payments.\n\nI think you do want to \n\n>\n> Aside: \"mesh network\" seems to be a much better description than\n> hub-and-spoke... cf\n>\n> https://www.reddit.com/r/Bitcoin/comments/3lo8mb/serious_question_for_blockstreamcom_will_you_let/\n\nThanks for that: I'd somehow missed that troll.\n\n>> That's a very different architecture,\n>\n> I'm just using it as terminology (I think...).\n>\n> The only architectural implication is that I'm assuming \"most\" people\n> (24999 out of 25000) don't end up doing routing. Given routing nodes\n> have to be online with hot keys and thus risk being hacked and having\n> their funds drained, I think that's fairly plausible?\n\nBut that risk also describes a wallet.  And if you route, you\npotentially gain funds as well as privacy.  It's more a connectivity\nissue, I think.\n\n> (Or going the other way; if you're making money running a node, I think\n> it's pretty reasonable you'll try to serve on the order of 100k users\n> -- much less than that and you'll be under utilising your hardware. But\n> with only 8B potential customers, there's a limit on the number of nodes\n> that can actually do that, as calculated above. I'm assuming economics\n> somehow ends up enforcing that limit effectively)\n>\n>> which uses hosted wallets or something?  I don't think that's very\n>> interesting.\n>\n> Not hosted wallets; more along the lines of SPV clients, where you're\n> relying on the network to do most of the work (in this case working out\n> a cheap route, rather than verifying txns)?\n\nBut the \"give me a cheap route\" question is exactly the same whatever\nyour role.  It's \"give me all your routes to beacons\".  That's a few\nhundred routes.  If we're clever it's \"give me changes since last time\",\nwhich is easy given that it's finite.\n\nThis has the advantage that you can't even tell if I'm routing or not.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-25T10:11:40",
                "message_text_only": "On Fri, Sep 25, 2015 at 06:26:55AM +0930, Rusty Russell wrote:\n> >> >> There are some twisty details here:\n> >> >> 1) How many beacon nodes?\n> >> >>    12, and increase on a log scale with network size.  That size can\n> >> >>    be derived from previous beacons.\n> >> > I think it's also something you could set per-node, like the\n> >> > minrelaytxfee.\n> >> That doesn't make sense, since we need to agree on who is a beacon.\n> > If you have the top 10 beacons and I have the top 14 beacons, we have\n> > the top 10 beacons in common. During the gossip phase, if either of us\n> > see someone in the top 10, we pass it along; I pass along a few more as\n> > well.\n> If I want to pay you, and you give me those 4 beacons I don't accept, we\n> break down.\n\nI have 14 beacons, and I know the order in which you're most likely\nto have them. If I know you can choose how many beacons you track,\nwhy would I give you the four you're least likely to have (because you\nhave a lower limit, or because you've heard of four better beacons that\nhaven't made it to me yet)?\n\nSince I have to update my beacon-to-me routes regularly because of fee\nchanges, I could regularly select different groups of beacons so you\ncould just ask again.\n\n> >> >> 2) How long between selection and a beacon becoming active?\n> >> >>    10 blocks.  That gives time for others to connect to beacon node.\n> >> > Beacons can be \"active\" as soon as you can route through them, and that's\n> >> > just a DHT lookup to determine, and then a matter of comparing fees to\n> >> > what the old beacons give you. So I think no artificial delay is needed,\n> >> > and the real question is just when you expire your routes to/from the\n> >> > old beacons?\n> >> No.  Beacons will get saturated fast unless they have a chance to\n> >> prepare.\n> > Sure. I was thinking you have to volunteer to be a beacon, ie something\n> > like:\n> >\n> >   1) commit to node id (anchor transaction in blockchain)\n> >   2) commit to ordering (abs difference of node id versus \n> >      sha of latest blockchain block with (depth % 2016 == 0))\n> >   3) volunteer to be a beacon (sign \"imma beacon! depth $n anchor\n> >      $txid\")\n> >   4) gossip (including your signed volunteer statement) and hope you're\n> >      in the top 12\n> > Any preparation (opening new channels etc happens between (2) and (3)),\n> > transactions happen immediately after (4).\n> We don't want to have to maintain a table of volunteers, hence 3 & 4 are\n> merged (simple optimization: delay advertising yourself as a beacon\n> longer if it's less likely).\n\nIf you want to do any setup, I think you need to advertise yourself as\na beacon to the people you want to setup with. I'm thinking that if you\nwin the beacon lottery, you'll want to say \"hi, I'm about to be a beacon\"\nso people will setup channels with you without you having to put much\ninitial investment in that channel. The people setting up channels with\nyou see a bunch of people doing that, and will only want to deal with the\ntop 12 or so. I'm not sure that's much different to actually advertising?\n\n> Then by convention you delay 10 blocks before using a beacon.  By that\n> time, routes should be sufficient.\n\nI wouldn't have thought 10 blocks was long enough to setup a new channel\nespecially to a beacon, fwiw. (If you can create a channel to a beacon\nwith the beacon's side initially 0, spend all that money back to yourself,\nthen reorg with a doublespend of the anchor inputs so the channel never\nexisted, you can steal the beacon's pre-existing savings. The routing's\ntrivial -- it's you to the beacon, and then each of your neighbours will\ntell you the cheapest path from a beacon to them as soon as they know it)\n\n> > So... doesn't this provide a /really/ juicy target for hackers? Either\n> > of the \"let's steal funds\" variety, or of the \"let's find out as much\n> > info about every transaction as we can\" type?\n> >\n> > If you just have to hack 12 systems to observe/DoS 100% of lightning\n> > network transactions, that seems worrying to me. I think I'd want to avoid\n> > being a beacon in that case, just to avoid painting a target on my system.\n> >\n> > I'm not sure if it's a realistic attack model, but if you can observe:\n> >\n> >   Bob -> Alice: pay me $20 to R (routes to current beacons: ...)\n> >\n> > and have control of the beacon Alice ends up using, then you can both\n> > observe that Alice is trying to make the payment (you see an HTLC with\n> > $20 and R), and prevent Alice from making the payment (you can just not\n> > forward any transactions involving R).\n> Sure.  But if you can observe the private conversation between Bob and\n> Alice, *and* you control enough nodes that you're likely to be the\n> beacon they choose, you don't need to be a beacon to block them :)\n\nYou don't have to control the nodes initially, you just have to attack\nthe beacons once they're announced. If they're accepting new channels,\nthen they've announced an IP. If you get an exploit on a node that\nwould have been #15 in the ranking, you just have to DoS three higher\nranked beacons to get it to have traffic.\n\n> > Without beacons (but routing still being possible somehow!), Bob could\n> > anonymously post prices and R values in public; Alice could observe them\n> > anonymously without giving away that she was observing them, and Mallory\n> > could not prevent Alice from paying Bob, without controlling Alice or Bob,\n> > or a large proportion of the lightning network as a whole. Bob could be\n> > a dissident asking for donations in this scenario, eg.\n> Yes!  I've been wondering about this kind of \"donation address\"\n> scenario.  Turns out you can encode the R value in the onion routed\n> message you send, too.  Only the final recipient can read it anyway.\n\nYep.\n\n> That doesn't help with routing to the donation address; maybe we will\n> need a best-effort DHT for that?\n\nIf you've got a route, but no fee information; you could probe the\nroute with nanopayments. ie, to move $10 along me->A->B->C->D, first\ntry sending 0.01c to B with a 0.1% then a 0.2% fee, etc. Once you know\nA's fee, repeat with B, then C. If the fees end up as 1%, 2% and 0.2%\nyour successful transactions are:\n\n  0.01c to B plus 0.0001c to A\n  0.01c to C plus 0.0001c to A plus 0.0002c to B\n  0.01c to D plus 0.0001c to A plus 0.0002c to B plus 0.00002c to C\n  $10 to D plus 10c to A plus 20c to B plus 2c to C\n\nand the txs that had smaller fees just bounce back to you.\n\nTotals:\n  $10 to D and also\n   0.01c to D\n   2.01002c to C\n  20.0014c to B\n  10.0003c to A\n\nfor a total of $10 and 32.02172c.\n\n0.2c = 860 satoshi, but lightning handles milli-satoshi now, so 0.0002c\n= 860 msat and 0.00002c = 86 msat, so all those fees are expressible,\nand the probing only increases your fees by 0.06%. If I'd been sending\n10c instead of $10 but used the same nanotransaction probing I would've\npaid 0.34172c instead of .32c in fees for a 6% increase in fees. So\npretty plausible even then.\n\n(If probing was the main use for nanotransactions, nodes might set higher\nfees on them though, if they assume you've already chosen a route, and\nthey therefore don't need to compete on price with other possible routes)\n\n> > ie, nodes do payment forwarding; wallets just spend/recieve. You'd use\n> > your phone as just a wallet, but you might run a node at home or in\n> > the cloud. Wallets still do the lightning protocol themselves, they just\n> > don't earn fees by forwarding payments.\n> I think you do want to \n\n\"run a node on your phone\" ?\n\nIn order to gain node-like return on your investment, I think you'd have\nto be constantly active -- so updating your routes, tracking beacons,\netc. You'd miss out on ever being a beacon presumably, which would\npretty severely cut into your income to nodes that are beacons -- though\nmaybe you could sell your beacon-worthy private keys and recoup some of\nthat? I don't see how anyone would feel confident to buy your private\nkeys though.\n\nYour phone would need to be doing fairly constant network access while\nit was in your pocket as it forwarded HTLCs; 24k transactions per second\nover a million nodes at 5 non-beacon hops is still around 7 tx/minute\nfor a random node. Each of those comes with multiple crypto ops as\nwell. So you'd be burning battery afaics. If you're only doing it while\nyou're plugged into AC, then I'd expect your ROI to drop proportionately\n(so instead of $10 from $100 over a year, maybe $3.50 if you leave your\nphone on charge every night).\n\nIt'd also up the latency for people routed through you a fair bit;\nphones aren't that fast, and aren't that well connected. So any payment\nrouted over one would be that much slower than one that went via servers\non fibre. If you're slow to process a transaction and more likely to\nlose connectivity, that ups the chances of an HTLC stalling -- you've\naccepted it, but you lost connectivity while trying to forward it, so\neveryone else is out of pocket until you get signal back.\n\nForwarding also introduces the risk that all your funds are tied up in\nactive HTLCs when you want to buy a coffee.\n\nI just don't think everyone running a full node trying to make a profit\noff routing is realistic.\n\n> > Aside: \"mesh network\" seems to be a much better description than\n> > hub-and-spoke... cf\n> > https://www.reddit.com/r/Bitcoin/comments/3lo8mb/serious_question_for_blockstreamcom_will_you_let/\n> Thanks for that: I'd somehow missed that troll.\n\nSeemed like a legit question to me *shrug*. There's a corresponding thread\n(same title) on BitcoinXT, if you really want to feel trolled.\n\nThere's also:\n\n  /r/lightningnetwork: The Bitcoin Lightning Network\n\n  This sub-reddit is dedicated to corporate interests trying to take over\n  the decentralized world-wide ledger.\n\nNo posts unfortunately...\n\n> >> That's a very different architecture,\n> > I'm just using it as terminology (I think...).\n> > The only architectural implication is that I'm assuming \"most\" people\n> > (24999 out of 25000) don't end up doing routing. Given routing nodes\n> > have to be online with hot keys and thus risk being hacked and having\n> > their funds drained, I think that's fairly plausible?\n> But that risk also describes a wallet.\n\nI don't think so: if I'm only sending/receiving money, I can be offline\nfor the entire time I'm not doing transactions. For consumers, that's\n(potentially) most of the time; for merchants, that's at least when the\nbusiness is closed (not much benefit for 24/7 online businesses though).\n\n> And if you route, you potentially gain funds as well as privacy.\n\nIt'll only gain you a percentage of what you've got in the channel though\n(or that's what I expect anyway). If you're a consumer who keeps $100 in\nyour wallet, that's maybe $10 in a year. But to earn that $10 you have to\nworry about keeping you wallet secure and online, which I'd expect isn't\nworth it. For a phone, that could be compromised by plugging it into a USB\nport for power, or a flaw in a carrier's version of android, or privilege\nescalation from some random app, I'd rather have it be offline and safe\nfor the 99% of the time I'm not buying anything.\n\n(Caveat one: Maybe phones are so insecure there's no way to have a private\nkey that's reasonably convenient, but also \"safe\" while \"offline\". You\ncould mitigate that by introducing a second factor; having $10 on your\nphone most of the time -- coffee and bus fare money, that you don't care\nmuch if someone steals -- but having a secondary lightning wallet that\nyou can only use by tapping a crypto-NFC smartcard for when you want to\npay for dinner or recharge your primary wallet, eg. Having your phone\nbe secure directly would be better though)\n\n(Caveat two: There's no reason not to forward transactions while you're\nonline and your private keys are in memory -- err, assuming they don't\nlock up too many funds anyway; I just think there's good reason to be\nonline as little as possible)\n\nAs far as privacy goes I think you could tell which of your neighbours\nis using lightning primarily as a wallet versus trying to be a\nprofit-generating node fairly easily: wallets will have smaller channels,\nthere'll be fewer transactions over them, and they'll disconnect more\noften. That doesn't guarantee they're not forwarding things; but if they\nare they're almost certainly arranging it out of band anyway (even if\nonly to know when they'll be online and thus able to forward).\n\n(I actually think arguing the other way might make a bit of sense; if\nyou're running a node, you should pay profits and expenses to/from an\nentirely separate lightning wallet)\n\n> > (Or going the other way; if you're making money running a node, I think\n> > it's pretty reasonable you'll try to serve on the order of 100k users\n> > -- much less than that and you'll be under utilising your hardware. But\n> > with only 8B potential customers, there's a limit on the number of nodes\n> > that can actually do that, as calculated above. I'm assuming economics\n> > somehow ends up enforcing that limit effectively)\n> >\n> >> which uses hosted wallets or something?  I don't think that's very\n> >> interesting.\n> >\n> > Not hosted wallets; more along the lines of SPV clients, where you're\n> > relying on the network to do most of the work (in this case working out\n> > a cheap route, rather than verifying txns)?\n> But the \"give me a cheap route\" question is exactly the same whatever\n> your role.  It's \"give me all your routes to beacons\".\n\nI was talking about the beacon-less alternative here, where nodes have\nthe full weighted-directed-graph of channels and fees to work out a route.\n\n> That's a few hundred routes.\n\nAlso, with beacons, you don't need to know all their routes to beacons,\njust their cheapest route to each beacon, so that should be just 12\nroutes (unless we're working with a few hundred beacons now?). No\nmatter which route from them, it'll always just be the same You<->Them\nchannel beforehand, so cheapest via them will just be that plus their\ncheapest. You need to keep all your neighbours' cheapest routes to\nfall back on if someone else raises fees though, if you're not willing\nto repoll.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-27T05:26:29",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Sep 25, 2015 at 06:26:55AM +0930, Rusty Russell wrote:\n>> >> >> There are some twisty details here:\n>> >> >> 1) How many beacon nodes?\n>> >> >>    12, and increase on a log scale with network size.  That size can\n>> >> >>    be derived from previous beacons.\n>> >> > I think it's also something you could set per-node, like the\n>> >> > minrelaytxfee.\n>> >> That doesn't make sense, since we need to agree on who is a beacon.\n>> > If you have the top 10 beacons and I have the top 14 beacons, we have\n>> > the top 10 beacons in common. During the gossip phase, if either of us\n>> > see someone in the top 10, we pass it along; I pass along a few more as\n>> > well.\n>> If I want to pay you, and you give me those 4 beacons I don't accept, we\n>> break down.\n>\n> I have 14 beacons, and I know the order in which you're most likely\n> to have them. If I know you can choose how many beacons you track,\n> why would I give you the four you're least likely to have (because you\n> have a lower limit, or because you've heard of four better beacons that\n> haven't made it to me yet)?\n\nErgo, there are only 10 beacons, since that's all you'll ever use?  So,\nyou *don't* get to choose your number of beacons.\n\nAnyway, I won't propagate fee broadcasts which don't alter my proximity\nto a beacon.  So if I'm between you and something only you consider a\n\"beacon\", you'll never know about it.\n\nAnd in practice it's trivial to agree on the number of new beacons for\nthis block, given the beacons for previous blocks (assuming we want\nnumber of beacons to grow with the network).\n\nIn summary, having your own beacons basically defeats the purpose of\nselecting beacons.\n\n> Since I have to update my beacon-to-me routes regularly because of fee\n> changes, I could regularly select different groups of beacons so you\n> could just ask again.\n\nYech... you really want this to be single pass \"pay me $5, and here are\nthree routes from beacons near me\".\n\n>> > Sure. I was thinking you have to volunteer to be a beacon, ie something\n>> > like:\n>> >\n>> >   1) commit to node id (anchor transaction in blockchain)\n>> >   2) commit to ordering (abs difference of node id versus \n>> >      sha of latest blockchain block with (depth % 2016 == 0))\n>> >   3) volunteer to be a beacon (sign \"imma beacon! depth $n anchor\n>> >      $txid\")\n>> >   4) gossip (including your signed volunteer statement) and hope you're\n>> >      in the top 12\n>> > Any preparation (opening new channels etc happens between (2) and (3)),\n>> > transactions happen immediately after (4).\n>> We don't want to have to maintain a table of volunteers, hence 3 & 4 are\n>> merged (simple optimization: delay advertising yourself as a beacon\n>> longer if it's less likely).\n>\n> If you want to do any setup, I think you need to advertise yourself as\n> a beacon to the people you want to setup with. I'm thinking that if you\n> win the beacon lottery, you'll want to say \"hi, I'm about to be a beacon\"\n> so people will setup channels with you without you having to put much\n> initial investment in that channel. The people setting up channels with\n> you see a bunch of people doing that, and will only want to deal with the\n> top 12 or so. I'm not sure that's much different to actually advertising?\n\nWell, my original idea was a beacon can just start broadcasting routes\nand see what happens.\n\nBut you're right makes more sense to have two-phases: an immediate one\nafter the block is broadcast where you compete (via SPV proof of some\ntx) to be a beacon, then another closer to activation where you\nbroadcast routes.  Between those two you can expect an influx of channel\noffers.\n\nInterestingly, the former idea means you get some leakage of routes,\nfrom nearby almost-beacons (until defeated by better beacons).\nRemembering those might help shortcircuit some routes (if there's some\ngeographical correlation between nodes).\n\n>> Then by convention you delay 10 blocks before using a beacon.  By that\n>> time, routes should be sufficient.\n>\n> I wouldn't have thought 10 blocks was long enough to setup a new channel\n> especially to a beacon, fwiw. (If you can create a channel to a beacon\n> with the beacon's side initially 0, spend all that money back to yourself,\n> then reorg with a doublespend of the anchor inputs so the channel never\n> existed, you can steal the beacon's pre-existing savings. The routing's\n> trivial -- it's you to the beacon, and then each of your neighbours will\n> tell you the cheapest path from a beacon to them as soon as they know it)\n\nI guess I was thinking of microtransactions, and expecting the average\nanchor depth requirement to be ~1.  6 is considered pretty conservative;\nI only added 4 to allow for propogation and setup time.\n\n>> > I'm not sure if it's a realistic attack model, but if you can observe:\n>> >\n>> >   Bob -> Alice: pay me $20 to R (routes to current beacons: ...)\n>> >\n>> > and have control of the beacon Alice ends up using, then you can both\n>> > observe that Alice is trying to make the payment (you see an HTLC with\n>> > $20 and R), and prevent Alice from making the payment (you can just not\n>> > forward any transactions involving R).\n>> Sure.  But if you can observe the private conversation between Bob and\n>> Alice, *and* you control enough nodes that you're likely to be the\n>> beacon they choose, you don't need to be a beacon to block them :)\n>\n> You don't have to control the nodes initially, you just have to attack\n> the beacons once they're announced. If they're accepting new channels,\n> then they've announced an IP. If you get an exploit on a node that\n> would have been #15 in the ranking, you just have to DoS three higher\n> ranked beacons to get it to have traffic.\n\nThey're still beacons though, they're just useless.  You do need to get\na beacon then DoS enough others to force traffic though you.  That may\nbe cheaper than offering the best rates, I guess.\n\n>> Yes!  I've been wondering about this kind of \"donation address\"\n>> scenario.  Turns out you can encode the R value in the onion routed\n>> message you send, too.  Only the final recipient can read it anyway.\n>\n> Yep.\n>\n>> That doesn't help with routing to the donation address; maybe we will\n>> need a best-effort DHT for that?\n>\n> If you've got a route, but no fee information; you could probe the\n> route with nanopayments. ie, to move $10 along me->A->B->C->D, first\n> try sending 0.01c to B with a 0.1% then a 0.2% fee, etc. Once you know\n> A's fee, repeat with B, then C. If the fees end up as 1%, 2% and 0.2%\n> your successful transactions are:\n>\n>   0.01c to B plus 0.0001c to A\n>   0.01c to C plus 0.0001c to A plus 0.0002c to B\n>   0.01c to D plus 0.0001c to A plus 0.0002c to B plus 0.00002c to C\n>   $10 to D plus 10c to A plus 20c to B plus 2c to C\n>\n> and the txs that had smaller fees just bounce back to you.\n\nI was assuming the \"insufficient fees\" message would include the latest\nroute info, so it's even easier.\n\nI was more concerned about the \"there's no channel from B->C any more\".\n\n> (If probing was the main use for nanotransactions, nodes might set higher\n> fees on them though, if they assume you've already chosen a route, and\n> they therefore don't need to compete on price with other possible routes)\n\nMaybe nodes will offer some kind of routing service in future.  Seems\nlike it'd be a layer up though.\n\n>> > ie, nodes do payment forwarding; wallets just spend/recieve. You'd use\n>> > your phone as just a wallet, but you might run a node at home or in\n>> > the cloud. Wallets still do the lightning protocol themselves, they just\n>> > don't earn fees by forwarding payments.\n>> I think you do want to \n>\n> \"run a node on your phone\" ?\n>\n> In order to gain node-like return on your investment, I think you'd have\n> to be constantly active -- so updating your routes, tracking beacons,\n> etc. You'd miss out on ever being a beacon presumably, which would\n> pretty severely cut into your income to nodes that are beacons -- though\n> maybe you could sell your beacon-worthy private keys and recoup some of\n> that? I don't see how anyone would feel confident to buy your private\n> keys though.\n>\n> Your phone would need to be doing fairly constant network access while\n> it was in your pocket as it forwarded HTLCs; 24k transactions per second\n> over a million nodes at 5 non-beacon hops is still around 7 tx/minute\n> for a random node. Each of those comes with multiple crypto ops as\n> well. So you'd be burning battery afaics. If you're only doing it while\n> you're plugged into AC, then I'd expect your ROI to drop proportionately\n> (so instead of $10 from $100 over a year, maybe $3.50 if you leave your\n> phone on charge every night).\n\nConstant connectivity is getting easier.  You'd stop accepting new HTLCs\nonce you wanted to go idle.\n\n> It'd also up the latency for people routed through you a fair bit;\n> phones aren't that fast, and aren't that well connected. So any payment\n> routed over one would be that much slower than one that went via servers\n> on fibre. If you're slow to process a transaction and more likely to\n> lose connectivity, that ups the chances of an HTLC stalling -- you've\n> accepted it, but you lost connectivity while trying to forward it, so\n> everyone else is out of pocket until you get signal back.\n\nYeah, you lose a channel for that.  Could end up costing you more than\nyou'd make in profits.\n\n> Forwarding also introduces the risk that all your funds are tied up in\n> active HTLCs when you want to buy a coffee.\n>\n> I just don't think everyone running a full node trying to make a profit\n> off routing is realistic.\n\nYou're probably right; and poor nodes might help the theoretical\ndecentralization of the network while degrading overall practicality.\n\nBut phones will get better.  \n\n>> > Aside: \"mesh network\" seems to be a much better description than\n>> > hub-and-spoke... cf\n>> > https://www.reddit.com/r/Bitcoin/comments/3lo8mb/serious_question_for_blockstreamcom_will_you_let/\n>> Thanks for that: I'd somehow missed that troll.\n>\n> Seemed like a legit question to me *shrug*.\n\nIf it didn't contain a kernel of validity, it wouldn't be a troll,\nright?\n\n> There's a corresponding thread\n> (same title) on BitcoinXT, if you really want to feel trolled.\n>\n> There's also:\n>\n>   /r/lightningnetwork: The Bitcoin Lightning Network\n>\n>   This sub-reddit is dedicated to corporate interests trying to take over\n>   the decentralized world-wide ledger.\n>\n> No posts unfortunately...\n\nDamn, let me fix that...\n\n> (Caveat one: Maybe phones are so insecure there's no way to have a private\n> key that's reasonably convenient, but also \"safe\" while \"offline\". You\n> could mitigate that by introducing a second factor; having $10 on your\n> phone most of the time -- coffee and bus fare money, that you don't care\n> much if someone steals -- but having a secondary lightning wallet that\n> you can only use by tapping a crypto-NFC smartcard for when you want to\n> pay for dinner or recharge your primary wallet, eg. Having your phone\n> be secure directly would be better though)\n>\n> (Caveat two: There's no reason not to forward transactions while you're\n> online and your private keys are in memory -- err, assuming they don't\n> lock up too many funds anyway; I just think there's good reason to be\n> online as little as possible)\n\nOK, if we have a real offline mode for standard wallets, the distinction\nbecomes real.\n\n> As far as privacy goes I think you could tell which of your neighbours\n> is using lightning primarily as a wallet versus trying to be a\n> profit-generating node fairly easily: wallets will have smaller channels,\n> there'll be fewer transactions over them, and they'll disconnect more\n> often. That doesn't guarantee they're not forwarding things; but if they\n> are they're almost certainly arranging it out of band anyway (even if\n> only to know when they'll be online and thus able to forward).\n>\n> (I actually think arguing the other way might make a bit of sense; if\n> you're running a node, you should pay profits and expenses to/from an\n> entirely separate lightning wallet)\n\nI think deniability is important.  Thus I would want my wallet to\nforward payments when offered.\n\n>> > (Or going the other way; if you're making money running a node, I think\n>> > it's pretty reasonable you'll try to serve on the order of 100k users\n>> > -- much less than that and you'll be under utilising your hardware. But\n>> > with only 8B potential customers, there's a limit on the number of nodes\n>> > that can actually do that, as calculated above. I'm assuming economics\n>> > somehow ends up enforcing that limit effectively)\n>> >\n>> >> which uses hosted wallets or something?  I don't think that's very\n>> >> interesting.\n>> >\n>> > Not hosted wallets; more along the lines of SPV clients, where you're\n>> > relying on the network to do most of the work (in this case working out\n>> > a cheap route, rather than verifying txns)?\n>> But the \"give me a cheap route\" question is exactly the same whatever\n>> your role.  It's \"give me all your routes to beacons\".\n>\n> I was talking about the beacon-less alternative here, where nodes have\n> the full weighted-directed-graph of channels and fees to work out a route.\n>\n>> That's a few hundred routes.\n>\n> Also, with beacons, you don't need to know all their routes to beacons,\n> just their cheapest route to each beacon, so that should be just 12\n> routes (unless we're working with a few hundred beacons now?). No\n> matter which route from them, it'll always just be the same You<->Them\n> channel beforehand, so cheapest via them will just be that plus their\n> cheapest. You need to keep all your neighbours' cheapest routes to\n> fall back on if someone else raises fees though, if you're not willing\n> to repoll.\n\nYes, exactly.  Routes propagate proportional to number of beacons.  Even\nwith hundreds, it's still cheap.\n\nCheers,\nRusty."
            },
            {
                "author": "Amos Bairn",
                "date": "2015-09-23T04:28:06",
                "message_text_only": "The obvious problem with having the whole network use the same set of\nbeacons at the same time is that those nodes will get slammed. A possible\nsolution is to have each user pick their own set of beacons (at random),\nbut make the beacon set large enough so that any two users are likely to\nshare a few. That way the all of nodes would share the load roughly evenly.\n\nThe size needed should be something on the order of the square root of the\nnumber of nodes. Some math could be done to see what set size would be\nneeded to have a given probability of two users having an intersection of\nat least a given size.\n\nIf you went with that you wouldn't have to worry about the extra mess of\nmaking sure everyone has consensus on the official beacon set.\n\nOn Sun, Sep 20, 2015 at 7:16 PM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Hi Amos,\n>\n>    I'm delighted that someone else is thinking about routing!\n>\n> I like the information hiding features, but I don't think this will\n> scale if everyone floods the network before sending a transaction.\n>\n> I do, however, have an alternate scheme which is something of a\n> middleman, which I'd appreciate your feedback on.\n>\n> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n> the SHA of latest block hash or something).  Everyone propagates the\n> cheapest route to & from those nodes (which is pretty efficient, similar\n> to your scheme).\n>\n> To receive a payment, B picks a few beacon nodes at random and sends\n> those routes (beacons -> B) to A.  Presumably A knows its route to all\n> the beacon nodes and thus can choose the best.\n>\n> There are some twisty details here:\n>\n> 1) How many beacon nodes?\n>    12, and increase on a log scale with network size.  That size can\n>    be derived from previous beacons.\n>\n> 2) How long between selection and a beacon becoming active?\n>    10 blocks.  That gives time for others to connect to beacon node.\n>\n> 3) How long before a beacon node is invalid?\n>    No idea.  Let's keep a day's worth for the moment?\n>\n> 4) How to avoid fake beacons?\n>    Require a signature attached to an unspent bitcoin TX from before\n>    beacon selection?  That TXID is actually what competes to be close\n>    to the beacon selector.\n>\n> 5) How to update beacon routing?\n>    Particularly for fee changes, this is important.  Best effort,\n>    with ratelimiting.  I hope eventually we'll have reasonable traffic\n>    models so a node can say \"I'm going to ramp up/down my fees for\n>    this long at this rate\" and have a reasonable chance that it's true.\n>\n> Cheers,\n> Rusty.\n> PS.  For the immediate term, we'll use a global comms mechanism like\n>      IRC, but that's just a prototype hack.\n>\n> Amos Bairn <eylrid at gmail.com> writes:\n> > Here is a scheme I thought of for flood based route finding. If it can be\n> > pulled off it would allow efficient route finding while keeping the shape\n> > of the network hidden, as well as giving onion like anonymity.\n> >\n> > After writing it up a realized that it has a trivial denial of service\n> > attack, that could render it a non-starter.\n> >\n> > I'm throwing it out there anyway, because this could have significant\n> > potential if the DoS problem can be solved.\n> >\n> > https://github.com/Eylrid/ionization/blob/master/ionization.mediawiki\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150922/b759a3fd/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-25T01:53:42",
                "message_text_only": "Amos Bairn <eylrid at gmail.com> writes:\n> The obvious problem with having the whole network use the same set of\n> beacons at the same time is that those nodes will get slammed. A possible\n> solution is to have each user pick their own set of beacons (at random),\n> but make the beacon set large enough so that any two users are likely to\n> share a few. That way the all of nodes would share the load roughly evenly.\n\nThe core scaling problem is propagating current fee information (ie. the\ndynamic part of route information) across the network.  That's easy with\nagreed beacons.  Hard with random beacons.\n\nBeacons are going to get slammed, but it's not clear how bad it is.\nGetting slammed from all directions doesn't use up channels; it's only\ncomputational and bandwidth limits.\n\nTheir neighbors will want to buff up, too (they'll take some load off\nthe beacon if both parties route through them).\n\nA semi-realistic simulation would be interesting.  If payments cluster\nby geography and some random channels are established by proximity\n(ie. low latency) that may take some of load off the beacons too.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-25T05:54:06",
                "message_text_only": "On Fri, Sep 25, 2015 at 11:23:42AM +0930, Rusty Russell wrote:\n> Beacons are going to get slammed, but it's not clear how bad it is.\n> Getting slammed from all directions doesn't use up channels; it's only\n> computational and bandwidth limits.\n\nIt does actually use up channels -- if you've got 5 channels with 100 BTC\nin them collectively in total, and you own 20 BTC of that, and collect\na 0.1% fee on each transaction, you'll gain 80 BTC after 80,000 BTC are\nforwarded through you, and nobody will be able to send you funds any more.\n\nAs a beacon, you'll probably be tempted to raise your fees (you're only\ncompeting against the 11 other current beacons which you can monitor\nfairly closely), so 1% or even 2% might be realistic figures, reducing\nthe number of transactions by a factor of 10 or 20.\n\nOther nodes can fix that by opening up new channels to you, though.\n\nAs far as b/w goes, the number of beacons and they're bandwidth puts a\nlimit on the transactions per second of the lightning network: if each\nof 12 beacons have 100Mb/s bandwidth available, and use 2048B to forward\nan HTLC, then the number of HTLCs a beacon can forward per second is:\n\n  100e6/8 / 2048 = ~6100\n\nmultiplying by 12 beacons to give a maximum of around ~73k lightning\ntransactions per second; which is about the same as the VisaNet stress\ntests (56k tps), which seems too low to me if you want micropayments.\n\n> Their neighbors will want to buff up, too (they'll take some load off\n> the beacon if both parties route through them).\n\n(In the event that someone suggests a route beacon_X -> X -> Y -> Z to\nget to them, and you have a path A -> C -> X -> beacon_X, you can cut out\nthe middleman and not route through a beacon at all. I don't think this\ngives much of an improvement though. A beacon could potentially avoid\nthis from being possible by partitioning its neighbours into two sets\nand setting incoming fees for one set prohibitively high, and outgoing\nfees to the other set as prohibitively high; managing that dynamically\nwould be difficult but I think possible)\n\n> A semi-realistic simulation would be interesting.  If payments cluster\n> by geography and some random channels are established by proximity\n> (ie. low latency) that may take some of load off the beacons too.\n\nI think routing by proximity cuts out some of the benefits of onion\nrouting; you just end up with locals conncting to their local banks,\nand paying locals directly via their bank, and the bank being able to\ndirectly correlate payments (or two banks being able to collaborate to\ncorrelate sender and recipient).\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-27T05:42:56",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Sep 25, 2015 at 11:23:42AM +0930, Rusty Russell wrote:\n>> Beacons are going to get slammed, but it's not clear how bad it is.\n>> Getting slammed from all directions doesn't use up channels; it's only\n>> computational and bandwidth limits.\n>\n> It does actually use up channels -- if you've got 5 channels with 100 BTC\n> in them collectively in total, and you own 20 BTC of that, and collect\n> a 0.1% fee on each transaction, you'll gain 80 BTC after 80,000 BTC are\n> forwarded through you, and nobody will be able to send you funds any more.\n\nThat's a great insight!  Fees *do* erode channels.  I had totally missed\nthat.\n\n> As a beacon, you'll probably be tempted to raise your fees (you're only\n> competing against the 11 other current beacons which you can monitor\n> fairly closely), so 1% or even 2% might be realistic figures, reducing\n> the number of transactions by a factor of 10 or 20.\n>\n> Other nodes can fix that by opening up new channels to you, though.\n>\n> As far as b/w goes, the number of beacons and they're bandwidth puts a\n> limit on the transactions per second of the lightning network: if each\n> of 12 beacons have 100Mb/s bandwidth available, and use 2048B to forward\n> an HTLC, then the number of HTLCs a beacon can forward per second is:\n>\n>   100e6/8 / 2048 = ~6100\n>\n> multiplying by 12 beacons to give a maximum of around ~73k lightning\n> transactions per second; which is about the same as the VisaNet stress\n> tests (56k tps), which seems too low to me if you want micropayments.\n\nIt is.  You definitely want to increase the number of beacons with\nnetwork size.\n\n>> Their neighbors will want to buff up, too (they'll take some load off\n>> the beacon if both parties route through them).\n>\n> (In the event that someone suggests a route beacon_X -> X -> Y -> Z to\n> get to them, and you have a path A -> C -> X -> beacon_X, you can cut out\n> the middleman and not route through a beacon at all. I don't think this\n> gives much of an improvement though. A beacon could potentially avoid\n> this from being possible by partitioning its neighbours into two sets\n> and setting incoming fees for one set prohibitively high, and outgoing\n> fees to the other set as prohibitively high; managing that dynamically\n> would be difficult but I think possible)\n\nBut you'd risk not being used as a beacon if your fees are too high.  It\nseems to me that a beacon wants many connections, to avoid the\n\"short-circuit\" case.  At 100 connections, it's only 1%, though\nthat's the best case which assumes they're all equally likely.\n\n>> A semi-realistic simulation would be interesting.  If payments cluster\n>> by geography and some random channels are established by proximity\n>> (ie. low latency) that may take some of load off the beacons too.\n>\n> I think routing by proximity cuts out some of the benefits of onion\n> routing; you just end up with locals conncting to their local banks,\n> and paying locals directly via their bank, and the bank being able to\n> directly correlate payments (or two banks being able to collaborate to\n> correlate sender and recipient).\n\nGood points.  If we reject all routes less than (say) 3 hops by default\nit might mean that local payments are *less* efficient.  Oops.\n\nI'll think harder on this...\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-21T07:12:42",
                "message_text_only": "On Sat, Sep 19, 2015 at 01:13:03PM -0700, Amos Bairn wrote:\n> https://github.com/Eylrid/ionization/blob/master/ionization.mediawiki\n\nEven assuming nodes are honest, afaics you could discover the shape of\nthe network simply by doing lots of probes with k1/h1, but never actually\nsend the k2/h2 transactions through (\"oh, it's always too expensive\").\n\nCheers,\naj"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-09-21T14:06:32",
                "message_text_only": "> On Mon, Sep 21, 2015 at 11:46:13AM +0930, Rusty Russell wrote:\n>> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n>> the SHA of latest block hash or something).  Everyone propagates the\n>> cheapest route to & from those nodes (which is pretty efficient, similar\n>> to your scheme).\n\nI don't know, using the beacon kind of technique does seem a little\nbit cumbersome and you really have to think about a lot of possible\nattacks that might render the whole network unusable, because all\nbeacons are maliciously sabotaging the network..\n\n\n> If you do know the entire graph, you don't need to give away any\n> information about who you want to pay prior to sending the transaction.\n> Knowing the graph is potentially interesting for commercial and academic\n> reasons beyond wanting privacy. (Knowing the fees others charge helps you\n> work out what fees you should charge; but just querying your neighbours'\n> routes is probably sufficient to work that out too)\n\nI initially thought about going with a Node Directory. That is, a\ncentral server collecting the routing data that could be sent there by\nchoice. We can work out with signature and if both nodes submit the\nroute towards the other node, whether this is indeed correct. But as\nthis isn't too much data in the first place, I am very much in favour\nof just using some gossip-protocol. Furthermore, we can also include\nsome byte for a reputation / web-of-trust system. It is completely\noptional, if you are able to figure out how to route the payment\nacross your nodes you are not forced to use this system, and I don't\nthink it will have severe privacy problems.\n\nPayer and payee can further work out a rendezvous node. The payee will\nsend the encrypted routing data from that node on to himself and the\npayer can build the rest of the routing from his viewpoint.\n\nHaving this data distributed really allows for making payments without\nleaving too many visible traces on the network.\n\nI would also spread data about how much can be spent and received with\nthis route and fees for receiving and spending. Again, this data can\nbe very vague and does not need to reflect the real world. You can say\nyou support payments up to 10k satoshis, even though the channel has\n5BTC in it.\n\nIs there any plan how we handle connections currently? I am thinking\nabout sending the current IP address with this update, such that nodes\ncan connect to each other after one broke down again, and it would\nfurther support dynamic IPs as well. Could be possible to extend this\nto hidden service notation, although this would need some more bytes\nto store.\n\nThe protocol on my side does look like this currently:\n\nGeneral beacon for our node\n - pubkey [32]\n - timestamp [4]\n - IP/connectionDetails [8+...]\n - signature [70]\n\nRouting information\n - pubkey_from_us [32]\n - pubkey_from_you [32]\n - fee_sending [4]\n - max_sending [4]\n - current_reputation [1]\n - timestamp [4]\n - signature [70]\n\nThese two would be spread as one message.\nThis allows to keep two separate databases, and be able to bootstrap\nnew nodes with this information, while we do not have to store old\nbeacon data.\nAs reputation will be stored for quite some time, we should really\nsave them with separate signatures. (This will make it more difficult\n/ costly to share the complete database with new nodes, and we need to\nstore old data (reputation should be stored for some time) to validate\nthe signatures.\n\nI was calculating with two updates a day, but only 100k nodes. Each\nnode would make a connection to around 10 other nodes, resulting in\n114+10*147 = 1.5kB per update. Each node would only use around 3kb/s\nup/down and would do around 3 signature verifications per second in\nidle mode, while allowing everyone a full copy of the routing. Making\nsure messages spread efficiently is another problem, as we have so\nmany tiny messages. Storing the hashes you received in a bloom table\nand asking other peers if they want to receive it as well does work,\nbut just the hashes of all messages do add up already..\n\nIn the end, the nodes themselves don't really need the routing\ninformation, we just need a way to transport the information to the\nclients that make payments. Nodes will just stupidly obey the orders\ngiven in the blob of data they'll receive.\n\nThis design opens up for some DDoS attacks, as we don't want other\nnodes to just spam information all day long that would be relayed\nthrough the complete network. Furthermore, one attacker can just\nemulate a complete network that is vouching for him, and he can use\nthose 'nodes' to push spam through the network as well. This does\nscrew a little bit with the reputation system, but I think it would be\npossible to detect a cluster of nodes that is only connected to the\nrest of the network through that one attacker (some graph theory I\nguess). Furthermore, we can check nodes by pinging them randomly, and\ndropping any reputation if we cannot reach them.\n\nMats Jerratsch"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-23T04:59:00",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n>> On Mon, Sep 21, 2015 at 11:46:13AM +0930, Rusty Russell wrote:\n>>> We regularly choose a dozen \"beacon\" nodes at random (using proximity to\n>>> the SHA of latest block hash or something).  Everyone propagates the\n>>> cheapest route to & from those nodes (which is pretty efficient, similar\n>>> to your scheme).\n>\n> I don't know, using the beacon kind of technique does seem a little\n> bit cumbersome and you really have to think about a lot of possible\n> attacks that might render the whole network unusable, because all\n> beacons are maliciously sabotaging the network..\n\nIndeed.  Random selection helps, here, but analysis will be interesting.\n\n>> If you do know the entire graph, you don't need to give away any\n>> information about who you want to pay prior to sending the transaction.\n>> Knowing the graph is potentially interesting for commercial and academic\n>> reasons beyond wanting privacy. (Knowing the fees others charge helps you\n>> work out what fees you should charge; but just querying your neighbours'\n>> routes is probably sufficient to work that out too)\n>\n> I initially thought about going with a Node Directory. That is, a\n> central server collecting the routing data that could be sent there by\n> choice. We can work out with signature and if both nodes submit the\n> route towards the other node, whether this is indeed correct. But as\n> this isn't too much data in the first place, I am very much in favour\n> of just using some gossip-protocol.\n\nShort term I'm thinking we'll have an IRC channel (a-la early bitcoin)\nand everyone will advertise their channels there.  This is design for\nthe next, more ambitious phase.\n\n> Furthermore, we can also include\n> some byte for a reputation / web-of-trust system. It is completely\n> optional, if you are able to figure out how to route the payment\n> across your nodes you are not forced to use this system, and I don't\n> think it will have severe privacy problems.\n\nI think reputation systems will become an overlay, if the basic system\nproves vulnerable.  It's nicer if we don't have to though, as reputation\nis both hard to encode in normal behaviour, and deeply centralizing.\n\n> Payer and payee can further work out a rendezvous node. The payee will\n> send the encrypted routing data from that node on to himself and the\n> payer can build the rest of the routing from his viewpoint.\n\nYes, like R hash and destination node, you'd send some\nroutes-from-nodes for one or more rendezvous.\n\nThe advantage of this system is that it's less revealing, even if you\nhave to ask how to get to those.\n\n> Having this data distributed really allows for making payments without\n> leaving too many visible traces on the network.\n>\n> I would also spread data about how much can be spent and received with\n> this route and fees for receiving and spending. Again, this data can\n> be very vague and does not need to reflect the real world. You can say\n> you support payments up to 10k satoshis, even though the channel has\n> 5BTC in it.\n\nMy basic model for fees is base + percentage.  AJ has been thinking\nharder about exactly how a node would set these...\n\n> Is there any plan how we handle connections currently? I am thinking\n> about sending the current IP address with this update, such that nodes\n> can connect to each other after one broke down again, and it would\n> further support dynamic IPs as well. Could be possible to extend this\n> to hidden service notation, although this would need some more bytes\n> to store.\n\nSo, I'm assuming the basic network comms is organized along channel\nlines; you have to communicate to the other end of the channel anyway,\nso that makes sense.\n\nThis doesn't solve \"how do I connect to the network\" or \"how do I start\na channel with this particular node\", though.  For that, I've floated\nthe idea of reusing the bittorrent DHT, which has extensions to allow\njust this.\n\n> The protocol on my side does look like this currently:\n>\n> General beacon for our node\n>  - pubkey [32]\n>  - timestamp [4]\n>  - IP/connectionDetails [8+...]\n>  - signature [70]\n\nYep, makes sense.  Pubkey is usually 33 bytes, BTW.\n\nYou can squeze some more bytes out of you want:\n1) Signature should be 64 bytes (never DER encode).\n2) Pubkey can be hashed bitcoin-address style, and recovered from sig.\n\n> Routing information\n>  - pubkey_from_us [32]\n>  - pubkey_from_you [32]\n>  - fee_sending [4]\n>  - max_sending [4]\n>  - current_reputation [1]\n>  - timestamp [4]\n>  - signature [70]\n\nIf we're using protobufs, they're extensible, so you can add reputation\nlater if we need it.\n\nYou also want two signatures, I think: one from each side.  Though it\nmakes sense to have a separate teardown message which only needs one\nsig.\n\n> These two would be spread as one message.\n> This allows to keep two separate databases, and be able to bootstrap\n> new nodes with this information, while we do not have to store old\n> beacon data.\n\n> As reputation will be stored for quite some time, we should really\n> save them with separate signatures. (This will make it more difficult\n> / costly to share the complete database with new nodes, and we need to\n> store old data (reputation should be stored for some time) to validate\n> the signatures.\n\nUnclear what reputation means, here?\n\n> I was calculating with two updates a day, but only 100k nodes. Each\n> node would make a connection to around 10 other nodes, resulting in\n> 114+10*147 = 1.5kB per update. Each node would only use around 3kb/s\n> up/down and would do around 3 signature verifications per second in\n> idle mode, while allowing everyone a full copy of the routing. Making\n> sure messages spread efficiently is another problem, as we have so\n> many tiny messages. Storing the hashes you received in a bloom table\n> and asking other peers if they want to receive it as well does work,\n> but just the hashes of all messages do add up already..\n>\n> In the end, the nodes themselves don't really need the routing\n> information, we just need a way to transport the information to the\n> clients that make payments. Nodes will just stupidly obey the orders\n> given in the blob of data they'll receive.\n\nBTW I've not been separating nodes and clients in my head-design.  Of\ncourse, some nodes might not ever generate payments, and some nodes\nmight never route others' payments, but it increases privacy vastly if\nthey *can*, so I'm trying to think about them that way.\n\n> This design opens up for some DDoS attacks, as we don't want other\n> nodes to just spam information all day long that would be relayed\n> through the complete network. Furthermore, one attacker can just\n> emulate a complete network that is vouching for him, and he can use\n> those 'nodes' to push spam through the network as well. This does\n> screw a little bit with the reputation system, but I think it would be\n> possible to detect a cluster of nodes that is only connected to the\n> rest of the network through that one attacker (some graph theory I\n> guess). Furthermore, we can check nodes by pinging them randomly, and\n> dropping any reputation if we cannot reach them.\n\nYes, reputation is hard.\n\nWhat do you think about the idea of using the anchor transactions in the\nblockchain as a map of the network?  You could use an OP_RETURN to stash\ntwo pubkeysx, that is the two node IDs.\n\nCheers,\nRusty."
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-09-23T07:56:08",
                "message_text_only": "> Indeed.  Random selection helps, here, but analysis will be interesting.\nHow have you ended up with a number of beacons you need? 12 seems so low, I can\u2019t imagine so few nodes to support all transacting for even 10 minutes.. And it\u2019s very difficult to estimate how much bitcoin they might need for that timeframe, as some people might want to transact only few satoshi, while others send multiple bitcoin. We can abstract the network towards two nodes at each end and N beacon nodes in the middle doing all the transacting. The two nodes at either side are separate networks then, which need to figure out their own routing.\n\nFurthermore, I don\u2019t really see the big advantage in this scheme. We still need to find a route towards these beacons, and often one might not be interested in the cheapest one, but would want to add more privacy. I think propagating the node-map is pretty efficient in general\u2026 \n\n> Short term I'm thinking we'll have an IRC channel (a-la early bitcoin)\n> and everyone will advertise their channels there.  This is design for\n> the next, more ambitious phase.\n\nHm I think this would be a wasted effort. While there are probably good libraries to do the job out there, it would still need some implementation. As soon as we can solve the node discovery (and if we want to go with a central server, we might just as well hard-code some reliable nodes into the code for now), we can communicate over the network..\n\n> \n>> Furthermore, we can also include\n>> some byte for a reputation / web-of-trust system. It is completely\n>> optional, if you are able to figure out how to route the payment\n>> across your nodes you are not forced to use this system, and I don't\n>> think it will have severe privacy problems.\n> \n> I think reputation systems will become an overlay, if the basic system\n> proves vulnerable.  It's nicer if we don't have to though, as reputation\n> is both hard to encode in normal behaviour, and deeply centralizing.\n\nYea centralisation is an issue with reputation, we might want to have it rather limited. Have it some way, such that there isn\u2019t much difference between a big node that has been around for long and a relatively new node, as long as both are \n(1) low latency\n(2) highly available\n(3) honest.\n\n>> Is there any plan how we handle connections currently? I am thinking\n>> about sending the current IP address with this update, such that nodes\n>> can connect to each other after one broke down again, and it would\n>> further support dynamic IPs as well. Could be possible to extend this\n>> to hidden service notation, although this would need some more bytes\n>> to store.\n> \n> So, I'm assuming the basic network comms is organized along channel\n> lines; you have to communicate to the other end of the channel anyway,\n> so that makes sense.\n> \n> This doesn't solve \"how do I connect to the network\" or \"how do I start\n> a channel with this particular node\", though.  For that, I've floated\n> the idea of reusing the bittorrent DHT, which has extensions to allow\n> just this.\n\nYea exactly, we can squeeze these information in there. The packages are very small. If we end up in a situation where they impede the payment transactions, we might want to have some priority mechanism..\n\nThe \u2018how to connect to the network\u2019 can be solved with basic peer discovery schemes, like IRC or stable-nodes. Having received the topology of the mesh, you can decide which nodes you want to create a channel with (maybe we should add a flag somewhere, whether this node wants to open a channel with strangers and under which conditions). He can directly connect to that node and open a channel with him, or am I missing something? \n\n> You can squeze some more bytes out of you want:\n> 1) Signature should be 64 bytes (never DER encode).\n> 2) Pubkey can be hashed bitcoin-address style, and recovered from sig.\n\nYou can recover the pubkey from the hash and the sig? Why are we putting the pubkey in the scriptSig then? ;)\n\n> If we're using protobufs, they're extensible, so you can add reputation\n> later if we need it.\n> \n> You also want two signatures, I think: one from each side.  Though it\n> makes sense to have a separate teardown message which only needs one\n> sig.\n\nYea was thinking about this as well, I thought as both nodes will propagate their own message, other nodes can puzzle it out, whether the channel has been confirmed by both parties. It saves one signature too.. \n\n> \n>> These two would be spread as one message.\n>> This allows to keep two separate databases, and be able to bootstrap\n>> new nodes with this information, while we do not have to store old\n>> beacon data.\n> \n>> As reputation will be stored for quite some time, we should really\n>> save them with separate signatures. (This will make it more difficult\n>> / costly to share the complete database with new nodes, and we need to\n>> store old data (reputation should be stored for some time) to validate\n>> the signatures.\n> \n> Unclear what reputation means, here?\n\nI was thinking about storing reputation for some time for all nodes. I\u2019m not sure this is a good idea anymore, as it may lead to some amount of centralization.. It would be beneficial in this case to have the reputation data along with the signature only, to be efficient. That way you can always recover the reputation data of all nodes of the network for a new node, as you can send along all signatures..\n\n> BTW I've not been separating nodes and clients in my head-design.  Of\n> course, some nodes might not ever generate payments, and some nodes\n> might never route others' payments, but it increases privacy vastly if\n> they *can*, so I'm trying to think about them that way.\n\nFor me it is more a connection issue. Nodes should have a 99+% uptime and allow for direct incoming connections. Still have to figure it out, but of course as a node provider you can always issue a payment directly (I think for any outsider, there is no difference between the node issuing the payment or some client connected to that node)\n\n> Yes, reputation is hard.\n> \n> What do you think about the idea of using the anchor transactions in the\n> blockchain as a map of the network?  You could use an OP_RETURN to stash\n> two pubkeysx, that is the two node IDs.\n\nHm isn\u2019t this difficult to prove? Anyone could have put those pubkeys in there, so unless we further put a signature in there, this information holds little value I think.. I like the idea in general, as it would make fake-nodes more difficult, but I think it is difficult to implement in the bitcoin blockchain. Furthermore, how do you plan to have the scriptPubKey for the anchor tx then? Ultimately it is still P2SH, so no one is really able to recover any data from it..\n\n\nAs a plus, I am currently working on some simulation project for lightning. A lot of the metrics are very difficult to estimate (let alone calculate), and often we want to depend on random selection. We will be able to deduct a lot of properties from it, and be able to determine, whether we need something like the reputation system at all, and how many dishonest nodes it takes for some attacks, and how efficient routing is, all the good stuff...\n\nCheers,\nMats\n\nPS.: This was the last time I opened a new thread incidentally -.- Just disabled the digest option\u2026 ;) Sorry for the inconvenience..."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-25T00:26:02",
                "message_text_only": "[ Pieter Wuille Cc'd for pubkey recovery, search for \"recovered\" ]\n\nMats Jerratsch <matsjj at gmail.com> writes:\n>> Indeed.  Random selection helps, here, but analysis will be interesting.\n\n> How have you ended up with a number of beacons you need? 12 seems so\n> low, I can\u2019t imagine so few nodes to support all transacting for even\n> 10 minutes..\n\nAs we keep the last 100 sets of beacons, the load is spread a little.\nAnd remember that the network rebalances; too many transfers in one\ndirection and it becomes cheaper to send funds in the other direction.\nIt's unclear how bad it will be.\n\n> And it\u2019s very difficult to estimate how much bitcoin they\n> might need for that timeframe, as some people might want to transact\n> only few satoshi, while others send multiple bitcoin.\n\nTrue.  I assume if we build it they will come.  But what will the come\nwith?\n\n> We can abstract\n> the network towards two nodes at each end and N beacon nodes in the\n> middle doing all the transacting. The two nodes at either side are\n> separate networks then, which need to figure out their own routing.\n\nIndeed, but it's efficient.  \n\n> Furthermore, I don\u2019t really see the big advantage in this scheme. We\n> still need to find a route towards these beacons, and often one might\n> not be interested in the cheapest one, but would want to add more\n> privacy. I think propagating the node-map is pretty efficient in\n> general\u2026\n\nIt's not the node map (which is pretty static; we've even discussed\nmaking the on-chain anchor transactions be the map), it's the continuous\nfee updates.\n\n>> Short term I'm thinking we'll have an IRC channel (a-la early bitcoin)\n>> and everyone will advertise their channels there.  This is design for\n>> the next, more ambitious phase.\n>\n> Hm I think this would be a wasted effort. While there are probably good libraries to do the job out there, it would still need some implementation. As soon as we can solve the node discovery (and if we want to go with a central server, we might just as well hard-code some reliable nodes into the code for now), we can communicate over the network..\n\nAs you note below, we can use IRC for the node discovery too.  If we\njust have an IRC channel where you send all your routes, we get both.\n\nThat lets us design something real, while we work on getting the rest\nstable.\n\n>>> Furthermore, we can also include\n>>> some byte for a reputation / web-of-trust system. It is completely\n>>> optional, if you are able to figure out how to route the payment\n>>> across your nodes you are not forced to use this system, and I don't\n>>> think it will have severe privacy problems.\n>> \n>> I think reputation systems will become an overlay, if the basic system\n>> proves vulnerable.  It's nicer if we don't have to though, as reputation\n>> is both hard to encode in normal behaviour, and deeply centralizing.\n>\n> Yea centralisation is an issue with reputation, we might want to have it rather limited. Have it some way, such that there isn\u2019t much difference between a big node that has been around for long and a relatively new node, as long as both are \n> (1) low latency\n> (2) highly available\n> (3) honest.\n\n(1) can be measured, (2) can be intuited over time, but I have no idea\nhow to measure (3) :(\n\n>>> Is there any plan how we handle connections currently? I am thinking\n>>> about sending the current IP address with this update, such that nodes\n>>> can connect to each other after one broke down again, and it would\n>>> further support dynamic IPs as well. Could be possible to extend this\n>>> to hidden service notation, although this would need some more bytes\n>>> to store.\n>> \n>> So, I'm assuming the basic network comms is organized along channel\n>> lines; you have to communicate to the other end of the channel anyway,\n>> so that makes sense.\n>> \n>> This doesn't solve \"how do I connect to the network\" or \"how do I start\n>> a channel with this particular node\", though.  For that, I've floated\n>> the idea of reusing the bittorrent DHT, which has extensions to allow\n>> just this.\n>\n> Yea exactly, we can squeeze these information in there. The packages\n> are very small. If we end up in a situation where they impede the\n> payment transactions, we might want to have some priority mechanism..\n\nYes, and it's proven and robust in practice.  It's also possible\nthat by adding nodes to the BT DHT we help robustness for everyone.\n\n> The \u2018how to connect to the network\u2019 can be solved with basic peer\n> discovery schemes, like IRC or stable-nodes. Having received the\n> topology of the mesh, you can decide which nodes you want to create a\n> channel with (maybe we should add a flag somewhere, whether this node\n> wants to open a channel with strangers and under which conditions). He\n> can directly connect to that node and open a channel with him, or am I\n> missing something?\n\nTo start, I was thinking you establish channels with 5 random nodes.\nLater, we'll probably want something more sophisticated, like 2 nearby\nnodes (low ping time), and 3 random nodes.  Close nodes make sense\nbecause payments also cluster along geographic lines.  Random nodes make\nsense for network robustness.  Over time, you might open a channel to a\nnode you end up using regularly; there's heaps of fun heuritics to be\ndeveloped here!\n\nI assumed that advertising an address would be optional; so if you don't\nwant incoming connections, don't advertise.\n\n>> You can squeze some more bytes out of you want:\n>> 1) Signature should be 64 bytes (never DER encode).\n>> 2) Pubkey can be hashed bitcoin-address style, and recovered from sig.\n>\n> You can recover the pubkey from the hash and the sig? Why are we putting the pubkey in the scriptSig then? ;)\n\nBecause crypto is hard :(\n\nTBH I only learned a few months ago that you can do this.\n\nIt helps if you have the (two-bit) recovery id, but you can brute force\nit AFAICT.  You then check if the pubkey matches the hash you're given.\n\n>> If we're using protobufs, they're extensible, so you can add reputation\n>> later if we need it.\n>> \n>> You also want two signatures, I think: one from each side.  Though it\n>> makes sense to have a separate teardown message which only needs one\n>> sig.\n>\n> Yea was thinking about this as well, I thought as both nodes will propagate their own message, other nodes can puzzle it out, whether the channel has been confirmed by both parties. It saves one signature too.. \n\nOr, in other words, they propagate almost twice as much data :)\n\n>> Unclear what reputation means, here?\n>\n> I was thinking about storing reputation for some time for all\n> nodes. I\u2019m not sure this is a good idea anymore, as it may lead to\n> some amount of centralization.. It would be beneficial in this case to\n> have the reputation data along with the signature only, to be\n> efficient. That way you can always recover the reputation data of all\n> nodes of the network for a new node, as you can send along all\n> signatures..\n\nYou need to flesh out how reputation is built and destroyed.  Does\nsomeone with sufficient reputation complain about someone else?\n\nEvery time I tried to build a reputation system my head hurt :(\n\n>> BTW I've not been separating nodes and clients in my head-design.  Of\n>> course, some nodes might not ever generate payments, and some nodes\n>> might never route others' payments, but it increases privacy vastly if\n>> they *can*, so I'm trying to think about them that way.\n>\n> For me it is more a connection issue. Nodes should have a 99+% uptime\n> and allow for direct incoming connections. Still have to figure it\n> out, but of course as a node provider you can always issue a payment\n> directly (I think for any outsider, there is no difference between the\n> node issuing the payment or some client connected to that node)\n\nYes, and eventually we end up bridging to other networks, so you really\ncan't tell.\n\nA weird property is that it's only mildly bad to be unreachable (stuff\njust bounced back for re-routing), as long as you don't go unreachable\nwith HTLCs outstanding.  The latter will cause people to drop channels\nto you.\n\n>> What do you think about the idea of using the anchor transactions in the\n>> blockchain as a map of the network?  You could use an OP_RETURN to stash\n>> two pubkeysx, that is the two node IDs.\n>\n> Hm isn\u2019t this difficult to prove? Anyone could have put those pubkeys\n> in there, so unless we further put a signature in there, this\n> information holds little value I think..\n\nYeah, good point!  We can't fit key+sig in 80 bytes, either.  Need to do\nsomething less dumb if we go that route...\n\n> I like the idea in general,\n> as it would make fake-nodes more difficult, but I think it is\n> difficult to implement in the bitcoin blockchain.\n\nI think I'm uncomfortable because I've tried to err on the side of\nreleasing as little info as possible.\n\n> Furthermore, how do\n> you plan to have the scriptPubKey for the anchor tx then? Ultimately\n> it is still P2SH, so no one is really able to recover any data from\n> it..\n\nWe could actually make this one non-P2SH, since multisig is standard.\nThat would imply that the address there is the node id.\n\n> As a plus, I am currently working on some simulation project for\n> lightning. A lot of the metrics are very difficult to estimate (let\n> alone calculate), and often we want to depend on random selection. We\n> will be able to deduct a lot of properties from it, and be able to\n> determine, whether we need something like the reputation system at\n> all, and how many dishonest nodes it takes for some attacks, and how\n> efficient routing is, all the good stuff...\n\nGreat!  BTW my mental goalpost is 1M nodes.  More than that is still\ninteresting, but probably only realistic once we have more/real data.\n\n> Cheers,\n> Mats\n>\n> PS.: This was the last time I opened a new thread incidentally -.- Just disabled the digest option\u2026 ;) Sorry for the inconvenience...\n\nHeh, that's fine.  You get a free pass when you've got such\ninformation-dense mails :)\n\nThanks!\nRusty."
            },
            {
                "author": "Pieter Wuille",
                "date": "2015-09-25T03:38:59",
                "message_text_only": "On Sep 25, 2015 3:09 AM, \"Rusty Russell\" wrote:\n> >> You can squeze some more bytes out of you want:\n> >> 1) Signature should be 64 bytes (never DER encode).\n> >> 2) Pubkey can be hashed bitcoin-address style, and recovered from sig.\n> >\n> > You can recover the pubkey from the hash and the sig? Why are we\nputting the pubkey in the scriptSig then? ;)\n>\n> Because crypto is hard :(\n>\n> TBH I only learned a few months ago that you can do this.\n>\n> It helps if you have the (two-bit) recovery id, but you can brute force\n> it AFAICT.  You then check if the pubkey matches the hash you're given.\n\nYou can indeed do public key recovery om ECDSA, and you can brute force the\nrecovery id. In all non-pathological cases, the recovery id will be 0 or 1;\nonly one in about 2^128 randomly generated signatures need 2 or 3.\n\nI don't have much context here, but is there a need for this to be ECDSA?\nIf not, the EC-Schnorr scheme in libsecp256k1 produces 64-byte\nnon-malleable signatures that support pubkey recovery without an additional\nrecovery id, and are compatible with the same private/public keys. The\nscheme is certainly non-standard and experimental at this point, but it's\nan instance of a well researched mechanism.\n\n-- \nPieter\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150925/02de7137/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-25T05:08:36",
                "message_text_only": "On Fri, Sep 25, 2015 at 09:56:02AM +0930, Rusty Russell wrote:\n> [ Pieter Wuille Cc'd for pubkey recovery, search for \"recovered\" ]\n> Mats Jerratsch <matsjj at gmail.com> writes:\n> >> Indeed.  Random selection helps, here, but analysis will be interesting.\n> > How have you ended up with a number of beacons you need? 12 seems so\n> > low, I can\u2019t imagine so few nodes to support all transacting for even\n> > 10 minutes..\n> As we keep the last 100 sets of beacons, the load is spread a little.\n\nDoes that actually work? Old beacons don't do any good if the payee\ndoesn't use them when advertising a route; but old beacons also don't\nget their fee updates propogated, and aren't known by people who only\njust joined the network. I don't think you could usefully keep more than\nthe last 2 or 3 sets of beacons?\n\n> To start, I was thinking you establish channels with 5 random nodes.\n\nI think Barabasi-Albert graphs are probably pretty reasonable here --\nyou start by establishing channels to N nodes, selected randomly but\nfavouring nodes in proportion to how connected they already are.\n\nhttps://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-27T04:24:45",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Fri, Sep 25, 2015 at 09:56:02AM +0930, Rusty Russell wrote:\n>> [ Pieter Wuille Cc'd for pubkey recovery, search for \"recovered\" ]\n>> Mats Jerratsch <matsjj at gmail.com> writes:\n>> >> Indeed.  Random selection helps, here, but analysis will be interesting.\n>> > How have you ended up with a number of beacons you need? 12 seems so\n>> > low, I can\u2019t imagine so few nodes to support all transacting for even\n>> > 10 minutes..\n>> As we keep the last 100 sets of beacons, the load is spread a little.\n>\n> Does that actually work? Old beacons don't do any good if the payee\n> doesn't use them when advertising a route; but old beacons also don't\n> get their fee updates propogated, and aren't known by people who only\n> just joined the network. I don't think you could usefully keep more than\n> the last 2 or 3 sets of beacons?\n\nI was thinking they all count as active.  No point turning over all the\nbeacons every block.\n\n>> To start, I was thinking you establish channels with 5 random nodes.\n>\n> I think Barabasi-Albert graphs are probably pretty reasonable here --\n> you start by establishing channels to N nodes, selected randomly but\n> favouring nodes in proportion to how connected they already are.\n>\n> https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model\n\nInteresting.  If we assume growth only (as I suggested) we end up with a\ngeometric distribution (as backed by Section 5 of\nhttp://www.e-publications.org/ims/submission/index.php/BEJ/user/submissionFile/10315?confirm=c40442a0\n).\n\nIt's not clear to me (without reading the paper) how much attachment\nbias is required for a power law to apply, however.  Larger nodes may be\nincentivized (through profit) to have better uptime, leading to a slight\nattachment bias.  Definitely second order.\n\nIt's not clear that we want a power law: do we?\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-28T10:37:19",
                "message_text_only": "Batch-replying.\n\nOn Sun, Sep 27, 2015 at 01:54:45PM +0930, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On Fri, Sep 25, 2015 at 09:56:02AM +0930, Rusty Russell wrote:\n> >> [ Pieter Wuille Cc'd for pubkey recovery, search for \"recovered\" ]\n> >> Mats Jerratsch <matsjj at gmail.com> writes:\n> >> >> Indeed.  Random selection helps, here, but analysis will be interesting.\n> >> > How have you ended up with a number of beacons you need? 12 seems so\n> >> > low, I can\u2019t imagine so few nodes to support all transacting for even\n> >> > 10 minutes..\n> >> As we keep the last 100 sets of beacons, the load is spread a little.\n> > Does that actually work? Old beacons don't do any good if the payee\n> > doesn't use them when advertising a route; but old beacons also don't\n> > get their fee updates propogated, and aren't known by people who only\n> > just joined the network. I don't think you could usefully keep more than\n> > the last 2 or 3 sets of beacons?\n> I was thinking they all count as active.  No point turning over all the\n> beacons every block.\n\nOkay, in that case I was misled by your original description. You're\nactually talking about n*k beacons at any point in time, of which the\noldest k are replaced every d days. If k=12 and n=8, that gives 96 beacons\nat any point in time. Any given beacon is operation for n*d days, for n=8,\nthen d=1 gives 8 days, while d=7 gives 2 months.\n\nThe \"d\" parameter would be \"consensus-critical\"; I don't think it's\npossible to agree on any beacons without agreeing on d. You could vary k\nor n as the network scales though, but in that case I think it'd generally\nbe easier to vary n than k?\n\nIf you identify a given beacon by its cohort (from 1..n), its rank\n(1..k), its visibility (how long ago you first heard about it in\nseconds) and its currency (how recently the last route update to that\nbeacon was), then I think the odds of a random other node also knowing\nabout that beacon works out as:\n\n - worse for the most recent cohort (older cohorts should have more fully\n   propogated)\n\n - potentially worse for the very oldest cohorts\n    + if being a beacon wears you out (channels may have been used\n      up; they may have been hacked; they may have cashed out their\n      profits and bought an island)\n    + if nodes have varying settings for n, so older cohorts don't have\n      as effective route propagation\n\n - worse for recent visibility (newly advertising beacon, that hadn't\n   fully propagated, same deal as for a new cohort)\n\n - worse for non-recent currency (beacon might be offline, or routes to\n   that beacon might have failed)\n\n - worse for low rank in recent cohorts (new beacons shouldn't show up\n   for old cohorts; if new beacons show up in recent cohorts, its the\n   low rank beacons that will be offloaded)\n\n - worse for low rank in any cohort if other nodes have lower values for\n   k\n\nWhen picking beacons to advertise for accepting a payment, I think you'd\nwant to take most of the above into account, to avoid only suggesting\ncoincidently unreachable beacons, and having the payment fail.\n\nI don't think you could really take route price into account, since the\nreal price is \"consumer to beacon\" plus \"beacon to merchant\"; and those\ncould trivially be inversely related. Having 10%-30% of your suggestions\nbe selected by cheapness would still be useful though.\n\nChoosing, say, two of the cheapest beacons, and three beacons from\ncohorts 3-n with recent currency and long term visibility would probably\nwork okay though.\n\nIf nodes are identified by a 160b address, and it takes around 4 hops\nto get to/from a random beacon, then a route is 4*160b=80B and five\nroutes as above is 400B. That's ~550 bytes with base58\nencoding by my count, or about 7 lines of 76 column text. Kinda lame:\n\n\"please pay to 1ajaj31PWNVZEzd68S8PqAPof4EFbeZaf via lightning route:\n5PSGzi9R6k6G2mdFPx2ZsfyVdiz9gSaA7EegpTvzbxLb13yMEuNuK7m1DhJuJvwkMe4BrfdU2V5q\ncKf825oYmikQMzpfAvVkavA3AyXZEgGWx9j3j5gUxMUE8LhawnfTWWSQMc2gChzKEz1puFcyveMa\nQHVdhbcJY73M4Aev7KDWqnrAYNid2keGRzDtUDfZarSsABR4RWjshCtBctekjvxYQpsBqD4NrzvV\nDCGQNNWbKibSawkt18xdPGxR3rwMwkEqU5rE8EfXmFrFaj7t2nB8DWQa1oe4QhvPe9BYsyAumJtG\nSZFmRknJ2E5feDCzYfqAu8tVcaW6yhKUgxdrxqBVfzdTBFVtt2p5PPrz4C9d3MQsrerfSHSbbX7Q\nVcUqhotinoMHX2UyfbRYX4BJgNjLqaXE33EthhF7BBmBRkP6V7EyZYrc53XtEi1ocuKNiejWcEQe\nneajEMR9rFpHHSnzSX8AXXn13TYsGirHiFG7KYu7tzg6EFEifLeAz2wxaaaMs2K6J488kxWpDy1s\nGtG3zX3v5msToo\"\n\n(I 100% approve of urandom generating bytes that encoded to \"aj\" twice\nin the length I estimated for a route... Sure, it probably means my RNG\nis compromised and identifying me, but how sweetly personalised!)\n\n> >> To start, I was thinking you establish channels with 5 random nodes.\n> > I think Barabasi-Albert graphs are probably pretty reasonable here --\n> > you start by establishing channels to N nodes, selected randomly but\n> > favouring nodes in proportion to how connected they already are.\n> > https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model\n> Interesting.  If we assume growth only (as I suggested) we end up with a\n> geometric distribution (as backed by Section 5 of\n> http://www.e-publications.org/ims/submission/index.php/BEJ/user/submissionFile/10315?confirm=c40442a0\n> ).\n> It's not clear that we want a power law: do we?\n\nI was more thinking that it's what we'll get without any particular\neffort. The more connected a node is:\n\n - the more likely you'll hear about it (via p2p), so the more likely\n   you'll connect to it, versus a node you don't know exists\n\n - the more it will earn from fees, so the more funds it will have to\n   connect to you out of the blue\n\n - the cheaper its routes to other nodes (beacons, consumers, merchants)\n   will be at least by path length, so the more attractive it will be\n   for connecting to (at least, I think?)\n\nso the more likely you'll connect to it by happenstance, and the more\nhappy you'll be that you did.\n\nOn Sun, Sep 27, 2015 at 02:56:29PM +0930, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On Fri, Sep 25, 2015 at 06:26:55AM +0930, Rusty Russell wrote:\n> >> >> >> There are some twisty details here:\n> >> >> >> 1) How many beacon nodes?\n> >> >> >>    12, and increase on a log scale with network size.  That size can\n> >> >> >>    be derived from previous beacons.\n> >> >> > I think it's also something you could set per-node, like the\n> >> >> > minrelaytxfee.\n> >> >> That doesn't make sense, since we need to agree on who is a beacon.\n> >> > If you have the top 10 beacons and I have the top 14 beacons, we have\n> >> > the top 10 beacons in common. During the gossip phase, if either of us\n> >> > see someone in the top 10, we pass it along; I pass along a few more as\n> >> > well.\n> >> If I want to pay you, and you give me those 4 beacons I don't accept, we\n> >> break down.\n> > I have 14 beacons, and I know the order in which you're most likely\n> > to have them. If I know you can choose how many beacons you track,\n> > why would I give you the four you're least likely to have (because you\n> > have a lower limit, or because you've heard of four better beacons that\n> > haven't made it to me yet)?\n> Ergo, there are only 10 beacons, since that's all you'll ever use?  So,\n> you *don't* get to choose your number of beacons.\n\nOr I choose 3 from the top 10 and 1 from the bottom 4, and have the top\n10 used 90% of the time and the bottom 4 10% of the time?\n\n> Anyway, I won't propagate fee broadcasts which don't alter my proximity\n> to a beacon.  So if I'm between you and something only you consider a\n> \"beacon\", you'll never know about it.\n\nIf 25% of the network uses 14, and 75% uses 10, but the 25% is a strongly\nconnected subgraph, I'll know about the routes to the next four. Maybe\nthey won't be the optimal routes to those beacons, and thus won't often\nbe the cheapest routes, and thus won't often get used, but it still all\nworks fine. As other people switch and it gets to a higher percentage,\nyou get a smooth transition from k=10 to k=14.\n\nI think bumping n=8 to n=9 or n=10 would work similarly.\n\nIf you're going to have parameters that need to be changed as things\nscale, seems useful to have them accept changes gracefully, rather than\nrelying on flag days. I'm still pretty sure that k (and/or n) here work\nthat way, as described.\n\n> > Since I have to update my beacon-to-me routes regularly because of fee\n> > changes, I could regularly select different groups of beacons so you\n> > could just ask again.\n> Yech... you really want this to be single pass \"pay me $5, and here are\n> three routes from beacons near me\".\n\nWell, so far a \"route\" consists of a path with fees; symbolically:\n\n pay [MY ADDRESS] $5 via:\n   [BEACON 1] 1c [N1A] 1c [N1B] 2c [N1C] 2c [N1D] 4c [ME]\n   [BEACON 2] 2c [N2A] 1c [N1C] 2c [N1D] 4c [ME]\n   [BEACON 3] 1c [N3A] 3c [N3B] 1c [N3C] 1c [N3D] 1c [ME]\n\nSo even if you keep the same set of beacons, you have to regularly\nupdate the route info as fees/routes change, eg:\n\n pay [MY ADDRESS] $5 via:\n   [BEACON 1] 1c [N1A] 1c [N1B] 2c [N1C] 2c [N1D] 4c [ME]\n   [BEACON 2] 2c [N2A] 2c [N2B] 1c [ME]\n   [BEACON 3] 1c [N3A] 3c [N3B] 1c [N3C] 1c [N3D] 1c [ME]\n\n (N2A to N2B dropped it's previously uncompetitive fee from 10c to 2c in\n  this example, nothing else changed. N1C->N2A costs 8c)\n\nEven just sitting on the \"checkout\" page for a minute might be long\nenough to require a new route suggestion, eg.\n\nIf you're doing that anyway, might as well select a different set of\nbeacons each time as well.\n\n(The only way to not have to do that (afaics) is to just say \"pay [MY\nADDRESS $5\" and query the network for the route; which either means\nkeeping the entire graph available for path finding, or having DHTs to\nlookup routes from beacons and fees)\n\n> But you're right makes more sense to have two-phases: an immediate one\n> after the block is broadcast where you compete (via SPV proof of some\n> tx) to be a beacon, then another closer to activation where you\n> broadcast routes.  Between those two you can expect an influx of channel\n> offers.\n\nIf you've got n cohorts of beacons anyway, it seems like you'd just\nalways have the newest cohort be \"in setup phase\". ie, they'd announce\nand compete fairly quickly (minutes or hours), and then spend some time\ngetting fully setup (new channels, rebalancing), and obviously still\nforwarding any transactions that find their way to them, but everyone\nwould still tend to use the more established cohorts. Then once the /next/\ncohort gets selected, it's game on.\n\nThat'd just require merchants to not select the latest cohort of\nbeacons when advertising routes from beacons. As far as everyone else\nis concerned, brand new beacons are fine to use as normal if they turn\nout to be the best route.\n\n> Interestingly, the former idea means you get some leakage of routes,\n> from nearby almost-beacons (until defeated by better beacons).\n> Remembering those might help shortcircuit some routes (if there's some\n> geographical correlation between nodes).\n\nI don't think this works: old route info also means old fee info; and\nyou can only shortcircuit if the fees are actually less, which you no\nlonger know.\n\n> >> Then by convention you delay 10 blocks before using a beacon.  By that\n> >> time, routes should be sufficient.\n> > I wouldn't have thought 10 blocks was long enough to setup a new channel\n> > especially to a beacon, fwiw. (If you can create a channel to a beacon\n> > with the beacon's side initially 0, spend all that money back to yourself,\n> > then reorg with a doublespend of the anchor inputs so the channel never\n> > existed, you can steal the beacon's pre-existing savings. The routing's\n> > trivial -- it's you to the beacon, and then each of your neighbours will\n> > tell you the cheapest path from a beacon to them as soon as they know it)\n> I guess I was thinking of microtransactions, and expecting the average\n> anchor depth requirement to be ~1.  6 is considered pretty conservative;\n> I only added 4 to allow for propogation and setup time.\n\nI don't think microtransactions help reduce risk here: from one angle,\nif you're spending $10,000/year on hardware and admin time to keep your\nnode operating, you want to make that much in revenue to pay for it,\nand if revenue is 20% ROI per year, that's $50,000 investment or more\non your side of your channels. ie, I'm expecting to see serious money\nlocked up in channels.\n\n(If forwarding a txn earns you 0.2%, then $10k/year in fees means\nforwarding $5M/year, so $13k/day, $600/hour, $10/minute, or 15c per\nsecond on average. If your average transaction is $10, that's one a\nminute; if it's 10c, it's three every two seconds, etc.)\n\nNow, if you're always receiving paired transactions (10c from Alice\nto Carol, then 10c from Carol to Alice, then 10c from Alice to Carol\nagain, etc), you don't need more than 10c in your channels to forward\nthe payments, and your profit isn't dependent on your investment, and\nlife is pretty sweet.\n\nBut if there's time discrepencies so that Alice pays multiple rounds\nof 10c to Carol, who then batches it up into a single $10 payment, you\nneed $10 in your channel (100x more). Or if Alice and Anna and Amy and\nAbby all pay multiple rounds of 10c, then eventually Carol accumulates\nthat into a burst of 50x $10 payments, you need at least $500 in your\nchannel with Carol, and a similar amount distributed across the channels\nconnecting you to the A-squad.\n\nAnd if the reason you're connected to the \"A-squad' is that you've got a\ncheap connection to a beacon, that's centralised in that one channel. If\nthere's multiple Carol's each batching $500 in received funds together at\nthe end of the day, your channel balances have to scale accordingly. If\nyou don't, you'll miss out on transactions, and hence fee income.\n\n(So, if you need $50k across your channels (making up your $50k investment\nmentioned above), that's $25k on each side, and you're making $10k\na year in fees, off of $5M/year in transactions (again, as above),\nthen that means your channels are able to cover about two days' worth\nof discrepency -- ie if you start balanced with $25k on your side\nof the Alice-you channel, and the same on you-Carol, after 46 hours\nworth of microtransactions at $13k/day, you can't accept payments from\nAlice or to Carol anymore. So I think this directly relates the ROI\nto... fee percentage and standard deviation of payment frequency on a\nchannel? Something like that)\n\n*However* this is all probably a moot point: if beacons aren't used\nwhile they're in the newest cohort, then they don't particularly\nneed to use the new channels immediately, and new anchors get\nsafely buried anyway. Something like:\n\n * 1 hour (6 blocks): pretty good global consensus on who the beacons are\n * 20 hours (120 blocks): plenty of time to setup new channels\n * 3 hours (18 blocks): plenty of time for the new channels to be buried\n\nAnd voila, 24 hours later, the new cohort has new channels and is ready\nto go active, and a new newest-cohort can be chosen.\n\n> >> > I'm not sure if it's a realistic attack model, but if you can observe:\n> >> >   Bob -> Alice: pay me $20 to R (routes to current beacons: ...)\n> >> > and have control of the beacon Alice ends up using, then you can both\n> >> > observe that Alice is trying to make the payment (you see an HTLC with\n> >> > $20 and R), and prevent Alice from making the payment (you can just not\n> >> > forward any transactions involving R).\n> >> Sure.  But if you can observe the private conversation between Bob and\n> >> Alice, *and* you control enough nodes that you're likely to be the\n> >> beacon they choose, you don't need to be a beacon to block them :)\n> > You don't have to control the nodes initially, you just have to attack\n> > the beacons once they're announced. If they're accepting new channels,\n> > then they've announced an IP. If you get an exploit on a node that\n> > would have been #15 in the ranking, you just have to DoS three higher\n> > ranked beacons to get it to have traffic.\n> They're still beacons though, they're just useless.  You do need to get\n> a beacon then DoS enough others to force traffic though you.  That may\n> be cheaper than offering the best rates, I guess.\n\nIf a beacon stops responding to pings, it won't be able to announce fee\nupdates, and would presumably expire. I'm assuming you'd just keep using\nthe k best beacons you've seen recently, so that would allow new guys\nin as well.\n\nIt feels a lot like doing economic stimulus by randomly selecting\nsome people, giving them a million dollars, and announcing their home\naddresses. Sure, it's the first story on the news, but the second is\nhow they were found mugged and broke two hours later...\n\nOkay it's not a million dollars, it's mmore transactions. So how's\nbeacon profitability compare to regular nodes? Assume 100 beacons,\n100k regular nodes doing forwarding, $20M/day (250k tx/s at\n10c/tx), and aggregate fees of 1%/tx. Shortest path between\nrandom nodes is ~4 hops, so actual tx path is about seven intermediaries:\nCONSUMER-a-b-c-BEACON-e-f-g-MERCHANT. So every transaction pays 6 nodes\nand 1 beacon. Assuming they break the fees down evenly, beacons get\n1/7th of all transactions fees; remaining nodes get 6/7th of all\ntransaction fees. So an average beacon gets:\n\n  1/100 * 1/7 * 1% * 20M = $285.71/day\n  1/(100k-100) * 6/7 * 1% * 20M = $1.72/day\n\nIf you're talking about millions of nodes, that's another factor of 10\nor more worse. If you're talking 100k nodes but 1000s of beacons instead\nof 100, maybe it gets better ($15-$30/day vs $2/day?), but then maybe\nwe need to revisit the beacon related traffic calculations, because 1000\nis a lot more than 12...\n\nIn reality, to me those numbers just say \"it's not worth running a node\nif you're not a beacon\", so the best strategy is to commit a few cents in\npretend channels on the blockchain to buy tickets in the beacon lottery,\nbut only start actually routing when you win. So there maybe ends up being\na few thousand nodes that have direct relationships with customers to\nearn profits based on subscription fees, and a bunch of beacon-specialists\nwho play the beacon lottery and run 90% of the beacons at any given time,\nearning profit from investment and routing.\n\nAlso, if the only routes you know are to and from beacons, it seems\na bit difficult to do much in the way of \"scenic\" routing to make the\nonion routing more obscure. I'm not sure this actually matters if you\nhave a total path length of more than six or seven though.\n\n(TBH: at this point beacons are seeming (to me) like a clever idea, that's\ntotally implementable, but won't actually work out at all. YMMV obviously)\n\n> >> Yes!  I've been wondering about this kind of \"donation address\"\n> >> scenario.  Turns out you can encode the R value in the onion routed\n> >> message you send, too.  Only the final recipient can read it anyway.\n> > Yep.\n> >> That doesn't help with routing to the donation address; maybe we will\n> >> need a best-effort DHT for that?\n> >\n> > If you've got a route, but no fee information; you could probe the\n> > route with nanopayments. ie, to move $10 along me->A->B->C->D, first\n> > try sending 0.01c to B with a 0.1% then a 0.2% fee, etc. Once you know\n> > A's fee, repeat with B, then C. If the fees end up as 1%, 2% and 0.2%\n> > your successful transactions are:\n> >   0.01c to B plus 0.0001c to A\n> >   0.01c to C plus 0.0001c to A plus 0.0002c to B\n> >   0.01c to D plus 0.0001c to A plus 0.0002c to B plus 0.00002c to C\n> >   $10 to D plus 10c to A plus 20c to B plus 2c to C\n> > and the txs that had smaller fees just bounce back to you.\n> I was assuming the \"insufficient fees\" message would include the latest\n> route info, so it's even easier.\n\nI was figuring it would just be a \"couldn't route\" message with no\nadditional info (could be no channel, not enough fees, bad R, mistake\nin crypto...) -- otherwise you're kind-of unwrapping the onion (ie, C\ntells B, \"C's fee is 1%\"; B tells A \"C's fee is 1%\"; A says \"oh, trying\nto send money to C, huh? how interesting!\". C could encrypt the info to the\nsymmetric key A sent C, but... seems like a lot of hassle at that point)\n\n> I was more concerned about the \"there's no channel from B->C any more\".\n\nSure. In that case you can't make the payment until they tell you new\nroutes, or you use some other protocol for route finding. The beacons\nare going to change soon enough anyway, so no suggested route will\nwork for all that long, even ignoring fee changes.\n\n> > (If probing was the main use for nanotransactions, nodes might set higher\n> > fees on them though, if they assume you've already chosen a route, and\n> > they therefore don't need to compete on price with other possible routes)\n> Maybe nodes will offer some kind of routing service in future.  Seems\n> like it'd be a layer up though.\n\nI kind-of think routing is actually already a layer up, and effectively\nsort-of pluggable. ie, you've got:\n\n 0: direct connection to someone, can establish a channe, update HTLCs\n\n 1: onion-routed packets, can be forwarded on level 0\n\n 2: route-finding\n\nIf you've got a bunch of beacon routes, that's one way of implementing\nlevel 2. If you know a whole bunch of channels, then you can do it that\nway. If you have an oracle you can query, that's another way. If you've\ngot multiple different systems (some nodes don't participate in the\nmain routing network because of persecution fears eg), with some nodes\nin common, you can join them up.\n\n> > There's a corresponding thread\n> > (same title) on BitcoinXT, if you really want to feel trolled.\n> > There's also:\n> >   /r/lightningnetwork: The Bitcoin Lightning Network\n> >   This sub-reddit is dedicated to corporate interests trying to take over\n> >   the decentralized world-wide ledger.\n> > No posts unfortunately...\n> Damn, let me fix that...\n\nStill no posts; caught in moderation I guess?\n\n> > ...\n> OK, if we have a real offline mode for standard wallets, the distinction\n> becomes real.\n\nWithout it, I guess I'm thinking of balances like:\n\n - $10-$20 on my phone (coffee, busfare, wifi access)\n - $100-$200 on my desktop/laptop (which I can turn off, and have more\n   control over)\n\n(Ideally, I'd rather have $200 on my phone though, replacing cash/credit for\neveryday purchases)\n\nThings that can't go offline don't change of course:\n\n - $1-$10 for IoT devices doing micropayments\n - $10-$100 for routers/cloud computers paying for their own internet\n - $1000-$5000 for merchants doing reasonable volume\n - $1000-$100,000 for nodes operating as revenue generating investments\n\n> > As far as privacy goes I think you could tell which of your neighbours\n> > is using lightning primarily as a wallet versus trying to be a\n> > profit-generating node fairly easily: wallets will have smaller channels,\n> > there'll be fewer transactions over them, and they'll disconnect more\n> > often. That doesn't guarantee they're not forwarding things; but if they\n> > are they're almost certainly arranging it out of band anyway (even if\n> > only to know when they'll be online and thus able to forward).\n> I think deniability is important.  Thus I would want my wallet to\n> forward payments when offered.\n\nSure, but I think in practice that only works if you actually forward\npayments; otherwise \"you claim that payment was forwarded; but in the\nfive months we've monitored you, you have not forwarded a single payment,\nwhy should the jury believe this one was special?\"\n\nIf you had $1000 on your phone, and were *actually* acting like a node,\nand willing to be a beacon, then *that* would be totally deniable, and\npretty awesome. But I think in practice technology will mean you've\ngot some nodes acting as an investment trying to earn a ROI/profit,\nand other nodes acting as wallets, spending money or receiving money\nbased on goods/services outside of lightning itself.\n\n> > (I actually think arguing the other way might make a bit of sense; if\n> > you're running a node, you should pay profits and expenses to/from an\n> > entirely separate lightning wallet)\n\nSo pulling in the other mail here:\n\nOn Sun, Sep 27, 2015 at 03:12:56PM +0930, Rusty Russell wrote:\n> Anthony Towns <aj at erisian.com.au> writes:\n> > On Fri, Sep 25, 2015 at 11:23:42AM +0930, Rusty Russell wrote:\n> >> Beacons are going to get slammed, but it's not clear how bad it is.\n> >> Getting slammed from all directions doesn't use up channels; it's only\n> >> computational and bandwidth limits.\n> > It does actually use up channels -- if you've got 5 channels with 100 BTC\n> > in them collectively in total, and you own 20 BTC of that, and collect\n> > a 0.1% fee on each transaction, you'll gain 80 BTC after 80,000 BTC are\n> > forwarded through you, and nobody will be able to send you funds any more.\n> That's a great insight!  Fees *do* erode channels.  I had totally missed\n> that.\n\nWhat I'm thinking is you'd do something like:\n\n - node has $10,000 in channels, earns 20% a year, so around $150 a month\n - once a month, roughly, node owner has the node pay $150 from the node\n   to a personal lightning wallet\n - payments for node's running costs can be made from wallet (avoiding\n   hitting the blockchain)\n - the personal wallet can get pushed to the blockchain providing anchor\n   transactions for new channels for the node (to reinvest the profits)\n\nBenefits:\n\n - you can lock the profits in an offline wallet if you want (you only\n   need to be active long enough to receive the HTLCs, and you can\n   decide when to send them)\n - if you have the node, you can't trace the money to the hosting\n   environment\n - node's channels are refreshed and can stay open indefinitely\n - if you hit a lucky channel that's makes $1000/month with only $100\n   channel balance, you can keep that channel active forever\n   (you'd have to empty profits out once a day or so though)\n - you can kind-of lock the node down, so that it will only sign\n   incoming/forwarded transactions, and outgoing transactions to\n   a particular wallet (probably have to limit to set of known R values\n   though). you could come close to having this be just a trusted crypto\n   module, and have any exploit in the rest of the system be unable to\n   steal your money.\n\nHmm, I think that actually explains the lightning/bitcoin fee nexus a\nbit: lightning nodes earn x% of lightning transactions; then to reinvest\nthis profit in lightning, they spend on the blockchain generating $f\nin fees for miners. It's not /spending/ the profits from lightning fees\nthat generates fees for miners (because that could be done withing the\nlightning network in theory), it's /reinvesting/ them in the lightning\nnetwork. (And also buying into lightning in the first place, or cashing\nout eventually, or rebalancing your investment)\n\n> > (In the event that someone suggests a route beacon_X -> X -> Y -> Z to\n> > get to them, and you have a path A -> C -> X -> beacon_X, you can cut out\n> > the middleman and not route through a beacon at all. I don't think this\n> > gives much of an improvement though. A beacon could potentially avoid\n> > this from being possible by partitioning its neighbours into two sets\n> > and setting incoming fees for one set prohibitively high, and outgoing\n> > fees to the other set as prohibitively high; managing that dynamically\n> > would be difficult but I think possible)\n> But you'd risk not being used as a beacon if your fees are too high.\n\nThat's not a problem here. Say every other beacon costs 1% to route\nthrough, give or take. You have neighbours A, B, C and D. You set the\nfollowing prices:\n\n   A -> Me: 0.45%\n   B -> Me: 0.45%\n   Me -> A: 5.1%\n   Me -> B: 5.1%\n\n   C -> Me: 5.1%\n   D -> Me: 5.1%\n   Me -> C: 0.45%\n   Me -> D: 0.45%\n\nA route that goes X -> A -> Me -> C -> Y will still only pay you 0.9%\nso is completely competitive for transactions; but hardly anyone will\never see a route like Z -> D -> C -> Me, because Z -> W -> V -> U -> A ->\nMe will be cheaper despite the extra hops. That in turn means means no\none will figure out that Z -> D -> C -> Y is a valid path, missing out\ngoing through me.\n\nTo make it work dynamically, you'd need to swap the channels you apply\nthe ~5% penalty so the transaction flows balance out, but I think the\ngeneral principle works.\n\n> It\n> seems to me that a beacon wants many connections, to avoid the\n> \"short-circuit\" case.  At 100 connections, it's only 1%, though\n> that's the best case which assumes they're all equally likely.\n\nMaybe... Establishing an extra 100 connections per beacon per cohort is a\nfair chunk of blockchain transactions; and presumably they'll expire once\nthe beacon stops being a beacon, rather than lasting for months/years.\n500kB per cohort, maybe? At 1MB/block and a cohort per day, that's 0.3%\nof the blockchain already.\n\n(Is 100 realistic, or would every node want a direct channel to a beacon,\nso that it would be more like 1000/beacon (100k nodes, 100 beacons)\nor more?)\n\n> Good points.  If we reject all routes less than (say) 3 hops by default\n> it might mean that local payments are *less* efficient.  Oops.\n\nI was thinking, at least at this stage, that there wasn't any point\ndifferentiating local vs global payments; I'm hoping global payments are\nquick enough for buying a coffee anyway, and online microtransactions\nwill probably be global anyway. And as above, I think route finding is\nseparate enough that you can always improve it while leaving the lower\nlayers (HTLCs and onion-forwarding) the same.\n\nCheers,\naj"
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-28T11:12:56",
                "message_text_only": "On Mon, Sep 28, 2015 at 08:37:19PM +1000, Anthony Towns wrote:\n> Batch-replying.\n\nOops, I triggered my own spamassassin here. Y'all might need to pull it\nout of your spam folders if you want to read.\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-30T05:12:54",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Batch-replying.\n>\n> On Sun, Sep 27, 2015 at 01:54:45PM +0930, Rusty Russell wrote:\n>> Anthony Towns <aj at erisian.com.au> writes:\n>> > On Fri, Sep 25, 2015 at 09:56:02AM +0930, Rusty Russell wrote:\n>> >> [ Pieter Wuille Cc'd for pubkey recovery, search for \"recovered\" ]\n>> >> Mats Jerratsch <matsjj at gmail.com> writes:\n>> >> >> Indeed.  Random selection helps, here, but analysis will be interesting.\n>> >> > How have you ended up with a number of beacons you need? 12 seems so\n>> >> > low, I can\u2019t imagine so few nodes to support all transacting for even\n>> >> > 10 minutes..\n>> >> As we keep the last 100 sets of beacons, the load is spread a little.\n>> > Does that actually work? Old beacons don't do any good if the payee\n>> > doesn't use them when advertising a route; but old beacons also don't\n>> > get their fee updates propogated, and aren't known by people who only\n>> > just joined the network. I don't think you could usefully keep more than\n>> > the last 2 or 3 sets of beacons?\n>> I was thinking they all count as active.  No point turning over all the\n>> beacons every block.\n>\n> Okay, in that case I was misled by your original description.\n\nDid I somehow give you the impression I'm making it up as we go along?\nI'm so sorry, let me reinforce that now...\n\n> You're\n> actually talking about n*k beacons at any point in time, of which the\n> oldest k are replaced every d days. If k=12 and n=8, that gives 96 beacons\n> at any point in time. Any given beacon is operation for n*d days, for n=8,\n> then d=1 gives 8 days, while d=7 gives 2 months.\n\nPretty much.\n\nI was thinking there's some delay before activation (so, we have 10\nblocks worth of \"chosen but inactive\" beacons), 100 blocks of active\nbeacons.  n beacons per block (though it may increase with <formula>).\n\nWe can play with the parameters.  And we might select every N blocks if\nwe want longer-lived beacons.\n\n> The \"d\" parameter would be \"consensus-critical\"; I don't think it's\n> possible to agree on any beacons without agreeing on d. You could vary k\n> or n as the network scales though, but in that case I think it'd generally\n> be easier to vary n than k?\n>\n> If you identify a given beacon by its cohort (from 1..n), its rank\n> (1..k), its visibility (how long ago you first heard about it in\n> seconds) and its currency (how recently the last route update to that\n> beacon was), then I think the odds of a random other node also knowing\n> about that beacon works out as:\n>\n>  - worse for the most recent cohort (older cohorts should have more fully\n>    propogated)\n>\n>  - potentially worse for the very oldest cohorts\n>     + if being a beacon wears you out (channels may have been used\n>       up; they may have been hacked; they may have cashed out their\n>       profits and bought an island)\n>     + if nodes have varying settings for n, so older cohorts don't have\n>       as effective route propagation\n>\n>  - worse for recent visibility (newly advertising beacon, that hadn't\n>    fully propagated, same deal as for a new cohort)\n>\n>  - worse for non-recent currency (beacon might be offline, or routes to\n>    that beacon might have failed)\n>\n>  - worse for low rank in recent cohorts (new beacons shouldn't show up\n>    for old cohorts; if new beacons show up in recent cohorts, its the\n>    low rank beacons that will be offloaded)\n>\n>  - worse for low rank in any cohort if other nodes have lower values for\n>    k\n\nIn practice, more recent beacons last longer.  The other effects are\nless clear.  I'm assuming nodes remember routes to older beacons than\nthey would actually give out to others (handwave).\n\n> When picking beacons to advertise for accepting a payment, I think you'd\n> want to take most of the above into account, to avoid only suggesting\n> coincidently unreachable beacons, and having the payment fail.\n>\n> I don't think you could really take route price into account, since the\n> real price is \"consumer to beacon\" plus \"beacon to merchant\"; and those\n> could trivially be inversely related. Having 10%-30% of your suggestions\n> be selected by cheapness would still be useful though.\n\nStill the best choice, I think.  Simulations welcome, but on a large\nnetwork random nodes are likely to be terrible for both.\n\n> Choosing, say, two of the cheapest beacons, and three beacons from\n> cohorts 3-n with recent currency and long term visibility would probably\n> work okay though.\n>\n> If nodes are identified by a 160b address, and it takes around 4 hops\n> to get to/from a random beacon, then a route is 4*160b=80B and five\n> routes as above is 400B. That's ~550 bytes with base58\n> encoding by my count, or about 7 lines of 76 column text. Kinda lame:\n>\n> \"please pay to 1ajaj31PWNVZEzd68S8PqAPof4EFbeZaf via lightning route:\n> 5PSGzi9R6k6G2mdFPx2ZsfyVdiz9gSaA7EegpTvzbxLb13yMEuNuK7m1DhJuJvwkMe4BrfdU2V5q\n> cKf825oYmikQMzpfAvVkavA3AyXZEgGWx9j3j5gUxMUE8LhawnfTWWSQMc2gChzKEz1puFcyveMa\n> QHVdhbcJY73M4Aev7KDWqnrAYNid2keGRzDtUDfZarSsABR4RWjshCtBctekjvxYQpsBqD4NrzvV\n> DCGQNNWbKibSawkt18xdPGxR3rwMwkEqU5rE8EfXmFrFaj7t2nB8DWQa1oe4QhvPe9BYsyAumJtG\n> SZFmRknJ2E5feDCzYfqAu8tVcaW6yhKUgxdrxqBVfzdTBFVtt2p5PPrz4C9d3MQsrerfSHSbbX7Q\n> VcUqhotinoMHX2UyfbRYX4BJgNjLqaXE33EthhF7BBmBRkP6V7EyZYrc53XtEi1ocuKNiejWcEQe\n> neajEMR9rFpHHSnzSX8AXXn13TYsGirHiFG7KYu7tzg6EFEifLeAz2wxaaaMs2K6J488kxWpDy1s\n> GtG3zX3v5msToo\"\n>\n> (I 100% approve of urandom generating bytes that encoded to \"aj\" twice\n> in the length I estimated for a route... Sure, it probably means my RNG\n> is compromised and identifying me, but how sweetly personalised!)\n\nIn the future, we'll all be using the payment protocol.  From our flying\ncars.  Right?\n\nOK, so we ahve to use a 177x177 QR code.  Lucky about high-res cameras,\nI guess?\n\n> If you're going to have parameters that need to be changed as things\n> scale, seems useful to have them accept changes gracefully, rather than\n> relying on flag days. I'm still pretty sure that k (and/or n) here work\n> that way, as described.\n\nThat's true, if we think of changing the numbers over time.\n\nI was thinking of scaling n with log2(number nodes).  And we can intuit\nnumber nodes from proximity of beacons to ideal <insert smoothing and\nformulae here>.\n\n>> > Since I have to update my beacon-to-me routes regularly because of fee\n>> > changes, I could regularly select different groups of beacons so you\n>> > could just ask again.\n>> Yech... you really want this to be single pass \"pay me $5, and here are\n>> three routes from beacons near me\".\n>\n> Well, so far a \"route\" consists of a path with fees; symbolically:\n>\n>  pay [MY ADDRESS] $5 via:\n>    [BEACON 1] 1c [N1A] 1c [N1B] 2c [N1C] 2c [N1D] 4c [ME]\n>    [BEACON 2] 2c [N2A] 1c [N1C] 2c [N1D] 4c [ME]\n>    [BEACON 3] 1c [N3A] 3c [N3B] 1c [N3C] 1c [N3D] 1c [ME]\n>\n> So even if you keep the same set of beacons, you have to regularly\n> update the route info as fees/routes change, eg:\n>\n>  pay [MY ADDRESS] $5 via:\n>    [BEACON 1] 1c [N1A] 1c [N1B] 2c [N1C] 2c [N1D] 4c [ME]\n>    [BEACON 2] 2c [N2A] 2c [N2B] 1c [ME]\n>    [BEACON 3] 1c [N3A] 3c [N3B] 1c [N3C] 1c [N3D] 1c [ME]\n>\n>  (N2A to N2B dropped it's previously uncompetitive fee from 10c to 2c in\n>   this example, nothing else changed. N1C->N2A costs 8c)\n>\n> Even just sitting on the \"checkout\" page for a minute might be long\n> enough to require a new route suggestion, eg.\n>\n> If you're doing that anyway, might as well select a different set of\n> beacons each time as well.\n>\n> (The only way to not have to do that (afaics) is to just say \"pay [MY\n> ADDRESS $5\" and query the network for the route; which either means\n> keeping the entire graph available for path finding, or having DHTs to\n> lookup routes from beacons and fees)\n\nYes, we could use the DHT for routes/fees.  I think it's a layer on top\nthough.\n\n>> But you're right makes more sense to have two-phases: an immediate one\n>> after the block is broadcast where you compete (via SPV proof of some\n>> tx) to be a beacon, then another closer to activation where you\n>> broadcast routes.  Between those two you can expect an influx of channel\n>> offers.\n>\n> If you've got n cohorts of beacons anyway, it seems like you'd just\n> always have the newest cohort be \"in setup phase\". ie, they'd announce\n> and compete fairly quickly (minutes or hours), and then spend some time\n> getting fully setup (new channels, rebalancing), and obviously still\n> forwarding any transactions that find their way to them, but everyone\n> would still tend to use the more established cohorts. Then once the /next/\n> cohort gets selected, it's game on.\n>\n> That'd just require merchants to not select the latest cohort of\n> beacons when advertising routes from beacons. As far as everyone else\n> is concerned, brand new beacons are fine to use as normal if they turn\n> out to be the best route.\n\nMakes sense.  Selecting a new cohort every block is probably silly then,\nsince they come too fast.\n\n>> Interestingly, the former idea means you get some leakage of routes,\n>> from nearby almost-beacons (until defeated by better beacons).\n>> Remembering those might help shortcircuit some routes (if there's some\n>> geographical correlation between nodes).\n>\n> I don't think this works: old route info also means old fee info; and\n> you can only shortcircuit if the fees are actually less, which you no\n> longer know.\n\nNo, you get updated fee information when your message gets bounced.\n\n> *However* this is all probably a moot point: if beacons aren't used\n> while they're in the newest cohort, then they don't particularly\n> need to use the new channels immediately, and new anchors get\n> safely buried anyway. Something like:\n>\n>  * 1 hour (6 blocks): pretty good global consensus on who the beacons are\n>  * 20 hours (120 blocks): plenty of time to setup new channels\n>  * 3 hours (18 blocks): plenty of time for the new channels to be buried\n>\n> And voila, 24 hours later, the new cohort has new channels and is ready\n> to go active, and a new newest-cohort can be chosen.\n\nI like your random formula, and shall slavishly adopt it!\n\n> It feels a lot like doing economic stimulus by randomly selecting\n> some people, giving them a million dollars, and announcing their home\n> addresses. Sure, it's the first story on the news, but the second is\n> how they were found mugged and broke two hours later...\n\nIt's a true Bitcoin story!\n\n> In reality, to me those numbers just say \"it's not worth running a node\n> if you're not a beacon\", so the best strategy is to commit a few cents in\n> pretend channels on the blockchain to buy tickets in the beacon lottery,\n> but only start actually routing when you win. So there maybe ends up being\n> a few thousand nodes that have direct relationships with customers to\n> earn profits based on subscription fees, and a bunch of beacon-specialists\n> who play the beacon lottery and run 90% of the beacons at any given time,\n> earning profit from investment and routing.\n\nPerhaps the entire network becomes corrupted.  But the alternatives seem\nto lead even faster to centralization.\n\nJoseph suggested that to be in the lottery, your anchor tx would have to\nbe above some amount.  I resisted that as another centralization force,\nbut perhaps we'll end up there.\n\n> Also, if the only routes you know are to and from beacons, it seems\n> a bit difficult to do much in the way of \"scenic\" routing to make the\n> onion routing more obscure. I'm not sure this actually matters if you\n> have a total path length of more than six or seven though.\n\nOr, something added up one layer.  Ask me my routes, and I will tell\nyou?\n\n> (TBH: at this point beacons are seeming (to me) like a clever idea, that's\n> totally implementable, but won't actually work out at all. YMMV obviously)\n\nQuite possibly.  It's implementable, but not sure it's going to be\nrobust.\n\n> I was figuring it would just be a \"couldn't route\" message with no\n> additional info (could be no channel, not enough fees, bad R, mistake\n> in crypto...) -- otherwise you're kind-of unwrapping the onion (ie, C\n> tells B, \"C's fee is 1%\"; B tells A \"C's fee is 1%\"; A says \"oh, trying\n> to send money to C, huh? how interesting!\". C could encrypt the info to the\n> symmetric key A sent C, but... seems like a lot of hassle at that point)\n\nYep, you have to onion up error messages.  (Except timeout, that needs\nexposure, to prove you broke a channel).\n\nIt's not that hard to do though, since every hop has a shared secret\nkey.\n\n>> I was more concerned about the \"there's no channel from B->C any more\".\n>\n> Sure. In that case you can't make the payment until they tell you new\n> routes, or you use some other protocol for route finding. The beacons\n> are going to change soon enough anyway, so no suggested route will\n> work for all that long, even ignoring fee changes.\n>\n>> > (If probing was the main use for nanotransactions, nodes might set higher\n>> > fees on them though, if they assume you've already chosen a route, and\n>> > they therefore don't need to compete on price with other possible routes)\n>> Maybe nodes will offer some kind of routing service in future.  Seems\n>> like it'd be a layer up though.\n>\n> I kind-of think routing is actually already a layer up, and effectively\n> sort-of pluggable. ie, you've got:\n>\n>  0: direct connection to someone, can establish a channe, update HTLCs\n>\n>  1: onion-routed packets, can be forwarded on level 0\n>\n>  2: route-finding\n>\n> If you've got a bunch of beacon routes, that's one way of implementing\n> level 2. If you know a whole bunch of channels, then you can do it that\n> way. If you have an oracle you can query, that's another way. If you've\n> got multiple different systems (some nodes don't participate in the\n> main routing network because of persecution fears eg), with some nodes\n> in common, you can join them up.\n\nIndeed.  Perhaps there's a smarter way to segment the network than\nglobal beacons though.  Maybe some limit on path length?\n\n> Hmm, I think that actually explains the lightning/bitcoin fee nexus a\n> bit: lightning nodes earn x% of lightning transactions; then to reinvest\n> this profit in lightning, they spend on the blockchain generating $f\n> in fees for miners. It's not /spending/ the profits from lightning fees\n> that generates fees for miners (because that could be done withing the\n> lightning network in theory), it's /reinvesting/ them in the lightning\n> network. (And also buying into lightning in the first place, or cashing\n> out eventually, or rebalancing your investment)\n\nIndeed.\n\n> That's not a problem here. Say every other beacon costs 1% to route\n> through, give or take. You have neighbours A, B, C and D. You set the\n> following prices:\n>\n>    A -> Me: 0.45%\n>    B -> Me: 0.45%\n>    Me -> A: 5.1%\n>    Me -> B: 5.1%\n>\n>    C -> Me: 5.1%\n>    D -> Me: 5.1%\n>    Me -> C: 0.45%\n>    Me -> D: 0.45%\n>\n> A route that goes X -> A -> Me -> C -> Y will still only pay you 0.9%\n> so is completely competitive for transactions; but hardly anyone will\n> ever see a route like Z -> D -> C -> Me, because Z -> W -> V -> U -> A ->\n> Me will be cheaper despite the extra hops. That in turn means means no\n> one will figure out that Z -> D -> C -> Y is a valid path, missing out\n> going through me.\n>\n> To make it work dynamically, you'd need to swap the channels you apply\n> the ~5% penalty so the transaction flows balance out, but I think the\n> general principle works.\n\nClever.  I'll have to think about that more...\n\n>> It\n>> seems to me that a beacon wants many connections, to avoid the\n>> \"short-circuit\" case.  At 100 connections, it's only 1%, though\n>> that's the best case which assumes they're all equally likely.\n>\n> Maybe... Establishing an extra 100 connections per beacon per cohort is a\n> fair chunk of blockchain transactions; and presumably they'll expire once\n> the beacon stops being a beacon, rather than lasting for months/years.\n> 500kB per cohort, maybe? At 1MB/block and a cohort per day, that's 0.3%\n> of the blockchain already.\n>\n> (Is 100 realistic, or would every node want a direct channel to a beacon,\n> so that it would be more like 1000/beacon (100k nodes, 100 beacons)\n> or more?)\n\nI don't know.  I think that the most likely connects will be distant\nnodes which are also hubs.  Deciding which ones to accept will be a fun\nproblem....\n\n>> Good points.  If we reject all routes less than (say) 3 hops by default\n>> it might mean that local payments are *less* efficient.  Oops.\n>\n> I was thinking, at least at this stage, that there wasn't any point\n> differentiating local vs global payments; I'm hoping global payments are\n> quick enough for buying a coffee anyway, and online microtransactions\n> will probably be global anyway. And as above, I think route finding is\n> separate enough that you can always improve it while leaving the lower\n> layers (HTLCs and onion-forwarding) the same.\n\nIndeed.  This conversation is about medium-to-long term.  For now,\neveryone blasting their routes & fees on IRC is workable.\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Ionization Protocol: Flood Routing",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Pieter Wuille",
                "Amos Bairn",
                "Rusty Russell",
                "Mats Jerratsch"
            ],
            "messages_count": 23,
            "total_messages_chars_count": 154560
        }
    },
    {
        "title": "[Lightning-dev] Payment and Refund Stuck",
        "thread_messages": [
            {
                "author": "Mats Jerratsch",
                "date": "2015-09-22T17:55:26",
                "message_text_only": "So far my impression was that an attacker that only stops one payment\nis just a nuisance, as the system can self-correct. The payer and\npayee can set a timeout. If the payment has not arrived after the\ntimeout the payee can issue a refund back to the payer. The refund\nwill pay to the same secret hash as the initial payment, and it will\npay an amount that is sufficient such that the payer will receive his\ninitial payment completely back. (That is, he might end up paying more\nrefund than actual payment)\n\nWhen the payer does receive the refund in his channel, he can be sure\nthat the payment got invalidated. The payee must not reveal the\nsecret, and even if he does, the funds will just circle back again.\n(plus the payee will pay fees for both transactions as a disincentive)\nThis concept has been around already, at least I read it somewhere.\nHowever, I recently thought about it and got a couple of unresolved\nissues:\n\n(1)\nHow do we resolve the complete chain to remove both, the refund and\nthe payment completely? Do we just wait until they timeout? This does\nnot seem very efficient and it would maximise the damage the attacker\nwould do to the network - that is, he is locking up the payment amount\nfor N1 nodes on the first route and N2 nodes on the refund route for\nthe maximum amount of time. I thought about letting the nodes resolve\nthis on their own, but this would need cooperation from the very node\nthat isn't relaying the payment in the first place.\n\nLets assume A wants to pay E, and it chose the route\n\nA->B->C->D->E.\n\nHowever, C is uncooperative in that he does accept the payment in the\nchannel he has with B, but he is not relaying it further to D. (for\nwhatever reason)\nSo we end up with\nA->B->C\n\nNow the timeout hits and E is making the refund payment\n\nE->D->F->B->A\n\nwith the same secret hash.\n\nA and B can resolve this, both payments are the same amount (as\ndescribed above), so the payments net-worth is zero for both parties.\nNow B has a binding payment towards C for X-a bitcoin, and he receives\nX+a bitcoin from F. (with some fees a)\n>From the point of view of B, this is just a normal payment from F\ntowards C with 2a in fees. And while B can drop the payment he gets\nfrom F (they can just update the channel and remove the payment if B\nagrees), he still has a binding agreement towards the payment to C.\nWithout C agreeing to drop the payment as well, B isn't in the\nposition to drop the payment towards F, keeping up the complete chain.\n\n\n(2)\nHow do we resolve the case, where the refund gets stuck as well? Let's\nassume the same case as above, but this time F is uncooperative too.\nWe end up with two chains of payments, where both payees don't get the\npayment:\n\nA->B->C\nE->D->F\n\nwhere C and F are both uncooperative. From the point of view of A, he\nhas made a final payment that he cannot revoke on his own. He further\nhas made the payment due to some contract, to which he expects some\nkind of service/good. Waiting out one day till the lightning timeout\nmight not be an option for A.\nThe same is true other way round, where E has issued the refund and is\nawaiting a new payment. Both parties can not sufficiently prove to the\nother party they haven't received the payment, and even if they could,\nthe initial payment could still route correctly after some delay while\nthe refund doesn't.\n\nThinking about it, I guess E could give out multiple refunds via other\nroutes, until one finally arrives at the payer. As he is obliged to\nnot reveal the secret anyways, these are just for resolving the issue\nat hand. However, this would again maximise the damage, as all\nadditional refunds would need to timeout. Furthermore, a malicious\npayer could just claim he never received any refund, locking up lots\nof funds of the payee with very few efforts..."
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-24T05:56:30",
                "message_text_only": "Mats Jerratsch <matsjj at gmail.com> writes:\n> So far my impression was that an attacker that only stops one payment\n> is just a nuisance, as the system can self-correct. The payer and\n> payee can set a timeout. If the payment has not arrived after the\n> timeout the payee can issue a refund back to the payer. The refund\n> will pay to the same secret hash as the initial payment, and it will\n> pay an amount that is sufficient such that the payer will receive his\n> initial payment completely back. (That is, he might end up paying more\n> refund than actual payment)\n>\n> When the payer does receive the refund in his channel, he can be sure\n> that the payment got invalidated. The payee must not reveal the\n> secret, and even if he does, the funds will just circle back again.\n> (plus the payee will pay fees for both transactions as a disincentive)\n> This concept has been around already, at least I read it somewhere.\n\nYes, I think it was Joseph Poon who suggested it.  I'm keeping it in\nreserve for the moment, in case this becomes common enough that we need\nto code up a solution.\n\nYour criticisms are valid, AFAICT.\n\nCheers,\nRusty."
            },
            {
                "author": "Joseph Poon",
                "date": "2015-09-24T20:52:52",
                "message_text_only": "Hi Mats,\n\nYes, I agree whole heartedly! See my related comment here:\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000018.html\n\nTwo hashes are necessary for this type of invalidation.\n\nOn Thu, Sep 24, 2015 at 03:26:30PM +0930, Rusty Russell wrote:\n> Mats Jerratsch <matsjj at gmail.com> writes:\n> > So far my impression was that an attacker that only stops one payment\n> > is just a nuisance, as the system can self-correct. The payer and\n> > payee can set a timeout. If the payment has not arrived after the\n> > timeout the payee can issue a refund back to the payer. The refund\n> > will pay to the same secret hash as the initial payment, and it will\n> > pay an amount that is sufficient such that the payer will receive his\n> > initial payment completely back. (That is, he might end up paying more\n> > refund than actual payment)\n> >\n> > When the payer does receive the refund in his channel, he can be sure\n> > that the payment got invalidated. The payee must not reveal the\n> > secret, and even if he does, the funds will just circle back again.\n> > (plus the payee will pay fees for both transactions as a disincentive)\n> > This concept has been around already, at least I read it somewhere.\n> \n> Yes, I think it was Joseph Poon who suggested it.  I'm keeping it in\n> reserve for the moment, in case this becomes common enough that we need\n> to code up a solution.\n\nYes, seems like something to tack on later.\n\n-- \nJoseph Poon"
            },
            {
                "author": "Pierre",
                "date": "2015-09-24T12:13:42",
                "message_text_only": "Hi Mats,\n\nI am not sure I understand what you meant, so forgive me if my answer\nis a bit off topic.\n\nLet's consider A->B->C->D->E.\n\nThe way lightning works is that A does *not* pay B, instead it locks\nthe corresponding funds in a contract that can end up two ways :\n1) B provides a secret R which means E got the funds, and the contract\nis fulfilled.\n2) a timeout occurs in which case the contract is voided. So there is\nno refund because the payment never actually took place.\n\nBut what you might have meant is that you are aware how this works,\nbut you still want a way for A to cancel the contract before the\ntimeout, in case A and E cooperate and C is unresponsive.\n\nI would say this is a bit contradictory because when A signed the\ninitial contract, it basically acknowledged the fact that it is\nwilling to take the risk to have its funds locked for at most $timeout\nif things go bad, right ? This is the essence of lightning after all.\n\nThat been said, I see two ways for A to reduce the timeout :\n- either find a shorter path (maybe even A->E)\n- or convince B/C/D to use small timeouts, maybe just a few blocks\nbetween each node. That would reduce A's timeout to a few hours, and I\ndon't see why that wouldn't work. This might be the real answer to\nyour problem, but I am certainly missing something!\n\nNow that I think of it, I actually don't know why the default timeout\nis 1 day on the original lightning presentation, that seems really\nhigh.\n\nCheers,\n\nPierre"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2015-09-24T13:24:58",
                "message_text_only": "Hey Pierre,\n\nI was mainly talking about the case where one node in the chain does\nnot relay the payment to the next node. So this is mainly about\nrecovering, such that we can finish the payment without waiting for\nthe timeout (which would piss off users so much). And this is possible\nin general. I feel I was either very unclear or you should reread my\npost again, as you just talk about timeouts (which is more of a\nlayer-0 variable than a layer-1 mitigating technique).\n\nI have discussed in\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-September/000182.html\nthat the revocation time and timeout time must be identical. I'm still\nnot sure if I am missing something, but it does seem logical. It is\nthe one drawback we have from having all outputs directly to the\nparties, instead of spending them to another set of multisig\naddresses.\nIndeed, one day payment timeout is a lot, but one day revocation time\nis quite low, as it means all parties has to check the blockchain at\nleast once a day, every day...\n\nCheers,\nMats\n\n2015-09-24 13:13 GMT+01:00 Pierre <pm+lists at acinq.fr>:\n> Hi Mats,\n>\n> I am not sure I understand what you meant, so forgive me if my answer\n> is a bit off topic.\n>\n> Let's consider A->B->C->D->E.\n>\n> The way lightning works is that A does *not* pay B, instead it locks\n> the corresponding funds in a contract that can end up two ways :\n> 1) B provides a secret R which means E got the funds, and the contract\n> is fulfilled.\n> 2) a timeout occurs in which case the contract is voided. So there is\n> no refund because the payment never actually took place.\n>\n> But what you might have meant is that you are aware how this works,\n> but you still want a way for A to cancel the contract before the\n> timeout, in case A and E cooperate and C is unresponsive.\n>\n> I would say this is a bit contradictory because when A signed the\n> initial contract, it basically acknowledged the fact that it is\n> willing to take the risk to have its funds locked for at most $timeout\n> if things go bad, right ? This is the essence of lightning after all.\n>\n> That been said, I see two ways for A to reduce the timeout :\n> - either find a shorter path (maybe even A->E)\n> - or convince B/C/D to use small timeouts, maybe just a few blocks\n> between each node. That would reduce A's timeout to a few hours, and I\n> don't see why that wouldn't work. This might be the real answer to\n> your problem, but I am certainly missing something!\n>\n> Now that I think of it, I actually don't know why the default timeout\n> is 1 day on the original lightning presentation, that seems really\n> high.\n>\n> Cheers,\n>\n> Pierre"
            }
        ],
        "thread_summary": {
            "title": "Payment and Refund Stuck",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Mats Jerratsch",
                "Pierre",
                "Joseph Poon"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 10472
        }
    },
    {
        "title": "[Lightning-dev] Minor protocol revisions.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2015-09-24T05:47:41",
                "message_text_only": "Hi all!\n\n        I know everyone's been busy, but I wanted to note some\nlightning.proto changes I just pushed.\n\n1) Close now has an second ACK stage, which means you know the close ack\n   has been received.\n2) Minor renumbering (I avoided this while it was still thrashing).\n3) HTLC rejection (eg. bad route, insufficient fees) added.\n4) HTLC precision increase, ceiling drop.\n\nThe last one deserves some discussion; I floated the idea with Taj and\nJoseph of allowing sub-satoshi HTLC amounts, and they concurred.\nAmounts get truncated on settlement of course, but they may serve us\nwell in future.\n\nAs a secondary effect, 32 bits places a ceiling of 0.04 satoshi\n(currently about $10USD) on each HTLC.  That's more than enough to cover\nthe micropayment uses of lightning, yet if you lose all your money due\nto a horrible bug in the early days, I can buy you a beer and count us\nabout even[1].  And we can change the protocol later if it becomes\noverly limiting.\n\nCheers,\nRusty.\n[1] Please do not construe this as any form of beverage-backed warranty :)"
            },
            {
                "author": "Pierre",
                "date": "2015-09-24T10:25:11",
                "message_text_only": "Hi Rusty,\n\n> 1) Close now has an second ACK stage, which means you know the close ack\n>    has been received.\nArgh, I already have trouble understanding the rationale behind all\nthe existing closing flows and states :-s Would it be possible to\npublish an updated version of the svg ? aj, any chance you could do\nthe same with your 'flat' version ?\n\n> 3) HTLC rejection (eg. bad route, insufficient fees) added.\nHow about the 'commit tx too big' case ? will that just be an error ?\n\n> As a secondary effect, 32 bits places [an upper bound of 0.04 BTC]\n> (currently about $10USD) on each HTLC.  That's more than enough to cover\n> the micropayment uses of lightning, yet if you lose all your money due\n> to a horrible bug in the early days, I can buy you a beer and count us\n> about even[1].  And we can change the protocol later if it becomes\n> overly limiting.\nSuch a low ceiling bothers me a little bit, because it kind of states\nthat the micropayment use case is the primary target. Is it ? To me,\nscalability and speed are the most interesting properties of\nlightning. I would have preferred a higher (1 BTC ?) limit, but I\nunderstand this can be changed. Regarding the risk of bugs, you can't\nloose more than the channel capacity so that's another parameter we\ncan play with I guess.\n\nCheers,\n\nPierre"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-25T01:11:02",
                "message_text_only": "Pierre <pm+lists at acinq.fr> writes:\n> Hi Rusty,\n>\n>> 1) Close now has an second ACK stage, which means you know the close ack\n>>    has been received.\n> Argh, I already have trouble understanding the rationale behind all\n> the existing closing flows and states :-s Would it be possible to\n> publish an updated version of the svg ? aj, any chance you could do\n> the same with your 'flat' version ?\n\nHeh, this one is pretty easy.  It's just an ack at the end of the\nmutual close handshake:\n\n    close_channel\n    close_channel_complete\n    close_channel_ack (this is new).\n\n>> 3) HTLC rejection (eg. bad route, insufficient fees) added.\n> How about the 'commit tx too big' case ? will that just be an error ?\n\nA protocol error: you should never propose a HTLC which will cause the\ncommit tx to be malformed.\n\n>> As a secondary effect, 32 bits places [an upper bound of 0.04 BTC]\n>> (currently about $10USD) on each HTLC.  That's more than enough to cover\n>> the micropayment uses of lightning, yet if you lose all your money due\n>> to a horrible bug in the early days, I can buy you a beer and count us\n>> about even[1].  And we can change the protocol later if it becomes\n>> overly limiting.\n\n> Such a low ceiling bothers me a little bit, because it kind of states\n> that the micropayment use case is the primary target. Is it ? To me,\n> scalability and speed are the most interesting properties of\n> lightning.\n\nI think the early adopters are going to be microtransactions.  And\nthey're good to have: they build the network, stress-test us, and let us\nlearn without risking too much.\n\n> I would have preferred a higher (1 BTC ?) limit, but I\n> understand this can be changed. Regarding the risk of bugs, you can't\n> loose more than the channel capacity so that's another parameter we\n> can play with I guess.\n\nMy reference implementation refuses to create a channel which would\noverflow this.  That was a simple check to implement (we already check\nthat no HTLC would spend more than channel capacity of course).\n\nI use 64 bits internally, to avoid wrap issues anyway.\n\nMy general philosophy here is to underpromise, and over-deliver.  I\ncan't talk to all the users individually, but if we set *our*\nexpectations at \"beer money, not rent money\" that will hopefully spread.\n\nI recommend reading one of the \"I was Goxxed\" reddit threads for some\nheartbreaking perspective on what happens when innocent people get\ncaught up in hype :(\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-29T06:47:40",
                "message_text_only": "On Thu, Sep 24, 2015 at 12:25:11PM +0200, Pierre wrote:\n> > 1) Close now has an second ACK stage, which means you know the close ack\n> Argh, I already have trouble understanding the rationale behind all\n> the existing closing flows and states :-s Would it be possible to\n> publish an updated version of the svg ? aj, any chance you could do\n> the same with your 'flat' version ?\n\nYeah. I've updated state.py so the following flow works:\n\n $ test/test_state_coverage --dump-states | tee STATES\n $ ./state.py  > update.dot\n $ dot -Tsvg update.dot > update.svg\n\nstate.py is at https://github.com/ajtowns/lightning/blob/state/state.py\n\nUpdated svg is viewable at\n\nhttp://azure.erisian.com.au/~aj/tmp/lightstate/simplified-states-20150929.svg\n\nNote that some transitions are still missing, notably\nPKT_UPDATE_DECLINE_HTLC.\n\n(I'm not following why the state coverage testing doesn't do something\nmore like:\n\n   states = []\n   path_to_state = {}\n   for s in init_states:\n        path_to_states[s] = [s]\n        states.append(s)\n\n   i = 0\n   while i < len(states):\n       tst_state = states[i]\n       p = path_to_states[tst_state]\n\n       for in_pkt in all_packets:\n           # enter test state\n           simulation_init(p[0])\n           for setup_pkt in p[1:]:\n               simulation_send_pkt(setup_pkt)\n\n           # send packet\n           new_state, response_pkt = simulation_send_pkt(in_pkt)\n\n           # document result\n           dump_transition(tst_state, in_pkt, new_state, response_pkt)\n\n           # if new state, add it to list to test\n           if new_state not in states:\n               path_to_state[new_state] = p + [in_pkt]\n               states.append(new_state)\n\nie, for every state, throw every packet at it and record what happens;\nassuming that any given state behaves the same no matter how you get\ninto it)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-30T01:41:09",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Thu, Sep 24, 2015 at 12:25:11PM +0200, Pierre wrote:\n>> > 1) Close now has an second ACK stage, which means you know the close ack\n>> Argh, I already have trouble understanding the rationale behind all\n>> the existing closing flows and states :-s Would it be possible to\n>> publish an updated version of the svg ? aj, any chance you could do\n>> the same with your 'flat' version ?\n>\n> Yeah. I've updated state.py so the following flow works:\n>\n>  $ test/test_state_coverage --dump-states | tee STATES\n>  $ ./state.py  > update.dot\n>  $ dot -Tsvg update.dot > update.svg\n>\n> state.py is at https://github.com/ajtowns/lightning/blob/state/state.py\n>\n> Updated svg is viewable at\n>\n> http://azure.erisian.com.au/~aj/tmp/lightstate/simplified-states-20150929.svg\n>\n> Note that some transitions are still missing, notably\n> PKT_UPDATE_DECLINE_HTLC.\n>\n> (I'm not following why the state coverage testing doesn't do something\n> more like:\n>\n>    states = []\n>    path_to_state = {}\n>    for s in init_states:\n>         path_to_states[s] = [s]\n>         states.append(s)\n>\n>    i = 0\n>    while i < len(states):\n>        tst_state = states[i]\n>        p = path_to_states[tst_state]\n>\n>        for in_pkt in all_packets:\n>            # enter test state\n>            simulation_init(p[0])\n>            for setup_pkt in p[1:]:\n>                simulation_send_pkt(setup_pkt)\n>\n>            # send packet\n>            new_state, response_pkt = simulation_send_pkt(in_pkt)\n>\n>            # document result\n>            dump_transition(tst_state, in_pkt, new_state, response_pkt)\n>\n>            # if new state, add it to list to test\n>            if new_state not in states:\n>                path_to_state[new_state] = p + [in_pkt]\n>                states.append(new_state)\n>\n> ie, for every state, throw every packet at it and record what happens;\n> assuming that any given state behaves the same no matter how you get\n> into it)\n\nSure, but that's not even close to exhaustive testing (drawing diagrams\nwas just a side-effect for me).\n\nUnfortunately the state doesn't quite encapsulate everything.  For\nexample, it captures whether you have HTLCs or not, but not whether you\nhave more than one.\n\nYou also want to simulate a pair, and make sure you cover all\ncombinations of states between the two.\n\nYou also need to take into account what non-packet events are possible\n(eg. timeouts, bitcoin watch events).\n\nFinally, you want to inject errors.\n\nAnyway, the final result (requiring about 14.5GB of memory to run,\nthough it should be fairly swap-friendly) has now been pushed.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-30T04:07:59",
                "message_text_only": "On Wed, Sep 30, 2015 at 11:11:09AM +0930, Rusty Russell wrote:\n> > (I'm not following why the state coverage testing doesn't do something\n> > more like: [...]\n> Sure, but that's not even close to exhaustive testing (drawing diagrams\n> was just a side-effect for me).\n\nAbsolutely. But... I'm not seeing what the code actually /does/ with the\nexhaustive testing? There's a lot of asserts; but I'm not sure that's\nactually testing things \"make sense\" or just \"don't crash\". Maybe having\nsome optional output of traces for successful test cases would make it\nmore obvious?\n\neg, (and I haven't tried pulling the code apart to really understand\nit or anything) I can't tell if you're testing agreeing on two HTLCs then\nhaving the first one time out, versus the second one time out first.\n\nHmm:\n\n          report_trail(&t, \"CLOSED with htlc in progress?\");\n\nI figured that was expected and normal protocol behaviour? Not ideal,\nbut if you're still communicating at all, if someone decides the channel\nhas to be closed, it's still always better to do a mutual close to\navoid the CSV delays and any unnecessarily elevated fees, even with\noutstanding HTLCs.\n\nThat would mean CLOSE should start tracking HTLCs (and spending when\ntimeouts hit or R's become known) just like when a commitment is\npublished; so I guess that's CLOSE_WAIT_HTLCs?\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-30T04:16:24",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> On Wed, Sep 30, 2015 at 11:11:09AM +0930, Rusty Russell wrote:\n>> > (I'm not following why the state coverage testing doesn't do something\n>> > more like: [...]\n>> Sure, but that's not even close to exhaustive testing (drawing diagrams\n>> was just a side-effect for me).\n>\n> Absolutely. But... I'm not seeing what the code actually /does/ with the\n> exhaustive testing? There's a lot of asserts; but I'm not sure that's\n> actually testing things \"make sense\" or just \"don't crash\". Maybe having\n> some optional output of traces for successful test cases would make it\n> more obvious?\n\nMore comments and more testing would be nice, but at some point I have\nto stop writing tests :)\n\nTests are (with varying degrees of thoroughness):\n\n1) State machine never gets into an invalid state.\n2) State machine never sends a packet other side doesn't expect.\n3) State machine terminates if not on main loop.\n4) State machine does not deadlock (both sides waiting, none sending).\n5) State machine cleans up.\n\n> eg, (and I haven't tried pulling the code apart to really understand\n> it or anything) I can't tell if you're testing agreeing on two HTLCs then\n> having the first one time out, versus the second one time out first.\n>\n> Hmm:\n>\n>           report_trail(&t, \"CLOSED with htlc in progress?\");\n>\n> I figured that was expected and normal protocol behaviour? Not ideal,\n> but if you're still communicating at all, if someone decides the channel\n> has to be closed, it's still always better to do a mutual close to\n> avoid the CSV delays and any unnecessarily elevated fees, even with\n> outstanding HTLCs.\n\nSTATE_CLOSED here means \"completely finished\".\n\nBut also, we don't support mutual close with outstanding HTLCs.  We\ncould, but the protocol is complex enough already.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2015-09-24T11:54:02",
                "message_text_only": "On Thu, Sep 24, 2015 at 03:17:41PM +0930, Rusty Russell wrote:\n> 4) HTLC precision increase, ceiling drop.\n> As a secondary effect, 32 bits places a ceiling of 0.04 satoshi\n> (currently about $10USD) on each HTLC.\n\nThis means keeping the channel balances in 64 bit counters, right?\n\nI was thinking along the following lines:\n\n - bitcoin txns have absolute fees (currently f = 0.1 mBTC)\n - lightning has percentage fees (call it p)\n - so breakeven point is a transaction amount A, where\n   A * p = f; ie A = f/p\n - p should be less than 2%, putting a lower limit on A of 5 mBTC,\n   but 0.04 BTC = 40 mBTC, which is well above that.\n - if A = 0.04 BTC, p = f/A = 0.25%, putting a lower limit on lightning\n   fees (that's for the entire path, individual hops could be lower)\n\nI probably would have preferred capping out at about 0.1 BTC (~$23),\ncorresponding to lightning fees of 0.1% matching bitcoin fees of 0.1 mBTC,\nbut that's quibbling.\n\nAnyway, if you want to send more than $10 via lightning you just do\nmultiple transactions with different R values [0], the same way you\nmight use two $20 notes to pay someone $40. Even $1000 would just be\n100 transactions, which doesn't seem like too big a deal?\n\nHaving a small maximum is probably also useful for routing -- if you want\nto send two $10 notes, send them along different routes to avoid draining\nany particular channel. That also helps obscure how much is being spent.\n\nA maximum seems pretty helpful for planning how to fund a node too --\nif you know no individual transaction will be more than 0.04 BTC, you\ncan setup your fee schedule in 0.04 BTC increments (or greater), and\nnot have to worry about \"if i got 30 mBTC I'd raise my fee before the\nnext 30 mBTC came in; but here's 60 mBTC in one hop with just 2x the\nlower fee! do I accept it or reject it?\"\n\nSo, hey, turns out I totally endorse this change. +1.\n\nCheers,\naj\n\n[0] or just rely on the different S values the R/S method for avoiding\n    onion probing would automatically use"
            },
            {
                "author": "Rusty Russell",
                "date": "2015-09-25T00:27:35",
                "message_text_only": "Rusty Russell <rusty at rustcorp.com.au> writes:\n> As a secondary effect, 32 bits places a ceiling of 0.04 satoshi\n\nThanks for everyone who pointed out that bitcoin has not jumped\nin value by a factor of 10^8.\n\nThis should indeed be 0.04 BTC :)\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Minor protocol revisions.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Pierre"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 14698
        }
    },
    {
        "title": "[Lightning-dev] Per-hop forwarding fees",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2015-09-24T08:31:21",
                "message_text_only": "Hi all,\n\nSo as was discussed last month [0] there's a potential incentive problem\nif fees are only paid on success: you can lock up someone else's funds for\n\"TIMEOUT\" and pay them nothing, just by routing a payment to someone who\nwon't either collect it, or redeem it. As an alternative to fines [1]\nI think it's possible to offer fees directly for forwarding a transaction.\n\nSuppose you have an onion wrapped routing message, and want to send N\nbitcoins to Dave via Alice, Bob and Carol. Alice receives message MA,\nBob receives MB, etc. Alice wants \"a\" in fees, Bob wants \"b\" in fees,\netc. Then you setup HTLCs paying A as follows:\n\n  \"c/2+n\"   bitcoins payable on receipt of R\n  \"c/2+b/2\" bitcoins payable on receipt of #(MD)\n  \"b/2+a/2\" bitcoins payable on receipt of #(MC)\n  \"a/2\"     bitcoins payable on receipt of #(MB)\n\nAlice forwards MB to Bob (encrypted), and asks if Bob is able to determine\nwhat hashes to #(#(MB)). Bob calculates #(MB) and #(#(MB)) and gives an\nack or nak -- if there's a nak, Alice aborts the transaction. If it's\nan ack, Bob begins updating the commitments to add (c/2+n), (c/2+b/2),\n(b/2) HTLCs with Alice payable to Bob, and provides #(#(MB)) to Alice,\nallowing her to collect the first half of her fee.\n\nThis then repeats for Bob/Carol and Carol/Dave.\n\nThis lets nodes get paid upfront (when they forward the transaction,\nrather than when the transaction eventually completes), including for\nfailing transactions, but requires them to actually do 90% of the work\nforwarding the transaction (Alice can abort accepting the HTLCs with\nBob, but Alice will miss out on half her fee, and Bob will know Alice\nis cheating him out of \"b\" bitcoins at that point, and can close the\nchannel as punishment). It also gives the payer some progress information\non how the transaction is doing (the \"a\" transaction should be finished\nshortly after the transaction has made it to Bob, etc).\n\nDownsides: it's complicated and multiplies the number of HTLCs you have\nto deal with, and it (at least somewhat) reveals the length of the route.\n\n(If incremental fines work out, I think they're probably a better way\nof dealing with delayed acceptance of transactions. Still, maybe this\nturns out to be useful/interesting anyway...)\n\nCheers,\naj\n\n[0] http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000135.html\n\n[1]\nhttp://lists.linuxfoundation.org/pipermail/lightning-dev/2015-August/000158.html"
            }
        ],
        "thread_summary": {
            "title": "Per-hop forwarding fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2424
        }
    },
    {
        "title": "[Lightning-dev] \"Locktime\" featurepack review",
        "thread_messages": [
            {
                "author": "Btc Drak",
                "date": "2015-09-24T21:30:08",
                "message_text_only": "As you are aware there are some ongoing pull requests to introduce support\nof relative CLTV into Bitcoin Core. There have been some modifications made\naccording to feedback over the last couple of months and the PRs are ready\nfor what looks like the final round of reviews.\n\nPlease could you review and test the following PRs and give your\nfeedback/ACKs where appropriate.\n\nBIP-68: Mempool-only sequence number constraint verification\nhttps://github.com/bitcoin/bitcoin/pull/6312\n\nMempool-only CHECKSEQUENCEVERIFY\nhttps://github.com/bitcoin/bitcoin/pull/6564\n\nMempool-only Median time-past as endpoint for lock-time calculations\nhttps://github.com/bitcoin/bitcoin/pull/6566\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20150924/36bd6c26/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "\"Locktime\" featurepack review",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Btc Drak"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 863
        }
    }
]