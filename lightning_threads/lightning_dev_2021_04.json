[
    {
        "title": "[Lightning-dev] Lightning Network Protocol Suite Diagram - Request for feedback",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2021-04-06T17:23:34",
                "message_text_only": "Dear fellow Lightning Developers,\n\nas you all probably know Andreas, Roasbeef and I are working on writing the\nbook \"Mastering the Lightning Network\" and I am happy to say that there has\nbeen quite some progress over the last 18 months. In Particular it lead to\na diagram of the Lightning Network Protocol Suite which is the reason I am\nsending this email. We would love to have your feedback and criticism (not\non my little design skills but on the content!). You can find the diagram\nat:\n\nhttps://commons.wikimedia.org/wiki/File:Lightning_Network_Protocol_Suite.png\n\nAs a Wikipedia Contributor I shared the current Version on Wikimedia\ncommons where the Diagram can easily be updated but the link will stay the\nsame as they also allow version control of files. Eventually I am happy to\nopen a PR and add this to BOLT 0 or the Readme of the lightning-rfc. But\nfirst we would welcome and encourage your feedback and discussion.\nEspecially the naming of some layers are somewhat novel but also the labels\nfor the boxes and the geometry and semantics of the boxes themselves.\n\nTo give you some context: As you know the BOLTs are somewhat linked and\nintermixed. For example BOLT2 describes the channel state machine with the\nHTLCs which is mainly needed for routing, BOLT 07 is named gossip routing\nthough the main onion routing is happening in BOLT 04, ... I am not saying\nthat such things would be wrong. However I made the experience that those\niterdependencies can sometimes be a bit confusing when introducing the\nprotocol to new people.\n\nConsequently this lead to plenty of internal discussions which we concluded\nby deciding that we need an architecture diagram for the Lightning Network.\nAfter a couple internal iterations we believe it is time to present our\ncurrent diagram to the community and hope to get even more feedback before\nwe `fix` it and use it also as a guide for some of the chapters in the\nbook. You can see a part of our discussions and previous versions on github\nhttps://github.com/lnbook/lnbook/issues/342\n\nAlso please note that BOLT 03 and BOLT 5 which is the Bitcoin stuff is\ncurrently not part of the diagram at all.\n\nwith kind Regards Rene\n\n\n\n-- \nhttps://www.rene-pickhardt.de\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210406/d796f6a1/attachment.html>"
            },
            {
                "author": "Elliot Heitman",
                "date": "2021-04-06T22:09:59",
                "message_text_only": "Hi,\n\nIt's great to have someone working on such an important project for\nadoption. Great work. I haven't spent much time on lightning so you can\ntemper my suggestions down with my lack of experience.\n\nThe diagram is interesting as a specification to layer mapping. My\nunderstanding is that BOLTs are specifications in neat categories but they\ndon't articulate the full protocol scope. So it's interesting to have the\nmapping but there are categories on the diagram that aren't sitting within\na BOLT. So the question is, can these categories fit within a BOLT (e.g.\nvia adding scope to a BOLT) or is there a better categorisation for\nprotocol for the diagram (noting that this could also have a BOLT mapping\nfor completeness)? My suggestions for other categorisations would be\nfunctional, similar to the intro into lightning (the spark) where it almost\narticulates the functional components.\n\nIt's not an easy task. But, it will be very valuable once complete.\n\nRegards,\n\nElliot\n\nOn Wed, 7 Apr 2021, 03:23 Ren\u00e9 Pickhardt via Lightning-dev, <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Dear fellow Lightning Developers,\n>\n> as you all probably know Andreas, Roasbeef and I are working on writing\n> the book \"Mastering the Lightning Network\" and I am happy to say that there\n> has been quite some progress over the last 18 months. In Particular it lead\n> to a diagram of the Lightning Network Protocol Suite which is the reason I\n> am sending this email. We would love to have your feedback and criticism\n> (not on my little design skills but on the content!). You can find the\n> diagram at:\n>\n>\n> https://commons.wikimedia.org/wiki/File:Lightning_Network_Protocol_Suite.png\n>\n> As a Wikipedia Contributor I shared the current Version on Wikimedia\n> commons where the Diagram can easily be updated but the link will stay the\n> same as they also allow version control of files. Eventually I am happy to\n> open a PR and add this to BOLT 0 or the Readme of the lightning-rfc. But\n> first we would welcome and encourage your feedback and discussion.\n> Especially the naming of some layers are somewhat novel but also the\n> labels for the boxes and the geometry and semantics of the boxes\n> themselves.\n>\n> To give you some context: As you know the BOLTs are somewhat linked and\n> intermixed. For example BOLT2 describes the channel state machine with the\n> HTLCs which is mainly needed for routing, BOLT 07 is named gossip routing\n> though the main onion routing is happening in BOLT 04, ... I am not saying\n> that such things would be wrong. However I made the experience that those\n> iterdependencies can sometimes be a bit confusing when introducing the\n> protocol to new people.\n>\n> Consequently this lead to plenty of internal discussions which we\n> concluded by deciding that we need an architecture diagram for the\n> Lightning Network. After a couple internal iterations we believe it is time\n> to present our current diagram to the community and hope to get even more\n> feedback before we `fix` it and use it also as a guide for some of the\n> chapters in the book. You can see a part of our discussions and previous\n> versions on github https://github.com/lnbook/lnbook/issues/342\n>\n> Also please note that BOLT 03 and BOLT 5 which is the Bitcoin stuff is\n> currently not part of the diagram at all.\n>\n> with kind Regards Rene\n>\n>\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210407/729658b9/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning Network Protocol Suite Diagram - Request for feedback",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Elliot Heitman"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6151
        }
    },
    {
        "title": "[Lightning-dev] Questions on lightning chan closure privacy",
        "thread_messages": [
            {
                "author": "Mr. Lee Chiffre",
                "date": "2021-04-16T02:11:23",
                "message_text_only": "> Two, if the balances of each side of a\n> channel are different when closing vs. opening, can someone determine\n> which output from the 2 of 2 multisig belongs to who?\n\n\nA thought to add to my last email. In theory it could be determined if the\noutput belonging to a certain node later uses that as an input for a non\nprivate chan opening right? But that would also look the same if it was\nalso the same user opening a new chan to that node?\n\nThis brings to another question. Not just chan closure but on chan opening\nis it possible to determine which input came from who?"
            },
            {
                "author": "Mr. Lee Chiffre",
                "date": "2021-04-16T02:06:01",
                "message_text_only": "When opening and closing channels on lightning it involves 2 of 2 multisig\nbitcoin addresses. I have two questions. One, if it is a private lightning\nchannel can someone who is analyzing the transaction details of the 2 of 2\nmultisig address when the chan is being opened or closed, determine what\nlightning node it belongs to? Two, if the balances of each side of a\nchannel are different when closing vs. opening, can someone determine\nwhich output from the 2 of 2 multisig belongs to who?\n\nRandom people connect to my lightning node with private channels\nfrequently including myself. Does a few transactions then closes the\nchannel. Somestimes I even open a chan to the lightning network and make\npayments to myself to one of my my other chans (sometimes private,\nsometimes not) before closing.\n\nDepending on the answer to my questions, lightning be used sort of like a\nfancy payjoin network by mixing the cluster of my coin history with users\nof my nodes along with that of the nodes I open and close chans to?\n\nCould someone mix their bitcoin by such activity of opening and closing\nprivate chans to random nodes after sending some amount to their other\nchans (or maybe reverse submarine swap) before closing?\n\nPlease CC me when replying so I get a copy.\n\n-- \nlee.chiffre at secmail.pro\nPGP 97F0C3AE985A191DA0556BCAA82529E2025BDE35"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-04-18T05:05:50",
                "message_text_only": "Hi Lee,\n\nYou are touching on some very relevant privacy challenges for lightning. To\nyour questions:\n\n1. Is it possible to identify which node funded a lightning channel? (this\ntells you who owns the change output)\n2. Is it possible to identify who owns which channel close output?\n\nI think that the answer to both these questions hinges on whether you\nexclusively use private channels. If you fund private and public channels\nwith the same wallet then it may be possible to identify your private\nchannels and the owner of the channel and channel close outputs[1].\nI've recently tried to describe what I think needs to happen to turn\nlightning into an effective layer-1 privacy tool in the \"Removing\ncross-layer links\" problem on bitcoin-problems.github.io[2].\n\nCheers\n\nLL\n\n[1] https://arxiv.org/pdf/2003.12470.pdf (section 3.2).[2]\nhttps://bitcoin-problems.github.io/problems/removing-cross-layer-links.html\n[2]\nhttps://bitcoin-problems.github.io/problems/removing-cross-layer-links.html\n\nOn Sat, 17 Apr 2021 at 12:22, Mr. Lee Chiffre <lee.chiffre at secmail.pro>\nwrote:\n\n>\n> > Two, if the balances of each side of a\n> > channel are different when closing vs. opening, can someone determine\n> > which output from the 2 of 2 multisig belongs to who?\n>\n>\n> A thought to add to my last email. In theory it could be determined if the\n> output belonging to a certain node later uses that as an input for a non\n> private chan opening right? But that would also look the same if it was\n> also the same user opening a new chan to that node?\n>\n> This brings to another question. Not just chan closure but on chan opening\n> is it possible to determine which input came from who?\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210418/eaf2a040/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Questions on lightning chan closure privacy",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Mr. Lee Chiffre",
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3957
        }
    },
    {
        "title": "[Lightning-dev] Replacement of invoices to handle stuck payments.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-04-16T05:59:50",
                "message_text_only": "Hi all,\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/798/commits/fc8aab72ccdd616301dc200fc124824efe4fbb58\n\nI've just added a simple addition to the proposed BOLT 12 offers spec,\nwhere invoice requests can ask to obsolete old invoices.  This allows a\nsimple workaround in the case where a payment is stuck: the vendor\ncommits to a new invoice which obsoletes the old one, using the\nalready-existing invoice_request message.\n\n        If the vendor cheats and accepts both old and new payments, you\ncan prove they lied.  Or they can return an error which indicates\nthey've already received the payment and it's simply the return which is\nstuck.\n\nEither way, it's now simple to implement, and gives wallets another\noption for handling these cases.\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Replacement of invoices to handle stuck payments.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 778
        }
    },
    {
        "title": "[Lightning-dev] Recovery of Lightning channels without backups",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-04-20T00:53:26",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> On Wed, Dec 9, 2020 at 4:26 PM Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>>\n>> Say r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n>>\n>> Nice work.  This would be a definite recovery win.  We should add this\n>> to the DF spec, because Lisa was almost finished implmenting it, so it's\n>> clearly due for a change!\n>>\n>\n> Yes that's certainly a fine way to do it.\n> I was also thinking you could eliminate all \"basepoints\" (not just funding\n> pubkey) using something like this. i.e. just use the node pubkey as the\n> \"basepoint\" for everything and randomize it using the shared secret for\n> each purpose.\n\nOK, I tried to spec this out, to implement it.  One issue is that you\nnow can't sign the commitment_tx (or htlc_tx) without knowing the node's\nsecret key (or, equivalently, knowing the tweaked key and being able to\nuse the derivation scheme to untweak it).\n\nc-lightning currently does a round-trip to the signing daemon for this\nalready, but it'd be nice to avoid requiring it.\n\nSo I somewhat reluctantly added `commit_basepoint` from which the others\nare derived: an implementation can use some hardened derivation from its\nprivkey (e.g. SHA256(node_privkey || ss || counter)) to create\nthis in a deterministic but still private manner.\n\nOr we could just leave all the other points in and just replace\nfunding_pubkey.\n\nCheers,\nRusty."
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-04-20T04:09:54",
                "message_text_only": "Hi Rusty,\n\nOn Tue, 20 Apr 2021 at 10:55, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> > On Wed, Dec 9, 2020 at 4:26 PM Rusty Russell <rusty at rustcorp.com.au>\n> wrote:\n> >\n> >>\n> >> Say r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n> >>\n> >> Nice work.  This would be a definite recovery win.  We should add this\n> >> to the DF spec, because Lisa was almost finished implmenting it, so it's\n> >> clearly due for a change!\n> >>\n> >\n> > Yes that's certainly a fine way to do it.\n> > I was also thinking you could eliminate all \"basepoints\" (not just\n> funding\n> > pubkey) using something like this. i.e. just use the node pubkey as the\n> > \"basepoint\" for everything and randomize it using the shared secret for\n> > each purpose.\n>\n> OK, I tried to spec this out, to implement it.  One issue is that you\n> now can't sign the commitment_tx (or htlc_tx) without knowing the node's\n> secret key (or, equivalently, knowing the tweaked key and being able to\n> use the derivation scheme to untweak it).\n>\n\nUsing node secret key to sign the commitment_tx seems like something you\nwill have to accept to introduce this feature. For the idea to work it has\nto be some public key that is known by others and gossiped through the\nnetwork. Of course you could extend the information that is gossiped about\na node to include a \"commit_tx_point\" but the nodeid seems the more natural\nchoice.\n\n\n> c-lightning currently does a round-trip to the signing daemon for this\n> already, but it'd be nice to avoid requiring it.\n>\n> So I somewhat reluctantly added `commit_basepoint` from which the others\n> are derived: an implementation can use some hardened derivation from its\n> privkey (e.g. SHA256(node_privkey || ss || counter)) to create\n> this in a deterministic but still private manner.\n>\n> Or we could just leave all the other points in and just replace\n> funding_pubkey.\n>\n\nAnother approach is to do things in \"soft-fork\" like manner.\nEach node that wants to offer this feature sets their funding_pubkey to a\nspecified DH tweak of the nodeid. Nodes that want backup-free channel\nrecovery can just refuse to carry on the funding protocol if the\nfunding_pubkey is not set the way it wanted.\n\n>From my pruisit crypto point of view having only one public key is nice but\nI'm not sure how it impacts things architecturally and other protocols like\nwatchtowers.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210420/65f16c10/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-20T04:52:01",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> Hi Rusty,\n>\n> On Tue, 20 Apr 2021 at 10:55, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n>> > On Wed, Dec 9, 2020 at 4:26 PM Rusty Russell <rusty at rustcorp.com.au>\n>> wrote:\n>> >\n>> >>\n>> >> Say r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n>> >>\n>> >> Nice work.  This would be a definite recovery win.  We should add this\n>> >> to the DF spec, because Lisa was almost finished implmenting it, so it's\n>> >> clearly due for a change!\n>> >>\n>> >\n>> > Yes that's certainly a fine way to do it.\n>> > I was also thinking you could eliminate all \"basepoints\" (not just\n>> funding\n>> > pubkey) using something like this. i.e. just use the node pubkey as the\n>> > \"basepoint\" for everything and randomize it using the shared secret for\n>> > each purpose.\n>>\n>> OK, I tried to spec this out, to implement it.  One issue is that you\n>> now can't sign the commitment_tx (or htlc_tx) without knowing the node's\n>> secret key (or, equivalently, knowing the tweaked key and being able to\n>> use the derivation scheme to untweak it).\n>>\n>\n> Using node secret key to sign the commitment_tx seems like something you\n> will have to accept to introduce this feature. For the idea to work it has\n> to be some public key that is known by others and gossiped through the\n> network. Of course you could extend the information that is gossiped about\n> a node to include a \"commit_tx_point\" but the nodeid seems the more natural\n> choice.\n\nDuh, yes, of course you need the funding_key secret to sign the\ncommitment tx.\n\nBut you really don't want to access the `remote_pubkey` (which in a\nmodern option_static_remotekey world is simply the payment_basepoint).\nIt's generally considered good practice *not* to have this accessible to\nyour lightning node at all.\n\n>> c-lightning currently does a round-trip to the signing daemon for this\n>> already, but it'd be nice to avoid requiring it.\n>>\n>> So I somewhat reluctantly added `commit_basepoint` from which the others\n>> are derived: an implementation can use some hardened derivation from its\n>> privkey (e.g. SHA256(node_privkey || ss || counter)) to create\n>> this in a deterministic but still private manner.\n>>\n>> Or we could just leave all the other points in and just replace\n>> funding_pubkey.\n>>\n>\n> Another approach is to do things in \"soft-fork\" like manner.\n> Each node that wants to offer this feature sets their funding_pubkey to a\n> specified DH tweak of the nodeid. Nodes that want backup-free channel\n> recovery can just refuse to carry on the funding protocol if the\n> funding_pubkey is not set the way it wanted.\n\nYeah, you can totally do this in an opt-in manner, except it doesn't\nwork unless your peer does it too.  Since we expect everyone to want to\ndo this, it's clearer to force everyone to calculate this and not have\nredundant and confusing fields in the message.\n\n>>From my pruisit crypto point of view having only one public key is nice but\n> I'm not sure how it impacts things architecturally and other protocols like\n> watchtowers.\n\nThey can operate exactly like the existing scheme, AFAICT.\n\nHere's the spec diff (based on dual-funding, since it's easier to simply\nhard change).  Please check my EC math! :)\n\ndiff --git a/02-peer-protocol.md b/02-peer-protocol.md\nindex fbc56c8..1114068 100644\n--- a/02-peer-protocol.md\n+++ b/02-peer-protocol.md\n@@ -867,11 +867,9 @@ This message initiates the v2 channel establishment workflow.\n    * [`u16`:`to_self_delay`]\n    * [`u16`:`max_accepted_htlcs`]\n    * [`u32`:`locktime`]\n-   * [`point`:`funding_pubkey`]\n+   * [`u64`:`generation`]\n    * [`point`:`revocation_basepoint`]\n    * [`point`:`payment_basepoint`]\n-   * [`point`:`delayed_payment_basepoint`]\n-   * [`point`:`htlc_basepoint`]\n    * [`point`:`first_per_commitment_point`]\n    * [`byte`:`channel_flags`]\n    * [`opening_tlvs`:`tlvs`]\n@@ -895,13 +893,16 @@ If nodes have negotiated `option_dual_fund`:\n \n The sending node:\n   - MUST set `funding_feerate_perkw` to the feerate for this transaction\n-  - MUST ensure `temporary_channel_id` is unique from any\n-    other channel ID with the same peer.\n+  - MUST set `generation` to a number greater than any previous\n+    `generation` it has sent to this receiving node which has reached\n+    `commitment_signed`.\n+  - SHOULD set `generation` to the lowest number which meets this requirement.\n \n The receiving node:\n   - MAY fail the negotiation if:\n     - the `locktime` is unacceptable\n     - the `funding_feerate_per_kw` is unacceptable\n+    - the `generation` exceeds expectation by more than the maximum it would scan for recovery.\n \n #### Rationale\n `channel_id` for the `open_channel2` MUST be derived using a zero-d out\n@@ -926,6 +927,13 @@ Instead, the channel reserve is fixed at 1% of the total channel balance\n rounded down to the nearest whole satoshi or the `dust_limit_satoshis`,\n whichever is greater.\n \n+`generation` is a number which is used to generate the points used for\n+this pair of peers, with the aim of allowing automatic onchain\n+scanning for channels if all other information is lost.  Since this\n+scan would presumably only try a limited number of generations, it is\n+best if this number is low, but it also needs to change for each\n+successive channel between the peers, to avoid obvious fingerprinting.\n+\n Note that `push_msat` has been omitted.\n \n ### The `accept_channel2` Message\n@@ -943,11 +951,9 @@ acceptance of the new channel.\n     * [`u32`:`minimum_depth`]\n     * [`u16`:`to_self_delay`]\n     * [`u16`:`max_accepted_htlcs`]\n-    * [`point`:`funding_pubkey`]\n+    * [`u64`:`generation`]\n     * [`point`:`revocation_basepoint`]\n     * [`point`:`payment_basepoint`]\n-    * [`point`:`delayed_payment_basepoint`]\n-    * [`point`:`htlc_basepoint`]\n     * [`point`:`first_per_commitment_point`]\n     * [`accept_tlvs`:`tlvs`]\n \n@@ -967,6 +973,10 @@ additions.\n \n The accepting node:\n     - MAY respond with a `funding_satoshis` value of zero.\n+    - MUST set `generation` to a number greater than any previous\n+      `generation` it has sent to this receiving node which has reached\n+      `commitment_signed`.\n+    - SHOULD set `generation` to the lowest number which meets this requirement.\n \n #### Rationale\n \n@@ -985,6 +995,31 @@ Funding composition for channel establishment v2 makes use of the\n [Interactive Transaction Construction](#interactive-transaction-construction)\n protocol, with the following additional caveats.\n \n+#### Point Derivation\n+\n+The `funding_pubkey` and basepoints are derived from the two\n+`node_id`s and the higher of the two `generation` values; the\n+`payment_basepoint` is supplied directly.\n+\n+Derivation is done as follows:\n+\n+1. Start with two node ids, `N1` and `N2` (`N1` is the lesser of the\n+   two SEC1-encoded compressed public keys, `N2` the greater).\n+2. Derive a shared secret, `SS`, using ECDH on `N1` and `N2`.\n+3. Define tweaks `T` for each peer, using `SHA256(SS || generation || node_id || name)`, where:\n+   1. `generation` is the `u64` larger of the two `generation` fields from `open_channel2` and `accept_channel2`.\n+   2. `node_id` is the SEC1-encoded compressed public key of the peer.\n+   3. `name` is a non-terminated ASCII string, e.g. `htlc` is the four bytes\n+   `0x68 0x74 0x6C 0x63`\n+4. The `funding_pubkey` is defined as the `node_id` + G*T(`funding`).\n+5. The `delayed_payment_basepoint` is defined as `node_id` + G*T(`delayed_payment`).\n+6. The `htlc_basepoint` is defined as the `node_id` + G*T(`htlc`).\n+\n+If the secret for `payment_basepoint` is derived in a similar manner,\n+it too can be easily recovered from just the `generation`, node key\n+and peer `node_id`.  However, it may also point to an address for a\n+completely separate system (e.g. cold storage), so it is specified\n+explicitly in the protocol.\n \n #### The `tx_add_input` Message"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-23T04:29:30",
                "message_text_only": "OK, I'm now leaning *against* this method.\n\n1. It removes the ability to update a channel without access to the node's\n   secret key.  At the moment the node secret key is only needed for\n   gossip and to DH to set up a new peer connection.  c-lightning does\n   not use this for now (we keep the per-channel keys in the HSM too),\n   but it would be a perfectly acceptable tradeoff not to do this.\n2. It doesn't get rid of temporary_channel_id, since we don't know\n   the generation_number until both sides have sent it.  We have a\n   workaround for this already in dual-funding anyway.\n3. Because we need a generation counter, it's not quite as easily\n   scannable as you'd hope (the \"gap\" problem).\n\nI think the \"encrypted blob served by peers\", even in a very naive way,\noffers another way to do this, though it requires the assumption that at\nleast one peer is honest.\n\nDamn, because it was so clever!\n\nThoughts?\nRusty.  \n\nRusty Russell <rusty at rustcorp.com.au> writes:\n> Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n>> Hi Rusty,\n>>\n>> On Tue, 20 Apr 2021 at 10:55, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>\n>>> Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n>>> > On Wed, Dec 9, 2020 at 4:26 PM Rusty Russell <rusty at rustcorp.com.au>\n>>> wrote:\n>>> >\n>>> >>\n>>> >> Say r1=SHA256(ss || counter || 0), r2 = SHA256(ss || counter || 1)?\n>>> >>\n>>> >> Nice work.  This would be a definite recovery win.  We should add this\n>>> >> to the DF spec, because Lisa was almost finished implmenting it, so it's\n>>> >> clearly due for a change!\n>>> >>\n>>> >\n>>> > Yes that's certainly a fine way to do it.\n>>> > I was also thinking you could eliminate all \"basepoints\" (not just\n>>> funding\n>>> > pubkey) using something like this. i.e. just use the node pubkey as the\n>>> > \"basepoint\" for everything and randomize it using the shared secret for\n>>> > each purpose.\n>>>\n>>> OK, I tried to spec this out, to implement it.  One issue is that you\n>>> now can't sign the commitment_tx (or htlc_tx) without knowing the node's\n>>> secret key (or, equivalently, knowing the tweaked key and being able to\n>>> use the derivation scheme to untweak it).\n>>>\n>>\n>> Using node secret key to sign the commitment_tx seems like something you\n>> will have to accept to introduce this feature. For the idea to work it has\n>> to be some public key that is known by others and gossiped through the\n>> network. Of course you could extend the information that is gossiped about\n>> a node to include a \"commit_tx_point\" but the nodeid seems the more natural\n>> choice.\n>\n> Duh, yes, of course you need the funding_key secret to sign the\n> commitment tx.\n>\n> But you really don't want to access the `remote_pubkey` (which in a\n> modern option_static_remotekey world is simply the payment_basepoint).\n> It's generally considered good practice *not* to have this accessible to\n> your lightning node at all.\n>\n>>> c-lightning currently does a round-trip to the signing daemon for this\n>>> already, but it'd be nice to avoid requiring it.\n>>>\n>>> So I somewhat reluctantly added `commit_basepoint` from which the others\n>>> are derived: an implementation can use some hardened derivation from its\n>>> privkey (e.g. SHA256(node_privkey || ss || counter)) to create\n>>> this in a deterministic but still private manner.\n>>>\n>>> Or we could just leave all the other points in and just replace\n>>> funding_pubkey.\n>>>\n>>\n>> Another approach is to do things in \"soft-fork\" like manner.\n>> Each node that wants to offer this feature sets their funding_pubkey to a\n>> specified DH tweak of the nodeid. Nodes that want backup-free channel\n>> recovery can just refuse to carry on the funding protocol if the\n>> funding_pubkey is not set the way it wanted.\n>\n> Yeah, you can totally do this in an opt-in manner, except it doesn't\n> work unless your peer does it too.  Since we expect everyone to want to\n> do this, it's clearer to force everyone to calculate this and not have\n> redundant and confusing fields in the message.\n>\n>>>From my pruisit crypto point of view having only one public key is nice but\n>> I'm not sure how it impacts things architecturally and other protocols like\n>> watchtowers.\n>\n> They can operate exactly like the existing scheme, AFAICT.\n>\n> Here's the spec diff (based on dual-funding, since it's easier to simply\n> hard change).  Please check my EC math! :)\n>\n> diff --git a/02-peer-protocol.md b/02-peer-protocol.md\n> index fbc56c8..1114068 100644\n> --- a/02-peer-protocol.md\n> +++ b/02-peer-protocol.md\n> @@ -867,11 +867,9 @@ This message initiates the v2 channel establishment workflow.\n>     * [`u16`:`to_self_delay`]\n>     * [`u16`:`max_accepted_htlcs`]\n>     * [`u32`:`locktime`]\n> -   * [`point`:`funding_pubkey`]\n> +   * [`u64`:`generation`]\n>     * [`point`:`revocation_basepoint`]\n>     * [`point`:`payment_basepoint`]\n> -   * [`point`:`delayed_payment_basepoint`]\n> -   * [`point`:`htlc_basepoint`]\n>     * [`point`:`first_per_commitment_point`]\n>     * [`byte`:`channel_flags`]\n>     * [`opening_tlvs`:`tlvs`]\n> @@ -895,13 +893,16 @@ If nodes have negotiated `option_dual_fund`:\n>  \n>  The sending node:\n>    - MUST set `funding_feerate_perkw` to the feerate for this transaction\n> -  - MUST ensure `temporary_channel_id` is unique from any\n> -    other channel ID with the same peer.\n> +  - MUST set `generation` to a number greater than any previous\n> +    `generation` it has sent to this receiving node which has reached\n> +    `commitment_signed`.\n> +  - SHOULD set `generation` to the lowest number which meets this requirement.\n>  \n>  The receiving node:\n>    - MAY fail the negotiation if:\n>      - the `locktime` is unacceptable\n>      - the `funding_feerate_per_kw` is unacceptable\n> +    - the `generation` exceeds expectation by more than the maximum it would scan for recovery.\n>  \n>  #### Rationale\n>  `channel_id` for the `open_channel2` MUST be derived using a zero-d out\n> @@ -926,6 +927,13 @@ Instead, the channel reserve is fixed at 1% of the total channel balance\n>  rounded down to the nearest whole satoshi or the `dust_limit_satoshis`,\n>  whichever is greater.\n>  \n> +`generation` is a number which is used to generate the points used for\n> +this pair of peers, with the aim of allowing automatic onchain\n> +scanning for channels if all other information is lost.  Since this\n> +scan would presumably only try a limited number of generations, it is\n> +best if this number is low, but it also needs to change for each\n> +successive channel between the peers, to avoid obvious fingerprinting.\n> +\n>  Note that `push_msat` has been omitted.\n>  \n>  ### The `accept_channel2` Message\n> @@ -943,11 +951,9 @@ acceptance of the new channel.\n>      * [`u32`:`minimum_depth`]\n>      * [`u16`:`to_self_delay`]\n>      * [`u16`:`max_accepted_htlcs`]\n> -    * [`point`:`funding_pubkey`]\n> +    * [`u64`:`generation`]\n>      * [`point`:`revocation_basepoint`]\n>      * [`point`:`payment_basepoint`]\n> -    * [`point`:`delayed_payment_basepoint`]\n> -    * [`point`:`htlc_basepoint`]\n>      * [`point`:`first_per_commitment_point`]\n>      * [`accept_tlvs`:`tlvs`]\n>  \n> @@ -967,6 +973,10 @@ additions.\n>  \n>  The accepting node:\n>      - MAY respond with a `funding_satoshis` value of zero.\n> +    - MUST set `generation` to a number greater than any previous\n> +      `generation` it has sent to this receiving node which has reached\n> +      `commitment_signed`.\n> +    - SHOULD set `generation` to the lowest number which meets this requirement.\n>  \n>  #### Rationale\n>  \n> @@ -985,6 +995,31 @@ Funding composition for channel establishment v2 makes use of the\n>  [Interactive Transaction Construction](#interactive-transaction-construction)\n>  protocol, with the following additional caveats.\n>  \n> +#### Point Derivation\n> +\n> +The `funding_pubkey` and basepoints are derived from the two\n> +`node_id`s and the higher of the two `generation` values; the\n> +`payment_basepoint` is supplied directly.\n> +\n> +Derivation is done as follows:\n> +\n> +1. Start with two node ids, `N1` and `N2` (`N1` is the lesser of the\n> +   two SEC1-encoded compressed public keys, `N2` the greater).\n> +2. Derive a shared secret, `SS`, using ECDH on `N1` and `N2`.\n> +3. Define tweaks `T` for each peer, using `SHA256(SS || generation || node_id || name)`, where:\n> +   1. `generation` is the `u64` larger of the two `generation` fields from `open_channel2` and `accept_channel2`.\n> +   2. `node_id` is the SEC1-encoded compressed public key of the peer.\n> +   3. `name` is a non-terminated ASCII string, e.g. `htlc` is the four bytes\n> +   `0x68 0x74 0x6C 0x63`\n> +4. The `funding_pubkey` is defined as the `node_id` + G*T(`funding`).\n> +5. The `delayed_payment_basepoint` is defined as `node_id` + G*T(`delayed_payment`).\n> +6. The `htlc_basepoint` is defined as the `node_id` + G*T(`htlc`).\n> +\n> +If the secret for `payment_basepoint` is derived in a similar manner,\n> +it too can be easily recovered from just the `generation`, node key\n> +and peer `node_id`.  However, it may also point to an address for a\n> +completely separate system (e.g. cold storage), so it is specified\n> +explicitly in the protocol.\n>  \n>  #### The `tx_add_input` Message\n>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-04-27T23:36:02",
                "message_text_only": "Hey Rusty,\n\nThoughts on each point below.\n\nOn Fri, 23 Apr 2021 at 14:29, Rusty Russell <rusty at rustcorp.com.au> wrote:\n\n> OK, I'm now leaning *against* this method.\n>\n> 1. It removes the ability to update a channel without access to the node's\n>    secret key.  At the moment the node secret key is only needed for\n>    gossip and to DH to set up a new peer connection.  c-lightning does\n>    not use this for now (we keep the per-channel keys in the HSM too),\n>    but it would be a perfectly acceptable tradeoff not to do this.\n>\n\nDon't you also need the node secret key for onion routing? i.e. every time\nyou update your channel to forward a payment.\nI am not familiar with lightning HSM designs and security goals but to me\nit doesn't sound like much of a cost to keep the key on the HSM and to\ninclude doing channel updates as well seeing as it's already doing so much\nwork. If it is desirable to have different keys for DH and channel updates\nthen a simple solution is to have two static public keys -- one for each\ntask.\n\n>From my perspective it is worth making the necessary sacrifices to include\nthis feature. For me and many people, lost data without backups is the\nbiggest risk to my funds in lightning. Certainly much more threatening than\nwhether certain keys are on a HSM or not. Anecdotally I've heard stories\nlike \"I put my lnd on autopilot and then lost my disk died -- all my funds\nare gone!?\" more than once.\n\n2. It doesn't get rid of temporary_channel_id, since we don't know\n>    the generation_number until both sides have sent it.  We have a\n>    workaround for this already in dual-funding anyway.\n>\n\nWhy did you decide to send this rather than just look up in your own\ndatabase what \"generation\" should be? I think that it's easy to make sure\nthat you and the other node are on the same page about this number without\ncommunicating it. If someone is opening a channel with data that appears to\nbe invlaid because they are using the wrong generation then sending an\nerror back indicating what you are up to should be sufficient to recover?\n\n\n> 3. Because we need a generation counter, it's not quite as easily\n>    scannable as you'd hope (the \"gap\" problem).\n>\n\nThis doesn't seem to be a big issue. You are trying to recover your funds\nafter all so you can afford to scan over very large gaps i.e. leave the\nnode on for days. I mean my Bitcoin wallet manages to handle this so why\nwouldn't it work here? I wonder if it is even necessary to bump the\ngeneration until a funding tx is confirmed -- I can't think of a good\nreason why you would want to open two channels to the same node at the same\ntime (why not put all your funds into the same funding).\n\n\n> I think the \"encrypted blob served by peers\", even in a very naive way,\n> offers another way to do this, though it requires the assumption that at\n> least one peer is honest.\n>\n\nI see encrypted backups as complementary. With this scheme you can at least\nfind a peer that you've had a channel with. From the encrypted backup you\nleft with them you can then find others and check against them.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210428/9090ecc5/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-04-28T01:18:10",
                "message_text_only": "On Wed, 28 Apr 2021 at 09:36, Lloyd Fournier <lloyd.fourn at gmail.com> wrote:\n\n>  I wonder if it is even necessary to bump the generation until a funding\n> tx is confirmed -- I can't think of a good reason why you would want to\n> open two channels to the same node at the same time (why not put all your\n> funds into the same funding).\n>\n\nNevermind I've thought of a few -- ignore this point!\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210428/d8436baa/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-28T02:59:35",
                "message_text_only": "Lloyd Fournier <lloyd.fourn at gmail.com> writes:\n> Hey Rusty,\n>\n> Thoughts on each point below.\n>\n> On Fri, 23 Apr 2021 at 14:29, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>\n>> OK, I'm now leaning *against* this method.\n>>\n>> 1. It removes the ability to update a channel without access to the node's\n>>    secret key.  At the moment the node secret key is only needed for\n>>    gossip and to DH to set up a new peer connection.  c-lightning does\n>>    not use this for now (we keep the per-channel keys in the HSM too),\n>>    but it would be a perfectly acceptable tradeoff not to do this.\n>>\n>\n> Don't you also need the node secret key for onion routing? i.e. every time\n> you update your channel to forward a payment.\n\nYou need to ECDH with the node_id privkey, yes (as you do to establish\npeer comms).  But in the c-lightning model, that's part of central\nrouting, not the subdaemon which deals with a single channel.  You can\nstill shutdown a channel without knowing the node's private key.\n\n> I am not familiar with lightning HSM designs and security goals but to me\n> it doesn't sound like much of a cost to keep the key on the HSM and to\n> include doing channel updates as well seeing as it's already doing so much\n> work. If it is desirable to have different keys for DH and channel updates\n> then a simple solution is to have two static public keys -- one for each\n> task.\n\nThe main concern is that access to one channel's keys doesn't give you\nany access to the other channels' keys.  I don't think there's a way\naround that in any \"I can derive another nodes' keys\" model.\n\n>>From my perspective it is worth making the necessary sacrifices to include\n> this feature. For me and many people, lost data without backups is the\n> biggest risk to my funds in lightning. Certainly much more threatening than\n> whether certain keys are on a HSM or not. Anecdotally I've heard stories\n> like \"I put my lnd on autopilot and then lost my disk died -- all my funds\n> are gone!?\" more than once.\n\nFair, but more reliable backups solve this better IMHO.  (Roasbeef told\nus that Electrum uses OP_RETURN to tag opens, which also works).\n\n> 2. It doesn't get rid of temporary_channel_id, since we don't know\n>>    the generation_number until both sides have sent it.  We have a\n>>    workaround for this already in dual-funding anyway.\n>>\n>\n> Why did you decide to send this rather than just look up in your own\n> database what \"generation\" should be? I think that it's easy to make sure\n> that you and the other node are on the same page about this number without\n> communicating it. If someone is opening a channel with data that appears to\n> be invlaid because they are using the wrong generation then sending an\n> error back indicating what you are up to should be sufficient to recover?\n\nIf you ever lose that information, you can never open a channel again?\nOr you simply believe them and retry if they offer a higher generation?\n\n>> 3. Because we need a generation counter, it's not quite as easily\n>>    scannable as you'd hope (the \"gap\" problem).\n>>\n>\n> This doesn't seem to be a big issue. You are trying to recover your funds\n> after all so you can afford to scan over very large gaps i.e. leave the\n> node on for days. I mean my Bitcoin wallet manages to handle this so why\n> wouldn't it work here?\n\nWell, bitcoin core famously didn't do this at all (had a key pool) and\npeople lost funds.  Deterministic key generation is better, but it's\nstill making gross assumptions, usually undocumented, on how many keys\nyou can hand out before you *have* to use one.\n\nIt's sometimes shocking how unpolished Bitcoin infrastructure is.  But\nit's stuff like this that so many exchanges offer fixed deposit\naddresses :(\n\n> I wonder if it is even necessary to bump the\n> generation until a funding tx is confirmed -- I can't think of a good\n> reason why you would want to open two channels to the same node at the same\n> time (why not put all your funds into the same funding).\n\nWell, I'd agree with you of course, but other implementations do allow\nit.  If you don't allow it, you don't need a temporary_channel_id at\nall.\n\nBut that still only prevents gaps if you scan the TXO set, not the UTXO\nset.  And it doesn't help with unannounced peers or peers which are no\nlonger in the public graph.  You want backups :)\n\n>> I think the \"encrypted blob served by peers\", even in a very naive way,\n>> offers another way to do this, though it requires the assumption that at\n>> least one peer is honest.\n>\n> I see encrypted backups as complementary. With this scheme you can at least\n> find a peer that you've had a channel with. From the encrypted backup you\n> left with them you can then find others and check against them.\n\nI see encrypted backups as a more-likely-to-be-implemented solution\nthough.  Because they're useful to send to places other than peers, and\nthey can also contain HTLC information if you want.\n\nAnd after that, I don't think the remaining problem is sufficient to\nengineer salvage solutions for.\n\nBut we can revisit if I'm wrong!\n\nCheers,\nRusty."
            },
            {
                "author": "David A. Harding",
                "date": "2021-04-28T20:14:38",
                "message_text_only": "On Mon, Dec 07, 2020 at 11:32:27AM +1100, Lloyd Fournier wrote:\n> I've been considering the problem of recovering lightning channels after\n> losing channel state in a boating accident. The modern way of doing this\n> seems to be \"static channel backups\" -- these are essentially lists of\n> channel ids and the nodes you had the channels with.\n> \n> The idea is that with this backup you can remember who you had channels\n> with, connect to them and ask them to force close the channel (can someone\n> link me the concrete protocol messages you send to do this?).\n> \n> It occurred to me that if the lightning protocol were changed slightly you\n> could do this without the channel backup at all.\n\nI was re-reading this OP after seeing some of Rusty's concerns later in\nthe thread and I was wondering why we need to alter funding at all.\nWe're assuming that when Alice recovers from her backup, she knows her\nnode_id and has the private key necessary to sign messages for it, so\nwhy can't she sign a message that gets gossiped across the network that\nsays, \"if you have a channel with node_id 0xa11ce, please close it now\"?\n\nMaybe the message also includes a signed timestamp or block height so\nonly channels with funding transactions confirmed before that\ntime/height get closed, preventing future replays of the message from\nclosing Alice's later channels opened with the same seed/node_id.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210428/14422f93/attachment.sig>"
            }
        ],
        "thread_summary": {
            "title": "Recovery of Lightning channels without backups",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "David A. Harding",
                "Lloyd Fournier"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 31649
        }
    },
    {
        "title": "[Lightning-dev] Splicing draft",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-04-20T07:14:27",
                "message_text_only": "https://github.com/lightningnetwork/lightning-rfc/pull/863\n\nI haven't even *started* to implement this, so I could well have missed\nsomething.  Let's see.\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Splicing draft",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 170
        }
    },
    {
        "title": "[Lightning-dev] [RFC] Simplified (but less optimal) HTLC Negotiation",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-04-20T21:19:24",
                "message_text_only": "Christian Decker <decker.christian at gmail.com> writes:\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n>>> This is in stark contrast to the leader-based approach, where both\n>>> parties can just keep queuing updates without silent times to\n>>> transferring the token from one end to the other.\n>>\n>> You've swayed me, but it needs new wire msgs to indicate \"these are\n>> your proposals I'm reflecting to you\".\n>>\n>> OTOH they don't need to carry data, so we can probably just have:\n>>\n>> update_htlcs_ack:\n>>    * [`channel_id`:`channel_id`]\n>>    * [`u16`:`num_added`]\n>>    * [`num_added*u64`:`added`]\n>>    * [`u16`:`num_removed`]\n>>    * [`num_removed*u64`:`removed`]\n>>\n>> update_fee can stay the same.\n>>\n>> Thoughts?\n>\n> So this would pretty much be a batch-ack, sent after a whole series of\n> changes were proposed to the leader, and referenced by their `htlc_id`,\n> correct? This is one optimization step further than what I was thinking,\n> but it can work. My proposal would have been to either reflect the whole\n> message (nodes need to remember proposals they've sent anyway in case of\n> disconnects, so matching incoming changes with the pending ones should\n> not be too hard), or send back individual acks, containing the hash of\n> the message if we want to safe on bytes transferred. Alternatively we\n> could also use reference the change by its htlc_id.\n\n[ Following up on an old thread ]\n\nAfter consideration, I prefer alternation.  It fits better with the\nexisting implementations, and it is more optimal than reflection for\noptimized implementations.\n\nIn particular, you have a rule that says you can send updates and\ncommitment_signed when it's not your turn, and the leader either\nresponds with a \"giving way\" message, or ignores your changes and sends\nits own.\n\nA simple implementation *never* sends a commitment_signed until it\nreceives \"giving way\" so it doesn't have to deal with orphaned\ncommitments.  A more complex implementation sends opportunistically and\nthen has to remember that it's committed if it loses the race.  Such an\nimplementation is only slower than the current system if that race\nhappens.\n\nI've been revisiting this because it makes things like splicing easier:\nthe current draft requires stopping changes while splicing is being\nnegotiated, which is not entirely trivial.  With the simplified method,\nyou don't have to wait at all.\n\nCheers,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-24T04:20:44",
                "message_text_only": "> On Apr 20, 2021, at 17:19, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> After consideration, I prefer alternation.  It fits better with the\n> existing implementations, and it is more optimal than reflection for\n> optimized implementations.\n> \n> In particular, you have a rule that says you can send updates and\n> commitment_signed when it's not your turn, and the leader either\n> responds with a \"giving way\" message, or ignores your changes and sends\n> its own.\n> \n> A simple implementation *never* sends a commitment_signed until it\n> receives \"giving way\" so it doesn't have to deal with orphaned\n> commitments.  A more complex implementation sends opportunistically and\n> then has to remember that it's committed if it loses the race.  Such an\n> implementation is only slower than the current system if that race\n> happens.\n\nSomehow I missed this thread, but I did note in a previous meeting - these issues are great fodder for fuzzing. We\u2019ve had a fuzzer which aggressively tests for precisely these types of message-non-delivery-and-resending production desync bugs for several years. When it initially landed it forced several rewrites of parts of the state machine, but quickly exhausted the bug fruit (though catches other classes of bugs occasionally as well). The state machine here is really not that big - while I agree simplifying it where possible is nice, ripping things out to replace them with fresh code (which would need similar testing) is probably not the most obvious decrease in complexity.\n\n> I've been revisiting this because it makes things like splicing easier:\n> the current draft requires stopping changes while splicing is being\n> negotiated, which is not entirely trivial.  With the simplified method,\n> you don't have to wait at all.\n\nHmm, what\u2019s nontrivial about this? How much more complicated is this than having an alternation to updates and pausing HTLC updates for a cycle or two while splicing is negotiated (I assume it would still need a similar requirement, as otherwise you have the same complexity)? We already have a similar update-stopping process for shutdown, though of course it doesn\u2019t include restarting."
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-24T05:55:55",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> Somehow I missed this thread, but I did note in a previous meeting - these issues are great fodder for fuzzing. We\u2019ve had a fuzzer which aggressively tests for precisely these types of message-non-delivery-and-resending production desync bugs for several years. When it initially landed it forced several rewrites of parts of the state machine, but quickly exhausted the bug fruit (though catches other classes of bugs occasionally as well). The state machine here is really not that big - while I agree simplifying it where possible is nice, ripping things out to replace them with fresh code (which would need similar testing) is probably not the most obvious decrease in complexity.\n\nIt's historically had more bugs than anything else in the protocol.  We\nliterally found another one in feerate negotiation since the last\nc-lightning release :(\n\nI'd rather not have bugs than try to catch them all.\n\n>> I've been revisiting this because it makes things like splicing easier:\n>> the current draft requires stopping changes while splicing is being\n>> negotiated, which is not entirely trivial.  With the simplified method,\n>> you don't have to wait at all.\n>\n> Hmm, what\u2019s nontrivial about this? How much more complicated is this than having an alternation to updates and pausing HTLC updates for a cycle or two while splicing is negotiated (I assume it would still need a similar requirement, as otherwise you have the same complexity)? We already have a similar update-stopping process for shutdown, though of course it doesn\u2019t include restarting.\n\nYou could propose a splice (or update to anchors, or whatever) any time\nwhen it's your turn, as long as you haven't proposed any other updates.\nThat's simple!\n\nInstead, *both* sides have to send a splice message to synchronize, and\nthey can only do so once all in-flight changes have cleared.  You have\nto resolve simultaneous splice attempts (we use \"highest feerate\"\ntiebreak by node_id), and keep track of this stage while you clear\nin-flight changes.\n\nHere's the subset of requirements from the draft which relate to this:\n\nThe sender:\n- MUST NOT send another splice message while a splice is being negotiated.\n- MUST NOT send a splice message after sending uncommitted changes.\n- MUST NOT send other channel updates until splice negotiation has completed.\n\nThe receiver:\n- MUST respond with a `splice` message of its own if it has not already.\n- MUST NOT reply with `splice` until all commitment updates are resolved by both peers.\n- MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n  the splice.\n- MUST NOT send other channel updates until splice negotiation has completed.\n\nSimilar requirements exist for other major channel changes.\n\nCheers,\nRusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-24T14:11:33",
                "message_text_only": "> On Apr 24, 2021, at 01:56, Rusty Russell <rusty at rustcorp.com.au> wrote:\n> \n> \ufeffMatt Corallo <lf-lists at mattcorallo.com> writes:\n>> Somehow I missed this thread, but I did note in a previous meeting - these issues are great fodder for fuzzing. We\u2019ve had a fuzzer which aggressively tests for precisely these types of message-non-delivery-and-resending production desync bugs for several years. When it initially landed it forced several rewrites of parts of the state machine, but quickly exhausted the bug fruit (though catches other classes of bugs occasionally as well). The state machine here is really not that big - while I agree simplifying it where possible is nice, ripping things out to replace them with fresh code (which would need similar testing) is probably not the most obvious decrease in complexity.\n> \n> It's historically had more bugs than anything else in the protocol.  We\n> literally found another one in feerate negotiation since the last\n> c-lightning release :(\n> \n> I'd rather not have bugs than try to catch them all.\n\nI promise it\u2019s much less work than it sounds like, and avoids having to debug these things based on logs, which is a huge pain :). Definitely less work than a new state machine:).\n\n> You could propose a splice (or update to anchors, or whatever) any time\n> when it's your turn, as long as you haven't proposed any other updates.\n> That's simple!\n\nI presume you\u2019d need to take it a few steps further - if the last message received required a response CS/RAA, you must still wait until things have settled down. I guess it also depends on the exact semantics of a \u201cturn based\u201d message protocol - if you received some updates and a signature, are you allowed to add more updates after you send your CS/RAA (then you have a good chunk of today\u2019s complexity), or do you have to wait until they send you back their last RAA (in which case presumably they aren\u2019t allowed to include anything else as then they\u2019d be able to monopolize update windows). In the first case you still have the same issues of today, in the second less so, but you\u2019re doing a similar \u201cok, just pause updates and wait for things to settle \u201c, I think.\n\n> Instead, *both* sides have to send a splice message to synchronize, and\n> they can only do so once all in-flight changes have cleared. You have\n> to resolve simultaneous splice attempts (we use \"highest feerate\"\n> tiebreak by node_id), and keep track of this stage while you clear\n> in-flight changes.\n\nIsn\u2019t that pretty similar? Discard one splice proposal deterministically (ok that\u2019s new) and the loser has to store their proposal in a holding cell for later (which they have to do in turn-based anyway). Logic to check if there\u2019s unsettled things in RAA handling is pretty similar to turn-based, and logic to reject other messages is the same as shutdown handling today.\n\n> Here's the subset of requirements from the draft which relate to this:\n> \n> The sender:\n> - MUST NOT send another splice message while a splice is being negotiated.\n> - MUST NOT send a splice message after sending uncommitted changes.\n> - MUST NOT send other channel updates until splice negotiation has completed.\n> \n> The receiver:\n> - MUST respond with a `splice` message of its own if it has not already.\n> - MUST NOT reply with `splice` until all commitment updates are resolved by both peers.\n\nProbably use \u201ccommitted\u201d not \u201cresolved\u201d. \u201cResolved\u201d sounds like \u201cno pending HTLCs left\u201d.\n\n> - MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n>  the splice.\n\nIf we like turn based, why not just deterministic throw out one slice? :)\n\n> - MUST NOT send other channel updates until splice negotiation has completed.\n> \n> Similar requirements exist for other major channel changes.\n> \n> Cheers,\n> Rusty.\n>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-27T05:04:06",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n>> On Apr 24, 2021, at 01:56, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>> \n>> \ufeffMatt Corallo <lf-lists at mattcorallo.com> writes:\n>>> Somehow I missed this thread, but I did note in a previous meeting - these issues are great fodder for fuzzing. We\u2019ve had a fuzzer which aggressively tests for precisely these types of message-non-delivery-and-resending production desync bugs for several years. When it initially landed it forced several rewrites of parts of the state machine, but quickly exhausted the bug fruit (though catches other classes of bugs occasionally as well). The state machine here is really not that big - while I agree simplifying it where possible is nice, ripping things out to replace them with fresh code (which would need similar testing) is probably not the most obvious decrease in complexity.\n>> \n>> It's historically had more bugs than anything else in the protocol.  We\n>> literally found another one in feerate negotiation since the last\n>> c-lightning release :(\n>> \n>> I'd rather not have bugs than try to catch them all.\n>\n> I promise it\u2019s much less work than it sounds like, and avoids having to debug these things based on logs, which is a huge pain :). Definitely less work than a new state machine:).\n\nBut the entire point of this proposal is that it's a subset of the\nexisting state machine?\n\n>> You could propose a splice (or update to anchors, or whatever) any time\n>> when it's your turn, as long as you haven't proposed any other updates.\n>> That's simple!\n>\n> I presume you\u2019d need to take it a few steps further - if the last\n> message received required a response CS/RAA, you must still wait until\n> things have settled down. I guess it also depends on the exact\n> semantics of a \u201cturn based\u201d message protocol - if you received some\n> updates and a signature, are you allowed to add more updates after you\n> send your CS/RAA (then you have a good chunk of today\u2019s complexity),\n> or do you have to wait until they send you back their last RAA (in\n> which case presumably they aren\u2019t allowed to include anything else as\n> then they\u2019d be able to monopolize update windows). In the first case\n> you still have the same issues of today, in the second less so, but\n> you\u2019re doing a similar \u201cok, just pause updates and wait for things to\n> settle \u201c, I think.\n\nYes, as the original proposal stated: you propose changes, send\ncommitment_signed, receive revoke_and_ack and commitment_signed, then\nsend revoke_and_ack.  Then both sides are in sync, and the other side\nhas a turn.\n\nThe only \"twist\" is that if it's your turn and you receive an update,\nyou can either reply with a \"yield\" message, or ignore it.\n\n>> Instead, *both* sides have to send a splice message to synchronize, and\n>> they can only do so once all in-flight changes have cleared. You have\n>> to resolve simultaneous splice attempts (we use \"highest feerate\"\n>> tiebreak by node_id), and keep track of this stage while you clear\n>> in-flight changes.\n>\n> Isn\u2019t that pretty similar? Discard one splice proposal deterministically (ok that\u2019s new) and the loser has to store their proposal in a holding cell for later (which they have to do in turn-based anyway). Logic to check if there\u2019s unsettled things in RAA handling is pretty similar to turn-based, and logic to reject other messages is the same as shutdown handling today.\n\nNope, with the simplified protocol you can `update_splice` at any time\ninstead of your normal update, since both sides are already in sync.\n\n>> Here's the subset of requirements from the draft which relate to this:\n>> \n>> The sender:\n>> - MUST NOT send another splice message while a splice is being negotiated.\n>> - MUST NOT send a splice message after sending uncommitted changes.\n>> - MUST NOT send other channel updates until splice negotiation has completed.\n>> \n>> The receiver:\n>> - MUST respond with a `splice` message of its own if it has not already.\n>> - MUST NOT reply with `splice` until all commitment updates are resolved by both peers.\n>\n> Probably use \u201ccommitted\u201d not \u201cresolved\u201d. \u201cResolved\u201d sounds like \u201cno pending HTLCs left\u201d.\n\nYes, and in fact this protocol was flawed and had to be revised, as it\ndid not actually mean both sides were committed in the case of\nsimultaneous splice proposals :(\n\n>> - MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n>>  the splice.\n>\n> If we like turn based, why not just deterministic throw out one slice? :)\n\nBecause while I am going to implement turn-based, I'm not sure if anyone\nelse is.  I guess we'll see?\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-27T21:32:20",
                "message_text_only": "OK, draft is up:\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/867\n\nI have to actually implement it now (though the real win comes from\nmaking it compulsory, but that's a fair way away).\n\nNotably, I added the requirement that update_fee messages be on their\nown.  This means there's no debate on the state of the channel when\nthis is being applied.\n\nCheers,\nRusty.\n\nRusty Russell <rusty at rustcorp.com.au> writes:\n\n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>>> On Apr 24, 2021, at 01:56, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>> \n>>> \ufeffMatt Corallo <lf-lists at mattcorallo.com> writes:\n>>>> Somehow I missed this thread, but I did note in a previous meeting - these issues are great fodder for fuzzing. We\u2019ve had a fuzzer which aggressively tests for precisely these types of message-non-delivery-and-resending production desync bugs for several years. When it initially landed it forced several rewrites of parts of the state machine, but quickly exhausted the bug fruit (though catches other classes of bugs occasionally as well). The state machine here is really not that big - while I agree simplifying it where possible is nice, ripping things out to replace them with fresh code (which would need similar testing) is probably not the most obvious decrease in complexity.\n>>> \n>>> It's historically had more bugs than anything else in the protocol.  We\n>>> literally found another one in feerate negotiation since the last\n>>> c-lightning release :(\n>>> \n>>> I'd rather not have bugs than try to catch them all.\n>>\n>> I promise it\u2019s much less work than it sounds like, and avoids having to debug these things based on logs, which is a huge pain :). Definitely less work than a new state machine:).\n>\n> But the entire point of this proposal is that it's a subset of the\n> existing state machine?\n>\n>>> You could propose a splice (or update to anchors, or whatever) any time\n>>> when it's your turn, as long as you haven't proposed any other updates.\n>>> That's simple!\n>>\n>> I presume you\u2019d need to take it a few steps further - if the last\n>> message received required a response CS/RAA, you must still wait until\n>> things have settled down. I guess it also depends on the exact\n>> semantics of a \u201cturn based\u201d message protocol - if you received some\n>> updates and a signature, are you allowed to add more updates after you\n>> send your CS/RAA (then you have a good chunk of today\u2019s complexity),\n>> or do you have to wait until they send you back their last RAA (in\n>> which case presumably they aren\u2019t allowed to include anything else as\n>> then they\u2019d be able to monopolize update windows). In the first case\n>> you still have the same issues of today, in the second less so, but\n>> you\u2019re doing a similar \u201cok, just pause updates and wait for things to\n>> settle \u201c, I think.\n>\n> Yes, as the original proposal stated: you propose changes, send\n> commitment_signed, receive revoke_and_ack and commitment_signed, then\n> send revoke_and_ack.  Then both sides are in sync, and the other side\n> has a turn.\n>\n> The only \"twist\" is that if it's your turn and you receive an update,\n> you can either reply with a \"yield\" message, or ignore it.\n>\n>>> Instead, *both* sides have to send a splice message to synchronize, and\n>>> they can only do so once all in-flight changes have cleared. You have\n>>> to resolve simultaneous splice attempts (we use \"highest feerate\"\n>>> tiebreak by node_id), and keep track of this stage while you clear\n>>> in-flight changes.\n>>\n>> Isn\u2019t that pretty similar? Discard one splice proposal deterministically (ok that\u2019s new) and the loser has to store their proposal in a holding cell for later (which they have to do in turn-based anyway). Logic to check if there\u2019s unsettled things in RAA handling is pretty similar to turn-based, and logic to reject other messages is the same as shutdown handling today.\n>\n> Nope, with the simplified protocol you can `update_splice` at any time\n> instead of your normal update, since both sides are already in sync.\n>\n>>> Here's the subset of requirements from the draft which relate to this:\n>>> \n>>> The sender:\n>>> - MUST NOT send another splice message while a splice is being negotiated.\n>>> - MUST NOT send a splice message after sending uncommitted changes.\n>>> - MUST NOT send other channel updates until splice negotiation has completed.\n>>> \n>>> The receiver:\n>>> - MUST respond with a `splice` message of its own if it has not already.\n>>> - MUST NOT reply with `splice` until all commitment updates are resolved by both peers.\n>>\n>> Probably use \u201ccommitted\u201d not \u201cresolved\u201d. \u201cResolved\u201d sounds like \u201cno pending HTLCs left\u201d.\n>\n> Yes, and in fact this protocol was flawed and had to be revised, as it\n> did not actually mean both sides were committed in the case of\n> simultaneous splice proposals :(\n>\n>>> - MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n>>>  the splice.\n>>\n>> If we like turn based, why not just deterministic throw out one slice? :)\n>\n> Because while I am going to implement turn-based, I'm not sure if anyone\n> else is.  I guess we'll see?\n>\n> Cheers,\n> Rusty."
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-28T02:16:30",
                "message_text_only": "On 4/27/21 17:32, Rusty Russell wrote:\n> OK, draft is up:\n> \n>          https://github.com/lightningnetwork/lightning-rfc/pull/867\n> \n> I have to actually implement it now (though the real win comes from\n> making it compulsory, but that's a fair way away).\n> \n> Notably, I added the requirement that update_fee messages be on their\n> own.  This means there's no debate on the state of the channel when\n> this is being applied.\n\nI do have to admit *that* part I like :).\n\nIf we don't do turns for splicing, I wonder if we can take the rules around splicing pausing other HTLC updates, make \nthem generic for future use, and then also use them for update_fee in a simpler-to-make-compulsory change :).\n\nMatt"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-28T02:13:01",
                "message_text_only": "On 4/27/21 01:04, Rusty Russell wrote:\n> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>>> On Apr 24, 2021, at 01:56, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>>\n>>> \ufeffMatt Corallo <lf-lists at mattcorallo.com> writes:\n>> I promise it\u2019s much less work than it sounds like, and avoids having to debug these things based on logs, which is a huge pain :). Definitely less work than a new state machine:).\n> \n> But the entire point of this proposal is that it's a subset of the\n> existing state machine?\n\nCompared to today, its a good chunk of additional state machine logic to enforce when a message can or can not be sent, \nand additional logic for when we can (or can not) flush any pending changes buffer(s).\n\n\n> The only \"twist\" is that if it's your turn and you receive an update,\n> you can either reply with a \"yield\" message, or ignore it.\n\nHow do you handle the \"no changes to make\" case - do you send yields back and forth ever Nms all day long or is there \nsome protocol by which you resolve it when both parties try to claim turn at once?\n\n\n>> Isn\u2019t that pretty similar? Discard one splice proposal deterministically (ok that\u2019s new) and the loser has to store their proposal in a holding cell for later (which they have to do in turn-based anyway). Logic to check if there\u2019s unsettled things in RAA handling is pretty similar to turn-based, and logic to reject other messages is the same as shutdown handling today.\n> \n> Nope, with the simplified protocol you can `update_splice` at any time\n> instead of your normal update, since both sides are already in sync.\n\nHmm, I'm somewhat failing to understand why its that different - you can only update_splice if its your turn, which is \nabout exactly the same amount of additional logic to check turn conditions as just flag \"want to do splice\". Either way \nyou have the same pending splice buffer.\n\n>>> - MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n>>>   the splice.\n>>\n>> If we like turn based, why not just deterministic throw out one slice? :)\n> \n> Because while I am going to implement turn-based, I'm not sure if anyone\n> else is.  I guess we'll see?\n\nMy point was more that its similar in logic - if you throw out the splice deterministically and just keep it in some \n\"pending slice\" buffer on the sending side, you've just done basically what you'd do to implement turns, while keeping \nthe non-turn slice protocol a bit easier :).\n\nMatt"
            }
        ],
        "thread_summary": {
            "title": "Simplified (but less optimal) HTLC Negotiation",
            "categories": [
                "Lightning-dev",
                "RFC"
            ],
            "authors": [
                "Rusty Russell",
                "Matt Corallo"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 23994
        }
    },
    {
        "title": "[Lightning-dev] L2s Onchain Support IRC Workshop",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2021-04-23T15:11:56",
                "message_text_only": "Hi,\n\nDuring the lastest years, tx-relay and mempool acceptances rules of the\nbase layer have been sources of major security and operational concerns for\nLightning and other Bitcoin second-layers [0]. I think those areas require\nsignificant improvements to ease design and deployment of higher Bitcoin\nlayers and I believe this opinion is shared among the L2 dev community. In\norder to make advancements, it has been discussed a few times in the last\nmonths to organize in-person workshops to discuss those issues with the\npresence of both L1/L2 devs to make exchange fruitful.\n\nUnfortunately, I don't think we'll be able to organize such in-person\nworkshops this year (because you know travel is hard those days...) As a\nsubstitution, I'm proposing a series of one or more irc meetings. That\nsaid, this substitution has the happy benefit to gather far more folks\ninterested by those issues that you can fit in a room.\n\n# Scope\n\nI would like to propose the following 4 items as topics of discussion.\n\n1) Package relay design or another generic L2 fee-bumping primitive like\nsponsorship [0]. IMHO, this primitive should at least solve mempools spikes\nmaking obsolete propagation of transactions with pre-signed feerate, solve\npinning attacks compromising Lightning/multi-party contract protocol\nsafety, offer an usable and stable API to L2 software stack, stay\ncompatible with miner and full-node operators incentives and obviously\nminimize CPU/memory DoS vectors.\n\n2) Deprecation of opt-in RBF toward full-rbf. Opt-in RBF makes it trivial\nfor an attacker to partition network mempools in divergent subsets and from\nthen launch advanced security or privacy attacks against a Lightning node.\nNote, it might also be a concern for bandwidth bleeding attacks against L1\nnodes.\n\n3) Guidelines about coordinated cross-layers security disclosures.\nMitigating a security issue around tx-relay or the mempool in Core might\nhave harmful implications for downstream projects. Ideally, L2 projects\nmaintainers should be ready to upgrade their protocols in emergency in\ncoordination with base layers developers.\n\n4) Guidelines about L2 protocols onchain security design. Currently\ndeployed like Lightning are making a bunch of assumptions on tx-relay and\nmempool acceptances rules. Those rules are non-normative, non-reliable and\nlack documentation. Further, they're devoid of tooling to enforce them at\nruntime [2]. IMHO, it could be preferable to identify a subset of them on\nwhich second-layers protocols can do assumptions without encroaching too\nmuch on nodes's policy realm or making the base layer development in those\nareas too cumbersome.\n\nI'm aware that some folks are interested in other topics such as extension\nof Core's mempools package limits or better pricing of RBF replacement. So\nl propose a 2-week concertation period to submit other topics related to\ntx-relay or mempools improvements towards L2s before to propose a finalized\nscope and agenda.\n\n# Goals\n\n1) Reaching technical consensus.\n2) Reaching technical consensus, before seeking community consensus as it\nlikely has ecosystem-wide implications.\n3) Establishing a security incident response policy which can be applied by\ndev teams in the future.\n4) Establishing a philosophy design and associated documentations (BIPs,\nbest practices, ...)\n\n# Timeline\n\n2021-04-23: Start of concertation period\n2021-05-07: End of concertation period\n2021-05-10: Proposition of workshop agenda and schedule\nlate 2021-05/2021-06: IRC meetings\n\nAs the problem space is savagely wide, I've started a collection of\ndocuments to assist this workshop : https://github.com/ariard/L2-zoology\nStill wip, but I'll have them in a good shape at agenda publication, with\nreading suggestions and open questions to structure discussions.\nAlso working on transaction pinning and mempool partitions attacks\nsimulations.\n\nIf L2s security/p2p/mempool is your jam, feel free to get involved :)\n\nCheers,\nAntoine\n\n[0] For e.g see optech section on transaction pinning attacks :\nhttps://bitcoinops.org/en/topics/transaction-pinning/\n[1]\nhttps://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n[2] Lack of reference tooling make it easier to have bug slip in like\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002858.html\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/98e1f2cc/attachment.html>"
            },
            {
                "author": "Jeremy",
                "date": "2021-04-23T15:25:19",
                "message_text_only": "I'd be excited to join. Recommend bumping the date  to mid June, if that's\nok, as many Americans will be at Bitcoin 2021.\n\nI was thinking about reviving the sponsors proposal with a 100 block lock\non spending a sponsoring tx which would hopefully make less controversial,\nthis would be a great place to discuss those tradeoffs.\n\nOn Fri, Apr 23, 2021, 8:17 AM Antoine Riard <antoine.riard at gmail.com> wrote:\n\n> Hi,\n>\n> During the lastest years, tx-relay and mempool acceptances rules of the\n> base layer have been sources of major security and operational concerns for\n> Lightning and other Bitcoin second-layers [0]. I think those areas require\n> significant improvements to ease design and deployment of higher Bitcoin\n> layers and I believe this opinion is shared among the L2 dev community. In\n> order to make advancements, it has been discussed a few times in the last\n> months to organize in-person workshops to discuss those issues with the\n> presence of both L1/L2 devs to make exchange fruitful.\n>\n> Unfortunately, I don't think we'll be able to organize such in-person\n> workshops this year (because you know travel is hard those days...) As a\n> substitution, I'm proposing a series of one or more irc meetings. That\n> said, this substitution has the happy benefit to gather far more folks\n> interested by those issues that you can fit in a room.\n>\n> # Scope\n>\n> I would like to propose the following 4 items as topics of discussion.\n>\n> 1) Package relay design or another generic L2 fee-bumping primitive like\n> sponsorship [0]. IMHO, this primitive should at least solve mempools spikes\n> making obsolete propagation of transactions with pre-signed feerate, solve\n> pinning attacks compromising Lightning/multi-party contract protocol\n> safety, offer an usable and stable API to L2 software stack, stay\n> compatible with miner and full-node operators incentives and obviously\n> minimize CPU/memory DoS vectors.\n>\n> 2) Deprecation of opt-in RBF toward full-rbf. Opt-in RBF makes it trivial\n> for an attacker to partition network mempools in divergent subsets and from\n> then launch advanced security or privacy attacks against a Lightning node.\n> Note, it might also be a concern for bandwidth bleeding attacks against L1\n> nodes.\n>\n> 3) Guidelines about coordinated cross-layers security disclosures.\n> Mitigating a security issue around tx-relay or the mempool in Core might\n> have harmful implications for downstream projects. Ideally, L2 projects\n> maintainers should be ready to upgrade their protocols in emergency in\n> coordination with base layers developers.\n>\n> 4) Guidelines about L2 protocols onchain security design. Currently\n> deployed like Lightning are making a bunch of assumptions on tx-relay and\n> mempool acceptances rules. Those rules are non-normative, non-reliable and\n> lack documentation. Further, they're devoid of tooling to enforce them at\n> runtime [2]. IMHO, it could be preferable to identify a subset of them on\n> which second-layers protocols can do assumptions without encroaching too\n> much on nodes's policy realm or making the base layer development in those\n> areas too cumbersome.\n>\n> I'm aware that some folks are interested in other topics such as extension\n> of Core's mempools package limits or better pricing of RBF replacement. So\n> l propose a 2-week concertation period to submit other topics related to\n> tx-relay or mempools improvements towards L2s before to propose a finalized\n> scope and agenda.\n>\n> # Goals\n>\n> 1) Reaching technical consensus.\n> 2) Reaching technical consensus, before seeking community consensus as it\n> likely has ecosystem-wide implications.\n> 3) Establishing a security incident response policy which can be applied\n> by dev teams in the future.\n> 4) Establishing a philosophy design and associated documentations (BIPs,\n> best practices, ...)\n>\n> # Timeline\n>\n> 2021-04-23: Start of concertation period\n> 2021-05-07: End of concertation period\n> 2021-05-10: Proposition of workshop agenda and schedule\n> late 2021-05/2021-06: IRC meetings\n>\n> As the problem space is savagely wide, I've started a collection of\n> documents to assist this workshop : https://github.com/ariard/L2-zoology\n> Still wip, but I'll have them in a good shape at agenda publication, with\n> reading suggestions and open questions to structure discussions.\n> Also working on transaction pinning and mempool partitions attacks\n> simulations.\n>\n> If L2s security/p2p/mempool is your jam, feel free to get involved :)\n>\n> Cheers,\n> Antoine\n>\n> [0] For e.g see optech section on transaction pinning attacks :\n> https://bitcoinops.org/en/topics/transaction-pinning/\n> [1]\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n> [2] Lack of reference tooling make it easier to have bug slip in like\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002858.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/4e8df87e/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-04-23T15:39:15",
                "message_text_only": "Hi Jeremy,\n\nYes dates are floating for now. After Bitcoin 2021, sounds a good idea.\n\nAwesome, I'll be really interested to review again an improved version of\nsponsorship. And I'll try to sketch out the sighash_no-input fee-bumping\nidea which was floating around last year during pinnings discussions. Yet\nanother set of trade-offs :)\n\nLe ven. 23 avr. 2021 \u00e0 11:25, Jeremy <jlrubin at mit.edu> a \u00e9crit :\n\n> I'd be excited to join. Recommend bumping the date  to mid June, if that's\n> ok, as many Americans will be at Bitcoin 2021.\n>\n> I was thinking about reviving the sponsors proposal with a 100 block lock\n> on spending a sponsoring tx which would hopefully make less controversial,\n> this would be a great place to discuss those tradeoffs.\n>\n> On Fri, Apr 23, 2021, 8:17 AM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi,\n>>\n>> During the lastest years, tx-relay and mempool acceptances rules of the\n>> base layer have been sources of major security and operational concerns for\n>> Lightning and other Bitcoin second-layers [0]. I think those areas require\n>> significant improvements to ease design and deployment of higher Bitcoin\n>> layers and I believe this opinion is shared among the L2 dev community. In\n>> order to make advancements, it has been discussed a few times in the last\n>> months to organize in-person workshops to discuss those issues with the\n>> presence of both L1/L2 devs to make exchange fruitful.\n>>\n>> Unfortunately, I don't think we'll be able to organize such in-person\n>> workshops this year (because you know travel is hard those days...) As a\n>> substitution, I'm proposing a series of one or more irc meetings. That\n>> said, this substitution has the happy benefit to gather far more folks\n>> interested by those issues that you can fit in a room.\n>>\n>> # Scope\n>>\n>> I would like to propose the following 4 items as topics of discussion.\n>>\n>> 1) Package relay design or another generic L2 fee-bumping primitive like\n>> sponsorship [0]. IMHO, this primitive should at least solve mempools spikes\n>> making obsolete propagation of transactions with pre-signed feerate, solve\n>> pinning attacks compromising Lightning/multi-party contract protocol\n>> safety, offer an usable and stable API to L2 software stack, stay\n>> compatible with miner and full-node operators incentives and obviously\n>> minimize CPU/memory DoS vectors.\n>>\n>> 2) Deprecation of opt-in RBF toward full-rbf. Opt-in RBF makes it trivial\n>> for an attacker to partition network mempools in divergent subsets and from\n>> then launch advanced security or privacy attacks against a Lightning node.\n>> Note, it might also be a concern for bandwidth bleeding attacks against L1\n>> nodes.\n>>\n>> 3) Guidelines about coordinated cross-layers security disclosures.\n>> Mitigating a security issue around tx-relay or the mempool in Core might\n>> have harmful implications for downstream projects. Ideally, L2 projects\n>> maintainers should be ready to upgrade their protocols in emergency in\n>> coordination with base layers developers.\n>>\n>> 4) Guidelines about L2 protocols onchain security design. Currently\n>> deployed like Lightning are making a bunch of assumptions on tx-relay and\n>> mempool acceptances rules. Those rules are non-normative, non-reliable and\n>> lack documentation. Further, they're devoid of tooling to enforce them at\n>> runtime [2]. IMHO, it could be preferable to identify a subset of them on\n>> which second-layers protocols can do assumptions without encroaching too\n>> much on nodes's policy realm or making the base layer development in those\n>> areas too cumbersome.\n>>\n>> I'm aware that some folks are interested in other topics such as\n>> extension of Core's mempools package limits or better pricing of RBF\n>> replacement. So l propose a 2-week concertation period to submit other\n>> topics related to tx-relay or mempools improvements towards L2s before to\n>> propose a finalized scope and agenda.\n>>\n>> # Goals\n>>\n>> 1) Reaching technical consensus.\n>> 2) Reaching technical consensus, before seeking community consensus as it\n>> likely has ecosystem-wide implications.\n>> 3) Establishing a security incident response policy which can be applied\n>> by dev teams in the future.\n>> 4) Establishing a philosophy design and associated documentations (BIPs,\n>> best practices, ...)\n>>\n>> # Timeline\n>>\n>> 2021-04-23: Start of concertation period\n>> 2021-05-07: End of concertation period\n>> 2021-05-10: Proposition of workshop agenda and schedule\n>> late 2021-05/2021-06: IRC meetings\n>>\n>> As the problem space is savagely wide, I've started a collection of\n>> documents to assist this workshop : https://github.com/ariard/L2-zoology\n>> Still wip, but I'll have them in a good shape at agenda publication, with\n>> reading suggestions and open questions to structure discussions.\n>> Also working on transaction pinning and mempool partitions attacks\n>> simulations.\n>>\n>> If L2s security/p2p/mempool is your jam, feel free to get involved :)\n>>\n>> Cheers,\n>> Antoine\n>>\n>> [0] For e.g see optech section on transaction pinning attacks :\n>> https://bitcoinops.org/en/topics/transaction-pinning/\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n>> [2] Lack of reference tooling make it easier to have bug slip in like\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002858.html\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/b87b1ec8/attachment-0001.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-04-23T16:17:36",
                "message_text_only": "Great idea, I'll join as well.\nThanks for setting this in motion.\n\nLe ven. 23 avr. 2021 \u00e0 17:39, Antoine Riard <antoine.riard at gmail.com> a\n\u00e9crit :\n\n> Hi Jeremy,\n>\n> Yes dates are floating for now. After Bitcoin 2021, sounds a good idea.\n>\n> Awesome, I'll be really interested to review again an improved version of\n> sponsorship. And I'll try to sketch out the sighash_no-input fee-bumping\n> idea which was floating around last year during pinnings discussions. Yet\n> another set of trade-offs :)\n>\n> Le ven. 23 avr. 2021 \u00e0 11:25, Jeremy <jlrubin at mit.edu> a \u00e9crit :\n>\n>> I'd be excited to join. Recommend bumping the date  to mid June, if\n>> that's ok, as many Americans will be at Bitcoin 2021.\n>>\n>> I was thinking about reviving the sponsors proposal with a 100 block lock\n>> on spending a sponsoring tx which would hopefully make less controversial,\n>> this would be a great place to discuss those tradeoffs.\n>>\n>> On Fri, Apr 23, 2021, 8:17 AM Antoine Riard <antoine.riard at gmail.com>\n>> wrote:\n>>\n>>> Hi,\n>>>\n>>> During the lastest years, tx-relay and mempool acceptances rules of the\n>>> base layer have been sources of major security and operational concerns for\n>>> Lightning and other Bitcoin second-layers [0]. I think those areas require\n>>> significant improvements to ease design and deployment of higher Bitcoin\n>>> layers and I believe this opinion is shared among the L2 dev community. In\n>>> order to make advancements, it has been discussed a few times in the last\n>>> months to organize in-person workshops to discuss those issues with the\n>>> presence of both L1/L2 devs to make exchange fruitful.\n>>>\n>>> Unfortunately, I don't think we'll be able to organize such in-person\n>>> workshops this year (because you know travel is hard those days...) As a\n>>> substitution, I'm proposing a series of one or more irc meetings. That\n>>> said, this substitution has the happy benefit to gather far more folks\n>>> interested by those issues that you can fit in a room.\n>>>\n>>> # Scope\n>>>\n>>> I would like to propose the following 4 items as topics of discussion.\n>>>\n>>> 1) Package relay design or another generic L2 fee-bumping primitive like\n>>> sponsorship [0]. IMHO, this primitive should at least solve mempools spikes\n>>> making obsolete propagation of transactions with pre-signed feerate, solve\n>>> pinning attacks compromising Lightning/multi-party contract protocol\n>>> safety, offer an usable and stable API to L2 software stack, stay\n>>> compatible with miner and full-node operators incentives and obviously\n>>> minimize CPU/memory DoS vectors.\n>>>\n>>> 2) Deprecation of opt-in RBF toward full-rbf. Opt-in RBF makes it\n>>> trivial for an attacker to partition network mempools in divergent subsets\n>>> and from then launch advanced security or privacy attacks against a\n>>> Lightning node. Note, it might also be a concern for bandwidth bleeding\n>>> attacks against L1 nodes.\n>>>\n>>> 3) Guidelines about coordinated cross-layers security disclosures.\n>>> Mitigating a security issue around tx-relay or the mempool in Core might\n>>> have harmful implications for downstream projects. Ideally, L2 projects\n>>> maintainers should be ready to upgrade their protocols in emergency in\n>>> coordination with base layers developers.\n>>>\n>>> 4) Guidelines about L2 protocols onchain security design. Currently\n>>> deployed like Lightning are making a bunch of assumptions on tx-relay and\n>>> mempool acceptances rules. Those rules are non-normative, non-reliable and\n>>> lack documentation. Further, they're devoid of tooling to enforce them at\n>>> runtime [2]. IMHO, it could be preferable to identify a subset of them on\n>>> which second-layers protocols can do assumptions without encroaching too\n>>> much on nodes's policy realm or making the base layer development in those\n>>> areas too cumbersome.\n>>>\n>>> I'm aware that some folks are interested in other topics such as\n>>> extension of Core's mempools package limits or better pricing of RBF\n>>> replacement. So l propose a 2-week concertation period to submit other\n>>> topics related to tx-relay or mempools improvements towards L2s before to\n>>> propose a finalized scope and agenda.\n>>>\n>>> # Goals\n>>>\n>>> 1) Reaching technical consensus.\n>>> 2) Reaching technical consensus, before seeking community consensus as\n>>> it likely has ecosystem-wide implications.\n>>> 3) Establishing a security incident response policy which can be applied\n>>> by dev teams in the future.\n>>> 4) Establishing a philosophy design and associated documentations (BIPs,\n>>> best practices, ...)\n>>>\n>>> # Timeline\n>>>\n>>> 2021-04-23: Start of concertation period\n>>> 2021-05-07: End of concertation period\n>>> 2021-05-10: Proposition of workshop agenda and schedule\n>>> late 2021-05/2021-06: IRC meetings\n>>>\n>>> As the problem space is savagely wide, I've started a collection of\n>>> documents to assist this workshop : https://github.com/ariard/L2-zoology\n>>> Still wip, but I'll have them in a good shape at agenda publication,\n>>> with reading suggestions and open questions to structure discussions.\n>>> Also working on transaction pinning and mempool partitions attacks\n>>> simulations.\n>>>\n>>> If L2s security/p2p/mempool is your jam, feel free to get involved :)\n>>>\n>>> Cheers,\n>>> Antoine\n>>>\n>>> [0] For e.g see optech section on transaction pinning attacks :\n>>> https://bitcoinops.org/en/topics/transaction-pinning/\n>>> [1]\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html\n>>> [2] Lack of reference tooling make it easier to have bug slip in like\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002858.html\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/09108adc/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "L2s Onchain Support IRC Workshop",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Jeremy",
                "Antoine Riard"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 21732
        }
    },
    {
        "title": "[Lightning-dev] Increase channel-jamming capital requirements by not counting dust HTLCs",
        "thread_messages": [
            {
                "author": "Eugene Siegel",
                "date": "2021-04-23T15:58:18",
                "message_text_only": "I propose a simple mitigation to increase the capital requirement of\nchannel-jamming attacks. This would prevent an unsophisticated attacker\nwith low capital from jamming a target channel.  It seems to me that this\nis a *free* mitigation without any downsides (besides code-writing), so I'd\nlike to hear other opinions.\n\nIn a commitment transaction, we trim dust HTLC outputs.  I believe that the\nreason for the 483 HTLC limit each side has in the spec is to prevent\ncommitment tx's from growing unreasonably large, and to ensure they are\nstill valid tx's that can be included in a block.  If we don't include dust\nHTLCs in this calculation, since they are not on the commitment tx, we\nstill allow 483 (x2) non-dust HTLCs to be included on the commitment tx.\nThere could be a configurable limit on the number of outstanding dust\nHTLCs, but the point is that it doesn't affect the non-dust throughput of\nthe channel.  This raises the capital requirement of channel-jamming so\nthat each HTLC must be non-dust, rather than spamming 1 sat payments.\n\nInterested in others' thoughts.\n\nEugene (Crypt-iQ)\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/28a7f555/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-04-23T16:24:26",
                "message_text_only": "Hi Eugene,\n\nThe reason dust HTLCs count for the 483 HTLC limit is because of\n`update_fee`.\nIf you don't count them and exceed the 483 HTLC limit, you can't lower the\nfee anymore\nbecause some HTLCs that were previously dust won't be dust anymore and you\nmay end\nup with more than 483 HTLC outputs in your commitment, which opens the door\nto other\nkinds of attacks.\n\nThis is the first issue that comes to mind, but there may be other\ndrawbacks if we dig into\nthis enough with an attacker's mindset.\n\nBastien\n\nLe ven. 23 avr. 2021 \u00e0 17:58, Eugene Siegel <elzeigel at gmail.com> a \u00e9crit :\n\n> I propose a simple mitigation to increase the capital requirement of\n> channel-jamming attacks. This would prevent an unsophisticated attacker\n> with low capital from jamming a target channel.  It seems to me that this\n> is a *free* mitigation without any downsides (besides code-writing), so I'd\n> like to hear other opinions.\n>\n> In a commitment transaction, we trim dust HTLC outputs.  I believe that\n> the reason for the 483 HTLC limit each side has in the spec is to prevent\n> commitment tx's from growing unreasonably large, and to ensure they are\n> still valid tx's that can be included in a block.  If we don't include dust\n> HTLCs in this calculation, since they are not on the commitment tx, we\n> still allow 483 (x2) non-dust HTLCs to be included on the commitment tx.\n> There could be a configurable limit on the number of outstanding dust\n> HTLCs, but the point is that it doesn't affect the non-dust throughput of\n> the channel.  This raises the capital requirement of channel-jamming so\n> that each HTLC must be non-dust, rather than spamming 1 sat payments.\n>\n> Interested in others' thoughts.\n>\n> Eugene (Crypt-iQ)\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/9068d4e9/attachment-0001.html>"
            },
            {
                "author": "Eugene Siegel",
                "date": "2021-04-23T21:44:07",
                "message_text_only": "Thanks for replying.\n\nI was under the impression that long-term update_fee was going to be\nremoved since second-level HTLC txn's can bring their own fees?\n\nOn Fri, Apr 23, 2021 at 12:24 PM Bastien TEINTURIER <bastien at acinq.fr>\nwrote:\n\n> Hi Eugene,\n>\n> The reason dust HTLCs count for the 483 HTLC limit is because of\n> `update_fee`.\n> If you don't count them and exceed the 483 HTLC limit, you can't lower the\n> fee anymore\n> because some HTLCs that were previously dust won't be dust anymore and you\n> may end\n> up with more than 483 HTLC outputs in your commitment, which opens the\n> door to other\n> kinds of attacks.\n>\n> This is the first issue that comes to mind, but there may be other\n> drawbacks if we dig into\n> this enough with an attacker's mindset.\n>\n> Bastien\n>\n> Le ven. 23 avr. 2021 \u00e0 17:58, Eugene Siegel <elzeigel at gmail.com> a \u00e9crit :\n>\n>> I propose a simple mitigation to increase the capital requirement of\n>> channel-jamming attacks. This would prevent an unsophisticated attacker\n>> with low capital from jamming a target channel.  It seems to me that this\n>> is a *free* mitigation without any downsides (besides code-writing), so I'd\n>> like to hear other opinions.\n>>\n>> In a commitment transaction, we trim dust HTLC outputs.  I believe that\n>> the reason for the 483 HTLC limit each side has in the spec is to prevent\n>> commitment tx's from growing unreasonably large, and to ensure they are\n>> still valid tx's that can be included in a block.  If we don't include dust\n>> HTLCs in this calculation, since they are not on the commitment tx, we\n>> still allow 483 (x2) non-dust HTLCs to be included on the commitment tx.\n>> There could be a configurable limit on the number of outstanding dust\n>> HTLCs, but the point is that it doesn't affect the non-dust throughput of\n>> the channel.  This raises the capital requirement of channel-jamming so\n>> that each HTLC must be non-dust, rather than spamming 1 sat payments.\n>>\n>> Interested in others' thoughts.\n>>\n>> Eugene (Crypt-iQ)\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210423/5765f8e9/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-24T04:02:38",
                "message_text_only": "The update_fee message does not, as far as I recall, change the dust limit for outputs in a channel (though I\u2019ve suggested making such a change).\n\n> On Apr 23, 2021, at 12:24, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n> \n> \ufeff\n> Hi Eugene,\n> \n> The reason dust HTLCs count for the 483 HTLC limit is because of `update_fee`.\n> If you don't count them and exceed the 483 HTLC limit, you can't lower the fee anymore\n> because some HTLCs that were previously dust won't be dust anymore and you may end\n> up with more than 483 HTLC outputs in your commitment, which opens the door to other\n> kinds of attacks.\n> \n> This is the first issue that comes to mind, but there may be other drawbacks if we dig into\n> this enough with an attacker's mindset.\n> \n> Bastien\n> \n>> Le ven. 23 avr. 2021 \u00e0 17:58, Eugene Siegel <elzeigel at gmail.com> a \u00e9crit :\n>> I propose a simple mitigation to increase the capital requirement of channel-jamming attacks. This would prevent an unsophisticated attacker with low capital from jamming a target channel.  It seems to me that this is a *free* mitigation without any downsides (besides code-writing), so I'd like to hear other opinions.\n>> \n>> In a commitment transaction, we trim dust HTLC outputs.  I believe that the reason for the 483 HTLC limit each side has in the spec is to prevent commitment tx's from growing unreasonably large, and to ensure they are still valid tx's that can be included in a block.  If we don't include dust HTLCs in this calculation, since they are not on the commitment tx, we still allow 483 (x2) non-dust HTLCs to be included on the commitment tx.  There could be a configurable limit on the number of outstanding dust HTLCs, but the point is that it doesn't affect the non-dust throughput of the channel.  This raises the capital requirement of channel-jamming so that each HTLC must be non-dust, rather than spamming 1 sat payments.\n>> \n>> Interested in others' thoughts.\n>> \n>> Eugene (Crypt-iQ)\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210424/b09dc276/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-04-24T08:01:28",
                "message_text_only": "You're right, I was thinking about trimmed HTLCs (which can re-appear in\nthe commit tx\nif you lower the feerate via update_fee).\n\nDust HTLCs will never appear in the commit tx regardless of subsequent\nupdate_fees,\nso Eugene's suggestion could make sense!\n\nLe sam. 24 avr. 2021 \u00e0 06:02, Matt Corallo <lf-lists at mattcorallo.com> a\n\u00e9crit :\n\n> The update_fee message does not, as far as I recall, change the dust limit\n> for outputs in a channel (though I\u2019ve suggested making such a change).\n>\n> On Apr 23, 2021, at 12:24, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>\n> \ufeff\n> Hi Eugene,\n>\n> The reason dust HTLCs count for the 483 HTLC limit is because of\n> `update_fee`.\n> If you don't count them and exceed the 483 HTLC limit, you can't lower the\n> fee anymore\n> because some HTLCs that were previously dust won't be dust anymore and you\n> may end\n> up with more than 483 HTLC outputs in your commitment, which opens the\n> door to other\n> kinds of attacks.\n>\n> This is the first issue that comes to mind, but there may be other\n> drawbacks if we dig into\n> this enough with an attacker's mindset.\n>\n> Bastien\n>\n> Le ven. 23 avr. 2021 \u00e0 17:58, Eugene Siegel <elzeigel at gmail.com> a \u00e9crit :\n>\n>> I propose a simple mitigation to increase the capital requirement of\n>> channel-jamming attacks. This would prevent an unsophisticated attacker\n>> with low capital from jamming a target channel.  It seems to me that this\n>> is a *free* mitigation without any downsides (besides code-writing), so I'd\n>> like to hear other opinions.\n>>\n>> In a commitment transaction, we trim dust HTLC outputs.  I believe that\n>> the reason for the 483 HTLC limit each side has in the spec is to prevent\n>> commitment tx's from growing unreasonably large, and to ensure they are\n>> still valid tx's that can be included in a block.  If we don't include dust\n>> HTLCs in this calculation, since they are not on the commitment tx, we\n>> still allow 483 (x2) non-dust HTLCs to be included on the commitment tx.\n>> There could be a configurable limit on the number of outstanding dust\n>> HTLCs, but the point is that it doesn't affect the non-dust throughput of\n>> the channel.  This raises the capital requirement of channel-jamming so\n>> that each HTLC must be non-dust, rather than spamming 1 sat payments.\n>>\n>> Interested in others' thoughts.\n>>\n>> Eugene (Crypt-iQ)\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210424/e0afd2d9/attachment.html>"
            },
            {
                "author": "Bastien TEINTURIER",
                "date": "2021-04-26T07:13:00",
                "message_text_only": "I looked into this more closely, and as far as I understand it, the spec\nalready states that you should not count dust HTLCs:\n\n*if result would be offering more than the remote's max_accepted_htlcs\nHTLCs, in the remote commitment transaction: *\n\n   - *MUST NOT add an HTLC.*\n\nNote that it clearly says \"in the remote commitment transaction\", which\nmeans\nyou don't count HTLCs that are dust or trimmed.\n\nThat matches eclair's behavior: we don't count dust HTLCs towards that\nlimit.\nIs lnd including them in that count? What about other implementations?\nIf that's the case, that can simply be fixed in lnd without any spec change\nIMHO.\n\nNote that this also excludes trimmed HTLCs from the count, which means that\nnodes that set `max_accepted_htlcs` to 483 may be exposed to the issue I\ndescribed earlier (impossible to lower the feerate because the HTLC count\nwould\nbecome greater than the limit).\n\nBastien\n\nLe sam. 24 avr. 2021 \u00e0 10:01, Bastien TEINTURIER <bastien at acinq.fr> a\n\u00e9crit :\n\n> You're right, I was thinking about trimmed HTLCs (which can re-appear in\n> the commit tx\n> if you lower the feerate via update_fee).\n>\n> Dust HTLCs will never appear in the commit tx regardless of subsequent\n> update_fees,\n> so Eugene's suggestion could make sense!\n>\n> Le sam. 24 avr. 2021 \u00e0 06:02, Matt Corallo <lf-lists at mattcorallo.com> a\n> \u00e9crit :\n>\n>> The update_fee message does not, as far as I recall, change the dust\n>> limit for outputs in a channel (though I\u2019ve suggested making such a change).\n>>\n>> On Apr 23, 2021, at 12:24, Bastien TEINTURIER <bastien at acinq.fr> wrote:\n>>\n>> \ufeff\n>> Hi Eugene,\n>>\n>> The reason dust HTLCs count for the 483 HTLC limit is because of\n>> `update_fee`.\n>> If you don't count them and exceed the 483 HTLC limit, you can't lower\n>> the fee anymore\n>> because some HTLCs that were previously dust won't be dust anymore and\n>> you may end\n>> up with more than 483 HTLC outputs in your commitment, which opens the\n>> door to other\n>> kinds of attacks.\n>>\n>> This is the first issue that comes to mind, but there may be other\n>> drawbacks if we dig into\n>> this enough with an attacker's mindset.\n>>\n>> Bastien\n>>\n>> Le ven. 23 avr. 2021 \u00e0 17:58, Eugene Siegel <elzeigel at gmail.com> a\n>> \u00e9crit :\n>>\n>>> I propose a simple mitigation to increase the capital requirement of\n>>> channel-jamming attacks. This would prevent an unsophisticated attacker\n>>> with low capital from jamming a target channel.  It seems to me that this\n>>> is a *free* mitigation without any downsides (besides code-writing), so I'd\n>>> like to hear other opinions.\n>>>\n>>> In a commitment transaction, we trim dust HTLC outputs.  I believe that\n>>> the reason for the 483 HTLC limit each side has in the spec is to prevent\n>>> commitment tx's from growing unreasonably large, and to ensure they are\n>>> still valid tx's that can be included in a block.  If we don't include dust\n>>> HTLCs in this calculation, since they are not on the commitment tx, we\n>>> still allow 483 (x2) non-dust HTLCs to be included on the commitment tx.\n>>> There could be a configurable limit on the number of outstanding dust\n>>> HTLCs, but the point is that it doesn't affect the non-dust throughput of\n>>> the channel.  This raises the capital requirement of channel-jamming so\n>>> that each HTLC must be non-dust, rather than spamming 1 sat payments.\n>>>\n>>> Interested in others' thoughts.\n>>>\n>>> Eugene (Crypt-iQ)\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210426/a59c0007/attachment.html>"
            },
            {
                "author": "Eugene Siegel",
                "date": "2021-04-26T15:03:15",
                "message_text_only": "Lnd counts dust + trimmed HTLCs towards max_accepted_htlcs.  We definitely\nshouldn't be counting dust towards that amount.  I would have to think more\nabout the issue where it's not possible to lower the feerate though.  That\nseems like a spec issue?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210426/cf896556/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2021-04-26T15:08:18",
                "message_text_only": "> I looked into this more closely, and as far as I understand it, the spec\nalready states that you should not count dust HTLCs:\n\nOops! We do the same thing, we will fix that.\n\nOn 4/26/21 11:03, Eugene Siegel wrote:\n> I would have to think more about the issue where it's not possible to lower the feerate though.\u00a0 That seems \n> like a spec issue?\n\nThere is no current in-protocol way to change the dust limit, so the issue doesn't apply here."
            }
        ],
        "thread_summary": {
            "title": "Increase channel-jamming capital requirements by not counting dust HTLCs",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bastien TEINTURIER",
                "Matt Corallo",
                "Eugene Siegel"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 16112
        }
    },
    {
        "title": "[Lightning-dev] Making unannounced channels harder to probe",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-04-24T04:09:18",
                "message_text_only": "Hi all,\n\n        You can currently probe for a channel id attached to node N by\nsending an HTLC, and seeing whether the error reply comes from the N or\nthe next hop.  The real answer is to get back to blinded paths, BTW.\n\nBut Joost pointed out that you need to know the node_id of the next node\nthough: this isn't quite true, since if the node_id is wrong the spec\nsays you should send an `update_fail_malformed_htlc` with failure code\ninvalid_onion_hmac, which node N turns into its own failure message.\nPerhaps it should convert it to `unknown_next_peer` instead?  This isn't\na common error on the modern network; I think our onion implementations\nhave been rock solid.\n\nThis doesn't help if you've revealed your node id in other ways\nofc. i.e. you offer me an invoice, now I probe the rest of the network\nto find all unannounced channels you have.  For that, implementations\n*could* choose to return `update_fail_malformed_htlc`\nfailure_code=invalid_onion_hmac as above on anything which comes through\nan unannounced channel but is not a successful payment (or part thereof,\ni.e. correct payment_hash for outstanding invoice with correct\npayment_secret field?).\n\nCheers,\nRusty.\nPS. https://twitter.com/cycryptr/status/1384355046381473792 contains exploration."
            },
            {
                "author": "Joost Jager",
                "date": "2021-04-24T05:51:40",
                "message_text_only": ">\n> But Joost pointed out that you need to know the node_id of the next node\n> though: this isn't quite true, since if the node_id is wrong the spec\n> says you should send an `update_fail_malformed_htlc` with failure code\n> invalid_onion_hmac, which node N turns into its own failure message.\n> Perhaps it should convert it to `unknown_next_peer` instead?  This isn't\n> a common error on the modern network; I think our onion implementations\n> have been rock solid.\n>\n\nIsn't this what I am suggesting here?\nhttps://twitter.com/joostjgr/status/1385150318959341569\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210424/583bf0c4/attachment-0001.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2021-04-24T05:57:46",
                "message_text_only": "Joost Jager <joost.jager at gmail.com> writes:\n>>\n>> But Joost pointed out that you need to know the node_id of the next node\n>> though: this isn't quite true, since if the node_id is wrong the spec\n>> says you should send an `update_fail_malformed_htlc` with failure code\n>> invalid_onion_hmac, which node N turns into its own failure message.\n>> Perhaps it should convert it to `unknown_next_peer` instead?  This isn't\n>> a common error on the modern network; I think our onion implementations\n>> have been rock solid.\n>>\n>\n> Isn't this what I am suggesting here?\n> https://twitter.com/joostjgr/status/1385150318959341569\n\nOops, I didn't read the second part of your tweet properly.\n\nSorry: this was right there indeed.\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Making unannounced channels harder to probe",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Joost Jager"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 2758
        }
    }
]