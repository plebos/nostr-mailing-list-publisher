[
    {
        "title": "[Lightning-dev] 2-of-3 Instant Escrow, or How to Do \"2-of-3 Multisig Contract\" Equivalent on Lightning",
        "thread_messages": [
            {
                "author": "Joseph Poon",
                "date": "2016-01-17T01:45:33",
                "message_text_only": "TL;DR: It's possible to do 2-of-3 party escrow in Lightning,\nfunctionally the same as the use case for on-chain \"2-of-3 multisig\"\nescrow systems (without the 3rd party escrow being a custodian for any\nfunds! Or anyone else holding custodial ownership of coins for the\nmatter). As Lightning uses Bitcoin transactions and scripts (using\nBitcoins, not 3rdPartyCoins), it'll be possible to do nearly *instant*\n*offchain* multisig \"escrow\" on decentralized Lightning! This is useful\nfor payments for goods and services which needs a 3rd party mediator.\n\nBy making multiple R-value hashes supported in HTLCs, you can do\nsomething equivalent to \"multisig\" where payments are conditional upon\n2-of-3 parties agreeing. This is to support conditional multiparty\npayments, e.g. 2-of-3 \"escrow\", which is one of the biggest use cases of\nbitcoin scripting today. An example use case is a 3rd party escrow\nverifies whether a seller should be paid. This design is such that the\nescrow is not a traditional custodial escrow, but instead determines who\nshould get the money in the event of non-cooperation. See the Bitcoin\nScript below for details.\n\nThere isn't message integration for 2-of-3 yet, but can work with *very*\nminimal changes. Arbitrary N-of-M can be supported with M values higher\nthan 3 and lower than max script size, but let's keep this simple for\nnow!\n\nHow it works: Require 2-of-3 R-value preimages (from 3 hashes) in order\nfor the HTLC to be fulfilled. For each hop in the payment, it requires\nthis 2-of-3 condition. The timeout minimum for each hop in the path is\nat least the minimum agreed contractual escrow timeout. The timeouts\nshould be fairly long compared to straight payments for security and\ngiving enough time for the escrow service. This means each hop consumes\na higher amount of time-value (due to much longer timeouts along all\nchannels in the path, and possibly higher fees to pay for larger scripts\nand greater time-sensitivity for transaction inclusion), which does have\ngreater pressure towards lower hop-distances, compared to straight\npayments where it matters a whole lot less.\n\nThis is a slightly different way of thinking about things. It's not\nsignatures that the escrow produces (or for that matters any of the\n3-parties in the 2-of-3 after the actual Commitment is signed). It's\nsome secret which is revealed to authorize payment. So if the escrow\nwants the payment to go through without cooperation of the sender, they\ndisclose the secret (R-value) to the recipient. If the recipient is\nunable to produce 2-of-3, after the agreed timeout, the sender will be\nrefunded. Sender and receiver can agree to authorize payment in most\ncases where there is cooperation, escrow is only contacted if there is\nnon-cooperation.\n\nAssume the order in the stack is Sender, Escrow, Recipient.\n\nFor PAID 2-of-3 Escrow+Recipient, the HTLC stack is:\n        <BobSig> <0> <EscrowPreimageR> <RecipientPreimageR> <0>\n\nIf it's REFUND because 2-of-3 has not been redeemed in time:\n        <AliceSig> <0> <1>\n\nBitcoin Script (Alice's, we use OP_1/OP_0 to distinctly show computed\ntrue/false. 0/1 is for supplied data as part of the\nsigScript/redeemScript stack):\n------------------------------------------------------------------------\n\n//Paid\nOP_IF\n        <CSVDelay> OP_DROP OP_CSV //under rusty's CSV style\n\n        //Stack: <BobSig> <0> <EscrowPreimageR> <RecipientPreimageR>\n        //Recipient must agree to receive funds.\n        OP_HASH160 <RecipientHash> OP_EQUALVERIFY\n\n        //Stack: <BobSig> <0> <EscrowPreimageR>\n        //Either the Sender or Escrow must consent for payment\n        OP_HASH160 <EscrowHash> OP_EQUAL\n        //Stack: <BobSig> <0> <OP_1>\n        OP_SWAP\n        //Stack: <BobSig> <OP_1> <0>\n        OP_HASH160 <SenderHash> OP_EQUAL\n        //Stack: <BobSig> <OP_1> <OP_0>\n        OP_BOOLOR\n        //Stack: <BobSig> <OP_1>\n        OP_VERIFY\n\n        <BobPubKey>\n        //Stack: <BobSig> <BobPubKey>\n//Refund\nOP_ELSE\n        //Stack: <AliceSig> <0>\n        OP_HASH160 OP_DUP\n        <R-HASH> OP_EQUAL\n        OP_NOTIF\n                <CSVDelay> OP_DROP OP_CSV\n        OP_ENDIF\n\n        <HTLCTimeout> OP_DROP OP_CLTV\n\n        //Stack: <AliceSig>\n        <AlicePubKey>\n        //Stack: <AliceSig> <AlicePubKey>\nOP_ENDIF\nOP_CHECKSIG\n------------------------------------------------------------------------\n\nNote: It is possible that Alice and Bob may not be Sender, Recipient,\nnor Escrow! They could be nodes along the routing path. Script might\nhave a typo or two or might be able to be optimized a couple bytes\nsmaller maybe? Also, the script would be a bit different depending upon\nis broadcasting due to the revocations/R-HASH.\n\nThe result? We can do 2-of-3 escrow payments which refund to the sender\nafter a timeout! The Sender and Recipient can agree to redeem and they\nonly need to go to the Escrow if there's a dispute. All nodes along the\npath gets paid or refunded atomically, the same as a single-HTLC payment\non Lightning. Escrowed payments can be nearly instant and off-chain (but\nenforced/net-settled ultimately using the blockchain).\n\nProposed HTLC wire message for the uint8 (two 4-bit N-of-M) determining\ntype:\n0x11 (00010001): 1-of-1\n0x22 (00100010): 2-of-2\n0x23 (00100011): 2-of-3 [with Recipient being 1 of the two N parties]\n0x33 (00110011): 3-of-3\n\nI think the only ones that really matter are 1-of-1, 2-of-3, and 2-of-2.\n1-of-2 and 1-of-3 doesn't make sense if the recipient must consent to\nreceiving funds anyway (pushing funds w/o consent is tricky due to\npay-to-contract-hash) so that's basically a 1-of-1.\n\nPossible Resolution States:\n* Recipient paid: Recipient and Sender provide R-values\n* Recipient paid: Recipient and Escrow provide R-values\n* Sender refunded via timeout: Sender is refunded if Recipient cannot\n  convince Escrow or Sender to disclose their R-value before HTLC\n  timeout\n* Payment immediately cancelled and Sender gets refunded: Payment sent\n  in the opposite direction enforced by same R-values (if there is\n  sender & receiver consent/cooperation to cancel payment)\n\nSender+Escrow isn't going to want to push funds w/o cooperation of\nRecipient. However, it's possible to construct a script that way.\n\nEscrow is only contacted if the recipient needs to redeem and the sender\nis uncooperative so this is still true to the \"lazy escrow service\" in\nBitcoin multisig.\n\nTa-da! \"Smart Contract(TM)\" meme on Lightning.\n\nP.S. Tadge, Laolu, and I have also put up a repo of our in-progress\ndesign/code for Lightning here: https://github.com/LightningNetwork/lnd\n\n-- \nJoseph Poon"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-01-18T00:00:30",
                "message_text_only": "Joseph Poon <joseph at lightning.network> writes:\n> TL;DR: It's possible to do 2-of-3 party escrow in Lightning,\n> functionally the same as the use case for on-chain \"2-of-3 multisig\"\n> escrow systems (without the 3rd party escrow being a custodian for any\n> funds! Or anyone else holding custodial ownership of coins for the\n> matter). As Lightning uses Bitcoin transactions and scripts (using\n> Bitcoins, not 3rdPartyCoins), it'll be possible to do nearly *instant*\n> *offchain* multisig \"escrow\" on decentralized Lightning! This is useful\n> for payments for goods and services which needs a 3rd party mediator.\n\nHi Joseph,\n\n        This is a very nice variant!  As you say, it's not complex\neither (it works just as well with privkey-instead-of-preimage variants,\ntoo, though I suspect that case can be compacted more than the naive\n\"just duplicate the whole script\").\n\n>From an inter-node transport perspective, all you really care about is\nhow many values per contract, AFAICT.  It's up to the sender and\nreceiver to agree on an escrow agent, figure out how to communicate to\nthem, etc.\n\n> P.S. Tadge, Laolu, and I have also put up a repo of our in-progress\n> design/code for Lightning here: https://github.com/LightningNetwork/lnd\n\nCongratulations!  I'm going to wade through this week and try to create\na list of wire protocol differences so we get closer to a final version.\n\nNice work!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "2-of-3 Instant Escrow, or How to Do \"2-of-3 Multisig Contract\" Equivalent on Lightning",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Joseph Poon"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 7954
        }
    },
    {
        "title": "[Lightning-dev] Some more lightning-related git repos",
        "thread_messages": [
            {
                "author": "Bryan Bishop",
                "date": "2016-01-17T08:02:29",
                "message_text_only": "I saw these two repositories through the -wizards IRC channel earlier\ntoday. I have not reviewed any of the source code for quality, security or\nfunctionality, so I don't have word to offer regarding status of these.\n\nhttps://github.com/LightningNetwork/lnd\nhttps://github.com/LightningNetwork/lightning-onion\n\nAlso other git repositories with related work:\nhttps://github.com/ElementsProject/lightning\nhttps://github.com/matsjj/thundernetwork\n\n- Bryan\nhttp://heybryan.org/\n1 512 203 0507\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160117/62dee7f2/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2016-01-22T09:35:26",
                "message_text_only": "Hi guys,\n\nAnother lightning repo! https://github.com/ACINQ/eclair\n\nThis is a scala implementation of \"deployable lightning\". The idea is to\nhave an actor per lightning channel, and keep everything non-blocking.\n\nIt should be fully compatible with rusty&aj's implementation (that is, when\nwe add networking ;-)). In particular it uses the same protobuf messages,\nand a similar state machine. There is also some prototyping on the\nsoon-to-be replaced onion routing.\n\nI'm looking forward to an agreement on the wire protocol !\n\nCheers,\n\nPierre\n\n\n2016-01-17 9:02 GMT+01:00 Bryan Bishop <kanzure at gmail.com>:\n\n> I saw these two repositories through the -wizards IRC channel earlier\n> today. I have not reviewed any of the source code for quality, security or\n> functionality, so I don't have word to offer regarding status of these.\n>\n> https://github.com/LightningNetwork/lnd\n> https://github.com/LightningNetwork/lightning-onion\n>\n> Also other git repositories with related work:\n> https://github.com/ElementsProject/lightning\n> https://github.com/matsjj/thundernetwork\n>\n> - Bryan\n> http://heybryan.org/\n> 1 512 203 0507\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160122/d34d3aa6/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Some more lightning-related git repos",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Bryan Bishop",
                "Pierre"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2175
        }
    },
    {
        "title": "[Lightning-dev] Lightning C prototype v0.2: \"Butterfly Labs' Timely Delivery\"",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-01-21T22:43:15",
                "message_text_only": "Hi all,\n\n        Thanks to Anthony Towns, who as a new contributor got to name\nthe release.  Future releases will be more regular!\n\n        This release has a daemon which does the crypto handshake and\ncan connect to other daemons, establish channels, negotiate and fulfull\nHTLCs, and close them.\n\n        What it doesn't do: stealing old transactions if they're\npublished, handling (unilateral) close with HTLCs, nor routing or fee\nnegotiation.\n\n        In addition, there is very little testing and many known bugs:\n110 FIXMEs at current count!\n\nPlans for the next release:\n        - Nail down the remaining unhandled inter-node protocol cases.\n        - More testing and bugfixes.\n        - Revisit crypto and packet format vs. https://github.com/LightningNetwork/lnd\n\nFor a guide to the source, see:\n\n        https://github.com/ElementsProject/lightning/blob/master/HACKING.md\n\nCheers!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Lightning C prototype v0.2: \"Butterfly Labs' Timely Delivery\"",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 896
        }
    },
    {
        "title": "[Lightning-dev] Laundry list of inter-peer wire protocol changes",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2016-01-27T03:07:04",
                "message_text_only": "Hi all!\n\n        As more code emerges, I'd like to try to nail down a \"1.0\"\nversion of the inter-node protocol as much as possible.  Since I'm most\nfamiliar with my own code (c-lightning[1]), I'll use that as a basis and\ndiscuss differences (esp. vs lnd[2]).\n\nFor this email I'll simply list the changes or proposals I'm aware of,\nthen we can dissect and comment on each one: defer, accept or close.\n\nDirect wire format stuff\n------------------------\n\n- Protobufs vs open-coded structures\n  - lnd open-coded their own protocol; I haven't finished reading their\n    code though.\n  - protobufs are easy to extend with new fields; with an open-coded\n    proto we simply need a rule that too-long packets are valid.\n  - protobufs are annoying for fixed-length blobs which we use a lot\n    (keys, signatures, hashes).\n  - The protocol is currently simple with very few variable-length fields.\n\n- Length prefix for initial key exchange\n  - Both lnd and c-lightning begin by exchanging a 33-byte EC key for DH.\n  - We should prefix with a length word, so we can extend this later\n    (eg. for new crypto)\n\n- Length prefix for other packets\n  - lightning-c sends an 8 byte prefix indicating the offset of the end of\n    the current packet: this effectively encodes both length and ordering.\n  - lnd uses a 4 byte network ID, 4 byte type, 4 byte length.\n\n- HTLC pipelining\n  - lnd's protocol supports multiple in-flight HTLC negotiations; this\n    would allow much greater throughput, with some complexity.\n  - lightning-c uses a simple one-at-a-time scheme, with alternating\n    priority in case of simultaneous sends.\n\n- HTLC abort stage\n  - Setting up a new HTLC involves both sides accepting, then revocation\n    message exchange.  Currently there's no way to abort this process.\n  - Allow the initator to abort any time before the revocation exchange,\n    for weird corner cases such as timeouts.\n\n- Version bits\n  - If we use an open-coded protocol, initial handshake after key setup\n    should exchange two sets of version bits: one for compulsory\n    features, one for optional features.  You hang up if there's a\n    compulsory feature you don't grok.\n\nWire protocol crypto\n--------------------\n- Crypto AES/HMAC-SHA256 or Chacha20/Poly1305\n  - AES has the word Standard in the name, but chacha20 is faster w/o\n    accel (ie. ARM) and almost as widely supported.\n   \n- Use separate encoding stream for packet lengths\n  - Laolu's suggestion; encode the packet lengths as well which makes\n    traffic analysis a bit harder.\n  - Makes it a bit harder to detect re-transmissions (required on node\n    restart), but probably not enough to kill the idea?\n\nMisc\n----\n- shachain vs elkrem\n  - We use this to generate the revocation secrets, to minimize storage\n    and computation for a huge number of old commitment txs.\n  - They're actually very similar, but elkrem is much easier to grok.[6]\n\n- Anchor tx renegotiation\n  - We should allow re-anchoring of channels, to add or remove funds.\n      - This would allow easy payment from lightning channel to normal\n        bitcoin addresses, for example.\n  - During transition, signatures for both commit txs must be exchanged.\n\n- R value vs keypair\n  - Using a simple secret \"redeemhash\" allows easy tracing of\n    transactions through the network.\n  - Mats Jeratsch proposed a keypair scheme which decorrelates them[3],\n    Greg Maxwell optimized it slightly, and Anthony Towns[4] and Andrew\n    Poelstra independently came up with a way to do it without any\n    bitcoin mods.\n\n- Multi-sig txs\n  - Joseph pointed out that by simply allowing more than one signature on\n    commit txs[5], we can enable escrow-style services (including things\n    like GreenAddress.it which does this for normal wallets).\n\nI'm sure I've missed things; what are they?\n\nThanks!\nRusty.\n\n[1] https://github.com/ElementsProject/lightning\n[2] https://github.com/LightningNetwork/lnd\n[3] http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000314.html\n[4] http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000344.html\n[5] http://lists.linuxfoundation.org/pipermail/lightning-dev/2016-January/000403.html\n[6] https://github.com/LightningNetwork/lnd/blob/master/elkrem/elkrem.go"
            },
            {
                "author": "Mats Jerratsch",
                "date": "2016-01-27T07:00:53",
                "message_text_only": "-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nGreat point Rusty, given how many implementations are emerging, we\nshould press more for compatibility.\n\nBefore making comments, just a quick reminder that everyone is invited\nin cloning\n\nhttps://github.com/lightning-core/lightning\n\nand writing up their specifications so others do not have to search\nthrough code, plus separating code from design is good practice. It\nwill also be easier to commit to them once the discussion is done.\n\n\n\n> For this email I'll simply list the changes or proposals I'm aware\n> of, then we can dissect and comment on each one: defer, accept or\n> close.\nI am so free and add changes from TN :)\n\n> \n> Direct wire format stuff ------------------------\n> \n> - Protobufs vs open-coded structures - lnd open-coded their own\n> protocol; I haven't finished reading their code though. - protobufs\n> are easy to extend with new fields; with an open-coded proto we\n> simply need a rule that too-long packets are valid. - protobufs are\n> annoying for fixed-length blobs which we use a lot (keys,\n> signatures, hashes). - The protocol is currently simple with very\n> few variable-length\nfields.\n- - TN currently is using JSON encoded objects. It is by no standard\nefficient, but allows for easy integration of other systems and\nit's easy to extend/modify.\n\nRight now I think the open-coded messaging is a bit too much. You\ndon't get the efficiency of protobufs, nor the readibility of JSON,\nbut still have to manually code each serialisation/deserialisation,\nand each change to the messages has to be carefully inserted into\nthese functions.\n\nI still don't think JSON is a bad choice for the beginning. If it\nactually turns out to be a bottleneck it is a very low-hanging fruit.\n\nI would rather adapt something like protobufs if it comes to it. (I\nheard there are other *bufs, maybe some of these serve us better?)\n\n\n> - Length prefix for initial key exchange - Both lnd and c-lightning\n> begin by exchanging a 33-byte EC key\nfor DH.\n> - We should prefix with a length word, so we can extend this later \n> (eg. for new crypto)\nAgree, same on TN.\n\nWon't new crypto be non-compatibily anyways?\n\n> - Length prefix for other packets - lightning-c sends an 8 byte\n> prefix indicating the offset of the\nend of\n> the current packet: this effectively encodes both length and\nordering.\n> - lnd uses a 4 byte network ID, 4 byte type, 4 byte length.\n- - TN uses 4 byte length, type is JSON encoded (message types are\ncompletely taken care of of GSON)\n\nI agree that a network ID prefix might make sense. Probably worth\ndesigning for an equivalent of testnet (and they should not just\ndiffer by the standard port they run on... )\n\n> \n> - HTLC pipelining - lnd's protocol supports multiple in-flight HTLC\n> negotiations; this would allow much greater throughput, with some\n> complexity. - lightning-c uses a simple one-at-a-time scheme, with\n> alternating priority in case of simultaneous sends.\n- - TN allows for adding / settling / refunding arbitrary amount of\nHTLCs at the same time.\n\nAgree with lnd here, the complexity is worth it IMO.\n\n> - HTLC abort stage - Setting up a new HTLC involves both sides\n> accepting, then revocation message exchange.  Currently there's no\n> way to abort this process. - Allow the initator to abort any time\n> before the revocation exchange, for weird corner cases such as\n> timeouts.\n- - TN allows for any party to start a new exchange to abort the\ncurrent one. I adapted the dice-rolling from CJP, in case both\ninitiate at the same time.\n- - It is important be careful with revocation hashes when aborting.\nYou don't want the other party to hold on to an unrevoked tx...\n> \n> - Version bits - If we use an open-coded protocol, initial\n> handshake after key setup should exchange two sets of version bits:\n> one for compulsory features, one for optional features.  You hang\n> up if there's a compulsory feature you don't grok.\n\nGood point, agree here.\n\n> Wire protocol crypto -------------------- - Crypto AES/HMAC-SHA256\n> or Chacha20/Poly1305 - AES has the word Standard in the name, but\n> chacha20 is faster w/o accel (ie. ARM) and almost as widely\n> supported.\n> \n> - Use separate encoding stream for packet lengths - Laolu's\n> suggestion; encode the packet lengths as well which makes traffic\n> analysis a bit harder. - Makes it a bit harder to detect\n> re-transmissions (required on node restart), but probably not\n> enough to kill the idea?\n> \n> Misc ---- - shachain vs elkrem - We use this to generate the\n> revocation secrets, to minimize storage and computation for a huge\n> number of old commitment txs. - They're actually very similar, but\n> elkrem is much easier to grok.[6]\n\nTBD on TN, they both sound solid, I agree with elkrem being easier to\nimplement.\n\n> \n> - Anchor tx renegotiation - We should allow re-anchoring of\n> channels, to add or remove funds. - This would allow easy payment\n> from lightning channel to normal bitcoin addresses, for example. -\n> During transition, signatures for both commit txs must be\n> exchanged.\n\nThis sounds like a 1.1 feature. Agree that we should allow it, but\ndoes not seem urgent right now.\n\n> - R value vs keypair - Using a simple secret \"redeemhash\" allows\n> easy tracing of transactions through the network. - Mats Jeratsch\n> proposed a keypair scheme which decorrelates them[3], Greg Maxwell\n> optimized it slightly, and Anthony Towns[4] and Andrew Poelstra\n> independently came up with a way to do it without any bitcoin\n> mods.\n\nCurrently I am using R value, I am still a bit afraid of the lengthy\nscripts when doing it without bitcoin mods. Might make sense to just\ndesign the system in a way that it's easy to change later than to\nimplement it already.\n\n> - Multi-sig txs - Joseph pointed out that by simply allowing more\n> than one\nsignature on\n> commit txs[5], we can enable escrow-style services (including\n> things like GreenAddress.it which does this for normal wallets).\n> \n> I'm sure I've missed things; what are they?\n\nWould be great to discuss connection/node failures. TN currently does\nnot support 'picking up' a lost connection again. I feel like anything\nthat MUST be finished on resume should rather be saved on hard disk in\nadvance, designing for various node failure modes.\nRestarting a fresh connection seems to be much cleaner for me?\n\nCheers\n- -- \nMats Jerratsch\nBackend Engineer, Blockchain\ne: mats.jerratsch at blockchain.com\nPGP: https://pgp.mit.edu/pks/lookup?op=get&search=0x7F3EC6CA\n-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAEBCgAGBQJWqGslAAoJEAYZmwZ/PsbK5kkP/Rp1tANr8BDVBLRW6VftoEFr\n6loMF49SUDvOoc21chem+y/eimnazRWzu6Kvcz19jHPZlDJLz3O+YLL//8QY+9Rc\n1ufhNzqy4lQ42Kxqo7wxLQbvaJCL0tlFk/fPjO5pCZY60+FmZQ8MxHemBxRWtNc9\n0BpMq5vUlcxC6AcsGtSaFNWVaoP5Y5FLi1InFVDUTfu9Fpko6hczjCu1MRMDk4DO\nN6db6MOGyi4NTb2sdEGW89deBzuK/hne9CGw+OH3Fi/+gTIWjmYO6OcSA8mCfqhp\nGvSS5CIBn5hzBY0IGd4Y3/KrivSRDfqnBOPUv1Sk9RIdqF+1tePB5u0vlsktM2EN\nZTz/0Ps3pn4PGzKJ76HRE3Qm994rymC9+ulW7f5xLON5ME53owT+GalTJ4oQfhL8\n9k9U0gOKbQFdSj1tQbJPsVhK0MbHdj2FQPv+Ky0dkeuO4n9lsrrNOPEfIayyVtis\nf9yVJ9dhKLU+U9oqE7pBOAVeYX+eqwJlKeqtsTQLGKuG60KjJav/LanPR8u1kkEX\njZN0hWToMfe9Sgu2dhMXl4L6lMn8KOXQTFNcGr+DDw+OVNc9X4YaaYHzIYLz+uTV\nsVL0VTe5ftALGMSYdhYt/i98REQ2+Kd3fzYFUF4QoeepRKdR0HPPaWmtB0XSN4Qi\nGrsltMsYqc/a3Zk59Hli\n=ODl1\n-----END PGP SIGNATURE-----"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-01-29T01:23:30",
                "message_text_only": "Mats Jerratsch <mats.jerratsch at blockchain.com> writes:\n> https://github.com/lightning-core/lightning\n>\n> and writing up their specifications so others do not have to search\n> through code, plus separating code from design is good practice. It\n> will also be easier to commit to them once the discussion is done.\n\nACK.\n\n>> For this email I'll simply list the changes or proposals I'm aware\n>> of, then we can dissect and comment on each one: defer, accept or\n>> close.\n> I am so free and add changes from TN :)\n\nFantastic, thanks.\n\n>> Direct wire format stuff ------------------------\n>> \n>> - Protobufs vs open-coded structures - lnd open-coded their own\n>> protocol; I haven't finished reading their code though. - protobufs\n>> are easy to extend with new fields; with an open-coded proto we\n>> simply need a rule that too-long packets are valid. - protobufs are\n>> annoying for fixed-length blobs which we use a lot (keys,\n>> signatures, hashes). - The protocol is currently simple with very\n>> few variable-length\n> fields.\n> - - TN currently is using JSON encoded objects. It is by no standard\n> efficient, but allows for easy integration of other systems and\n> it's easy to extend/modify.\n>\n> Right now I think the open-coded messaging is a bit too much. You\n> don't get the efficiency of protobufs, nor the readibility of JSON,\n> but still have to manually code each serialisation/deserialisation,\n> and each change to the messages has to be carefully inserted into\n> these functions.\n\nI'm extremely reluctant to use JSON for wire formats beyond prototyping;\nI really prefer formats where there is only one possible representation\nof any given message, and where parsing is as trivial as possible.\n\nI would be generating my serialization code anyway, ideally from some\nspec document directly.\n\nI'll hack up a binary protocol and see if it lines up into nice, neatly\npacked structs.  I can write you a JSON translation layer if you want :)\n\n> I still don't think JSON is a bad choice for the beginning. If it\n> actually turns out to be a bottleneck it is a very low-hanging fruit.\n>\n> I would rather adapt something like protobufs if it comes to it. (I\n> heard there are other *bufs, maybe some of these serve us better?)\n\nUnfortunately the other contender (Capnproto) doesn't fix our worst pain\npoint either, which is fixed-size blobs.\n\n>> - Length prefix for initial key exchange - Both lnd and c-lightning\n>> begin by exchanging a 33-byte EC key\n> for DH.\n>> - We should prefix with a length word, so we can extend this later \n>> (eg. for new crypto)\n> Agree, same on TN.\n>\n> Won't new crypto be non-compatibily anyways?\n\nThe length word makes it backwards compatible.  If you see extra data,\nyou know they're using crypto v2, and ignore the old key.\n\n>> - Length prefix for other packets - lightning-c sends an 8 byte\n>> prefix indicating the offset of the\n> end of\n>> the current packet: this effectively encodes both length and\n> ordering.\n>> - lnd uses a 4 byte network ID, 4 byte type, 4 byte length.\n> - - TN uses 4 byte length, type is JSON encoded (message types are\n> completely taken care of of GSON)\n>\n> I agree that a network ID prefix might make sense. Probably worth\n> designing for an equivalent of testnet (and they should not just\n> differ by the standard port they run on... )\n\nDefinitely in the original handshake, but on every packet seems a bit\nextreme?\n\n>> - HTLC pipelining - lnd's protocol supports multiple in-flight HTLC\n>> negotiations; this would allow much greater throughput, with some\n>> complexity. - lightning-c uses a simple one-at-a-time scheme, with\n>> alternating priority in case of simultaneous sends.\n> - - TN allows for adding / settling / refunding arbitrary amount of\n> HTLCs at the same time.\n>\n> Agree with lnd here, the complexity is worth it IMO.\n\nOK.  There are a few ways of doing it.  Any change is a 4-step process,\n\"offer, accept, sig+oldrevocation, sig+oldrevocation\" (though my\nprotocol put the last sig in the accept, that is ugly and wrong, see\nbelow).\n\nSo simplest is to tag each one with what HTLC it's talking about: lnd\nintroduces 64 bit HTLCs ids to optimize this.  IIUC for clarity, one\nparty uses even ids, the other odd, counting in order.\n\nIf you want to batch signing as well, so you can say \"I include\neverything up to change #N, here's the signature\", we'd skip the HTLC id\nand use an incrementing offer id.  But I think this step is overkill?\n\n>> - HTLC abort stage - Setting up a new HTLC involves both sides\n>> accepting, then revocation message exchange.  Currently there's no\n>> way to abort this process. - Allow the initator to abort any time\n>> before the revocation exchange, for weird corner cases such as\n>> timeouts.\n> - - TN allows for any party to start a new exchange to abort the\n> current one. I adapted the dice-rolling from CJP, in case both\n> initiate at the same time.\n\nIf we allow parallel negotiation, we don't need a priority scheme I\nthink?  But we do need an explicit abort.\n\n> - - It is important be careful with revocation hashes when aborting.\n> You don't want the other party to hold on to an unrevoked tx...\n\nI think you really want to send the old revocation hash and the sig for\nthe new tx together.  At that point, aborting is no longer possible and\nyou have to cancel through normal means...\n\nie.  You can send \"add this please\", and then \"abort that\".\n\n>> - Version bits - If we use an open-coded protocol, initial\n>> handshake after key setup should exchange two sets of version bits:\n>> one for compulsory features, one for optional features.  You hang\n>> up if there's a compulsory feature you don't grok.\n>\n> Good point, agree here.\n\nOK, I'll add.\n\n>> - Anchor tx renegotiation - We should allow re-anchoring of\n>> channels, to add or remove funds. - This would allow easy payment\n>> from lightning channel to normal bitcoin addresses, for example. -\n>> During transition, signatures for both commit txs must be\n>> exchanged.\n>\n> This sounds like a 1.1 feature. Agree that we should allow it, but\n> does not seem urgent right now.\n\nAgreed; stuff we can defer is good....\n\n>> - R value vs keypair - Using a simple secret \"redeemhash\" allows\n>> easy tracing of transactions through the network. - Mats Jeratsch\n>> proposed a keypair scheme which decorrelates them[3], Greg Maxwell\n>> optimized it slightly, and Anthony Towns[4] and Andrew Poelstra\n>> independently came up with a way to do it without any bitcoin\n>> mods.\n>\n> Currently I am using R value, I am still a bit afraid of the lengthy\n> scripts when doing it without bitcoin mods. Might make sense to just\n> design the system in a way that it's easy to change later than to\n> implement it already.\n\nYes, everyone is on R AFAIK.  This might be worth deferring, if only\nbecause it raises the interesting question on how we would do the\nupgrade (every node on your path needs to understand the new version).\n\n>> - Multi-sig txs - Joseph pointed out that by simply allowing more\n>> than one\n> signature on\n>> commit txs[5], we can enable escrow-style services (including\n>> things like GreenAddress.it which does this for normal wallets).\n>> \n>> I'm sure I've missed things; what are they?\n>\n> Would be great to discuss connection/node failures. TN currently does\n> not support 'picking up' a lost connection again. I feel like anything\n> that MUST be finished on resume should rather be saved on hard disk in\n> advance, designing for various node failure modes.\n> Restarting a fresh connection seems to be much cleaner for me?\n\nYes, TBA for me too.\n\nThere should be a new crypto handshake, then the conversation should\ncontinue as before.\n\nThis means you need to save state, and also tolerate limited amount of\nidentical re-transmission.  My plan for c-lightning was to hand this at\na layer between the state machine and cryptopkt: if we see a\nretransmission we replay our previous responses.  My current state\nmachine could theoretically send out 4 packets in a row after receiving\none (decline, propose new, close, error), but this would be more if we\nallow multiple parallel change negotiations.\n\nCheers,\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2016-01-27T14:22:29",
                "message_text_only": "On Wed, Jan 27, 2016 at 01:37:04PM +1030, Rusty Russell wrote:\n> Misc\n> ----\n> - shachain vs elkrem\n>   - We use this to generate the revocation secrets, to minimize storage\n>     and computation for a huge number of old commitment txs.\n>   - They're actually very similar, but elkrem is much easier to grok.[6]\n\nHmm, I was going to say I like it, but I'm not sure I do...\n\nThe comments in the code don't quite make sense to me, for instance,\nthe given examples:\n\n 0b0000: L(L(L(L(seed))))\n 0b0001: R(L(L(L(seed))))\n 0b1000:   L(L(L(seed)))\n\nshould be 0, 1 and 2, I think, not 0, 1 and 8; and with four hash\noperations, you've got 31 nodes not 15, and 16 leaves, not 8?\n\nI think the pattern is:\n\n 0b0000:  LLL (ie L(L(L(seed)))\n 0b0001:  RLL (ie R(L(L(seed)))\n 0b0010:  LL -> (0, 1)\n 0b0011:  LRL\n 0b0100:  RRL\n 0b0101:  RL -> (3, 4)\n 0b0110:  L -> (0, 1, 2, 3, 4, 5)\n 0b0111:  LLR\n 0b1000:  RLR\n 0b1001:  LR -> (7, 8)\n 0b1010:  LRR\n 0b1011:  RRR\n 0b1100:  RR -> (10, 11)\n 0b1101:  R -> (7, 8, 9, 10, 11, 12)\n 0b1110:  seed -> (0,..,13)\n\n(Running the code translated into python gives those results too)\n\nI don't the code is quite right either (though I may have translated\nsomething wrong); eg if I try calling:\n\n  descend(6, 13, 2, R(seed))\n\nI get\n\n  L(L(R(seed)))\n\ninstead of an error (since the right answer would be L(seed), which\ncan't be derived from R(seed)).\n\nPersonally, I think both this and shachain have the indexing backwards;\nI think i=0 should match the seed, and the first hash transmitted across\nthe wire should be i=2^64-1, then counting down from there. This matches\nthe numbering used in https://en.wikipedia.org/wiki/Hash_chain fwiw.\n\nWith shachain, that gives the nice property that the only parameter\nyou need is the seed, you can work out the hash for any given index\ndirectly from that, up to any arbitrary index, until you run out of\ninteger precision, or bits of security in your hash function.\n\nWith elkrem you can build an arbitrarily deep tree given a seed at the\nconceptual level without any further parameters, but when you start\nmapping that to indexes you need to know the desired height first.\nThis is, in essence, because L(seed) (eg) gets sent at different places\ndepending on the \"height\"; with a height of 1 it's the first value (or\nthird from last), with a height of 2 it's the third value (or fifth\nfrom last), with a height of 3 it's the seventh value (or ninth from\nlast), etc.\n\nProbably doesn't really matter, but I think it leads me to prefer Rusty's\nconstruction. Might be good to have an explanation with it diagrammed\nas an n-way tree structure though, in a similar way to how you visualise\nthe elkrem tree...\n\n> - R value vs keypair\n>   - Using a simple secret \"redeemhash\" allows easy tracing of\n>     transactions through the network.\n>   - Mats Jeratsch proposed a keypair scheme which decorrelates them[3],\n>     Greg Maxwell optimized it slightly, and Anthony Towns[4] and Andrew\n>     Poelstra independently came up with a way to do it without any\n>     bitcoin mods.\n\nFWIW I think this should still be considered an R&D idea rather than\ntrying to release it in v1.0.\n\n> - Multi-sig txs\n>   - Joseph pointed out that by simply allowing more than one signature on\n>     commit txs[5], we can enable escrow-style services (including things\n>     like GreenAddress.it which does this for normal wallets).\n\nIt's \"more than one hash\" not more than one /signature/, isn't it? (The\nproposal was also to support 2-of-3 hashes, slightly more complicated\nthan just multiple hashes)\n\nCheers,\naj"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-01-29T01:35:35",
                "message_text_only": "Anthony Towns <aj at erisian.com.au> writes:\n> Personally, I think both this and shachain have the indexing backwards;\n> I think i=0 should match the seed, and the first hash transmitted across\n> the wire should be i=2^64-1, then counting down from there. This matches\n> the numbering used in https://en.wikipedia.org/wiki/Hash_chain fwiw.\n\nOK.\n\n> With shachain, that gives the nice property that the only parameter\n> you need is the seed, you can work out the hash for any given index\n> directly from that, up to any arbitrary index, until you run out of\n> integer precision, or bits of security in your hash function.\n>\n> With elkrem you can build an arbitrarily deep tree given a seed at the\n> conceptual level without any further parameters, but when you start\n> mapping that to indexes you need to know the desired height first.\n\nWe can just say \"64 bits is enough for everyone\", and be done.\n\n> This is, in essence, because L(seed) (eg) gets sent at different places\n> depending on the \"height\"; with a height of 1 it's the first value (or\n> third from last), with a height of 2 it's the third value (or fifth\n> from last), with a height of 3 it's the seventh value (or ninth from\n> last), etc.\n>\n> Probably doesn't really matter, but I think it leads me to prefer Rusty's\n> construction. Might be good to have an explanation with it diagrammed\n> as an n-way tree structure though, in a similar way to how you visualise\n> the elkrem tree...\n\nDefinitely; a 64-deep binary tree is a 64-dimensional 1x1...x1\nhypercube, but the former is less brainhurty.\n\n>> - R value vs keypair\n>>   - Using a simple secret \"redeemhash\" allows easy tracing of\n>>     transactions through the network.\n>>   - Mats Jeratsch proposed a keypair scheme which decorrelates them[3],\n>>     Greg Maxwell optimized it slightly, and Anthony Towns[4] and Andrew\n>>     Poelstra independently came up with a way to do it without any\n>>     bitcoin mods.\n>\n> FWIW I think this should still be considered an R&D idea rather than\n> trying to release it in v1.0.\n>\n>> - Multi-sig txs\n>>   - Joseph pointed out that by simply allowing more than one signature on\n>>     commit txs[5], we can enable escrow-style services (including things\n>>     like GreenAddress.it which does this for normal wallets).\n>\n> It's \"more than one hash\" not more than one /signature/, isn't it? (The\n> proposal was also to support 2-of-3 hashes, slightly more complicated\n> than just multiple hashes)\n\nYou're right, it's multiple hashes.  Which gives me an idea I'll post\nseparately.\n\nThanks!\nRusty."
            },
            {
                "author": "Anthony Towns",
                "date": "2016-01-29T04:37:33",
                "message_text_only": "On Fri, Jan 29, 2016 at 12:05:35PM +1030, Rusty Russell wrote:\n> > Probably doesn't really matter, but I think it leads me to prefer Rusty's\n> > construction. Might be good to have an explanation with it diagrammed\n> > as an n-way tree structure though, in a similar way to how you visualise\n> > the elkrem tree...\n> Definitely; a 64-deep binary tree is a 64-dimensional 1x1...x1\n> hypercube, but the former is less brainhurty.\n\nNono, you don't need hypercubes to describe shachain, just a tree.\nVoila:\n\n[attached]\n\n(Okay, so technically it's a spanning tree for a hypercube, fine,\nwhatever. I guess you can kind-of see the outline of the 4d hypercube\nin the picture if you look hard enough...)\n\nIn the notation I'm using, H(p||x) means \"flip the xth bit from the\nparent hash/seed then hash\" [0]. So to get to the hash for 10 you do:\n\n   SHA256( SHA256( seed with bit 3 flipped ) with bit 1 flipped )\n\nThe subtrees are all very self-similar, and extending past 2**n just means\nadding a new branch off from 0. Because it's so self-similar adding the\nbranch is just literally copying the existing tree, adding 2**n to all the\nnode values, and then adding a H(p||n) step from 0 to keep it connected.\n\nPython code for generating the graph also attached, for whatever that's\nworth. Layout gets a bit painful when you add an additional dimension to\nget up to 32 nodes.\n\nCheers,\naj\n\n[0] Or, alternatively and IMO preferably, append the number \"x\" and\n    hash.\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: shachain.png\nType: image/png\nSize: 48127 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160129/2463d873/attachment-0001.png>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: shachain.py\nType: text/x-python\nSize: 798 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20160129/2463d873/attachment-0001.py>"
            },
            {
                "author": "CJP",
                "date": "2016-01-27T19:34:15",
                "message_text_only": "> I'm sure I've missed things; what are they?\n\nThe lazy answer is to tell you to read the Amiko Pay protocol\ndescription.[1] :-P Note that it is (of course) already outdated. To\ngive you some of the concept choices in there:\n\n* Transport layer: TCP. We don't need its retransmission features (since\nit's not good enough and we'll re-implement it in a higher layer), but\nunlike UDP it works well over TOR.\n* Serialization: JSON, with some conventions added on top of it, e.g.\nfor more efficient transfer of binary data. It is bloated, but easily\ndebuggable and easily extensible. Good for prototypes, maybe not so good\nfor high-performance production code.\n* Message confirmation: this is done manually (instead of relying on\nTCP), so that a node knows which messages were received / need to be\nre-transmitted, even after a crash + restart.\n* There is not only two-way communication between linked peers, but also\nbetween payer and payee. This is necessary for Amiko Pay's\nbi-directional routing, but also useful e.g. for transmitting meta-data\nthat doesn't fit in a QR code. Amiko Pay transmits an arbitrary-contents\n\"receipt\" from payee to payer; in the future, this might be digitally\nsigned by the payee, as a \"proof of transfer of ownership\" of\nnon-cryptographic goods.\n* Bi-directional routing: both payer and payee route towards a \"meeting\npoint\". This way, neither payer nor payee has to have a routable address\non the network. This is good for both payer and payee privacy; also, in\ncase of a semi-centralized network with a couple of large hubs, this\nallows the network to grow without the large hubs noticing it, both in\npayer and in payee direction.\n* Multiple channels per link: useful to be able to route transactions\nthe usual way while one of the channels is (temporarily) closed. It's\nalso the easy way of adding more funds to an existing link, or funds\nfrom both sides.\n* Different channel classes: the micro-transaction design, and its\nimplications on what info needs to be transferred in which situations,\nis a separate, higher-level protocol layer on top of a more generic\nprotocol that takes care of routing.\n* Reserving before locking: this is an optimization, to reduce the risk\nof locking funds in payment channels on a part of the route, and then\nhaving to undo the locking when it turns out that the remaining part of\nthe route doesn't exist (anymore). Reserving is an informal(*),\ntemporary locking of funds for use in the transaction, and can be done\nand undone very fast, without any channel operations. It is done\ntogether with route searching + establishment.\n\nCJP\n\nPS. Don't trust a protocol spec that doesn't have an implementation,\nsince it's probably missing a couple of essential things. Don't use an\nimplementation that doesn't have a protocol spec, since you're likely to\nrun into future compatibility issues.\n\n(*)informal = without cryptographic commitment, and without actual\nchannel update.\n\n[1]https://github.com/cornwarecjp/lightning/tree/cornwarecjp/communications"
            },
            {
                "author": "Rusty Russell",
                "date": "2016-01-29T02:35:17",
                "message_text_only": "CJP <cjp at ultimatestunts.nl> writes:\n>> I'm sure I've missed things; what are they?\n>\n> The lazy answer is to tell you to read the Amiko Pay protocol\n> description.[1] :-P Note that it is (of course) already outdated. To\n> give you some of the concept choices in there:\n>\n> * Transport layer: TCP. We don't need its retransmission features (since\n> it's not good enough and we'll re-implement it in a higher layer), but\n> unlike UDP it works well over TOR.\n\nAgreed.  I've implemented TCP for the moment, but am not making any\nassumptions about it for protocol design.\n\n> * Serialization: JSON, with some conventions added on top of it, e.g.\n> for more efficient transfer of binary data. It is bloated, but easily\n> debuggable and easily extensible. Good for prototypes, maybe not so good\n> for high-performance production code.\n\nAgreed.  I think I'd like something better for a protocol definition,\nbut it's nice for prototyping.\n\n> * Message confirmation: this is done manually (instead of relying on\n> TCP), so that a node knows which messages were received / need to be\n> re-transmitted, even after a crash + restart.\n\nI think the protocol itself needs to be robust against retransmissions.\nThere's no way to know if the other side received your acknowledgement\nbefore a crash, so you will always need to handle duplication on\nre-establishment.\n\n> * There is not only two-way communication between linked peers, but also\n> between payer and payee. This is necessary for Amiko Pay's\n> bi-directional routing, but also useful e.g. for transmitting meta-data\n> that doesn't fit in a QR code. Amiko Pay transmits an arbitrary-contents\n> \"receipt\" from payee to payer; in the future, this might be digitally\n> signed by the payee, as a \"proof of transfer of ownership\" of\n> non-cryptographic goods.\n\nI agree.  There's room in the initial onion design for payer -> payee\nmessages, but we don't have a channel for responses.\n\nI can't see an easy way to implement the payee --> payer comms reliably:\nto be reliable it would have to be published on-chain in the commit tx.\n(Which we could do by constructing HTLCs such that they require a blob\nsigned by the payee, but that's tracable ...).\n\nMats and Laolu wanted to add an arbitrary comms protocol layer, but I\nthink that's something we can defer.\n\n> * Bi-directional routing: both payer and payee route towards a \"meeting\n> point\". This way, neither payer nor payee has to have a routable address\n> on the network. This is good for both payer and payee privacy; also, in\n> case of a semi-centralized network with a couple of large hubs, this\n> allows the network to grow without the large hubs noticing it, both in\n> payer and in payee direction.\n\nYes, I've totally punted on routing and fees.  This idea merges well\nwith the idea of randomly selecting a handful of \"beacons\", which I've\ntoyed with in the past.\n\n> * Multiple channels per link: useful to be able to route transactions\n> the usual way while one of the channels is (temporarily) closed. It's\n> also the easy way of adding more funds to an existing link, or funds\n> from both sides.\n\nFor the moment this is done with separate connections, though it would\nbe fairly trivial to multiplex over a single transport.\n\n> * Different channel classes: the micro-transaction design, and its\n> implications on what info needs to be transferred in which situations,\n> is a separate, higher-level protocol layer on top of a more generic\n> protocol that takes care of routing.\n\nYes, and we can't really finalize the lower-level implementation until\nwe have the upper parts anyway...\n\n> * Reserving before locking: this is an optimization, to reduce the risk\n> of locking funds in payment channels on a part of the route, and then\n> having to undo the locking when it turns out that the remaining part of\n> the route doesn't exist (anymore). Reserving is an informal(*),\n> temporary locking of funds for use in the transaction, and can be done\n> and undone very fast, without any channel operations. It is done\n> together with route searching + establishment.\n\nI think that trades one DoS for another, though.  It saves cryptographic\nconstructs, but latency is the real cost, and this increases it.\n\nOf course, we'll have to revisit that if the network in practice proves\nsubject to these problems...\n\n> PS. Don't trust a protocol spec that doesn't have an implementation,\n> since it's probably missing a couple of essential things. Don't use an\n> implementation that doesn't have a protocol spec, since you're likely to\n> run into future compatibility issues.\n\nRough consensus and running code, indeed.\n\nThanks,\nRusty."
            },
            {
                "author": "CJP",
                "date": "2016-01-27T21:19:42",
                "message_text_only": "There are a couple of subjects where new concepts are being worked out,\nor where alternative concepts exist; these things are likely to continue\nto evolve after you finish the first version of the protocol.\n\nIt would be great if concept changes in one subject can be made more or\nless independently from concept changes in another subject. In order to\nmake this possible, I suggest to de-couple certain things, and let each\nsubject have its own sub-protocol, with version number / protocol\nidentifier.\n\nThe way I see it, the following subjects have ongoing design /\nalternative concepts, more or less independently from each other:\n\n* Micro-transaction channel design: e.g. several variations on the\nLightning channel design, and Amiko Pay's escrow-based HTLC emulation\nand IOU semi-channel.\n* Commit conditions: traditional definition consists of a hash value and\na time-out. For practical purposes, Amiko Pay also adds a \"start time\",\nand there is an alternative concept of using keypairs instead of hash\nvalues to de-correlate a transaction in different links.\n* Routing: how to exchange routing info. For source routing: informing\neach other about Lightning nodes that exist. For source and non-source\nrouting: informing each other about availability of routes, expected\ncapacity and fees. The type of routing info depends on the routing\nalgorithm in use by a node.\n\nIn Amiko Pay, the micro-transaction channel design is already separated\nfrom the rest of the protocol; commit conditions are not (yet), and\nexchange of routing info doesn't really exist yet, since it's still\ndoing \"dumb\" non-source routing (trying every possible route).\n\nCJP\n\nRusty Russell schreef op wo 27-01-2016 om 13:37 [+1030]:\n> Hi all!\n> \n>         As more code emerges, I'd like to try to nail down a \"1.0\"\n> version of the inter-node protocol as much as possible.  Since I'm most\n> familiar with my own code (c-lightning[1]), I'll use that as a basis and\n> discuss differences (esp. vs lnd[2]).\n> \n> For this email I'll simply list the changes or proposals I'm aware of,\n> then we can dissect and comment on each one: defer, accept or close.\n> \n> Direct wire format stuff\n> ------------------------\n> \n> - Protobufs vs open-coded structures\n>   - lnd open-coded their own protocol; I haven't finished reading their\n>     code though.\n>   - protobufs are easy to extend with new fields; with an open-coded\n>     proto we simply need a rule that too-long packets are valid.\n>   - protobufs are annoying for fixed-length blobs which we use a lot\n>     (keys, signatures, hashes).\n>   - The protocol is currently simple with very few variable-length fields.\n> \n> - Length prefix for initial key exchange\n>   - Both lnd and c-lightning begin by exchanging a 33-byte EC key for DH.\n>   - We should prefix with a length word, so we can extend this later\n>     (eg. for new crypto)\n> \n> - Length prefix for other packets\n>   - lightning-c sends an 8 byte prefix indicating the offset of the end of\n>     the current packet: this effectively encodes both length and ordering.\n>   - lnd uses a 4 byte network ID, 4 byte type, 4 byte length.\n> \n> - HTLC pipelining\n>   - lnd's protocol supports multiple in-flight HTLC negotiations; this\n>     would allow much greater throughput, with some complexity.\n>   - lightning-c uses a simple one-at-a-time scheme, with alternating\n>     priority in case of simultaneous sends.\n> \n> - HTLC abort stage\n>   - Setting up a new HTLC involves both sides accepting, then revocation\n>     message exchange.  Currently there's no way to abort this process.\n>   - Allow the initator to abort any time before the revocation exchange,\n>     for weird corner cases such as timeouts.\n> \n> - Version bits\n>   - If we use an open-coded protocol, initial handshake after key setup\n>     should exchange two sets of version bits: one for compulsory\n>     features, one for optional features.  You hang up if there's a\n>     compulsory feature you don't grok.\n> \n> Wire protocol crypto\n> --------------------\n> - Crypto AES/HMAC-SHA256 or Chacha20/Poly1305\n>   - AES has the word Standard in the name, but chacha20 is faster w/o\n>     accel (ie. ARM) and almost as widely supported.\n>    \n> - Use separate encoding stream for packet lengths\n>   - Laolu's suggestion; encode the packet lengths as well which makes\n>     traffic analysis a bit harder.\n>   - Makes it a bit harder to detect re-transmissions (required on node\n>     restart), but probably not enough to kill the idea?\n> \n> Misc\n> ----\n> - shachain vs elkrem\n>   - We use this to generate the revocation secrets, to minimize storage\n>     and computation for a huge number of old commitment txs.\n>   - They're actually very similar, but elkrem is much easier to grok.[6]\n> \n> - Anchor tx renegotiation\n>   - We should allow re-anchoring of channels, to add or remove funds.\n>       - This would allow easy payment from lightning channel to normal\n>         bitcoin addresses, for example.\n>   - During transition, signatures for both commit txs must be exchanged.\n> \n> - R value vs keypair\n>   - Using a simple secret \"redeemhash\" allows easy tracing of\n>     transactions through the network.\n>   - Mats Jeratsch proposed a keypair scheme which decorrelates them[3],\n>     Greg Maxwell optimized it slightly, and Anthony Towns[4] and Andrew\n>     Poelstra independently came up with a way to do it without any\n>     bitcoin mods.\n> \n> - Multi-sig txs\n>   - Joseph pointed out that by simply allowing more than one signature on\n>     commit txs[5], we can enable escrow-style services (including things\n>     like GreenAddress.it which does this for normal wallets).\n> \n> I'm sure I've missed things; what are they?\n> \n> Thanks!\n> Rusty.\n> \n> [1] https://github.com/ElementsProject/lightning\n> [2] https://github.com/LightningNetwork/lnd\n> [3] http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000314.html\n> [4] http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000344.html\n> [5] http://lists.linuxfoundation.org/pipermail/lightning-dev/2016-January/000403.html\n> [6] https://github.com/LightningNetwork/lnd/blob/master/elkrem/elkrem.go\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Laundry list of inter-peer wire protocol changes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Anthony Towns",
                "Mats Jerratsch",
                "CJP"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 41644
        }
    }
]