[
    {
        "title": "[Lightning-dev] Lightning dice",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-03T01:31:39",
                "message_text_only": "Good morning aj, and list,\n\n\n\n> Note that Bob could abort the protocol with a winning bet before\n> requesting the payout from Carol -- he already has enough info to prove\n> he's won and claim Carol isn't paying him out at this point.\n> One way of dealing with this is to vet Bob's claim by sending b,R2 and a\n> PTLC invoice of (50bet,S2) to Carol with yourself as the recipient -- youcan construct all that info from Bob's claim that Carol is cheating. If\n> Carol isn't cheating, she won't be able to tell you're not Bob and\n> will try paying the PTLC; at which point you know Carol's not cheating.\n> This protocol does't work without better spam defenses in lightning --\n> PTLC payments have to be serialised or Carol risks sending the payout\n> to Bob multiple times, and if many people want to verify Carol is(n't)\n> cheating, they can be delayed by just one verifier forcing Carol to wait\n> for the PTLC timeout to be reached.\n\nFor this particular issue, would not stuckless payments be possible to allow parallelism of validation at least?\n\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Lightning dice",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1063
        }
    },
    {
        "title": "[Lightning-dev] PoDLEs revisited",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2021-02-03T06:33:44",
                "message_text_only": "On Fri, Jan 29, 2021 at 10:51 AM Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n\n> Less true after taproot though?\n>\n\nThe heuristic from [1] is not affected by Taproot.\nTaproot will be helpful for keeping private channels private against the\nmethod in [2] though.\n\n> [1] https://arxiv.org/abs/2007.00764\n> > [2] https://arxiv.org/pdf/2003.12470.pdf\n> > [3] https://graphsense.info/\n> >\n> > I am told there is a new revision of [1] coming out any day now that will\n> > present a few more tricks and have contributions directly from a\n> scientist\n> > at Chainalsysis (the company).\n>\n> I'll add to my reading list (or wait for one of my colleagues to provide\n> the TL;DR!).\n>\n>\nLet me TL;DR quickly the core idea quickly as it's not too difficult to\ngrasp.\n\n1. You are node n_1\n2. You fund a public channel to node n_2 called c1\n3. You use the change to fund a public channel to node n_3 called c2\n4. The network sees that n_1 is involved in both c_1 and c_2. They're both\npublic channels so the channel_id gives away the on-chain funding utxo.\nEveryone can conclude that the owner of n_1 was also the funder of both and\ntherefore owns the change output of the funding of c_2.\n\nConsider a variant of this heuristic where instead of using funding change\nthey use the output of a cooperative close of c_1 to to fund c_2. By the\nsame reasoning you can identify the owner of n_1 funded the channel but you\ncan also now know  that n_2 is the owner of the other utxo of the close of\nc_1.\n\nThe point of this is if you are a node that is churning UTXOs from the\nfunding change or the closing UTXO into other public channels you\nnecessarily associate those UTXOs with your node id and any descendent\nutxos. This is the point of UTXO probing too but with this you get the info\nfor free by just passively observing the new channel gossip. I think this\nmakes UTXO probing useless as long we can assume that public nodes that\naccept dual funding requests from random people on the internet (and\ntherefore vulnerable to probing) are also likely to use their wallet funds\nto fund channels in the future.\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210203/253a4ccb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "PoDLEs revisited",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lloyd Fournier"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2277
        }
    },
    {
        "title": "[Lightning-dev] Pay-for-Elgamal-decryption-key and its application to Anonymous Credentials",
        "thread_messages": [
            {
                "author": "Joe Miyamoto Philips",
                "date": "2021-02-03T14:32:09",
                "message_text_only": "Hi all.\n\n\n\nI want to point out another application of Discrete-Log selling on PTLC\nlightning since I could not find anyone else mentioning it (in particular,\nI could not find in the Nadav Kohen's list here. [1] )\n\n\n\nThe protocol may be obvious to most of the members here, but I believe its\napplication has some impact on the way people make anonymity-focused\napplications with LN, so I want to have some feedback.\n\n\n\nIn short, by using ElGamal encryption, we can sell not only a discrete-log\nbut also an elliptic curve point which satisfies some requirements. This\nincludes KVAC [2] which is used for WabiSabi [3] and Signal app [4].\n\n\n\n> disclaimer: I'm not a cryptography or math major, the following reasoning\nmight be wrong at the fundamental level. Please correct me if I'm wrong.\n\n\n\n## Notations\n\n\n\n* G ... Elliptic curve base point.\n\n* H ... some additional NUMS\n\n* x, X = x * G ... secret and public key\n\n\n\nFor ZKPoK, I will use Camenisch-Stadler like notation\n\nPK{ (secret values) : statements about secret values to prove. }\n\ne.g. For DLEQ proof. assume the verifier already have some points P_1, P_2\n\nPK{ (x, y) : P_1 =  x * G and P_2 = y * H and x = y }\n\n\n\n# Protocols\n\n\n\n## pay-for ElGamal decryption key\n\n\n\nQuick recap, ElGamal encryption for message M (= m * G) is\n\n(r * G, M + r * P)\n\nwhere r is some blinding factor and P is a shared secret (P = p * G)\n\n\n\nImagine the Buyer knows some point (X_h = x * H), and he wants another\npoint (X_g  = x * G).\n\nThe Seller knows x and he wants to sell the point X_g but he does NOT want\nto reveal its discrete log x to the buyer.\n\n(There is not much of a situation like this, but I will explain it later.)\n\n\n\nIn this case, the Seller can send its elgamal encryption and sell its\ndecryption key.\n\nSeller:\n\n* Generate ephemeral encryption key S = s * G\n\n* Encrypt X_g  with random blinding r ... (c1, c2) := (r * G, X_g + r * S)\n\n* Send (c1, c2) and S to the Buyer.\n\n* Also, send PK{(x, r, s) :  c1 = r * G and c2 = x * G + r * S and X_h = x\n* H }\n\n\n\nBuyer\n\n* Verifies the ZKPoK, he can be sure that the plaintext will be X_g that he\nwants.\n\n* Make a payment offer to the Seller with S.\n\n\n\nSeller\n\n* Receive the payment by revealing s\n\n\n\nBuyer\n\n* Decrypt the ciphertext by s to get the X_g ... (X_g := c2 - c1 * s)\n\n\n\n## Pay for Keyed Verification Anonymous Credential. (KVAC)\n\n\n\nWe assume MAC_{GGM} scheme for the KVAC. [2]\n\n\n\n* attributes encoded in the credential is m_1, ... m_n\n\n* secret keys for the issuer=verifier is r, x_0, x_1, ... x_n\n\n* Public params for the issuer are (C_x0 = x_0 * G + r * H), (X_1 = x_1 *\nG, ... X_n = x_n * G)\n\n\n\nThe credential is of the form (U, U') where U' = U * (x_0 + x_1 * m_1 + ...\n+ x_n * m_n)\n\n\n\nIssuer:\n\n* get random point `U`\n\n* compute U' = U * (x_0 + x_1 * m_1 + ... + x_n + m_n)\n\n* sends U and ElGamal encryption of U' to the Buyer with blinding factor k\nand ephemeral encryption key S.\n\n  * (c1, c2) = (k * G, U' + k * S)\n\n* Also send ZKPoK to tell the ciphertext is for correct U'\n\n  * PK{(x_0, ... x_n, x_0, r, k, s, U\u2019) :  U' = U * (x_0 + x_1 * m_1 + ...\n+ x_n * m_n)  and  C_x0 = G * x_0 + H * r and X_1 = x_1 * G and ... and X_n\n= x_n * G and  c1 = k * G and c2 = U' + k * S }\n\n\n\nThen Buyer can buy s as the same as above.\n\n\n\n# Why this matters\n\n\n\nI believe that KVAC has great potential as a building block of anonymous\nweb apps.\n\nIts MAC-based construction is more performant and easy to prove the\nsecurity compared to the similar system for the PKI based anonymous\ncredentials (e.g. U-Prove [5] and ACL [6]).\n\nAnd it's a great fit for commercial purpose applications which do not have\nto cooperate with other entities when defining the protocol. (Which is not\nthe case for an Attribute based credential system in general.)\n\n\n\nThe reason so far it has not been used widely is, IMHO, it's because there\nis no way to charge its users anonymously. [7]\n\nAnother problem is Sybil attack. In general, the DoS protection is a great\nconcern for anonymous applications.\n\nSo we need users to commit something \"scarce\" to prevent it.\n\nIt is why Signal requires its users to register their telephone number\n(Maybe I'm wrong about this, not sure).\n\n(WabiSabi cleverly uses the user's UTXO as the scarce resource to mitigate\nthis problem.)\n\n\n\nAnd of course, these problems get fixed by LN, if users have to pay to get\ntheir service, the service does not have to ban the users by DoS-ing\nanymore. So I think the LN-based payment and KVAC-based app fits very well.\n\n\n\nThus, if the service wants to grant some right to do something with their\nserver resource to users in an unlinkable fashion, then I believe\nexchanging the credential in this way has a benefit.\n\n\n\n\n\nRegards,\n\n\n\nMiyamoto.\n\n\n\n P.S. I may have sent the same mail with a different address. Please ignore\nit.\n\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002647.html\n\n[2]: https://eprint.iacr.org/2013/516.pdf\n\n[3]: https://github.com/zkSNACKs/WabiSabi\n\n[4]: https://signal.org/blog/pdfs/signal_private_group_system.pdf\n\n[5]: https://www.microsoft.com/en-us/research/project/u-prove/\n\n[6]: https://core.ac.uk/download/pdf/193377167.pdf\n\n[7]: DuckDuckGo has an interesting solution for this. But it is not a\ngeneral solution for all kinds of apps and I doubt how good it works\ncompared to charging a fee by LN.\nhttps://spreadprivacy.com/duckduckgo-revenue-model/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210203/3ec104bc/attachment-0001.html>"
            },
            {
                "author": "\u5bae\u672c\u4e08",
                "date": "2021-02-03T14:13:49",
                "message_text_only": "Hi all.\n\nI want to point out another application of Discrete-Log selling on PTLC\nlightning since I could not find anyone else mentioning it (in particular,\nI could not find in the Nadav Kohen's list here. [1] )\n\nThe protocol may be obvious to most of the members here, but I believe its\napplication has some impact on the way people make anonymity-focused\napplications with LN, so I want to have some feedback.\n\nIn short, by using ElGamal encryption, we can sell not only a discrete-log\nbut also an elliptic curve point which satisfies some requirements. This\nincludes KVAC [2] which is used for WabiSabi [3] and Signal app [4].\n\n> disclaimer: I'm not a cryptography or math major, the following reasoning\nmight be wrong at the fundamental level. Please correct me if I'm wrong.\n\n## Notations\n\n* G ... Elliptic curve base point.\n* H ... some additional NUMS\n* x, X = x * G ... secret and public key\n\nFor ZKPoK, I will use Camenisch-Stadler like notation\nPK{ (secret values) : statements about secret values to prove. }\ne.g. For DLEQ proof. assume the verifier already have some points P_1, P_2\nPK{ (x, y) : P_1 =  x * G and P_2 = y * H and x = y }\n\n# Protocols\n\n## pay-for ElGamal decryption key\n\nQuick recap, ElGamal encryption for message M (= m * G) is\n(r * G, M + r * P)\nwhere r is some blinding factor and P is a shared secret (P = p * G)\n\nImagine the Buyer knows some point (X_h = x * H), and he wants another\npoint (X_g  = x * G).\nThe Seller knows x and he wants to sell the point X_g but he does NOT want\nto reveal its discrete log x to the buyer.\n(There is not much of a situation like this, but I will explain it later.)\n\nIn this case, the Seller can send its elgamal encryption and sell its\ndecryption key.\nSeller:\n* Generate ephemeral encryption key S = s * G\n* Encrypt X_g  with random blinding r ... (c1, c2) := (r * G, X_g + r * S)\n* Send (c1, c2) and S to the Buyer.\n* Also, send PK{(x, r, s) :  c1 = r * G and c2 = x * G + r * S and X_h = x\n* H }\n\nBuyer\n* Verifies the ZKPoK, he can be sure that the plaintext will be X_g that he\nwants.\n* Make a payment offer to the Seller with S.\n\nSeller\n* Receive the payment by revealing s\n\nBuyer\n* Decrypt the ciphertext by s to get the X_g ... (X_g := c2 - c1 * s)\n\n## Pay for Keyed Verification Anonymous Credential. (KVAC)\n\nWe assume MAC_{GGM} scheme for the KVAC. [2]\n\n* attributes encoded in the credential is m_1, ... m_n\n* secret keys for the issuer=verifier is r, x_0, x_1, ... x_n\n* Public params for the issuer is (C_x0 = x_0 * G + r * H), (X_1 = x_1 * G,\n... X_n = x_n * G)\n\nThe credential is of the form (U, U') where U' = U * (x_0 + x_1 * m_1 + ...\n+ x_n * m_n)\n\nIssuer:\n* get random point `U`\n* compute U' = U * (x_0 + x_1 * m_1 + ... + x_n + m_n)\n* sends U and ElGamal encryption of U' to the Buyer with blinding factor k\nand ephemeral encryption key S.\n  * (c1, c2) = (k * G, U' + k * S)\n* Also send ZKPoK to tell the ciphertext is for correct U'\n  * PK{(x_0, ... x_n, x_0, r, k, s) :  U' = U * (x_0 + x_1 * m_1 + ... +\nx_n * m_n)  and  C_x0 = G * x_0 + H * r and X_1 = x_1 * G and ... and X_n =\nx_n * G and  c1 = k * G and c2 = U' + k * S }\n\nThen Buyer can buy s as the same as above.\n\n# Why this matters\n\nI believe that KVAC has great potential as a building block of anonymous\nweb apps.\nIts MAC-based construction is more performant and easy to prove the\nsecurity compared to the similar system for the PKI based anonymous\ncredentials (e.g. U-Prove [5] and ACL [6]).\nAnd it's a great fit for commercial purpose applications which do not have\nto cooperate with other entities when defining the protocol. (Which is not\nthe case for an Attribute based credential system in general.)\n\nThe reason so far it has not been used widely is, IMHO, it's because there\nis no way to charge its users anonymously. [7]\nAnother problem is Sybil attack. In general, the DoS protection is a great\nconcern for anonymous applications.\nSo we need users to commit something \"scarce\" to prevent it.\nIt is why Signal requires its users to register their telephone number\n(Maybe I'm wrong about this, not sure).\n(WabiSabi cleverly uses the user's UTXO as the scarce resource to mitigate\nthis problem.)\n\nAnd of course, these problems get fixed by LN, if users have to pay to get\ntheir service, the service does not have to ban the users by DoS-ing\nanymore. So I think the LN-based payment and KVAC-based app fits very well.\n\nThus, if the service wants to grant some right to do something with their\nserver resource to users in an unlinkable fashion, then I believe\nexchanging the credential in this way has a benefit.\n\n\nRegards,\n\nMiyamoto.\n\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002647.html\n[2]: https://eprint.iacr.org/2013/516.pdf\n[3]: https://github.com/zkSNACKs/WabiSabi\n[4]: https://signal.org/blog/pdfs/signal_private_group_system.pdf\n[5]: https://www.microsoft.com/en-us/research/project/u-prove/\n[6]: https://core.ac.uk/download/pdf/193377167.pdf\n[7]: DuckDuckGo has an interesting solution for this. But it is not a\ngeneral solution for all kinds of apps and I doubt how good it works.\nhttps://spreadprivacy.com/duckduckgo-revenue-model/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210203/210db689/attachment.html>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-02-05T00:05:58",
                "message_text_only": "Hi Miyamoto,\n\nVery interesting idea :)\nUsually when dealing with anonymous credentials you are necessarily dealing\nwith a trusted third party so it's fine to just make a normal payment and\nthen receive the credential after successfully paying.\nBut I see the advantage of your idea. If a malicious credential server is\nable to identify you somehow at the point of payment then they might want\nto selectively steal your money while being honest with everyone else.\nIn your scheme, if you pay you get the credential and then since it is\nanonymous it can't be distinguished from others when you go to claim\nwhatever it entails.\nIs this the idea?\n\nCheers,\n\nLL\n\nOn Thu, Feb 4, 2021 at 1:04 PM \u5bae\u672c\u4e08 via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n>\n> Hi all.\n>\n> I want to point out another application of Discrete-Log selling on PTLC\n> lightning since I could not find anyone else mentioning it (in particular,\n> I could not find in the Nadav Kohen's list here. [1] )\n>\n> The protocol may be obvious to most of the members here, but I believe its\n> application has some impact on the way people make anonymity-focused\n> applications with LN, so I want to have some feedback.\n>\n> In short, by using ElGamal encryption, we can sell not only a discrete-log\n> but also an elliptic curve point which satisfies some requirements. This\n> includes KVAC [2] which is used for WabiSabi [3] and Signal app [4].\n>\n> > disclaimer: I'm not a cryptography or math major, the following\n> reasoning might be wrong at the fundamental level. Please correct me if I'm\n> wrong.\n>\n> ## Notations\n>\n> * G ... Elliptic curve base point.\n> * H ... some additional NUMS\n> * x, X = x * G ... secret and public key\n>\n> For ZKPoK, I will use Camenisch-Stadler like notation\n> PK{ (secret values) : statements about secret values to prove. }\n> e.g. For DLEQ proof. assume the verifier already have some points P_1, P_2\n> PK{ (x, y) : P_1 =  x * G and P_2 = y * H and x = y }\n>\n> # Protocols\n>\n> ## pay-for ElGamal decryption key\n>\n> Quick recap, ElGamal encryption for message M (= m * G) is\n> (r * G, M + r * P)\n> where r is some blinding factor and P is a shared secret (P = p * G)\n>\n> Imagine the Buyer knows some point (X_h = x * H), and he wants another\n> point (X_g  = x * G).\n> The Seller knows x and he wants to sell the point X_g but he does NOT want\n> to reveal its discrete log x to the buyer.\n> (There is not much of a situation like this, but I will explain it later.)\n>\n> In this case, the Seller can send its elgamal encryption and sell its\n> decryption key.\n> Seller:\n> * Generate ephemeral encryption key S = s * G\n> * Encrypt X_g  with random blinding r ... (c1, c2) := (r * G, X_g + r * S)\n> * Send (c1, c2) and S to the Buyer.\n> * Also, send PK{(x, r, s) :  c1 = r * G and c2 = x * G + r * S and X_h = x\n> * H }\n>\n> Buyer\n> * Verifies the ZKPoK, he can be sure that the plaintext will be X_g that\n> he wants.\n> * Make a payment offer to the Seller with S.\n>\n> Seller\n> * Receive the payment by revealing s\n>\n> Buyer\n> * Decrypt the ciphertext by s to get the X_g ... (X_g := c2 - c1 * s)\n>\n> ## Pay for Keyed Verification Anonymous Credential. (KVAC)\n>\n> We assume MAC_{GGM} scheme for the KVAC. [2]\n>\n> * attributes encoded in the credential is m_1, ... m_n\n> * secret keys for the issuer=verifier is r, x_0, x_1, ... x_n\n> * Public params for the issuer is (C_x0 = x_0 * G + r * H), (X_1 = x_1 *\n> G, ... X_n = x_n * G)\n>\n> The credential is of the form (U, U') where U' = U * (x_0 + x_1 * m_1 +\n> ... + x_n * m_n)\n>\n> Issuer:\n> * get random point `U`\n> * compute U' = U * (x_0 + x_1 * m_1 + ... + x_n + m_n)\n> * sends U and ElGamal encryption of U' to the Buyer with blinding factor k\n> and ephemeral encryption key S.\n>   * (c1, c2) = (k * G, U' + k * S)\n> * Also send ZKPoK to tell the ciphertext is for correct U'\n>   * PK{(x_0, ... x_n, x_0, r, k, s) :  U' = U * (x_0 + x_1 * m_1 + ... +\n> x_n * m_n)  and  C_x0 = G * x_0 + H * r and X_1 = x_1 * G and ... and X_n =\n> x_n * G and  c1 = k * G and c2 = U' + k * S }\n>\n> Then Buyer can buy s as the same as above.\n>\n> # Why this matters\n>\n> I believe that KVAC has great potential as a building block of anonymous\n> web apps.\n> Its MAC-based construction is more performant and easy to prove the\n> security compared to the similar system for the PKI based anonymous\n> credentials (e.g. U-Prove [5] and ACL [6]).\n> And it's a great fit for commercial purpose applications which do not have\n> to cooperate with other entities when defining the protocol. (Which is not\n> the case for an Attribute based credential system in general.)\n>\n> The reason so far it has not been used widely is, IMHO, it's because there\n> is no way to charge its users anonymously. [7]\n> Another problem is Sybil attack. In general, the DoS protection is a great\n> concern for anonymous applications.\n> So we need users to commit something \"scarce\" to prevent it.\n> It is why Signal requires its users to register their telephone number\n> (Maybe I'm wrong about this, not sure).\n> (WabiSabi cleverly uses the user's UTXO as the scarce resource to mitigate\n> this problem.)\n>\n> And of course, these problems get fixed by LN, if users have to pay to get\n> their service, the service does not have to ban the users by DoS-ing\n> anymore. So I think the LN-based payment and KVAC-based app fits very well.\n>\n> Thus, if the service wants to grant some right to do something with their\n> server resource to users in an unlinkable fashion, then I believe\n> exchanging the credential in this way has a benefit.\n>\n>\n> Regards,\n>\n> Miyamoto.\n>\n>\n> [1]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002647.html\n> [2]: https://eprint.iacr.org/2013/516.pdf\n> [3]: https://github.com/zkSNACKs/WabiSabi\n> [4]: https://signal.org/blog/pdfs/signal_private_group_system.pdf\n> [5]: https://www.microsoft.com/en-us/research/project/u-prove/\n> [6]: https://core.ac.uk/download/pdf/193377167.pdf\n> [7]: DuckDuckGo has an interesting solution for this. But it is not a\n> general solution for all kinds of apps and I doubt how good it works.\n> https://spreadprivacy.com/duckduckgo-revenue-model/\n>\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210205/8001a145/attachment.html>"
            },
            {
                "author": "Joe Miyamoto Philips",
                "date": "2021-02-08T10:02:16",
                "message_text_only": "(I have replied without changing the subject line so I will reply\nagain. sorry for spamming)\n\n> But I see the advantage of your idea. If a malicious credential server is able to identify you somehow at the point of payment then they might want\n> to selectively steal your money while being honest with everyone else.\n> In your scheme, if you pay you get the credential and then since it is anonymous it can't be distinguished from others when you go to claim whatever it entails.\n> Is this the idea?\n\nYes, And in case of a trustful exchange with LN, the malicious server does\nnot even have to distinguish a user. The server can just choose one private\nchannel that is connected to itself and decides to be dishonest to it.\nThe victim has no way to prove that he did NOT receive a credential after\npayment.\n\nEven if the server acts completely honestly, the user may claim that\nthey did not receive the credentials after payment. Other entities\nhave no way to tell if the user has been fooled or they are just\ntrying to undermine the reputation of the service.\n(In the case of credential presentation, it is easy to check if the\nserver is acting honestly. Just run the blind-show protocol and check\nif the server acts expectedly. The blind-show can be run by anyone and\nthe server has no way to distinguish which credential they received.)\n\nThus I think making an exchange atomic in this way is necessary for a\ncommercial application."
            },
            {
                "author": "Joe Miyamoto Philips",
                "date": "2021-02-08T10:33:36",
                "message_text_only": "(I have replied without changing the subject line  byte mistake so I will reply\nagain. sorry for spamming)\n\n> But I see the advantage of your idea. If a malicious credential server is able to identify you somehow at the point of payment then they might want\n> to selectively steal your money while being honest with everyone else.\n> In your scheme, if you pay you get the credential and then since it is anonymous it can't be distinguished from others when you go to claim whatever it entails.\n> Is this the idea?\n\nYes, And in case of a trustful exchange with LN, the malicious server does\nnot even have to distinguish a user. The server can just choose one private\nchannel that is connected to itself and decides to be dishonest to it.\nThe victim has no way to prove that he did NOT receive a credential after\npayment.\n\nEven if the server acts completely honestly, the user may claim that\nthey did not receive the credentials after payment. Other entities\nhave no way to tell if the user has been fooled or they are just\ntrying to undermine the reputation of the service.\n(In the case of credential presentation, it is easy to check if the\nserver is acting honestly. Just run the blind-show protocol and check\nif the server acts expectedly. The blind-show can be run by anyone and\nthe server has no way to distinguish which credential they received.)\n\nThus I think making an exchange atomic in this way is necessary for a\ncommercial application."
            }
        ],
        "thread_summary": {
            "title": "Pay-for-Elgamal-decryption-key and its application to Anonymous Credentials",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "\u5bae\u672c\u4e08",
                "Lloyd Fournier",
                "Joe Miyamoto Philips"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 20243
        }
    },
    {
        "title": "[Lightning-dev] Lightning-dev Digest, Vol 66, Issue 4",
        "thread_messages": [
            {
                "author": "Joe Miyamoto Philips",
                "date": "2021-02-05T13:02:42",
                "message_text_only": ">  If a malicious credential server is\nable to identify you somehow at the point of payment then they might want\n> to selectively steal your money while being honest with everyone else.\n> In your scheme, if you pay you get the credential and then since it is\nanonymous it can't be distinguished from others when you go to claim\nwhatever it entails.\n> Is this the idea?\n\nYes, And in case of a trustful exchange with LN, the malicious server does\nnot even have to distinguish a user. The server can just choose one private\nchannel that is connected to itself and decides to be dishonest to it.\nThe victim has no way to prove that he did NOT receive a credential after\npayment.\n\nThus I think making an exchange atomic is necessary in a commercial\napplication.\n\n\n\nOn Fri, Feb 5, 2021 at 9:00 PM <\nlightning-dev-request at lists.linuxfoundation.org> wrote:\n\n> Send Lightning-dev mailing list submissions to\n>         lightning-dev at lists.linuxfoundation.org\n>\n> To subscribe or unsubscribe via the World Wide Web, visit\n>         https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> or, via email, send a message with subject or body 'help' to\n>         lightning-dev-request at lists.linuxfoundation.org\n>\n> You can reach the person managing the list at\n>         lightning-dev-owner at lists.linuxfoundation.org\n>\n> When replying, please edit your Subject line so it is more specific\n> than \"Re: Contents of Lightning-dev digest...\"\n>\n>\n> Today's Topics:\n>\n>    1. Re: Pay-for-Elgamal-decryption-key and its application to\n>       Anonymous Credentials (Lloyd Fournier)\n>\n>\n> ----------------------------------------------------------------------\n>\n> Message: 1\n> Date: Fri, 5 Feb 2021 11:05:58 +1100\n> From: Lloyd Fournier <lloyd.fourn at gmail.com>\n> To: ??? <joe.miyamoto at bitcoinbank.co.jp>\n> Cc: \"lightning-dev\\\\\\\\@lists.linuxfoundation.org\"\n>         <lightning-dev at lists.linuxfoundation.org>\n> Subject: Re: [Lightning-dev] Pay-for-Elgamal-decryption-key and its\n>         application to Anonymous Credentials\n> Message-ID:\n>         <CAH5Bsr2b+1r=\n> KOG+eQWBYNMZuwkaHZvsR1O+6bWaGqym6r9c6w at mail.gmail.com>\n> Content-Type: text/plain; charset=\"utf-8\"\n>\n> Hi Miyamoto,\n>\n> Very interesting idea :)\n> Usually when dealing with anonymous credentials you are necessarily dealing\n> with a trusted third party so it's fine to just make a normal payment and\n> then receive the credential after successfully paying.\n> But I see the advantage of your idea. If a malicious credential server is\n> able to identify you somehow at the point of payment then they might want\n> to selectively steal your money while being honest with everyone else.\n> In your scheme, if you pay you get the credential and then since it is\n> anonymous it can't be distinguished from others when you go to claim\n> whatever it entails.\n> Is this the idea?\n>\n> Cheers,\n>\n> LL\n>\n> On Thu, Feb 4, 2021 at 1:04 PM ??? via Lightning-dev <\n> lightning-dev at lists.linuxfoundation.org> wrote:\n>\n> >\n> > Hi all.\n> >\n> > I want to point out another application of Discrete-Log selling on PTLC\n> > lightning since I could not find anyone else mentioning it (in\n> particular,\n> > I could not find in the Nadav Kohen's list here. [1] )\n> >\n> > The protocol may be obvious to most of the members here, but I believe\n> its\n> > application has some impact on the way people make anonymity-focused\n> > applications with LN, so I want to have some feedback.\n> >\n> > In short, by using ElGamal encryption, we can sell not only a\n> discrete-log\n> > but also an elliptic curve point which satisfies some requirements. This\n> > includes KVAC [2] which is used for WabiSabi [3] and Signal app [4].\n> >\n> > > disclaimer: I'm not a cryptography or math major, the following\n> > reasoning might be wrong at the fundamental level. Please correct me if\n> I'm\n> > wrong.\n> >\n> > ## Notations\n> >\n> > * G ... Elliptic curve base point.\n> > * H ... some additional NUMS\n> > * x, X = x * G ... secret and public key\n> >\n> > For ZKPoK, I will use Camenisch-Stadler like notation\n> > PK{ (secret values) : statements about secret values to prove. }\n> > e.g. For DLEQ proof. assume the verifier already have some points P_1,\n> P_2\n> > PK{ (x, y) : P_1 =  x * G and P_2 = y * H and x = y }\n> >\n> > # Protocols\n> >\n> > ## pay-for ElGamal decryption key\n> >\n> > Quick recap, ElGamal encryption for message M (= m * G) is\n> > (r * G, M + r * P)\n> > where r is some blinding factor and P is a shared secret (P = p * G)\n> >\n> > Imagine the Buyer knows some point (X_h = x * H), and he wants another\n> > point (X_g  = x * G).\n> > The Seller knows x and he wants to sell the point X_g but he does NOT\n> want\n> > to reveal its discrete log x to the buyer.\n> > (There is not much of a situation like this, but I will explain it\n> later.)\n> >\n> > In this case, the Seller can send its elgamal encryption and sell its\n> > decryption key.\n> > Seller:\n> > * Generate ephemeral encryption key S = s * G\n> > * Encrypt X_g  with random blinding r ... (c1, c2) := (r * G, X_g + r *\n> S)\n> > * Send (c1, c2) and S to the Buyer.\n> > * Also, send PK{(x, r, s) :  c1 = r * G and c2 = x * G + r * S and X_h =\n> x\n> > * H }\n> >\n> > Buyer\n> > * Verifies the ZKPoK, he can be sure that the plaintext will be X_g that\n> > he wants.\n> > * Make a payment offer to the Seller with S.\n> >\n> > Seller\n> > * Receive the payment by revealing s\n> >\n> > Buyer\n> > * Decrypt the ciphertext by s to get the X_g ... (X_g := c2 - c1 * s)\n> >\n> > ## Pay for Keyed Verification Anonymous Credential. (KVAC)\n> >\n> > We assume MAC_{GGM} scheme for the KVAC. [2]\n> >\n> > * attributes encoded in the credential is m_1, ... m_n\n> > * secret keys for the issuer=verifier is r, x_0, x_1, ... x_n\n> > * Public params for the issuer is (C_x0 = x_0 * G + r * H), (X_1 = x_1 *\n> > G, ... X_n = x_n * G)\n> >\n> > The credential is of the form (U, U') where U' = U * (x_0 + x_1 * m_1 +\n> > ... + x_n * m_n)\n> >\n> > Issuer:\n> > * get random point `U`\n> > * compute U' = U * (x_0 + x_1 * m_1 + ... + x_n + m_n)\n> > * sends U and ElGamal encryption of U' to the Buyer with blinding factor\n> k\n> > and ephemeral encryption key S.\n> >   * (c1, c2) = (k * G, U' + k * S)\n> > * Also send ZKPoK to tell the ciphertext is for correct U'\n> >   * PK{(x_0, ... x_n, x_0, r, k, s) :  U' = U * (x_0 + x_1 * m_1 + ... +\n> > x_n * m_n)  and  C_x0 = G * x_0 + H * r and X_1 = x_1 * G and ... and\n> X_n =\n> > x_n * G and  c1 = k * G and c2 = U' + k * S }\n> >\n> > Then Buyer can buy s as the same as above.\n> >\n> > # Why this matters\n> >\n> > I believe that KVAC has great potential as a building block of anonymous\n> > web apps.\n> > Its MAC-based construction is more performant and easy to prove the\n> > security compared to the similar system for the PKI based anonymous\n> > credentials (e.g. U-Prove [5] and ACL [6]).\n> > And it's a great fit for commercial purpose applications which do not\n> have\n> > to cooperate with other entities when defining the protocol. (Which is\n> not\n> > the case for an Attribute based credential system in general.)\n> >\n> > The reason so far it has not been used widely is, IMHO, it's because\n> there\n> > is no way to charge its users anonymously. [7]\n> > Another problem is Sybil attack. In general, the DoS protection is a\n> great\n> > concern for anonymous applications.\n> > So we need users to commit something \"scarce\" to prevent it.\n> > It is why Signal requires its users to register their telephone number\n> > (Maybe I'm wrong about this, not sure).\n> > (WabiSabi cleverly uses the user's UTXO as the scarce resource to\n> mitigate\n> > this problem.)\n> >\n> > And of course, these problems get fixed by LN, if users have to pay to\n> get\n> > their service, the service does not have to ban the users by DoS-ing\n> > anymore. So I think the LN-based payment and KVAC-based app fits very\n> well.\n> >\n> > Thus, if the service wants to grant some right to do something with their\n> > server resource to users in an unlinkable fashion, then I believe\n> > exchanging the credential in this way has a benefit.\n> >\n> >\n> > Regards,\n> >\n> > Miyamoto.\n> >\n> >\n> > [1]:\n> >\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002647.html\n> > [2]: https://eprint.iacr.org/2013/516.pdf\n> > [3]: https://github.com/zkSNACKs/WabiSabi\n> > [4]: https://signal.org/blog/pdfs/signal_private_group_system.pdf\n> > [5]: https://www.microsoft.com/en-us/research/project/u-prove/\n> > [6]: https://core.ac.uk/download/pdf/193377167.pdf\n> > [7]: DuckDuckGo has an interesting solution for this. But it is not a\n> > general solution for all kinds of apps and I doubt how good it works.\n> > https://spreadprivacy.com/duckduckgo-revenue-model/\n> >\n> >\n> >\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> >\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: <\n> http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210205/8001a145/attachment-0001.html\n> >\n>\n> ------------------------------\n>\n> Subject: Digest Footer\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n> ------------------------------\n>\n> End of Lightning-dev Digest, Vol 66, Issue 4\n> ********************************************\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210205/057d9dd8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Lightning-dev Digest, Vol 66, Issue 4",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Joe Miyamoto Philips"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 9644
        }
    },
    {
        "title": "[Lightning-dev] Escrow Over Lightning?",
        "thread_messages": [
            {
                "author": "Andr\u00e9s G. Aragoneses",
                "date": "2021-02-08T08:09:49",
                "message_text_only": "Hey ZmnSCPxj,\n\nAm I correct in understanding that this is a proposal to change the spec\n(maybe add a new BOLT) so that all lightning implementations can try to\nsupport this feature.\n\nIf the above is true, then I'm wondering: could a Lightning-based escrow\nsystem be implemented that doesn't require to modify the existing\nimplementations? Maybe if we simplify the requirements a bit? Like,\nremoving the \"Escrow only learns of dispute cases, never learns non-dispute\ncase\" aspect? That is, the third-party S always knows about an escrow\nbetween A and B taking place.\n\nI understand that the above requirement is a good to have, but if removing\nit allows a simpler version of escrow be implemented, then at least there\ncould be an interim solution for non-custodial exchanges to start adopting\nthis (otherwise they have to resort to custodial-based escrows, which is\nworse than lacking the escrow privacy brought by the requirement above).\n\nThanks\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210208/7070bbe6/attachment.html>"
            },
            {
                "author": "Pedro Moreno-Sanchez",
                "date": "2021-02-08T08:43:28",
                "message_text_only": "Hello,\n\nWhile reading this thread I realized that my colleagues and I have been working on a construction called \u201cBitcoin-compatible Virtual Channels\u201d [1] that, at a first glance, highly resembles the use case and requirements that you put forward in this thread. In a nutshell, a Virtual Channel is built on top of two payment channels and use them to construct its own \u201cfunding transaction\u201d. Imagine that Buyer and Seller do not have a payment channel between them, but they both have a payment channel with a  common node (e.g., Escrow in your example). Alice and Bob can create a Virtual Channel between them using fundings from both: channel Alice-Escrow and channel Escrow-Bob. After created, the Virtual Channel offers the same functionality as a direct payment channel between Alice and Bob (i.e., Escrow is no longer involved for payments). Our construction makes sure that no party losses funds when the Virtual Channel needs to be closed (either when Alice and Bob collaborate or any of the 3 parties cheat). \n\nThis construction is compatible with the current Bitcoin script (e.g., taproot is not required although perhaps useful when available) and with the Lightning Network. In the paper, we describe our construction assuming that a payment-channel follows the design in \u201cGeneralized Bitcoin-Compatible Channels\u201d [2], however the Virtual Channel construction can seamlessly work using the current Lightning payment channels.\n\nI would be glad to hear any feedback that you may have.\n\nCheers,\nPedro Moreno-Sanchez \n\n==\n\n[1] https://eprint.iacr.org/2020/554\n[2] https://eprint.iacr.org/2020/476.pdf\n\n> On Feb 8, 2021, at 9:09 AM, Andr\u00e9s G. Aragoneses <knocte at gmail.com> wrote:\n> \n> Hey ZmnSCPxj,\n> \n> Am I correct in understanding that this is a proposal to change the spec (maybe add a new BOLT) so that all lightning implementations can try to support this feature.\n> \n> If the above is true, then I'm wondering: could a Lightning-based escrow system be implemented that doesn't require to modify the existing implementations? Maybe if we simplify the requirements a bit? Like, removing the \"Escrow only learns of dispute cases, never learns non-dispute case\" aspect? That is, the third-party S always knows about an escrow between A and B taking place.\n> \n> I understand that the above requirement is a good to have, but if removing it allows a simpler version of escrow be implemented, then at least there could be an interim solution for non-custodial exchanges to start adopting this (otherwise they have to resort to custodial-based escrows, which is worse than lacking the escrow privacy brought by the requirement above).\n> \n> Thanks\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Nadav Kohen",
                "date": "2021-02-08T19:49:30",
                "message_text_only": "Hi Andr\u00e9s,\n\n> Am I correct in understanding that this is a proposal to change the spec\n(maybe add a new BOLT) so that all lightning implementations can try to\nsupport this feature.\n\nYes, the proposal relies on the use of PTLCs in place of HTLCs which is a\npopular change that will (hopefully) be brought about by Taproot. It is\nworth noting that this change is not specific to this protocol and that\nonly the end nodes (buyer and seller) would need any special code in order\nto execute these contracts if the underlying Lightning Network was using\nPTLCs.\n\n> If the above is true, then I'm wondering: could a Lightning-based escrow\nsystem be implemented that doesn't require to modify the existing\nimplementations? Maybe if we simplify the requirements a bit? Like,\nremoving the \"Escrow only learns of dispute cases, never learns non-dispute\ncase\" aspect? That is, the third-party S always knows about an escrow\nbetween A and B taking place.\n\nAt a high level, what is required here is that the payment goes through iff\n[Seller AND (Buyer OR Escrow)] agree to it. Lifting restrictions so that\nthe Escrow is allowed to be more interactive can allow the Buyer and Escrow\nto do an interactive shared secret generation and this secret could then be\nused in a spontaneous payment to the Seller (meaning the payment hash is\ngenerated by the Buyer and not the Seller) and then the Seller would have\nto obtain a ZKP from the Escrow that the payment hash is the hash of a\nsecret known to the Escrow. If all of this were done, then the Seller could\nexecute given the shared secret from either the Buyer or the Escrow. Of\nnote, another downside to this scheme beyond Escrow involvement is that\nthere is no proof of payment/reciept over the Lightning Network for this\npayment because it is a spontaneous payment.\n\nLike ZmnSCPxj's proposal, this would only require special code for the \"end\nnodes\" (Buyer and Seller) and the underlying HTLC-based lightning network\nwould require no changes. Also note that this scheme relies on the\nexistence of a Zero Knowledge Proof of Knowledge (ZKPoK) of a hash which is\nnot a trivial piece of work but certainly do-able.\n\nHi Pedro,\n\nI actually did have a question for you about Virtual Channels: The first\ntime I read the paper it struck me that while on the surface things look\npretty nice for the virtual channel participants, the intermediary has to\nlock up a lot of collateral (in total, the size of the channel) in order to\nenable this and subsequently this channel could stay open for a very long\ntime. As such, to the intermediary this seems very similar to having to\nroute a (potentially very large) hodl HTLC which means they will be\ncharging a very large fee for both the setup and the duration of the\nchannel. Because of this, I'm having trouble thinking of almost any use\ncases where this is preferable to just routing payments the normal way\nother than if the in-between node is not reliable and there are no other\ncheap routes (in which case it might be worth it to pay a premium). Did you\nor your colleagues have other use cases in mind? And have you done any fee\nanalysis for this scheme?\n\nBest,\nNadav\n\nOn Mon, Feb 8, 2021 at 2:43 AM Pedro Moreno-Sanchez <\npedrorechezmailinglists at gmail.com> wrote:\n\n> Hello,\n>\n> While reading this thread I realized that my colleagues and I have been\n> working on a construction called \u201cBitcoin-compatible Virtual Channels\u201d [1]\n> that, at a first glance, highly resembles the use case and requirements\n> that you put forward in this thread. In a nutshell, a Virtual Channel is\n> built on top of two payment channels and use them to construct its own\n> \u201cfunding transaction\u201d. Imagine that Buyer and Seller do not have a payment\n> channel between them, but they both have a payment channel with a  common\n> node (e.g., Escrow in your example). Alice and Bob can create a Virtual\n> Channel between them using fundings from both: channel Alice-Escrow and\n> channel Escrow-Bob. After created, the Virtual Channel offers the same\n> functionality as a direct payment channel between Alice and Bob (i.e.,\n> Escrow is no longer involved for payments). Our construction makes sure\n> that no party losses funds when the Virtual Channel needs to be closed\n> (either when Alice and Bob collaborate or any of the 3 parties cheat).\n>\n> This construction is compatible with the current Bitcoin script (e.g.,\n> taproot is not required although perhaps useful when available) and with\n> the Lightning Network. In the paper, we describe our construction assuming\n> that a payment-channel follows the design in \u201cGeneralized\n> Bitcoin-Compatible Channels\u201d [2], however the Virtual Channel construction\n> can seamlessly work using the current Lightning payment channels.\n>\n> I would be glad to hear any feedback that you may have.\n>\n> Cheers,\n> Pedro Moreno-Sanchez\n>\n> ==\n>\n> [1] https://eprint.iacr.org/2020/554\n> [2] https://eprint.iacr.org/2020/476.pdf\n>\n> > On Feb 8, 2021, at 9:09 AM, Andr\u00e9s G. Aragoneses <knocte at gmail.com>\n> wrote:\n> >\n> > Hey ZmnSCPxj,\n> >\n> > Am I correct in understanding that this is a proposal to change the spec\n> (maybe add a new BOLT) so that all lightning implementations can try to\n> support this feature.\n> >\n> > If the above is true, then I'm wondering: could a Lightning-based escrow\n> system be implemented that doesn't require to modify the existing\n> implementations? Maybe if we simplify the requirements a bit? Like,\n> removing the \"Escrow only learns of dispute cases, never learns non-dispute\n> case\" aspect? That is, the third-party S always knows about an escrow\n> between A and B taking place.\n> >\n> > I understand that the above requirement is a good to have, but if\n> removing it allows a simpler version of escrow be implemented, then at\n> least there could be an interim solution for non-custodial exchanges to\n> start adopting this (otherwise they have to resort to custodial-based\n> escrows, which is worse than lacking the escrow privacy brought by the\n> requirement above).\n> >\n> > Thanks\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210208/89782223/attachment.html>"
            },
            {
                "author": "Pedro Moreno-Sanchez",
                "date": "2021-02-09T13:48:50",
                "message_text_only": "Hi Nadav,\n\nYou are right that the intermediary (i.e., Ingrid) needs to hold a certain amount of coins to allow the virtual channel between Alice and Bob. Some comments here:\n - The protocol makes sure that Ingrid will get paid whatever fee she decides to charge for the service of creating a virtual channel. Note that Ingrid does not have the guarantee that enough payments would be routed through her node to gain the same fee in the same amount of time.\n\n - If Ingrid is afraid that her coins will hold too long, one of the two modes in our construction for virtual channels offers the possibility for Ingrid to close the virtual channel at any time and get the locked coins back (plus the fee). \n\n - On the other hand, imagine that Ingrid charges \u201cx\u201d as fee. Alice and Bob would be interested in opening a virtual channel if they plan to do a number of payments between them such that the total fee they would pay would be higher than \u201cx\u201d. (We have a more elaborated fee analysis at the end of the performance evaluation section in the paper).\n\nWe envision some use cases where virtual channels would be beneficial: \n - Imagine Bob is a new provider of a web service (e.g., premium news or a premium music player) that charges for each new/song that is downloaded. Alice, who has previously created all the channels that she is willing/able to manage, still wants to try this new service. Alice could open a virtual channel with Bob to try out this service.\n\n - Same situation as before, but Bob (a router) now offers wifi connection in exchange for micropayments. \n\n - In general, any two-party computation between Alice and Bob that can be expressed in Bitcoin scripting language in a scenario where Alice and Bob do not share a payment channel yet. \n\nAnd of course could be other use cases that we have not thought about yet. I am looking forward to hearing any proposal that people in this list might have.\n\nCheers,\nPedro. \n\n> On 8 Feb 2021, at 20:49, Nadav Kohen <nadav at suredbits.com> wrote:\n> \n> Hi Pedro,\n> \n> I actually did have a question for you about Virtual Channels: The first time I read the paper it struck me that while on the surface things look pretty nice for the virtual channel participants, the intermediary has to lock up a lot of collateral (in total, the size of the channel) in order to enable this and subsequently this channel could stay open for a very long time. As such, to the intermediary this seems very similar to having to route a (potentially very large) hodl HTLC which means they will be charging a very large fee for both the setup and the duration of the channel. Because of this, I'm having trouble thinking of almost any use cases where this is preferable to just routing payments the normal way other than if the in-between node is not reliable and there are no other cheap routes (in which case it might be worth it to pay a premium). Did you or your colleagues have other use cases in mind? And have you done any fee analysis for this scheme?\n> \n> Best,\n> Nadav\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210209/bfd8277f/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-11T05:31:21",
                "message_text_only": "Good morning Pedro,\n\n> Hi Nadav,\n>\n> You are right that the intermediary (i.e., Ingrid) needs to hold a certain amount of coins to allow the virtual channel between Alice and Bob. Some comments here:\n> \u00a0- The protocol makes sure that Ingrid will get paid whatever fee she decides to charge for the service of creating a virtual channel. Note that Ingrid does not have the guarantee that enough payments would be routed through her node to gain the same fee in the same amount of time.\n\nHave not examined this deeply, but what happens if any of the *actual* Alice-Ingrid or Ingrid-Bob channels are forced unilaterally onchain before the purported lifetime of the virtual channel?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Pedro Moreno-Sanchez",
                "date": "2021-02-11T17:03:09",
                "message_text_only": "> On Feb 11, 2021, at 6:31 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> \n> Good morning Pedro,\n> \n>> Hi Nadav,\n>> \n>> You are right that the intermediary (i.e., Ingrid) needs to hold a certain amount of coins to allow the virtual channel between Alice and Bob. Some comments here:\n>>  - The protocol makes sure that Ingrid will get paid whatever fee she decides to charge for the service of creating a virtual channel. Note that Ingrid does not have the guarantee that enough payments would be routed through her node to gain the same fee in the same amount of time.\n> \n> Have not examined this deeply, but what happens if any of the *actual* Alice-Ingrid or Ingrid-Bob channels are forced unilaterally onchain before the purported lifetime of the virtual channel?\n\nAs a safe fallback, the protocol gives time to Ingrid (or Bob depending on the case) to put the other channel onchain before the punishment can be triggered. \n\n> \n> Regards,\n> ZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-11T06:00:58",
                "message_text_only": "Good morning Nadav and Andres,\n\nThank you for bringing up this topic again.\n\nLet me provide a new twist to this old idea.\n\nThis is the entire logic of the contract to the seller:\n\n   SELLER && (BUYER || ESCROW)\n\nNow, a big issue is that simple `&&` is trivial for PTLCs, it is the `||` which is difficult and requires ECDH and proof that the ECDH was done correctly.\n\nBut we can observe the De Morgan Theorem:\n\n   A || B <=> !(!A && !B)\n\nSo how about we *invert* the logic?\n\nSo what we do is, we make *two* payments of the same amount:\n\n* Seller -> Buyer , claimable by BUYER && ESCROW key.\n* Buyer  -> Seller, claimable by SELLER key.\n\nSo the ritual is this:\n\n* Seller -> Buyer claimable by BUYER && ESCROW.\n* Buyer -> Seller claimable by SELLER.\n* Seller hands over item.\n* Buyer judges whether to accept, or complain to Escrow.\n\nNow let us consider our cases:\n\n* Buyer is satisfied with the product.\n  * Buyer fails the Seller->Buyer payment after seller claims the Buyer->Seller payment, so Seller is paid and has no more obligations.\n* Buyer is dissastisfied and wants the Escrow to judge:\n  * Escrow judges Buyer is right: Escrow reveals ESCROW key to Buyer, who then clawbacks the payment to the seller.\n  * Escrow judges Seller is right: Escrow deletes ESCROW privkey (\"not ESCROW\"), and the Seller->Buyer payment eventually times out, ending the obligation of the Seller.\n\nThe \"reverse\" payment is effectively the inversion of logic by the De Morgan theorem, and the \"normal case\" (buyer ultimately pays seller) has the Escrow not revealing the privkey.\nIn addition, in the case where Buyer is satisfied (i.e. both Buyer and Seller agree the trade is beneficial) the Escrow is never involved (the Escrow might have a timeout for the temporary ESCROW keypair, which it will eventually delete; since all payments on LN need a timeout anyway, this is fine) and thus does not know about the trade, except that some trade was requested (since it must provide a temporary ESCROW pubkey).\n\nThis even provides a simple BUYER + ESCROW keypair that gives the seller a proof-of-refund, and of course the simple SELLER gives the buyer a proof-of-payment as well.\nIt only just requires twice as much Bitcoins getting locked.\n\nThoughts?\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andr\u00e9s G. Aragoneses",
                "date": "2021-02-11T07:21:18",
                "message_text_only": "This looks cool but would hinder UX too much for certain scenarios: e.g. if\nthe escrow in place is part of a bitcoin exchange, then you require the\nbitcoin buyer to have bitcoin already, which makes it harder to on-ramp new\nusers (which could maybe only have fiat). Am I right?\n\nSo are you saying that this is not doable without PTLCs (with simple HTLCs)\nunless it's done like suggested?\n\nOn Thu, 11 Feb 2021 at 14:01, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Nadav and Andres,\n>\n> Thank you for bringing up this topic again.\n>\n> Let me provide a new twist to this old idea.\n>\n> This is the entire logic of the contract to the seller:\n>\n>    SELLER && (BUYER || ESCROW)\n>\n> Now, a big issue is that simple `&&` is trivial for PTLCs, it is the `||`\n> which is difficult and requires ECDH and proof that the ECDH was done\n> correctly.\n>\n> But we can observe the De Morgan Theorem:\n>\n>    A || B <=> !(!A && !B)\n>\n> So how about we *invert* the logic?\n>\n> So what we do is, we make *two* payments of the same amount:\n>\n> * Seller -> Buyer , claimable by BUYER && ESCROW key.\n> * Buyer  -> Seller, claimable by SELLER key.\n>\n> So the ritual is this:\n>\n> * Seller -> Buyer claimable by BUYER && ESCROW.\n> * Buyer -> Seller claimable by SELLER.\n> * Seller hands over item.\n> * Buyer judges whether to accept, or complain to Escrow.\n>\n> Now let us consider our cases:\n>\n> * Buyer is satisfied with the product.\n>   * Buyer fails the Seller->Buyer payment after seller claims the\n> Buyer->Seller payment, so Seller is paid and has no more obligations.\n> * Buyer is dissastisfied and wants the Escrow to judge:\n>   * Escrow judges Buyer is right: Escrow reveals ESCROW key to Buyer, who\n> then clawbacks the payment to the seller.\n>   * Escrow judges Seller is right: Escrow deletes ESCROW privkey (\"not\n> ESCROW\"), and the Seller->Buyer payment eventually times out, ending the\n> obligation of the Seller.\n>\n> The \"reverse\" payment is effectively the inversion of logic by the De\n> Morgan theorem, and the \"normal case\" (buyer ultimately pays seller) has\n> the Escrow not revealing the privkey.\n> In addition, in the case where Buyer is satisfied (i.e. both Buyer and\n> Seller agree the trade is beneficial) the Escrow is never involved (the\n> Escrow might have a timeout for the temporary ESCROW keypair, which it will\n> eventually delete; since all payments on LN need a timeout anyway, this is\n> fine) and thus does not know about the trade, except that some trade was\n> requested (since it must provide a temporary ESCROW pubkey).\n>\n> This even provides a simple BUYER + ESCROW keypair that gives the seller a\n> proof-of-refund, and of course the simple SELLER gives the buyer a\n> proof-of-payment as well.\n> It only just requires twice as much Bitcoins getting locked.\n>\n> Thoughts?\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210211/c6a316f0/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-11T07:33:29",
                "message_text_only": "Good morning Andres,\n\n> This looks cool but would hinder UX too much for certain scenarios: e.g. if the escrow in place is part of a bitcoin exchange, then you\u00a0require the bitcoin buyer to have bitcoin already, which makes it harder to on-ramp new users (which could maybe only have fiat). Am I right?\n\nCorrect.\nThough note that existing systems like Bisq, to my knowledge, have the same problem, a buyer of Bitcoin has to have a small amount of Bitcoin to offer as stake that can be revoked in case they attempt to defraud the counterparty.\nWithout it, the counterparty takes on increased risk (which translate to larger exchange spread).\n\nIn any case, once you have that initial stake, you can then keep increasing your ability to provide stake so as to relieve your counterparties of risk and have them offer better exchange rates, so it is \"only\" an issue for initial onboarding.\nPresumably, in the later stable state, parents will provide children the initial stake needed for them to start transacting over such a system, just as they already provide their children with other \"initial stakes\" (education, food, shelter, etc.) anyway.\n\n>\n> So are you saying that this is not doable without PTLCs (with simple HTLCs) unless it's done like suggested?\n\nYes, it is yet another reason we want PTLCs quickly.\n\nAn alternative would be to have dual-hash HTLCs, which would be helpful in other escrow-related cases including escrow-facilitated cross-currency swaps.\n\nRegards,\nZmnSCPxj\n\n\n>\n> On Thu, 11 Feb 2021 at 14:01, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Nadav and Andres,\n> >\n> > Thank you for bringing up this topic again.\n> >\n> > Let me provide a new twist to this old idea.\n> >\n> > This is the entire logic of the contract to the seller:\n> >\n> > \u00a0 \u00a0SELLER && (BUYER || ESCROW)\n> >\n> > Now, a big issue is that simple `&&` is trivial for PTLCs, it is the `||` which is difficult and requires ECDH and proof that the ECDH was done correctly.\n> >\n> > But we can observe the De Morgan Theorem:\n> >\n> > \u00a0 \u00a0A || B <=> !(!A && !B)\n> >\n> > So how about we *invert* the logic?\n> >\n> > So what we do is, we make *two* payments of the same amount:\n> >\n> > * Seller -> Buyer , claimable by BUYER && ESCROW key.\n> > * Buyer\u00a0 -> Seller, claimable by SELLER key.\n> >\n> > So the ritual is this:\n> >\n> > * Seller -> Buyer claimable by BUYER && ESCROW.\n> > * Buyer -> Seller claimable by SELLER.\n> > * Seller hands over item.\n> > * Buyer judges whether to accept, or complain to Escrow.\n> >\n> > Now let us consider our cases:\n> >\n> > * Buyer is satisfied with the product.\n> > \u00a0 * Buyer fails the Seller->Buyer payment after seller claims the Buyer->Seller payment, so Seller is paid and has no more obligations.\n> > * Buyer is dissastisfied and wants the Escrow to judge:\n> > \u00a0 * Escrow judges Buyer is right: Escrow reveals ESCROW key to Buyer, who then clawbacks the payment to the seller.\n> > \u00a0 * Escrow judges Seller is right: Escrow deletes ESCROW privkey (\"not ESCROW\"), and the Seller->Buyer payment eventually times out, ending the obligation of the Seller.\n> >\n> > The \"reverse\" payment is effectively the inversion of logic by the De Morgan theorem, and the \"normal case\" (buyer ultimately pays seller) has the Escrow not revealing the privkey.\n> > In addition, in the case where Buyer is satisfied (i.e. both Buyer and Seller agree the trade is beneficial) the Escrow is never involved (the Escrow might have a timeout for the temporary ESCROW keypair, which it will eventually delete; since all payments on LN need a timeout anyway, this is fine) and thus does not know about the trade, except that some trade was requested (since it must provide a temporary ESCROW pubkey).\n> >\n> > This even provides a simple BUYER + ESCROW keypair that gives the seller a proof-of-refund, and of course the simple SELLER gives the buyer a proof-of-payment as well.\n> > It only just requires twice as much Bitcoins getting locked.\n> >\n> > Thoughts?\n> >\n> > Regards,\n> > ZmnSCPxj"
            },
            {
                "author": "Andr\u00e9s G. Aragoneses",
                "date": "2021-02-11T15:02:26",
                "message_text_only": "Hey ZmnSCPxj,\n\nOn Thu, 11 Feb 2021 at 15:33, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Andres,\n>\n> > This looks cool but would hinder UX too much for certain scenarios: e.g.\n> if the escrow in place is part of a bitcoin exchange, then you require the\n> bitcoin buyer to have bitcoin already, which makes it harder to on-ramp new\n> users (which could maybe only have fiat). Am I right?\n>\n> Correct.\n> Though note that existing systems like Bisq, to my knowledge, have the\n> same problem, a buyer of Bitcoin has to have a small amount of Bitcoin to\n> offer as stake that can be revoked in case they attempt to defraud the\n> counterparty.\n> Without it, the counterparty takes on increased risk (which translate to\n> larger exchange spread).\n>\n\nYeah I understand Bisq's model.\nHowever not all P2P exchanges work like this; e.g. localcryptos, hodlhodl,\nlocalbitcoins, localcryptos...\n\n\n\n>\n> In any case, once you have that initial stake, you can then keep\n> increasing your ability to provide stake so as to relieve your\n> counterparties of risk and have them offer better exchange rates, so it is\n> \"only\" an issue for initial onboarding.\n> Presumably, in the later stable state, parents will provide children the\n> initial stake needed for them to start transacting over such a system, just\n> as they already provide their children with other \"initial stakes\"\n> (education, food, shelter, etc.) anyway.\n>\n> >\n> > So are you saying that this is not doable without PTLCs (with simple\n> HTLCs) unless it's done like suggested?\n>\n> Yes, it is yet another reason we want PTLCs quickly.\n>\n> An alternative would be to have dual-hash HTLCs, which would be helpful in\n> other escrow-related cases including escrow-facilitated cross-currency\n> swaps.\n>\n\nIs there any disadvantage about using dual-hash HTLCs?\nIs it supported by the current LN spec?\n\n\n\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> >\n> > On Thu, 11 Feb 2021 at 14:01, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Nadav and Andres,\n> > >\n> > > Thank you for bringing up this topic again.\n> > >\n> > > Let me provide a new twist to this old idea.\n> > >\n> > > This is the entire logic of the contract to the seller:\n> > >\n> > >    SELLER && (BUYER || ESCROW)\n> > >\n> > > Now, a big issue is that simple `&&` is trivial for PTLCs, it is the\n> `||` which is difficult and requires ECDH and proof that the ECDH was done\n> correctly.\n> > >\n> > > But we can observe the De Morgan Theorem:\n> > >\n> > >    A || B <=> !(!A && !B)\n> > >\n> > > So how about we *invert* the logic?\n> > >\n> > > So what we do is, we make *two* payments of the same amount:\n> > >\n> > > * Seller -> Buyer , claimable by BUYER && ESCROW key.\n> > > * Buyer  -> Seller, claimable by SELLER key.\n> > >\n> > > So the ritual is this:\n> > >\n> > > * Seller -> Buyer claimable by BUYER && ESCROW.\n> > > * Buyer -> Seller claimable by SELLER.\n> > > * Seller hands over item.\n> > > * Buyer judges whether to accept, or complain to Escrow.\n> > >\n> > > Now let us consider our cases:\n> > >\n> > > * Buyer is satisfied with the product.\n> > >   * Buyer fails the Seller->Buyer payment after seller claims the\n> Buyer->Seller payment, so Seller is paid and has no more obligations.\n> > > * Buyer is dissastisfied and wants the Escrow to judge:\n> > >   * Escrow judges Buyer is right: Escrow reveals ESCROW key to Buyer,\n> who then clawbacks the payment to the seller.\n> > >   * Escrow judges Seller is right: Escrow deletes ESCROW privkey (\"not\n> ESCROW\"), and the Seller->Buyer payment eventually times out, ending the\n> obligation of the Seller.\n> > >\n> > > The \"reverse\" payment is effectively the inversion of logic by the De\n> Morgan theorem, and the \"normal case\" (buyer ultimately pays seller) has\n> the Escrow not revealing the privkey.\n> > > In addition, in the case where Buyer is satisfied (i.e. both Buyer and\n> Seller agree the trade is beneficial) the Escrow is never involved (the\n> Escrow might have a timeout for the temporary ESCROW keypair, which it will\n> eventually delete; since all payments on LN need a timeout anyway, this is\n> fine) and thus does not know about the trade, except that some trade was\n> requested (since it must provide a temporary ESCROW pubkey).\n> > >\n> > > This even provides a simple BUYER + ESCROW keypair that gives the\n> seller a proof-of-refund, and of course the simple SELLER gives the buyer a\n> proof-of-payment as well.\n> > > It only just requires twice as much Bitcoins getting locked.\n> > >\n> > > Thoughts?\n> > >\n> > > Regards,\n> > > ZmnSCPxj\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210211/ad341e90/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-12T00:51:52",
                "message_text_only": "Good morning Andres,\n\n> Hey ZmnSCPxj,\n>\n> On Thu, 11 Feb 2021 at 15:33, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n> > Good morning Andres,\n> >\n> > > This looks cool but would hinder UX too much for certain scenarios: e.g. if the escrow in place is part of a bitcoin exchange, then you\u00a0require the bitcoin buyer to have bitcoin already, which makes it harder to on-ramp new users (which could maybe only have fiat). Am I right?\n> >\n> > Correct.\n> > Though note that existing systems like Bisq, to my knowledge, have the same problem, a buyer of Bitcoin has to have a small amount of Bitcoin to offer as stake that can be revoked in case they attempt to defraud the counterparty.\n> > Without it, the counterparty takes on increased risk (which translate to larger exchange spread).\n>\n> Yeah I understand Bisq's model.\n> However not all P2P exchanges work like this; e.g. localcryptos, hodlhodl, localbitcoins, localcryptos...\n>\n\nAt least localbitcoins is custodial, and this scheme is non-custodial (though the escrow must still be trusted to actually judge correctly in case of dispute, so non-custodiality might be a very thin assurance).\n\n> \u00a0\n>\n> > In any case, once you have that initial stake, you can then keep increasing your ability to provide stake so as to relieve your counterparties of risk and have them offer better exchange rates, so it is \"only\" an issue for initial onboarding.\n> > Presumably, in the later stable state, parents will provide children the initial stake needed for them to start transacting over such a system, just as they already provide their children with other \"initial stakes\" (education, food, shelter, etc.) anyway.\n> >\n> > >\n> > > So are you saying that this is not doable without PTLCs (with simple HTLCs) unless it's done like suggested?\n> >\n> > Yes, it is yet another reason we want PTLCs quickly.\n> >\n> > An alternative would be to have dual-hash HTLCs, which would be helpful in other escrow-related cases including escrow-facilitated cross-currency swaps.\n>\n> Is there any disadvantage about using dual-hash HTLCs?\n> Is it supported by the current LN spec?\n\nIt is no supported by current LN spec, and PTLCs are overall superior (they are equivalent to having any number of hashes, not just 2 that dual-hash HTLCs can do).\nSo if we need to change the LN spec anyway, PTLCs are still the better choice, since they enable a lot more, and we probably want to support that in the future anyway, so we might as well do HTLC->PTLC rather than HTLC->2HTLC->PTLC.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Andr\u00e9s G. Aragoneses",
                "date": "2021-02-13T04:50:21",
                "message_text_only": "Hey ZmnSCPxj,\n\nOn Fri, 12 Feb 2021 at 08:52, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Andres,\n>\n> > Hey ZmnSCPxj,\n> >\n> > On Thu, 11 Feb 2021 at 15:33, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n> >\n> > > Good morning Andres,\n> > >\n> > > > This looks cool but would hinder UX too much for certain scenarios:\n> e.g. if the escrow in place is part of a bitcoin exchange, then you require\n> the bitcoin buyer to have bitcoin already, which makes it harder to on-ramp\n> new users (which could maybe only have fiat). Am I right?\n> > >\n> > > Correct.\n> > > Though note that existing systems like Bisq, to my knowledge, have the\n> same problem, a buyer of Bitcoin has to have a small amount of Bitcoin to\n> offer as stake that can be revoked in case they attempt to defraud the\n> counterparty.\n> > > Without it, the counterparty takes on increased risk (which translate\n> to larger exchange spread).\n> >\n> > Yeah I understand Bisq's model.\n> > However not all P2P exchanges work like this; e.g. localcryptos,\n> hodlhodl, localbitcoins, localcryptos...\n> >\n>\n> At least localbitcoins is custodial, and this scheme is non-custodial\n> (though the escrow must still be trusted to actually judge correctly in\n> case of dispute, so non-custodiality might be a very thin assurance).\n>\n>\nTrue, I shouldn't have included LB in that list of examples; the other two\nare non-custodial though.\n\n\n\n> >\n> >\n> > > In any case, once you have that initial stake, you can then keep\n> increasing your ability to provide stake so as to relieve your\n> counterparties of risk and have them offer better exchange rates, so it is\n> \"only\" an issue for initial onboarding.\n> > > Presumably, in the later stable state, parents will provide children\n> the initial stake needed for them to start transacting over such a system,\n> just as they already provide their children with other \"initial stakes\"\n> (education, food, shelter, etc.) anyway.\n> > >\n> > > >\n> > > > So are you saying that this is not doable without PTLCs (with simple\n> HTLCs) unless it's done like suggested?\n> > >\n> > > Yes, it is yet another reason we want PTLCs quickly.\n> > >\n> > > An alternative would be to have dual-hash HTLCs, which would be\n> helpful in other escrow-related cases including escrow-facilitated\n> cross-currency swaps.\n> >\n> > Is there any disadvantage about using dual-hash HTLCs?\n> > Is it supported by the current LN spec?\n>\n> It is no supported by current LN spec, and PTLCs are overall superior\n> (they are equivalent to having any number of hashes, not just 2 that\n> dual-hash HTLCs can do).\n> So if we need to change the LN spec anyway, PTLCs are still the better\n> choice, since they enable a lot more, and we probably want to support that\n> in the future anyway, so we might as well do HTLC->PTLC rather than\n> HTLC->2HTLC->PTLC.\n>\n\nBut anyway any L2 wallet that interacts with this, will need to be aware of\nthe escrow, so developing an 2HTLC extension for it to work with the\ncurrent version of bitcoin (instead of waiting for Taproot) should be\ndoable, right?\n\n\n\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210213/ff3292bc/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-13T05:26:40",
                "message_text_only": "Good morning Andres,\n\n> > > Is there any disadvantage about using dual-hash HTLCs?\n> > > Is it supported by the current LN spec?\n> >\n> > It is no supported by current LN spec, and PTLCs are overall superior (they are equivalent to having any number of hashes, not just 2 that dual-hash HTLCs can do).\n> > So if we need to change the LN spec anyway, PTLCs are still the better choice, since they enable a lot more, and we probably want to support that in the future anyway, so we might as well do HTLC->PTLC rather than HTLC->2HTLC->PTLC.\n>\n> But anyway any L2 wallet that interacts with this, will need to be aware of the escrow, so developing an 2HTLC extension for it to work with the current version of bitcoin (instead of waiting for Taproot) should be doable, right?\n\nEvery forwarding node needs to support 2HTLC or PTLC, meaning it has to be a network-wide upgrade.\nThen once the network-wide upgrade is deployed, individual endpoints just have to understand this protocol.\n\nBecause of the need of widespread upgrade, we would prefer to just upgrade once, from HTLCs to PTLCs, rather than have multiple network-wide upgrades.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Nadav Kohen",
                "date": "2021-02-13T05:47:50",
                "message_text_only": "Hey ZmnSCPxj,\n\nYour earlier post about how to accomplish ORing points without verifiable\nencryption was super interesting.\n\nI think this contains a clever general NOT operation where you double the\npayment and use the point as a condition for the \"cancellation payment.\"\nThis is actually very similar to something that is used in my PTLC DLC\nscheme where many payments are failed in most cases :) But nice to add it\nto the toolkit, especially as a way to not use ORs for the price of\nover-collateralization which is acceptable in many use cases.\n\nOne comment to make though, is that this mechanism requires the atomic\nsetup of multiple payments otherwise Seller -> Buyer will be set up after\nwhich Buyer may keep the free option and not set up the payment in return.\nLuckily with barrier escrows we can do atomic multi-payment setup to\naccomplish this!\n\nBest,\nNadav\n\nOn Fri, Feb 12, 2021 at 11:26 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Andres,\n>\n> > > > Is there any disadvantage about using dual-hash HTLCs?\n> > > > Is it supported by the current LN spec?\n> > >\n> > > It is no supported by current LN spec, and PTLCs are overall superior\n> (they are equivalent to having any number of hashes, not just 2 that\n> dual-hash HTLCs can do).\n> > > So if we need to change the LN spec anyway, PTLCs are still the better\n> choice, since they enable a lot more, and we probably want to support that\n> in the future anyway, so we might as well do HTLC->PTLC rather than\n> HTLC->2HTLC->PTLC.\n> >\n> > But anyway any L2 wallet that interacts with this, will need to be aware\n> of the escrow, so developing an 2HTLC extension for it to work with the\n> current version of bitcoin (instead of waiting for Taproot) should be\n> doable, right?\n>\n> Every forwarding node needs to support 2HTLC or PTLC, meaning it has to be\n> a network-wide upgrade.\n> Then once the network-wide upgrade is deployed, individual endpoints just\n> have to understand this protocol.\n>\n> Because of the need of widespread upgrade, we would prefer to just upgrade\n> once, from HTLCs to PTLCs, rather than have multiple network-wide upgrades.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210212/015b8ab3/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-13T06:30:42",
                "message_text_only": "Good morning Nadav,\n\n> Hey ZmnSCPxj,\n>\n> Your earlier post about how to accomplish ORing points without verifiable encryption was super interesting.\n>\n> I think this contains a clever general NOT operation where you double the payment and use the point as a condition for the \"cancellation payment.\" This is actually very similar to something that is used in my PTLC DLC scheme where\u00a0many payments are failed in most cases :) But nice to add it to the toolkit, especially as a way to not use ORs for the price of over-collateralization which is acceptable in many use cases.\n\nIndeed, specifically this point of De Morgan Theorem transformation should probably be emphasized.\n\nMore generally, all Boolean logic can be converted to one of two standard forms.\n\n* sum-of-products i.e. `||` over `&&`\n* product-of-sums i.e. `&&` over `||`\n\nFor example an XOR can be converted to the sum-of-products form:\n\n    A ^ B = (!A && B) || (A && !B)\n\nIf we have any complicated Boolean logic, we can consider to always use some kind of product-of-sums form.\nSo for the example case, escrow service is the logic:\n\n    SELLER && (BUYER || ESCROW)\n\nThe above is a standard product-of-sums form.\n\nAny sums (i.e. `||`) can be converted by De Morgan Theorem to product, and the payment can be a reversal instead.\n\n    SELLER && !(!BUYER && !ESCROW)\n\nThe `!(a && b && ...)` can be converted to a reversal of the payment.\nThe individual `!BUYER` is just the buyer choosing not to claim the seller->buyer direction, and the individual `!ESCROW` is just the escrow choosing not to reveal its temporary scalar for this payment.\nAnd any products (i.e. `&&`) are trivially implemented in PTLCs as trivial scalar and point addition.\n\nSo it may actually be possible to express *any* Boolean logic, by the use of reversal payments and \"option not to release scalar\", both of which implement the NOT gate needed for the above.\nBoolean logic is a fairly powerful, non-Turing-complete, and consistent programming language, and if we can actually implement any kind of Boolean logic with a set of payments in various directions and Barrier Escrows we can enable some fairly complex use-cases..\n\nFor example, a simple DLC binary oracle can provide two points in such a way that it can only reveal one scalar of those two points (e.g. it has a persistent public key `P`, and two temporary points `H` and `T` such that `H = T + P`, and it can only safely reveal either `h` or `t`.).\nBased on the outcome of a coin flip (or other input from the mythical \"real world\"), it reveals either one or the other scalar.\nThen we can use either point as part of any `!Oracle` or `Oracle` Boolean logic we need.\n\n>\n> One comment to make though, is that this mechanism requires the atomic setup of multiple payments otherwise Seller -> Buyer will be set up after which Buyer may keep the free option and not set up the payment in return. Luckily with barrier escrows we can do atomic multi-payment setup to accomplish this!\n\nFor this particular use-case, I think it is safe to just use the order \"Seller->Buyer, then Buyer->Seller\" rather than add a barrier escrow.\nRemember, the entire setup presumes that both Buyer and Seller can tr\\*st the Escrow to resolve disputes, and the Seller->Buyer payment requires BUYER && ESCROW.\nIf the buyer never makes the Buyer->Seller payment presumably the Escrow will take that into consideration during dispute resolution and not release the ESCROW scalar to the Buyer.\n\nAnd if the Buyer->Seller payment (which requires only SELLER scalar) is claimed \"early\" by the Seller before handing off the item, the Escrow is tr\\*sted to consider this also (it is substantially the same as the Seller providing substandard goods) and release the ESCROW scalar.\n\nOf course in the most general case above where we could potentially do any arbitrary logic it probably makes most sense to use a Barrier escrow as well to ensure atomicity of the setup.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-13T07:03:28",
                "message_text_only": "Good morning Nadav, and list,\n\n\n>\n> More generally, all Boolean logic can be converted to one of two standard forms.\n>\n> -   sum-of-products i.e. `||` over `&&`\n> -   product-of-sums i.e. `&&` over `||`\n>\n>     For example an XOR can be converted to the sum-of-products form:\n>\n>     A ^ B = (!A && B) || (A && !B)\n>\n>     If we have any complicated Boolean logic, we can consider to always use some kind of product-of-sums form.\n>     So for the example case, escrow service is the logic:\n>\n>     SELLER && (BUYER || ESCROW)\n>\n>     The above is a standard product-of-sums form.\n>\n>     Any sums (i.e. `||`) can be converted by De Morgan Theorem to product, and the payment can be a reversal instead.\n>\n>     SELLER && !(!BUYER && !ESCROW)\n>\n>     The `!(a && b && ...)` can be converted to a reversal of the payment.\n>     The individual `!BUYER` is just the buyer choosing not to claim the seller->buyer direction, and the individual `!ESCROW` is just the escrow choosing not to reveal its temporary scalar for this payment.\n>\n>\n> And any products (i.e. `&&`) are trivially implemented in PTLCs as trivial scalar and point addition.\n>\n> So it may actually be possible to express any Boolean logic, by the use of reversal payments and \"option not to release scalar\", both of which implement the NOT gate needed for the above.\n> Boolean logic is a fairly powerful, non-Turing-complete, and consistent programming language, and if we can actually implement any kind of Boolean logic with a set of payments in various directions and Barrier Escrows we can enable some fairly complex use-cases..\n>\n> For example, a simple DLC binary oracle can provide two points in such a way that it can only reveal one scalar of those two points (e.g. it has a persistent public key `P`, and two temporary points `H` and `T` such that `H = T + P`, and it can only safely reveal either `h` or `t`.).\n> Based on the outcome of a coin flip (or other input from the mythical \"real world\"), it reveals either one or the other scalar.\n> Then we can use either point as part of any `!Oracle` or `Oracle` Boolean logic we need.\n\n\n\nOkay, so here is a worked example.\n\nSuppose we have two oracles, 1 and 2.\nAt some point, they will flip coins in the future.\nBased on their (independent) coin flip, oracle 1 will reveal either H1 or T1, and oracle 2 will reveal either H2 or T2.\n\nSuppose some bettor wants to make some bet:\n\n* Either both coins are heads (H1 && H2), or both coins are tails (T1 && T2).\n\nSo we have a Bettor, and a Bookie that facilitates this bet.\n\nSo the base logic is that the bettor wins (i.e. there is a payment Bookie->Bettor) if:\n\n    (H1 && H2) || (T1 && T2)\n\nAnd the inverse of that logic (Better->Bookie) if the above is false.\n\nWe also know that `T1 = !H1` and `T2 = !H2` (i.e. the DLC oracles will only publish one scalar or the other), so:\n\n    (H1 && H2) || (!H1 && !H2)\n\nLet us transform to product-of-sums (this can be done by computers by using a Karnaugh Map):\n\n    (H1 || !H2) && (!H1 || H2)\n\nLet us check by Boolean table:\n\n    H1   H2    (H1 && H2) || (!H2 && !H2)       (H1 || !H2) && (!H1 || H2)\n    0    0     1                                1\n    0    1     0                                0\n    1    0     0                                0\n    1    1     1                                1\n\nSo the above product-of-sums is correct.\n\nWe apply the De Morgan transform:\n\n    !(!H1 && H2) && !(H1 && !H2)\n\nThen we return the `T`s:\n\n    !(T1 && H2) && !(H1 && T2)\n\nSince the logic is inverted, what actually happens is that the Bettor makes two payments:\n\n* Bettor->Bookie : (Bookie && T1 && H2)\n* Bettor->Bookie : (Bookie && H1 && T2)\n\nThe Bookie would also need to pay out if the Bettor wins, so the Bookie makes two payments as well:\n\n* Bookie->Bettor : (Bettor && T1 && T2)\n* Bookie->Bettor : (Bettor && H1 && H2)\n\nWe can derive the above by inverting the initial `(H1 && H2) || (!H1 && !H2)` logic, then going through the same conversion to product-of-sums and De Morganizing it as for the Bettor case.\n\nWith the above, we now have a setup where either both oracles are heads, or both oracles are tails, and if so the Bettor wins, otherwise the Bookie wins.\nThis all probably needs to be set up with some kind of Barrier Escrow, but Nadav already has that covered.\n\nHere is a cute magical trick.\nWhat happens if for example oracle 1 has a failure where the CPU liquid cooler on its server fails, and oracle 1 is unable to find a replacement CPU cooler because the CPU socket has been obsoleted and nobody makes CPU coolers for that CPU socket anymore and the server cannot be brought up again?\nIn that case, it will be unable to publish either `H1` or `T1`.\n\nAnd note that all the payments above involve `H1` or `T1`.\nIn that case, nobody pays out to anyone, as none of the payments are ever claimable.\nThus the case where \"oracle disappears\" is handled \"gracefully\" by simply not having any monetary transfers at all.\nThis seems to be a reasonable \"fail safe\" default to have when one of the oracles disappears without publishing the result of the coin toss.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-13T07:54:30",
                "message_text_only": "Good morning Nadav, and list,\n\n\n>\n> More generally, all Boolean logic can be converted to one of two standard forms.\n>\n> -   sum-of-products i.e. `||` over `&&`\n> -   product-of-sums i.e. `&&` over `||`\n>\n>     For example an XOR can be converted to the sum-of-products form:\n>\n>     A ^ B = (!A && B) || (A && !B)\n>\n>     If we have any complicated Boolean logic, we can consider to always use some kind of product-of-sums form.\n>     So for the example case, escrow service is the logic:\n>\n>     SELLER && (BUYER || ESCROW)\n>\n>     The above is a standard product-of-sums form.\n>\n>     Any sums (i.e. `||`) can be converted by De Morgan Theorem to product, and the payment can be a reversal instead.\n>\n>     SELLER && !(!BUYER && !ESCROW)\n>\n>     The `!(a && b && ...)` can be converted to a reversal of the payment.\n>     The individual `!BUYER` is just the buyer choosing not to claim the seller->buyer direction, and the individual `!ESCROW` is just the escrow choosing not to reveal its temporary scalar for this payment.\n>\n>\n> And any products (i.e. `&&`) are trivially implemented in PTLCs as trivial scalar and point addition.\n>\n> So it may actually be possible to express any Boolean logic, by the use of reversal payments and \"option not to release scalar\", both of which implement the NOT gate needed for the above.\n> Boolean logic is a fairly powerful, non-Turing-complete, and consistent programming language, and if we can actually implement any kind of Boolean logic with a set of payments in various directions and Barrier Escrows we can enable some fairly complex use-cases..\n>\n> For example, a simple DLC binary oracle can provide two points in such a way that it can only reveal one scalar of those two points (e.g. it has a persistent public key `P`, and two temporary points `H` and `T` such that `H = T + P`, and it can only safely reveal either `h` or `t`.).\n> Based on the outcome of a coin flip (or other input from the mythical \"real world\"), it reveals either one or the other scalar.\n> Then we can use either point as part of any `!Oracle` or `Oracle` Boolean logic we need.\n\n\n\nOkay, so here is a worked example.\n\nSuppose we have two oracles, 1 and 2.\nAt some point, they will flip coins in the future.\nBased on their (independent) coin flip, oracle 1 will reveal either H1 or T1, and oracle 2 will reveal either H2 or T2.\n\nSuppose some bettor wants to make some bet:\n\n* Either both coins are heads (H1 && H2), or both coins are tails (T1 && T2).\n\nSo we have a Bettor, and a Bookie that facilitates this bet.\n\nSo the base logic is that the bettor wins (i.e. there is a payment Bookie->Bettor) if:\n\n    (H1 && H2) || (T1 && T2)\n\nAnd the inverse of that logic (Better->Bookie) if the above is false.\n\nWe also know that `T1 = !H1` and `T2 = !H2` (i.e. the DLC oracles will only publish one scalar or the other), so:\n\n    (H1 && H2) || (!H1 && !H2)\n\nLet us transform to product-of-sums (this can be done by computers by using a Karnaugh Map):\n\n    (H1 || !H2) && (!H1 || H2)\n\nLet us check by Boolean table:\n\n    H1   H2    (H1 && H2) || (!H2 && !H2)       (H1 || !H2) && (!H1 || H2)\n    0    0     1                                1\n    0    1     0                                0\n    1    0     0                                0\n    1    1     1                                1\n\nSo the above product-of-sums is correct.\n\nWe apply the De Morgan transform:\n\n    !(!H1 && H2) && !(H1 && !H2)\n\nThen we return the `T`s:\n\n    !(T1 && H2) && !(H1 && T2)\n\nSince the logic is inverted, what actually happens is that the Bettor makes two payments:\n\n* Bettor->Bookie : (Bookie && T1 && H2)\n* Bettor->Bookie : (Bookie && H1 && T2)\n\nThe Bookie would also need to pay out if the Bettor wins, so the Bookie makes two payments as well:\n\n* Bookie->Bettor : (Bettor && T1 && T2)\n* Bookie->Bettor : (Bettor && H1 && H2)\n\nWe can derive the above by inverting the initial `(H1 && H2) || (!H1 && !H2)` logic, then going through the same conversion to product-of-sums and De Morganizing it as for the Bettor case.\n\nWith the above, we now have a setup where either both oracles are heads, or both oracles are tails, and if so the Bettor wins, otherwise the Bookie wins.\nThis all probably needs to be set up with some kind of Barrier Escrow, but Nadav already has that covered.\n\nHere is a cute magical trick.\nWhat happens if for example oracle 1 has a failure where the CPU liquid cooler on its server fails, and oracle 1 is unable to find a replacement CPU cooler because the CPU socket has been obsoleted and nobody makes CPU coolers for that CPU socket anymore and the server cannot be brought up again?\nIn that case, it will be unable to publish either `H1` or `T1`.\n\nAnd note that all the payments above involve `H1` or `T1`.\nIn that case, nobody pays out to anyone, as none of the payments are ever claimable.\nThus the case where \"oracle disappears\" is handled \"gracefully\" by simply not having any monetary transfers at all.\nThis seems to be a reasonable \"fail safe\" default to have when one of the oracles disappears without publishing the result of the coin toss.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Christian Decker",
                "date": "2021-02-27T10:02:29",
                "message_text_only": "> The `!(a && b && ...)` can be converted to a reversal of the payment.\n> The individual `!BUYER` is just the buyer choosing not to claim the\n> seller->buyer direction, and the individual `!ESCROW` is just the\n> escrow choosing not to reveal its temporary scalar for this payment.\n> And any products (i.e. `&&`) are trivially implemented in PTLCs as\n> trivial scalar and point addition.\n>\n> So it may actually be possible to express *any* Boolean logic, by the\n> use of reversal payments and \"option not to release scalar\", both of\n> which implement the NOT gate needed for the above.  Boolean logic is a\n> fairly powerful, non-Turing-complete, and consistent programming\n> language, and if we can actually implement any kind of Boolean logic\n> with a set of payments in various directions and Barrier Escrows we\n> can enable some fairly complex use-cases..\n\nThis got me thinking about my first year logic course and functional\ncompleteness [1], and it it trivial to prove that any boolean logic can\nbe expressed by this construction. We can trivially build a functionally\ncomplete set by just constructing a NAND, a NOR, or {AND, NOT}, all of\nwhich you've already done in your prior mails.\n\nThe resulting expressions may not be particularly nice, and result in a\nmultitude of payments going back and forth between the participants to\nrepresent that logic, but it is possible. So the problem should now\nsimply be reduced to finding a minimal representation for a given\nexpression, which then minimizes the funds committed to a particular\ninstance of the expression.\n\nCheers,\nChristian\n\n[1] https://en.wikipedia.org/wiki/Functional_completeness"
            },
            {
                "author": "Nadav Kohen",
                "date": "2021-02-27T11:05:14",
                "message_text_only": "Hey Christian,\n\nLove this chain of thought! Back before I'd realized as ZmnSCPxj did that\nwe have a nice general NOT operation for a given point, I had a similar\nthought on this thread\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-October/002213.html\nwhere we eventually figured out that verifiable encryption kind of yields a\nnice OR operation (where addition gives a nice AND).\n\nI would like to note a couple of unsolved things/limitations on this front\nthough. The current NOT operation actually isn't composable meaning If I\nhave P_1 and P_2 we know how to construct !(P_1 AND P_2) but I don't\nbelieve we know how to do (P_1 AND !P_2). This is because NOT P is\nessentially an unconditional payment atomic with a reverse \"cancellation\"\npayment using P as its payment point.\n\nLooking more closely at ZmnSCPxj's proposal for escrow contracts which we\nwere previously thinking of as (Seller AND (Buyer OR Escrow)) I believe is\nactually essentially just a payment to the Seller using the point !(Buyer\nAND Escrow) as opposed to some actually compiled version of (Seller AND\n(Buyer OR Escrow)).\n\nAll of this said, I think it would be super awesome if someone thought of a\nway to construct some kind of negation operation which is composable in the\nsense that we can do (A AND NOT B) and/or (A OR NOT B) or the like!\n\nBest,\nNadav\n\nOn Sat, Feb 27, 2021 at 4:02 AM Christian Decker <decker.christian at gmail.com>\nwrote:\n\n> > The `!(a && b && ...)` can be converted to a reversal of the payment.\n> > The individual `!BUYER` is just the buyer choosing not to claim the\n> > seller->buyer direction, and the individual `!ESCROW` is just the\n> > escrow choosing not to reveal its temporary scalar for this payment.\n> > And any products (i.e. `&&`) are trivially implemented in PTLCs as\n> > trivial scalar and point addition.\n> >\n> > So it may actually be possible to express *any* Boolean logic, by the\n> > use of reversal payments and \"option not to release scalar\", both of\n> > which implement the NOT gate needed for the above.  Boolean logic is a\n> > fairly powerful, non-Turing-complete, and consistent programming\n> > language, and if we can actually implement any kind of Boolean logic\n> > with a set of payments in various directions and Barrier Escrows we\n> > can enable some fairly complex use-cases..\n>\n> This got me thinking about my first year logic course and functional\n> completeness [1], and it it trivial to prove that any boolean logic can\n> be expressed by this construction. We can trivially build a functionally\n> complete set by just constructing a NAND, a NOR, or {AND, NOT}, all of\n> which you've already done in your prior mails.\n>\n> The resulting expressions may not be particularly nice, and result in a\n> multitude of payments going back and forth between the participants to\n> represent that logic, but it is possible. So the problem should now\n> simply be reduced to finding a minimal representation for a given\n> expression, which then minimizes the funds committed to a particular\n> instance of the expression.\n>\n> Cheers,\n> Christian\n>\n> [1] https://en.wikipedia.org/wiki/Functional_completeness\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210227/49154487/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Escrow Over Lightning?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Andr\u00e9s G. Aragoneses",
                "Nadav Kohen",
                "Pedro Moreno-Sanchez",
                "ZmnSCPxj"
            ],
            "messages_count": 19,
            "total_messages_chars_count": 57763
        }
    },
    {
        "title": "[Lightning-dev] Hold fee rates as DoS protection (channel spamming and jamming)",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2021-02-11T14:28:14",
                "message_text_only": "Hi all,\n\nThings have been quiet around channel jamming lately, but the vulnerability\nit still there as much as it was before. I've participated in an (isolated)\nmainnet channel jamming experiment (\nhttps://bitcoinmagazine.com/articles/good-griefing-a-lingering-vulnerability-on-lightning-network-that-still-needs-fixing)\nwhich only confirmed the seriousness of the issue.\n\nBIDIRECTIONAL UPFRONT PAYMENT\n\nOf all the proposals that have been presented, t-bast's remix of forward\nand backward upfront payments (\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002862.html\n,\nhttps://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md#bidirectional-upfront-payment)\nindicates in my opinion the most promising direction.\n\nOne characteristic of the proposal is that the `hold_fees` are\ntime-independent. If an htlc doesn't resolve within the `grace_period`, the\nreceiver of the htlc will be forced to pay the full hold fee. The hold fee\nshould cover the expenses for locking up an htlc for the maximum duration\n(could be 2000 blocks), so this can be a significant penalty. Applications\nsuch as atomic onchain/offchain swaps (Lightning Loop and others) rely on\nlocking funds for some time and could get expensive with a fixed hold fee.\n\nHOLD FEE RATE\n\nIn this post I'd like to present a variation of bidirectional upfront\npayments that uses a time-proportional hold fee rate to address the\nlimitation above. I also tried to come up with a system that aims to relate\nthe fees paid more directly to the actual costs incurred and thereby reduce\nthe number of parameters.\n\nIn a Lightning channel, the sender of an htlc always incurs the cost. The\nhtlc value is deduced from their balance and the money can't be used for\nother purposes when the htlc is in flight. Therefore ideally a routing node\nis compensated for the time that their outgoing htlc is in flight.\n\nTo communicate this cost to the outside world, routing nodes advertise a\n`hold_fee_rate` as part of their channel forwarding policy. An example\nwould be \"0.3 msat per sat per minute\". So if someone wants to forward 10k\nsat through that channel and the htlc remains in flight for 5 minutes, the\nrouting node would like to see a compensation of 0.3msat * 10k sat * 5 mins\n= 15 sat. (it is possible to extend the model with a base fee rate to also\ncover the cost of an occupied slot on the commitment tx)\n\nThe question here again is who is going to pay the hold fee. The answer is\nthat it is primarily the receiver of the htlc who is going to pay. They are\nthe ones that can fail or settle the htlc and are therefore in control of\nthe hold time (\"Reverse upfront payment\")\n\nBut this would also mean that anyone can send out an htlc and collect hold\nfees unconditionally. Therefore routing nodes advertise on the network\ntheir `hold_grace_period`. When routing nodes accept an htlc to forward,\nthey're willing to pay hold fees for it. But only if they added a delay\ngreater than `hold_grace_period` for relaying the payment and its response.\nIf they relayed in a timely fashion, they expect the sender of the htlc to\ncover those costs themselves. If the sender is also a routing node, the\nsender should expect the node before them to cover it. Of course, routing\nnodes can't be trusted. So in practice we can just as well assume that\nthey'll always try to claim from the prior node the maximum amount in\ncompensation.\n\nThis is the basic idea. Routing nodes have real costs for the lock up of\ntheir money and will be compensated for it.\n\nTo coordinate the payment of the fees, the `update_add_htlc` message is\nextended with:\n* `hold_fee_rate`: the fee rate that the sender charges for having the htlc\nin-flight (msat per sat per min)\n* `hold_fee_discount`: the absolute fee discount (sat) that the receiver\ngets as a compensation for hold fees that couldn't be claimed downstream\nbecause of the grace periods (the worst case amount).\n(the previous `hold_grace_period` in `update_add_htlc` is no longer needed)\n\nWhen an htlc is resolved, the receiver of the htlc will pay the sender the\n`hold_fee_rate` minus `hold_fee_discount` (exact details of how to\nintegrate this into the channel state machine and deal with clock shift\ntbd).\n\nIt is up to the sender of a payment to construct the onion payloads such\nthat all nodes along the route will have their costs covered.\n\nEXAMPLE\n\nA ----> B ----> C ----> D\nEvery node charges 0.6 msat/sat/minute with a hold grace period of 1\nminute. In this example, the routing fees are zero.\nA wants to send 1000 sat to D.\n\nA will charge B a hold fee rate of 0.6 sat/min (1000 sat at 0.6\nmsat/sat/min). B will charge C a hold fee rate of 1.2 sat/min to cover both\nits own cost and what must be paid back to A. C will charge D a hold fee\nrate of 1.8 sat/min to cover the costs of A, B and C.\n\nD has a grace period of 1 minute. At the 1.8 sat/min fee rate that C\ncharges, D would need to pay a maximum of 1.8 sat if it meets its grace\ndeadline just in time. C pays the 1.8 sats to D as a discount on its hold\nfee (assuming D will settle right before the deadline anyway).\n\nC also has a grace period of 1 minute. But because D has a grace period\ntoo, it could be that C needs to hold on to the htlc for a total of 2\nminutes. At the 1.2 sat/min fee rate B charges, C would need to pay a\nmaximum of 2.4 sats, plus the hold fee that it needs to pay to D (1.8\nsats). Therefore B gives C a hold fee discount of 2.4+1.8 = 4.2 sats.\n\nThe same logic applies to A and B. A offers a hold fee discount of 0.6 * 3\nmin + 4.2 = 6 sats to cover the worst case cost of B, C and D.\n\nIf A is just spamming/probing, it will cost hem 6 sats per htlc. If D is\ntrying to channel-jam by hodling htlcs, it will cost them 1.8 sat/min. If\nan intermediate hop is delaying the payment, they will pay at least 0.6\nsat/min (depending on the position in the route).\n\nIn the happy flow, A is still paying 6 sat per payment attempt which is\nused to compensate B, C and D for the short unavailability of their funds.\nTo me, this seems only fair.\n\nCONCLUSION\n\nEven though the proposal above is not fundamentally different from what was\nknown already, I do think that it adds the flexibility that we need to not\ntake a step back in terms of functionality (fair pricing for hodl invoices\nand its applications). Plus that it simplifies the parameter set.\n\nThoughts?\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210211/491e64e5/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-11T14:53:06",
                "message_text_only": "Good morning Joost,\n\nNot quite up-to-speed back into this, but, I believe an issue with using feerates rather than fixed fees is \"what happens if a channel is forced onchain\"?\n\nSuppose after C offers the HTLC to D, the C-D channel, for any reason, is forced onchain, and the blockchain is bloated and the transaction remains floating in mempools until very close to the timeout of C-D.\nC is now liable for a large time the payment is held, and because the C-D channel was dropped onchain, presumably any parameters of the HTLC (including penalties D owes to C) have gotten fixed at the time the channel was dropped onchain.\n\nThe simplicity of the fixed fee is that it bounds the amount of risk that C has in case its outgoing channel is dropped onchain.\n\nRegards,\nZmnSCPxj\n\n\n> Hi all,\n>\n> Things have been quiet around channel jamming lately, but the vulnerability it still there as much as it was before. I've participated in an (isolated) mainnet channel jamming experiment (https://bitcoinmagazine.com/articles/good-griefing-a-lingering-vulnerability-on-lightning-network-that-still-needs-fixing) which only confirmed the seriousness of the issue.\n>\n> BIDIRECTIONAL UPFRONT PAYMENT\n>\n> Of all the proposals that have been presented, t-bast's remix of forward and backward upfront payments (https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002862.html,\u00a0https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md#bidirectional-upfront-payment) indicates in my opinion the most promising direction.\n>\n> One characteristic of the proposal is that the `hold_fees` are time-independent. If an htlc doesn't resolve within the `grace_period`, the receiver of the htlc will be forced to pay the full hold fee. The hold fee should cover the expenses for locking up an htlc for the maximum duration (could be 2000 blocks), so this can be a significant penalty. Applications such as atomic onchain/offchain swaps (Lightning Loop and others) rely on locking funds for some time and could get expensive with a fixed hold fee.\n>\n> HOLD FEE RATE\n>\n> In this post I'd like to present a variation of bidirectional upfront payments that uses a time-proportional hold fee rate to address the limitation above. I also tried to come up with a system that aims to relate the fees paid more directly to the actual costs incurred and thereby reduce the number of parameters.\n>\n> In a Lightning channel, the sender of an htlc always incurs the cost. The htlc value is deduced from their balance and the money can't be used for other purposes when the htlc is in flight. Therefore ideally a routing node is compensated for the time that their outgoing htlc is in flight.\n>\n> To communicate this cost to the outside world, routing nodes advertise a `hold_fee_rate` as part of their channel forwarding policy. An example would be \"0.3 msat per sat per minute\". So if someone wants to forward 10k sat through that channel and the htlc remains in flight for 5 minutes, the routing node would like to see a compensation of 0.3msat * 10k sat * 5 mins = 15 sat. (it is possible to extend the model with a base fee rate to also cover the cost of an occupied slot on the commitment tx)\n>\n> The question here again is who is going to pay the hold fee. The answer is that it is primarily the receiver of the htlc who is going to pay. They are the ones that can fail or settle the htlc and are therefore in control of the hold time (\"Reverse upfront payment\")\n>\n> But this would also mean that anyone can send out an htlc and collect hold fees unconditionally. Therefore routing nodes advertise on the network their `hold_grace_period`. When routing nodes accept an htlc to forward, they're willing to pay hold fees for it. But only if they added a delay greater than `hold_grace_period` for relaying the payment and its response. If they relayed in a timely fashion, they expect the sender of the htlc to cover those costs themselves. If the sender is also a routing node, the sender should expect the node before them to cover it. Of course, routing nodes can't be trusted. So in practice we can just as well assume that they'll always try to claim from the prior node the maximum amount in compensation.\u00a0\n>\n> This is the basic idea. Routing nodes have real costs for the lock up of their money and will be compensated for it.\n>\n> To coordinate the payment of the fees, the `update_add_htlc` message is extended with:\n> * `hold_fee_rate`: the fee rate that the sender charges for having the htlc in-flight (msat per sat per min)\n> * `hold_fee_discount`: the absolute fee discount (sat) that the receiver gets as a compensation for hold fees that couldn't be claimed downstream because of the grace periods (the worst case amount).\n> (the previous `hold_grace_period` in `update_add_htlc` is no longer needed)\n>\n> When an htlc is resolved, the receiver of the htlc will pay the sender the `hold_fee_rate` minus `hold_fee_discount` (exact details of how to integrate this into the channel state machine and deal with clock shift tbd).\n>\n> It is up to the sender of a payment to construct the onion payloads such that all nodes along the route will have their costs covered.\n>\n> EXAMPLE\n>\n> A ----> B ----> C ----> D\n> Every node charges 0.6 msat/sat/minute with a hold grace period of 1 minute. In this example, the routing fees are zero.\n> A wants to send 1000 sat to D.\n>\n> A will charge B a hold fee rate of 0.6 sat/min (1000 sat at 0.6 msat/sat/min). B will charge C a hold fee rate of 1.2 sat/min to cover both its own cost and what must be paid back to A. C will charge D a hold fee rate of 1.8 sat/min to cover the costs of A, B and C.\n>\n> D has a grace period of 1 minute. At the 1.8 sat/min fee rate that C charges, D would need to pay a maximum of 1.8 sat if it meets its grace deadline just in time. C pays the 1.8 sats to D as a discount on its hold fee (assuming D will settle right before the deadline anyway).\n>\n> C also has a grace period of 1 minute. But because D has a grace period too, it could be that C needs to hold on to the htlc for a total of 2 minutes. At the 1.2 sat/min fee rate B charges, C would need to pay a maximum of 2.4 sats, plus the hold fee that it needs to pay to D (1.8 sats). Therefore B gives C a hold fee discount of 2.4+1.8 = 4.2 sats.\n>\n> The same logic applies to A and B. A offers a hold fee discount of 0.6 * 3 min + 4.2 = 6 sats to cover the worst case cost of B, C and D.\n>\n> If A is just spamming/probing, it will cost hem 6 sats per htlc. If D is trying to channel-jam by hodling htlcs, it will cost them 1.8 sat/min. If an intermediate hop is delaying the payment, they will pay at least 0.6 sat/min (depending on the position in the route).\n>\n> In the happy flow, A is still paying 6 sat per payment attempt which is used to compensate B, C and D for the short unavailability of their funds. To me, this seems only fair.\u00a0\n>\n> CONCLUSION\n>\n> Even though the proposal above is not fundamentally different from what was known already, I do think that it adds the flexibility that we need to not take a step back in terms of functionality (fair pricing for hodl invoices and its applications). Plus that it simplifies the parameter set.\n>\n> Thoughts?\u00a0\n>\n> Joost"
            },
            {
                "author": "Joost Jager",
                "date": "2021-02-11T15:24:05",
                "message_text_only": "Hi ZmnSCPxj,\n\nNot quite up-to-speed back into this, but, I believe an issue with using\n> feerates rather than fixed fees is \"what happens if a channel is forced\n> onchain\"?\n>\n> Suppose after C offers the HTLC to D, the C-D channel, for any reason, is\n> forced onchain, and the blockchain is bloated and the transaction remains\n> floating in mempools until very close to the timeout of C-D.\n> C is now liable for a large time the payment is held, and because the C-D\n> channel was dropped onchain, presumably any parameters of the HTLC\n> (including penalties D owes to C) have gotten fixed at the time the channel\n> was dropped onchain.\n>\n\nThe simplicity of the fixed fee is that it bounds the amount of risk that C\n> has in case its outgoing channel is dropped onchain.\n>\n\nThe risk is bound in both cases. If you want you can cap the variable fee\nat a level that isn't considered risky, but it will then not fully cover\nthe actual cost of the locked-up htlc. Also any anti-DoS fee could very\nwell turn out to be insignificant to the cost of closing and reopening a\nchannel with the state of the mempool these days.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210211/9a7280c9/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-02-12T13:29:11",
                "message_text_only": "Hi Joost,\n\nThanks for working on this and keeping raising awareness about channel\njamming.\n\n> In this post I'd like to present a variation of bidirectional upfront\npayments that uses a time-proportional hold fee rate to address the\nlimitation above. I also tried to come up with a system that aims > relate\nthe fees paid more directly to the actual costs incurred and thereby reduce\nthe number of parameters.\n\nNot considering hold invoices and other long-term held packets was one of\nmy main concerns in the previous bidirectional upfront payments. This new\n\"hodl_fee_rate\" is better by binding the hold fee to the effectively\nconsumed timelocked period of the liquidity and not its potential maximum.\n\nThat said, routing nodes might still include the risk of hitting the chain\nin the computation of their `hodl_fee_rate` and the corresponding cost of\nhaving onchain timelocked funds. Given that HTLC deltas are decreasing\nalong the path, it's more likely that `hodl_fee_rate` will be decreasing\nalong the path. Even in case of lawfully solved hodl HTLC, routing nodes\nmight be at loss for having paid a higher hold_fee on their upstream link\nthan received on the downstream one.\n\nIs assuming increasing `hodl_fee_rate` along a payment path at odds with\nthe ordering of timelocks ?\n\n> But this would also mean that anyone can send out an htlc and collect\nhold fees unconditionally. Therefore routing nodes advertise on the network\ntheir `hold_grace_period`. When routing nodes accept an htl> to forward,\nthey're willing to pay hold fees for it. But only if they added a delay\ngreater than `hold_grace_period` for relaying the payment and its response.\nIf they relayed in a timely fashion, they exp> ect the sender of the htlc\nto cover those costs themselves. If the sender is also a routing node, the\nsender should expect the node before them to cover it. Of course, routing\nnodes can't be trusted. So in> practice we can just as well assume that\nthey'll always try to claim from the prior node the maximum amount in\ncompensation.\n\nAssuming `hodl_fee_rate` are near-similar along the payment path, you have\na concern when the HTLC settlement happens at period N on the outgoing link\nand at period N+1 on the incoming link due to clock differences. In this\ncase, a routing node will pay a higher `hodl_fee_rate` than received.\n\nI think this is okay, that's an edge case, only leaking a few sats.\n\nA more concerning one is when the HTLC settlement happens at period N on\nthe outgoing link and your incoming counterparty goes offline. According to\nthe HTLC relay contract, the `hodl_fee_rate` will be inflated until the\ncounterparty goes back online and thus the routing node is at loss. And\ngoing offline is a really lawful behavior for mobile clients, even further\nif you consider mailbox-style of HTLC delivery (e.g Lightning Rod). You\ncan't simply label such counterparty as malicious.\n\nAnd I don't think counterparties can trust themselves about their onliness\nto suspend the `hodl_fee_rate` inflation. Both sides have an interest to\nequivocate, the HTLC sender to gain a higher fee, the HTLC relayer to save\nthe fee while having received one on the incoming link ?\n\n> Even though the proposal above is not fundamentally different from what\nwas known already, I do think that it adds the flexibility that we need to\nnot take a step back in terms of functionality (fair prici> ng for hodl\ninvoices and its applications). Plus that it simplifies the parameter set.\n\nMinding the concerns raised above, I think this proposal is an improvement\nand would merit a specification draft, at least to ease further reasoning\non its economic and security soundness. As a side-note, we're working\nfurther on Stake Certificates, which I believe is better for long-term\nnetwork economics by not adding a new fee burden on payments. We should be\ncareful to not economically outlaw micropayments. If we think channel\njamming is concerning enough in the short-term, we can deploy a\nbidirectional upfront payment-style of proposal now and consider a better\nsolution when it's technically mature.\n\n\nAntoine\n\nLe jeu. 11 f\u00e9vr. 2021 \u00e0 10:25, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> Hi ZmnSCPxj,\n>\n> Not quite up-to-speed back into this, but, I believe an issue with using\n>> feerates rather than fixed fees is \"what happens if a channel is forced\n>> onchain\"?\n>>\n>> Suppose after C offers the HTLC to D, the C-D channel, for any reason, is\n>> forced onchain, and the blockchain is bloated and the transaction remains\n>> floating in mempools until very close to the timeout of C-D.\n>> C is now liable for a large time the payment is held, and because the C-D\n>> channel was dropped onchain, presumably any parameters of the HTLC\n>> (including penalties D owes to C) have gotten fixed at the time the channel\n>> was dropped onchain.\n>>\n>\n> The simplicity of the fixed fee is that it bounds the amount of risk that\n>> C has in case its outgoing channel is dropped onchain.\n>>\n>\n> The risk is bound in both cases. If you want you can cap the variable fee\n> at a level that isn't considered risky, but it will then not fully cover\n> the actual cost of the locked-up htlc. Also any anti-DoS fee could very\n> well turn out to be insignificant to the cost of closing and reopening a\n> channel with the state of the mempool these days.\n>\n> Joost\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210212/846ce794/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-02-12T20:15:50",
                "message_text_only": "Hi Antoine,\n\nThat said, routing nodes might still include the risk of hitting the chain\n> in the computation of their `hodl_fee_rate` and the corresponding cost of\n> having onchain timelocked funds.\n>\n\nYes, that could be another reason to define `hodl_fee_rate` as a base fee\nrate plus a component that is proportional to the amount. As mentioned in\nmy initial email, the base fee can be used to cover the cost of occupying\nan htlc slot (which can be a significant factor for a large wumbo channel).\nThe risk of hitting the chain that you mention can be factored into this\nbase part as well. The hold fee rate would then be defined in the form (2\nsat + 1%) per minute.\n\n\n> Given that HTLC deltas are decreasing along the path, it's more likely\n> that `hodl_fee_rate` will be decreasing along the path. Even in case of\n> lawfully solved hodl HTLC, routing nodes might be at loss for having paid a\n> higher hold_fee on their upstream link than received on the downstream one.\n>\n\n> Is assuming increasing `hodl_fee_rate` along a payment path at odds with\n> the ordering of timelocks ?\n>\n\nI don't think it is. There is indeed a time lock delta in case htlcs need\nto be settled on-chain. But in the happy offchain scenario, the added (wall\nclock) delay of a hop is tiny. So yes, they get paid from downstream a few\nseconds less in hold fees than what they need to pay upstream, but I think\nthis is insignificant compared to the total compensation that they are\ngetting (which is based on the grace period that is advertised). To be\nclear, for the calculation of the hold fee, it is the wall clock time that\nis used and not the block height.\n\n\n> > But this would also mean that anyone can send out an htlc and collect\n> hold fees unconditionally. Therefore routing nodes advertise on the network\n> their `hold_grace_period`. When routing nodes accept an htl> to forward,\n> they're willing to pay hold fees for it. But only if they added a delay\n> greater than `hold_grace_period` for relaying the payment and its response.\n> If they relayed in a timely fashion, they exp> ect the sender of the htlc\n> to cover those costs themselves. If the sender is also a routing node, the\n> sender should expect the node before them to cover it. Of course, routing\n> nodes can't be trusted. So in> practice we can just as well assume that\n> they'll always try to claim from the prior node the maximum amount in\n> compensation.\n>\n> Assuming `hodl_fee_rate` are near-similar along the payment path, you have\n> a concern when the HTLC settlement happens at period N on the outgoing link\n> and at period N+1 on the incoming link due to clock differences. In this\n> case, a routing node will pay a higher `hodl_fee_rate` than received.\n>\n> I think this is okay, that's an edge case, only leaking a few sats.\n>\n\nIs this the same concern as above or slightly different? Or do you mean\nclock differences between the endpoints of a channel? For that, I'd think\nthat there needs to be some tolerance to smooth out disagreements. But yes,\nin general as long as a node is getting a positive amount, it is probably\nokay to tolerate a few rounding errors here and there.\n\n\n> A more concerning one is when the HTLC settlement happens at period N on\n> the outgoing link and your incoming counterparty goes offline. According to\n> the HTLC relay contract, the `hodl_fee_rate` will be inflated until the\n> counterparty goes back online and thus the routing node is at loss. And\n> going offline is a really lawful behavior for mobile clients, even further\n> if you consider mailbox-style of HTLC delivery (e.g Lightning Rod). You\n> can't simply label such counterparty as malicious.\n>\n\n\n> And I don't think counterparties can trust themselves about their onliness\n> to suspend the `hodl_fee_rate` inflation. Both sides have an interest to\n> equivocate, the HTLC sender to gain a higher fee, the HTLC relayer to save\n> the fee while having received one on the incoming link ?\n>\n\nYes, that is a good point. But I do think that it is reasonable that a node\nthat can go offline doesn't charge a hodl fee. Those nodes aren't generally\nforwarding htlcs anyway, so it would just be for their own outgoing\npayments. Without charging a hodl fee for outgoing payments, they risk that\ntheir channel peer delays the htlc for free. So they should choose their\npeers carefully. It seems that at the moment mobile nodes are often\nconnected to a known LSP already, so this may not be a real problem. The\npolicies for a channel can be asymmetric with the mobile node not charging\nhold fees for its outgoing htlcs to the LSP, while the LSP does charge hold\nfees for htlcs that its forwards to the mobile node.\n\nFor the mailbox scenario, I think it is fair that someone is going to pay\nfor all those locked htlcs along the route. If the LSP decides to hold the\nhtlc until the destination comes online, they need to find a way to get the\nmailbox bill paid.\n\nAll of this indeed also implies that nodes that do charge hold fees, need\nto make sure to stay online. Otherwise peers may close channels with them\nbecause they are unreliable and charging for their own outage.\n\n\n> > Even though the proposal above is not fundamentally different from what\n> was known already, I do think that it adds the flexibility that we need to\n> not take a step back in terms of functionality (fair prici> ng for hodl\n> invoices and its applications). Plus that it simplifies the parameter set.\n>\n> Minding the concerns raised above, I think this proposal is an improvement\n> and would merit a specification draft, at least to ease further reasoning\n> on its economic and security soundness. As a side-note, we're working\n> further on Stake Certificates, which I believe is better for long-term\n> network economics by not adding a new fee burden on payments. We should be\n> careful to not economically outlaw micropayments.\n>\n\nYes, we should be careful not to outlaw micropayments. But I don't think\nthe hold fees as described above do this. Because the fees are modeled as\nclose to the real costs as possible, it can only be fair? Tiny amounts that\nsettle quickly should need only very small hold fees. But if the tiny\namount gets stuck for a week and occupies an htlc slot in each of its 25\nhops through multi-btc wumbo channels, yes, than it should be costly?\n\n\n> If we think channel jamming is concerning enough in the short-term, we can\n> deploy a bidirectional upfront payment-style of proposal now and consider a\n> better solution when it's technically mature.\n>\n\nIt remains unclear how much time we still have to fix this. Already today\nthere are nodes on the network that benefit from short interruptions of\nlarge channel sets between the bigger nodes. During those interruptions,\nthey provide a fallback route at a premium price. It is not difficult to\ncome up with actions that happen to make those disruptions more likely to\nhappen. I wouldn't take too many chances with this.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210212/835761e2/attachment-0001.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-02-14T18:05:08",
                "message_text_only": "I've made a first attempt at projecting this idea onto the existing spec:\nhttps://github.com/lightningnetwork/lightning-rfc/pull/843. This may also\nclarify some of the questions that haven't been answered yet.\n\nJoost\n\nOn Fri, Feb 12, 2021 at 2:29 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Joost,\n>\n> Thanks for working on this and keeping raising awareness about channel\n> jamming.\n>\n> > In this post I'd like to present a variation of bidirectional upfront\n> payments that uses a time-proportional hold fee rate to address the\n> limitation above. I also tried to come up with a system that aims > relate\n> the fees paid more directly to the actual costs incurred and thereby reduce\n> the number of parameters.\n>\n> Not considering hold invoices and other long-term held packets was one of\n> my main concerns in the previous bidirectional upfront payments. This new\n> \"hodl_fee_rate\" is better by binding the hold fee to the effectively\n> consumed timelocked period of the liquidity and not its potential maximum.\n>\n> That said, routing nodes might still include the risk of hitting the chain\n> in the computation of their `hodl_fee_rate` and the corresponding cost of\n> having onchain timelocked funds. Given that HTLC deltas are decreasing\n> along the path, it's more likely that `hodl_fee_rate` will be decreasing\n> along the path. Even in case of lawfully solved hodl HTLC, routing nodes\n> might be at loss for having paid a higher hold_fee on their upstream link\n> than received on the downstream one.\n>\n> Is assuming increasing `hodl_fee_rate` along a payment path at odds with\n> the ordering of timelocks ?\n>\n> > But this would also mean that anyone can send out an htlc and collect\n> hold fees unconditionally. Therefore routing nodes advertise on the network\n> their `hold_grace_period`. When routing nodes accept an htl> to forward,\n> they're willing to pay hold fees for it. But only if they added a delay\n> greater than `hold_grace_period` for relaying the payment and its response.\n> If they relayed in a timely fashion, they exp> ect the sender of the htlc\n> to cover those costs themselves. If the sender is also a routing node, the\n> sender should expect the node before them to cover it. Of course, routing\n> nodes can't be trusted. So in> practice we can just as well assume that\n> they'll always try to claim from the prior node the maximum amount in\n> compensation.\n>\n> Assuming `hodl_fee_rate` are near-similar along the payment path, you have\n> a concern when the HTLC settlement happens at period N on the outgoing link\n> and at period N+1 on the incoming link due to clock differences. In this\n> case, a routing node will pay a higher `hodl_fee_rate` than received.\n>\n> I think this is okay, that's an edge case, only leaking a few sats.\n>\n> A more concerning one is when the HTLC settlement happens at period N on\n> the outgoing link and your incoming counterparty goes offline. According to\n> the HTLC relay contract, the `hodl_fee_rate` will be inflated until the\n> counterparty goes back online and thus the routing node is at loss. And\n> going offline is a really lawful behavior for mobile clients, even further\n> if you consider mailbox-style of HTLC delivery (e.g Lightning Rod). You\n> can't simply label such counterparty as malicious.\n>\n> And I don't think counterparties can trust themselves about their onliness\n> to suspend the `hodl_fee_rate` inflation. Both sides have an interest to\n> equivocate, the HTLC sender to gain a higher fee, the HTLC relayer to save\n> the fee while having received one on the incoming link ?\n>\n> > Even though the proposal above is not fundamentally different from what\n> was known already, I do think that it adds the flexibility that we need to\n> not take a step back in terms of functionality (fair prici> ng for hodl\n> invoices and its applications). Plus that it simplifies the parameter set.\n>\n> Minding the concerns raised above, I think this proposal is an improvement\n> and would merit a specification draft, at least to ease further reasoning\n> on its economic and security soundness. As a side-note, we're working\n> further on Stake Certificates, which I believe is better for long-term\n> network economics by not adding a new fee burden on payments. We should be\n> careful to not economically outlaw micropayments. If we think channel\n> jamming is concerning enough in the short-term, we can deploy a\n> bidirectional upfront payment-style of proposal now and consider a better\n> solution when it's technically mature.\n>\n>\n> Antoine\n>\n> Le jeu. 11 f\u00e9vr. 2021 \u00e0 10:25, Joost Jager <joost.jager at gmail.com> a\n> \u00e9crit :\n>\n>> Hi ZmnSCPxj,\n>>\n>> Not quite up-to-speed back into this, but, I believe an issue with using\n>>> feerates rather than fixed fees is \"what happens if a channel is forced\n>>> onchain\"?\n>>>\n>>> Suppose after C offers the HTLC to D, the C-D channel, for any reason,\n>>> is forced onchain, and the blockchain is bloated and the transaction\n>>> remains floating in mempools until very close to the timeout of C-D.\n>>> C is now liable for a large time the payment is held, and because the\n>>> C-D channel was dropped onchain, presumably any parameters of the HTLC\n>>> (including penalties D owes to C) have gotten fixed at the time the channel\n>>> was dropped onchain.\n>>>\n>>\n>> The simplicity of the fixed fee is that it bounds the amount of risk that\n>>> C has in case its outgoing channel is dropped onchain.\n>>>\n>>\n>> The risk is bound in both cases. If you want you can cap the variable fee\n>> at a level that isn't considered risky, but it will then not fully cover\n>> the actual cost of the locked-up htlc. Also any anti-DoS fee could very\n>> well turn out to be insignificant to the cost of closing and reopening a\n>> channel with the state of the mempool these days.\n>>\n>> Joost\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210214/c9e283f4/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2021-02-15T13:56:45",
                "message_text_only": "> The risk of hitting the chain that you mention can be factored into this\n> base part as well. The hold fee rate would then be defined in the form (2\n> sat + 1%) per minute.\n\nI think this works if the base fee is paid at HTLC commitment lock-in.\nOtherwise, you're still exposed to the chain-hit risk, the channel might\nbreak at any time and the timevalues of the pending forward HTLC set will\nbe lost. Note, it's likely the hedge to be probabilistic as you won't make\nHTLC receivers pay for the effective timevalue but only a fragment computed\nfrom the expected outgoing HTLC traffic during channel lifetime.\n\nA smart channel relay policy will discount chain-hit risks for stable\nlinks, incentivizing your counterparties to be good peers.\n\n> Is this the same concern as above or slightly different? Or do you mean\n> clock differences between the endpoints of a channel? For that, I'd think\n> that there needs to be some tolerance to smooth out disagreements. But\nyes,\n> in general as long as a node is getting a positive amount, it is probably\n> okay to tolerate a few rounding errors here and there.\n\nThis is slightly different concern, HTLC settlement may happen at different\nwall clock time periods between downstream/upstream.\n\nLet's say a HTLC is relayed across Alice, Bob, Caroll. The HTLC is\nsuccessfully settled at N between Bob and Caroll, with N the number of\nminutes since htlc lock-in. Caroll pays N * `hold_fee_rate` to Bob. As\nupstream settlement isn't atomic, it happens at N+1. Bob pays N *\n`hold_fee_rate` to Alice. Bob loss 1 * `hold_fee_rate`.\n\nFor normal operations, I concede it should happen rarely enough for this\nbeing an edge-case.\n\n> Yes, that is a good point. But I do think that it is reasonable that a\nnode\n> that can go offline doesn't charge a hodl fee. Those nodes aren't\ngenerally\n> forwarding htlcs anyway, so it would just be for their own outgoing\n> payments. Without charging a hodl fee for outgoing payments, they risk\nthat\n> their channel peer delays the htlc for free. So they should choose their\n> peers carefully. It seems that at the moment mobile nodes are often\n> connected to a known LSP already, so this may not be a real problem.\n\nI think the reasoning holds for mobile clients not charging hold fees. Most\nof the time, your LSP doesn't have an interest to delay your HTLC, better\nto succeed/fail quickly to release the liquidity to potentially earn fees\non another payment. The only case might be when all the outgoing liquidity\nof your LSPs are already near-busy and they have to select between your\nHTLC to forward and the one from another spoke. Minding this, hold fees\ncharged by mobile clients might be a way to prioritize their payments.\n\n> All of this indeed also implies that nodes that do charge hold fees, need\n> to make sure to stay online. Otherwise peers may close channels with them\n> because they are unreliable and charging for their own outage.\n\nAnd this is the point where it becomes tricky. A malicious upstream node\nmimic offliness to inflate its due hold fee. Considering the long-term\nprotocol trend to pour the unilateral closing fee burden on the\ncounterparty deciding to go onchain, it won't be economical to do so if the\nextorted hold fees is inferior to channel closing onchain fees. So you\nmight have this cat-and-mouse game play many times until it's obvious for a\nchannel scoring logic that this peer is malicious and the channel must be\nclosed. In-between the accumulated hold fees might have been superior to\nthe cost of channel opening...\n\nI can really see a sophisticated attacker able to escape such channel\nblacklist heuristics.\n\n> Yes, we should be careful not to outlaw micropayments. But I don't think\n> the hold fees as described above do this. Because the fees are modeled as\n> close to the real costs as possible, it can only be fair? Tiny amounts\nthat\n> settle quickly should need only very small hold fees. But if the tiny\n> amount gets stuck for a week and occupies an htlc slot in each of its 25\n> hops through multi-btc wumbo channels, yes, than it should be costly?\n\nI agree that any packet which holds liquidity for a while should cover slot\ncosts and timevalue, even if the value transferred is in fine inferior to\nthe final hold fees. In that case, it should be up to the original sender\nto arbitrate between its expected traffic and the opportunity to open a\nchannel to shorten its payment paths.\n\nStill, a \"very small hold fees\" might scope a lot of use-cases, which are\nhard to care about because they might not exist yet. Compared to leveraging\na resource (channel UTXOs) which is already assumed to be owned by\nLightning users.\n\nLe dim. 14 f\u00e9vr. 2021 \u00e0 13:05, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> I've made a first attempt at projecting this idea onto the existing spec:\n> https://github.com/lightningnetwork/lightning-rfc/pull/843. This may also\n> clarify some of the questions that haven't been answered yet.\n>\n> Joost\n>\n> On Fri, Feb 12, 2021 at 2:29 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi Joost,\n>>\n>> Thanks for working on this and keeping raising awareness about channel\n>> jamming.\n>>\n>> > In this post I'd like to present a variation of bidirectional upfront\n>> payments that uses a time-proportional hold fee rate to address the\n>> limitation above. I also tried to come up with a system that aims > relate\n>> the fees paid more directly to the actual costs incurred and thereby reduce\n>> the number of parameters.\n>>\n>> Not considering hold invoices and other long-term held packets was one of\n>> my main concerns in the previous bidirectional upfront payments. This new\n>> \"hodl_fee_rate\" is better by binding the hold fee to the effectively\n>> consumed timelocked period of the liquidity and not its potential maximum.\n>>\n>> That said, routing nodes might still include the risk of hitting the\n>> chain in the computation of their `hodl_fee_rate` and the corresponding\n>> cost of having onchain timelocked funds. Given that HTLC deltas are\n>> decreasing along the path, it's more likely that `hodl_fee_rate` will be\n>> decreasing along the path. Even in case of lawfully solved hodl HTLC,\n>> routing nodes might be at loss for having paid a higher hold_fee on their\n>> upstream link than received on the downstream one.\n>>\n>> Is assuming increasing `hodl_fee_rate` along a payment path at odds with\n>> the ordering of timelocks ?\n>>\n>> > But this would also mean that anyone can send out an htlc and collect\n>> hold fees unconditionally. Therefore routing nodes advertise on the network\n>> their `hold_grace_period`. When routing nodes accept an htl> to forward,\n>> they're willing to pay hold fees for it. But only if they added a delay\n>> greater than `hold_grace_period` for relaying the payment and its response.\n>> If they relayed in a timely fashion, they exp> ect the sender of the htlc\n>> to cover those costs themselves. If the sender is also a routing node, the\n>> sender should expect the node before them to cover it. Of course, routing\n>> nodes can't be trusted. So in> practice we can just as well assume that\n>> they'll always try to claim from the prior node the maximum amount in\n>> compensation.\n>>\n>> Assuming `hodl_fee_rate` are near-similar along the payment path, you\n>> have a concern when the HTLC settlement happens at period N on the outgoing\n>> link and at period N+1 on the incoming link due to clock differences. In\n>> this case, a routing node will pay a higher `hodl_fee_rate` than received.\n>>\n>> I think this is okay, that's an edge case, only leaking a few sats.\n>>\n>> A more concerning one is when the HTLC settlement happens at period N on\n>> the outgoing link and your incoming counterparty goes offline. According to\n>> the HTLC relay contract, the `hodl_fee_rate` will be inflated until the\n>> counterparty goes back online and thus the routing node is at loss. And\n>> going offline is a really lawful behavior for mobile clients, even further\n>> if you consider mailbox-style of HTLC delivery (e.g Lightning Rod). You\n>> can't simply label such counterparty as malicious.\n>>\n>> And I don't think counterparties can trust themselves about their\n>> onliness to suspend the `hodl_fee_rate` inflation. Both sides have an\n>> interest to equivocate, the HTLC sender to gain a higher fee, the HTLC\n>> relayer to save the fee while having received one on the incoming link ?\n>>\n>> > Even though the proposal above is not fundamentally different from what\n>> was known already, I do think that it adds the flexibility that we need to\n>> not take a step back in terms of functionality (fair prici> ng for hodl\n>> invoices and its applications). Plus that it simplifies the parameter set.\n>>\n>> Minding the concerns raised above, I think this proposal is an\n>> improvement and would merit a specification draft, at least to ease further\n>> reasoning on its economic and security soundness. As a side-note, we're\n>> working further on Stake Certificates, which I believe is better for\n>> long-term network economics by not adding a new fee burden on payments. We\n>> should be careful to not economically outlaw micropayments. If we think\n>> channel jamming is concerning enough in the short-term, we can deploy a\n>> bidirectional upfront payment-style of proposal now and consider a better\n>> solution when it's technically mature.\n>>\n>>\n>> Antoine\n>>\n>> Le jeu. 11 f\u00e9vr. 2021 \u00e0 10:25, Joost Jager <joost.jager at gmail.com> a\n>> \u00e9crit :\n>>\n>>> Hi ZmnSCPxj,\n>>>\n>>> Not quite up-to-speed back into this, but, I believe an issue with using\n>>>> feerates rather than fixed fees is \"what happens if a channel is forced\n>>>> onchain\"?\n>>>>\n>>>> Suppose after C offers the HTLC to D, the C-D channel, for any reason,\n>>>> is forced onchain, and the blockchain is bloated and the transaction\n>>>> remains floating in mempools until very close to the timeout of C-D.\n>>>> C is now liable for a large time the payment is held, and because the\n>>>> C-D channel was dropped onchain, presumably any parameters of the HTLC\n>>>> (including penalties D owes to C) have gotten fixed at the time the channel\n>>>> was dropped onchain.\n>>>>\n>>>\n>>> The simplicity of the fixed fee is that it bounds the amount of risk\n>>>> that C has in case its outgoing channel is dropped onchain.\n>>>>\n>>>\n>>> The risk is bound in both cases. If you want you can cap the variable\n>>> fee at a level that isn't considered risky, but it will then not fully\n>>> cover the actual cost of the locked-up htlc. Also any anti-DoS fee could\n>>> very well turn out to be insignificant to the cost of closing and reopening\n>>> a channel with the state of the mempool these days.\n>>>\n>>> Joost\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210215/2bab1be3/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-02-13T04:24:07",
                "message_text_only": "Good morning Joost,\n\n> > Not quite up-to-speed back into this, but, I believe an issue with using feerates rather than fixed fees is \"what happens if a channel is forced onchain\"?\n> >\n> > Suppose after C offers the HTLC to D, the C-D channel, for any reason, is forced onchain, and the blockchain is bloated and the transaction remains floating in mempools until very close to the timeout of C-D.\n> > C is now liable for a large time the payment is held, and because the C-D channel was dropped onchain, presumably any parameters of the HTLC (including penalties D owes to C) have gotten fixed at the time the channel was dropped onchain.\n>\n> > The simplicity of the fixed fee is that it bounds the amount of risk that C has in case its outgoing channel is dropped onchain.\n>\n> The risk is bound in both cases. If you want you can cap the variable fee at a level that isn't considered risky, but it will then not fully cover the actual cost of the locked-up htlc. Also any anti-DoS fee could very well turn out to be insignificant to the cost of closing and reopening a channel with the state of the mempool these days.\n\n\nI think the problem of accidental channel closure is getting ignored by devs.\nIf we think any anti-DoS fee will be \"insignificant\" compared to the cost of closing and reopening a channel, maybe dev attention should be on fixing accidental channel closure costs than any anti-DoS fee mechanism.\nAny deterrence of the channel jamming problem is economic so if the anti-DoS fee is tiny, then its deterrence will be tiny as well.\n\nIt seems to me that adding this anti-DoS fee *on top of* an accidental channel closure is just adding insult to injury, when we should probably be considering how to ameliorate the injury.\nOtherwise forwarding nodes will themselves be deterred from operating at all.\n\n\n> > Is assuming increasing `hodl_fee_rate` along a payment path at odds with the ordering of timelocks ?\n>\n> I don't think it is.\n\nIn terms of privacy, this is more dangerous.\n\nThe decrementing timelock already leaks an upper bound on the distance to payee.\nAn incrementing holdfee leaks an upper bound on the distance to payer.\nThis translates to a single payment-part being more easily associated with the payer and payee.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2021-02-23T01:52:49",
                "message_text_only": "> I think the problem of accidental channel closure is getting ignored by\n> devs.\n>\n> If we think any anti-DoS fee will be \"insignificant\" compared to the cost\n> of closing and reopening a channel, maybe dev attention should be on\n> fixing accidental channel closure costs than any anti-DoS fee mechanism.\n>\n> Any deterrence of the channel jamming problem is economic so if the\n> anti-DoS fee is tiny, then its deterrence will be tiny as well.\n\nThis struck me as an extremely salient point. One thing that has been\nnoticeable missing from these discussions is any sort of threat model or\nattacker\nprofile. Given this is primarily a griefing attack, and the attacker doesn't\nstand any direct gain, how high a fee is considered \"adequate\" deterrence\nwithout also dramatically increasing the cost of node operation in the\naverage case?\n\nIf an attacker has say a budget of 20 BTC to blow as they just want to see\nthe world burn, then most parametrizations of attempt fees are likely\ninsufficient. In addition, if the HTLC attempt/hold fees rise well above\nrouting fees, then costs are also increased for senders in addition to\nrouting nodes.\n\nAlso IMO, it's important to re-state, that if channels are parametrized\nproperly (dust values, max/min HTLC, private channels, micropayment specific\nchannels, etc), then there is an inherent existing cost re the opportunity\ncost of committing funds in channels and the chain fee cost of making the\nseries of channels in the first place.\n\nBased on the discussion above, it appears that the decaying fee idea needs\ncloser examination to ensure it doesn't increase the day to day operational\ncost of a routing node in order to defend against threats at the edges.\nNodes go down all the time for various reasons: need to allocate more disk,\nsoftware upgrade, infrastructure migrations, power outages, etc, etc. By\nadding a steady decay cost, we introduce an idle penalty for lack of uptime\nwhen holding an HTLC, similar to the availability slashing in PoS systems.\nIt would be unfortunate if an end result of such a solution is increasing\nnode operation costs as a whole, (which has other trickle down effects: less\nnodes, higher routing fees, strain of dev-ops teams to ensure higher uptime\nor loss of funds, etc), while having negligible effects on the \"success\"\nprofile of such an attack in practice.\n\nIf nodes wish to be compensated for committing capital to Lightning itself,\nthen markets such as Lightning Pool which rewards them for allocating the\ncapital (independent of use) for a period of time can help them scratch that\nitch.\n\nReturning back to the original point, it may very well be the case that the\nvery first solution proposed (circa 2015) to this issue: close out the\nchannel and send back a proof of closure, may in fact be more desirable from\nthe PoV of enforcing tangible costs given it requires the attacker to\nforfeit on-chain fees in the case of an unsuccessful attack. Services that\nrequire long lived HTLCs (HTLC mailboxes, etc) can flag the HTLCs as such in\nthe onion payload allowing nodes to preferentially forward or reject them.\n\nZooming out, I have a new idea in this domain that attempts to tackle things\nfrom a different angle. Assuming that any efforts to add further off-chain\ncosts are insignificant in the face of an attacker with few constraints\nw.r.t budget, perhaps some efforts should be focused on instead ensuring\nthat if there's \"turbulence\" in the network, it can gracefully degraded to a\nslightly more restricted operating mode until the storm passes. If an\nattacker spends coins/time/utxos, etc to be in position to distrust things,\nbut then finds that things are working as normal, such a solution may serve\nas a low cost deterrence mechanism that won't tangibly increase\noperation/forwarding/payment costs within the network. Working out some of\nthe kinks re the idea, but I hope to publish it sometime over the next few\ndays.\n\n-- Laolu\n\n\nOn Fri, Feb 12, 2021 at 8:24 PM ZmnSCPxj via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> wrote:\n\n> Good morning Joost,\n>\n> > > Not quite up-to-speed back into this, but, I believe an issue with\n> using feerates rather than fixed fees is \"what happens if a channel is\n> forced onchain\"?\n> > >\n> > > Suppose after C offers the HTLC to D, the C-D channel, for any reason,\n> is forced onchain, and the blockchain is bloated and the transaction\n> remains floating in mempools until very close to the timeout of C-D.\n> > > C is now liable for a large time the payment is held, and because the\n> C-D channel was dropped onchain, presumably any parameters of the HTLC\n> (including penalties D owes to C) have gotten fixed at the time the channel\n> was dropped onchain.\n> >\n> > > The simplicity of the fixed fee is that it bounds the amount of risk\n> that C has in case its outgoing channel is dropped onchain.\n> >\n> > The risk is bound in both cases. If you want you can cap the variable\n> fee at a level that isn't considered risky, but it will then not fully\n> cover the actual cost of the locked-up htlc. Also any anti-DoS fee could\n> very well turn out to be insignificant to the cost of closing and reopening\n> a channel with the state of the mempool these days.\n>\n>\n> I think the problem of accidental channel closure is getting ignored by\n> devs.\n> If we think any anti-DoS fee will be \"insignificant\" compared to the cost\n> of closing and reopening a channel, maybe dev attention should be on fixing\n> accidental channel closure costs than any anti-DoS fee mechanism.\n> Any deterrence of the channel jamming problem is economic so if the\n> anti-DoS fee is tiny, then its deterrence will be tiny as well.\n>\n> It seems to me that adding this anti-DoS fee *on top of* an accidental\n> channel closure is just adding insult to injury, when we should probably be\n> considering how to ameliorate the injury.\n> Otherwise forwarding nodes will themselves be deterred from operating at\n> all.\n>\n>\n> > > Is assuming increasing `hodl_fee_rate` along a payment path at odds\n> with the ordering of timelocks ?\n> >\n> > I don't think it is.\n>\n> In terms of privacy, this is more dangerous.\n>\n> The decrementing timelock already leaks an upper bound on the distance to\n> payee.\n> An incrementing holdfee leaks an upper bound on the distance to payer.\n> This translates to a single payment-part being more easily associated with\n> the payer and payee.\n>\n>\n> Regards,\n> ZmnSCPxj\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210222/be677d34/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-02-23T12:33:50",
                "message_text_only": ">\n> This struck me as an extremely salient point. One thing that has been\n> noticeable missing from these discussions is any sort of threat model or\n> attacker\n> profile. Given this is primarily a griefing attack, and the attacker\n> doesn't\n> stand any direct gain, how high a fee is considered \"adequate\" deterrence\n> without also dramatically increasing the cost of node operation in the\n> average case?\n>\n\nI think that the first instances that we'll see of this attack will be\nexecuted by routing node operators that don't mind operating in a gray\narea. Apparently the popularity of the Lightning Network has risen to the\npoint where it is possible for an operator to earn thousands of dollars per\nmonth in routing fees. Imagine how much this could be when you're actively\njamming the competition's channels. Not only can you capture their traffic,\nbut it will also be possible to command a higher fee rate because senders\nprobably still want those payments to go through.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210223/15786d74/attachment.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2021-02-20T18:33:09",
                "message_text_only": "To further illustrate the interactions of the hold fee rate proposal, I've\ncreated a spreadsheet that calculates the fees for a three hop route:\n\nhttps://docs.google.com/spreadsheets/d/1UX3nMl-L9URO3Vd49DBVaubs6fdi6wxSb-ziSVlF6eo/edit?usp=sharing\n\n\n(if there was a way to paste a working spreadheet into an email, I would\nhave done it...)\n\nYou can make a copy and try out various different values. The actual hold\ntime is particularly interesting, because it allows you to see how much\nholding an htlc is going to cost you.\n\nExample 1:\nIf all nodes want a 5% yearly return on their held capital and one sends a\n1 million sat payment across three hops that is held for one hour by the\nrecipient, the recipient will be charged about 20 sats for this.\n\nExample 2:\nWith the same configuration, a 1 sat micropayment that is settled\nnear-instantly will cost the sender around 130 msat in hold fees.\n\nJoost\n\nOn Thu, Feb 11, 2021 at 3:28 PM Joost Jager <joost.jager at gmail.com> wrote:\n\n> Hi all,\n>\n> Things have been quiet around channel jamming lately, but the\n> vulnerability it still there as much as it was before. I've participated in\n> an (isolated) mainnet channel jamming experiment (\n> https://bitcoinmagazine.com/articles/good-griefing-a-lingering-vulnerability-on-lightning-network-that-still-needs-fixing)\n> which only confirmed the seriousness of the issue.\n>\n> BIDIRECTIONAL UPFRONT PAYMENT\n>\n> Of all the proposals that have been presented, t-bast's remix of forward\n> and backward upfront payments (\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-October/002862.html\n> ,\n> https://github.com/t-bast/lightning-docs/blob/master/spam-prevention.md#bidirectional-upfront-payment)\n> indicates in my opinion the most promising direction.\n>\n> One characteristic of the proposal is that the `hold_fees` are\n> time-independent. If an htlc doesn't resolve within the `grace_period`, the\n> receiver of the htlc will be forced to pay the full hold fee. The hold fee\n> should cover the expenses for locking up an htlc for the maximum duration\n> (could be 2000 blocks), so this can be a significant penalty. Applications\n> such as atomic onchain/offchain swaps (Lightning Loop and others) rely on\n> locking funds for some time and could get expensive with a fixed hold fee.\n>\n> HOLD FEE RATE\n>\n> In this post I'd like to present a variation of bidirectional upfront\n> payments that uses a time-proportional hold fee rate to address the\n> limitation above. I also tried to come up with a system that aims to relate\n> the fees paid more directly to the actual costs incurred and thereby reduce\n> the number of parameters.\n>\n> In a Lightning channel, the sender of an htlc always incurs the cost. The\n> htlc value is deduced from their balance and the money can't be used for\n> other purposes when the htlc is in flight. Therefore ideally a routing node\n> is compensated for the time that their outgoing htlc is in flight.\n>\n> To communicate this cost to the outside world, routing nodes advertise a\n> `hold_fee_rate` as part of their channel forwarding policy. An example\n> would be \"0.3 msat per sat per minute\". So if someone wants to forward 10k\n> sat through that channel and the htlc remains in flight for 5 minutes, the\n> routing node would like to see a compensation of 0.3msat * 10k sat * 5 mins\n> = 15 sat. (it is possible to extend the model with a base fee rate to also\n> cover the cost of an occupied slot on the commitment tx)\n>\n> The question here again is who is going to pay the hold fee. The answer is\n> that it is primarily the receiver of the htlc who is going to pay. They are\n> the ones that can fail or settle the htlc and are therefore in control of\n> the hold time (\"Reverse upfront payment\")\n>\n> But this would also mean that anyone can send out an htlc and collect hold\n> fees unconditionally. Therefore routing nodes advertise on the network\n> their `hold_grace_period`. When routing nodes accept an htlc to forward,\n> they're willing to pay hold fees for it. But only if they added a delay\n> greater than `hold_grace_period` for relaying the payment and its response.\n> If they relayed in a timely fashion, they expect the sender of the htlc to\n> cover those costs themselves. If the sender is also a routing node, the\n> sender should expect the node before them to cover it. Of course, routing\n> nodes can't be trusted. So in practice we can just as well assume that\n> they'll always try to claim from the prior node the maximum amount in\n> compensation.\n>\n> This is the basic idea. Routing nodes have real costs for the lock up of\n> their money and will be compensated for it.\n>\n> To coordinate the payment of the fees, the `update_add_htlc` message is\n> extended with:\n> * `hold_fee_rate`: the fee rate that the sender charges for having the\n> htlc in-flight (msat per sat per min)\n> * `hold_fee_discount`: the absolute fee discount (sat) that the receiver\n> gets as a compensation for hold fees that couldn't be claimed downstream\n> because of the grace periods (the worst case amount).\n> (the previous `hold_grace_period` in `update_add_htlc` is no longer needed)\n>\n> When an htlc is resolved, the receiver of the htlc will pay the sender the\n> `hold_fee_rate` minus `hold_fee_discount` (exact details of how to\n> integrate this into the channel state machine and deal with clock shift\n> tbd).\n>\n> It is up to the sender of a payment to construct the onion payloads such\n> that all nodes along the route will have their costs covered.\n>\n> EXAMPLE\n>\n> A ----> B ----> C ----> D\n> Every node charges 0.6 msat/sat/minute with a hold grace period of 1\n> minute. In this example, the routing fees are zero.\n> A wants to send 1000 sat to D.\n>\n> A will charge B a hold fee rate of 0.6 sat/min (1000 sat at 0.6\n> msat/sat/min). B will charge C a hold fee rate of 1.2 sat/min to cover both\n> its own cost and what must be paid back to A. C will charge D a hold fee\n> rate of 1.8 sat/min to cover the costs of A, B and C.\n>\n> D has a grace period of 1 minute. At the 1.8 sat/min fee rate that C\n> charges, D would need to pay a maximum of 1.8 sat if it meets its grace\n> deadline just in time. C pays the 1.8 sats to D as a discount on its hold\n> fee (assuming D will settle right before the deadline anyway).\n>\n> C also has a grace period of 1 minute. But because D has a grace period\n> too, it could be that C needs to hold on to the htlc for a total of 2\n> minutes. At the 1.2 sat/min fee rate B charges, C would need to pay a\n> maximum of 2.4 sats, plus the hold fee that it needs to pay to D (1.8\n> sats). Therefore B gives C a hold fee discount of 2.4+1.8 = 4.2 sats.\n>\n> The same logic applies to A and B. A offers a hold fee discount of 0.6 * 3\n> min + 4.2 = 6 sats to cover the worst case cost of B, C and D.\n>\n> If A is just spamming/probing, it will cost hem 6 sats per htlc. If D is\n> trying to channel-jam by hodling htlcs, it will cost them 1.8 sat/min. If\n> an intermediate hop is delaying the payment, they will pay at least 0.6\n> sat/min (depending on the position in the route).\n>\n> In the happy flow, A is still paying 6 sat per payment attempt which is\n> used to compensate B, C and D for the short unavailability of their funds.\n> To me, this seems only fair.\n>\n> CONCLUSION\n>\n> Even though the proposal above is not fundamentally different from what\n> was known already, I do think that it adds the flexibility that we need to\n> not take a step back in terms of functionality (fair pricing for hodl\n> invoices and its applications). Plus that it simplifies the parameter set.\n>\n> Thoughts?\n>\n> Joost\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210220/e9784f60/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Hold fee rates as DoS protection (channel spamming and jamming)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Joost Jager",
                "Olaoluwa Osuntokun",
                "Antoine Riard",
                "ZmnSCPxj"
            ],
            "messages_count": 11,
            "total_messages_chars_count": 63017
        }
    },
    {
        "title": "[Lightning-dev] Error Codes for LN",
        "thread_messages": [
            {
                "author": "Carla Kirk-Cohen",
                "date": "2021-02-12T07:34:04",
                "message_text_only": "Hi all,\n\nI\u2019d like to make a case for re-purposing the existing error message\n\n(17) in the spec to allow for more structured errors, and create a\n\npath for standardized, enriched errors going forward.\n\nAs is: the error message contains an arbitrary string, and is used to\n\ncommunicate fatal errors to our peers.\n\nTo (potentially) be: the error message contains an error code, and\n\noptional metadata which enriches the context of the error.\n\nThere are a few benefits of upgrading these messages:\n\n* Better debugging information, and standardization across\n\n   implementations\n\n* Clearer information for the end user\n\n* Reduced risk of leaking information in an arbitrary string\n\n* More fine-grained error handling based on error code\n\nSince we shouldn\u2019t have non-ascii values in the error string itself,\n\nthis can most easily be achieved by adding TLV fields after the\n\ndata field. In terms of supporting nodes that have not upgraded,\n\nwe could either include the error code in the data field to cover\n\nour bases, or introduce a feature bit so that we know whether\n\nto backfill the data field. This gives upgraded nodes an improved\n\nquality of life, while leaving older nodes unaffected.\n\nWhile we can\u2019t enumerate every possible error, there are quite\n\na few cases in the spec where we can introduce explicit error\n\ncodes. For the sake of the skim-readers, I\u2019ve left that list at\n\nthe end of the email.\n\nTaking the example of our node receiving an invalid signature for\n\na htlc, a new error would look like this:\n\n   1.\n\n   type: 17 (`error`)\n   2.\n\n   data\n\n[Channel_id:channel_id]\n\n[u16:len]\n\n[len*byte:data]\n\n   1.\n\n   tlv_stream: `invalid_sig_tlvs`\n   2.\n\n   Types\n\ni. type 0 (`error_code`)\n\ndata: [u16: error_code]\n\nii. type 1 (`htlc_id`)\n\ndata: [u64: id]\n\niii. type 2 (`state_number`)\n\ndata: [u64: commitment_number]\n\nThis new kind of error provides us with an error code that tells us\n\nexactly what has gone wrong, and metadata pointing to the htlc\n\nwith an invalid sig. This information can be logged, or stored in a\n\nmore permanent error store to help diagnose issues in the future.\n\nRight now, the spec is pretty strict on error handling [13], indicating\n\nthat senders/recipients of errors `MUST` fail the channel referenced\n\nin the error. This isn\u2019t very practical, and I believe that the majority\n\nof the impls don\u2019t abide by this instruction. With the addition of error\n\ncodes, we can pair each error code with a recommended action\n\nthat is more appropriate for the error at hand - for example, still force\n\nclosing if we get an invalid signature, but being more lenient if we\n\nget a low fee in update fee. While this may already be the case in\n\npractise, it\u2019s messy for everybody to roll their own and then figure\n\nout what other impls are doing. With a standardized set of errors,\n\nand reasonable handling - rather than the current \u201cclose-all-da-chans\u201d\n\nprescription in the spec - we can clear up some of the ambiguity\n\naround errors, and a spec that\u2019s reasonable for the end user to\n\nfollow.\n\nThanks for reading!\n\n- Carla\n\nCandidates for error codes:\n\nSignature problems:\n\n* Incorrect Signature [1] [3] [7] [12]\n\n*Non-standard signature [1] [3 [7]\n\nFunding Process:\n\n* Funding process timeout [2]\n\n* Fees greater than base fee [3]\n\n* Fees out of range [3]\n\n* Funding tx spent [11]\n\n* Funding params unacceptable (eg, channel too small)\n\nChannel State Machine:\n\n* HTLC timeout [4]\n\n* Zero htlc add [5]\n\n* Htlc add less than minimum [5]\n\n* Htlc add can\u2019t afford at current fee rate [5]\n\n* Maximum htlc count exceeded [5]\n\n* Maximum htlc in flight exceeded [5]\n\n* cltv > 500000000 [5]\n\n* Sub-msat values [5]\n\n* Fulfill/fail htlc id not found [6]\n\n* Incorrect commitment number [10]\n\n* Incorrect preimage [6]\n\n* Incorrect per commit secret [8]\n\nFee Updates\n\n* Update fee to low/high [9]\n\n* Unexpected update fee [9]\n\n* Cannot afford update fee [9]\n\nConnection Level\n\n* Disconnecting\n\n* Feature bit required\n\nGossip\n\n* Incorrect gossip short channel ID [12]\n\n\n[1]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#the-funding_created-message\n\n[2]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#the-funding_locked-message\n\n[3]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#closing-negotiation-closing_signed\n\n[4]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-8\n\n[5]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-9\n\n[6]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-10\n\n[7]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-11\n\n[8]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-12\n\n[9]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-13\n\n[10]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#requirements-14\n\n[11]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/05-onchain.md#requirements\n\n[12]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#requirements\n\n[13]\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#the-error-message\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210212/0fc08d61/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Error Codes for LN",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Carla Kirk-Cohen"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 5527
        }
    }
]