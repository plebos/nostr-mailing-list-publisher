[
    {
        "title": "[Lightning-dev] General questions about channels",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-01-01T03:00:53",
                "message_text_only": "Andy Schroder <info at AndySchroder.com> writes:\n\n> Andy Schroder\n>\n> On 12/27/2017 12:56 AM, ZmnSCPxj wrote:\n>> Good morning Andy,\n>>\n>>>\n>>>     Channel closing\n>>>     costs dwarf the gains to be made from cheating, however.\n>>>\n>>>         Since millisatoshis is used, is there a maximum channel\n>>>         funding size?\n>>>         Yes, the upper 32 bits must be zero, from BOLT #2:\n>>>\n>>>      *\n>>>         for channels with |chain_hash| identifying the Bitcoin\n>>>         blockchain:\n>>>           o MUST set the four most significant bytes of |amount_msat|\n>>>             to 0.\n>>>\n>>>     This gives a maximum HTLC value of .04294967295 BTC, which, back when\n>>>     we started, was about $10.\n>>>\n>>>\n>>> What's the point of wasting the upper 32 bits? Seems like this is a\n>>> waste of data?\n>>\n>> The specs are intended to eventually support other similar \n>> cryptocurrencies, such as Litecoin.  For those currencies, payments of \n>> hundreds of whole coins may be practical, and thus the 0.042 limit is \n>> not imposed.  For Bitcoin only, the limit is applied.  This simplifies \n>> the design of software by only imposing a limit to a large field under \n>> certain conditions (i.e. for Bitcoin) while retaining the same format \n>> for all coins. Other cryptocurrencies may have different imposed \n>> limits when Lightning gets around to those.\n>\n> It seems like you are making assumptions about the purchasing power of \n> certain cryptocurrencies. Why even bother doing this? You have no idea \n> what the future holds. Why set a limit for any cryptocurrency that might \n> use lightning?\n\nHi Andy,\n\n        I think I covered this pretty well previously: https://medium.com/@rusty_lightning/bitcoin-lightning-faq-why-the-0-042-bitcoin-limit-2eb48b703f3\n\n> Okay, so why bother making these two amounts different?\n\nSince that's just between peers, it was less critical in restraiing the\nnetwork (and far easier to change).  There was also a proposal for a\n\"dangerous feature bit\" which would avoid this limitation.\n\n>> Both you and the exchange would want to do this: the exchange wants \n>> this so it can capture your routing fees, you want this so that you do \n>> not even touch the chain at all and start out in Lightning in the \n>> first place.\n>\n> Okay, so all this feature is doing is saving the extra step of making an \n> initial payment? Just saving a little time, and not a monumental or \n> required feature?\n\nIt also allows you to hand *all* the money to the other side (the\ninitial state is not required to have a reserve).\n\nBut basically it had the advantage of being trivial.  If nobody actually\nuses it, we'll probably drop it in 1.1.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2018-01-01T03:18:18",
                "message_text_only": "Mark Friedenbach <mark at friedenbach.org> writes:\n> I had always assumed the protocol limits were training wheels, and would be shocked and dismayed if that were not the case (and would immediately begin work on an alternative fork because such limits would make lightning useless for my intended applications).\n\nMark,\n\n        This is an unnecessarily aggressive sentence; we all need to\ntake care not to let Bitcoin's mode of discussion leak into Lightning\ndevelopment.  I've failed at this several times myself.\n\nIf you have enough time to work on an alternative fork, I'd encourage\nyou to contribute to the spec process :)\n\nThanks,\nRusty."
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-01T17:47:53",
                "message_text_only": "Andy Schroder <info at AndySchroder.com> writes:\n> I understand that you have to be in agreement with your direct peers. So \n> you don't really care about what agreements others in your route may \n> have in place? I would think that you would choose not to route through \n> hops that violate your capacity limit.\n\nI'm failing to see why I'd care about a remote channel's capacity, aside\nfrom it being large enough to cover the amount I want to transfer. As a\nparticipant routing through a channel that has a higher capacity I do\nnot incur any additional risk than from a smaller channel, since the\npayment is guaranteed to be atomic. In the contrary one could argue that\na higher capacity channel has a higher probability of having sufficient\ncapacity in the desired direction to forward my transfer.\n\nMaybe I'm failing to see something? I always interpreted the limit as\npurely self-defense on how much value I'm confident enough to keep in a\nchannel.\n\nCheers,\nChristian"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-01-02T05:21:53",
                "message_text_only": "What you are saying makes perfect sense for the short term.\n\nWhat I am talking about could promote a big picture healthier network \nlong term by discouraging \"super nodes\" in the network from existing, if \nyou avoid making connections to nodes that have large channel capacities \nwith other parties.\n\nDoes this make sense?\n\nAndy Schroder\n\nOn 01/01/2018 12:47 PM, Christian Decker wrote:\n> Andy Schroder <info at AndySchroder.com> writes:\n>> I understand that you have to be in agreement with your direct peers. So\n>> you don't really care about what agreements others in your route may\n>> have in place? I would think that you would choose not to route through\n>> hops that violate your capacity limit.\n> I'm failing to see why I'd care about a remote channel's capacity, aside\n> from it being large enough to cover the amount I want to transfer. As a\n> participant routing through a channel that has a higher capacity I do\n> not incur any additional risk than from a smaller channel, since the\n> payment is guaranteed to be atomic. In the contrary one could argue that\n> a higher capacity channel has a higher probability of having sufficient\n> capacity in the desired direction to forward my transfer.\n>\n> Maybe I'm failing to see something? I always interpreted the limit as\n> purely self-defense on how much value I'm confident enough to keep in a\n> channel.\n>\n> Cheers,\n> Christian\n>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-02T13:11:50",
                "message_text_only": "I see, are you suggesting that large channels could be an indicator of a\nlarge actor trying to attract a lot of payment traffic? Not sure whether\nthat is really a good measure, since it is trivial for a large node to\nmasquerade as any number of smaller nodes, thus hiding its size.\n\nWe definitely want to discourage this kind of masquerades since it\ncauses a lot more transactions on-chain and results in UTXO\nfragmentation. In addition what we actually try to guard against are\nhubs, which have a lot of channels open, not large ones :-)\n\nCheers,\nChristian\n\nAndy Schroder <info at AndySchroder.com> writes:\n> What you are saying makes perfect sense for the short term.\n>\n> What I am talking about could promote a big picture healthier network \n> long term by discouraging \"super nodes\" in the network from existing, if \n> you avoid making connections to nodes that have large channel capacities \n> with other parties.\n>\n> Does this make sense?\n>\n> Andy Schroder\n>\n> On 01/01/2018 12:47 PM, Christian Decker wrote:\n>> Andy Schroder <info at AndySchroder.com> writes:\n>>> I understand that you have to be in agreement with your direct peers. So\n>>> you don't really care about what agreements others in your route may\n>>> have in place? I would think that you would choose not to route through\n>>> hops that violate your capacity limit.\n>> I'm failing to see why I'd care about a remote channel's capacity, aside\n>> from it being large enough to cover the amount I want to transfer. As a\n>> participant routing through a channel that has a higher capacity I do\n>> not incur any additional risk than from a smaller channel, since the\n>> payment is guaranteed to be atomic. In the contrary one could argue that\n>> a higher capacity channel has a higher probability of having sufficient\n>> capacity in the desired direction to forward my transfer.\n>>\n>> Maybe I'm failing to see something? I always interpreted the limit as\n>> purely self-defense on how much value I'm confident enough to keep in a\n>> channel.\n>>\n>> Cheers,\n>> Christian\n>>"
            },
            {
                "author": "Andy Schroder",
                "date": "2018-01-03T03:45:50",
                "message_text_only": "Yes, that's what I'm suggesting, but I don't know if it's right or not.\n\nI was assuming many small channels would be partially self regulating \nbecause people would have to pay for more on chain transaction fees for \nthe opening and closing of the channels.\n\n\nAndy Schroder\n\nOn 01/02/2018 08:11 AM, Christian Decker wrote:\n> I see, are you suggesting that large channels could be an indicator of a\n> large actor trying to attract a lot of payment traffic? Not sure whether\n> that is really a good measure, since it is trivial for a large node to\n> masquerade as any number of smaller nodes, thus hiding its size.\n>\n> We definitely want to discourage this kind of masquerades since it\n> causes a lot more transactions on-chain and results in UTXO\n> fragmentation. In addition what we actually try to guard against are\n> hubs, which have a lot of channels open, not large ones :-)\n>\n> Cheers,\n> Christian\n>\n> Andy Schroder <info at AndySchroder.com> writes:\n>> What you are saying makes perfect sense for the short term.\n>>\n>> What I am talking about could promote a big picture healthier network\n>> long term by discouraging \"super nodes\" in the network from existing, if\n>> you avoid making connections to nodes that have large channel capacities\n>> with other parties.\n>>\n>> Does this make sense?\n>>\n>> Andy Schroder\n>>\n>> On 01/01/2018 12:47 PM, Christian Decker wrote:\n>>> Andy Schroder <info at AndySchroder.com> writes:\n>>>> I understand that you have to be in agreement with your direct peers. So\n>>>> you don't really care about what agreements others in your route may\n>>>> have in place? I would think that you would choose not to route through\n>>>> hops that violate your capacity limit.\n>>> I'm failing to see why I'd care about a remote channel's capacity, aside\n>>> from it being large enough to cover the amount I want to transfer. As a\n>>> participant routing through a channel that has a higher capacity I do\n>>> not incur any additional risk than from a smaller channel, since the\n>>> payment is guaranteed to be atomic. In the contrary one could argue that\n>>> a higher capacity channel has a higher probability of having sufficient\n>>> capacity in the desired direction to forward my transfer.\n>>>\n>>> Maybe I'm failing to see something? I always interpreted the limit as\n>>> purely self-defense on how much value I'm confident enough to keep in a\n>>> channel.\n>>>\n>>> Cheers,\n>>> Christian\n>>>"
            }
        ],
        "thread_summary": {
            "title": "General questions about channels",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Andy Schroder",
                "Christian Decker"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 10129
        }
    },
    {
        "title": "[Lightning-dev] Replaceable Funding Transactions",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-02T00:12:31",
                "message_text_only": "Good morning list,\n\nReading the BOLT spec, and considering the common issue of slow transaction confirmation on the blockchain level, I want to ask the list if it is possible to use replaceable (replace-by-fee) funding transactions, at the current 1.0\n\nBOLT v1.0 has a below suggestion:\n\n> A non-funding node (fundee):\n>\n> * SHOULD forget the channel if it does not see the funding transaction after a reasonable timeout\n\nSo, to my mind, it is possible to do RBF funding transactions, as long as the counterparty allows multiple channels per peer (i.e. not work with c-lightning, which restricts one-channel-one-peer).\n\nThe consideration is below:\n\n1.  Send open_channel for channel #1\n2.  Receive accept_channel for channel #1\n3.  Create RBF-able funding transaction for low feerate.\n4.  Send funding_created for channel #1\n5.  Receive funding_signed for channel #1\n6.  Wait on blockchain.  Since feerate is low, it does not confirm. So, we decide, we should increase fee rate.\n7.  Send open_channel for channel #2 to same party.\n8.  Receive accept_channel for channel #2.\n9.  Create replacement funding transaction for high feerate.\n10.  Send funding_created for channel #2.\n11.  Receive funding_signed for channel #2\n12.  Wait on blockchain. Because feerate is so high, it confirms quickly.\n13.  Send funding_locked for channel #2, receive funding_locked for channel #2\n14.  Let counterparty forget channel #1 (which is now impossible to make, as the funding transaction spends an already-spent UTXO).\n\nIs the above possible in current BOLT spec (modulo, the fact that c-lightning restricts channels)?\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180101/f07e27ad/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2018-01-02T14:32:04",
                "message_text_only": "Hi ZmnSCPxj,\n\nI don't see why this wouldn't work as long as implementations on both\nends supports channels multiplexing, like lnd or eclair do (didn't\ntest it though).\n\nBut being the accepting node, I wouldn't like receiving too many\nchannel requests that never confirm. Also, most of the time I don't\nthink the opening of a channel should be considered a time-sensitive\noperation (in general, but there are exceptions to this of course).\n\nCheers,\n\nPierre"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-03T13:09:34",
                "message_text_only": "Good morning,\n\n> I don't see why this wouldn't work as long as implementations on both\n> ends supports channels multiplexing, like lnd or eclair do (didn't\n> test it though).\n\nThank you, that is my understanding also.\n\n> But being the accepting node, I wouldn't like receiving too many\n> channel requests that never confirm.\n\nI understand and this is a concern. Hopefully a later Lightning BOLT spec can provide some kind of cancel_channel message to indicate that the funder node is very sure that a particular funding transaction will never confirm.\n\n> Also, most of the time I don't\n> think the opening of a channel should be considered a time-sensitive\n> operation (in general, but there are exceptions to this of course).\n\nI think all blockchain operations should be considered potentially time-sensitive, including channel opening.\n\nIn theory it would be possible (but likely not easy) to develop a wallet which strives to keep transactions replaceable. Each blockchain send from the wallet would replace any unconfirmed transaction, and funding a channel would be similar to such a blockchain-level send (except the protocol needs to wait for funding_signed for all channel counterparties before broadcasting a replacement transaction).\n\nI also think that a good part of the frustration around transaction fees at the blockchain level is at least partly due to the lack of ways to control transaction fees after a transaction has been broadcast.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180103/80e3a024/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Replaceable Funding Transactions",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Pierre",
                "ZmnSCPxj"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3919
        }
    },
    {
        "title": "[Lightning-dev] SegWit and LN",
        "thread_messages": [
            {
                "author": "Praveen Baratam",
                "date": "2018-01-02T13:53:41",
                "message_text_only": "Why is SegWit required for LN? If we wait for the *funding transaction* to\nbe *confirmed*, we can then safely create and update unconfirmed commitment\ntransactions...\n\nI don't see how SegWit is important here... Am I missing something?\n\n-- \nDr. Praveen Baratam\n\nabout.me <http://about.me/praveen.baratam>\n\u1427\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/8d27677c/attachment.html>"
            },
            {
                "author": "Hafeez Bana",
                "date": "2018-01-02T14:11:20",
                "message_text_only": "to fix transaction malleability\n\nOn Tue, Jan 2, 2018 at 1:53 PM, Praveen Baratam <praveen.baratam at gmail.com>\nwrote:\n\n> Why is SegWit required for LN? If we wait for the *funding transaction*\n> to be *confirmed*, we can then safely create and update unconfirmed\n> commitment transactions...\n>\n> I don't see how SegWit is important here... Am I missing something?\n>\n> --\n> Dr. Praveen Baratam\n>\n> about.me <http://about.me/praveen.baratam>\n> \u1427\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/80383faf/attachment.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-02T14:31:04",
                "message_text_only": "Hi,\nBefore you can safely broadcast the funding transaction, the two parties involved in a channel must have signed a commitment transaction spending the output from the funding transaction. Without segwit, the funding transaction can be malleated, leaving the commitment transaction invalid, and funds locked up if one of the parties stops cooperating.\n\nCheers, Johan\nOn Tue, Jan 2, 2018 at 15:11, Hafeez Bana <hafeez.bana at gmail.com> wrote:\nto fix transaction malleability\n\nOn Tue, Jan 2, 2018 at 1:53 PM, Praveen Baratam < praveen.baratam at gmail.com [praveen.baratam at gmail.com] > wrote:\nWhy is SegWit required for LN? If we wait for the funding transaction to be confirmed , we can then safely create and update unconfirmed commitment transactions...\nI don't see how SegWit is important here... Am I missing something?\n\n--\nDr. Praveen Baratam\nabout.me [http://about.me/praveen.baratam] \u1427\n______________________________ _________________\nLightning-dev mailing list\nLightning-dev at lists. linuxfoundation.org [Lightning-dev at lists.linuxfoundation.org]\nhttps://lists.linuxfoundation. org/mailman/listinfo/ lightning-dev [https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev]\n\n\n\n_______________________________________________ Lightning-dev mailing list Lightning-dev at lists.linuxfoundation.org https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/f5facf90/attachment.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-02T14:43:03",
                "message_text_only": "That\u2019s correct :)\n\nOn Tue, Jan 2, 2018 at 15:34, Praveen Baratam <praveen.baratam at gmail.com> wrote:\nThank you for explaining @Hafeez & @Johan\nNow that all the BIPs necessary for LN including SegWit (Softfork) are active on the mainnet, are we just waiting for the LN implementation to mature or are there any other issues? \u1427\nOn Tue, Jan 2, 2018 at 8:01 PM, Johan Tor\u00e5s Halseth < johanth at gmail.com [johanth at gmail.com] > wrote:\nHi,\nBefore you can safely broadcast the funding transaction, the two parties involved in a channel must have signed a commitment transaction spending the output from the funding transaction. Without segwit, the funding transaction can be malleated, leaving the commitment transaction invalid, and funds locked up if one of the parties stops cooperating.\n\nCheers, Johan\nOn Tue, Jan 2, 2018 at 15:11, Hafeez Bana < hafeez.bana at gmail.com [hafeez.bana at gmail.com] > wrote:\nto fix transaction malleability\n\nOn Tue, Jan 2, 2018 at 1:53 PM, Praveen Baratam < praveen.baratam at gmail.com [praveen.baratam at gmail.com] > wrote:\nWhy is SegWit required for LN? If we wait for the funding transaction to be confirmed , we can then safely create and update unconfirmed commitment transactions...\nI don't see how SegWit is important here... Am I missing something?\n\n--\nDr. Praveen Baratam\nabout.me [http://about.me/praveen.baratam] \u1427\n______________________________ _________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfound ation.org [Lightning-dev at lists.linuxfoundation.org]\nhttps://lists.linuxfoundation. org/mailman/listinfo/lightning -dev [https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev]\n\n\n\n______________________________ _________________ Lightning-dev mailing list Lightning-dev at lists. linuxfoundation.org [Lightning-dev at lists.linuxfoundation.org] https://lists.linuxfoundation. org/mailman/listinfo/ lightning-dev [https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev]\n\n\n--\nDr. Praveen Baratam\nabout.me [http://about.me/praveen.baratam]\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/bbc8938a/attachment-0001.html>"
            },
            {
                "author": "Praveen Baratam",
                "date": "2018-01-02T15:35:40",
                "message_text_only": "Which is the most mature Lightning implementation right now? I want to\nsetup a lightning node and start experimenting with it.\n\nAlso did anybody create a protocol diagram of how lightning works? (similar\nto the one below about SSL)\n\n[image: Inline image 1]\n\nI have seen higher level diagrams but as evident from my previous mails,\nthey only touch the basic concepts and not the exact flow of events leaving\nmany doubts.  It would be really helpful to make such a detailed\nflowchart/diagram if one does not exist already.\n\nAlso, what are the current limitations/known-gaps in lightening network\nprotocol? When can its guarantees fail?\n\u1427\n\nOn Tue, Jan 2, 2018 at 8:13 PM, Johan Tor\u00e5s Halseth <johanth at gmail.com>\nwrote:\n\n> That\u2019s correct :)\n>\n> On Tue, Jan 2, 2018 at 15:34, Praveen Baratam <praveen.baratam at gmail.com>\n> wrote:\n>\n> Thank you for explaining @Hafeez & @Johan\n>\n> Now that all the BIPs necessary for LN including SegWit (Softfork) are\n> active on the mainnet, are we just waiting for the LN implementation to\n> mature or are there any other issues?\n> \u1427\n>\n> On Tue, Jan 2, 2018 at 8:01 PM, Johan Tor\u00e5s Halseth <johanth at gmail.com>\n> wrote:\n>\n>> Hi,\n>>\n>> Before you can safely broadcast the funding transaction, the two parties\n>> involved in a channel must have signed a commitment transaction spending\n>> the output from the funding transaction. Without segwit, the funding\n>> transaction can be malleated, leaving the commitment transaction invalid,\n>> and funds locked up if one of the parties stops cooperating.\n>>\n>> Cheers,\n>> Johan\n>> On Tue, Jan 2, 2018 at 15:11, Hafeez Bana <hafeez.bana at gmail.com> wrote:\n>>\n>> to fix transaction malleability\n>>\n>> On Tue, Jan 2, 2018 at 1:53 PM, Praveen Baratam <\n>> praveen.baratam at gmail.com> wrote:\n>>\n>>> Why is SegWit required for LN? If we wait for the *funding transaction*\n>>> to be *confirmed*, we can then safely create and update unconfirmed\n>>> commitment transactions...\n>>>\n>>> I don't see how SegWit is important here... Am I missing something?\n>>>\n>>> --\n>>> Dr. Praveen Baratam\n>>>\n>>> about.me <http://about.me/praveen.baratam>\n>>> \u1427\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>>\n>>\n>> _______________________________________________ Lightning-dev mailing\n>> list Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n>\n> --\n> Dr. Praveen Baratam\n>\n> about.me <http://about.me/praveen.baratam>\n>\n>\n\n\n-- \nDr. Praveen Baratam\n\nabout.me <http://about.me/praveen.baratam>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/95ab9cd8/attachment-0001.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: image.png\nType: image/png\nSize: 35857 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/95ab9cd8/attachment-0001.png>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-02T23:25:14",
                "message_text_only": "Good morning Praveen,\n\nFor some background please consider the article I wrote:\nhttps://zmnscpxj.github.io/offchain/generalized.html\n\nEspecially \"Requirements on the Blockchain\".\n\nFor cases where the funding transaction is funded by only one side, then full SegWit is not needed, \"only\" some kind of malleability fix.  However, there is the possibility in the future of funding transaction being funded by both sides, and that requires full SegWit.  Full SegWit is not only a malleability fix, but also provides the feature that an unsigned transaction has the same txid as a signed transaction. This is necessary for multi-funded funding transactions (not yet present in Lightning BOLT 1.0).\n\n> Which is the most mature Lightning implementation right now? I want to setup a lightning node and start experimenting with it.\n\nI believe lnd has the most features. There are even a few brave individuals who are experimenting with it on mainnet. Please note that those individuals have mainnet BTC to spare for this and will not miss those BTC if it becomes locked due to bugs (they are mostly using UTXOs they consider to be \"dust\" I believe), so in general you should restrict yourself to testnet for now unless you have some dust you are willing to lose.\n\n> Also did anybody create a protocol diagram of how lightning works? (similar to the one below about SSL)\n\nThe Lightning BOLT specs have many sequence diagrams: https://github.com/lightningnetwork/lightning-rfc\n\nThey are ASCII graphics, but are understandable.\n\n> [image.png]\n>\n> I have seen higher level diagrams but as evident from my previous mails, they only touch the basic concepts and not the exact flow of events leaving many doubts.  It would be really helpful to make such a detailed flowchart/diagram if one does not exist already.\n>\n> Also, what are the current limitations/known-gaps in lightening network protocol? When can its guarantees fail?\n\nThere are many. A few include:\n\n1. The same hash is used for the entire route. Spies who have many nodes can correlate routes with the same hash if the route passes through multiple different nodes they control.  This is fixable and will be fixed in a future BOLT version.\n2. Funding of channels is currently one-sided only. This is safer in general as some measure of trust and anti-DoS and so on is needed for two-sided funding of channels (i.e. if you blindly accept requests for two-sided funding, and I am much richer than you, I can start up a node or hundreds of nodes, have them request two-sided funding channels with you, then take all of them offline, leaving you with BTC locked in unuseable channels which you will have to unilaterally close (which requires delays measured in hours or days as part of the protocol)). Two-sided channel funding will probably be rejected by default by your node software and would have to be specifically enabled for nodes you trust (although that probably will not be part of the protocol itself, just the design of node software).  This will be added in a future BOLT version.\n3. Burchert-Decker-Wattenhofer channel factories are not yet part of the BOLT spec. This will reduce blockchain use even further, at the cost of a more involved process for closing channels.  This will be added in a far future BOLT version, because this is even newer tech than Lightning and will still need more design and so on.\n4. If you do any receives at all (note that routing through your node is a receive+send) you need to watch the blockchain for attempts at theft. There is some work being done, called WatchTower, that would let you delegate this watching to a third party on your behalf. You do not need to watch the blockchain if you use your node strictly for sending only (I believe Eclair has a mode for this, intended to be used for mobile devices).  This WatchTower will be added in a future BOLT version.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/2f714082/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "SegWit and LN",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Hafeez Bana",
                "Praveen Baratam",
                "ZmnSCPxj",
                "Johan Tor\u00e5s Halseth"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 12306
        }
    },
    {
        "title": "[Lightning-dev] Descriptive annotations visible to intermediate nodes",
        "thread_messages": [
            {
                "author": "Benjamin Mord",
                "date": "2018-01-03T00:32:17",
                "message_text_only": "Are there, or will there be, annotations one can add to a lightning\ntransaction that can be read by all intermediate nodes along a given route?\nConversely, can one add annotations readable only by certain specific known\n(to sender) intermediate nodes?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180102/72057803/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-04T00:01:54",
                "message_text_only": "Good morning Benjamin,\n\nIt may be possible to embed this information in the hash preimage of the receiver. Alternatively it would be possible to create a new realm to provide such annotations to specific nodes on the route that support that realm (nodes that do not support this annotation realm would not need to be aware of it).\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: [Lightning-dev] Descriptive annotations visible to intermediate nodes\n> Local Time: January 3, 2018 12:32 AM\n> UTC Time: January 3, 2018 12:32 AM\n> From: ben at mord.io\n> To: lightning-dev at lists.linuxfoundation.org\n>\n> Are there, or will there be, annotations one can add to a lightning transaction that can be read by all intermediate nodes along a given route? Conversely, can one add annotations readable only by certain specific known (to sender) intermediate nodes?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180103/24727414/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-04T17:13:10",
                "message_text_only": "Hi Benjamin,\n\ncurrently the only piece of information that is kept contstant along the\nentire route is the payment hash, and we will be removing that as well\nin order to further decorrelate hops of a payment and make it harder for\nforwarding nodes to collate hops into a route.\n\nAs ZmnSCPxj has pointed out we do have the possibility of adding some\ninformation in the onion packet. You can even give every single hop its\nvery specific information in the onion. Say for example you have a node\nthat does currency conversion, you may specify the desired exchange rate\nin the onion.\n\nMay I ask what use-case you are looking to implement using this feature?\n\nCheers,\nChristian\n\nBenjamin Mord <ben at mord.io> writes:\n> Are there, or will there be, annotations one can add to a lightning\n> transaction that can be read by all intermediate nodes along a given route?\n> Conversely, can one add annotations readable only by certain specific known\n> (to sender) intermediate nodes?\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-11T16:40:56",
                "message_text_only": "Thanks Christian. I'm reading the BOLTs and reviewing source code now, so\nperhaps my question / request will be more usefully specific once I've\nfinished that review. Sorry for being vague as to use case for now, let me\njust point out that the concept of source routing opens up a lot of\npotential use cases that involve collaborations with intermediaries of\nvarious sorts, but for which flexible communication capability would be\ndesirable or required (unless you do that out-of-band, which would be so\nmessy as to largely defeat the point.)\n\nI'm impressed so far by how cleanly and explicitly the BOLTs address\nextensibility. I find that reassuring, many thanks to whoever applied their\ntechnical creativity to this aspect.\n\nWas there a BOLT #6?\n\nOn Thu, Jan 4, 2018 at 12:13 PM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> Hi Benjamin,\n>\n> currently the only piece of information that is kept contstant along the\n> entire route is the payment hash, and we will be removing that as well\n> in order to further decorrelate hops of a payment and make it harder for\n> forwarding nodes to collate hops into a route.\n>\n> As ZmnSCPxj has pointed out we do have the possibility of adding some\n> information in the onion packet. You can even give every single hop its\n> very specific information in the onion. Say for example you have a node\n> that does currency conversion, you may specify the desired exchange rate\n> in the onion.\n>\n> May I ask what use-case you are looking to implement using this feature?\n>\n> Cheers,\n> Christian\n>\n> Benjamin Mord <ben at mord.io> writes:\n> > Are there, or will there be, annotations one can add to a lightning\n> > transaction that can be read by all intermediate nodes along a given\n> route?\n> > Conversely, can one add annotations readable only by certain specific\n> known\n> > (to sender) intermediate nodes?\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/011a25a2/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-11T23:06:26",
                "message_text_only": "Hi Benjamin,\n\nyes, there was a BOLT#6. It was a trivial bootstrapping mechanism I set up\nusing IRC (like the original bitcoin client), but we retired it in favor of\nDNS seeds and gossiping.\n\nCheers,\nChristian\n\nOn Thu, Jan 11, 2018 at 5:40 PM Benjamin Mord <ben at mord.io> wrote:\n\n>\n> Thanks Christian. I'm reading the BOLTs and reviewing source code now, so\n> perhaps my question / request will be more usefully specific once I've\n> finished that review. Sorry for being vague as to use case for now, let me\n> just point out that the concept of source routing opens up a lot of\n> potential use cases that involve collaborations with intermediaries of\n> various sorts, but for which flexible communication capability would be\n> desirable or required (unless you do that out-of-band, which would be so\n> messy as to largely defeat the point.)\n>\n> I'm impressed so far by how cleanly and explicitly the BOLTs address\n> extensibility. I find that reassuring, many thanks to whoever applied their\n> technical creativity to this aspect.\n>\n> Was there a BOLT #6?\n>\n> On Thu, Jan 4, 2018 at 12:13 PM, Christian Decker <\n> decker.christian at gmail.com> wrote:\n>\n>> Hi Benjamin,\n>>\n>> currently the only piece of information that is kept contstant along the\n>> entire route is the payment hash, and we will be removing that as well\n>> in order to further decorrelate hops of a payment and make it harder for\n>> forwarding nodes to collate hops into a route.\n>>\n>> As ZmnSCPxj has pointed out we do have the possibility of adding some\n>> information in the onion packet. You can even give every single hop its\n>> very specific information in the onion. Say for example you have a node\n>> that does currency conversion, you may specify the desired exchange rate\n>> in the onion.\n>>\n>> May I ask what use-case you are looking to implement using this feature?\n>>\n>> Cheers,\n>> Christian\n>>\n>> Benjamin Mord <ben at mord.io> writes:\n>> > Are there, or will there be, annotations one can add to a lightning\n>> > transaction that can be read by all intermediate nodes along a given\n>> route?\n>> > Conversely, can one add annotations readable only by certain specific\n>> known\n>> > (to sender) intermediate nodes?\n>> > _______________________________________________\n>> > Lightning-dev mailing list\n>> > Lightning-dev at lists.linuxfoundation.org\n>> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/6beac273/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Descriptive annotations visible to intermediate nodes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "ZmnSCPxj",
                "Benjamin Mord"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 7551
        }
    },
    {
        "title": "[Lightning-dev] rfc using payment_hash fields txn vs the others",
        "thread_messages": [
            {
                "author": "dreamwvr",
                "date": "2018-01-05T09:55:41",
                "message_text_only": "Hi,\nThe donation payment_hash txn field layout is diff \nin the second lines stanza. Instead it goes right to the \nbes32 static int. Why is does it not use say a 0x20\nto indicate not a bc value or reserved value to indicate\nno bc value in txn?\n\nwould it not simpify optimizing for any sort of deep inspection?\nlnbc <- network to mainnet field\n1 <- bes32 field\n1234567 <- epochtimestmp\n(..)\n\nthe rest layout their fields like..\nlnbc <- network to mainnet field\nbcvalue <- some bc value\n1 <- bes32 field\n(...)\n\nsimplified with a..\nlnbc <- network to mainnet field\nnone_bc_value <- reserved hex value says this is hash_payment\n1 <- bes32\n(...)\n\nnothing more to see here.. just a pseudo random thought. =)\n\nBest Regards,\ndreamwvr at dreamwvr.com"
            },
            {
                "author": "dreamwvr",
                "date": "2018-01-06T09:10:36",
                "message_text_only": "Subject: Re: [Lightning-dev] rfc using payment_hash fields txn vs the others\nReply-To:  dreamwvr <dreamwvr at dreamwvr.com>\n \nIn-Reply-To: <20180105095541.GA6376 at dreamwvr.com>\n\n\n\nOn Fri, Jan 05, 2018 at 02:55:41AM -0700, dreamwvr wrote:\n> \n> Hi,\n> The donation payment_hash txn field layout is diff \n> in the second lines stanza. Instead it goes right to the \n> bes32 static int. Why is does it not use say a 0x20\n> to indicate not a bc value or reserved value to indicate\n> no bc value in txn?\n> \n> would it not simpify optimizing for any sort of deep inspection?\n> lnbc <- network to mainnet field\n> 1 <- bes32 field\n> 1234567 <- epochtimestmp\n> (..)\n> \n> the rest layout their fields like..\n> lnbc <- network to mainnet field\n> bcvalue <- some bc value\n> 1 <- bes32 field\n> (...)\n> \n> simplified with a..\n> lnbc <- network to mainnet field\n> none_bc_value <- reserved hex value says this is hash_payment\n> 1 <- bes32\n> (...)\n> \nwith the rfc donation example with the\nlnbc <- network to mainnet field \n_second_field_ <- say some reserved hex value for hash_payment\n1 <- bes32 \n(...)\nnow if _second_field_ is added like all the others then there is say\npotential to add bid on item value using bc value. Since a bid does\nnot mean in auction that a buyer gets to purchase on a item. It just\nsays they bid on it. so if there is a..\nlnbc <- network to mainnet field\n_second_field_ <- either bc value or reserved hex indicates either\n                  donation where another reserved hex value indicates\n                  secured bid on an item a buyer wants to acquire?\n1 <- bes32\n(...)\nanother semi random thought.\nBest Regards,\ndreamwvr at dreamwvr.com"
            }
        ],
        "thread_summary": {
            "title": "rfc using payment_hash fields txn vs the others",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "dreamwvr"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 2395
        }
    },
    {
        "title": "[Lightning-dev] Invoice without amount",
        "thread_messages": [
            {
                "author": "Cezary Dziemian",
                "date": "2018-01-06T14:04:39",
                "message_text_only": "Hello,\n\nIt looks \"amount\" is optional for invoice:\n\nhttps://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md\n\nThe issue is I cannot generate such invoice using lnd. This is very\nimportant for what we are tryiong to do with LN. Can you confirm, that\nvalue will be optional for LN invoice.\n\nOr at least, thet there is some other way to send payment when sender\nspecifies amount.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180106/d7a97460/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-08T06:22:44",
                "message_text_only": "Good morning Cezary,\n\nCurrently, c-lightning can PAY amountless invoices via the \"pay\" command, but cannot CREATE them via the c-lightning \"invoice\" command.\n\nTo pay an amountless invoice lntb... 4 satoshis in c-lightning: lightning-cli pay lntb.. 4000\n\nHowever the internals of c-lightning should be able to handle creating amountless invoices (it is only the JSON-RPC command itself which requires the amount, but the rest of the code treats it as optional).  I will see what I can do to make creating amountless invoices in c-lightning possible.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: [Lightning-dev] Invoice without amount\n> Local Time: January 6, 2018 10:04 PM\n> UTC Time: January 6, 2018 2:04 PM\n> From: cezary.dziemian at gmail.com\n> To: lightning-dev at lists.linuxfoundation.org\n>\n> Hello,\n>\n> It looks \"amount\" is optional for invoice:\n>\n> https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md\n>\n> The issue is I cannot generate such invoice using lnd. This is very important for what we are tryiong to do with LN. Can you confirm, that value will be optional for LN invoice.\n>\n> Or at least, thet there is some other way to send payment when sender specifies amount.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180108/208c416d/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-01-09T04:31:01",
                "message_text_only": "ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> writes:\n\n> Good morning Cezary,\n>\n> Currently, c-lightning can PAY amountless invoices via the \"pay\" command, but cannot CREATE them via the c-lightning \"invoice\" command.\n\nGood point, I've filed an issue for this, so we don't lose it:\n\n        https://github.com/ElementsProject/lightning/issues/534\n\n> To pay an amountless invoice lntb... 4 satoshis in c-lightning: lightning-cli pay lntb.. 4000\n\nNote that I'd prefer the \"msatoshi\" field to be a magic string\n(eg. \"any\") rather than omitting the parameter, since it's too easy for\na bug to omit the parameter.\n\nCheers,\nRusty."
            },
            {
                "author": "Cezary Dziemian",
                "date": "2018-01-09T13:21:37",
                "message_text_only": "Good news, thanks.\n\nDo Lightning Labs also have plan to introduce this soon? I prefer to stay\nwith lnd, as we already know this implementation better, but if this option\nwill not be introduced soon, we have to switch to use c-lightning.\n\nCheers,\nCezary\n\n2018-01-09 5:31 GMT+01:00 Rusty Russell <rusty at rustcorp.com.au>:\n\n> ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n> writes:\n>\n> > Good morning Cezary,\n> >\n> > Currently, c-lightning can PAY amountless invoices via the \"pay\"\n> command, but cannot CREATE them via the c-lightning \"invoice\" command.\n>\n> Good point, I've filed an issue for this, so we don't lose it:\n>\n>         https://github.com/ElementsProject/lightning/issues/534\n>\n> > To pay an amountless invoice lntb... 4 satoshis in c-lightning:\n> lightning-cli pay lntb.. 4000\n>\n> Note that I'd prefer the \"msatoshi\" field to be a magic string\n> (eg. \"any\") rather than omitting the parameter, since it's too easy for\n> a bug to omit the parameter.\n>\n> Cheers,\n> Rusty.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180109/8620ec4c/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2018-01-10T23:21:01",
                "message_text_only": "Hi Cezary,\n\nI invite you to make an issue on lnd's issue tracker:\nhttps://github.com/lightningnetwork/lnd/issues. This list isn't the place\nfor support requests/features for individual implementations.\n\nOn Tue, Jan 9, 2018 at 5:21 AM Cezary Dziemian <cezary.dziemian at gmail.com>\nwrote:\n\n> Good news, thanks.\n>\n> Do Lightning Labs also have plan to introduce this soon? I prefer to stay\n> with lnd, as we already know this implementation better, but if this option\n> will not be introduced soon, we have to switch to use c-lightning.\n>\n> Cheers,\n> Cezary\n>\n> 2018-01-09 5:31 GMT+01:00 Rusty Russell <rusty at rustcorp.com.au>:\n>\n>> ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n>> writes:\n>>\n>> > Good morning Cezary,\n>> >\n>> > Currently, c-lightning can PAY amountless invoices via the \"pay\"\n>> command, but cannot CREATE them via the c-lightning \"invoice\" command.\n>>\n>> Good point, I've filed an issue for this, so we don't lose it:\n>>\n>>         https://github.com/ElementsProject/lightning/issues/534\n>>\n>> > To pay an amountless invoice lntb... 4 satoshis in c-lightning:\n>> lightning-cli pay lntb.. 4000\n>>\n>> Note that I'd prefer the \"msatoshi\" field to be a magic string\n>> (eg. \"any\") rather than omitting the parameter, since it's too easy for\n>> a bug to omit the parameter.\n>>\n>> Cheers,\n>> Rusty.\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180110/69b80acf/attachment.html>"
            },
            {
                "author": "Cezary Dziemian",
                "date": "2018-01-11T17:16:31",
                "message_text_only": "I made issue 5 days ago: https://github.com/lightningnetwork/lnd/issues/564\n\n2018-01-11 0:21 GMT+01:00 Olaoluwa Osuntokun <laolu32 at gmail.com>:\n\n>\n> Hi Cezary,\n>\n> I invite you to make an issue on lnd's issue tracker: https://github.com/\n> lightningnetwork/lnd/issues. This list isn't the place for support\n> requests/features for individual implementations.\n>\n> On Tue, Jan 9, 2018 at 5:21 AM Cezary Dziemian <cezary.dziemian at gmail.com>\n> wrote:\n>\n>> Good news, thanks.\n>>\n>> Do Lightning Labs also have plan to introduce this soon? I prefer to stay\n>> with lnd, as we already know this implementation better, but if this option\n>> will not be introduced soon, we have to switch to use c-lightning.\n>>\n>> Cheers,\n>> Cezary\n>>\n>> 2018-01-09 5:31 GMT+01:00 Rusty Russell <rusty at rustcorp.com.au>:\n>>\n>>> ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org>\n>>> writes:\n>>>\n>>> > Good morning Cezary,\n>>> >\n>>> > Currently, c-lightning can PAY amountless invoices via the \"pay\"\n>>> command, but cannot CREATE them via the c-lightning \"invoice\" command.\n>>>\n>>> Good point, I've filed an issue for this, so we don't lose it:\n>>>\n>>>         https://github.com/ElementsProject/lightning/issues/534\n>>>\n>>> > To pay an amountless invoice lntb... 4 satoshis in c-lightning:\n>>> lightning-cli pay lntb.. 4000\n>>>\n>>> Note that I'd prefer the \"msatoshi\" field to be a magic string\n>>> (eg. \"any\") rather than omitting the parameter, since it's too easy for\n>>> a bug to omit the parameter.\n>>>\n>>> Cheers,\n>>> Rusty.\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/c3982401/attachment.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-11T17:47:53",
                "message_text_only": "Hi, Cezary,\nI initially read the issue you created as a bug filing, my bad. I\u2019ve updated it to reflect that it is a feature request.\nCheers! Johan\n\nOn Thu, Jan 11, 2018 at 18:16, Cezary Dziemian <cezary.dziemian at gmail.com> wrote:\nI made issue 5 days ago: https://github.com/lightningnetwork/lnd/issues/564 [https://github.com/lightningnetwork/lnd/issues/564]\n2018-01-11 0:21 GMT+01:00 Olaoluwa Osuntokun < laolu32 at gmail.com [laolu32 at gmail.com] > :\n\nHi Cezary,\nI invite you to make an issue on lnd's issue tracker: https://github.com/ lightningnetwork/lnd/issues [https://github.com/lightningnetwork/lnd/issues] . This list isn't the place for support requests/features for individual implementations.\nOn Tue, Jan 9, 2018 at 5:21 AM Cezary Dziemian < cezary.dziemian at gmail.com [cezary.dziemian at gmail.com] > wrote:\nGood news, thanks.\n\nDo Lightning Labs also have plan to introduce this soon? I prefer to stay with lnd, as we already know this implementation better, but if this option will not be introduced soon, we have to switch to use c-lightning.\n\nCheers,\nCezary\n2018-01-09 5:31 GMT+01:00 Rusty Russell < rusty at rustcorp.com.au [rusty at rustcorp.com.au] > :\nZmnSCPxj via Lightning-dev < lightning-dev at lists. linuxfoundation.org [lightning-dev at lists.linuxfoundation.org] > writes:\n\n> Good morning Cezary,\n>\n> Currently, c-lightning can PAY amountless invoices via the \"pay\" command, but cannot CREATE them via the c-lightning \"invoice\" command.\n\nGood point, I've filed an issue for this, so we don't lose it:\n\nhttps://github.com/ ElementsProject/lightning/ issues/534 [https://github.com/ElementsProject/lightning/issues/534]\n\n> To pay an amountless invoice lntb... 4 satoshis in c-lightning: lightning-cli pay lntb.. 4000\n\nNote that I'd prefer the \"msatoshi\" field to be a magic string\n(eg. \"any\") rather than omitting the parameter, since it's too easy for\na bug to omit the parameter.\n\nCheers,\nRusty.\n\n______________________________ _________________\nLightning-dev mailing list\nLightning-dev at lists. linuxfoundation.org [Lightning-dev at lists.linuxfoundation.org]\nhttps://lists.linuxfoundation. org/mailman/listinfo/ lightning-dev [https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev]\n\n\n_______________________________________________ Lightning-dev mailing list Lightning-dev at lists.linuxfoundation.org https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/36620dd6/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Invoice without amount",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Cezary Dziemian",
                "Johan Tor\u00e5s Halseth",
                "Rusty Russell",
                "Olaoluwa Osuntokun",
                "ZmnSCPxj"
            ],
            "messages_count": 7,
            "total_messages_chars_count": 10169
        }
    },
    {
        "title": "[Lightning-dev] [1.1] Proposed `funding_cancelled` message",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-08T03:26:23",
                "message_text_only": "Good morning Lightning world,\n\nhttps://github.com/lightningnetwork/lightning-rfc/pull/349\n\nI propose in the above pull request a new `funding_cancelled` message intended to inform the fundee node that the funder node is definitely sure that the channel funding transaction can never confirm.\n\nThis thread is intended to open a discussion for this proposed message, to be added to v1.1 spec.\n\nThe reason for including this message is the below:\n\n1.  Implementing this message should not be onerous, if the node software already implements code to forget the channel after a timeout. We simply trigger this code if the channel funding transaction times out or if this message is received.\n2.  It allows replace-by-fee funding transactions. To replace an RBF funding transaction, the funder simply re-initiates the opening protocol from `open_channel` -> `acccept_channel` -> `funding_created` -> `funding_signed`, then broadcasts the replacement funding transaction.  Then both funder and fundee wait for either the old or the new funding transaction to confirm (miners might reject replacements, or the new funding transactions might simply not have propagated to the miner at the time of mining a new block), and once one of the transactions is confirmed deeply enough, the funder cancels the other funding transaction via `funding_cancelled`.\n3.  It allows multi-channel funding transactions.  To fund multiple channels from a single transaction, the funder initiates the opening protocol to each node separately.  However, the funder must not boradcast the funding transaction until all fundees reply `funding_signed`.  If some fundees complete the protocol up to `funding_signed` but some fundees time out or fail/cannot contact, then the funder cannot safely broadcast the funding transaction at all. The funder node can then send `funding_cancelled` to each fundee that completed up to `funding_signed` to free resources of those nodes.\n\nIn principle the message is unnecessary if funding timeout is implemented by the fundee node. However, this message lets the funder node free up resources on the fundee node.\n\nAdmittedly, implementing RBF funding transactions and multi-channel funding transactions is more involved than implementing `funding_cancelled`,\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180107/1f052636/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-01-08T14:42:01",
                "message_text_only": "I have to say I'm rather not a fan of this idea. Adding messages which do not result in different node behavior other then waiting for the timeout with little overhead on the node to simply keep watching for the funding transaction is a recipe for ending up with a needlessly complex protocol and misimplementation.\n\nOn January 8, 2018 3:26:23 AM UTC, ZmnSCPxj via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n>Good morning Lightning world,\n>\n>https://github.com/lightningnetwork/lightning-rfc/pull/349\n>\n>I propose in the above pull request a new `funding_cancelled` message\n>intended to inform the fundee node that the funder node is definitely\n>sure that the channel funding transaction can never confirm.\n>\n>This thread is intended to open a discussion for this proposed message,\n>to be added to v1.1 spec.\n>\n>The reason for including this message is the below:\n>\n>1.  Implementing this message should not be onerous, if the node\n>software already implements code to forget the channel after a timeout.\n>We simply trigger this code if the channel funding transaction times\n>out or if this message is received.\n>2.  It allows replace-by-fee funding transactions. To replace an RBF\n>funding transaction, the funder simply re-initiates the opening\n>protocol from `open_channel` -> `acccept_channel` -> `funding_created`\n>-> `funding_signed`, then broadcasts the replacement funding\n>transaction.  Then both funder and fundee wait for either the old or\n>the new funding transaction to confirm (miners might reject\n>replacements, or the new funding transactions might simply not have\n>propagated to the miner at the time of mining a new block), and once\n>one of the transactions is confirmed deeply enough, the funder cancels\n>the other funding transaction via `funding_cancelled`.\n>3.  It allows multi-channel funding transactions.  To fund multiple\n>channels from a single transaction, the funder initiates the opening\n>protocol to each node separately.  However, the funder must not\n>boradcast the funding transaction until all fundees reply\n>`funding_signed`.  If some fundees complete the protocol up to\n>`funding_signed` but some fundees time out or fail/cannot contact, then\n>the funder cannot safely broadcast the funding transaction at all. The\n>funder node can then send `funding_cancelled` to each fundee that\n>completed up to `funding_signed` to free resources of those nodes.\n>\n>In principle the message is unnecessary if funding timeout is\n>implemented by the fundee node. However, this message lets the funder\n>node free up resources on the fundee node.\n>\n>Admittedly, implementing RBF funding transactions and multi-channel\n>funding transactions is more involved than implementing\n>`funding_cancelled`,\n>\n>Regards,\n>ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180108/de444926/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-09T05:25:29",
                "message_text_only": "Good morning Matt,\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] [1.1] Proposed `funding_cancelled` message\n> Local Time: January 8, 2018 10:42 PM\n> UTC Time: January 8, 2018 2:42 PM\n> From: lf-lists at mattcorallo.com\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>, lightning-dev\\\\@lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>\n> I have to say I'm rather not a fan of this idea. Adding messages which do not result in different node behavior other then waiting for the timeout with little overhead on the node to simply keep watching for the funding transaction is a recipe for ending up with a needlessly complex protocol and misimplementation.\n\nThere is no specified timeout for funding transactions, and thus a fundee node may keep track of funding transactions until end-of-life.  This is a concern since replaceable funding transactions require that all versions be monitored on the blockchain - there is always the possibility that the winning miner got older versions of the funding transaction.\n\nTo my mind, a sketch of an implementation for `funding_cancelled` requires only to delete an entry in a database of transactions to be watched.\n\nImplementing replacable funding transactions require an implementation to keep track of all versions of the funding transaction, as well as the state (\"waiting for accept_channel\", \"waiting for funding_signed\", \"waiting for confirmation\") of each funding transaction version. You would also link all those versions together - for example you might have a separate table containing an ID column that you allocate for each channel open attempt, and separate this from the funding transaction table (which would have a foreign key to the openings table).  If one funding transaction confirms \"deeply enough\", then you send `funding_cancelled` for each other funding transaction.\n\nNote that the complexity here for replace-by-fee funding transactions is due solely to the fact that miners have the choice of mining any version of the transaction.  It is possible that a miner deliberately chooses an older version, or (more realistically) that a race condition occurs where you broadcast the replacement but the miner has already won a block before the replacement propagated to it.  Thus the funder (who initially owns all coins in the channel) needs to keep track of all versions of the funding transaction it broadcast, regardless.  But of course it will want to not consume its own resources watching for transactions that can never confirm if another transaction has deeply confirmed, and it will delete such entries from its database; sending `funding_cancelled` in this case is simply \"being nice\", and the fundee ignores this at its own detriment, wasting resources each block to check for a transaction that logically can never confirm.\n\nIn any case, how would you implement replace-by-fee funding transactions?\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180109/993ca27d/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-01-15T01:00:20",
                "message_text_only": "Sounds to me like the lack of a protocol-required minimum timeout is the issue. Because the cost of tracking an unopened channel is relatively trivial, I see limited reason to bother notifying the peer that a channel has timed out. However, due to potentially radically different concepts for what is and isn't an acceptable wait time, it's likely useful to have something like \"a receiving node MUST keep a channel ready to be used for at least a week prior to funding transaction confirmation. Thus, a node creating a funding transaction SHOULD double-spend and make unconfirmable a funding transaction which has not confirmed prior to a week.\"\n\nNote that obviously a node can keep the initial commitment transaction around and just wait forever and if the funding transaction ever confirms it can go broadcast the initial commitment transaction then, but it's much nicer to be able to simply double spend via RBF.\n\nGiven the relative simplicity on the receiving end, this could even be slipped in to the spec today prior to v1.1.\n\nCue bikeshedding.\n\nOn January 9, 2018 5:25:29 AM UTC, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>Good morning Matt,\n>\n>> -------- Original Message --------\n>> Subject: Re: [Lightning-dev] [1.1] Proposed `funding_cancelled`\n>message\n>> Local Time: January 8, 2018 10:42 PM\n>> UTC Time: January 8, 2018 2:42 PM\n>> From: lf-lists at mattcorallo.com\n>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>,\n>lightning-dev\\\\@lists.linuxfoundation.org\n><lightning-dev at lists.linuxfoundation.org>\n>>\n>> I have to say I'm rather not a fan of this idea. Adding messages\n>which do not result in different node behavior other then waiting for\n>the timeout with little overhead on the node to simply keep watching\n>for the funding transaction is a recipe for ending up with a needlessly\n>complex protocol and misimplementation.\n>\n>There is no specified timeout for funding transactions, and thus a\n>fundee node may keep track of funding transactions until end-of-life. \n>This is a concern since replaceable funding transactions require that\n>all versions be monitored on the blockchain - there is always the\n>possibility that the winning miner got older versions of the funding\n>transaction.\n>\n>To my mind, a sketch of an implementation for `funding_cancelled`\n>requires only to delete an entry in a database of transactions to be\n>watched.\n>\n>Implementing replacable funding transactions require an implementation\n>to keep track of all versions of the funding transaction, as well as\n>the state (\"waiting for accept_channel\", \"waiting for funding_signed\",\n>\"waiting for confirmation\") of each funding transaction version. You\n>would also link all those versions together - for example you might\n>have a separate table containing an ID column that you allocate for\n>each channel open attempt, and separate this from the funding\n>transaction table (which would have a foreign key to the openings\n>table).  If one funding transaction confirms \"deeply enough\", then you\n>send `funding_cancelled` for each other funding transaction.\n>\n>Note that the complexity here for replace-by-fee funding transactions\n>is due solely to the fact that miners have the choice of mining any\n>version of the transaction.  It is possible that a miner deliberately\n>chooses an older version, or (more realistically) that a race condition\n>occurs where you broadcast the replacement but the miner has already\n>won a block before the replacement propagated to it.  Thus the funder\n>(who initially owns all coins in the channel) needs to keep track of\n>all versions of the funding transaction it broadcast, regardless.  But\n>of course it will want to not consume its own resources watching for\n>transactions that can never confirm if another transaction has deeply\n>confirmed, and it will delete such entries from its database; sending\n>`funding_cancelled` in this case is simply \"being nice\", and the fundee\n>ignores this at its own detriment, wasting resources each block to\n>check for a transaction that logically can never confirm.\n>\n>In any case, how would you implement replace-by-fee funding\n>transactions?\n>\n>Regards,\n>ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180115/18f95f71/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-15T02:14:57",
                "message_text_only": "Good morning Matt,\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] [1.1] Proposed `funding_cancelled` message\n> Local Time: January 15, 2018 9:00 AM\n> UTC Time: January 15, 2018 1:00 AM\n> From: lf-lists at mattcorallo.com\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> lightning-dev\\\\\\\\@lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>\n> Sounds to me like the lack of a protocol-required minimum timeout is the issue. Because the cost of tracking an unopened channel is relatively trivial, I see limited reason to bother notifying the peer that a channel has timed out. However, due to potentially radically different concepts for what is and isn't an acceptable wait time, it's likely useful to have something like \"a receiving node MUST keep a channel ready to be used for at least a week prior to funding transaction confirmation. Thus, a node creating a funding transaction SHOULD double-spend and make unconfirmable a funding transaction which has not confirmed prior to a week.\"\n\nThough the cost may be trivial for single channels, the cost can be made arbitrarily high by a malicious node that just keeps sending `open_channel` -> `funding_created` with random numbers for transaction ID.  It seems sensible for a node implementation to allow limiting the number of pending channel opens for each peer to avoid this (e.g. c-lightning currently limits one-channel-one-peer, even at opening).  The intent of `funding_cancelled` is: an honest party can free up the limited resource \"number of pending channel opens\" by using this message, without having to wait for the timeout, whatever the timeout is defined to be.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/ae2b573c/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-01-15T02:33:39",
                "message_text_only": "I can't imagine the constants add up that fast... Allow 25 channels per peer and limit your peers reasonably and the cost should be low enough. Really not sure why something like a 25 channel limit should limit any usage or reasonably burden a node, what am I missing?\n\nOn January 15, 2018 2:14:57 AM UTC, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>Good morning Matt,\n>\n>Sent with [ProtonMail](https://protonmail.com) Secure Email.\n>\n>> -------- Original Message --------\n>> Subject: Re: [Lightning-dev] [1.1] Proposed `funding_cancelled`\n>message\n>> Local Time: January 15, 2018 9:00 AM\n>> UTC Time: January 15, 2018 1:00 AM\n>> From: lf-lists at mattcorallo.com\n>> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>> lightning-dev\\\\\\\\@lists.linuxfoundation.org\n><lightning-dev at lists.linuxfoundation.org>\n>>\n>> Sounds to me like the lack of a protocol-required minimum timeout is\n>the issue. Because the cost of tracking an unopened channel is\n>relatively trivial, I see limited reason to bother notifying the peer\n>that a channel has timed out. However, due to potentially radically\n>different concepts for what is and isn't an acceptable wait time, it's\n>likely useful to have something like \"a receiving node MUST keep a\n>channel ready to be used for at least a week prior to funding\n>transaction confirmation. Thus, a node creating a funding transaction\n>SHOULD double-spend and make unconfirmable a funding transaction which\n>has not confirmed prior to a week.\"\n>\n>Though the cost may be trivial for single channels, the cost can be\n>made arbitrarily high by a malicious node that just keeps sending\n>`open_channel` -> `funding_created` with random numbers for transaction\n>ID.  It seems sensible for a node implementation to allow limiting the\n>number of pending channel opens for each peer to avoid this (e.g.\n>c-lightning currently limits one-channel-one-peer, even at opening). \n>The intent of `funding_cancelled` is: an honest party can free up the\n>limited resource \"number of pending channel opens\" by using this\n>message, without having to wait for the timeout, whatever the timeout\n>is defined to be.\n>\n>Regards,\n>ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180115/d84388d9/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-15T02:53:07",
                "message_text_only": "Good morning Matt,\n\n> I can't imagine the constants add up that fast... Allow 25 channels per peer and limit your peers reasonably and the cost should be low enough. Really not sure why something like a 25 channel limit should limit any usage or reasonably burden a node, what am I missing?\n\nYou impose this 25 channels per peer.  I start opening a channel to you.  Because I did not check mempool or because my fee-estimation algo is bad, I pay too low a fee.  I become impatient and bump it up, which you perceive as another open (so it is now 2/25 channels).  Unfortunately I only bumped my fee by a tiny amount, because reasons.  I bump the fees upwards for example five more times, each of which you perceive as another channel open, so from your side it looks like I am consuming 7/25 channels.  Finally the funding transaction confirms, but the 6 previous transactions are perceived by you as unconfirmed channel opens, so you will still keep the 6 channels accounted in your 25-channel-limit.\n\nSuppose in a few days (i.e. much less than a week) I decide to have three more channels to you.  If I go through all that (starting with low fee, bumping up fee, etc) then I may very well run out of the available 25 channels to you, even though I only really have 1 channel already opened and am trying to make an additional 3 channels only.\n\nGranted this is somewhat contrived, but it shows what I wish to avoid with `funding_cancelled`.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/f05d4b7e/attachment.html>"
            },
            {
                "author": "Matt Corallo",
                "date": "2018-01-15T23:25:24",
                "message_text_only": "Ok, so limit things to 100 channels... Still don't see why the constants get into unreasonable load here...\n\nOn January 15, 2018 2:53:07 AM UTC, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>Good morning Matt,\n>\n>> I can't imagine the constants add up that fast... Allow 25 channels\n>per peer and limit your peers reasonably and the cost should be low\n>enough. Really not sure why something like a 25 channel limit should\n>limit any usage or reasonably burden a node, what am I missing?\n>\n>You impose this 25 channels per peer.  I start opening a channel to\n>you.  Because I did not check mempool or because my fee-estimation algo\n>is bad, I pay too low a fee.  I become impatient and bump it up, which\n>you perceive as another open (so it is now 2/25 channels). \n>Unfortunately I only bumped my fee by a tiny amount, because reasons. \n>I bump the fees upwards for example five more times, each of which you\n>perceive as another channel open, so from your side it looks like I am\n>consuming 7/25 channels.  Finally the funding transaction confirms, but\n>the 6 previous transactions are perceived by you as unconfirmed channel\n>opens, so you will still keep the 6 channels accounted in your\n>25-channel-limit.\n>\n>Suppose in a few days (i.e. much less than a week) I decide to have\n>three more channels to you.  If I go through all that (starting with\n>low fee, bumping up fee, etc) then I may very well run out of the\n>available 25 channels to you, even though I only really have 1 channel\n>already opened and am trying to make an additional 3 channels only.\n>\n>Granted this is somewhat contrived, but it shows what I wish to avoid\n>with `funding_cancelled`.\n>\n>Regards,\n>ZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180115/87ac7cd0/attachment.html>"
            },
            {
                "author": "7riw77 at gmail.com",
                "date": "2018-01-18T11:03:58",
                "message_text_only": "> \tYou impose this 25 channels per peer.  I start opening a channel to\n> you.  Because I did not check mempool or because my fee-estimation algo is\n> bad, I pay too low a fee.  I become impatient and bump it up, which you\n> perceive as another open (so it is now 2/25 channels).\n\nIt seems, to me, that this example could be pretty easily extended to 1000, or 2000, or -- pretty much anything. In fact, this brings up an important'ish point, possibly. If every channel I \"try to open,\" and then fail to, counts as resources of any kind on the receiver, we've just added a perfect attack surface for a denial of service. However this is arranged, it needs to be arranged in a way that does not have (or at least has a minimal number of) fixed pool of resources/magic numbers of any kind that can be exhausted, after which things \"no longer work.\" To do otherwise is to practically invite someone taking the entire network down with a well-planned/executed process that exhausts this resource across a large number of critical nodes (and there will be critical nodes -- it's just a part of graph theory that this will happen).\n\n\ud83d\ude0a /r"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-20T04:49:03",
                "message_text_only": "As mentioned in the text, this is imposed  by you on each peer that connects to you. The point is to prevent a single peer from consuming all your memory and CPU and prevent you from servicing legitimate peers- i.e. it prevents denial of service using a single peer and forces attackers to use a *distributed* denial of service.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n-------- Original Message --------\nOn January 18, 2018 7:03 PM, <7riw77 at gmail.com> wrote:\n\n>\n>\n>> You impose this 25 channels per peer. I start opening a channel to\n>> you. Because I did not check mempool or because my fee-estimation algo is\n>> bad, I pay too low a fee. I become impatient and bump it up, which you\n>> perceive as another open (so it is now 2/25 channels).\n>\n> It seems, to me, that this example could be pretty easily extended to 1000, or 2000, or -- pretty much anything. In fact, this brings up an important'ish point, possibly. If every channel I \"try to open,\" and then fail to, counts as resources of any kind on the receiver, we've just added a perfect attack surface for a denial of service. However this is arranged, it needs to be arranged in a way that does not have (or at least has a minimal number of) fixed pool of resources/magic numbers of any kind that can be exhausted, after which things \"no longer work.\" To do otherwise is to practically invite someone taking the entire network down with a well-planned/executed process that exhausts this resource across a large number of critical nodes (and there will be critical nodes -- it's just a part of graph theory that this will happen).\n>\n> \ud83d\ude0a /r\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180119/3c21300b/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2018-01-08T18:28:35",
                "message_text_only": "Hello,\n\n> intended to inform the fundee node that the funder node is definitely sure that the channel funding transaction can never confirm\n\nIf the deprecated tx initially sent funds to the fundee via push_msat,\nthen the fundee may not want to trust the funder on this. One way to\ndo it trustlessly would be for the funder to attach the actual\ndeprecated funding tx (not necessarily signed, but still could be big)\nto the `funding_cancelled` message, then the fundee would be able to\nverify that its inputs have indeed been spent by the overriding tx.\n\nCheers,\n\nPierre"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-09T05:44:14",
                "message_text_only": "Good morning,\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] [1.1] Proposed `funding_cancelled` message\n> Local Time: January 9, 2018 2:28 AM\n> UTC Time: January 8, 2018 6:28 PM\n> From: pm+lists at acinq.fr\n> To: ZmnSCPxj <ZmnSCPxj at protonmail.com>\n> lightning-dev\\\\@lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\n>\n> Hello,\n>\n>> intended to inform the fundee node that the funder node is definitely sure that the channel funding transaction can never confirm\n>\n> If the deprecated tx initially sent funds to the fundee via push_msat,\n> then the fundee may not want to trust the funder on this. One way to\n> do it trustlessly would be for the funder to attach the actual\n> deprecated funding tx (not necessarily signed, but still could be big)\n> to the funding_cancelled message, then the fundee would be able to\n> verify that its inputs have indeed been spent by the overriding tx.\n\nThis will not work easily for the multi-channel funding transaction case.\n\nSuppose the funder node A wants to make two channels to two other nodes B and C using a single funding transaction.\n\n1.  In parallel, it initiates the open_channel on both B and C.\n2.  B and C respond with accept_channel.  A can now create the funding transaction.\n3.  In parallel, it sends the funding_created to both B and C.\n4.  B responds with funding_signed.  However, C suddenly disconnects instead of responding with funding_signed.\n5.  A cannot safely broadcast the funding transaction.  So it does funding_cancelled to B instead.\n\nIt is not safe for A to send the funding transaction to B, because B can turn around and broadcast the funding transaction itself (for example, B and C can be in cahoots with each other, and force A to push_msat more funds to C).  In the above case there is no replacement created - the intent is not to increase the fees to speed up opening the channel, the intent is to create a single funding transaction that can be used to anchor A<->B and A<->C channels.\n\nOf course, A can simply double-spend the inputs it used for the multi-channel funding transaction to an address it controls solely, but that just adds an otherwise-unnecessary transaction with the cost paid by A.  A would prefer to simply silently forget the A<->B and A<->C channels and let B waste its resources hopelessly scanning each block for a transaction that A will never want to broadcast.\n\nThe important part to remember for this proposal is that the current 1.0 spec already allow both replace-by-fee and muilti-channel funding transactions, but at the cost of wasting resources on the fundee side, while only the funder side gets the benefit (either faster channel opens or cheaper channel opens).  Remember that the protocols for both replace-by-fee funding transactions and multi-channel funding transactions simply require implementation on the funder side, with the fundee side using the same protocol as the simple single-channel non-replaceable funding transaction case.  To prevent this, a fundee node might restrict the number of pending channel opening attempts that a peer can have with it; implementing `funding_cancelled` lets the funder free up this imposed resource limit on the fundee side.\n\n(one could say that the c-lightning one-channel-one-peer is an example of this limiting of the resources an external node can consume, for example; of course, my understanding is that this limit will be lifted later on)\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180109/64e7e93c/attachment-0001.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-22T10:45:58",
                "message_text_only": "Good morning all,\n\nLooking at BOLT#1, there is an `error` message which is supposed to \"fail the channel\".  At a first glance, it seems to be what is basically a superpowered version of `funding_cancelled`, since it only fails the channel (and in particular does not indicate to fail the peer or fail the connection).\n\nI will need to check exactly how each implementation reacts to an `error` message while awaiting lockin, but it looks like `funding_cancelled` is unnecessary for RBF and multi-funding/coinjoined funding transactions.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180122/30a5d807/attachment.html>"
            },
            {
                "author": "7riw77 at gmail.com",
                "date": "2018-01-21T12:57:32",
                "message_text_only": "> Yes, but it still limits how much damage each peer can do to the node.\n> And I think you overstate the ease of distributed denial of service attacks,\n> and the relative resource consumption differences on an attacker simulating\n> multiple nodes versus one simulating a single node.\n\nSo assume the following situation: Someone has gotten a \"bum deal\" on their pizza (or thinks they have), and they want to take down their pizza provider. They note the lightning node the pizza provider uses happens to be some particular address, so they hire out a 10k node botnet (rather small in the real world), and ask each bot to open as many transactions as possible, as fast as possible, without completing any of them, with the ip address of the node in question. The server eventually says \"I'm not accepting any more connections, because I have too many outstanding connections right now,\" which effectively takes it off line for new transactions, blocking anyone who uses that node from any sort of transaction. How long can this last? So long as the botnet continues asking for new connections. \n\nThere are ways around this on the network side -- specifically using anycast, like DNS does, to spread the attack around -- but I'm not certain anycast would work in this case because of the state issues involved in lightning. \n\nWhen I was at Verisign, we figured a 100g link was enough to block any sort of DDoS against the DNS root servers. The attack against Krebs shows just how silly this line of thinking is today. \n\nThere is no perfect defense, but it might be useful to think about these things, and how to solve them, now, rather than once they happen, particularly when the trust of the overall network is in play. This might mean several things, such as --\n\n1. The closer you can come to stateless on the server side during session setup, before you know the request is going to be followed through/is legitimate, the less chance this sort of thing will happen\n2. The more you have the ability to shift a transaction from one server to another without losing some essential state, the more a network of devices can be designed to handle such problems\n\nThere may be other solutions, as well; just throwing some ideas out there.\n\n\ud83d\ude0a /r"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-22T10:36:40",
                "message_text_only": "I do not see the relevance of the example.  The limit I propose that nodes will impose is a limit imposed on *each* *peer*, not a limit imposed on all peers in total.  Indeed, imposing the limit on each peer reduces the actual CPU, bandwidth, and storage resources that each peer can consume on the attacked node.  If it did not limit each peer, then each attacking peer can consume significantly more resources (CPU, bandwidth, storage) that other, legitimate peers would want to use.  By limiting each peer to some maximum number of channel open attempts, it allows the server to serve more peers, and possibly shrug off a 10k or 100k attack (depending on the actual CPU/bandwidth/storage resources it has) that it otherwise would be unable to service if each peer could consume an arbitrary amount of resources on the server.\n\nIn any case this has diverged from \"propose `funding_cancelled` message\".  Obviously only cooperative, non-attacking peers will use `funding_canclled`, but only cooperative non-attacking peers will start an `open_channel` sequence and broadcast a valid funding tx to the blockchain network anyway.\n\nRegards,\nZmnSCPxj\n\nSent with [ProtonMail](https://protonmail.com) Secure Email.\n\n-------- Original Message --------\nOn January 21, 2018 8:57 PM, <7riw77 at gmail.com> wrote:\n\n>\n>\n>> Yes, but it still limits how much damage each peer can do to the node.\n>> And I think you overstate the ease of distributed denial of service attacks,\n>> and the relative resource consumption differences on an attacker simulating\n>> multiple nodes versus one simulating a single node.\n>\n> So assume the following situation: Someone has gotten a \"bum deal\" on their pizza (or thinks they have), and they want to take down their pizza provider. They note the lightning node the pizza provider uses happens to be some particular address, so they hire out a 10k node botnet (rather small in the real world), and ask each bot to open as many transactions as possible, as fast as possible, without completing any of them, with the ip address of the node in question. The server eventually says \"I'm not accepting any more connections, because I have too many outstanding connections right now,\" which effectively takes it off line for new transactions, blocking anyone who uses that node from any sort of transaction. How long can this last? So long as the botnet continues asking for new connections.\n>\n> There are ways around this on the network side -- specifically using anycast, like DNS does, to spread the attack around -- but I'm not certain anycast would work in this case because of the state issues involved in lightning.\n>\n> When I was at Verisign, we figured a 100g link was enough to block any sort of DDoS against the DNS root servers. The attack against Krebs shows just how silly this line of thinking is today.\n>\n> There is no perfect defense, but it might be useful to think about these things, and how to solve them, now, rather than once they happen, particularly when the trust of the overall network is in play. This might mean several things, such as --\n>\n> - The closer you can come to stateless on the server side during session setup, before you know the request is going to be followed through/is legitimate, the less chance this sort of thing will happen\n> - The more you have the ability to shift a transaction from one server to another without losing some essential state, the more a network of devices can be designed to handle such problems\n>\n> There may be other solutions, as well; just throwing some ideas out there.\n>\n> \ud83d\ude0a /r\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180122/66216327/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Proposed `funding_cancelled` message",
            "categories": [
                "Lightning-dev",
                "1.1"
            ],
            "authors": [
                "7riw77 at gmail.com",
                "Matt Corallo",
                "Pierre",
                "ZmnSCPxj"
            ],
            "messages_count": 15,
            "total_messages_chars_count": 34509
        }
    },
    {
        "title": "[Lightning-dev] Pay payment_request with an openchannel+push_sat",
        "thread_messages": [
            {
                "author": "Jonathan Underwood",
                "date": "2018-01-11T04:22:05",
                "message_text_only": "Hi all,\n\nI have mentioned this to roasbeef re: lnd implementing it... but I am\nwondering if this idea has propagated through the LN community and whether\nother wallets are going to implement it?\n\nFeature:\n\nIf the recipient of a payment waiting for a specific r_hash receives\nan open_channel message with push_msat >= the value of the request where\nthe temporary_channel_id contains the r_hash... that payment will be set to\na WAITING_OPEN status.\n\nOnce the channel is open, the payment moves to a PAID status.\n\nIf while waiting for channel to open in the WAITING_OPEN state, a routed\npayment is received with the r_hash, accept that payment and change the\npayment status to PAID.\n\nReasoning:\n\n1. Open_channel can take up to 10 minutes, but most smartphone apps kill\nbackground network processes for apps after 5 minutes or so.\n2. If routing fails to pay someone. A wallet UI should ask the user:\n\"You have enough on-chain funds to send. What would you like to do?\n  1. Open channel & send\n  2. Send on-chain\n  3. Give up\"\n3. If we choose 1 in the current implementations, we would need to open a\nchannel, then wait... then remember to re-open the app as soon as the\nchannel is open. Then we need to paste the payment request again.\n4. By allowing the person to \"pay\" with an open_channel, it allows people\nto signal intent to pay... allowing payment processors that generate\npayment requests with short expiration times to react to that intent\naccordingly.\n\n\nI think this might be good to add into BOLT 2... what does everyone\nthink?....... not sure.\n\nThanks for your input.\nJon\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/759776ff/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-01-12T00:30:21",
                "message_text_only": "Jonathan Underwood <junderwood at bitcoinbank.co.jp> writes:\n> Hi all,\n>\n> I have mentioned this to roasbeef re: lnd implementing it... but I am\n> wondering if this idea has propagated through the LN community and whether\n> other wallets are going to implement it?\n>\n> Feature:\n>\n> If the recipient of a payment waiting for a specific r_hash receives\n> an open_channel message with push_msat >= the value of the request where\n> the temporary_channel_id contains the r_hash... that payment will be set to\n> a WAITING_OPEN status.\n>\n> Once the channel is open, the payment moves to a PAID status.\n>\n> If while waiting for channel to open in the WAITING_OPEN state, a routed\n> payment is received with the r_hash, accept that payment and change the\n> payment status to PAID.\n\nHi Jonathan,\n\n        It's an interesting idea, but I think I prefer simply opening a\nchannel then making a payment rather than using push_msat.  Otherwise\nthe payer doesn't get proof of payment for this case.\n\n> 1. Open_channel can take up to 10 minutes, but most smartphone apps kill\n> background network processes for apps after 5 minutes or so.\n\nWorse, open_channel can take *hours* if the depth requirement is high,\nthe fees too low, or miners unlucky.\n\n> 2. If routing fails to pay someone. A wallet UI should ask the user:\n> \"You have enough on-chain funds to send. What would you like to do?\n>   1. Open channel & send\n>   2. Send on-chain\n>   3. Give up\"\n\nGenerally it's better to open a channel, though sending onchain is\npossible if they provided a fallback address.\n\n> 3. If we choose 1 in the current implementations, we would need to open a\n> channel, then wait... then remember to re-open the app as soon as the\n> channel is open. Then we need to paste the payment request again.\n\nI'm sure there are ways for mobile wallets do the kind of polling needed\nhere, and respond accordingly.  They can certainly disconnect in the\nmeantime.\n\n> 4. By allowing the person to \"pay\" with an open_channel, it allows people\n> to signal intent to pay... allowing payment processors that generate\n> payment requests with short expiration times to react to that intent\n> accordingly.\n\nIt introduces trust into the system though; either you're prepared to\noffer longer settlement terms, or you aren't.  I don't think you should\nadjust based on such a falsifiable signal?\n\n> I think this might be good to add into BOLT 2... what does everyone\n> think?....... not sure.\n\nFWIW, this would be a 1.1 thing, since spec is frozen other than\noutright bugs.\n\nThanks!\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Pay payment_request with an openchannel+push_sat",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Jonathan Underwood"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4461
        }
    },
    {
        "title": "[Lightning-dev] BOLTs and meaning of \"MUST\" in potentially adversarial contexts",
        "thread_messages": [
            {
                "author": "Benjamin Mord",
                "date": "2018-01-11T17:29:38",
                "message_text_only": "One thing I find useful in RFCs is a brief discussion about the meaning of\nterms like MUST, SHOULD, MAY, etc.. as used in the subsequent protocol\ndefinition. But in the traditional approach to protocol design we first\nassume cooperative nodes, and then later attempt to retrofit security when\nwe are surprised (yet again) to find not all nodes are operating in good\nfaith. Initial definition of \"MUST\" in RFCs thus implicitly presumes good\nfaith, inadvertently inviting implementers to lower their guard. But of\ncourse, integrity despite presence of adversarial nodes is an explicit\ndesign goal of the lightning network.\n\nWhen a BOLT says that a lightning node MUST do some X, what does that mean\nexactly? I'm thinking it means we should stigmatize it as \"non-compliant\"\nwith protocol consensus as documented in BOLTs, whenever we discuss the\nimplementation. I think violation of a MUST should be considered hostile. I\nthink a MUST encourages nodes to fail a channel or connection upon\nobserving a violation of that MUST, and even to take\nimplementation-specific defensive measures as deemed appropriate by\nimplementers (so long as they have cryptographic evidence that the\nviolation is not forged). But in no way does a MUST assure implementers\nthat they may assume this MUST will be respected by remote nodes, as it is\nnot the purpose of MUST to convey that cryptographic safeguards or such\nelsewhere in the protocol design have arranged to force adherence..\n\nDoes that sound right? Is it worth stating explicitly somewhere, along with\ndefinitions of SHOULD, MAY etc? Sorry if these definitions are already\nstated someplace that I overlooked.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180111/36714035/attachment.html>"
            },
            {
                "author": "Rusty Russell",
                "date": "2018-01-16T00:01:39",
                "message_text_only": "Benjamin Mord <ben at mord.io> writes:\n> One thing I find useful in RFCs is a brief discussion about the meaning of\n> terms like MUST, SHOULD, MAY, etc.. as used in the subsequent protocol\n> definition.\n\nHi Benjamin!\n\n        Weird, I always find them kinda useless.  RFC2119 pretty much\ncovers it.\n\n> When a BOLT says that a lightning node MUST do some X, what does that mean\n> exactly? I'm thinking it means we should stigmatize it as \"non-compliant\"\n> with protocol consensus as documented in BOLTs, whenever we discuss the\n> implementation. I think violation of a MUST should be considered hostile. I\n> think a MUST encourages nodes to fail a channel or connection upon\n> observing a violation of that MUST, and even to take\n> implementation-specific defensive measures as deemed appropriate by\n> implementers (so long as they have cryptographic evidence that the\n> violation is not forged). But in no way does a MUST assure implementers\n> that they may assume this MUST will be respected by remote nodes, as it is\n> not the purpose of MUST to convey that cryptographic safeguards or such\n> elsewhere in the protocol design have arranged to force adherence..\n\nThis is why we attempt to divide requirements into sender and receiver.\nFor example, this is an absolute unchangable protocol requirement:\n\n        Sender MUST set X.\n        Receiver MUST close channel if X is not set.\n\nor:\n        Sender MUST set X.\n        If X is set, Receiver MUST ...\n\nThe latter implies that future versions of the spec may have senders not\nsetting X.\n\nI thought about writing a BOLT on how to write BOLTs, but it would\ndoubtless come across as inane navel-gazing.\n\nNote also that the spec does not live up to this property in all places,\nbut we bugfix where we find that.\n\nCheers,\nRusty."
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-16T14:37:25",
                "message_text_only": "With all due respect to Bradner, RFC 2119 (written in 1997) is harmful to\nlightning and to cryptocurrency protocols more broadly. As was the\nprevailing mindset at the time, RFC 2119 is for a world of good guys and\n(if we're feeling diligent) bad guys, where good guys try to communicate\ndespite presence of bad guys who would spoil the fun. The intended endpoint\nof your communication would never itself be a bad guy - why would you\nknowingly communicate with a bad guy?\n\nBut Satoshi was less naive, and considered every node as pursuing self\ninterest alone. Rather than good guys and bad guys, we have lots of selfish\nguys playing the game (and also selfish guys trying to destroy the game).\nThe lightning concept itself embraces this idea also at the very abstract\nlevel, so the navel-gazing we MUST take on now is simply the task of\ncarrying that philosophy through into the byte-level details and how we\nsell those details to programmers. RFC 2119 is harmful both for what it\nsays and what it does not say. The harm in what it says is illustrated by\nthis example - one of several (emphasis mine):\n   \"In particular, they MUST only be used where it is\n   actually required for interoperation or to limit behavior *which has*\n*   potential for causing harm* (e.g., limiting retransmisssions)\"\n\n(Another example is where it limits what sort of behavior implementers\nought to prepare for in their peers.)\n\nWhen someone violates a MUST, what shall we do? Throw them in jail? Say\nnasty things behind their backs? No, cryptocurrency protocol specifications\nare 100% advisory - a cleverly devised system where we can sincerely sell\nthe implementer that it will be in their individual best interest to do\nhighly specific things which have been arranged to also accrue to the\ncollective benefit. Use of MUST (in RFC 2119 sense) invites lazy thought in\nthe protocol design itself, where details need not be sold as beneficial to\nindividuals. We should say, there is no RFC 2119 MUST - there is only self\ninterest.\n\nAnother way to view it: a protocol spec attempts to program the\nprogrammers. But unlike computers, people don't always do what you ask\nsimply because you asked. Every detail must therefore be sold, as there is\nno other source of authority at our disposal. RFC 2119 assumes an intrinsic\nauthority that simply does not exist here. We must arrange for that to be\nOK - not only at an abstract level, but at a detailed one also.\n\n\nOn Mon, Jan 15, 2018 at 7:01 PM, Rusty Russell <rusty at rustcorp.com.au>\nwrote:\n\n> Benjamin Mord <ben at mord.io> writes:\n> > One thing I find useful in RFCs is a brief discussion about the meaning\n> of\n> > terms like MUST, SHOULD, MAY, etc.. as used in the subsequent protocol\n> > definition.\n>\n> Hi Benjamin!\n>\n>         Weird, I always find them kinda useless.  RFC2119 pretty much\n> covers it.\n>\n> > When a BOLT says that a lightning node MUST do some X, what does that\n> mean\n> > exactly? I'm thinking it means we should stigmatize it as \"non-compliant\"\n> > with protocol consensus as documented in BOLTs, whenever we discuss the\n> > implementation. I think violation of a MUST should be considered\n> hostile. I\n> > think a MUST encourages nodes to fail a channel or connection upon\n> > observing a violation of that MUST, and even to take\n> > implementation-specific defensive measures as deemed appropriate by\n> > implementers (so long as they have cryptographic evidence that the\n> > violation is not forged). But in no way does a MUST assure implementers\n> > that they may assume this MUST will be respected by remote nodes, as it\n> is\n> > not the purpose of MUST to convey that cryptographic safeguards or such\n> > elsewhere in the protocol design have arranged to force adherence..\n>\n> This is why we attempt to divide requirements into sender and receiver.\n> For example, this is an absolute unchangable protocol requirement:\n>\n>         Sender MUST set X.\n>         Receiver MUST close channel if X is not set.\n>\n> or:\n>         Sender MUST set X.\n>         If X is set, Receiver MUST ...\n>\n> The latter implies that future versions of the spec may have senders not\n> setting X.\n>\n> I thought about writing a BOLT on how to write BOLTs, but it would\n> doubtless come across as inane navel-gazing.\n>\n> Note also that the spec does not live up to this property in all places,\n> but we bugfix where we find that.\n>\n> Cheers,\n> Rusty.\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180116/9a13eedb/attachment.html>"
            },
            {
                "author": "7riw77 at gmail.com",
                "date": "2018-01-18T11:12:38",
                "message_text_only": "> benefit. Use of MUST (in RFC 2119 sense) invites lazy thought in the protocol\n> design itself, where details need not be sold as beneficial to individuals. We\n> should say, there is no RFC\n> 2119 MUST - there is only self interest.\n\nI think you are misreading the intent behind RFC2119 a bit... The idea has always been that implementations MUST follow MUSTs -- but who is this enforced by? Vendors? They've never cared. Neither the IETF nor the Internet Society run jails that I'm aware of, nor is there any nation state who offers their jails up for folks who don't follow a MUST. The situation in the routing world is the same as it is in the cryptocurrency world -- you can make real money by not following the rules (there seems to be this general idea that the 'net is \"free\" -- which is wrong), and the only enforcement on the rules is the community at large. The correct interpretation of RFC2119 MUST is this:\n\n- If I write an implementation, and you send me something you shouldn't (because it's MUST), then I simply refuse to interoperate with your implementation. This (hopefully) harms the implementation financially.\n- If I run a network, and you produce gear that doesn't follow a MUST, then I won't buy your gear.\n\nNote that private implementations are not bound by these rules -- implementations that are intentionally not designed to interoperate with other implementations. If such implementations become large enough to care, then they go through the standardization process so everyone has a look before it becomes an issue within the community.\n\n\ud83d\ude0a /r"
            }
        ],
        "thread_summary": {
            "title": "BOLTs and meaning of \"MUST\" in potentially adversarial contexts",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "7riw77 at gmail.com",
                "Benjamin Mord"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 9744
        }
    },
    {
        "title": "[Lightning-dev] Insufficient funder balance for paying fees",
        "thread_messages": [
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-12T10:32:23",
                "message_text_only": "Hi all,\nI am wondering how Eclair and c-lightning is handling the following case, as I wasn\u2019t able to derive exactly how to handle it from the BOLTs. If it is described somewhere, please point me to it, if not, let\u2019s agree on a strategy, and get it in :)\nLet's say Alice is the funder of the channel (meaning she is paying all fees) between Alice and Bob. She wants to add an HTLC, and has just enough balance available for the HTLC + the extra fee for adding it to the commitment transaction. At the same time Bob wants to add an HTLC, and sees that Alice has enough balance to be able to pay the fee for receiving this HTLC (add it to her commitment tx).\nThey both send the AddHTLC at the same time, thinking Alice has enough balance available, but she doesn't have enough to cover her own HTLC+fee, in addition to the fee for adding Bob's. Adding both the HTLCs to her commitment transaction will either 1) violate the channel reserve requirement, or 2) deplete her channel completely if the channel reserve is set to 0.\nWhat is the expected way of handling this case, from both Alice and Bob\u2019s point of view?\nCheers, Johan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180112/8844551f/attachment.html>"
            },
            {
                "author": "Pierre",
                "date": "2018-01-12T11:56:39",
                "message_text_only": "Hi Johan,\n\nThat's an interesting corner case. I think it shares some similarities\nwith the race condition described in BOLT 2 [1], which handling is\nspecified in BOLT 3 [2].\n\nNote that what matters really is the timing of the\n`commit_sig`/`revoke_and_ack` messages, not the `update_add_htlc`s,\nbecause of the acknowledgment logic that excludes remote's unsigned\nupdates. A side effect is that there can be multiple HTLCs on each\nside.\n\nEach party will end up receiving a commitment tx which has\ninsufficient (possibly zero) fees. At that point according to [2] it\nmay decide to fail the channel, using its previous commitment (which\nit hasn't yet revoked). Currently eclair won't fail the channel, but I\nthink we probably should, especially if we are the fundee and would\nend up with all funds in an unpublishable tx. The funder could face\nthe same situation if the pending htlcs have a high value (at this\npoint its main output is zero anyway).\n\nAn appropriate choice of channel parameters (`mainly\nmax_htlc_value_in_flight_msat`, `channel_reserve_satoshis`,\n`max_accepted_htlcs`) could probably reduce the probability of this\nhappening.\n\nHope that helps,\n\nPierre\n\n[1] https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee\n[2] https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-payment"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-12T12:41:09",
                "message_text_only": "Hi Pierre,\nYou\u2019re right, that looks very much like the same kind of situation!\nI agree, it looks from [2] that a node may fail the channel in this case, and that it probably should to not risk end up with all funds in an unpublishable tx. Seems like something that could be used as a DOS attack vector by a malicious counter party otherwise.\n\nRelevant to this: We use a node\u2019s resulting output (that is, after subtracting fees) when checking that the channel_reserve is met. In these cases we can therefore end up violating the reserve, even though none of the nodes are actually violating the protocol. When this happens we don\u2019t really end up with an unpublishable tx, as the fees are still high enough, and I guess each node can choose what to do. I think we will just fail the channel to not have to deal with this as a special case.\nAnyway, I think these are cases that are not very likely to occur, especially with the right choice of parameters as you mention. And because of this it might be less error-prone to just fail the channel instead of trying to recover from it.\nThanks! - Johan\nOn Fri, Jan 12, 2018 at 12:56, Pierre <pm+lists at acinq.fr> wrote:\nHi Johan,\n\nThat's an interesting corner case. I think it shares some similarities\nwith the race condition described in BOLT 2 [1], which handling is\nspecified in BOLT 3 [2].\n\nNote that what matters really is the timing of the\n`commit_sig`/`revoke_and_ack` messages, not the `update_add_htlc`s,\nbecause of the acknowledgment logic that excludes remote's unsigned\nupdates. A side effect is that there can be multiple HTLCs on each\nside.\n\nEach party will end up receiving a commitment tx which has\ninsufficient (possibly zero) fees. At that point according to [2] it\nmay decide to fail the channel, using its previous commitment (which\nit hasn't yet revoked). Currently eclair won't fail the channel, but I\nthink we probably should, especially if we are the fundee and would\nend up with all funds in an unpublishable tx. The funder could face\nthe same situation if the pending htlcs have a high value (at this\npoint its main output is zero anyway).\n\nAn appropriate choice of channel parameters (`mainly\nmax_htlc_value_in_flight_msat`, `channel_reserve_satoshis`,\n`max_accepted_htlcs`) could probably reduce the probability of this\nhappening.\n\nHope that helps,\n\nPierre\n\n[1] https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#updating-fees-update_fee\n[2] https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-payment\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180112/c18884a0/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Insufficient funder balance for paying fees",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Pierre",
                "Johan Tor\u00e5s Halseth"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 5406
        }
    },
    {
        "title": "[Lightning-dev] [Question] Unilateral closing during fee increase.",
        "thread_messages": [
            {
                "author": "Jonathan Underwood",
                "date": "2018-01-14T01:30:28",
                "message_text_only": "Hey everybody.\n\nSay that the last time we updated channel state, we assumed 40 satoshi/byte\nwas enough to get confirmed, then I leave the channel for a few weeks, come\nback to find my partner fell off the face of the internet.\n\nI perform unilateral close with my output on CSV timelock... but it turns\nout there\u2019s 500 MB of txes at around 100 satoshi/byte and lets say my\ntransaction will never get confirmed at 40 sat/byte.\n\nWhat course of action can I take?\n\n1. to_local output can't be redeemed until the commitment transaction\n(which will \"never confirm\") is confirmed + the CSV timeout.\n2. to_remote output probably won't be redeemed as the other person is\noffline.\n\nThe only remedy I can think of is hope that the other person comes back\nonline and CPFPs your to_remote output for you... but at that point it\nwould be better for them to just amicably close with normal outputs... so\nbasically your only hope is wait for other person to come online.\n\nSince CSV will cause script verification to fail, a CPFP transaction will\nnot be propagated.\nIf we can't CPFP, the CSV timer won't start (it starts once the CSV\ncontaining output is confirmed).\n\nSeems like a problem.\n\nAnyone have any solutions?\n\nThanks,\nJon\n\n-- \n-----------------\nJonathan Underwood\n\u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc\n-----------------\n\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/0fc7a441/attachment.html>"
            },
            {
                "author": "Peter Todd",
                "date": "2018-01-14T12:32:29",
                "message_text_only": "On Sun, Jan 14, 2018 at 10:30:28AM +0900, Jonathan Underwood wrote:\n> Hey everybody.\n> \n> Say that the last time we updated channel state, we assumed 40 satoshi/byte\n> was enough to get confirmed, then I leave the channel for a few weeks, come\n> back to find my partner fell off the face of the internet.\n> \n> I perform unilateral close with my output on CSV timelock... but it turns\n> out there\u2019s 500 MB of txes at around 100 satoshi/byte and lets say my\n> transaction will never get confirmed at 40 sat/byte.\n> \n> What course of action can I take?\n> \n> 1. to_local output can't be redeemed until the commitment transaction\n> (which will \"never confirm\") is confirmed + the CSV timeout.\n> 2. to_remote output probably won't be redeemed as the other person is\n> offline.\n> \n> The only remedy I can think of is hope that the other person comes back\n> online and CPFPs your to_remote output for you... but at that point it\n> would be better for them to just amicably close with normal outputs... so\n> basically your only hope is wait for other person to come online.\n> \n> Since CSV will cause script verification to fail, a CPFP transaction will\n> not be propagated.\n> If we can't CPFP, the CSV timer won't start (it starts once the CSV\n> containing output is confirmed).\n> \n> Seems like a problem.\n> \n> Anyone have any solutions?\n\nWhile not ideal, you can use out-of-band fee payment mechanisms such as\nhttps://confirmtx.com and https://pushtx.btc.com to get the transaction mined\nwithout an on-blockchain payment. For that matter, you could use a Lightning\ntransaction to pay for that service more cheaply than on-chain payments those\nexisting accelerators currently use.\n\n-- \nhttps://petertodd.org 'peter'[:-1]@petertodd.org\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 455 bytes\nDesc: Digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/98c78dd1/attachment.sig>"
            },
            {
                "author": "Richard",
                "date": "2018-01-14T12:37:55",
                "message_text_only": "Complete n00b question here: if one side of the channel have 100% of the\nfunds, can the last message give that user complete controll over the\nchannel (to close it \"unilateral\" without any interaction from the other\nside?\n\nAnd that way change the fee size when that part want's to close the channel?\n\nOr give the other side the complete controll over a channel if the funds on\none side is less than what is currently needed to close a channel?\n\n\nRichard\n\ns\u00f8n. 14. jan. 2018 kl. 13:32 skrev Peter Todd <pete at petertodd.org>:\n\n> On Sun, Jan 14, 2018 at 10:30:28AM +0900, Jonathan Underwood wrote:\n> > Hey everybody.\n> >\n> > Say that the last time we updated channel state, we assumed 40\n> satoshi/byte\n> > was enough to get confirmed, then I leave the channel for a few weeks,\n> come\n> > back to find my partner fell off the face of the internet.\n> >\n> > I perform unilateral close with my output on CSV timelock... but it turns\n> > out there\u2019s 500 MB of txes at around 100 satoshi/byte and lets say my\n> > transaction will never get confirmed at 40 sat/byte.\n> >\n> > What course of action can I take?\n> >\n> > 1. to_local output can't be redeemed until the commitment transaction\n> > (which will \"never confirm\") is confirmed + the CSV timeout.\n> > 2. to_remote output probably won't be redeemed as the other person is\n> > offline.\n> >\n> > The only remedy I can think of is hope that the other person comes back\n> > online and CPFPs your to_remote output for you... but at that point it\n> > would be better for them to just amicably close with normal outputs... so\n> > basically your only hope is wait for other person to come online.\n> >\n> > Since CSV will cause script verification to fail, a CPFP transaction will\n> > not be propagated.\n> > If we can't CPFP, the CSV timer won't start (it starts once the CSV\n> > containing output is confirmed).\n> >\n> > Seems like a problem.\n> >\n> > Anyone have any solutions?\n>\n> While not ideal, you can use out-of-band fee payment mechanisms such as\n> https://confirmtx.com and https://pushtx.btc.com to get the transaction\n> mined\n> without an on-blockchain payment. For that matter, you could use a\n> Lightning\n> transaction to pay for that service more cheaply than on-chain payments\n> those\n> existing accelerators currently use.\n>\n> --\n> https://petertodd.org 'peter'[:-1]@petertodd.org\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/b202f355/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-15T02:01:36",
                "message_text_only": "Good Morning Richard,\n\n> -------- Original Message --------\n> Subject: Re: [Lightning-dev] [Question] Unilateral closing during fee increase.\n> Local Time: January 14, 2018 8:37 PM\n> UTC Time: January 14, 2018 12:37 PM\n> From: richard.hagen at gmail.com\n> To: Peter Todd <pete at petertodd.org>\n> lightning-dev at lists.linuxfoundation.org, Jonathan Underwood <junderwood at bitcoinbank.co.jp>\n>\n> Complete n00b question here: if one side of the channel have 100% of the funds, can the last message give that user complete controll over the channel (to close it \"unilateral\" without any interaction from the other side?\n\nThe only trustless way to transfer control of the funds from one-sided back to both of them would be an on-chain transaction. So it is equivalent to closing the channel, then reopening it when the other side returns to be connected.\n\n> And that way change the fee size when that part want's to close the channel?\n>\n> Or give the other side the complete controll over a channel if the funds on one side is less than what is currently needed to close a channel?\n\nThis puts trust into the system. If you are going to trust anyway,then you can probably trust that the other side will gracefully inform you of pending shutdown on their side and cooperatively close.\n\nRegards,\nZmnSCPxj\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180114/1d1c0699/attachment-0001.html>"
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-16T23:47:04",
                "message_text_only": "Hi Jonathan,\nThis is definitely a problem! I have a mainnet channel I force closed 2 weeks ago that is still not mined :(\nWith current spec I guess it is not much that can be done other than crossing fingers. For future specs maybe someone could come up with some SIGHASH flag magic to either (1) allow adding an extra input that could go to fees, or (2) add both a new input and output, where the difference goes to fees. I believe this would change the TXID of the commitment transaction, but not sure if that\u2019s a problem? (Watchtowers comes to mind).\nIf keeping the TXID intact is important, one solution would be to always add a small (1 satoshi?) output to every commitment transaction, that anyone can spend. So if the commitment transaction has a fee too low, you could do CPFP on this small output, making it confirm. You could even make a batch sweep of many such outputs, and they would be (un)fairly cheap since they don\u2019t need a signature. Do you think this would work?\n- Johan\n\nOn Sun, Jan 14, 2018 at 2:30, Jonathan Underwood <junderwood at bitcoinbank.co.jp> wrote:\nHey everybody.\nSay that the last time we updated channel state, we assumed 40 satoshi/byte was enough to get confirmed, then I leave the channel for a few weeks, come back to find my partner fell off the face of the internet.\nI perform unilateral close with my output on CSV timelock... but it turns out there\u2019s 500 MB of txes at around 100 satoshi/byte and lets say my transaction will never get confirmed at 40 sat/byte.\nWhat course of action can I take?\n1. to_local output can't be redeemed until the commitment transaction (which will \"never confirm\") is confirmed + the CSV timeout.\n2. to_remote output probably won't be redeemed as the other person is offline.\nThe only remedy I can think of is hope that the other person comes back online and CPFPs your to_remote output for you... but at that point it would be better for them to just amicably close with normal outputs... so basically your only hope is wait for other person to come online.\n\nSince CSV will cause script verification to fail, a CPFP transaction will not be propagated.\nIf we can't CPFP, the CSV timer won't start (it starts once the CSV containing output is confirmed).\nSeems like a problem.\nAnyone have any solutions?\nThanks, Jon\n--\n-----------------\nJonathan Underwood \u30d3\u30c3\u30c8\u30d0\u30f3\u30af\u793e \u30c1\u30fc\u30d5\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30aa\u30d5\u30a3\u30b5\u30fc -----------------\n\u6697\u53f7\u5316\u3057\u305f\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u304a\u9001\u308a\u306e\u65b9\u306f\u4e0b\u8a18\u306e\u516c\u958b\u9375\u3092\u3054\u5229\u7528\u4e0b\u3055\u3044\u3002\n\u6307\u7d0b: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3\n_______________________________________________ Lightning-dev mailing list Lightning-dev at lists.linuxfoundation.org https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180117/1a4ee0f6/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Unilateral closing during fee increase.",
            "categories": [
                "Lightning-dev",
                "Question"
            ],
            "authors": [
                "Richard",
                "Peter Todd",
                "Johan Tor\u00e5s Halseth",
                "Jonathan Underwood",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 10579
        }
    },
    {
        "title": "[Lightning-dev] Fee disentanglement for 1.1 spec?",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2018-01-15T23:55:09",
                "message_text_only": "Hi all,\n\n        Wanted to post some thinking on this for everyone to mull over,\nthough I know we're all busy.\n\nYour consideration and feedback gratefully accepted!\n\nProblem #1\n==========\nFor simplicity, one side (funder) sets fees, but other side\nneeds to check they're sufficient, and not insanely high (as *they* end\nup paying for HTLC txs).  If they disagree, they close channel; this\nhappens a fair bit on testnet, for example, and will be worse with\ndifferent backends (eg. different bitcoind versions, or btcd, etc).\n\nSolution\n--------\nHave both sides set fees independently.  I specify what fees my\ncommitment tx and HTLC txs will have, you do the same.  This works in\nwell with dual-funder proposals.\n\nImplementation:\n--------------\nc-lightning did something similar pre-spec.  The way it works is both\nsides set an initial fee in `open_channel`: this is the only point at\nwhich the counterparty checks it's reasonable.\n\nYou send an `update_fee` message like now, but it has no effect on the\nother side: it's applied to *you* when they 'revoke_and_ack', like any\nother change.\n\nYou disallow any `update_fee` which the other side could not afford with\n(1) all their current HTLCs, AND (2) the `max_accepted_htlcs` from you.\nThat covers the race where one side sets fees and the other adds a heap\nof HTLCs and the two cross over.\n\nAlso disallow any new HTLCs you can't pay fees for (given same\nworst-case calculation as above), and if the one side can't afford fees,\npull from its reserve and other side as necessary (this can only happen\nduring initial phase, and is the same logic as now).\n\n\nProblem #2\n==========\nPredicting the future is hard.  Today's sufficient fee may be a gross\noverpayment or insufficient tomorrow.\n\nSolution\n--------\nAllow multiple simultaneous fee levels.\n\nImplementation:\n---------------\nThis means multiple signatures in each `commitment_signed` message,\nwhich is more work and more storage.  But since our nSequence is <\n0xFFFFFFFE anyway, all transactions are RBF-ready except\nclosing_transaction.  We might want to change that; we already allow\nre-negotiation of closing tx by reconnecting anyway."
            },
            {
                "author": "Johan Tor\u00e5s Halseth",
                "date": "2018-01-16T23:37:11",
                "message_text_only": "Hi Rusty,\nThis is something I\u2019ve been thinking a bit about, as I\u2019ve stumbled into some of the edge cases you mention. Just to get on the same page: does the other side (non-funder) pay any fees in the current implementation? [1] suggests that the funder pays everything atm (on both sides\u2019 commitment), so I reckon you are talking about dual-funder from here on.\n[1] https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#fee-payment\nProblem#1 If we can make each side pay the fee for the HTLCs they are adding (on both commitments!), in addition to your suggestion of having them set fees independently, we get a nice bonus: Any update Alice makes, can only decrease *her* balance, not Bob\u2019s. She can add HTLCs (she must pay HTLC+fee), do a fee update (potentially increasing the fees she must pay), or settle/fail HTLCs (can not decrease her balance). This is in contrast to the current spec, where an added HTLC can make Bob pay the fee (if he\u2019s funder), and a fee update can make Bob not afford the new fee (the race you mentioned).\nI think this will work without the check (2) you mention, since if Alice sends a fee update, then it will apply only to her HTLCs, and as mentioned can only decrease her balance. It doesn\u2019t matter if Bob adds `max_accepted_htlcs` at the same time, since those fees will then be subtracted from his balance, and is not affected by the fee update.\nThis would make a lot of the edge cases go away, and would make it a lot easier to verify that a node is not violating its channel reserve. Let me know if I\u2019m missing something.\n- Johan\n\nOn Tue, Jan 16, 2018 at 0:55, Rusty Russell <rusty at rustcorp.com.au> wrote:\nHi all,\n\nWanted to post some thinking on this for everyone to mull over,\nthough I know we're all busy.\n\nYour consideration and feedback gratefully accepted!\n\nProblem #1\n==========\nFor simplicity, one side (funder) sets fees, but other side\nneeds to check they're sufficient, and not insanely high (as *they* end\nup paying for HTLC txs). If they disagree, they close channel; this\nhappens a fair bit on testnet, for example, and will be worse with\ndifferent backends (eg. different bitcoind versions, or btcd, etc).\n\nSolution\n--------\nHave both sides set fees independently. I specify what fees my\ncommitment tx and HTLC txs will have, you do the same. This works in\nwell with dual-funder proposals.\n\nImplementation:\n--------------\nc-lightning did something similar pre-spec. The way it works is both\nsides set an initial fee in `open_channel`: this is the only point at\nwhich the counterparty checks it's reasonable.\n\nYou send an `update_fee` message like now, but it has no effect on the\nother side: it's applied to *you* when they 'revoke_and_ack', like any\nother change.\n\nYou disallow any `update_fee` which the other side could not afford with\n(1) all their current HTLCs, AND (2) the `max_accepted_htlcs` from you.\nThat covers the race where one side sets fees and the other adds a heap\nof HTLCs and the two cross over.\n\nAlso disallow any new HTLCs you can't pay fees for (given same\nworst-case calculation as above), and if the one side can't afford fees,\npull from its reserve and other side as necessary (this can only happen\nduring initial phase, and is the same logic as now).\n\n\nProblem #2\n==========\nPredicting the future is hard. Today's sufficient fee may be a gross\noverpayment or insufficient tomorrow.\n\nSolution\n--------\nAllow multiple simultaneous fee levels.\n\nImplementation:\n---------------\nThis means multiple signatures in each `commitment_signed` message,\nwhich is more work and more storage. But since our nSequence is <\n0xFFFFFFFE anyway, all transactions are RBF-ready except\nclosing_transaction. We might want to change that; we already allow\nre-negotiation of closing tx by reconnecting anyway.\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180117/bebe4a64/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Fee disentanglement for 1.1 spec?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell",
                "Johan Tor\u00e5s Halseth"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 6299
        }
    },
    {
        "title": "[Lightning-dev] negative fees for HTLC relay",
        "thread_messages": [
            {
                "author": "Benjamin Mord",
                "date": "2018-01-16T19:23:44",
                "message_text_only": "It isn't obvious to me from the BOLTs if fees can be negative, and I'm\nfinding uint in the go source code - which suggests not. In scenarios where\nthe funding of a payment channel has been fully committed in one direction,\nwhy not allow negative fees to incent unwinding, in scenarios where nodes\nconsider that cheaper than on-chain rebalancing?\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180116/e91b10db/attachment.html>"
            },
            {
                "author": "William Casarin",
                "date": "2018-01-16T19:58:11",
                "message_text_only": "Benjamin Mord <ben at mord.io> writes:\n> [..]\n> why not allow negative fees to incent unwinding, in scenarios where nodes\n> consider that cheaper than on-chain rebalancing?\n\nThis was brought up before here [1]:\n\nRusty Russell <rusty at rustcorp.com.au> writes:\n>> Edward Marynarz <edziumarynarz at gmail.com> writes:\n>> Another trivial question: can the fee be negative? It might help with some\n>> channel rebalancing.\n\n>In my original implementation, they could be.  However, that turns out\n>to be a very strange idea, and complicates routing.\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2017-December/000827.html\n\nCheers,\n\n-- \nhttps://jb55.com"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-16T20:32:09",
                "message_text_only": "Thanks. It sounds like it was dropped due to difficulty in the routing\nprotocol. Is that difficulty documented somewhere I can review? If so, I\nmight take a crack at a solution to it. But regardless I suggest the\nprotocol should support negative fees, even if an individual routing\nimplementation prefers to treat as 0 for simplicity. That should be up to\nthe implementation I think, and not a protocol constraint.\n\nOn Tue, Jan 16, 2018 at 2:58 PM, William Casarin <jb55 at jb55.com> wrote:\n\n> Benjamin Mord <ben at mord.io> writes:\n> > [..]\n> > why not allow negative fees to incent unwinding, in scenarios where nodes\n> > consider that cheaper than on-chain rebalancing?\n>\n> This was brought up before here [1]:\n>\n> Rusty Russell <rusty at rustcorp.com.au> writes:\n> >> Edward Marynarz <edziumarynarz at gmail.com> writes:\n> >> Another trivial question: can the fee be negative? It might help with\n> some\n> >> channel rebalancing.\n>\n> >In my original implementation, they could be.  However, that turns out\n> >to be a very strange idea, and complicates routing.\n>\n> [1] https://lists.linuxfoundation.org/pipermail/lightning-dev/\n> 2017-December/000827.html\n>\n> Cheers,\n>\n> --\n> https://jb55.com\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180116/79b12b13/attachment.html>"
            },
            {
                "author": "Will Yager",
                "date": "2018-01-16T22:45:03",
                "message_text_only": "I agree. Negative shadow prices are incredibly important for optimality of constrained network markets where flows in opposite directions cancel (as is the case with lightning). See for example FTRs.  It\u2019s unclear to me how well the analogy holds, but it\u2019s worth considering.\n\n\u2014Will\n\nOn Tue, Jan 16, 2018 at 3:32 PM, Benjamin Mord <ben at mord.io> wrote:\n\n> Thanks. It sounds like it was dropped due to difficulty in the routing protocol. Is that difficulty documented somewhere I can review? If so, I might take a crack at a solution to it. But regardless I suggest the protocol should support negative fees, even if an individual routing implementation prefers to treat as 0 for simplicity. That should be up to the implementation I think, and not a protocol constraint.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180116/b22f2a29/attachment-0001.html>"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2018-01-17T04:42:15",
                "message_text_only": "Negative fees also come up in the context of peer to peer credit using self issued IOUs (over colored coins or whatever) that are atomically swapped via a lightning HTLC. In this case negative fees may be the norm as there is incentive to rebalance from higher to lower interest IOUs.\n\n> On Jan 16, 2018, at 2:45 PM, Will Yager <lists at yager.io> wrote:\n> \n> I agree. Negative shadow prices are incredibly important for optimality of constrained network markets where flows in opposite directions cancel (as is the case with lightning). See for example FTRs.  It\u2019s unclear to me how well the analogy holds, but it\u2019s worth considering. \n> \n> \u2014Will\n> \n>> On Tue, Jan 16, 2018 at 3:32 PM, Benjamin Mord <ben at mord.io> wrote:\n>> \n>> Thanks. It sounds like it was dropped due to difficulty in the routing protocol. Is that difficulty documented somewhere I can review? If so, I might take a crack at a solution to it. But regardless I suggest the protocol should support negative fees, even if an individual routing implementation prefers to treat as 0 for simplicity. That should be up to the implementation I think, and not a protocol constraint.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180116/46be8616/attachment-0001.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-17T20:40:13",
                "message_text_only": "Benjamin Mord <ben at mord.io> writes:\n> It isn't obvious to me from the BOLTs if fees can be negative, and I'm\n> finding uint in the go source code - which suggests not. In scenarios where\n> the funding of a payment channel has been fully committed in one direction,\n> why not allow negative fees to incent unwinding, in scenarios where nodes\n> consider that cheaper than on-chain rebalancing?\n\nAfter discussing this for a while we decided not to allow negative fees\nin channel announcements (for now), because they actually do not add to\nthe flexibility and require special handling for route finding.\n\nThe main argument for negative fees has always been that they allow a\nchannel operator to rebalance its channels. However it is neither\nrequired, nor is it really all that helpful. If a node wants to\nrebalance he needs to find a cycle, that it can use to rebalance.  The\nsimplest rebalancing is that the node itself sends a payment along that\ncycle back to itself, giving the rebalancing node full control over the\namount to rebalance, timing and costs.\n\nThe negative fees were intended to encourage other participants to use\nany cycle and rebalance for the node offering the negative fees. However\nthat results in less control over the rebalancing for the node, e.g.,\nhow many payments to incentivize, amounts, etc. This is compounded by\nthe inherent delay of channel updates being disseminated in the\nnetwork. So if a rebalancing node gets too many payments that try to\ntake advantage of the negative fees, what should it do? It'd result in\neither losses for the node, or many forward rejections. So why not use\nthe funds one would have used towards negative fees for the active way\nof rebalancing.\n\nIt is preferable to have payments be routed around an exhausted channel,\nafter all if there is a cycle there must be an alternative route, rather\nthan trying to artificially rebalance.\n\nSo overall, allowing only positive fees makes routing simpler, and still\nallows for active rebalancing. As for other applications some have\nalluded to, this constraint is only for the routing gossip. Should there\nbe a good reason to allow increasing the amount forwarded by a peer,\ne.g., node n receives x from the previous hop and forwards x+e to the\nnext hop, that can still be negotiated out of band or even in the onion\npayload for that node.\n\nCheers,\nChristian"
            },
            {
                "author": "Mark Friedenbach",
                "date": "2018-01-17T23:06:42",
                "message_text_only": "It is not the case that all instances where you might have negative fees would have loops. One instance where you want this feature is when the network becomes too weighted in one side of the graph. Another is when the other side is a non-routable endpoint. In both cases would be useful to signal to others that you were willing to pay to rebalance, and this hand wavy argument about loops doesn\u2019t seem to apply.\n\n> On Jan 17, 2018, at 12:40 PM, Christian Decker <decker.christian at gmail.com> wrote:\n> \n> Benjamin Mord <ben at mord.io> writes:\n>> It isn't obvious to me from the BOLTs if fees can be negative, and I'm\n>> finding uint in the go source code - which suggests not. In scenarios where\n>> the funding of a payment channel has been fully committed in one direction,\n>> why not allow negative fees to incent unwinding, in scenarios where nodes\n>> consider that cheaper than on-chain rebalancing?\n> \n> After discussing this for a while we decided not to allow negative fees\n> in channel announcements (for now), because they actually do not add to\n> the flexibility and require special handling for route finding.\n> \n> The main argument for negative fees has always been that they allow a\n> channel operator to rebalance its channels. However it is neither\n> required, nor is it really all that helpful. If a node wants to\n> rebalance he needs to find a cycle, that it can use to rebalance.  The\n> simplest rebalancing is that the node itself sends a payment along that\n> cycle back to itself, giving the rebalancing node full control over the\n> amount to rebalance, timing and costs.\n> \n> The negative fees were intended to encourage other participants to use\n> any cycle and rebalance for the node offering the negative fees. However\n> that results in less control over the rebalancing for the node, e.g.,\n> how many payments to incentivize, amounts, etc. This is compounded by\n> the inherent delay of channel updates being disseminated in the\n> network. So if a rebalancing node gets too many payments that try to\n> take advantage of the negative fees, what should it do? It'd result in\n> either losses for the node, or many forward rejections. So why not use\n> the funds one would have used towards negative fees for the active way\n> of rebalancing.\n> \n> It is preferable to have payments be routed around an exhausted channel,\n> after all if there is a cycle there must be an alternative route, rather\n> than trying to artificially rebalance.\n> \n> So overall, allowing only positive fees makes routing simpler, and still\n> allows for active rebalancing. As for other applications some have\n> alluded to, this constraint is only for the routing gossip. Should there\n> be a good reason to allow increasing the amount forwarded by a peer,\n> e.g., node n receives x from the previous hop and forwards x+e to the\n> next hop, that can still be negotiated out of band or even in the onion\n> payload for that node.\n> \n> Cheers,\n> Christian\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-18T17:17:10",
                "message_text_only": "Mark Friedenbach <mark at friedenbach.org> writes:\n\n> It is not the case that all instances where you might have negative\n> fees would have loops.\n\nIf we don't have a cycle we can hardly talk about rebalancing\nchannels. At that point you're paying for someone else's payment to go\nthrough your channel, and I'm unclear what the motivation for that might\nbe. Anyway, this is still possible by communicating this out of band\nwith the payment creator, and should not be baked into the gossip\nprotocol itself, in my opinion. It's obscure enough to not be worth the\nextra effort.\n\n> One instance where you want this feature is when the network becomes\n> too weighted in one side of the graph.\n\nThere is little you can do to prevent this: if we have a network with a\nsmall cut, with a source and sink on opposite sides of that cut, no\namount of voluntary sacrifice from the nodes along the cut will have a\nlasting effect. The better solution would be to change the topology of\nthe network to remove the cut, or balance traffic over it, e.g., moving\na sink to the other side of the cut.\n\n> Another is when the other side is a non-routable endpoint. In both\n> cases would be useful to signal to others that you were willing to pay\n> to rebalance, and this hand wavy argument about loops doesn\u2019t seem to\n> apply.\n\nI'm not sure I understand what you mean with non-routable endpoint, so\ncorrect me if I'm wrong. I'm assuming that non-routable endpoint is a\nnon-publicly announced node in the network? In that case no fee tricks\nwill ever get people to route over it, since they can't even construct\nthe onion to talk to it. Notice that the payment requests allow for\nrecipients of payments to get paid by explicitly including the necessary\ninformation to construct the onion to talk to that node.\n\nNot trying to be dismissive here, and I might be getting this wrong, so\nlet me know if I did and what use-cases you had in mind :-)\n\nCheers,\nChristian"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-18T18:10:53",
                "message_text_only": "Although lightning and cryptocurrency is new, the idea of a distribution\nnetwork created from links with negotiated fees and with limited\nunidirectional capacity that can be corrected via rebalancing, is not new.\nIn fact there are several very large and mature markets around the world\nthat we can study which illustrate what people have found to work well in\nsuch contexts, and one class of such markets is wholesale electricity\ndistribution, such as PJM:\nhttp://www.pjm.com/about-pjm/who-we-are.aspx\n\nWhen Will Yager mentioned FTRs, he was referring to a specific financial\ninstrument traded on the PJM, for the purpose of managing load on\ntransmission lines. Much as with lightning payment channels, power flows in\none direction on a line can be canceled with power flows in the opposite\ndirection, and so FTR prices are therefore allowed to go negative on the\nPJM exchanges for the same reasons as discussed in this thread. If this has\nworked for them for some decades, I'm not sure why it wouldn't work for us\nalso.\n\nIn full disclosure, I should point out that this is not the same thing as\nelectricity transmission. Although they do have counterflow cancellation in\ncommon, payment channel balance is still more analogous to energy than\npower, whereas transmission capacity limits are in power and not energy.\nTime scales are long enough for manual intervention in PJM negotiations,\nwhereas timescales necessitate a high degree of automation in lightning\nnegotiation, as another difference. And there are other differences, and\nsome might matter.\n\nAt at a technical level, I see no complexity at all in allowing fees to go\nnegative. What is hard about allowing signed versus unsigned integers in\nthe protocol, and even passing them along? Perhaps there is complexity in a\nrouting algorithm which attempts to take full advantage of negative fees,\nand so perhaps implementations will prefer in the near term to pretend\nnegative fees are actually zero - but such implementations can easily pass\nalong info about negative fees even when they themselves choose not to\nfully avail themselves of the resulting opportunities. (At worst, some\nrecipients might receive an unexpected tip! There are worse fates in life.)\n\nAs relates to lightning's design goals, I applaud simplifying assumptions\nin the early implementations, as a matter of triage - but I would still\ndiscourage premature neutering of underlying protocol expressiveness, since\nthe resulting limitations can then linger or even come to motivate harmful\nor risky forks down the road. Passingly along signed instead of unsigned\nints is easy enough, and we can just cast to unsigned internally, wherever\nthat may be our local preference.\n\nIncidentally, if anyone is interested in exploring specific application of\nlightning to the electricity markets, please contact me offline at\nben at mord.io, as it happens I am attempting to organize such an effort.\nWhile I see opportunity here for collaborative and complimentary work that\ncould in turn boost lightning adoption, I want to be careful also not to\ndistract the lightning project from its already ambitious and laudable\nmission. Lightning must beware scope creep of a harmful sort, and I'll try\nto be disciplined in not encouraging it. We should still walk before we run.\n\n\nOn Thu, Jan 18, 2018 at 12:17 PM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> Mark Friedenbach <mark at friedenbach.org> writes:\n>\n> > It is not the case that all instances where you might have negative\n> > fees would have loops.\n>\n> If we don't have a cycle we can hardly talk about rebalancing\n> channels. At that point you're paying for someone else's payment to go\n> through your channel, and I'm unclear what the motivation for that might\n> be. Anyway, this is still possible by communicating this out of band\n> with the payment creator, and should not be baked into the gossip\n> protocol itself, in my opinion. It's obscure enough to not be worth the\n> extra effort.\n>\n> > One instance where you want this feature is when the network becomes\n> > too weighted in one side of the graph.\n>\n> There is little you can do to prevent this: if we have a network with a\n> small cut, with a source and sink on opposite sides of that cut, no\n> amount of voluntary sacrifice from the nodes along the cut will have a\n> lasting effect. The better solution would be to change the topology of\n> the network to remove the cut, or balance traffic over it, e.g., moving\n> a sink to the other side of the cut.\n>\n> > Another is when the other side is a non-routable endpoint. In both\n> > cases would be useful to signal to others that you were willing to pay\n> > to rebalance, and this hand wavy argument about loops doesn\u2019t seem to\n> > apply.\n>\n> I'm not sure I understand what you mean with non-routable endpoint, so\n> correct me if I'm wrong. I'm assuming that non-routable endpoint is a\n> non-publicly announced node in the network? In that case no fee tricks\n> will ever get people to route over it, since they can't even construct\n> the onion to talk to it. Notice that the payment requests allow for\n> recipients of payments to get paid by explicitly including the necessary\n> information to construct the onion to talk to that node.\n>\n> Not trying to be dismissive here, and I might be getting this wrong, so\n> let me know if I did and what use-cases you had in mind :-)\n>\n> Cheers,\n> Christian\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180118/e66006d8/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "negative fees for HTLC relay",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Will Yager",
                "Benjamin Mord",
                "William Casarin",
                "Mark Friedenbach",
                "Christian Decker"
            ],
            "messages_count": 9,
            "total_messages_chars_count": 18075
        }
    },
    {
        "title": "[Lightning-dev] How to use LN",
        "thread_messages": [
            {
                "author": "v e",
                "date": "2018-01-18T21:27:24",
                "message_text_only": "Hi,\n\nI am building merchant app and consumer wallet app using\nhttps://bitcoinj.github.io APIs for wallet creation. Now I want to use LN\nbuilt by your team. I am looking at this API\nhttps://github.com/ElementsProject/lightning-charge\n\nand have few questions:\n\n* Do i need to run bitcoin core node?\n* I see invoice apis, I assume that the invoice is generated at the\nmerchant wallet app. How do i tie the merchant wallet to the invoice?\n\n* similarly how do i send coins from consumer wallet to the created invoice?\n\nSorry I am very new to this and apologize my assumptions.\n\nAny help is highly appreciated.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180118/a3eb37e0/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-19T11:31:49",
                "message_text_only": "Hi v e,\n\nin order to use Lightning Charge you will need the following:\n\n - A full bitcoind node sync'd with the network\n - A c-lightning node\n - npm + lightgning-charge running to give you access to the REST API\n\nWe currently do not have (and may never have) bindings for bitcoinj.\n\nRe invoices: the invoices are tracked by c-lightning and you can store a\nreference to them in your store using the `payment_hash`. Customers will\nneed to have their own Lightning client and some channels open to the\nnetwork in order to send payments.\n\nCheers,\nChristian\n\nv e <veligeti999 at gmail.com> writes:\n> Hi,\n>\n> I am building merchant app and consumer wallet app using\n> https://bitcoinj.github.io APIs for wallet creation. Now I want to use LN\n> built by your team. I am looking at this API\n> https://github.com/ElementsProject/lightning-charge\n>\n> and have few questions:\n>\n> * Do i need to run bitcoin core node?\n> * I see invoice apis, I assume that the invoice is generated at the\n> merchant wallet app. How do i tie the merchant wallet to the invoice?\n>\n> * similarly how do i send coins from consumer wallet to the created invoice?\n>\n> Sorry I am very new to this and apologize my assumptions.\n>\n> Any help is highly appreciated.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            },
            {
                "author": "v e",
                "date": "2018-01-19T17:21:27",
                "message_text_only": "Thanks christian,\n\nWill do as you suggested. one another question, when you say customers do\nyou mean end clients who are buying goods and services?\n\nAlso i am building an server-client model where i am trying to host\nmultiple merchants who can accepts payments from end customers.\nDoes that mean i need to have (bitcoins node, c-lightning + charge) node\nper merchant?\n\n\nOn Fri, Jan 19, 2018 at 3:31 AM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> Hi v e,\n>\n> in order to use Lightning Charge you will need the following:\n>\n>  - A full bitcoind node sync'd with the network\n>  - A c-lightning node\n>  - npm + lightgning-charge running to give you access to the REST API\n>\n> We currently do not have (and may never have) bindings for bitcoinj.\n>\n> Re invoices: the invoices are tracked by c-lightning and you can store a\n> reference to them in your store using the `payment_hash`. Customers will\n> need to have their own Lightning client and some channels open to the\n> network in order to send payments.\n>\n> Cheers,\n> Christian\n>\n> v e <veligeti999 at gmail.com> writes:\n> > Hi,\n> >\n> > I am building merchant app and consumer wallet app using\n> > https://bitcoinj.github.io APIs for wallet creation. Now I want to use\n> LN\n> > built by your team. I am looking at this API\n> > https://github.com/ElementsProject/lightning-charge\n> >\n> > and have few questions:\n> >\n> > * Do i need to run bitcoin core node?\n> > * I see invoice apis, I assume that the invoice is generated at the\n> > merchant wallet app. How do i tie the merchant wallet to the invoice?\n> >\n> > * similarly how do i send coins from consumer wallet to the created\n> invoice?\n> >\n> > Sorry I am very new to this and apologize my assumptions.\n> >\n> > Any help is highly appreciated.\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180119/936ec06f/attachment.html>"
            },
            {
                "author": "Christian Decker",
                "date": "2018-01-20T13:41:53",
                "message_text_only": "v e <veligeti999 at gmail.com> writes:\n> Will do as you suggested. one another question, when you say customers do\n> you mean end clients who are buying goods and services?\n\nYes, they'll need to have clients that understand the Lightning protocol\njust like anyone else in the network.\n\n> Also i am building an server-client model where i am trying to host\n> multiple merchants who can accepts payments from end customers.\n> Does that mean i need to have (bitcoins node, c-lightning + charge) node\n> per merchant?\n\nNeither c-lightning nor Lightning Charge (or any other implementation\nfor that matter) is multi-tenant, which is what you're\ndescribing. Someone with access to the RPC has full control over all\nchannels and all funds in the daemon. Just like you wouldn't expose a\nraw bitcoind RPC interface to multiple users, you shouldn't directly\nexpose lightningd to multiple tenants. You can build a layer inbetween\nthat differentiates the tenants and controls access to individual\nresources though, but we don't currently support it directly.\n\nNotive also that we'd like to encourage every users, be it customer or\nshop, to run their own nodes, not rely on large managed infrastructure.\n\nCheers,\nChristian"
            },
            {
                "author": "v e",
                "date": "2018-01-25T20:48:12",
                "message_text_only": "Thanks Christian,\n\nI do know that i should not expose lighteningd to multiple tenants however,\nI am still trying to understand:\n\n1) How merchant wallet is tied up to an invoice?\n\n2) How consumer wallet can send satoshi to that invoice id?\n\nIf you have any code examples that would be great.\n\n\n\nOn Sat, Jan 20, 2018 at 5:41 AM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> v e <veligeti999 at gmail.com> writes:\n> > Will do as you suggested. one another question, when you say customers do\n> > you mean end clients who are buying goods and services?\n>\n> Yes, they'll need to have clients that understand the Lightning protocol\n> just like anyone else in the network.\n>\n> > Also i am building an server-client model where i am trying to host\n> > multiple merchants who can accepts payments from end customers.\n> > Does that mean i need to have (bitcoins node, c-lightning + charge) node\n> > per merchant?\n>\n> Neither c-lightning nor Lightning Charge (or any other implementation\n> for that matter) is multi-tenant, which is what you're\n> describing. Someone with access to the RPC has full control over all\n> channels and all funds in the daemon. Just like you wouldn't expose a\n> raw bitcoind RPC interface to multiple users, you shouldn't directly\n> expose lightningd to multiple tenants. You can build a layer inbetween\n> that differentiates the tenants and controls access to individual\n> resources though, but we don't currently support it directly.\n>\n> Notive also that we'd like to encourage every users, be it customer or\n> shop, to run their own nodes, not rely on large managed infrastructure.\n>\n> Cheers,\n> Christian\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180125/4ac806b7/attachment.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-25T21:16:50",
                "message_text_only": "Related, I am also interested in the differences between the three major\nlightning implementations: lnd, eclair, and c-lightning. I understand they\nare implemented in Go, Scala, and C, respectively. Are there other\nimportant differences for early adopters to consider, when selecting an\nimplementation?\n\n(Christian, I believe of these three implementations, you happen to work on\nc-lightning. Correct? Are there contributors from lnd and eclair on this\nlist as well?)\n\nOn Jan 25, 2018 3:48 PM, \"v e\" <veligeti999 at gmail.com> wrote:\n\nThanks Christian,\n\nI do know that i should not expose lighteningd to multiple tenants however,\nI am still trying to understand:\n\n1) How merchant wallet is tied up to an invoice?\n\n2) How consumer wallet can send satoshi to that invoice id?\n\nIf you have any code examples that would be great.\n\n\n\nOn Sat, Jan 20, 2018 at 5:41 AM, Christian Decker <\ndecker.christian at gmail.com> wrote:\n\n> v e <veligeti999 at gmail.com> writes:\n> > Will do as you suggested. one another question, when you say customers do\n> > you mean end clients who are buying goods and services?\n>\n> Yes, they'll need to have clients that understand the Lightning protocol\n> just like anyone else in the network.\n>\n> > Also i am building an server-client model where i am trying to host\n> > multiple merchants who can accepts payments from end customers.\n> > Does that mean i need to have (bitcoins node, c-lightning + charge) node\n> > per merchant?\n>\n> Neither c-lightning nor Lightning Charge (or any other implementation\n> for that matter) is multi-tenant, which is what you're\n> describing. Someone with access to the RPC has full control over all\n> channels and all funds in the daemon. Just like you wouldn't expose a\n> raw bitcoind RPC interface to multiple users, you shouldn't directly\n> expose lightningd to multiple tenants. You can build a layer inbetween\n> that differentiates the tenants and controls access to individual\n> resources though, but we don't currently support it directly.\n>\n> Notive also that we'd like to encourage every users, be it customer or\n> shop, to run their own nodes, not rely on large managed infrastructure.\n>\n> Cheers,\n> Christian\n>\n\n\n_______________________________________________\nLightning-dev mailing list\nLightning-dev at lists.linuxfoundation.org\nhttps://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180125/71b22b08/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "How to use LN",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker",
                "Benjamin Mord",
                "v e"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 9941
        }
    },
    {
        "title": "[Lightning-dev] Suggestion: Add optional IP address field to invoice format",
        "thread_messages": [
            {
                "author": "Ignatius Rivaldi",
                "date": "2018-01-26T11:35:13",
                "message_text_only": "Hi,\n\nI think that there is a potential problem for sellers to accept \nlightning network. They need someone to open a channel with them that is \nfilled with bitcoins so that they can start receiving bitcoins from \nother LN users. But what if a buyer can simultaneously open a channel \nand pay the seller? In order to do that they need to know the IP address \nof the seller and how much bitcoins they need to pay, so that they can \npush the appropriate amount of bitcoins to the seller side, satisfying \nthe seller's transaction. But currently we opened a channel using the \npubkey at ip format, which doesn't have amount information, and then we pay \nthem using lntb... format, which doesn't have IP address information.\n\nSo my suggestion is to add optional IP address field to the lntb... \ninvoice format. This will be optional because someone probably wants \nsome privacy using LN. But with this combined lntb... + IP address \ninvoice format, the LN wallet can be smarter in routing. Here are some \nscenarios:\n\n1. A seller gives this combined invoice to a buyer, and then the buyer's \nLN wallet finds a route, which it finds. Then there will be LN \ntransaction as usual.\n\n2. A buyer regularly buy something from this seller, and then the wallet \nnotices this, and then on the next transaction, the buyer's wallet will \ngive suggestion to the user such as a checkbox that say \"Open a xxx mBTC \nchannel for faster checkout next time\". If the user checks that \ncheckbox, the buyer's wallet will then do a LN transaction to the \nseller, while opening up a new channel toward the seller through another \non-chain transaction.\n\n3. A seller gives this combined invoice to a buyer, and then the buyer's \nLN wallet finds a route, which it fails to find. Then the buyer's wallet \nwill open a channel toward the seller, and then push the requested \namount of mBTC to the seller. Then the buyer's wallet will tell to the \nseller's wallet that we are essentially paying on-chain, and then the \nseller can react to it, for example if this is an online shop, they can \nask the buyer to wait for confirmations, or if this a coffee shop, the \nseller could just ignore it and go zero-confirmation.\n\nThis new invoice format, combined with channel autopilot, will make \nbetter user experience as they can be sure that they can always pay an \nLN capable seller, without any route not found error. This will also \nmakes the seller's lives easier, as they will have their channels opened \nand funded automatically by the buyers."
            }
        ],
        "thread_summary": {
            "title": "Suggestion: Add optional IP address field to invoice format",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ignatius Rivaldi"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2506
        }
    },
    {
        "title": "[Lightning-dev] lightning operation during / following a chain fork (e.g. BIP 50)",
        "thread_messages": [
            {
                "author": "Benjamin Mord",
                "date": "2018-01-29T16:15:25",
                "message_text_only": "Hi,\n\nOne topic I can't seem to find in the BOLTs is how lightning nodes maintain\nconsensus during or after a fork of the underlying blockchain(s). For\nexample, channel_announcement messages use a chain_hash, defined as hash of\nunderlying block chain's genesis block, to identify the currency in use.\nToday, one might ask which hash identifies BTC as opposed to BCH?\n\nA more difficult question arises in how existing channels handle\nintentional forks which arise after funding of a payment channel.\n\nAn even more difficult question arises in the handling of unintentional\nforks, as documented for example in BIP 50.\n\nHave these scenarios been analyzed / designed yet, or does that work remain?\n\nThanks!\nBen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180129/7b478ccf/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2018-01-30T06:16:02",
                "message_text_only": "Good morning Ben,\n\n> Hi,\n>\n> One topic I can't seem to find in the BOLTs is how lightning nodes maintain consensus during or after a fork of the underlying blockchain(s). For example, channel_announcement messages use a chain_hash, defined as hash of underlying block chain's genesis block, to identify the currency in use. Today, one might ask which hash identifies BTC as opposed to BCH?\n\nI believe the rough consensus among most Lightning developers is that BTC is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an altcoin that was forked off BTC and gets as hash the branching-off point.  You could try to convince people developing and using Lightning software to do the reverse, but I think it is unlikely that many people would agree to that.\n\n> A more difficult question arises in how existing channels handle intentional forks which arise after funding of a payment channel.\n>\n> An even more difficult question arises in the handling of unintentional forks, as documented for example in BIP 50.\n>\n> Have these scenarios been analyzed / designed yet, or does that work remain?\n\nThe work remains.  For the most part, the priority is to get implementations to a state, where we can safely deploy on Bitcoin Mainnet.  Then optimize further by adding RBF and multi-channel funding, then integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so on.  Greater support for altcoins can be done later.\n\nFor forked altcoins, short channel IDs contain the block height at which the funding transaction confirmed.  This might be used to judge if a channel contains forked coins or not.\n\nRegards,\nZmnSCPxj\n\n> Thanks!\n> Ben\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/6b952288/attachment.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-30T16:26:36",
                "message_text_only": "Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\nbelieve they don't even support segwit (!) so lightning would be unsafe due\nto their txid mutability bug. I agree altcoin support should be lower\npriority, whenever it is obvious which is the altcoin (as indeed, is\nabundantly clear wrt BTC vs BCH). But it might one day become unclear.\n\nI remain concerned about safety despite BIP 50 scenarios, forks with more\nlegitimate contention than so far seen, and also system stability in face\nof increasingly unsophisticated / gullible user base. As a cryptocurrency\nis little more than a trustless consensus mechanism, it seems circular to\nassume consensus in its design, especially if there are entities\nfinancially motivated to fracture that consensus. Resilience against forks\nwould seem core to safety. If I think of a concrete solution, I'll send it\nfirst to this list for discussion - as I believe that is the preferred\nprocess?\n\nThanks,\nBen\n\nOn Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n\n> Good morning Ben,\n>\n> Hi,\n>\n> One topic I can't seem to find in the BOLTs is how lightning nodes\n> maintain consensus during or after a fork of the underlying blockchain(s).\n> For example, channel_announcement messages use a chain_hash, defined as\n> hash of underlying block chain's genesis block, to identify the currency in\n> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>\n>\n> I believe the rough consensus among most Lightning developers is that BTC\n> is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n> altcoin that was forked off BTC and gets as hash the branching-off point.\n> You could try to convince people developing and using Lightning software to\n> do the reverse, but I think it is unlikely that many people would agree to\n> that.\n>\n>\n> A more difficult question arises in how existing channels handle\n> intentional forks which arise after funding of a payment channel.\n>\n> An even more difficult question arises in the handling of unintentional\n> forks, as documented for example in BIP 50.\n>\n> Have these scenarios been analyzed / designed yet, or does that work\n> remain?\n>\n>\n> The work remains.  For the most part, the priority is to get\n> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n> Then optimize further by adding RBF and multi-channel funding, then\n> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n> on.  Greater support for altcoins can be done later.\n>\n> For forked altcoins, short channel IDs contain the block height at which\n> the funding transaction confirmed.  This might be used to judge if a\n> channel contains forked coins or not.\n>\n> Regards,\n> ZmnSCPxj\n>\n>\n> Thanks!\n> Ben\n>\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/12f8f93b/attachment.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2018-01-30T16:31:43",
                "message_text_only": "\"Adversarial\" forks that rip out segwit, or maliciously do not change their\nsignature algorithm, are basically impossible to defend against. May be\nbest to focus energies on forks that use strong replay protection in the\nform of FORKID.\n\nOn Tue, Jan 30, 2018 at 11:26 AM, Benjamin Mord <ben at mord.io> wrote:\n\n>\n> Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\n> believe they don't even support segwit (!) so lightning would be unsafe due\n> to their txid mutability bug. I agree altcoin support should be lower\n> priority, whenever it is obvious which is the altcoin (as indeed, is\n> abundantly clear wrt BTC vs BCH). But it might one day become unclear.\n>\n> I remain concerned about safety despite BIP 50 scenarios, forks with more\n> legitimate contention than so far seen, and also system stability in face\n> of increasingly unsophisticated / gullible user base. As a cryptocurrency\n> is little more than a trustless consensus mechanism, it seems circular to\n> assume consensus in its design, especially if there are entities\n> financially motivated to fracture that consensus. Resilience against forks\n> would seem core to safety. If I think of a concrete solution, I'll send it\n> first to this list for discussion - as I believe that is the preferred\n> process?\n>\n> Thanks,\n> Ben\n>\n>\n> On Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:\n>\n>> Good morning Ben,\n>>\n>> Hi,\n>>\n>> One topic I can't seem to find in the BOLTs is how lightning nodes\n>> maintain consensus during or after a fork of the underlying blockchain(s).\n>> For example, channel_announcement messages use a chain_hash, defined as\n>> hash of underlying block chain's genesis block, to identify the currency in\n>> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>>\n>>\n>> I believe the rough consensus among most Lightning developers is that BTC\n>> is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n>> altcoin that was forked off BTC and gets as hash the branching-off point.\n>> You could try to convince people developing and using Lightning software to\n>> do the reverse, but I think it is unlikely that many people would agree to\n>> that.\n>>\n>>\n>> A more difficult question arises in how existing channels handle\n>> intentional forks which arise after funding of a payment channel.\n>>\n>> An even more difficult question arises in the handling of unintentional\n>> forks, as documented for example in BIP 50.\n>>\n>> Have these scenarios been analyzed / designed yet, or does that work\n>> remain?\n>>\n>>\n>> The work remains.  For the most part, the priority is to get\n>> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n>> Then optimize further by adding RBF and multi-channel funding, then\n>> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n>> on.  Greater support for altcoins can be done later.\n>>\n>> For forked altcoins, short channel IDs contain the block height at which\n>> the funding transaction confirmed.  This might be used to judge if a\n>> channel contains forked coins or not.\n>>\n>> Regards,\n>> ZmnSCPxj\n>>\n>>\n>> Thanks!\n>> Ben\n>>\n>>\n>>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/78bb9637/attachment-0001.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-30T16:41:09",
                "message_text_only": "Greg, I think you are confusing two different topics: adversarial forks,\nversus segwit as fix to transaction malleability.\n\nIf you remove segwit, i.e. if you reintroduce the txid malleability bug,\nthen lightning becomes unsafe - any nodes which attempt to follow such a\nfork would suffer. Incentives strongly motivate maintenance of consensus,\nso that scenario (I think?) is automatically covered and of no concern. (So\nactually, BCH is presently of no concern.) BOLTs as presently written\nexplicitly require segwit2x anyhow, and for this reason.\n\nI understand an \"adversarial fork\" is one which lacks replay protection, .\nThis is very much something worth addressing, as that is the case by\ndefault with a BIP 50-style accidental fork, and also appeared likely with\nthe failed (and poorly named) \"segwit2x\". But I'm thinking out loud, will\nstop spamming people on the list unless / until I have a usefully concrete\nsolution to offer. (Or until someone else comes up with something.)\n\n\nOn Tue, Jan 30, 2018 at 11:31 AM, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> \"Adversarial\" forks that rip out segwit, or maliciously do not change\n> their signature algorithm, are basically impossible to defend against. May\n> be best to focus energies on forks that use strong replay protection in the\n> form of FORKID.\n>\n> On Tue, Jan 30, 2018 at 11:26 AM, Benjamin Mord <ben at mord.io> wrote:\n>\n>>\n>> Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\n>> believe they don't even support segwit (!) so lightning would be unsafe due\n>> to their txid mutability bug. I agree altcoin support should be lower\n>> priority, whenever it is obvious which is the altcoin (as indeed, is\n>> abundantly clear wrt BTC vs BCH). But it might one day become unclear.\n>>\n>> I remain concerned about safety despite BIP 50 scenarios, forks with more\n>> legitimate contention than so far seen, and also system stability in face\n>> of increasingly unsophisticated / gullible user base. As a cryptocurrency\n>> is little more than a trustless consensus mechanism, it seems circular to\n>> assume consensus in its design, especially if there are entities\n>> financially motivated to fracture that consensus. Resilience against forks\n>> would seem core to safety. If I think of a concrete solution, I'll send it\n>> first to this list for discussion - as I believe that is the preferred\n>> process?\n>>\n>> Thanks,\n>> Ben\n>>\n>>\n>> On Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>> wrote:\n>>\n>>> Good morning Ben,\n>>>\n>>> Hi,\n>>>\n>>> One topic I can't seem to find in the BOLTs is how lightning nodes\n>>> maintain consensus during or after a fork of the underlying blockchain(s).\n>>> For example, channel_announcement messages use a chain_hash, defined as\n>>> hash of underlying block chain's genesis block, to identify the currency in\n>>> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>>>\n>>>\n>>> I believe the rough consensus among most Lightning developers is that\n>>> BTC is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n>>> altcoin that was forked off BTC and gets as hash the branching-off point.\n>>> You could try to convince people developing and using Lightning software to\n>>> do the reverse, but I think it is unlikely that many people would agree to\n>>> that.\n>>>\n>>>\n>>> A more difficult question arises in how existing channels handle\n>>> intentional forks which arise after funding of a payment channel.\n>>>\n>>> An even more difficult question arises in the handling of unintentional\n>>> forks, as documented for example in BIP 50.\n>>>\n>>> Have these scenarios been analyzed / designed yet, or does that work\n>>> remain?\n>>>\n>>>\n>>> The work remains.  For the most part, the priority is to get\n>>> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n>>> Then optimize further by adding RBF and multi-channel funding, then\n>>> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n>>> on.  Greater support for altcoins can be done later.\n>>>\n>>> For forked altcoins, short channel IDs contain the block height at which\n>>> the funding transaction confirmed.  This might be used to judge if a\n>>> channel contains forked coins or not.\n>>>\n>>> Regards,\n>>> ZmnSCPxj\n>>>\n>>>\n>>> Thanks!\n>>> Ben\n>>>\n>>>\n>>>\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/0da17217/attachment.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-30T16:42:59",
                "message_text_only": "Ugh, correction - BOLTs are presently written explicitly require segwit\n(not segwit2x! need more coffee...). Sorry for the 'typo'\n\nOn Tue, Jan 30, 2018 at 11:41 AM, Benjamin Mord <ben at mord.io> wrote:\n\n>\n> Greg, I think you are confusing two different topics: adversarial forks,\n> versus segwit as fix to transaction malleability.\n>\n> If you remove segwit, i.e. if you reintroduce the txid malleability bug,\n> then lightning becomes unsafe - any nodes which attempt to follow such a\n> fork would suffer. Incentives strongly motivate maintenance of consensus,\n> so that scenario (I think?) is automatically covered and of no concern. (So\n> actually, BCH is presently of no concern.) BOLTs as presently written\n> explicitly require segwit2x anyhow, and for this reason.\n>\n> I understand an \"adversarial fork\" is one which lacks replay protection, .\n> This is very much something worth addressing, as that is the case by\n> default with a BIP 50-style accidental fork, and also appeared likely with\n> the failed (and poorly named) \"segwit2x\". But I'm thinking out loud, will\n> stop spamming people on the list unless / until I have a usefully concrete\n> solution to offer. (Or until someone else comes up with something.)\n>\n>\n> On Tue, Jan 30, 2018 at 11:31 AM, Greg Sanders <gsanders87 at gmail.com>\n> wrote:\n>\n>> \"Adversarial\" forks that rip out segwit, or maliciously do not change\n>> their signature algorithm, are basically impossible to defend against. May\n>> be best to focus energies on forks that use strong replay protection in the\n>> form of FORKID.\n>>\n>> On Tue, Jan 30, 2018 at 11:26 AM, Benjamin Mord <ben at mord.io> wrote:\n>>\n>>>\n>>> Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\n>>> believe they don't even support segwit (!) so lightning would be unsafe due\n>>> to their txid mutability bug. I agree altcoin support should be lower\n>>> priority, whenever it is obvious which is the altcoin (as indeed, is\n>>> abundantly clear wrt BTC vs BCH). But it might one day become unclear.\n>>>\n>>> I remain concerned about safety despite BIP 50 scenarios, forks with\n>>> more legitimate contention than so far seen, and also system stability in\n>>> face of increasingly unsophisticated / gullible user base. As a\n>>> cryptocurrency is little more than a trustless consensus mechanism, it\n>>> seems circular to assume consensus in its design, especially if there are\n>>> entities financially motivated to fracture that consensus. Resilience\n>>> against forks would seem core to safety. If I think of a concrete solution,\n>>> I'll send it first to this list for discussion - as I believe that is the\n>>> preferred process?\n>>>\n>>> Thanks,\n>>> Ben\n>>>\n>>>\n>>> On Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>>> wrote:\n>>>\n>>>> Good morning Ben,\n>>>>\n>>>> Hi,\n>>>>\n>>>> One topic I can't seem to find in the BOLTs is how lightning nodes\n>>>> maintain consensus during or after a fork of the underlying blockchain(s).\n>>>> For example, channel_announcement messages use a chain_hash, defined as\n>>>> hash of underlying block chain's genesis block, to identify the currency in\n>>>> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>>>>\n>>>>\n>>>> I believe the rough consensus among most Lightning developers is that\n>>>> BTC is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n>>>> altcoin that was forked off BTC and gets as hash the branching-off point.\n>>>> You could try to convince people developing and using Lightning software to\n>>>> do the reverse, but I think it is unlikely that many people would agree to\n>>>> that.\n>>>>\n>>>>\n>>>> A more difficult question arises in how existing channels handle\n>>>> intentional forks which arise after funding of a payment channel.\n>>>>\n>>>> An even more difficult question arises in the handling of unintentional\n>>>> forks, as documented for example in BIP 50.\n>>>>\n>>>> Have these scenarios been analyzed / designed yet, or does that work\n>>>> remain?\n>>>>\n>>>>\n>>>> The work remains.  For the most part, the priority is to get\n>>>> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n>>>> Then optimize further by adding RBF and multi-channel funding, then\n>>>> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n>>>> on.  Greater support for altcoins can be done later.\n>>>>\n>>>> For forked altcoins, short channel IDs contain the block height at\n>>>> which the funding transaction confirmed.  This might be used to judge if a\n>>>> channel contains forked coins or not.\n>>>>\n>>>> Regards,\n>>>> ZmnSCPxj\n>>>>\n>>>>\n>>>> Thanks!\n>>>> Ben\n>>>>\n>>>>\n>>>>\n>>>\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/f330ebd6/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2018-01-30T16:55:58",
                "message_text_only": "Not sure there is much to be done in simple consensus failures. Agreed it's\na bit floaty unless there's an actual proposal.\n\nOn Tue, Jan 30, 2018 at 11:42 AM, Benjamin Mord <ben at mord.io> wrote:\n\n>\n> Ugh, correction - BOLTs are presently written explicitly require segwit\n> (not segwit2x! need more coffee...). Sorry for the 'typo'\n>\n> On Tue, Jan 30, 2018 at 11:41 AM, Benjamin Mord <ben at mord.io> wrote:\n>\n>>\n>> Greg, I think you are confusing two different topics: adversarial forks,\n>> versus segwit as fix to transaction malleability.\n>>\n>> If you remove segwit, i.e. if you reintroduce the txid malleability bug,\n>> then lightning becomes unsafe - any nodes which attempt to follow such a\n>> fork would suffer. Incentives strongly motivate maintenance of consensus,\n>> so that scenario (I think?) is automatically covered and of no concern. (So\n>> actually, BCH is presently of no concern.) BOLTs as presently written\n>> explicitly require segwit2x anyhow, and for this reason.\n>>\n>> I understand an \"adversarial fork\" is one which lacks replay protection,\n>> . This is very much something worth addressing, as that is the case by\n>> default with a BIP 50-style accidental fork, and also appeared likely with\n>> the failed (and poorly named) \"segwit2x\". But I'm thinking out loud, will\n>> stop spamming people on the list unless / until I have a usefully concrete\n>> solution to offer. (Or until someone else comes up with something.)\n>>\n>>\n>> On Tue, Jan 30, 2018 at 11:31 AM, Greg Sanders <gsanders87 at gmail.com>\n>> wrote:\n>>\n>>> \"Adversarial\" forks that rip out segwit, or maliciously do not change\n>>> their signature algorithm, are basically impossible to defend against. May\n>>> be best to focus energies on forks that use strong replay protection in the\n>>> form of FORKID.\n>>>\n>>> On Tue, Jan 30, 2018 at 11:26 AM, Benjamin Mord <ben at mord.io> wrote:\n>>>\n>>>>\n>>>> Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\n>>>> believe they don't even support segwit (!) so lightning would be unsafe due\n>>>> to their txid mutability bug. I agree altcoin support should be lower\n>>>> priority, whenever it is obvious which is the altcoin (as indeed, is\n>>>> abundantly clear wrt BTC vs BCH). But it might one day become unclear.\n>>>>\n>>>> I remain concerned about safety despite BIP 50 scenarios, forks with\n>>>> more legitimate contention than so far seen, and also system stability in\n>>>> face of increasingly unsophisticated / gullible user base. As a\n>>>> cryptocurrency is little more than a trustless consensus mechanism, it\n>>>> seems circular to assume consensus in its design, especially if there are\n>>>> entities financially motivated to fracture that consensus. Resilience\n>>>> against forks would seem core to safety. If I think of a concrete solution,\n>>>> I'll send it first to this list for discussion - as I believe that is the\n>>>> preferred process?\n>>>>\n>>>> Thanks,\n>>>> Ben\n>>>>\n>>>>\n>>>> On Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>>>> wrote:\n>>>>\n>>>>> Good morning Ben,\n>>>>>\n>>>>> Hi,\n>>>>>\n>>>>> One topic I can't seem to find in the BOLTs is how lightning nodes\n>>>>> maintain consensus during or after a fork of the underlying blockchain(s).\n>>>>> For example, channel_announcement messages use a chain_hash, defined as\n>>>>> hash of underlying block chain's genesis block, to identify the currency in\n>>>>> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>>>>>\n>>>>>\n>>>>> I believe the rough consensus among most Lightning developers is that\n>>>>> BTC is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n>>>>> altcoin that was forked off BTC and gets as hash the branching-off point.\n>>>>> You could try to convince people developing and using Lightning software to\n>>>>> do the reverse, but I think it is unlikely that many people would agree to\n>>>>> that.\n>>>>>\n>>>>>\n>>>>> A more difficult question arises in how existing channels handle\n>>>>> intentional forks which arise after funding of a payment channel.\n>>>>>\n>>>>> An even more difficult question arises in the handling of\n>>>>> unintentional forks, as documented for example in BIP 50.\n>>>>>\n>>>>> Have these scenarios been analyzed / designed yet, or does that work\n>>>>> remain?\n>>>>>\n>>>>>\n>>>>> The work remains.  For the most part, the priority is to get\n>>>>> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n>>>>> Then optimize further by adding RBF and multi-channel funding, then\n>>>>> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n>>>>> on.  Greater support for altcoins can be done later.\n>>>>>\n>>>>> For forked altcoins, short channel IDs contain the block height at\n>>>>> which the funding transaction confirmed.  This might be used to judge if a\n>>>>> channel contains forked coins or not.\n>>>>>\n>>>>> Regards,\n>>>>> ZmnSCPxj\n>>>>>\n>>>>>\n>>>>> Thanks!\n>>>>> Ben\n>>>>>\n>>>>>\n>>>>>\n>>>>\n>>>> _______________________________________________\n>>>> Lightning-dev mailing list\n>>>> Lightning-dev at lists.linuxfoundation.org\n>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>\n>>>>\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/bef20077/attachment.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-30T17:23:11",
                "message_text_only": "Oh wait - I think we're covered. Any node \"B\" which follows the \"wrong\"\nfork (according to judgement of node \"A\"), will at worst be\nindistinguishable from a fraudulent node that attempts to mimic the\nlightning protocol while failing to transmit the expected blockchain\ntransactions during channel funding or closure. But the protocol is already\ndesigned to be robust against nodes failing to broadcast expected\nblockchain transactions, so we get fork protection as byproduct. Correct?\nIf so, this point might be worth advertising in either BOLT 2 or 5. In some\nways, this might even strengthen consensus of the underlying blockchain.\n\nPerhaps the only caveat is we must not get carried away with excessive\npenalties against nodes who fail to broadcast blockchain transactions, if\nthose penalties are given to others. In aggregate, such penalties could\nturn needless forking into a profit opportunity for\ndisingenuous-yet-sophisticated nodes at expense of sincere nodes, which in\nturn might motivate forking.\n\nOn Tue, Jan 30, 2018 at 11:55 AM, Greg Sanders <gsanders87 at gmail.com> wrote:\n\n> Not sure there is much to be done in simple consensus failures. Agreed\n> it's a bit floaty unless there's an actual proposal.\n>\n> On Tue, Jan 30, 2018 at 11:42 AM, Benjamin Mord <ben at mord.io> wrote:\n>\n>>\n>> Ugh, correction - BOLTs are presently written explicitly require segwit\n>> (not segwit2x! need more coffee...). Sorry for the 'typo'\n>>\n>> On Tue, Jan 30, 2018 at 11:41 AM, Benjamin Mord <ben at mord.io> wrote:\n>>\n>>>\n>>> Greg, I think you are confusing two different topics: adversarial forks,\n>>> versus segwit as fix to transaction malleability.\n>>>\n>>> If you remove segwit, i.e. if you reintroduce the txid malleability bug,\n>>> then lightning becomes unsafe - any nodes which attempt to follow such a\n>>> fork would suffer. Incentives strongly motivate maintenance of consensus,\n>>> so that scenario (I think?) is automatically covered and of no concern. (So\n>>> actually, BCH is presently of no concern.) BOLTs as presently written\n>>> explicitly require segwit2x anyhow, and for this reason.\n>>>\n>>> I understand an \"adversarial fork\" is one which lacks replay protection,\n>>> . This is very much something worth addressing, as that is the case by\n>>> default with a BIP 50-style accidental fork, and also appeared likely with\n>>> the failed (and poorly named) \"segwit2x\". But I'm thinking out loud, will\n>>> stop spamming people on the list unless / until I have a usefully concrete\n>>> solution to offer. (Or until someone else comes up with something.)\n>>>\n>>>\n>>> On Tue, Jan 30, 2018 at 11:31 AM, Greg Sanders <gsanders87 at gmail.com>\n>>> wrote:\n>>>\n>>>> \"Adversarial\" forks that rip out segwit, or maliciously do not change\n>>>> their signature algorithm, are basically impossible to defend against. May\n>>>> be best to focus energies on forks that use strong replay protection in the\n>>>> form of FORKID.\n>>>>\n>>>> On Tue, Jan 30, 2018 at 11:26 AM, Benjamin Mord <ben at mord.io> wrote:\n>>>>\n>>>>>\n>>>>> Thank you, ZmnSCPxj. BCH is a warmup question for several reasons, I\n>>>>> believe they don't even support segwit (!) so lightning would be unsafe due\n>>>>> to their txid mutability bug. I agree altcoin support should be lower\n>>>>> priority, whenever it is obvious which is the altcoin (as indeed, is\n>>>>> abundantly clear wrt BTC vs BCH). But it might one day become unclear.\n>>>>>\n>>>>> I remain concerned about safety despite BIP 50 scenarios, forks with\n>>>>> more legitimate contention than so far seen, and also system stability in\n>>>>> face of increasingly unsophisticated / gullible user base. As a\n>>>>> cryptocurrency is little more than a trustless consensus mechanism, it\n>>>>> seems circular to assume consensus in its design, especially if there are\n>>>>> entities financially motivated to fracture that consensus. Resilience\n>>>>> against forks would seem core to safety. If I think of a concrete solution,\n>>>>> I'll send it first to this list for discussion - as I believe that is the\n>>>>> preferred process?\n>>>>>\n>>>>> Thanks,\n>>>>> Ben\n>>>>>\n>>>>>\n>>>>> On Tue, Jan 30, 2018 at 1:16 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com>\n>>>>> wrote:\n>>>>>\n>>>>>> Good morning Ben,\n>>>>>>\n>>>>>> Hi,\n>>>>>>\n>>>>>> One topic I can't seem to find in the BOLTs is how lightning nodes\n>>>>>> maintain consensus during or after a fork of the underlying blockchain(s).\n>>>>>> For example, channel_announcement messages use a chain_hash, defined as\n>>>>>> hash of underlying block chain's genesis block, to identify the currency in\n>>>>>> use. Today, one might ask which hash identifies BTC as opposed to BCH?\n>>>>>>\n>>>>>>\n>>>>>> I believe the rough consensus among most Lightning developers is that\n>>>>>> BTC is \"the real BTC\" and gets the Satoshi genesis hash, while BCH is an\n>>>>>> altcoin that was forked off BTC and gets as hash the branching-off point.\n>>>>>> You could try to convince people developing and using Lightning software to\n>>>>>> do the reverse, but I think it is unlikely that many people would agree to\n>>>>>> that.\n>>>>>>\n>>>>>>\n>>>>>> A more difficult question arises in how existing channels handle\n>>>>>> intentional forks which arise after funding of a payment channel.\n>>>>>>\n>>>>>> An even more difficult question arises in the handling of\n>>>>>> unintentional forks, as documented for example in BIP 50.\n>>>>>>\n>>>>>> Have these scenarios been analyzed / designed yet, or does that work\n>>>>>> remain?\n>>>>>>\n>>>>>>\n>>>>>> The work remains.  For the most part, the priority is to get\n>>>>>> implementations to a state, where we can safely deploy on Bitcoin Mainnet.\n>>>>>> Then optimize further by adding RBF and multi-channel funding, then\n>>>>>> integrate Burchert-Decker-Wattenhofer channel factories, splicing, and so\n>>>>>> on.  Greater support for altcoins can be done later.\n>>>>>>\n>>>>>> For forked altcoins, short channel IDs contain the block height at\n>>>>>> which the funding transaction confirmed.  This might be used to judge if a\n>>>>>> channel contains forked coins or not.\n>>>>>>\n>>>>>> Regards,\n>>>>>> ZmnSCPxj\n>>>>>>\n>>>>>>\n>>>>>> Thanks!\n>>>>>> Ben\n>>>>>>\n>>>>>>\n>>>>>>\n>>>>>\n>>>>> _______________________________________________\n>>>>> Lightning-dev mailing list\n>>>>> Lightning-dev at lists.linuxfoundation.org\n>>>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>>>\n>>>>>\n>>>>\n>>>\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180130/cd1d60d9/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "lightning operation during / following a chain fork (e.g. BIP 50)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Greg Sanders",
                "ZmnSCPxj",
                "Benjamin Mord"
            ],
            "messages_count": 8,
            "total_messages_chars_count": 30883
        }
    },
    {
        "title": "[Lightning-dev] Receiving node on mainnet?",
        "thread_messages": [
            {
                "author": "Cezary Dziemian",
                "date": "2018-01-29T21:09:29",
                "message_text_only": "Hello,\n\nBecause mainnet is growing, I would also like to make some mainnet tests. I\nwould like to be able to receive funds by LN. I ques in order to do that I\nneed to talk with some of existing nodes to convince him to \"lock\" funds on\nhis side. Do you know any place, when people who setup mainnet nodes can\ndiscuss?\n\nRegards,\nCezary\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180129/0b0d47e6/attachment.html>"
            },
            {
                "author": "Jim Rogers",
                "date": "2018-01-29T21:27:18",
                "message_text_only": "I recommend the Lightning Network subreddit: https://www.reddit.com/domain/lightning.network/\n\n \n\nThere is quite a bit of discussion there from those with mainnet Lightning Network nodes. I am sure that you will be able to find plenty of people to test with you there.\n\n \n\n \n\n \n\nFrom: lightning-dev-bounces at lists.linuxfoundation.org [mailto:lightning-dev-bounces at lists.linuxfoundation.org] On Behalf Of Cezary Dziemian\nSent: Monday, January 29, 2018 12:09 PM\nTo: lightning-dev at lists.linuxfoundation.org\nSubject: [Lightning-dev] Receiving node on mainnet?\n\n \n\nHello,\n\n\nBecause mainnet is growing, I would also like to make some mainnet tests. I would like to be able to receive funds by LN. I ques in order to do that I need to talk with some of existing nodes to convince him to \"lock\" funds on his side. Do you know any place, when people who setup mainnet nodes can discuss?\n\nRegards,\nCezary\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180129/02efe9e8/attachment.html>"
            },
            {
                "author": "Ad\u00e1n S\u00e1nchez de Pedro Crespo",
                "date": "2018-01-29T22:10:48",
                "message_text_only": "I can recommend the #mainnet channel on the LN Discord:\n\nhttps://discord.gg/QD7xzz3\n\nAlso, feel free to tell me your node_id and IP address and I'll be more\nthan happy to open a channel to you and play \"the invoice game\" back and\nforth ;)\n\n-- \nAd\u00e1n S\u00e1nchez de Pedro Crespo\nCTO, Stampery Inc.\nSan Francisco - Madrid\n\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180129/67c011f5/attachment-0001.sig>"
            },
            {
                "author": "Cezary Dziemian",
                "date": "2018-01-29T22:25:03",
                "message_text_only": "Thanks for help. Ad\u00e1n - will tell my node_id on discord then. Don't want to\nmake big off-topic on dev mailing list.\n\n2018-01-29 23:10 GMT+01:00 Ad\u00e1n S\u00e1nchez de Pedro Crespo <adan at stampery.co>:\n\n> I can recommend the #mainnet channel on the LN Discord:\n>\n> https://discord.gg/QD7xzz3\n>\n> Also, feel free to tell me your node_id and IP address and I'll be more\n> than happy to open a channel to you and play \"the invoice game\" back and\n> forth ;)\n>\n> --\n> Ad\u00e1n S\u00e1nchez de Pedro Crespo\n> CTO, Stampery Inc.\n> San Francisco - Madrid\n>\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180129/8e475b09/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Receiving node on mainnet?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ad\u00e1n S\u00e1nchez de Pedro Crespo",
                "Cezary Dziemian",
                "Jim Rogers"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 3128
        }
    },
    {
        "title": "[Lightning-dev] lnd on bitcoind",
        "thread_messages": [
            {
                "author": "Benjamin Mord",
                "date": "2018-01-31T20:22:56",
                "message_text_only": "Hi,\n\nI'm not finding evidence of segwit in btcd, yet choice of golang is\nappealing to me. Can one run lnd on bitcoind?\n\nMore generally speaking, is there a plan for the layer 2 / layer 1 protocol\nbinding to be abstracted away from the implementation on either side, via\nSPI or such?\n\nThanks,\nBen\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180131/a4570a8b/attachment.html>"
            },
            {
                "author": "Olaoluwa Osuntokun",
                "date": "2018-01-31T20:43:44",
                "message_text_only": "Segwit has been merged into btcd for for sometime now. It's also possible to\nrun with bitcoind. I encourage you to check out the documentation:\nhttps://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md\n\nIn lnd, the chain backend has already been abstracted[1]. This is what\nallows\nit to run with any of the three supported chain backends (btcd, bitcoind,\nneutrino). I invite you to continue this conversation on #lnd on Freenode.\n\n[1]:\nhttps://github.com/lightningnetwork/lnd/blob/master/lnwallet/interface.go\n\nOn Wed, Jan 31, 2018 at 12:23 PM Benjamin Mord <ben at mord.io> wrote:\n\n> Hi,\n>\n> I'm not finding evidence of segwit in btcd, yet choice of golang is\n> appealing to me. Can one run lnd on bitcoind?\n>\n> More generally speaking, is there a plan for the layer 2 / layer 1\n> protocol binding to be abstracted away from the implementation on either\n> side, via SPI or such?\n>\n> Thanks,\n> Ben\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180131/b2f3e156/attachment.html>"
            },
            {
                "author": "Benjamin Mord",
                "date": "2018-01-31T21:28:00",
                "message_text_only": "Thanks - the installation instructions you linked to say otherwise (the\nreason I asked), but perhaps they just need to be updated.\n\n*\"Installing btcd*\n*lnd currently requires btcd with segwit support, which is not yet merged\ninto the master branch. Instead, roasbeef maintains a fork with his segwit\nimplementation applied. To install, run the following commands:\"*\n\n\n\nOn Wed, Jan 31, 2018 at 3:43 PM, Olaoluwa Osuntokun <laolu32 at gmail.com>\nwrote:\n\n> Segwit has been merged into btcd for for sometime now. It's also possible\n> to\n> run with bitcoind. I encourage you to check out the documentation:\n> https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md\n>\n> In lnd, the chain backend has already been abstracted[1]. This is what\n> allows\n> it to run with any of the three supported chain backends (btcd, bitcoind,\n> neutrino). I invite you to continue this conversation on #lnd on Freenode.\n>\n> [1]: https://github.com/lightningnetwork/lnd/blob/\n> master/lnwallet/interface.go\n>\n> On Wed, Jan 31, 2018 at 12:23 PM Benjamin Mord <ben at mord.io> wrote:\n>\n>> Hi,\n>>\n>> I'm not finding evidence of segwit in btcd, yet choice of golang is\n>> appealing to me. Can one run lnd on bitcoind?\n>>\n>> More generally speaking, is there a plan for the layer 2 / layer 1\n>> protocol binding to be abstracted away from the implementation on either\n>> side, via SPI or such?\n>>\n>> Thanks,\n>> Ben\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180131/ffd52b92/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "lnd on bitcoind",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Olaoluwa Osuntokun",
                "Benjamin Mord"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 3547
        }
    }
]