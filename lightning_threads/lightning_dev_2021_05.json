[
    {
        "title": "[Lightning-dev] Recovery of Lightning channels without backups",
        "thread_messages": [
            {
                "author": "Lloyd Fournier",
                "date": "2021-05-03T01:01:48",
                "message_text_only": "On Thu, 29 Apr 2021 at 06:15, David A. Harding <dave at dtrt.org> wrote:\n\n> why can't she sign a message that gets gossiped across the network that\n> says, \"if you have a channel with node_id 0xa11ce, please close it now\"?\n>\n\nHi David,\n\nAs a user this would be an improvement. There are a few downsides though:\n\n1. It creates a new gossip message that can be spammed.\n2. It is not easy to figure out whether it worked or not (maybe the person\nI had my channel with is offline?).\n3. This is incompatible with covert recovery schemes like in [1] whereas\nwhat I propose here builds towards making such schemes possible in the\nfuture.\n\n(3) is also a problem with just doing encrypted backups -- going around\nlooking for backups means you tell everyone that you are in recovery mode.\n\n[1]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-December/002912.html\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210503/2e8afd2a/attachment.html>"
            },
            {
                "author": "David A. Harding",
                "date": "2021-05-03T12:50:16",
                "message_text_only": "On Mon, May 03, 2021 at 11:01:48AM +1000, Lloyd Fournier wrote:\n> 2. It is not easy to figure out whether it worked or not\n\nGood point.\n\n> 3. This is incompatible with covert recovery schemes like in [1] [...]\n> (3) is also a problem with just doing encrypted backups -- going around\n> looking for backups means you tell everyone that you are in recovery mode.\n\nEh, I assume nodes using the backup commons would, each time they're\nrestarted, go through the steps of downloading some number of backups\neven if they haven't lost any data.  This tests that the backups are\nbeing stored faithfully (essential to any backup process) and provides\ncover for cases where a node does lose data.\n\nThus encrypted backups seem fully compatible to me with covert recovery.\nSorry, I didn't realize that compatibility was one of your design goals\nfor seed-based peer rediscovery.\n\n-Dave\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 833 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210503/104ee3c0/attachment.sig>"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-05-03T22:42:10",
                "message_text_only": "On Mon, 3 May 2021 at 22:58, David A. Harding <dave at dtrt.org> wrote:\n\n> On Mon, May 03, 2021 at 11:01:48AM +1000, Lloyd Fournier wrote:\n> > 2. It is not easy to figure out whether it worked or not\n>\n> Good point.\n>\n> > 3. This is incompatible with covert recovery schemes like in [1] [...]\n> > (3) is also a problem with just doing encrypted backups -- going around\n> > looking for backups means you tell everyone that you are in recovery\n> mode.\n>\n> Eh, I assume nodes using the backup commons would, each time they're\n> restarted, go through the steps of downloading some number of backups\n> even if they haven't lost any data.  This tests that the backups are\n> being stored faithfully (essential to any backup process) and provides\n> cover for cases where a node does lose data.\n>\n\nOk this is a fun idea and hadn't thought of it like that before. Here are\nthe thoughts that come to mind:\n\n1. Each time you start up your node you backup you go around to different\nnodes -- but the obvious question is *which* nodes do you go to? You could\ntry and do something like rendezvous hashing [1] to reduce the set (with\nsome secret data as input so it is not predictable to anyone but yourself) .\n2. What do you backup? Full-channel state or just a channel list? Even if\nyou have mostly honest backup nodes you need to make sure you delete old\nstates from your remote backups before revoking them if you do full\nbackups. This slows down sending payments but it might be worth it for\nusers like myself. So perhaps it's still better to avoid full backups here.\n\n[1] https://en.wikipedia.org/wiki/Rendezvous_hashing\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210504/dec95c85/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Recovery of Lightning channels without backups",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "David A. Harding",
                "Lloyd Fournier"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 4002
        }
    },
    {
        "title": "[Lightning-dev] [RFC] Simplified (but less optimal) HTLC Negotiation",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-05-04T04:50:40",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> On 4/27/21 17:32, Rusty Russell wrote:\n>> OK, draft is up:\n>> \n>>          https://github.com/lightningnetwork/lightning-rfc/pull/867\n>> \n>> I have to actually implement it now (though the real win comes from\n>> making it compulsory, but that's a fair way away).\n>> \n>> Notably, I added the requirement that update_fee messages be on their\n>> own.  This means there's no debate on the state of the channel when\n>> this is being applied.\n>\n> I do have to admit *that* part I like :).\n>\n> If we don't do turns for splicing, I wonder if we can take the rules around splicing pausing other HTLC updates, make \n> them generic for future use, and then also use them for update_fee in a simpler-to-make-compulsory change :).\n\nYes, it is similar to the close requirement, except that requires all\nHTLCs be absent.\n\nCheers,\nRusty."
            },
            {
                "author": "Rusty Russell",
                "date": "2021-05-04T05:03:35",
                "message_text_only": "Matt Corallo <lf-lists at mattcorallo.com> writes:\n> On 4/27/21 01:04, Rusty Russell wrote:\n>> Matt Corallo <lf-lists at mattcorallo.com> writes:\n>>>> On Apr 24, 2021, at 01:56, Rusty Russell <rusty at rustcorp.com.au> wrote:\n>>>>\n>>>> \ufeffMatt Corallo <lf-lists at mattcorallo.com> writes:\n>>> I promise it\u2019s much less work than it sounds like, and avoids having to debug these things based on logs, which is a huge pain :). Definitely less work than a new state machine:).\n>> \n>> But the entire point of this proposal is that it's a subset of the\n>> existing state machine?\n>\n> Compared to today, its a good chunk of additional state machine logic to enforce when a message can or can not be sent, \n> and additional logic for when we can (or can not) flush any pending\n> changes buffer(s)\n\nKind of.  I mean, we can add a \"update_noop\" message which simply\nrequests your turn and has no other effects.\n\n>> The only \"twist\" is that if it's your turn and you receive an update,\n>> you can either reply with a \"yield\" message, or ignore it.\n>\n> How do you handle the \"no changes to make\" case - do you send yields back and forth ever Nms all day long or is there \n> some protocol by which you resolve it when both parties try to claim turn at once?\n\nYou don't do anything?\n\nIf you want to send an update:\n1. If it is your turn, send it.\n2. If it is not your turn, send it and wait for either a `yield`, or a\n   different update.  In the former case, it's now your turn, in the\n   latter case it's not and your update was ignored.\n\nIf you receive an update when it's your turn:\n1. If you've sent an update already, ignore it.\n2. Otherwise, send `yield`.\n\n>>> Isn\u2019t that pretty similar? Discard one splice proposal deterministically (ok that\u2019s new) and the loser has to store their proposal in a holding cell for later (which they have to do in turn-based anyway). Logic to check if there\u2019s unsettled things in RAA handling is pretty similar to turn-based, and logic to reject other messages is the same as shutdown handling today.\n>> \n>> Nope, with the simplified protocol you can `update_splice` at any time\n>> instead of your normal update, since both sides are already in sync.\n>\n> Hmm, I'm somewhat failing to understand why its that different - you can only update_splice if its your turn, which is \n> about exactly the same amount of additional logic to check turn conditions as just flag \"want to do splice\". Either way \n> you have the same pending splice buffer.\n\nNo, for turn-taking, this case is exactly like any other update.\n\nFor non-turn taking, we need an explicit quiescence protocol, and to\nhandle simultanous splicing.\n\n>>>> - MUST use the higher of the two `funding_feerate_perkw` as the feerate for\n>>>>   the splice.\n>>>\n>>> If we like turn based, why not just deterministic throw out one slice? :)\n>> \n>> Because while I am going to implement turn-based, I'm not sure if anyone\n>> else is.  I guess we'll see?\n>\n> My point was more that its similar in logic - if you throw out the splice deterministically and just keep it in some \n> \"pending slice\" buffer on the sending side, you've just done basically what you'd do to implement turns, while keeping \n> the non-turn slice protocol a bit easier :).\n\nNo, you really haven't.  Right now you can have Alice propose a splice\nwhile Bob proposes at the same time, so we have a tiebreak protocol.\nAnd you can have Alice propose a splice while Bob proposes a different\nupdate which needs to be completely resolved before the splice can\ncontinue.\n\nWhereas in turn taking, when someone proposes a splice, that's what\nyou're doing, as soon as it is received.  And when someone wants to\npropose a splice, they can do it as soon as it's their turn.  If it's\nnot their turn and the other side proposes a splice, they can jump onto\nthat (happy days, since the splice proposer pays for 1 input 1 output\nand the core of the tx!).\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Simplified (but less optimal) HTLC Negotiation",
            "categories": [
                "Lightning-dev",
                "RFC"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4769
        }
    },
    {
        "title": "[Lightning-dev] On Mempool Funny Games against Multi-Party Funded Transactions",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2021-05-06T13:44:04",
                "message_text_only": "Hi,\n\nIn this post I would like to highlight some DoS attacks against multi-party\nBitcoin protocols during their funding phases. Recent discussions around\nDLC funding flow [0] and dual-funding of LN channel [1] remind me that some\ntimevalue DoS/fee inflation issues are common to any multi-party funded\ntransactions. I'm not sure how much developers meddle in that kind of\nprotocols/applications are aware of them and how well they mitigate against\nthem.\n\nThe first issue is a timevalue DoS by exploiting standardness malleability.\nThe second one is a fee inflation one by exploiting RBF policy rules. User\nutxo aren't directly at risk but those attacks might reveal themselves as\nsevere nuisances. More sophisticated variations do exist, but those ones\nare pretty easy and cheap to execute with a high-rate of success.\n\n# The Model : Multi-Party Funded Transaction\n\nLet's say Alice, Bob and Caroll commit one input in a single transaction.\nEach of them receive inputs from others, verify the outpoint existence (and\nis a segwit one if you have a chain of child transactions) and sign the\nwhole transaction data with sighash_all to enforce the expected protocol\nsemantics. One of them collects all the witnesses and broadcasts the\nfinalized transaction. This broadcaster might be responsible to fee-bump\nthe transaction through CPFP if the feerate as previously negotiated isn't\ngood enough for a quick confirmation.\n\nOnce the transaction is confirmed, the protocol moves in its operation\nphase (e.g start channel updates) or might even end up here (e.g a basic\none-stage coinjoin). But those later phases are out of concern.\n\nI think this rough model applies to a wide set of L2 bitcoin protocols\n(DLC, Coinjoin, Payjoin, dual-funded LN channel, swaps ?). Notice that\n*single-party funded*, multi-party transactions (e.g batching_tx to N\npayouts) are excluded from this discussion. Although they do share the same\nrisks, exploits against them are a bit harder, as the attacker has to\nexecute a real RBF-pinning on a payout output, more costly in feerate.\n\nAccepting input and committing coins with a low-trusted counterparty opens\nthe way to some troubles.\n\n# 1st issue : Standardness Malleability of Counterparty Input\n\nCurrent Core's script interpreter is applying some stricter checks beyond\nthe consensus one, like MINIMALIF or NULLFAIL (bip143). While non-compliant\nwith those checks, witness data might still succeed consensus checks. A L2\nclient only verifying input for consensus validity will miss standardness\nvalidity and sign/broadcast a non-propagating transaction.\n\nIn the model described above, Alice might furnish a non-MINIMALIF compliant\np2wsh spending input to Bob and Caroll, they will accept it as a valid\ninput, finish the transaction finalization and try to broadcast. It will\nfail to propagate and confirm. If Bob and Caroll are relying on a\nfull-node, they can observe the failure directly and move their coins.\nOtherwise, if they don't have access to a mempool policy verifier, they\nshould move their coins after some timeout.\n\nIn both cases, victims of this malleability will waste timevalue on their\ncoins and likely fees for a double-spend of their honest inputs, as it's\nbetter to cancel out the corrupted multi-party funding transaction. If the\ndouble-spend timeout only occurs after a meaningful timeout, e.g 2048\nblocks ahead from signatures exchange like for the recent LN change [2],\nthis timevalue loss might be in the same range that one's suffered on LN's\nrevokeable outputs. The attacker coin might be of far lower value than the\nvictim ones and the asymmetry should be underscored, *one* malicious input\nlets you affect *N* victim ones.\n\nAs a simple mitigation, participants of the multi-party funded transaction\nshould verify the absence of standardness malleability of contributed\nwitnessScripts. Though AFAIK, we don't have such tooling available\nready-to-integrate in L2 stack client [3].\n\nNotice, I'm not considering timevalue DoS inflicted by malicious\nbroadcaster/orchestrator, where signatures are collected but transaction\nbroadcast is withheld. This should be minded at counterparty/service\nselection but it's beyond the scope of an analysis centered on\nmempool/tx-relay risks.\n\n# 2nd issue : RBF opt-out by a Counterparty Double-Spend\n\nCurrent bip125 RBF rules make signaling mandatory to enable replacement,\notherwise even a better-feerate candidate won't replace a conflicting\ntransaction with a finalized nSequence field [4]. A L2 client might be in\npossession of better-feerate multi-party funded transactions but it won't\npropagate on today's network if a opt-out double-spend is already present.\n\nIn the model described above, Alice might provide a consensus-and-standard\nvalid input to Bob and Caroll, they will verify and accept it, finish the\ntransaction finalization and broadcast. Meantimes, Alice will mass-connect\nto the network and announce a double-spend of its input with\nnSequence=0xffffffff. Alice-Bob-Caroll's funding transaction won't\npropagate on the network as it's an attempt to double-spend a rbf opt-out\ntransaction.\n\nA L2 client, with only a view of its mempool at best, won't understand why\nthe transaction doesn't confirm and if it's responsible for the\nfee-bumping, it might do multiple rounds of feerate increase through CPFP,\nin vain. As the fee-bumping algorithm is assumed to be known if the victim\nclient is open source code, the attacker can predict when the fee-bumping\nlogic reaches its upper bound. When this bound is reached, the attacker\nmight evict its own malicious opt-out double-spend by replacing an\nunconfirmed parent. At the next rebroadcast attempt by the L2 client, the\nfunding transaction should propagate associated with a maliciously inflated\nfeerate.\n\nCurrently, we don't have mitigation against this simple pinning, as it\nexploits the first-seen mempool behavior. Participants of the multi-party\nfunding transaction might double-spend their contributed inputs after some\ntimeout, encumbering the fees and timevalue losses for nothing.\n\n# Conclusion\n\nMulti-party bitcoin protocols offer a wider attack surface when you\nconsider actual mempool acceptance/tx-relay rules compared to simple\nbitcoin applications. As all those protocols are currently under design or\nin early deployment phase, I don't believe DoS attacks described are\nconcerning for now.\n\nThat said, if we don't address them at some point in the future, they're\nlikely going to be a major source of disruption for users and services\nproviders of such advanced bitcoin protocols. Even if those attacks might\nsound tricky for now and attacker incentives are relatively loose, always\nremember how far people have been leveraging Internet infrastructure\nillnesses to apparently proceed with their Minecraft business [5]\n\nI think the issues described are mostly right but please point out any\nshortcomings.\n\nCheers,\nAntoine\n\n[0] https://github.com/discreetlogcontracts/dlcspecs/issues/155\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/851\n[2] https://github.com/lightningnetwork/lightning-rfc/pull/839\n[3] We assume a protocol participant will first receive outpoints from\nothers, validate their witnessScript,\nthen release signatures. I don't think Core's `testmempoolaccept` lets you\ndo a \"validate their witnessScript\"\noperation only without yelling first for lack of signature\n[4] https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L651\n[5]\nhttps://krebsonsecurity.com/2017/01/who-is-anna-senpai-the-mirai-worm-author/\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210506/466d2c64/attachment.html>"
            },
            {
                "author": "J\u00e1n S\u00e1ren\u00edk",
                "date": "2021-05-06T15:00:36",
                "message_text_only": "Hi Antoine,\n\nOn Thu, May 6, 2021 at 3:44 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> In this post I would like to highlight some DoS attacks against\n> multi-party Bitcoin protocols during their funding phases. Recent\n> discussions around DLC funding flow [0] and dual-funding of LN channel [1]\n> remind me that some timevalue DoS/fee inflation issues are common to any\n> multi-party funded transactions. I'm not sure how much developers meddle in\n> that kind of protocols/applications are aware of them and how well they\n> mitigate against them.\n>\n\ntwo days ago I tried to open a dual-funded channel and yesterday my\nC-Lightning node started crashing.\nHave a look at https://github.com/jsarenik/clightning-dual-crash-logs as I\nthink it may be related to the DoS you mention.\n\nIf it is related, let me know and I can provide all the details.\n\nThank you!\nBest regards to all!\nJasan\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210506/0df07804/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "On Mempool Funny Games against Multi-Party Funded Transactions",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "J\u00e1n S\u00e1ren\u00edk",
                "Antoine Riard"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 8774
        }
    },
    {
        "title": "[Lightning-dev] Upgrade on reestablish.",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-05-07T03:22:33",
                "message_text_only": "I wanted this for my simplified update commitment draft, so here it is.\nWould be nice to upgrade those old channels to static remotekey and\nanchors (yeah, it's still on my TODO) so we could top the old stuff out\nof implementations and finally the spec!\n\n        https://github.com/lightningnetwork/lightning-rfc/pull/868\n\nInline copy below!\n\nCheers,\nRusty.\n\n### Upgrading Channels\n\nUpgrading channels (e.g. enabling `option_static_remotekey` for a\nchannel where it was not negotiated originally) is possible at\nreconnection time if both implementations support it.\n\nBoth peers indicate what upgrades are available, and if they both\noffer an upgrade either peer wants, then the upgrade is performed\nfollowing any reestablish retransmissions and corresponding\ncommitments which bring the channel into a symmetrical state with no\nupdates outstanding.\n\nOnce both peers indicate things are quiescent by sending\n`update_upgrade`, the channel features are considered upgraded and a\nnormal `commiment_signed` cycle occurs with the new upgrade in place.\n\nIn case of disconnection it's possible that one peer will consider the\nchannel upgraded and the other not.  For this reason (and potentially\nbetter diagnostics in future) , they indicate what the current channel\nfeatures are on reconnect: the \"more upgraded\" one applies immediately\nin this case.\n\nChannel features are currently defined as:\n  - `option_static_remotekey`\n  - `option_anchor_outputs` (requires `option_static_remotekey`)\n\n1. type: 40 (`update_upgrade`)\n2. data:\n   * [`channel_id`:`channel_id`]\n   * [`...*byte`:`features`]\n\n#### Requirements\n\nA node sending `channel_reestablish`:\n  - if it sets `channel_features`:\n    - MUST set the channel features which currently apply to the channel.\n  - if it sets `upgrades_available`\n    - MUST set `channel_features`\n    - MUST set it to a set of channel features not in `channel_features`.\n  - if it sets `upgrades_wanted`:\n    - MUST set it to a single channel feature NOT in `channel_features`, plus any required features which are also not in `channel_features`.\n    - MUST NOT set any bits not in `upgrades_available`.\n\nA node receiving `channel_reestablish`:\n  - if `channel_features` has more bits set than the sent `channel_features`:\n    - if the additional bits are not in the sent `upgrades_available`:\n      - MUST fail the upgrade\n    - otherwise:\n      - MUST consider the received `channel_features` as the current features of the channel.\n  - otherwise, if `channel_features` has fewer bits set than the sent `channel_features`:\n    - if the missing bits are not in the sent `upgrades_available`:\n      - MUST fail the upgrade\n    - otherwise:\n      - MUST consider the sent `channel_features` as the current features of the channel.\n  - if either peer sets a bit in `upgrades_wanted` which is also in both peers' `upgrades_available`:\n    - if `channel_features` modified by `upgrades_wanted` does not have required features:\n\t  - MUST fail the upgrade.\n    - MUST send `update_upgrade` with the new `channel_features` after any retransmissions required by `channel_reestablish` and as soon as there are no outstanding updates on either commitment transaction.\n\nA node receiving `update_upgrade`:\n  - if the `features` is not the same as the one it sent (or will send):\n    - MUST fail the upgrade\n\nWhen a node has both sent and received `update_upgrade`:\n  - MUST consider the channel features to be those sent in `update_upgrade`.\n  - if it has a lower SEC1-encoded node_id than its peer:\n    - MUST send `commitment_signed` (using the new channel features).\n\n#### Rationale\n\nIt is generally simpler to have both sides synchronized when upgrades\noccur: by indicating that an upgrade is desired and available, both\nsides know to perform the upgrade as soon as this is the case.  In\npractice most upgrades happen by restarting software which implies a\nreconnect cycle anyway.\n\nThe modification of bits is actually quite tricky: a channel which has\n`option_static_remotekey` needs only set `option_anchor_outputs` in\n`upgrades_wanted`, but one with neither would set both.\n\nA node which only offered `option_anchor_outputs` as an upgrade would\nonly set that in `upgrades_available`, to avoid indicating that an\nupgrade only to `option_static_remotekey` was available.\n\nThere's weasel wording around how `channel_features` combines with\n`upgrades_wanted` (\"modified by\") since future channel features may\nturn off existing features they conflict with.  This will be defined\nby them.\n\nFinally, the `update_upgrade` features field is technically redundant,\nbut a useful sanity check and diagnostic that both sides are now\nentering the same state.  It also allows us to continue to enforce the\nrule that commitment_signed must include an update."
            },
            {
                "author": "Rusty Russell",
                "date": "2021-05-09T05:22:40",
                "message_text_only": "Just a quick note that I have a signficant simplification of this,\nbecause I started implementing and I hated it.\n\nThis time I'll finish implementing it before I post the spec :)\n\nCheers,\nRusty."
            }
        ],
        "thread_summary": {
            "title": "Upgrade on reestablish.",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 4956
        }
    },
    {
        "title": "[Lightning-dev] Questions on lightning chan closure privacy",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-05-18T08:19:47",
                "message_text_only": "Good morning LL and Lee,\n\n> Hi Lee,\n>\n> You are touching on some very relevant privacy challenges for lightning. To your questions:\n>\n> 1. Is it possible to identify which node funded a lightning channel? (this tells you who owns the change output)\n> 2. Is it possible to identify who owns which channel close output?\n>\n> I think that the answer to both these questions hinges on whether you exclusively use private channels. If you fund private and public channels with the same wallet then it may be possible to identify your private channels and the owner of the channel and channel close outputs[1].\n\nIt is helpful to avoid the terminology \"public / private\" and use instead \"published / unpublished\", precisely because unpublished channels are not necessarily an improvement in privacy (but are a degradation in usability for the rest of the network).\n\nIf a node has a mix of published and unpublished channels, then it is usually possible to look at a closed unpublished node and determine which output belongs to that node.\nAnd because channels are composed of two participants, by simple elimination, the other output obviously belongs to the counterparty.\n\nNow, a node that only has unpublished channels has to (in the current network) be connected to a node with *mixed* published and unpublished channels.\nOtherwise, it would not be able to find a route to *any* other payee via that channel, and thus the channel capacity is wasted.\n\nWhen that channel is closed, with non-negligible probability it is possible to determine which output goes to the \"mixed\" node and which one goes to the \"unpublished-only\" node.\nThat can then be tracked as well.\n\nThus, a node which has only unpublished channels does not really have a much improved privacy over one which uses only published channels, or has a mix of channels.\n\n--\n\nOn the other hand, I have written before about \"CoinSwapper\", which is basically:\n\n* Use some onchain funds to create a channel to some random well-connected node.\n* Pay to an offchain-to-onchain swap and withdraw all your coins onchain.\n* Close the previous channel and blacklist your output from the mutual close (i.e. throw away the key and destroy all evidence that you used that channel).\n\nThis allows some privacy, as long as you never use the output from the mutual close.\nThis is a clunky way you can achieve CoinSwap in practice today without waiting for specific CoinSwap software.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Questions on lightning chan closure privacy",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2439
        }
    },
    {
        "title": "[Lightning-dev] Improving Payment Latency by Fast Forwards",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2021-05-23T07:26:30",
                "message_text_only": "Good morning list,\n\nI have decided to dabble in necromancy, thus, I revive this long-dead thread from two years ago.\nPh34R mE and my leet thread necromancy skillz.\n\nA short while ago, LL and Steve Lee were discussing about ways to reduce the privkey onlineness requirement for Lightning.\nAnd LL mentioned that this proposal could allow privkeys to be kept offline for a receiver.\n\n* The receiver has to be online, still.\n* Its privkeys can be kept offline.\n  * The receiver can still receive even if its privkeys are offline (for example the privkeys are in a hardware signing module that is typically kept offline and is only put online at rare intervals).\n* The sender has to be online and the sender privkeys have to be online.\n* Forwarders and their privkeys have to be online.\n\nUnfortunately, I think the proposal, as currently made, cannot support the above feature, as stated.\n\nWhen an HTLC transaction is provided by the sender under a Fast Forward scheme, it provides a transaction that spends from \"its\" output in both versions of the latest Poon-Dryja commitment transaction.\n\nHowever, this output, as provided in the Fast Forward scheme, requires *two* signatures.\n\nHere are the scripts mentioned in the previous post:\n\n    OP_IF\n        # Penalty transaction/Fast forward\n        <local_revokepubkey> OP_CHECKSIGVERIFY <remote_penaltyclaimpubkey>\n    OP_ELSE\n        `to_self_delay`\n        OP_CSV\n        OP_DROP\n        <local_delayedpubkey>\n    OP_ENDIF\n    OP_CHECKSIG\n\nAnd:\n\n    OP_IF\n        # Penalty transaction/Fast forward\n        <local_revokepubkey> OP_CHECKSIGVERIFY <remote_penaltyclaimpubkey>\n    OP_ELSE\n        `to_self_delay`\n        OP_CSV\n        OP_DROP\n        <remote_delayedpubkey>\n    OP_ENDIF\n    OP_CHECKSIG\n\nNow, the first branch is what is used in the Fast Forward scheme.\nAnd we can see that in the first branch, two signatures are needed: one for local, and one for remote.\n\nThus, any HTLC-bearing transactions are signed by both the sender and receiver.\nFast Forwards works its low-latency magic by simply having the sender send the signature spending from the current channel state, outright, to the receiver, and until the channel is updated, the HTLC is \"safe\":\n\n* The current channel state (represented by some commitment tx) cannot be replaced with an alternative, without the replacer risking funds loss (Poon-Dryja punishment mechanism).\n* The spending tx that instantiates the HTLC is safe because the receiver will not willingly sign an alternate version.\n\n***HOWEVER***, the HTLC is safe on the assumption that *the receiver can provide its signature* if the channel is dropped onchain.\nAnd channels can be dropped onchain *at any time*.\nIf the receiver is unable to provide its signature before the `to_self_delay` finishes, then the sender can revoke ***all*** HTLCs it sent!\n\nThus, at least as initially stated, Fast Forwards cannot be used for this \"receiver online, privkeys offline, can receive\" feature.\n\n***HOWEVER HOWEVER***, we should note that the caveats are something we can actually work with:\n\n* The privkeys can only be offline for up to `to_self_delay` blocks.\n  * We ***need*** privkeys to be periodically online more often than `to_self_delay` anyway, ***in case of theft attempts***.\n    So this is not an ***additional*** requirement at least.\n* Watchtowers cannot guard against attempts to steal Fast Forwarded HTLCs --- they need to receive the signatures for the HTLC transactions as well, otherwise they can do nothing about it.\n  * However, whenever the receiver sends to a watchtower it *does* need to send signatures anyway, so it still needs to get privkeys online for signing.\n  * Since we need the privkeys to be made online a little more often than every `to_self_delay` blocks anyway, this is *not* an additional requirement!\n\n***THUS***, we *can* provide a tweaked version of the above desired feature:\n\n* The receiver has to be online, still.\n* Its privkeys can be kept offline, ***BUT***, it has to be regularly brought online a little more often than `to_self_delay`.\n  * The receiver can still receive even if its privkeys are offline (for example the privkeys are in a hardware signing module that is typically kept offline and is only put online at rare intervals).\n* The sender has to be online and the sender privkeys have to be online.\n* Forwarders and their privkeys have to be online.\n\nThe additional requirement --- that the receiver privkeys have to be regularly brought online --- is not actually an onerous one *since we need it for channel safety*.\n\nSo this feature is indeed supported by Fast Forwards (with fairly minimal caveats!) and kudos to LL for thinking of it!\n\nAgainst this, we should remind the drawbacks of Fast Forwards:\n\n* Onchain space is much higher (in the unilateral close case only --- channel opens and mutual closes remain small) due to chaining of transactions instead of strict replacement.\n* Fast Forwarded HTLCs need to have their signatures stored on replicated storage, and is O(n) (current Poon-Dryja requires O(1) storage for revocation keys but O(n) storage for HTLC hash/timelock details).\n  If you lose your data storage, you lose received HTLCs, including those whose preimages you have already released.\n\nFor this, we should also take note that:\n\n* Payment latency is greatly improved.\n* The above \"receiver online, receiver privkeys offline, can receive\" feature is now possible, with the caveat:\n  * The privkeys need to be periodically brought online for short amounts of time in order to \"collapse\" chains of HTLC transactions, recover from theft attempts, and update watchtowers etc.\n\n---\n\nNow, Fast Forwards is a scheme that is designed for a modified form of Poon-Dryja.\n\nUnfortunately, at least for now, it seems the scheme cannot be used in Decker-Russell-Osuntokun (\"eltoo\").\n\nIn particular, Fast Forwards work because it is safe (and even required!) for a Poon-Dryja scheme to impose timeouts on the \"main\" outputs of a channel.\nAnd those timeouts have a branch that is a 2-of-2 between the channel participants.\nThat branch is where Fast Forwards hook into.\n\nIn Decker-Russell-Osuntokun, the \"main\" outputs are not encumbered by any timeouts; they are simple singly-signed outputs.\nThe timeout is instead placed \"before\" the state transactions that contain the \"main\" outputs.\nThe HTLC transactions are not safe without a 2-of-2, as otherwise the sender could just spend the main output to a different address, removing the HTLC.\n\nBecause of this, the \"main\" output of a Decker-Russell-Osuntokun cannot be used in a Fast Forwarded manner, as the Fast Forwarded transaction needs to be signed by both participants.\n\nWe *could* add *another* timeout at the main output simply to support Fast Forwards, using a similar \"2of2 or OP_CSV+singlesig\".\nHowever, this increases the effective delay in the case the channel is dropped unilaterally onchain.\n\nIn addition, we should remind that when forwarding, Decker-Russell-Osuntokun requires that the CLTV at a particular hop be larger than the `to_self_delay` at that hop i.e. it imposes a \"minimum CLTV\" cost that is combined with `max` instead of `+`, which pathfinding algorithms (that I know of) are totally not designed for.\n\nFurthermore, properly designed, a Decker-Russell-Osuntokun construction could also have payment latency approaching the latency of the Fast Forward scheme, so that advantage of Fast Forwards is lost as well, so we are paying for more inconvenience for a smaller feature set (only the \"receiver online, privkey offline\" feature remains; maybe worth it?).\n\nOf note, is that there also exists a Poon-Dryja variant that has a similar structure to Decker-Russell-Osuntokun (and has the same drawback of requiring a \"minimum CLTV\" at each hop) --- Fast Forwards would also not work well with that particular Poon-Dryja variant, too.\n\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-05-23T18:48:37",
                "message_text_only": "Good morning list,\n\nNote that there is a possible jamming attack here.\n\nMore specifically, when \"failing\" an incoming HTLC, the receiver of the HTLC sends its signature for a transaction spending the HTLC and spending it back to the sender revocable contract.\nThe funds cannot be reused until the channel state is updated to cut-through all the transactions (the HTLC transaction and the failure transaction).\n(Well it *could* but that greatly amps the complexity of the whole thing --- no, just no.)\n\nThus I could jam a particular receiver by sending, via forwarding nodes, to that receiver, payments with a random hash, which with high probability have preimages that are unknown by the receiver.\nThe receiver can only fail those HTLCs, but \"to fail an HTLC\" under Fast Forwards makes the funds unusable, until the previous channel state can be revoked and replaced with a new one.\nBut updating the channel state requires privkeys to be online in order to create the signatures for the new channel state.\n\nThis creates a practical limit on how long you can keep privkeys offline; if you keep it offline too long, an attacker can jam all your incoming capacity for long periods of time.\nThis is not currently a problem without \"receiver online, privkey offline\", since without \"privkey offline\" case, the receiver can update the channel state immediately.\n\nHowever, if the receiver is willing to lose privacy, the protocol can be mildly modified so that the receiver tells the forwarding node to *first* ask the receiver about every HTLC hash before actually instantiating and sending the HTLC.\nOnly if the receiver agrees will the forwarder actually send the HTLC.\n\nThe forwarder is incentivized to go along with this, as otherwise, the receiver cannot actually fail any HTLCs --- it needs to provide a signature, and signatures require privkeys, and the receiver has those offline.\nThus, the forwarder would prefer to ask the receiver *before* it instantiates the HTLC, as otherwise the HTLC cannot be cancelled until the receiver gets its privkeys online, which can take a long time --- and if the HTLC times out in the meantime, that can only be enforced by dropping onchain, and Fast Forwards are *very* expensive in the unilateral close case.\n\nObviously this tells the forwarding node that the channel is used for receiving and that any payments over it terminate at the next hop, thus a privacy degradation.\nOn the other hand, unpublished channels remain popular despite my best efforts, and this is the exact problem unpublished channels have, so ---- not a degradation in privacy in practice, since users of unpublished channels already have degraded privacy (axiom of terminus),\n\nThis also increases latency once again, as there is now 1.5 roundtrips (forwarder asks receiver if this forwarded HTLC is kosher, receiver responds, forwarder sends signature to HTLC transaction).\nHowever, the increased latency only occurs at the endpoint; forwarders (which need to have privkeys online 100% of the time anyway, and can thus cut-through any number of failed HTLCs at any time) can skip the \"is this HTLC kosher\" message and just send the HTLC signatures immediately.\nThus, this may be an acceptable tradeoff.\n\nThus, one might consider this scheme to be usable for *either* Fast Forwards, *or* \"receiver online, privkeys offline\", but not usefully both (after all, a forwarder is both a receiver and a sender, and a sender needs its keys in order to send, so it cannot use the \"privkeys offline\" feature anyway).\n\n\nIt may be difficult to understand this, so maybe I will make a convenient presentation of some sort.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Lloyd Fournier",
                "date": "2021-05-24T05:53:16",
                "message_text_only": "Hey Z,\n\nThanks for your analysis. I agree with your conclusion. I think the most\npractical approach is the \"ask first\" 3 round protocol.\n\nAnother option is to have `remote_penaltyclaimpubkey` owned by the node\ninstead of the hardware device.\nThis allows funds to accrue in the fast forward state which can be swept\ninto the commit tx at the merchants discretion.\nIf a fast forward state needs to be asserted on-chain it can then be done\nautomatically without the hardware device.\nOf course, the funds in the FF state are more vulnerable than the main\nchannel balance during that time because their keys are not in a secure\ndevice but this seems ok.\nThe obvious analogy is to having cash in the till (less secure) that you\nsend to your bank (more secure\u2122) at the end of the day or week.\n\n> We ***need*** privkeys to be periodically online more often than\n`to_self_delay` anyway, ***in case of theft attempts***.\n>  So this is not an ***additional*** requirement at least.\n\nThis is a really important point. I guess you have to actually do this\nperiodically, only when there is an actual attempt at theft. Quite annoying\nto UX to require this.\n\nCheers,\n\nLL\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210524/98ec9903/attachment.html>"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-05-24T07:04:27",
                "message_text_only": "Good morning LL,\n\n> Hey Z,\n>\n> Thanks for your analysis. I agree with your conclusion. I think the most practical approach is the \"ask first\" 3 round protocol.\n>\n> Another option is to have `remote_penaltyclaimpubkey` owned by the node instead of the hardware device.\n> This allows funds to accrue in the fast forward state which can be swept into the commit tx at the merchants discretion.\n> If a fast forward state needs to be asserted on-chain it can then be done automatically without the hardware device.\n> Of course, the funds in the FF state are more vulnerable than the main channel balance during that time because their keys are not in a secure device but this seems ok.\n> The obvious analogy is to having cash in the till (less secure) that you send to your bank (more secure\u2122) at the end of the day or week.\n\n\nThis seems a useful technique.\n\n>\n> > We ***need*** privkeys to be periodically online more often than `to_self_delay` anyway, ***in case of theft attempts***.\n> >\u00a0 So this is not an ***additional*** requirement at least.\n>\n> This is a really important point. I guess you have to actually do this periodically, only when there is an actual attempt at theft. Quite annoying to UX to require this.\n\nIf you mean \"***not*** only when there is an actual attempt at theft\", yes.\n\nMy thought that this would be useful for a \"big\"-ish merchant that primarily accepts payments, to mitigate its key exposure.\nIt would program a small low-power device such that it almost always has its network interface disabled, but periodically (at random times) it will enable its network interface and connect out to the node, presenting a proof that it holds the privkey.\nIt would have a firewall so that it cannot receive incoming connection requests and can only make outgoing connection requests (and as noted above, most of the time the network interface would be disabled outright).\n\nThen the node could wait for this hardware to contact it, and proceed to \"roll up\" any fast-forwarded HTLCs.\nThis could also be an opportunity for the node to send out funds, for example to pay the salaries of employees or dividends to shareholders of the merchant.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2021-05-31T09:46:57",
                "message_text_only": "Good morning list,\n\n> It may be difficult to understand this, so maybe I will make a convenient presentation of some sort.\n\nAs promised: https://zmnscpxj.github.io/offchain/2021-06-fast-forwards.odp\n\nThe presentation is intended to be seen by semi-technical and technical people, particular those that have not read (or managed to fully read and understand) the original writeup in 2019.\nSimply \"run\" the presentation (F5 in LibreOffice), as the presentation uses callouts extensively for explication.\n\nRegards,\nZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "Improving Payment Latency by Fast Forwards",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Lloyd Fournier",
                "ZmnSCPxj"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 15543
        }
    },
    {
        "title": "[Lightning-dev] YAELBOT",
        "thread_messages": [
            {
                "author": "J\u00e1n S\u00e1ren\u00edk",
                "date": "2021-05-24T07:39:53",
                "message_text_only": "Hi there, lightning-dev list!\n\nSeeing Z and LL talk about Fast Forwards, I would like to bring to\nyour attention my proposal, so far best described in the comment at\nhttps://github.com/ariard/L2-zoology/pull/7#issuecomment-845175234\n\nIn YAELBOT the bot (possibly a LN node extended with proposed\nfunctionality) would have its private keys merely to keep track of the\nbalance with the other party. The real Bitcoin keys will be totally\noffline and owned by humans setting up the channel.\n\nPlease have a look and comment. Feel free to turn this proposal down\nand please refer to any similar ones from the past.\n\nThank you!\nJasan"
            }
        ],
        "thread_summary": {
            "title": "YAELBOT",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "J\u00e1n S\u00e1ren\u00edk"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 626
        }
    }
]