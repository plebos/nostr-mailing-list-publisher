[
    {
        "title": "[Lightning-dev] Mitigating Channel Jamming with Reputation Credentials: a Protocol Sketch",
        "thread_messages": [
            {
                "author": "ZmnSCPxj",
                "date": "2022-12-01T11:52:13",
                "message_text_only": "Good morning Antoin, Dave, et al.,\n\n\n> Hi Dave,\n> \n> I think the issue you're describing about credential tampering by intermediary nodes is correct. If Alice controls Y along the path W->X->Y->Zed, she can waste the credentials value provided. Indeed, this issue generalizes for any classic payment path, where a routing node can waste the senders credentials allocated on the downstream hops.\n\nOf note is that jamming attacks are mounted by routing nodes against other routing nodes, and a routing node will not *deliberately* attack a payment that goes through them --- doing so sacrifices the potential for fees.\nIt still remains the case that accidents can happen, and Y could fail completely by accident and cause accidental failure.\nIndeed, if any mechanism to protect against channel jamming succeeds, then the remaining instances of apparent channel jamming will be accidental.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "ZmnSCPxj",
                "date": "2022-12-01T12:28:00",
                "message_text_only": "Good morning Antoine,\n\n> About secondary-markets, the credentials themselves are subject to the classic double-spend problem. E.g, Alice can transfer her \"Ned\" credentials both to Bob and Caroll, without any of them getting knowledge of the duplication. So it could be expected secondary markets to only happen between LSP and their spokes (where \"trust\" relationships already exist), as such harder to formalize.\n\nIf this is a problem, would the use of the WabiSabi technique help?\nIf my understanding was correct, the WabiSabi paper described a Chaumian bank that issues coins of variable amount, with clients able to merge and split coins without revealing the amount to the bank/issuer, while allowing for non-double-spendable transfer of coins by having the bank sign off on all transfers between clients (without the bank becoming aware of the value being transferred or the pseudonyms of either client).\n\n\nIf transfer of tokens can be made non-double-spendable, then it may be feasible for a forwarding node to accept tokens issued by a different forwarding node, if the sender also transfers control of those tokens to the forwarding node.\ni.e. if a sender has credentials for node A but needs to forward via node B, then node B may be willing to accept credentials issued by node A.\nThis is similar to the situation where \"free banks\", in the absence of a central bank, are willing to accept paper bearer bonds issued by another bank, as this lets them attack the other bank by withdrawing the value backing the bond and attempt to trigger a bank run on that other bank (and thus remove them from competition).\nSimilarly, node B who is a competitor of node A may be willing to accept credentials issued by node A, in a forward that goes through node B, as the transferred credentials would allow node B to perform a jamming attack on node A (and thus remove them from competition).\nBoth node A and B can then peacefully resolve the difference without attacking via a \"clearing house\" where they reveal how much of the credential issued by the other they have, in much the same way as free banks would resolve paper bearer bonds.\n\nRegards,\nZmnSCPxj"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-02T01:07:09",
                "message_text_only": "Hi Zeeman,\n\nI think it is correct to say that if any mechanism to protect against\nchannel jamming succeeds, the remaining instance of apparent channel\njamming might be accidental. This rate of accident might be still high due\nto spontaneous congestion (i.e more HTLC senders than slots/liquidity\navailable for the core links of the network). With the present credential\ntokens scheme the rate of spontaneous failure should still have to be\nencumbered by some entity. By default it would be the HTLC sender, as is\nthe one attaching the tokens, and this sounds to be aligned with incentive\nas is the one building a payment path of _reliable_ routing hop.\n\nOn the second issue, namely a node B who is a competitor of node A and\naccepting node A credentials to provoke a jamming attack against A, I don't\nthink this is plausible. As long as node A is requesting its _own_ tokens\nto accept HTLC forward, there is a compensation for the risk. The behavior\nof node B accepting node A to drain traffic through node A, in an attempt\nto jam it, would in the present situation benefit node A due to the\ncredentials acquisition cost.\n\nThere is a different idea, I think you're describing, the trust-minimized\nexchange of credentials tokens between receivers. Effectively here we can\nimagine a Chaumian bank-style construction where the tokens are transferred\nin a privacy-fashion, and double-spend flagged out by the bank. However,\nthis wouldn't prevent a token double-spend against another bank. So it\nsounds to me you need some kind of underlying reputation or enforcement\nmechanism to make the economics of the bank work ? I.e the bank being a LSP\nand force-closing channels in case of double-spend.\n\nIt should be noted, even if we assume federation of Chaumian banks leading\nto a global secondary market for token transfers, the routing hops should\nbe still economically safe against jamming attacks, as long as the token\nacquisition cost is paid at issuance.\n\nBest,\nAntoine\n\nLe jeu. 1 d\u00e9c. 2022 \u00e0 07:28, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n>\n> Good morning Antoine,\n>\n> > About secondary-markets, the credentials themselves are subject to the\n> classic double-spend problem. E.g, Alice can transfer her \"Ned\" credentials\n> both to Bob and Caroll, without any of them getting knowledge of the\n> duplication. So it could be expected secondary markets to only happen\n> between LSP and their spokes (where \"trust\" relationships already exist),\n> as such harder to formalize.\n>\n> If this is a problem, would the use of the WabiSabi technique help?\n> If my understanding was correct, the WabiSabi paper described a Chaumian\n> bank that issues coins of variable amount, with clients able to merge and\n> split coins without revealing the amount to the bank/issuer, while allowing\n> for non-double-spendable transfer of coins by having the bank sign off on\n> all transfers between clients (without the bank becoming aware of the value\n> being transferred or the pseudonyms of either client).\n>\n>\n> If transfer of tokens can be made non-double-spendable, then it may be\n> feasible for a forwarding node to accept tokens issued by a different\n> forwarding node, if the sender also transfers control of those tokens to\n> the forwarding node.\n> i.e. if a sender has credentials for node A but needs to forward via node\n> B, then node B may be willing to accept credentials issued by node A.\n> This is similar to the situation where \"free banks\", in the absence of a\n> central bank, are willing to accept paper bearer bonds issued by another\n> bank, as this lets them attack the other bank by withdrawing the value\n> backing the bond and attempt to trigger a bank run on that other bank (and\n> thus remove them from competition).\n> Similarly, node B who is a competitor of node A may be willing to accept\n> credentials issued by node A, in a forward that goes through node B, as the\n> transferred credentials would allow node B to perform a jamming attack on\n> node A (and thus remove them from competition).\n> Both node A and B can then peacefully resolve the difference without\n> attacking via a \"clearing house\" where they reveal how much of the\n> credential issued by the other they have, in much the same way as free\n> banks would resolve paper bearer bonds.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221201/57ee379b/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-02T00:33:20",
                "message_text_only": "Hi Dave & Zeeman,\n\nAs the credentials tokens should be blinded during countersigning and then\nwrapped inside HTLC onions, the routing hops cannot use them to assign\nblame. Instead the jamming attack prevention efficiency relies on\nmisbehaving senders exhausting their supply of scarce and costly tokens. A\nnaive blinding should still enable delegation -- Bob can share his Ned's\ntokens with Mallory, and she could consume them to waste Ned routing\nliquidity. However Bob should have borne the acquisition cost.\n\nThis delegation could happen in a trampoline flow, where Bob attaches\non-the-flight his Ned tokens to Alice's HTLC. This naive attachment\nshouldn't leak the delegation fact itself to the routing hops.\n\nAbout the economic relationships between LSPs and their clients, it sounds\neffectively possible the token harvesting to be done at the LSP-level,\nwhere over-supply of tokens are resold to the LSP in exchange of other\nadvantages (e.g discount on JIT channels). This over-supply can be assigned\nto newer clients, devoid of credentials token, at condition there is still\na costly bound enforced by the LSP, to avoid a jamming adversary exploiting\nthe cost asymmetry (e.g presence of channels). This asymmetry exploitation\nwould be detrimental to the _LSP zone_, not the tokens issuer routing hop,\nas the original compensation must have been paid by the LSP.\n\nIt should be noted, a reasonable routing policy might be to additionally\nreward HTLC on \"favorable\" incoming links, as a means to incentive the\nmaintenance of the open link. However this creates asymmetry if the\nincoming link operator allows free credential tokens earned by its clients.\n\nOn the jamming vectors opened by an adversary having collected a large\nstock of tokens, the routing hops should be still economically \"safe\", as\nlong as there is a strict equality between the credentials acquisition cost\nand the routing fees. E.g wasting liquidity worth 1000 sats of routing fees\nshould have been compensated by credentials worth 1000 sats, therefore the\nrouting hops still earn an income. Note, one of the insights of\n\"staking/reputational\" credentials is to pour the original HTLC forwarding\nrisk on the sender, while making this risk \"fine-grained\" and \"flexible\" in\nits allocation.\n\nWhile the routing fees would vary in function of multiple factors (e.g\nnetwork-wide channels congestion) the credentials token acquisition cost\nshould stay identical, otherwise you're offering exploitable asymmetries to\nan attacker.\n\nOn the argument that jamming would be solved as the attacker has to\nsacrifice opportunity costs of its own liquidity, I think such a position\nforgets few elements. Such as the fact one channel can tied up liquidity\nfor many links, jammed channel might have higher return rate than attacker\nliquidity due to routing algorithms historical data, the damage inflicted\nmight be merchant goods themselves far beyond the attacker opportunity\ncosts, the opportunity cost between attacker and victims might not be\nsymmetric because the attacker have large liquidity reserves (e.g an\nattacker blocking new incumbents).\n\nBest,\nAntoine\n\nLe lun. 28 nov. 2022 \u00e0 06:50, ZmnSCPxj <ZmnSCPxj at protonmail.com> a \u00e9crit :\n\n> Good morning David,\n>\n> > On 2022-11-25 13:12, ZmnSCPxj via Lightning-dev wrote:\n> >\n> > > If I am an LSP, and I know my competitor LSP distributes their\n> > > credentials, then I can simply apply to be a spoke on my competitor\n> > > and then make several payments to my node, which I then jam up.\n> > > This reduces the reputation of my competitor LSP.\n> >\n> >\n> > I don't think this how Riard's credentials work. The credential tokens\n> > are blinded, so forwarding nodes can't use them to determine the origin\n> > of the payment---thus they can't assign blame.\n> >\n> > As I understand them, credential tokens prevent DoS by each token only\n> > allowing the one-time creation of a single HTLC, so any failed payment\n> > reduces the sender's supply of tokens. That means, if Mallory becomes a\n> > client of Bob's and Bob lets Mallory use some of his tokens, Mallory can\n> > destroy those tokens. Although that's bad for Bob, he can easily limit\n> > the damage by not giving Mallory more tokens after too many failures.\n> > If Bob obtained his tokens at a low cost (e.g. by sending many payments\n> > that were successful and receiving back >100% of the tokens he used to\n> >\n> > make those payments) and if Alice has to pay a similar or greater cost\n> > to become a client of Bob's (e.g. onchain channel open costs), then the\n> > attack should not be economically rational.\n>\n> The usual response is to subsequently attack the mitigation, this is a\n> general technique that works on pretty much anything.\n>\n> Mallory can run multiple nodes.\n> Mallory can then initially buy a small number of tokens.\n> Then Mallory sends payments back and forth ensuring success, receiving\n> back >100% tokens used.\n> This gives Mallory a large number of tokens.\n>\n> Finally, Mallory launches a wide attack on the network by using its\n> harvested tokens (from the >100% token return from successful payment\n> resolution), trading off reputation for whatever they might gain by\n> attacking the LN.\n>\n> Unless forwarding nodes charge a large fee on successful resolution of\n> payments, such that the >100% return on tokens is equal to the cost of\n> buying the extra tokens \"fresh\", then this makes launching the attack\n> cheaper.\n>\n>\n> > > Thus all reputation still rests with ultimate senders, who have to\n> > > convince LSPs to sell their reputation to them, because they might\n> > > secretly be competitor LSPs who have incentive to drain their\n> > > reputation.\n> > >\n> > > If the price of sold reputation is too high, then it is no different\n> > > from upfront fees.\n> > >\n> > > If the price of sold reputation is too low, then I can drain the\n> > > reputation of competitor LSPs.\n> >\n> >\n> > I think the statement at the top about reputation resting with ultimate\n> > senders is true but two conditionals below it are not quite right. If\n> > an LSP helps many clients make successful payments, those clients may\n> > (at no additional cost to them beyond the forwarding fees they already\n> > paid) receive more credential tokens than they'll ever need. By\n> > allowing the LSP to instead use those tokens for other clients\n> > (\"harvesting\" them), it's possible for those later clients to avoid\n> > paying for credential tokens---this is equivalent to free upfront fees.\n> > As long as the LSP can prevent a client from using too many tokens, and\n> > requires the client pay other inescapable costs, then it shouldn't be\n> > possible for a competitor to substantially drain the token capital of a\n> > LSP without losing a substantial amount of its own money.\n>\n> It is helpful to consider that jamming attacks require that jamming\n> attackers tie up their funds on Lightning too.\n> So while a jamming attacker can impose opportunity costs on the rest of\n> the network, it also sacrifices opportunity to instead use the same funds\n> in forwarding.\n> Thus a jamming attacker can impose costs on others by also losing a\n> substantial amount (in terms of lost opportunity to instead use the same\n> locked funds to earn forwarding fees), meaning that if you are going to\n> make that argument, then the original problem was already solved by its own\n> structure.\n>\n> Regards,\n> ZmnSCPxj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221201/05b770e8/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Mitigating Channel Jamming with Reputation Credentials: a Protocol Sketch",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "ZmnSCPxj",
                "Antoine Riard"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 15088
        }
    },
    {
        "title": "[Lightning-dev] Statechain channel blip",
        "thread_messages": [
            {
                "author": "Tom Trevethan",
                "date": "2022-12-01T16:59:50",
                "message_text_only": "We have been working on a draft blip for a new type of channel that can be\ncreated from a statechain UTXO, here:\nhttps://github.com/commerceblock/blip-XXXX/blob/main/blip-XXXX.md\nAny comments or suggestions welcome.\n\nTom\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221201/94b5e335/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Statechain channel blip",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Tom Trevethan"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 405
        }
    },
    {
        "title": "[Lightning-dev] Mitigating Channel Jamming with Reputation Credentials: a Protocol Sketch (Antoine Riard)",
        "thread_messages": [
            {
                "author": "Loki Verloren",
                "date": "2022-12-02T12:32:46",
                "message_text_only": "This subject makes a strong argument, along with the onion routed messaging part of Bolt 12 for an independent, Lightning funded onion routing relay network, over which all such kinds of traffic and security can be provided.\n\nI'm working on such a project, which will be initially built to support LND/BTCD/Neutrino: https://github.com/Indra-Labs/indra\u00a0One of its key innovations is a mechanism for path tracing, which enables the deduction of likely nodes that are currently not functioning correctly or malicious or offline or congested, via a process of deduction, while keeping the client originating traffic hidden from nodes in the path.\n\nChannels running across this overlay network would not be possible to jam and with many nodes a lot of traffic would pass through opaque tunnels, which would make jamming harder. The payment scheme in it also might work as a full solution to the adding of a cost against attempts to jam channels. My current idea for reputation is just a simple measure of client success ranking nodes by how recent and reliable they are, creating a loose consensus on the network of which nodes are better connected and dependable. Because it will use a median/zip merging process for evaluating the nodes it is hard for an adversary to damage the reputation of good nodes without also having to run a lot of nodes and for those nodes to also develop a good reputation.\u00a0\n\nAnyway, just some thoughts on the subject, not sure how useful or correct they are at this point.\n\n\n\nSent with Proton Mail secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/398391a6/attachment.html>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: publickey - stalker.loki at protonmail.ch - 0x96FE6FEA.asc\nType: application/pgp-keys\nSize: 1775 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/398391a6/attachment.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 509 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/398391a6/attachment.sig>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-02T23:25:16",
                "message_text_only": "Hi Loki,\n\nThanks for raising awareness on this project.\n\nI share the sentiment on the gradual generalization of Lightning onion\nmessaging as a transport network on its own for Bitcoin-specific traffic\nsuch as offers, offline receive control flow or credentials tokens or even\nin the future DLC offers. I don't know about the extension as a\nfully-fledged anonymity network such as Tor or I2P, we'll have issues with\nDoS too there [0] [1].\n\nOn a mechanism to improve the reliability of path-finding, have a look at\nthe recent fat errors proposal [1] (probably a needed piece for\nreputational credentials too).\n\nBest,\nAntoine\n\n[0]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-June/003623.html\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-July/003660.html\n[2] https://github.com/lightning/bolts/pull/1044\n\nLe ven. 2 d\u00e9c. 2022 \u00e0 07:33, Loki Verloren via Lightning-dev <\nlightning-dev at lists.linuxfoundation.org> a \u00e9crit :\n\n> This subject makes a strong argument, along with the onion routed\n> messaging part of Bolt 12 for an independent, Lightning funded onion\n> routing relay network, over which all such kinds of traffic and security\n> can be provided.\n>\n> I'm working on such a project, which will be initially built to support\n> LND/BTCD/Neutrino: https://github.com/Indra-Labs/indra One of its key\n> innovations is a mechanism for path tracing, which enables the deduction of\n> likely nodes that are currently not functioning correctly or malicious or\n> offline or congested, via a process of deduction, while keeping the client\n> originating traffic hidden from nodes in the path.\n>\n> Channels running across this overlay network would not be possible to jam\n> and with many nodes a lot of traffic would pass through opaque tunnels,\n> which would make jamming harder. The payment scheme in it also might work\n> as a full solution to the adding of a cost against attempts to jam\n> channels. My current idea for reputation is just a simple measure of client\n> success ranking nodes by how recent and reliable they are, creating a loose\n> consensus on the network of which nodes are better connected and\n> dependable. Because it will use a median/zip merging process for evaluating\n> the nodes it is hard for an adversary to damage the reputation of good\n> nodes without also having to run a lot of nodes and for those nodes to also\n> develop a good reputation.\n>\n> Anyway, just some thoughts on the subject, not sure how useful or correct\n> they are at this point.\n>\n>\n> Sent with Proton Mail <https://proton.me/> secure email.\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/83fed228/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Mitigating Channel Jamming with Reputation Credentials: a Protocol Sketch (Antoine Riard)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "Loki Verloren"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 5272
        }
    },
    {
        "title": "[Lightning-dev] Jamming against Channel Jamming",
        "thread_messages": [
            {
                "author": "Joost Jager",
                "date": "2022-12-02T17:59:23",
                "message_text_only": "A simple but imperfect way to deal with channel jamming and spamming is to\ninstall a lightning firewall such as circuitbreaker [1]. It allows you to\nset limits like a maximum number of pending htlcs (fight jamming) and/or a\nrate limit (fight spamming). Incoming htlcs that exceed one of the limits\nare failed back.\n\nUnfortunately there are problems with this approach. Failures probably lead\nto extra retries which increases the load on the network as a whole.\nSenders are also taking note of the failure, penalizing you and favoring\nother nodes that do not apply limits. With a large part of the network\napplying limits, it will probably work better because misbehaving nodes\nhave fewer opportunities to affect distant nodes. Then it also becomes less\nlikely that limits are applied to traffic coming from well-behaving nodes,\nand the reputation of routing nodes isn\u2019t degraded as much.\n\nBut how to get to the point where restrictions are applied generally?\nCurrently there isn\u2019t too much of a reason for routing nodes to constrain\ntheir peers, and as explained above it may even be bad for business.\n\nInstead of failing, an alternative course of action for htlcs that exceed a\nlimit is to hold and queue them. For example, if htlcs come in at a high\nrate, they\u2019ll just be stacking up on the incoming side and are gradually\nforwarded when their time has come.\n\nAn advantage of this is that a routing node\u2019s reputation isn\u2019t affected\nbecause there are no failures. This however may change in the future with\nfat errors [2]. It will then become possible for senders to identify slow\nnodes, and the no-penalty advantage may go away.\n\nA more important effect of holding is that the upstream nodes are punished\nfor the bad traffic that they facilitate. They see their htlc slots\noccupied and funds frozen. They can\u2019t coop close, and a force-close may be\nexpensive depending on the number of htlcs that materialize on the\ncommitment transaction. This could be a reason for them to take a careful\nlook at the source of that traffic, and also start applying limits. Limits\npropagating recursively across the network and pushing bad senders into\ncorners where they can\u2019t do much harm anymore. It\u2019s sort of paradoxical:\njamming channels to stop jamming.\n\nOne thing to note is that routing nodes employing the hold strategy are\npotentially punishing themselves too. If they are the initiator of a\nchannel with many pending htlcs, the commit fee for them to pay can be high\nin the case of a force-close. They do not need to sweep the htlcs that were\nextended by their peer, but still. One way around this is to only use the\nhold strategy for channels that the routing node did not initiate, and use\nthe fail action or no limit at all for self-initiated channels.\n\nInterested to hear opinions on the idea. I\u2019ve also updated circuitbreaker\nwith a queue mode for anyone willing to experiment with it [3].\n\n[1] https://github.com/lightningequipment/circuitbreaker\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-October/003723.html\n[3] https://github.com/lightningequipment/circuitbreaker/pull/14\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/9059931a/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-03T01:05:08",
                "message_text_only": "Hi Joost,\n\nIf I understand correctly circuitbreaker, it adds new \"dynamic\" HTLC slot\nlimits, in opposition to the \"static\" ones declared to your counterparty\nduring channel opening (within the protocol-limit of 483). On top, you can\nrate-limit the HTLCs forwards based on the incoming source.\n\nEffectively, this scheme would penalize your own routing hop as HTLC\nsenders routing algorithms would likely cause the hop, in the lack of a new\ngossip message advertising the limits/rates. Further, it sounds for the\nmeasure to be robust, a circuitbreaking policy should be applied\nrecursively by your counterparty on their network topologies. Otherwise,\nyou're opening I think you'll have the non-constrained links being targeted\nas entry points in the rate-limited, \"jamming-safe\" subset of the graph.\n\nThe limits could be based on HTLC values, e.g the Xth slots for HTLCs of\nvalue <1k sats, the Yth slots for HTLC of value <100k sats, the remaining\nZth slots for HTLC of value <200k sats. IIRC, this jamming countermeasure\nhas been implemented by Eclair [0] and discussed more in detail here [1].\nWhile it increases the liquidity cost for an attacker to launch jamming\nattacks against the high-value slots, it comes at the major downside of\nlowering the cost for jamming low-value slots. Betting on an increasing\nbitcoin price, all other things equals, we'll make simple payments from\nlambda users more and more vulnerable.\n\nBeyond that, I think this solution would classify in the reputation-based\nfamily of solutions, where reputation is local and enforced through\nrate-limiting (from my understanding), I would say there is no economic\nproportionality enforced between the rate-limiting and the cost for an\nattacker. A jamming attacker could open new channels during period of\nlow-fees in the edges of the graph, and still launch attacks against\ndistant hops by splitting the jamming traffic between many sources,\ntherefore avoiding force-closures (e.g 230 HTLCs from channel Mallory, 253\nHTLCs from channel Malicia). Even force-closure in case of observed jamming\nisn't that evident, as the economic traffic could still be opportunistic\nlocally but only a jam on a distant hop. So I think the economic\nequilibrium and risk structure of this scheme is still uncertain.\n\nHowever, I think the mode of queuing HTLCs is still valuable itself,\nindependently of jamming, either a) to increase routed privacy of HTLC (e.g\n\"delay my HTLC\" option [2]), maybe with double opt-in of both senders/hops\nor b) as a congestion control mechanism where you have >100% of honest\nincoming HTLC traffic and you would like to earn routing fees on all of\nthem, in the limit of what the outgoing CLTV allow you. An advanced idea\ncould be based on statistics collection, sending back-pressure messages or\nHTLC sending scheduling information to the upstream hops. Let's say in the\nfuture we have more periodic payments, those ones could be scheduled in\nperiods of low-congestions.\n\nSo I wonder if we don't have two (or even more) problems when we think\nabout jamming, the first one, the HTLC forward \"counterparty risk\" (the\nreal jamming) and the other one, congestion and scheduling of efficient\nHTLC traffic, with some interdependencies between them of course.\n\nOn experimenting with circuitbreaker, I don't know which HTLC intercepting\ninterface it does expect, we still have a rudimentary one on the LDK-side\nonly supporting JIT channels use-case.\n\nBest,\nAntoine\n\n[0] https://github.com/ACINQ/eclair/pull/2330\n[1] https://jamming-dev.github.io/book/about.html\n[2] https://github.com/lightning/bolts/issues/1008\n[3] https://github.com/lightningdevkit/rust-lightning/pull/1835\n\nLe ven. 2 d\u00e9c. 2022 \u00e0 13:00, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> A simple but imperfect way to deal with channel jamming and spamming is to\n> install a lightning firewall such as circuitbreaker [1]. It allows you to\n> set limits like a maximum number of pending htlcs (fight jamming) and/or a\n> rate limit (fight spamming). Incoming htlcs that exceed one of the limits\n> are failed back.\n>\n> Unfortunately there are problems with this approach. Failures probably\n> lead to extra retries which increases the load on the network as a whole.\n> Senders are also taking note of the failure, penalizing you and favoring\n> other nodes that do not apply limits. With a large part of the network\n> applying limits, it will probably work better because misbehaving nodes\n> have fewer opportunities to affect distant nodes. Then it also becomes less\n> likely that limits are applied to traffic coming from well-behaving nodes,\n> and the reputation of routing nodes isn\u2019t degraded as much.\n>\n> But how to get to the point where restrictions are applied generally?\n> Currently there isn\u2019t too much of a reason for routing nodes to constrain\n> their peers, and as explained above it may even be bad for business.\n>\n> Instead of failing, an alternative course of action for htlcs that exceed\n> a limit is to hold and queue them. For example, if htlcs come in at a high\n> rate, they\u2019ll just be stacking up on the incoming side and are gradually\n> forwarded when their time has come.\n>\n> An advantage of this is that a routing node\u2019s reputation isn\u2019t affected\n> because there are no failures. This however may change in the future with\n> fat errors [2]. It will then become possible for senders to identify slow\n> nodes, and the no-penalty advantage may go away.\n>\n> A more important effect of holding is that the upstream nodes are punished\n> for the bad traffic that they facilitate. They see their htlc slots\n> occupied and funds frozen. They can\u2019t coop close, and a force-close may be\n> expensive depending on the number of htlcs that materialize on the\n> commitment transaction. This could be a reason for them to take a careful\n> look at the source of that traffic, and also start applying limits. Limits\n> propagating recursively across the network and pushing bad senders into\n> corners where they can\u2019t do much harm anymore. It\u2019s sort of paradoxical:\n> jamming channels to stop jamming.\n>\n> One thing to note is that routing nodes employing the hold strategy are\n> potentially punishing themselves too. If they are the initiator of a\n> channel with many pending htlcs, the commit fee for them to pay can be high\n> in the case of a force-close. They do not need to sweep the htlcs that were\n> extended by their peer, but still. One way around this is to only use the\n> hold strategy for channels that the routing node did not initiate, and use\n> the fail action or no limit at all for self-initiated channels.\n>\n> Interested to hear opinions on the idea. I\u2019ve also updated circuitbreaker\n> with a queue mode for anyone willing to experiment with it [3].\n>\n> [1] https://github.com/lightningequipment/circuitbreaker\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-October/003723.html\n> [3] https://github.com/lightningequipment/circuitbreaker/pull/14\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/5cdcb76a/attachment-0001.html>"
            },
            {
                "author": "Joost Jager",
                "date": "2022-12-03T07:50:00",
                "message_text_only": "Hi Antoine,\n\nIf I understand correctly circuitbreaker, it adds new \"dynamic\" HTLC slot\n> limits, in opposition to the \"static\" ones declared to your counterparty\n> during channel opening (within the protocol-limit of 483). On top, you can\n> rate-limit the HTLCs forwards based on the incoming source.\n>\n\nCorrect.\n\n\n> Effectively, this scheme would penalize your own routing hop as HTLC\n> senders routing algorithms would likely cause the hop, in the lack of a new\n> gossip message advertising the limits/rates. Further, it sounds for the\n> measure to be robust, a circuitbreaking policy should be applied\n> recursively by your counterparty on their network topologies. Otherwise,\n> you're opening I think you'll have the non-constrained links being targeted\n> as entry points in the rate-limited, \"jamming-safe\" subset of the graph.\n>\n\nIndeed, the more nodes run it, the harder it becomes for attackers to\nattack. You'd only penalize your own routing node if you send back\nfailures. If you hold the htlc, there is no penalty with the network as it\nis currently.\n\n\n> The limits could be based on HTLC values, e.g the Xth slots for HTLCs of\n> value <1k sats, the Yth slots for HTLC of value <100k sats, the remaining\n> Zth slots for HTLC of value <200k sats. IIRC, this jamming countermeasure\n> has been implemented by Eclair [0] and discussed more in detail here [1].\n> While it increases the liquidity cost for an attacker to launch jamming\n> attacks against the high-value slots, it comes at the major downside of\n> lowering the cost for jamming low-value slots. Betting on an increasing\n> bitcoin price, all other things equals, we'll make simple payments from\n> lambda users more and more vulnerable.\n>\n\nIt is true that the limits make it easier to jam a channel, but the theory\nis that everyone does it, the attacker won't have much reach anymore.\n\n\n> Beyond that, I think this solution would classify in the reputation-based\n> family of solutions, where reputation is local and enforced through\n> rate-limiting (from my understanding), I would say there is no economic\n> proportionality enforced between the rate-limiting and the cost for an\n> attacker. A jamming attacker could open new channels during period of\n> low-fees in the edges of the graph, and still launch attacks against\n> distant hops by splitting the jamming traffic between many sources,\n> therefore avoiding force-closures (e.g 230 HTLCs from channel Mallory, 253\n> HTLCs from channel Malicia). Even force-closure in case of observed jamming\n> isn't that evident, as the economic traffic could still be opportunistic\n> locally but only a jam on a distant hop. So I think the economic\n> equilibrium and risk structure of this scheme is still uncertain.\n>\n\nThe economic proportionality is that an attacker can't do much with a\nseverely limited channel, and would need many more to achieve the same\neffect. I don't think it is possible to eliminate all bad behavior, and\nthat the goal should just be to make it a lot harder than it currently is.\nNot sure how force-closes come into play. I don't think there needs to be\nany force-close? I just mentioned them in my original post because they can\nhappen for independent reasons (bug, node offline), and then the size of\nthe commitment tx and number of pending htlcs translates to a real cost.\n\n\n> However, I think the mode of queuing HTLCs is still valuable itself,\n> independently of jamming, either a) to increase routed privacy of HTLC (e.g\n> \"delay my HTLC\" option [2]), maybe with double opt-in of both senders/hops\n> or b) as a congestion control mechanism where you have >100% of honest\n> incoming HTLC traffic and you would like to earn routing fees on all of\n> them, in the limit of what the outgoing CLTV allow you. An advanced idea\n> could be based on statistics collection, sending back-pressure messages or\n> HTLC sending scheduling information to the upstream hops. Let's say in the\n> future we have more periodic payments, those ones could be scheduled in\n> periods of low-congestions.\n>\n> So I wonder if we don't have two (or even more) problems when we think\n> about jamming, the first one, the HTLC forward \"counterparty risk\" (the\n> real jamming) and the other one, congestion and scheduling of efficient\n> HTLC traffic, with some interdependencies between them of course.\n>\n\nYes, so the main idea that I tried to present is that applying congestion\ncontrol by holding htlcs may wake up everyone along the path back to the\nattacker and move them to apply congestion control too.\n\n\n> On experimenting with circuitbreaker, I don't know which HTLC intercepting\n> interface it does expect, we still have a rudimentary one on the LDK-side\n> only supporting JIT channels use-case.\n>\n\nIt connects to lnd's htlc interceptor and htlc events interfaces.\n\nJoost\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221203/55d7f0c4/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-06T04:27:12",
                "message_text_only": "Hi Joost,\n\n> The economic proportionality is that an attacker can't do much with a\n> severely limited channel, and would need many more to achieve the same\n> effect. I don't think it is possible to eliminate all bad behavior, and\n> that the goal should just be to make it a lot harder than it currently is.\n> Not sure how force-closes come into play. I don't think there needs to be\n> any force-close?\n\nI think I share the assumption that you're restraining the ability of a\njamming attacker by applying congestion control, though it sounds only a\nhindrance and there might still be an asymmetry between the on-chain\nopening channel cost encumbered by the attacker and the gain from hijacking\nHTLC traffic. Force-close would be a means to increase the cost for the\nattacker by slashing the channel source of jamming.\n\nThough, I think in the design of jammign solution, there is a conceptual\nstep to define first what we aim to achieve by making a routing hop\n\"jamming safe\", either putting a cost so high on the attacker it's not\neconomically profitable (from my understanding the direction of\ncircuitbreaker, or old stake certificates) or guaranteeing routing fees\nincomes to the routing hop, whatever the outcome of the HTLC traffic (more\nthe direction of unconditional fees or reputational credentials).\n\nBest,\nAntoine\n\nLe sam. 3 d\u00e9c. 2022 \u00e0 02:50, Joost Jager <joost.jager at gmail.com> a \u00e9crit :\n\n> Hi Antoine,\n>\n> If I understand correctly circuitbreaker, it adds new \"dynamic\" HTLC slot\n>> limits, in opposition to the \"static\" ones declared to your counterparty\n>> during channel opening (within the protocol-limit of 483). On top, you can\n>> rate-limit the HTLCs forwards based on the incoming source.\n>>\n>\n> Correct.\n>\n>\n>> Effectively, this scheme would penalize your own routing hop as HTLC\n>> senders routing algorithms would likely cause the hop, in the lack of a new\n>> gossip message advertising the limits/rates. Further, it sounds for the\n>> measure to be robust, a circuitbreaking policy should be applied\n>> recursively by your counterparty on their network topologies. Otherwise,\n>> you're opening I think you'll have the non-constrained links being targeted\n>> as entry points in the rate-limited, \"jamming-safe\" subset of the graph.\n>>\n>\n> Indeed, the more nodes run it, the harder it becomes for attackers to\n> attack. You'd only penalize your own routing node if you send back\n> failures. If you hold the htlc, there is no penalty with the network as it\n> is currently.\n>\n>\n>> The limits could be based on HTLC values, e.g the Xth slots for HTLCs of\n>> value <1k sats, the Yth slots for HTLC of value <100k sats, the remaining\n>> Zth slots for HTLC of value <200k sats. IIRC, this jamming countermeasure\n>> has been implemented by Eclair [0] and discussed more in detail here [1].\n>> While it increases the liquidity cost for an attacker to launch jamming\n>> attacks against the high-value slots, it comes at the major downside of\n>> lowering the cost for jamming low-value slots. Betting on an increasing\n>> bitcoin price, all other things equals, we'll make simple payments from\n>> lambda users more and more vulnerable.\n>>\n>\n> It is true that the limits make it easier to jam a channel, but the theory\n> is that everyone does it, the attacker won't have much reach anymore.\n>\n>\n>> Beyond that, I think this solution would classify in the reputation-based\n>> family of solutions, where reputation is local and enforced through\n>> rate-limiting (from my understanding), I would say there is no economic\n>> proportionality enforced between the rate-limiting and the cost for an\n>> attacker. A jamming attacker could open new channels during period of\n>> low-fees in the edges of the graph, and still launch attacks against\n>> distant hops by splitting the jamming traffic between many sources,\n>> therefore avoiding force-closures (e.g 230 HTLCs from channel Mallory, 253\n>> HTLCs from channel Malicia). Even force-closure in case of observed jamming\n>> isn't that evident, as the economic traffic could still be opportunistic\n>> locally but only a jam on a distant hop. So I think the economic\n>> equilibrium and risk structure of this scheme is still uncertain.\n>>\n>\n> The economic proportionality is that an attacker can't do much with a\n> severely limited channel, and would need many more to achieve the same\n> effect. I don't think it is possible to eliminate all bad behavior, and\n> that the goal should just be to make it a lot harder than it currently is.\n> Not sure how force-closes come into play. I don't think there needs to be\n> any force-close? I just mentioned them in my original post because they can\n> happen for independent reasons (bug, node offline), and then the size of\n> the commitment tx and number of pending htlcs translates to a real cost.\n>\n>\n>> However, I think the mode of queuing HTLCs is still valuable itself,\n>> independently of jamming, either a) to increase routed privacy of HTLC (e.g\n>> \"delay my HTLC\" option [2]), maybe with double opt-in of both senders/hops\n>> or b) as a congestion control mechanism where you have >100% of honest\n>> incoming HTLC traffic and you would like to earn routing fees on all of\n>> them, in the limit of what the outgoing CLTV allow you. An advanced idea\n>> could be based on statistics collection, sending back-pressure messages or\n>> HTLC sending scheduling information to the upstream hops. Let's say in the\n>> future we have more periodic payments, those ones could be scheduled in\n>> periods of low-congestions.\n>>\n>> So I wonder if we don't have two (or even more) problems when we think\n>> about jamming, the first one, the HTLC forward \"counterparty risk\" (the\n>> real jamming) and the other one, congestion and scheduling of efficient\n>> HTLC traffic, with some interdependencies between them of course.\n>>\n>\n> Yes, so the main idea that I tried to present is that applying congestion\n> control by holding htlcs may wake up everyone along the path back to the\n> attacker and move them to apply congestion control too.\n>\n>\n>> On experimenting with circuitbreaker, I don't know which HTLC\n>> intercepting interface it does expect, we still have a rudimentary one on\n>> the LDK-side only supporting JIT channels use-case.\n>>\n>\n> It connects to lnd's htlc interceptor and htlc events interfaces.\n>\n> Joost\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221205/1fa4f5eb/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Jamming against Channel Jamming",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "Joost Jager"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 22069
        }
    },
    {
        "title": "[Lightning-dev] Factory-Optimized Protocols For Lightning",
        "thread_messages": [
            {
                "author": "jlspc",
                "date": "2022-12-02T20:18:25",
                "message_text_only": "TL;DR\n=====\n* This post presents a channel protocol that's optimized for use within channel factories.\n* The protocol allows HTLCs to be resolved on-chain:\n* without making the expiry of the HTLC depend on the time to close the factory, and\n* without closing the factory.\n* The key ides is the use of separate value and control transactions like those used in the Tunable Penalties protocol.\n* A version of the protocol that provides watchtower-freedom and one-shot receives for casual users is also given.\n\nOverview\n========\n\nWhile the Lightning Network greatly improves Bitcoin's scalability, factories that allow multiple two-party channels to be created and closed with a small number of on-chain transactions are essential if Bitcoin is to be widely used in a trust-free manner [2].\nUnfortunately, the existing channel protocols aren't optimized for use within factories, thus limiting the efficiency of both the channels and the factories.\n\nThe Lightning Network uses Hash Time-Locked Contracts (HTLCs) to implement payments across multiple channels.\nIf one of the parties to an HTLC is unresponsive, the other party must resolve the HTLC on-chain.\nThis creates two problems.\n\nFirst, the HTLC's expiry must be delayed by the time required to close the factory and put the channel containing the HTLC on-chain.\nThe most efficient known factory [2] can be closed in O(log S) time using O(log S) on-chain transactions, assuming the factory supports S states.\nIf all the hops in a multi-hop payment use channels that are implemented with factories, the sum of the delays for closing all of those factories must be included in the HTLC expiry of the first hop.\nAs a result, this delay could become very large, thus leading to inefficient use of the channels' capital and long waits to obtain payment receipts.\n\nSecond, the requirement to close a factory due to the need to resolve an HTLC on-chain means that a single unresponsive party can force the closure of an entire factory, thus limiting the factory's ability to scale Bitcoin.\n\nThis post presents factory-optimized channel protocols that solve both of these problems.\nThe first protocol, called the Partially-Factory-Optimized (PFO) protocol, solves the first problem, while the second protocol, called the Fully-Factory-Optimized (FFO) protocol, solves both problems.\nBoth protocols are slight modifications of the Tunable-Penalties (TP) protocol [5] and they share many of its properties, including:\n* tunable penalties for putting old transactions on-chain, and\n* efficient watchtowers with O(log S) storage for supporting O(S) channel states.\n\nIn addition, a version of the FFO protocol, called the Fully-Factory-Optimized-Watchtower-Free (FFO-WF) protocol is presented that supports watchtower-freedom and one-shot receives for casual users [4].\nNo change to the underlying Bitcoin protocol is required.\n\nA paper with a more complete description of the protocols, including figures, values for the timing parameters, and proofs of correctness, is available [6].\n\nThe Partially-Factory-Optimized (PFO) Protocol\n==============================================\n\nThe PFO protocol is a slight modification of the TP protocol [5].\nIn the TP protocol, each party has their own on-chain Individual transaction, the output of which they spend with their State transaction.\nThis State transaction is a control transaction that establishes the channel's state and has an HTLC control output corresponding to each HTLC outstanding in the channel in that state.\nEach HTLC control output is used to resolve an HTLC by spending the output with either an HTLC-success or an HTLC-timeout transaction.\nCritically, the State, HTLC-success and HTLC-timeout transactions can be put on-chain without spending any of the channel's funds.\nTherefore, the TP protocol almost solves the problem of resolving a channel's HTLCs without waiting for the Funding transaction to be put on-chain.\n\nUnfortunately, there's one problem in trying to use the TP protocol to resolve the HTLCs of a factory-created channel before the factory is closed and its Funding transaction is on-chain.\nThe correctness of the TP protocol depends on the ability to put the current Commitment transaction (spending the output of the channel's Funding transaction) on-chain as soon as possible once the relative delay between it and its corresponding State transaction has been met.\nThis relative delay is set to tsdAB, which is the maximum of the two parties' to_self_delay parameters.\nThe problem is that the latency to close the factory and put the channel's Funding transaction on-chain could exceed tsdAB.\nAs a result, the TP protocol can't be used in such a factory.\n\nThe PFO protocol fixes this by simply setting the relative delay between the State transaction and its associated Commitment transaction to the maximum of the factory-close latency and tsdAB.\n\nThe Fully-Factory-Optimized (FFO) Protocol\n==========================================\n\nWhile the PFO protocol separates the latency to close the factory from the setting of the HTLCs' expiries, it still requires that the factory be closed in order to guarantee that the HTLCs have been resolved correctly.\n\nThe FFO protocol makes several changes to the PFO protocol in order to resolve HTLCs without requiring the closure of the factory.\nConsider an HTLC offered by Alice to Bob.\n\nFirst, in the FFO protocol only Bob's State transaction has an HTLC control output that determines the resolution of this HTLC, regardless of which party's Commitment transaction is put on-chain.\nAs a result, there's no race to put one's Commitment transaction on-chain, and thus no need to close the factory in order to resolve HTLCs.\nAs another result, it eliminates the possibility of this HTLC being resolved with Alice's State and associated HTLC-timeout transactions being put on-chain late relative to the HTLC's expiry.\n\nSecond, because the HTLC is always resolved based on an HTLC control output in Bob's State transaction, Bob has to be incentivized to put his correct State transaction on-chain (or else he could prevent the HTLC from timing out by not putting his State transaction on-chain).\nThis is solved by requiring Bob's State and HTLC-success transactions in order to pay the HTLC, and to refund the HTLC to Alice (after a suitable relative delay) if Bob's State and HTLC-success transactions are not on-chain.\n\nThird, Bob is prevented from putting his State transaction on-chain late relative to the HTLC's expiry by adding a relative delay of tsdA (Alice's to_self_delay parameter) before he can put his HTLC-success transaction on-chain.\nThis guarantees that Alice will have time to respond with a conflicting transaction that prevents Bob's HTLC-success transaction from being put on-chain late relative to the HTLC's expiry.\n\nFinally, if the HTLC's secret were not revealed until the HTLC-success transaction is put on-chain, the worst-case latency for obtaining a secret from a successful HTLC would depend on tsdA, which would greatly increase Bob's cltv_expiry_delta parameter, in turn increasing the cost of capital reserved for the HTLC and the delay for obtaining a payment receipt.\nThis problem is solved by introducing a new transaction, called an HTLC-kickoff transaction, that spends the HTLC control output in Bob's State transaction and reveals the HTLC's secret, with the HTLC-success transaction spending the HTLC-kickoff transaction's output.\nThus,the revelation of the HTLC's secret is performed first, followed by the resolution of the HTLC approximately tsdA later.\n\nThe FFO protocol is shown below:\n\n+-+ AB +----+ A\n|F|----+-----------------------------| CC |----\n+-+ | | |\n. | | B\n. | |----\n. +----+\n| +----+ A\n+-----------------------------|C_Ai|----\n| | |\n| | | B\n| | |----\n| tsdB & A | | tsdAB & A\n| +---------------| |-----+------------\n| | +----+ |\n| | | AB +-----+ B\n| | +--------------|Hp_Bi|----\n| | | |\n| | +--| |\n| | | +-----+\n| | +----+ A |\n+-----------------------------|C_Bi|---- |\n| | | | |\n. | | | B |\n. | | |---- |\n. | tsdA & B | | tsdAB & A |\n| +-----------------| |-----+--------------\nV | | +----+ | |\n| | | AB | +-----+ B\n+----+ A +-----+ | | pckeyAi +--------------|Hp_Bi|----\n|In_A|----|St_Ai|----+---------- | | |\n+----+ | | | +--| |\n| | | | +-----+\n| | | |\n+-----+ | |\n| (eAB+tsdA) & A |\n+----+ B +-----+ | pckeyBi +----------------- |\n|In_B|----|St_Bi|--+------------ | |\n+----+ | | | |\n| | hp(X) & B +-----+ | tsdA & B +-----+ B |\n| |------------|Hk_Bi|-+-----------|Hs_Bi|----+\n+-----+ +-----+ +-----+\n\nwhere:\nF is the Funding transaction,\nCC is the Cooperative Close transaction,\nIn_{A|B} is {Alice's|Bob's} Individual transaction,\nSt_{A|B}i is {Alice's|Bob's} State transaction for state i,\nC_{A|B}i is {Alice's|Bob's} Commitment transaction for state i,\nHk_Bi is Bob's HTLC-kickoff transaction for state i,\nHs_Bi is Bob's HTLC-success transaction for state i, and\nHp_Bi is Bob's HTLC-payment transaction for state i.\n\nRequirements for output cases are as follows:\nA: Alice's signature,\nB: Bob's signature,\nAB: Alice's and Bob's signatures,\npckey{A|B}i: a signature using a per-commitment key for revoking\n{Alice's|Bob's} state i transaction,\nhp(X): the hash preimage of X,\ntsd{A|B}: a relative delay equal to {Alice's|Bob's} to_self_delay\nparameter,\ntsdAB: a relative delay equal to max(tsdA, tsdB), and\neAB: an absolute timelock equal to the expiry of the HTLC in this hop.\n\nExtensions\n==========\n\nIf a party accidentally puts on old State transaction on-chain, they only lose the penalty amount that is the output of that transaction (and potentially some of the minimal values of that transaction's HTLC control outputs).\nHowever, once their State transaction has been revoked, they've lost the ability to force a unilateral close of the channel after the Funding transaction is on-chain.\nTo address this, it's possible to add a Trigger [2] transaction that spends the output of the Funding transaction.\nAfter the Trigger transaction has been on-chain for 3tsdAB (in order to allow the other party to put their Commitment transaction on-chain), the Decker-Wattenhofer protocol [3] can be used to settle the channel.\n\nThe FFO protocol shows how a channel's HTLCs can be resolved on-chain without putting its Funding transaction on-chain, and thus without closing the channel factory.\nThe party that went on-chain can settle the channel and its HTLCs correctly, even if their partner is malicious.\nHowever, the most likely reason a party goes on-chain is that their partner is unintentionally unavailable, rather than malicious.\nWhen the unavailable partner becomes available again, the two parties could choose to re-start operating the channel, and that's possible because the channel's funds haven't been distributed.\nIn particular, the party that went on-chain can use the unspent first output of their State transaction to play the role of their Individiual transaction's output as they resume operating the channel.\nThis output has slightly less value, as it's sized for the penalty amount and doesn't have additional funds for HTLC control outputs, but it seems reasonable to reduce the penalty amount that they will have to pay, given that it was the other party's unavailability that forced them to go on-chain.\n\nWatchtower-Freedom And One-Shot Receives For Casual Users\n=========================================================\n\nThe WF protocol modified the current Lightning protocol to allow casual users to operate without watchtowers and to perform one-shot receives.\nA similar approach can be used to modify the FFO protocol to achieve the same goals, resulting in the FFO-WF protocol.\n\nConsider a casual user Alice and her dedicated channel partner Bob.\nLike the WF protocol, the FFO-WF protocol adds a relative delay before Alice can time out an HTLC offered to Bob, allowing Bob to stay off-chain after the HTLC's expiry, thus tolerating Alice's intentional unavailability.\nAs in the FFO protocol, in the FFO-WF protocol only one of the two parties' State transactions has an HTLC control output for each HTLC that is outstanding.\nHowever, unlike the FFO protocol, Alice's State transaction has the HTLC control outputs for all HTLCs, even those offered to Bob.\nThe control of the HTLCs offered to Bob is moved to Alice's State transaction in order to allow Alice to force Bob to produce a receipt (or to not receive payment) by putting her State transaction on-chain.\nWhile this solves the problem of forcing receipts, it creates a risk that Alice will never put her State transaction on-chain, thus preventing Bob from receiving payment for HTLCs offered to him.\nThis risk is solved by modifying Bob's Commitment transaction to ignore the HTLC control results and to pay all HTLC amounts (both those offered by him and those offered to him) to Bob, but delaying Bob's State and Commitment transactions enough that Alice can always get her State and Commitment transactions on-chain, thus resolving the HTLCs correctly (as she is incentivized to do, given Bob's Commitment transaction).\n\nIn order to support one-shot receives for Alice, she is able to submit her State and HTLC-success transactions as a single package, without any relative delay between them.\nThis creates a risk that she will submit them well after the HTLC's expiry, thus allowing her to receive payment without meeting the terms of the HTLC.\nThis risk is solved by requiring Alice's HTLC-success transaction to also spend a new control output in Bob's Individual transaction, and allowing Bob to spend that new control output with an HTLC-timeout transaction after the HTLC's expiry (thus blocking Alice's HTLC-success transaction).\nThis design creates another issue, namely the possibility of Bob using an old HTLC-timeout transaction (or any other transaction) to spend the new control output and block Alice's HTLC-success transaction before the HTLC's expiry.\nThis final issue is solved by having each HTLC output in Alice's Commitment transaction default (after a sufficient relative delay) to paying her for the HTLC offered to her unless Bob's corresponding HTLC-timeout transaction is on-chain.\n\nThe FFO-WF protocol, with a single HTLC outstanding from dedicated user Bob to casual user Alice, is shown below:\n\n+-+ AB +----+ A\n|F|----+-----------------------------| CC |----\n+-+ | | |\n. | | B\n. | |----\n. +----+\n| tsdB & AB +----+ A\n+-----------------------------|C_Ai|----\n| | |\n| | | B\n| | |----\n| tsdB & A | | tsdAB & A\n| +-----------------| |-----+------------\n| | +----+ |\n| | | AB +-----+ B\n| | +-----------|Hr_Bi|----\n| | | |\n| | B | |\n| | +--| |\n| | | +-----+\n| tA+B & AB | +----+ A |\n+-----------------------------|C_Bi|---- |\n| | | | |\n. | | | B |\n. | | |---- |\n. | tA+B & B | | |\n| | +-------------| | |\nV | | +----+ |\n| | |\n+----+ A +-----+ | | pckeyAi |\n|In_A|----|St_Ai|--+-------------- |\n+----+ | | | |\n| | | hp(X) & A +-----+ A |\n| | ---------------------|Hs_Ai|---- |\n+-----+ | | | |\n| B | | |\n| +--| | |\n| | +-----+ |\n+----+ (Li)&B +-----+ | pckeyBi | |\n|In_B|---------|St_Bi|-+---------- | |\n| | +-----+ | |\n| | | (eAB) & B +-----+ |\n| |------------------------------+------------|Ht_Bi|-+\n+----+ +-----+\n\nwhere notation matches the figure above, plus:\nHs_Ai is Alice's HTLC-success transaction for state i,\nHt_Bi is Bob's HTLC-timeout transaction for state i,\nHr_Bi is Bob's HTLC-refund transaction for state i,\ntA+B equals tsdA + tsdB, and\nLi is an absolute locktime that is tsdA in the future when state i is\ncreated.\n\nRelated Work\n============\n\nThe protocols presented here are designed to make efficient use of channel factories for Lightning.\nThe concept of channel factories and the most efficient published protocol for a channel factory were created by Burchert, Decker and Wattenhofer [2].\n\nTowns proposed adding a new opcode to Bitcoin, called TAPLEAF_UPDATE_VERIFY (TLUV), that would support (among other things) the ability to remove one party from a CoinPool without having to close the CoinPool [7], and ZmnSCPxj noted that this opcode could also be used to remove one channel from a factory without closing the factory [8].\nThose proposals differ from the protocols presented here in that they require a change to Bitcoin.\n\nThe protocols presented here use HTLC-timeout and HTLC-success transactions to resolve HTLCs before the channel's Funding transaction has been put on-chain, thus reducing the expiry of those HTLCs.\nThis idea is analogous to, and inspired by, the Lightning protocol's use of HTLC-timeout and HTLC-success transactions to resolve HTLCs before their associated Commitment transaction has been verified to be unrevoked [1].\n\nThe PFO, FFO and FFO-WF protocols are based on the TP protocol presented by Law [5].\nThe techniques for supporting watchtower-freedom and one-shot receives in the FFO-WF protocol are based on those presented by Law in [4] and [5].\n\nConclusions\n===========\n\nThis post presents channel protocols that are optimized for use within channel factories.\nThe protocols make the resolution of HTLCs in the channels independent of the latency to close the channel factory.\nThe FFO and FFO-WF protocols also allows HTLCs to be resolved on-chain without closing the channel factory.\n\nIf the FFO protocol is used in channels owned by pairs of dedicated users and the FFO-WF protocol is used in channels with a casual user:\n* casual users do not require watchtowers,\n* casual users can use one-shot receives,\n* dedicated users can use watchtowers with logarithmic storage,\n* all users can have tunable penalties,\n* all channels can have HTLCs with expiries that are independent of the latency of closing the factory that created them, and\n* all channels can resolve their HTLCs without closing the factories that created them.\n\nIt's hoped that these factory-optimized protocols will allow channel factories to become commonly-used, thus improving Bitcoin's scalability.\n\nRegards,\nJohn\n\nReferences\n==========\n\n[1] BOLT specifications, available at https://github.com/lightningnetwork/lightning-rfc.\n[2] Burchert, Decker and Wattenhofer, \"Scalable Funding of Bitcoin Micropayment Channel Networks\", available at http://dx.doi.org/10.1098/rsos.180089.\n[3] Decker and Wattenhofer, \"A Fast and Scalable Payment Network with Bitcoin Duplex Micropayment Channels\", available at https://tik-old.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf.\n[4] Law, \"Watchtower-Free Lightning Channels For Casual Users\", available at https://github.com/JohnLaw2/ln-watchtower-free.\n[5] Law, \"Lightning Channels With Tunable Penalties\", available at https://github.com/JohnLaw2/ln-tunable-penalties.\n[6] Law, \"Factory-Optimized Channel Protocols For Lightning\", available at https://github.com/JohnLaw2/ln-factory-optimized.\n[7] Towns, \"TAPLEAF_UPDATE_VERIFY covenant opcode\", available at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html.\n[8] ZmnSCPxj, \"Channel Eviction From Channel Factories By New Covenant Operations\", available at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/003479.html.\n\nSent with [Proton Mail](https://proton.me/) secure email.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221202/9a91c6d0/attachment-0001.html>"
            },
            {
                "author": "jlspc",
                "date": "2022-12-26T19:18:38",
                "message_text_only": "I'd like to make two corrections to this post:\n\n1) The link for reference [8] should be: https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-February/003479.html (thanks to David A. Harding for this correction).\n\n2) An extension of the FFO protocol was described in which the parties in a channel could continue to operate the channel after one party put their State transaction on-chain by having the first output of that State transaction play the role of the same party's Individiual transaction's output. This doesn't work, because that party would have to reveal the per-commitment key to invalidate the previous channel state, and once revealed the other party could then spend that output. This problem can be fixed by having the party that put their State transaction on-chain put a new Individual transaction on-chain that spends the first output of their State transaction.\n\nRegards,\nJohn\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221226/fd9d9147/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Factory-Optimized Protocols For Lightning",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "jlspc"
            ],
            "messages_count": 2,
            "total_messages_chars_count": 20405
        }
    },
    {
        "title": "[Lightning-dev] Unjamming lightning (new research paper)",
        "thread_messages": [
            {
                "author": "Matt Corallo",
                "date": "2022-12-04T00:03:17",
                "message_text_only": "On 11/15/22 12:09\u202fPM, Clara Shikhelman wrote:\n> Matt \u2013 I don't know that I agree with \"... upfront payments kinda kill the lightning UX ...\". I \n> think that upfront fees are almost essential, even outside the context of jamming. This also helps \n> with probing, general spam, and other aspects. Furthermore, I think that the UX is very explainable,\n\nIndeed, it may be explainable, but its still somewhat painful, I think. I do wonder if we can enable \nprobing via a non-HTLC message and do immediate pre-send-probing to avoid paying upfront fees on \npaths that will fail.\n\n> and in general nodes shouldn't be motivated to send a lot of failed payments, and should adopt \n> better routing strategies.\n\nI don't think so - today there are at least three different routing goals to maximize - (a) privacy, \n(b) fees, (c) success rate. For \"live\" payment, you probably want to lean towards optimizing for \nsuccess rate, and many nodes do today by default. But that isn't the full story - many nodes do \nbackground rebalancing and they prefer to take paths which optimize for fees, trying many paths they \nthink are likely to fail to see if they can rebalance with lower fees. I don't think we should tell \nthose users/use-cases that they aren't allowed to do that or they're doing something \"wrong\" - I \nthink choosing to optimize for fees (or, in the future, privacy) is an important thing to allow, and \nideally make as reliable as possible, without charging extra for it.\n\nMatt"
            },
            {
                "author": "Clara Shikhelman",
                "date": "2022-12-08T15:29:48",
                "message_text_only": "Hi Matt,\n\n\n\n> Indeed, it may be explainable, but its still somewhat painful, I think. I\n> do wonder if we can enable\n> probing via a non-HTLC message and do immediate pre-send-probing to avoid\n> paying upfront fees on\n> paths that will fail.\n>\n>\nThis could be a good idea, but I think that it shouldn't be a prerequisite\nfor unconditional fees.\n\n\n> I don't think so - today there are at least three different routing goals\n> to maximize - (a) privacy,\n> (b) fees, (c) success rate. For \"live\" payment, you probably want to lean\n> towards optimizing for\n> success rate, and many nodes do today by default. But that isn't the full\n> story - many nodes do\n> background rebalancing and they prefer to take paths which optimize for\n> fees, trying many paths they\n> think are likely to fail to see if they can rebalance with lower fees. I\n> don't think we should tell\n> those users/use-cases that they aren't allowed to do that or they're doing\n> something \"wrong\" - I\n> think choosing to optimize for fees (or, in the future, privacy) is an\n> important thing to allow, and\n> ideally make as reliable as possible, without charging extra for it.\n>\n\nI agree that fees and privacy are important, and play a bigger role in\ntransactions that are not very time sensitive. That being said, locking up\nfunds in channels knowing that with a decent probability the nodes along\nthe route won't be compensated at all is not great. If it's on a small\nscale, we don't have to think about this as \"wrong\". The sender is asking\nthe nodes along the route to provide a service (lock up funds and provide\ninformation about liquidity) and is paying a small fee for it.\n\nSpeaking of \"wrong\" - on Monday we'll be discussing further parameters to\nbe considered in reputation schemes. I think that your input will be very\nvaluable.\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/329f785d/attachment.html>"
            },
            {
                "author": "Michael Folkson",
                "date": "2022-12-09T10:16:48",
                "message_text_only": "> I don't think so - today there are at least three different routing goals to maximize - (a) privacy,\n> (b) fees, (c) success rate. For \"live\" payment, you probably want to lean towards optimizing for\n> success rate, and many nodes do today by default. But that isn't the full story - many nodes do\n> background rebalancing and they prefer to take paths which optimize for fees, trying many paths they\n> think are likely to fail to see if they can rebalance with lower fees. I don't think we should tell\n> those users/use-cases that they aren't allowed to do that or they're doing something \"wrong\" - I\n> think choosing to optimize for fees (or, in the future, privacy) is an important thing to allow, and\n> ideally make as reliable as possible, without charging extra for it.\n\nRight, the trade-offs here are really tricky to navigate and to whatever extent this is possible the choice of what trade-offs to make should be pushed to the user. For example, not knowing the real time channel balances clearly hurts routing success. If this degraded routing success from 95 percent to say 90 percent the network as a whole would probably be willing to pay that routing success \"cost\" to ensure better balance privacy. But if it degraded routing success from 95 percent to say 50 percent I expect much of the network wouldn't be willing to put up with that terrible routing success percentage and routing nodes would probably seek to broadcast their channel balances either in gossip or out of band.\n\nSimilarly a routing node not knowing the source of the payment and the intermediate nodes on the route is fine (it is clearly *much* better for privacy) assuming jamming attacks occur rarely. But if the network is being paralyzed regularly by jamming attacks a routing node is going to show a lot more interest in which Lightning node it is routing payments for and which other Lightning nodes are also part of the route. You aren't going to want to continue to be subject to jamming attacks by the same Lightning node.\n\nHence I stick by this from a protocol developer perspective.\n\n\"Decisions protocol developers make will impact what data can be collected and how easy that data is to collect (there are already some tricky trade-offs with regards to privacy, routing success and transparency for when things go wrong) but beyond that protocol developers should leave it to others.\"\n\nA protocol developer (and individual implementation developer I guess) is going to have to wrestle with these trade-offs and to what extent options can be pushed to the user. But protocol reputation tokens that can be sold or transferred to an attacker or worse collected through gaming the system, ouch. The protocol developer has taken a problem (jamming attacks) that already exists and added an additional problem (reputation) which no doubt will be addressed by adding an additional problem on top of that and another on top of that etc etc.\n\n--\nMichael Folkson\nEmail: michaelfolkson at protonmail.com\nKeybase: michaelfolkson\nPGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3\n\n\n------- Original Message -------\nOn Sunday, December 4th, 2022 at 02:03, Matt Corallo <lf-lists at mattcorallo.com> wrote:\n\n\n> \n> On 11/15/22 12:09\u202fPM, Clara Shikhelman wrote:\n> \n> > Matt \u2013 I don't know that I agree with \"... upfront payments kinda kill the lightning UX ...\". I\n> > think that upfront fees are almost essential, even outside the context of jamming. This also helps\n> > with probing, general spam, and other aspects. Furthermore, I think that the UX is very explainable,\n> \n> \n> Indeed, it may be explainable, but its still somewhat painful, I think. I do wonder if we can enable\n> probing via a non-HTLC message and do immediate pre-send-probing to avoid paying upfront fees on\n> paths that will fail.\n> \n> > and in general nodes shouldn't be motivated to send a lot of failed payments, and should adopt\n> > better routing strategies.\n> \n> \n> I don't think so - today there are at least three different routing goals to maximize - (a) privacy,\n> (b) fees, (c) success rate. For \"live\" payment, you probably want to lean towards optimizing for\n> success rate, and many nodes do today by default. But that isn't the full story - many nodes do\n> background rebalancing and they prefer to take paths which optimize for fees, trying many paths they\n> think are likely to fail to see if they can rebalance with lower fees. I don't think we should tell\n> those users/use-cases that they aren't allowed to do that or they're doing something \"wrong\" - I\n> think choosing to optimize for fees (or, in the future, privacy) is an important thing to allow, and\n> ideally make as reliable as possible, without charging extra for it.\n> \n> Matt\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev"
            }
        ],
        "thread_summary": {
            "title": "Unjamming lightning (new research paper)",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Michael Folkson",
                "Matt Corallo",
                "Clara Shikhelman"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 8370
        }
    },
    {
        "title": "[Lightning-dev] Two-party eltoo w/ punishment",
        "thread_messages": [
            {
                "author": "Anthony Towns",
                "date": "2022-12-07T05:35:59",
                "message_text_only": "Hi all,\n\nOn the eltoo irc channel we discussed optimising eltoo for the 2-party\nscenario; figured it was probably worth repeating that here.\n\nThis is similar to:\n\n - 2018-07-18, simplified eltoo: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001363.html\n - 2021-09-17, IID 2Stage, https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019470.html\n - 2022-09-29, Daric: https://eprint.iacr.org/2022/1295\n - 2022-10-21, eltoo/chia: https://twitter.com/bramcohen/status/1583122833932099585\n\nThe basic idea is \"if it's a two party channel with just Alice and Bob,\nthen if Alice starts a unilateral close, then she's already had her say,\nso it's only Bob's opinion that matters from now on, and he should be\nable to act immediately\", and once it's only Bob's opinion that matters,\nyou can simplify a bunch of things.\n\nA \"gist\" for this idea is https://gist.github.com/ajtowns/53e0f735f4d5c06a681429d937200aa5 (it goes into a little more detail in places, though doesn't cover trustless watchtowers at all).\n\n\n\nIn particular, there are a few practical constraints that we might like\nto consider for 2-party channels with eltoo:\n\n - fast forwards: we might want to allow our channel partner\n   to immediately rely on a new state we propose without needing a\n   round-trip delay -- this potentially makes forwarding payments much\n   faster (though with some risk of locking the funds up, if you do a\n   fast forward to someone who's gone offline)\n\n - doubled delays: once we publish the latest state we can, we want to\n   be able to claim the funds immediately after to_self_delay expires;\n   however if our counterparty has signatures for a newer state than we\n   do (which will happen if it was fast forwarded), they could post that\n   state shortly before to_self_delay expires, potentially increasing\n   the total delay to 2*to_self_delay.\n\n - penalties: when you do a unilateral close, attempting to cheat comes\n   with no cost to you and a possible benefit if you succeed, but\n   potentially does cost your channel partner (either in forcing them\n   to spend on-chain fees to update to the correct state, or in the risk\n   of loss if their node malfunctions occassionally) -- a penalty could\n   reduce this incentive to cheat\n\n - trustless watchtowers: we may want to consider the possibility of a\n   watchtower holding onto obsolete states and colluding with an\n   attacker to attempt to cheat us\n\nWhat follows is a rough approach for dealing with all those issues for\ntwo-party channels. It's spelled out in a little more detail in the gist.\n\n(I think for initial eltoo experimentation it doesn't make sense to try to\ndeal with all (or perhaps any) of those constraints; simple and working\nis better than complex and theoretical. But having them written down so\nthe ideas can be thought about and looked up later still seems useful)\n\nIn more detail: unilateral closes are handled by each channel participant\nmaintaining five transactions, which we'll call:\n\n * UA.n, UB.n : unilaterally propose closing at state n\n   - this is for Alice or Bob to spend the funding tx for a unilater\n     close to state n. Spends the funding transaction.\n\n * WA.n, WB.n : watchtower update to state n\n   - this is for an untrusted watchtower to correct attempted cheating\n     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n     (or UA.k/WB.k) respectively, provided k < n.\n\n * CA.n, CB.n : cooperatively claim funds according to state n\n   - this is for Alice to confirm Bob's unilateral close (or vice-versa).\n     Spends UB.k, WA.k (or UA.k/WB.k respectively), provided k <= n\n\n * SA.n, SB.n : slowly claim funds according to state n\n   - this is for Alice to claim her funds if Bob is completely offline\n     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n     timelock of to_self_delay.\n\n * RA.n, RB.n : claim funds with penalty after unilateral close to\n   revoked state\n   - this is for Alice to update the state if Bob attempted to cheat\n     (or vice-versa). Spends UB.k or WA.k (or UA.k/WB.k respectively)\n     conditional on k < n - 1; outputs are adjusted to transfer a fixed\n     penalty of penalty_msat from Bob's balance to Alice's (or vice-versa)\n\nEach of these \"transactions\" requires a pre-signed signature; however\nthe actual transaction/txid will vary in cases where a transaction has\nthe possibility of spending different inputs (eg \"Spends UB.k or WA.k\").\nIn particular UA.n/UB.n can be constructed with known txids and non-APO\nsignatures but WA.n/WB.n/CA.n/CB.n/SA.n/SB.n/RA.n/RB.n all require\nAPO signatures.\n\nThey're named such that Alice can immediately broadcast all the *A.n\ntransactions (provided a tx that it can spend has been broadcast) and\nBob can likewise immediately broadcast all the *B.n transactions.\n\nScenarios where Alice decides to unilaterally close the channel might\nlook like:\n\n * if Alice/Bob can't communicate directly, but both are online:\n\n     F -> UA.n -> CB.n -> money\n\n   (balances and htlcs claimed, no delay)\n\n * if Bob has gone offline entirely:\n\n     F -> UA.n -> (to_self_delay) -> SA.n -> money\n\n * Alice cheats, Bob punishes:\n\n     F -> UA.k -> RB.n -> money[Alice pays Bob penalty]\n\n * Bob is offline, Alice cheats, but Bob has a watchtower:\n\n     F -> UA.k -> WB.n -> (to_self_delay) -> SA.n -> money\n\n * Alice and Bob's watchtower collude, but Bob's not offline:\n\n     F -> UA.k1 -> WB.k2 -> RB.n -> money[Alice pays Bob penalty]\n\n * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n\n     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n\nFor Alice to successfully cheat, she needs Bob to be offline for at least\nto_self_delay, and for all Bob's watchtowers to either also be offline,\nor colluding.\n\nThis can be simplified somewhat, if you don't care about all the features:\n\n * If you don't care about trustless watchtowers you can drop WA.n/WB.n\n   (and simplify SA.n/SB.n to not require an APO signature)\n\n * If you don't care about penalties you can set penalty_msat to 0 and\n   allow RA.n/RB.n to spend k<=n. In this case, you can either drop\n   CA.n/CB.n entirely, or you can have CA.n/CB.n only be used for directly\n   spending of UB.n/UA.n and thus not require APO signatures\n\nIn order to allow fast-forwards, when Alice proposes a new state,\nshe needs to send her partial signatures to allow Bob to unilaterally\naccept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\nalso needs to be able to claim the funds if Bob proposes the new state\nand broadcasts UB.n, she needs to be able broadcast CA.n. This can be\nachieved with an adaptor signature approach (spelt out a bit more fully\nin the gist) or a CTV-like approach, provided that UB.n reveals the\nstate needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\nhttps://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md).\n\nNote that in this scenario Alice doesn't provide WB.n to Bob\nimmediately. This is okay, as if Alice proposes UA.(n-1) (her most\nrecent state), Bob can still immediately claim via CA.n. If Bob did have\nWB.n; then if Alice proposed UA.(n-1) Bob could wait for an initial\nto_self_delay period and broadcast WB.n, forcing Alice to wait for an\nadditional to_self_delay before being able to claim her funds via SA.n.\n\nNote also that this is why RA.n/RB.n require \"k < n - 1\" -- otherwise\nAlice would only be able to broadcast UA.(n-1) and Bob would immediately\nbe able to penalise by broadcasting RB.n.\n\nNote that if you're using a watchtower and wish to punish your\ncounterparty if it attempts to cheat, you should only pass WA.(n-2)\nto your watchtowers, not WA.(n-1) or WA.n.\n\n\n\nThis doesn't address any potential issues from:\n\n * how to add fees -- the U/W transactions are 1-in/1-out transactions\n   that can't be trivially CPFPed by the proposer and need to have\n   fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n   ephemeral output and package relay might be workable); the C/S/R\n   transactions are 1-in/many-out transactions, but have balance outputs\n   that can be immediately spent to pay for fees via CPFP if package\n   relay is available.\n\n * how to pay watchtowers -- when a watchtower broadcasts a W\n   transaction, it needs to add fees, and it's not clear (to me) how it\n   could fairly and reliably ensure it's compensated for those costs,\n   particularly if multiple W transactions are broadcast for a single\n   unilateral close attempt, due to one or more watchtowers colluding\n   with an attacker, or simply having out of date information.\n\n * lack of layered transactions -- while this prevents you having to\n   wait longer than to_self_delay before you can claim channel funds,\n   it still means that any htlc that is going to timeout sooner than that\n   may not be claimable on-chain, meaning you need to set\n   cltv_expiry_delta >= to_self_delay.\n\n * extending to multiparty channels -- penalising is hard if there's\n   more than two parties, fast forwards are probably impossible since\n   you need multiple round-trips to coordinate signatures anyway, and if\n   you're doing channels-within-channels to reduce your n-party channel\n   to an easier to update 2-party channel you're probably forced to have\n   to_self_delay for each layer of channels. Also, just figuring out how\n   to coordinate multiparty state updates and even keeping everyone in\n   a multiparty channel online consistently to generate new signatures\n   seems potentially hard?\n\nCheers,\naj"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-08T19:14:06",
                "message_text_only": "Hi AJ,\n\nThe eltoo irc channel is ##eltoo on Libera chat.\n\n>  - 2022-10-21, eltoo/chia:\nhttps://twitter.com/bramcohen/status/1583122833932099585\n\nOn the eltoo/chia variant, from my (quick) understanding, the main\ninnovation aimed for is the limitation of the publication of eltoo states\nmore than once by a counterparty, by introducing a cryptographic puzzle,\nwhere the witness can be produced once and only once ? I would say you\nmight need the inheritance of the updated scriptpubkey across the chain of\neltoo states, with a TLUV-like mechanism.\n\n> The basic idea is \"if it's a two party channel with just Alice and Bob,\n> then if Alice starts a unilateral close, then she's already had her say,\n> so it's only Bob's opinion that matters from now on, and he should be\n> able to act immediately\", and once it's only Bob's opinion that matters,\n> you can simplify a bunch of things.\n\n>From my understanding, assuming Eltoo paper terminology, Alice can publish\nan update K transaction, and then after Bob can publish an update\ntransaction K<N or Alice can publish the settlement transaction N, or Bob\ncan publish an update transaction N. The main advantage of this\nconstruction I can see is a strict bound on the shared_delay encumbered in\nthe on-chain publication of the channel ?\n\n> fast forwards: we might want to allow our channel partner\n> to immediately rely on a new state we propose without needing a\n> round-trip delay -- this potentially makes forwarding payments much\n> faster (though with some risk of locking the funds up, if you do a\n> fast forward to someone who's gone offline)\n\nIIRC, there has already been a \"fast-forward\" protocol upgrade proposal\nbased on update-turn in the LN-penalty paradigm [0]. I think reducing the\nlatency of HTLC propagation across payment paths would constitute a UX\nimprovement, especially a link-level update mechanism upgrade deployment\nmight be incentivized by routing algorithms starting to penalize routing\nhops HTLC relay latency. What is unclear is the additional risk of locking\nthe funds up. If you don't receive acknowledgement the fast forward state\nhas been received, you should still be able to exit with the state N-1 ?\nHowever, the fast-forward trade-off might sound acceptable, with time you\nmight expect reliable routing hops in the core of the graph, and flappy\nspokes at the edge.\n\n> doubled delays: once we publish the latest state we can, we want to\n> be able to claim the funds immediately after to_self_delay expires;\n> however if our counterparty has signatures for a newer state than we\n> do (which will happen if it was fast forwarded), they could post that\n> state shortly before to_self_delay expires, potentially increasing\n> the total delay to 2*to_self_delay.\n\nWhile the 2*to_self_delay sounds the maximum time delay in the state\npublication scenario where the cheating counterparty publishes a old state\nthen the honest counterparty publishes the latest one, there could be the\ncase where the cheating counterparty broadcast chain of old states, up to\nmempool's `limitancestorcount`. However, this chain of eltoo transactions\ncould be replaced by the honest party paying a higher-feerate (assuming\nsomething like nversion=3). I think there might still be an attack\ntriggerable under certain economic conditions, where the attacker overbids\nwith the higher-feerate transaction until the HTLC cltv expires. If this\nattack is plausible, it could be even opportun if you're batching against\nmultiple channels, where the victims are not able to coordinate response.\n\n> penalties: when you do a unilateral close, attempting to cheat comes\n> with no cost to you and a possible benefit if you succeed, but\n> potentially does cost your channel partner (either in forcing them\n> to spend on-chain fees to update to the correct state, or in the risk\n> of loss if their node malfunctions occassionally) -- a penalty could\n> reduce this incentive to cheat\n\nI think there has been a proposal in the past to enable penalties on top of\nsymmetric states by leveraging asymmetric witnesses [1]. Further, I wonder\nif there is a game-theory interest for penalty-on-top-eltoo, it could be an\nincentive against laziness, where a dysfunctional trusted watchtower\nbroadcasts an old state. On the qualification of the game-theory soundness,\nI think one would have to run the empirical case study: select channel\ncounterparties randomly (no out-of-band assumptions), one set with\neltoo+penalty and the other with vanilla eltoo, observe the broadcast of\nrevoked states over some period.\n\n> trustless watchtowers: we may want to consider the possibility of a\n> watchtower holding onto obsolete states and colluding with an\n> attacker to attempt to cheat us\n\nIn terms of pinning and other mempool games, I think honest participant own\nstates leveraged by a colluding watchtower might increase the attack\nsurface, especially post-anchor with the SIGHASH_SINGLE malleability on\nsecond-stage HTLC transactions.\n\n> (I think for initial eltoo experimentation it doesn't make sense to try to\n> deal with all (or perhaps any) of those constraints; simple and working\n> is better than complex and theoretical. But having them written down so\n> the ideas can be thought about and looked up later still seems useful)\n\nI share the belief -- \"simple and working\" enable shorter iteration cycles\nand hopefully fasten the protocol design learning curve. Beyond, I think\nit's also realistic in face of the state of the LN ecosystem, especially on\nthe watchtower issue. AFAICT, there is no even multi trusted watchtower\ndesign covering the full execution of the protocol (i.e including\nHTLC-preimage/ HTLC-timeout claim), and such implementation is far from\nsimple, as from now on you LN's chain backend might have asynchronicity\nissue to solve between your on-chain monitoring state machine (at least\nspeaking in knowledge of the LDK-architecture).\n\n> * WA.n, WB.n : watchtower update to state n\n>   - this is for an untrusted watchtower to correct attempted cheating\n>     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n>     (or UA.k/WB.k) respectively, provided k < n.\n\nI wonder if the introduction of watchtower specific transactions doesn't\nbreak the 2*to_self_delay assumption (iiuc it's a design goal of current\nprotocol) and what is the design rationale. Beyond that, there is a concern\nwith watchtower-specific transactions, it might leak your towers topology\n(i.e the number of them and the distribution in the p2p network) to an\nadversary.\n\n> * SA.n, SB.n : slowly claim funds according to state n\n>   - this is for Alice to claim her funds if Bob is completely offline\n>     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n>     timelock of to_self_delay.\n\nIf I'm following correctly the description, this is logically equivalent to\nthe sweep of a `to_local`/`to_remote` output on a commitment transaction\nthough instead the waiting delay is eltoo shared_delay. There is no\nto_self_delay, at the punishment seems only to happen on the update-level,\nor maybe one should be also able to punish slow fund exit, and another\nrelative locktime should exist on the S* transactions.\n\n> * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n>\n>     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n\nCould the punishment transactions R* be also delegated to watchtowers,\nassuming they have been pre-signed to lockdown the exit scriptpubkeys ?\n\n> In order to allow fast-forwards, when Alice proposes a new state,\n> she needs to send her partial signatures to allow Bob to unilaterally\n> accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n> also needs to be able to claim the funds if Bob proposes the new state\n> and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n> achieved with an adaptor signature approach (spelt out a bit more fully\n> in the gist) or a CTV-like approach, provided that UB.n reveals the\n> state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n>\nhttps://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n).\n\nIf you would like to have fast forward of chain of transactions, I wonder\nif there could be also the \"sig-in-the-script\" trick, where UB.n\nscriptpubkey (or one of its tapscripts) contains the signature for CB.n,\nSB.n, RB.n. Though you might have an issue of re-generating the\nwitnessscript in case of state loss.\n\n> * how to add fees -- the U/W transactions are 1-in/1-out transactions\n>   that can't be trivially CPFPed by the proposer and need to have\n>   fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n>   ephemeral output and package relay might be workable); the C/S/R\n>   transactions are 1-in/many-out transactions, but have balance outputs\n>   that can be immediately spent to pay for fees via CPFP if package\n>   relay is available.\n\nAssuming something like nversion=3, the SINGLE/ANYONCANPAY could be a\nviable fee-bumping mechanism, as ancestor-based pinning should be less of a\nconcern. Ephemeral anchor output could be a more efficient direction, if\nthe output value can be cooperatively inflated from the channel value,\nrather than relying on external fee-bumping reserves. I think even more\nefficient fee-bumping primitives can be introduced later.\n\n> * how to pay watchtowers -- when a watchtower broadcasts a W\n>   transaction, it needs to add fees, and it's not clear (to me) how it\n>   could fairly and reliably ensure it's compensated for those costs,\n>   particularly if multiple W transactions are broadcast for a single\n>   unilateral close attempt, due to one or more watchtowers colluding\n>   with an attacker, or simply having out of date information.\n\nI wonder if paying a watchtower, or getting paid as a watchtower isn't  a\n\"counterparty risk\" similar to what is happening with jamming due to\nnon-covered HTLC forward risk. The watchtower has the risk of not being\npaid a posteriori and the user has the risk of the tower not acting. There\nis even a trade-off between tower costs and safety, as the more towers you\nhave, more robust if your Lightning channel (in theory, as you also have a\nduplication of the key material).\n\n> * lack of layered transactions -- while this prevents you having to\n>   wait longer than to_self_delay before you can claim channel funds,\n>   it still means that any htlc that is going to timeout sooner than that\n>   may not be claimable on-chain, meaning you need to set\n>   cltv_expiry_delta >= to_self_delay.\n\n>From a security perspective, offsetting the cltv_expiry_delta to a value\nsuperior to to_self_delay can be considered as an improvement, especially\nif it gradually does it network-wide. On the other hand, if routing\nalgorithms start to penalize long-cltv-delta payment paths as the timevalue\nof liquidity is priced in routing fees, this design rationale might not be\naligned with long-term LN network incentives (as of today even more\nloosely-defined than miner incentives).\n\n> * extending to multiparty channels -- penalising is hard if there's\n>   more than two parties, fast forwards are probably impossible since\n>   you need multiple round-trips to coordinate signatures anyway, and if\n>   you're doing channels-within-channels to reduce your n-party channel\n>   to an easier to update 2-party channel you're probably forced to have\n>   to_self_delay for each layer of channels. Also, just figuring out how\n>   to coordinate multiparty state updates and even keeping everyone in\n>   a multiparty channel online consistently to generate new signatures\n>   seems potentially hard?\n\nI don't know if penalising has been a solved issue for mulit-party, at\nleast in a trustless fashion in the same way we have with 2-party\nLN-penalty (you could devise weird scheme based on timelock, taproot tree\nand threshold signatures incentivizing towards the convergence of a\n\"consensus\" punishment, still...) Figuring out coordinating multi-party\nstates updates sounds workable with modern consensus algorithms (e.g Raft),\nthough still conserving the fast forward effect is a high bar, it might be\nbetter deferred to an uplifted layer of 2-of-2 LN channels. The only reason\nyou might have payments at the multi-party level (with the signature of the\nN-of-N participants requested) only for privacy or liquidity allocation\nreason. Though effectively, it sounds like your multiparty\nchannel coordination mechanism should encompass party eviction or\npartitioning the offline parties. One or two orders of magnitude of\ncomplexity beyond the 2-party eltoo channel case, I think.\n\nAntoine\n\n[0] https://github.com/lightning/bolts/pull/867\n[1] https://github.com/LLFourn/witness-asymmetric-channel\n\nLe mer. 7 d\u00e9c. 2022 \u00e0 00:36, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> Hi all,\n>\n> On the eltoo irc channel we discussed optimising eltoo for the 2-party\n> scenario; figured it was probably worth repeating that here.\n>\n> This is similar to:\n>\n>  - 2018-07-18, simplified eltoo:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001363.html\n>  - 2021-09-17, IID 2Stage,\n> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019470.html\n>  - 2022-09-29, Daric: https://eprint.iacr.org/2022/1295\n>  - 2022-10-21, eltoo/chia:\n> https://twitter.com/bramcohen/status/1583122833932099585\n>\n> The basic idea is \"if it's a two party channel with just Alice and Bob,\n> then if Alice starts a unilateral close, then she's already had her say,\n> so it's only Bob's opinion that matters from now on, and he should be\n> able to act immediately\", and once it's only Bob's opinion that matters,\n> you can simplify a bunch of things.\n>\n> A \"gist\" for this idea is\n> https://gist.github.com/ajtowns/53e0f735f4d5c06a681429d937200aa5 (it goes\n> into a little more detail in places, though doesn't cover trustless\n> watchtowers at all).\n>\n>\n>\n> In particular, there are a few practical constraints that we might like\n> to consider for 2-party channels with eltoo:\n>\n>  - fast forwards: we might want to allow our channel partner\n>    to immediately rely on a new state we propose without needing a\n>    round-trip delay -- this potentially makes forwarding payments much\n>    faster (though with some risk of locking the funds up, if you do a\n>    fast forward to someone who's gone offline)\n>\n>  - doubled delays: once we publish the latest state we can, we want to\n>    be able to claim the funds immediately after to_self_delay expires;\n>    however if our counterparty has signatures for a newer state than we\n>    do (which will happen if it was fast forwarded), they could post that\n>    state shortly before to_self_delay expires, potentially increasing\n>    the total delay to 2*to_self_delay.\n>\n>  - penalties: when you do a unilateral close, attempting to cheat comes\n>    with no cost to you and a possible benefit if you succeed, but\n>    potentially does cost your channel partner (either in forcing them\n>    to spend on-chain fees to update to the correct state, or in the risk\n>    of loss if their node malfunctions occassionally) -- a penalty could\n>    reduce this incentive to cheat\n>\n>  - trustless watchtowers: we may want to consider the possibility of a\n>    watchtower holding onto obsolete states and colluding with an\n>    attacker to attempt to cheat us\n>\n> What follows is a rough approach for dealing with all those issues for\n> two-party channels. It's spelled out in a little more detail in the gist.\n>\n> (I think for initial eltoo experimentation it doesn't make sense to try to\n> deal with all (or perhaps any) of those constraints; simple and working\n> is better than complex and theoretical. But having them written down so\n> the ideas can be thought about and looked up later still seems useful)\n>\n> In more detail: unilateral closes are handled by each channel participant\n> maintaining five transactions, which we'll call:\n>\n>  * UA.n, UB.n : unilaterally propose closing at state n\n>    - this is for Alice or Bob to spend the funding tx for a unilater\n>      close to state n. Spends the funding transaction.\n>\n>  * WA.n, WB.n : watchtower update to state n\n>    - this is for an untrusted watchtower to correct attempted cheating\n>      by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n>      (or UA.k/WB.k) respectively, provided k < n.\n>\n>  * CA.n, CB.n : cooperatively claim funds according to state n\n>    - this is for Alice to confirm Bob's unilateral close (or vice-versa).\n>      Spends UB.k, WA.k (or UA.k/WB.k respectively), provided k <= n\n>\n>  * SA.n, SB.n : slowly claim funds according to state n\n>    - this is for Alice to claim her funds if Bob is completely offline\n>      (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n>      timelock of to_self_delay.\n>\n>  * RA.n, RB.n : claim funds with penalty after unilateral close to\n>    revoked state\n>    - this is for Alice to update the state if Bob attempted to cheat\n>      (or vice-versa). Spends UB.k or WA.k (or UA.k/WB.k respectively)\n>      conditional on k < n - 1; outputs are adjusted to transfer a fixed\n>      penalty of penalty_msat from Bob's balance to Alice's (or vice-versa)\n>\n> Each of these \"transactions\" requires a pre-signed signature; however\n> the actual transaction/txid will vary in cases where a transaction has\n> the possibility of spending different inputs (eg \"Spends UB.k or WA.k\").\n> In particular UA.n/UB.n can be constructed with known txids and non-APO\n> signatures but WA.n/WB.n/CA.n/CB.n/SA.n/SB.n/RA.n/RB.n all require\n> APO signatures.\n>\n> They're named such that Alice can immediately broadcast all the *A.n\n> transactions (provided a tx that it can spend has been broadcast) and\n> Bob can likewise immediately broadcast all the *B.n transactions.\n>\n> Scenarios where Alice decides to unilaterally close the channel might\n> look like:\n>\n>  * if Alice/Bob can't communicate directly, but both are online:\n>\n>      F -> UA.n -> CB.n -> money\n>\n>    (balances and htlcs claimed, no delay)\n>\n>  * if Bob has gone offline entirely:\n>\n>      F -> UA.n -> (to_self_delay) -> SA.n -> money\n>\n>  * Alice cheats, Bob punishes:\n>\n>      F -> UA.k -> RB.n -> money[Alice pays Bob penalty]\n>\n>  * Bob is offline, Alice cheats, but Bob has a watchtower:\n>\n>      F -> UA.k -> WB.n -> (to_self_delay) -> SA.n -> money\n>\n>  * Alice and Bob's watchtower collude, but Bob's not offline:\n>\n>      F -> UA.k1 -> WB.k2 -> RB.n -> money[Alice pays Bob penalty]\n>\n>  * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n>\n>      F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n>\n> For Alice to successfully cheat, she needs Bob to be offline for at least\n> to_self_delay, and for all Bob's watchtowers to either also be offline,\n> or colluding.\n>\n> This can be simplified somewhat, if you don't care about all the features:\n>\n>  * If you don't care about trustless watchtowers you can drop WA.n/WB.n\n>    (and simplify SA.n/SB.n to not require an APO signature)\n>\n>  * If you don't care about penalties you can set penalty_msat to 0 and\n>    allow RA.n/RB.n to spend k<=n. In this case, you can either drop\n>    CA.n/CB.n entirely, or you can have CA.n/CB.n only be used for directly\n>    spending of UB.n/UA.n and thus not require APO signatures\n>\n> In order to allow fast-forwards, when Alice proposes a new state,\n> she needs to send her partial signatures to allow Bob to unilaterally\n> accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n> also needs to be able to claim the funds if Bob proposes the new state\n> and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n> achieved with an adaptor signature approach (spelt out a bit more fully\n> in the gist) or a CTV-like approach, provided that UB.n reveals the\n> state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n>\n> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n> ).\n>\n> Note that in this scenario Alice doesn't provide WB.n to Bob\n> immediately. This is okay, as if Alice proposes UA.(n-1) (her most\n> recent state), Bob can still immediately claim via CA.n. If Bob did have\n> WB.n; then if Alice proposed UA.(n-1) Bob could wait for an initial\n> to_self_delay period and broadcast WB.n, forcing Alice to wait for an\n> additional to_self_delay before being able to claim her funds via SA.n.\n>\n> Note also that this is why RA.n/RB.n require \"k < n - 1\" -- otherwise\n> Alice would only be able to broadcast UA.(n-1) and Bob would immediately\n> be able to penalise by broadcasting RB.n.\n>\n> Note that if you're using a watchtower and wish to punish your\n> counterparty if it attempts to cheat, you should only pass WA.(n-2)\n> to your watchtowers, not WA.(n-1) or WA.n.\n>\n>\n>\n> This doesn't address any potential issues from:\n>\n>  * how to add fees -- the U/W transactions are 1-in/1-out transactions\n>    that can't be trivially CPFPed by the proposer and need to have\n>    fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n>    ephemeral output and package relay might be workable); the C/S/R\n>    transactions are 1-in/many-out transactions, but have balance outputs\n>    that can be immediately spent to pay for fees via CPFP if package\n>    relay is available.\n>\n>  * how to pay watchtowers -- when a watchtower broadcasts a W\n>    transaction, it needs to add fees, and it's not clear (to me) how it\n>    could fairly and reliably ensure it's compensated for those costs,\n>    particularly if multiple W transactions are broadcast for a single\n>    unilateral close attempt, due to one or more watchtowers colluding\n>    with an attacker, or simply having out of date information.\n>\n>  * lack of layered transactions -- while this prevents you having to\n>    wait longer than to_self_delay before you can claim channel funds,\n>    it still means that any htlc that is going to timeout sooner than that\n>    may not be claimable on-chain, meaning you need to set\n>    cltv_expiry_delta >= to_self_delay.\n>\n>  * extending to multiparty channels -- penalising is hard if there's\n>    more than two parties, fast forwards are probably impossible since\n>    you need multiple round-trips to coordinate signatures anyway, and if\n>    you're doing channels-within-channels to reduce your n-party channel\n>    to an easier to update 2-party channel you're probably forced to have\n>    to_self_delay for each layer of channels. Also, just figuring out how\n>    to coordinate multiparty state updates and even keeping everyone in\n>    a multiparty channel online consistently to generate new signatures\n>    seems potentially hard?\n>\n> Cheers,\n> aj\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/6ba33096/attachment-0001.html>"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-12-08T20:28:11",
                "message_text_only": "Antoine,\n\n> While the 2*to_self_delay sounds the maximum time delay in the state\npublication scenario where the cheating counterparty publishes a old state\nthen the honest counterparty publishes the latest one, there could be the\ncase where the cheating counterparty broadcast chain of old states, up to\nmempool's `limitancestorcount`. However, this chain of eltoo transactions\ncould be replaced by the honest party paying a higher-feerate (assuming\nsomething like nversion=3). I think there might still be an attack\ntriggerable under certain economic conditions, where the attacker overbids\nwith the higher-feerate transaction until the HTLC cltv expires. If this\nattack is plausible, it could be even opportun if you're batching against\nmultiple channels, where the victims are not able to coordinate response.\n\nFeel free to assume that we've worked around mempool pinning for all of\nthese discussions, otherwise we're pretty hosed regardless. I'm implicitly\nassuming V3+ephemeral anchors, which disallows batched bumps, for example.\nYou'll need to give some room for \"slippage\", but I think\nshared_delay/2*shared_delay is going to end up dominating UX in any\nnon-layered scheme.\n\n> I wonder if the introduction of watchtower specific transactions doesn't\nbreak the 2*to_self_delay assumption\n\nThis architecture doesn't suffer from 2*self_delay, and each transition\naside from Slow/Settle/SX.y has no relative timelock so that relative\ntimelock is all that matters. It does introduce a watchtower cycle, so it's\nnot longer a one-shot architecture, or even k-shot exactly, it ends up\nlooking like vanilla eltoo for that single path.\n\nCheers,\nGreg\n\nOn Thu, Dec 8, 2022 at 2:14 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi AJ,\n>\n> The eltoo irc channel is ##eltoo on Libera chat.\n>\n> >  - 2022-10-21, eltoo/chia:\n> https://twitter.com/bramcohen/status/1583122833932099585\n>\n> On the eltoo/chia variant, from my (quick) understanding, the main\n> innovation aimed for is the limitation of the publication of eltoo states\n> more than once by a counterparty, by introducing a cryptographic puzzle,\n> where the witness can be produced once and only once ? I would say you\n> might need the inheritance of the updated scriptpubkey across the chain of\n> eltoo states, with a TLUV-like mechanism.\n>\n> > The basic idea is \"if it's a two party channel with just Alice and Bob,\n> > then if Alice starts a unilateral close, then she's already had her say,\n> > so it's only Bob's opinion that matters from now on, and he should be\n> > able to act immediately\", and once it's only Bob's opinion that matters,\n> > you can simplify a bunch of things.\n>\n> From my understanding, assuming Eltoo paper terminology, Alice can publish\n> an update K transaction, and then after Bob can publish an update\n> transaction K<N or Alice can publish the settlement transaction N, or Bob\n> can publish an update transaction N. The main advantage of this\n> construction I can see is a strict bound on the shared_delay encumbered in\n> the on-chain publication of the channel ?\n>\n> > fast forwards: we might want to allow our channel partner\n> > to immediately rely on a new state we propose without needing a\n> > round-trip delay -- this potentially makes forwarding payments much\n> > faster (though with some risk of locking the funds up, if you do a\n> > fast forward to someone who's gone offline)\n>\n> IIRC, there has already been a \"fast-forward\" protocol upgrade proposal\n> based on update-turn in the LN-penalty paradigm [0]. I think reducing the\n> latency of HTLC propagation across payment paths would constitute a UX\n> improvement, especially a link-level update mechanism upgrade deployment\n> might be incentivized by routing algorithms starting to penalize routing\n> hops HTLC relay latency. What is unclear is the additional risk of locking\n> the funds up. If you don't receive acknowledgement the fast forward state\n> has been received, you should still be able to exit with the state N-1 ?\n> However, the fast-forward trade-off might sound acceptable, with time you\n> might expect reliable routing hops in the core of the graph, and flappy\n> spokes at the edge.\n>\n> > doubled delays: once we publish the latest state we can, we want to\n> > be able to claim the funds immediately after to_self_delay expires;\n> > however if our counterparty has signatures for a newer state than we\n> > do (which will happen if it was fast forwarded), they could post that\n> > state shortly before to_self_delay expires, potentially increasing\n> > the total delay to 2*to_self_delay.\n>\n> While the 2*to_self_delay sounds the maximum time delay in the state\n> publication scenario where the cheating counterparty publishes a old state\n> then the honest counterparty publishes the latest one, there could be the\n> case where the cheating counterparty broadcast chain of old states, up to\n> mempool's `limitancestorcount`. However, this chain of eltoo transactions\n> could be replaced by the honest party paying a higher-feerate (assuming\n> something like nversion=3). I think there might still be an attack\n> triggerable under certain economic conditions, where the attacker overbids\n> with the higher-feerate transaction until the HTLC cltv expires. If this\n> attack is plausible, it could be even opportun if you're batching against\n> multiple channels, where the victims are not able to coordinate response.\n>\n> > penalties: when you do a unilateral close, attempting to cheat comes\n> > with no cost to you and a possible benefit if you succeed, but\n> > potentially does cost your channel partner (either in forcing them\n> > to spend on-chain fees to update to the correct state, or in the risk\n> > of loss if their node malfunctions occassionally) -- a penalty could\n> > reduce this incentive to cheat\n>\n> I think there has been a proposal in the past to enable penalties on top\n> of symmetric states by leveraging asymmetric witnesses [1]. Further, I\n> wonder if there is a game-theory interest for penalty-on-top-eltoo, it\n> could be an incentive against laziness, where a dysfunctional trusted\n> watchtower broadcasts an old state. On the qualification of the game-theory\n> soundness, I think one would have to run the empirical case study: select\n> channel counterparties randomly (no out-of-band assumptions), one set with\n> eltoo+penalty and the other with vanilla eltoo, observe the broadcast of\n> revoked states over some period.\n>\n> > trustless watchtowers: we may want to consider the possibility of a\n> > watchtower holding onto obsolete states and colluding with an\n> > attacker to attempt to cheat us\n>\n> In terms of pinning and other mempool games, I think honest participant\n> own states leveraged by a colluding watchtower might increase the attack\n> surface, especially post-anchor with the SIGHASH_SINGLE malleability on\n> second-stage HTLC transactions.\n>\n> > (I think for initial eltoo experimentation it doesn't make sense to try\n> to\n> > deal with all (or perhaps any) of those constraints; simple and working\n> > is better than complex and theoretical. But having them written down so\n> > the ideas can be thought about and looked up later still seems useful)\n>\n> I share the belief -- \"simple and working\" enable shorter iteration cycles\n> and hopefully fasten the protocol design learning curve. Beyond, I think\n> it's also realistic in face of the state of the LN ecosystem, especially on\n> the watchtower issue. AFAICT, there is no even multi trusted watchtower\n> design covering the full execution of the protocol (i.e including\n> HTLC-preimage/ HTLC-timeout claim), and such implementation is far from\n> simple, as from now on you LN's chain backend might have asynchronicity\n> issue to solve between your on-chain monitoring state machine (at least\n> speaking in knowledge of the LDK-architecture).\n>\n> > * WA.n, WB.n : watchtower update to state n\n> >   - this is for an untrusted watchtower to correct attempted cheating\n> >     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n> >     (or UA.k/WB.k) respectively, provided k < n.\n>\n> I wonder if the introduction of watchtower specific transactions doesn't\n> break the 2*to_self_delay assumption (iiuc it's a design goal of current\n> protocol) and what is the design rationale. Beyond that, there is a concern\n> with watchtower-specific transactions, it might leak your towers topology\n> (i.e the number of them and the distribution in the p2p network) to an\n> adversary.\n>\n> > * SA.n, SB.n : slowly claim funds according to state n\n> >   - this is for Alice to claim her funds if Bob is completely offline\n> >     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n> >     timelock of to_self_delay.\n>\n> If I'm following correctly the description, this is logically equivalent\n> to the sweep of a `to_local`/`to_remote` output on a commitment transaction\n> though instead the waiting delay is eltoo shared_delay. There is no\n> to_self_delay, at the punishment seems only to happen on the update-level,\n> or maybe one should be also able to punish slow fund exit, and another\n> relative locktime should exist on the S* transactions.\n>\n> > * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n> >\n> >     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n>\n> Could the punishment transactions R* be also delegated to watchtowers,\n> assuming they have been pre-signed to lockdown the exit scriptpubkeys ?\n>\n> > In order to allow fast-forwards, when Alice proposes a new state,\n> > she needs to send her partial signatures to allow Bob to unilaterally\n> > accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n> > also needs to be able to claim the funds if Bob proposes the new state\n> > and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n> > achieved with an adaptor signature approach (spelt out a bit more fully\n> > in the gist) or a CTV-like approach, provided that UB.n reveals the\n> > state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n> >\n> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n> ).\n>\n> If you would like to have fast forward of chain of transactions, I wonder\n> if there could be also the \"sig-in-the-script\" trick, where UB.n\n> scriptpubkey (or one of its tapscripts) contains the signature for CB.n,\n> SB.n, RB.n. Though you might have an issue of re-generating the\n> witnessscript in case of state loss.\n>\n> > * how to add fees -- the U/W transactions are 1-in/1-out transactions\n> >   that can't be trivially CPFPed by the proposer and need to have\n> >   fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n> >   ephemeral output and package relay might be workable); the C/S/R\n> >   transactions are 1-in/many-out transactions, but have balance outputs\n> >   that can be immediately spent to pay for fees via CPFP if package\n> >   relay is available.\n>\n> Assuming something like nversion=3, the SINGLE/ANYONCANPAY could be a\n> viable fee-bumping mechanism, as ancestor-based pinning should be less of a\n> concern. Ephemeral anchor output could be a more efficient direction, if\n> the output value can be cooperatively inflated from the channel value,\n> rather than relying on external fee-bumping reserves. I think even more\n> efficient fee-bumping primitives can be introduced later.\n>\n> > * how to pay watchtowers -- when a watchtower broadcasts a W\n> >   transaction, it needs to add fees, and it's not clear (to me) how it\n> >   could fairly and reliably ensure it's compensated for those costs,\n> >   particularly if multiple W transactions are broadcast for a single\n> >   unilateral close attempt, due to one or more watchtowers colluding\n> >   with an attacker, or simply having out of date information.\n>\n> I wonder if paying a watchtower, or getting paid as a watchtower isn't  a\n> \"counterparty risk\" similar to what is happening with jamming due to\n> non-covered HTLC forward risk. The watchtower has the risk of not being\n> paid a posteriori and the user has the risk of the tower not acting. There\n> is even a trade-off between tower costs and safety, as the more towers you\n> have, more robust if your Lightning channel (in theory, as you also have a\n> duplication of the key material).\n>\n> > * lack of layered transactions -- while this prevents you having to\n> >   wait longer than to_self_delay before you can claim channel funds,\n> >   it still means that any htlc that is going to timeout sooner than that\n> >   may not be claimable on-chain, meaning you need to set\n> >   cltv_expiry_delta >= to_self_delay.\n>\n> From a security perspective, offsetting the cltv_expiry_delta to a value\n> superior to to_self_delay can be considered as an improvement, especially\n> if it gradually does it network-wide. On the other hand, if routing\n> algorithms start to penalize long-cltv-delta payment paths as the timevalue\n> of liquidity is priced in routing fees, this design rationale might not be\n> aligned with long-term LN network incentives (as of today even more\n> loosely-defined than miner incentives).\n>\n> > * extending to multiparty channels -- penalising is hard if there's\n> >   more than two parties, fast forwards are probably impossible since\n> >   you need multiple round-trips to coordinate signatures anyway, and if\n> >   you're doing channels-within-channels to reduce your n-party channel\n> >   to an easier to update 2-party channel you're probably forced to have\n> >   to_self_delay for each layer of channels. Also, just figuring out how\n> >   to coordinate multiparty state updates and even keeping everyone in\n> >   a multiparty channel online consistently to generate new signatures\n> >   seems potentially hard?\n>\n> I don't know if penalising has been a solved issue for mulit-party, at\n> least in a trustless fashion in the same way we have with 2-party\n> LN-penalty (you could devise weird scheme based on timelock, taproot tree\n> and threshold signatures incentivizing towards the convergence of a\n> \"consensus\" punishment, still...) Figuring out coordinating multi-party\n> states updates sounds workable with modern consensus algorithms (e.g Raft),\n> though still conserving the fast forward effect is a high bar, it might be\n> better deferred to an uplifted layer of 2-of-2 LN channels. The only reason\n> you might have payments at the multi-party level (with the signature of the\n> N-of-N participants requested) only for privacy or liquidity allocation\n> reason. Though effectively, it sounds like your multiparty\n> channel coordination mechanism should encompass party eviction or\n> partitioning the offline parties. One or two orders of magnitude of\n> complexity beyond the 2-party eltoo channel case, I think.\n>\n> Antoine\n>\n> [0] https://github.com/lightning/bolts/pull/867\n> [1] https://github.com/LLFourn/witness-asymmetric-channel\n>\n> Le mer. 7 d\u00e9c. 2022 \u00e0 00:36, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n>\n>> Hi all,\n>>\n>> On the eltoo irc channel we discussed optimising eltoo for the 2-party\n>> scenario; figured it was probably worth repeating that here.\n>>\n>> This is similar to:\n>>\n>>  - 2018-07-18, simplified eltoo:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001363.html\n>>  - 2021-09-17, IID 2Stage,\n>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019470.html\n>>  - 2022-09-29, Daric: https://eprint.iacr.org/2022/1295\n>>  - 2022-10-21, eltoo/chia:\n>> https://twitter.com/bramcohen/status/1583122833932099585\n>>\n>> The basic idea is \"if it's a two party channel with just Alice and Bob,\n>> then if Alice starts a unilateral close, then she's already had her say,\n>> so it's only Bob's opinion that matters from now on, and he should be\n>> able to act immediately\", and once it's only Bob's opinion that matters,\n>> you can simplify a bunch of things.\n>>\n>> A \"gist\" for this idea is\n>> https://gist.github.com/ajtowns/53e0f735f4d5c06a681429d937200aa5 (it\n>> goes into a little more detail in places, though doesn't cover trustless\n>> watchtowers at all).\n>>\n>>\n>>\n>> In particular, there are a few practical constraints that we might like\n>> to consider for 2-party channels with eltoo:\n>>\n>>  - fast forwards: we might want to allow our channel partner\n>>    to immediately rely on a new state we propose without needing a\n>>    round-trip delay -- this potentially makes forwarding payments much\n>>    faster (though with some risk of locking the funds up, if you do a\n>>    fast forward to someone who's gone offline)\n>>\n>>  - doubled delays: once we publish the latest state we can, we want to\n>>    be able to claim the funds immediately after to_self_delay expires;\n>>    however if our counterparty has signatures for a newer state than we\n>>    do (which will happen if it was fast forwarded), they could post that\n>>    state shortly before to_self_delay expires, potentially increasing\n>>    the total delay to 2*to_self_delay.\n>>\n>>  - penalties: when you do a unilateral close, attempting to cheat comes\n>>    with no cost to you and a possible benefit if you succeed, but\n>>    potentially does cost your channel partner (either in forcing them\n>>    to spend on-chain fees to update to the correct state, or in the risk\n>>    of loss if their node malfunctions occassionally) -- a penalty could\n>>    reduce this incentive to cheat\n>>\n>>  - trustless watchtowers: we may want to consider the possibility of a\n>>    watchtower holding onto obsolete states and colluding with an\n>>    attacker to attempt to cheat us\n>>\n>> What follows is a rough approach for dealing with all those issues for\n>> two-party channels. It's spelled out in a little more detail in the gist.\n>>\n>> (I think for initial eltoo experimentation it doesn't make sense to try to\n>> deal with all (or perhaps any) of those constraints; simple and working\n>> is better than complex and theoretical. But having them written down so\n>> the ideas can be thought about and looked up later still seems useful)\n>>\n>> In more detail: unilateral closes are handled by each channel participant\n>> maintaining five transactions, which we'll call:\n>>\n>>  * UA.n, UB.n : unilaterally propose closing at state n\n>>    - this is for Alice or Bob to spend the funding tx for a unilater\n>>      close to state n. Spends the funding transaction.\n>>\n>>  * WA.n, WB.n : watchtower update to state n\n>>    - this is for an untrusted watchtower to correct attempted cheating\n>>      by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n>>      (or UA.k/WB.k) respectively, provided k < n.\n>>\n>>  * CA.n, CB.n : cooperatively claim funds according to state n\n>>    - this is for Alice to confirm Bob's unilateral close (or vice-versa).\n>>      Spends UB.k, WA.k (or UA.k/WB.k respectively), provided k <= n\n>>\n>>  * SA.n, SB.n : slowly claim funds according to state n\n>>    - this is for Alice to claim her funds if Bob is completely offline\n>>      (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n>>      timelock of to_self_delay.\n>>\n>>  * RA.n, RB.n : claim funds with penalty after unilateral close to\n>>    revoked state\n>>    - this is for Alice to update the state if Bob attempted to cheat\n>>      (or vice-versa). Spends UB.k or WA.k (or UA.k/WB.k respectively)\n>>      conditional on k < n - 1; outputs are adjusted to transfer a fixed\n>>      penalty of penalty_msat from Bob's balance to Alice's (or vice-versa)\n>>\n>> Each of these \"transactions\" requires a pre-signed signature; however\n>> the actual transaction/txid will vary in cases where a transaction has\n>> the possibility of spending different inputs (eg \"Spends UB.k or WA.k\").\n>> In particular UA.n/UB.n can be constructed with known txids and non-APO\n>> signatures but WA.n/WB.n/CA.n/CB.n/SA.n/SB.n/RA.n/RB.n all require\n>> APO signatures.\n>>\n>> They're named such that Alice can immediately broadcast all the *A.n\n>> transactions (provided a tx that it can spend has been broadcast) and\n>> Bob can likewise immediately broadcast all the *B.n transactions.\n>>\n>> Scenarios where Alice decides to unilaterally close the channel might\n>> look like:\n>>\n>>  * if Alice/Bob can't communicate directly, but both are online:\n>>\n>>      F -> UA.n -> CB.n -> money\n>>\n>>    (balances and htlcs claimed, no delay)\n>>\n>>  * if Bob has gone offline entirely:\n>>\n>>      F -> UA.n -> (to_self_delay) -> SA.n -> money\n>>\n>>  * Alice cheats, Bob punishes:\n>>\n>>      F -> UA.k -> RB.n -> money[Alice pays Bob penalty]\n>>\n>>  * Bob is offline, Alice cheats, but Bob has a watchtower:\n>>\n>>      F -> UA.k -> WB.n -> (to_self_delay) -> SA.n -> money\n>>\n>>  * Alice and Bob's watchtower collude, but Bob's not offline:\n>>\n>>      F -> UA.k1 -> WB.k2 -> RB.n -> money[Alice pays Bob penalty]\n>>\n>>  * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n>>\n>>      F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n>>\n>> For Alice to successfully cheat, she needs Bob to be offline for at least\n>> to_self_delay, and for all Bob's watchtowers to either also be offline,\n>> or colluding.\n>>\n>> This can be simplified somewhat, if you don't care about all the features:\n>>\n>>  * If you don't care about trustless watchtowers you can drop WA.n/WB.n\n>>    (and simplify SA.n/SB.n to not require an APO signature)\n>>\n>>  * If you don't care about penalties you can set penalty_msat to 0 and\n>>    allow RA.n/RB.n to spend k<=n. In this case, you can either drop\n>>    CA.n/CB.n entirely, or you can have CA.n/CB.n only be used for directly\n>>    spending of UB.n/UA.n and thus not require APO signatures\n>>\n>> In order to allow fast-forwards, when Alice proposes a new state,\n>> she needs to send her partial signatures to allow Bob to unilaterally\n>> accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n>> also needs to be able to claim the funds if Bob proposes the new state\n>> and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n>> achieved with an adaptor signature approach (spelt out a bit more fully\n>> in the gist) or a CTV-like approach, provided that UB.n reveals the\n>> state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n>>\n>> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n>> ).\n>>\n>> Note that in this scenario Alice doesn't provide WB.n to Bob\n>> immediately. This is okay, as if Alice proposes UA.(n-1) (her most\n>> recent state), Bob can still immediately claim via CA.n. If Bob did have\n>> WB.n; then if Alice proposed UA.(n-1) Bob could wait for an initial\n>> to_self_delay period and broadcast WB.n, forcing Alice to wait for an\n>> additional to_self_delay before being able to claim her funds via SA.n.\n>>\n>> Note also that this is why RA.n/RB.n require \"k < n - 1\" -- otherwise\n>> Alice would only be able to broadcast UA.(n-1) and Bob would immediately\n>> be able to penalise by broadcasting RB.n.\n>>\n>> Note that if you're using a watchtower and wish to punish your\n>> counterparty if it attempts to cheat, you should only pass WA.(n-2)\n>> to your watchtowers, not WA.(n-1) or WA.n.\n>>\n>>\n>>\n>> This doesn't address any potential issues from:\n>>\n>>  * how to add fees -- the U/W transactions are 1-in/1-out transactions\n>>    that can't be trivially CPFPed by the proposer and need to have\n>>    fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n>>    ephemeral output and package relay might be workable); the C/S/R\n>>    transactions are 1-in/many-out transactions, but have balance outputs\n>>    that can be immediately spent to pay for fees via CPFP if package\n>>    relay is available.\n>>\n>>  * how to pay watchtowers -- when a watchtower broadcasts a W\n>>    transaction, it needs to add fees, and it's not clear (to me) how it\n>>    could fairly and reliably ensure it's compensated for those costs,\n>>    particularly if multiple W transactions are broadcast for a single\n>>    unilateral close attempt, due to one or more watchtowers colluding\n>>    with an attacker, or simply having out of date information.\n>>\n>>  * lack of layered transactions -- while this prevents you having to\n>>    wait longer than to_self_delay before you can claim channel funds,\n>>    it still means that any htlc that is going to timeout sooner than that\n>>    may not be claimable on-chain, meaning you need to set\n>>    cltv_expiry_delta >= to_self_delay.\n>>\n>>  * extending to multiparty channels -- penalising is hard if there's\n>>    more than two parties, fast forwards are probably impossible since\n>>    you need multiple round-trips to coordinate signatures anyway, and if\n>>    you're doing channels-within-channels to reduce your n-party channel\n>>    to an easier to update 2-party channel you're probably forced to have\n>>    to_self_delay for each layer of channels. Also, just figuring out how\n>>    to coordinate multiparty state updates and even keeping everyone in\n>>    a multiparty channel online consistently to generate new signatures\n>>    seems potentially hard?\n>>\n>> Cheers,\n>> aj\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/78e37af8/attachment-0001.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-13T01:55:43",
                "message_text_only": "Hi Greg,\n\n> Feel free to assume that we've worked around mempool pinning for all of\n> these discussions, otherwise we're pretty hosed regardless. I'm implicitly\n> assuming V3+ephemeral anchors, which disallows batched bumps, for example.\n> You'll need to give some room for \"slippage\", but I think\n> shared_delay/2*shared_delay is going to end up dominating UX in any\n> non-layered scheme.\n\nI think I was making the same assumption of V3+ephemeral anchors, and\neffectively disabling batching removes the known case of \"commitment\ncat-and-mouse\" attack, where a counterparty goes to confirm the commitment\none by one to break the validity of the common CPFP. However, I wonder if\nthere is not another attack case, see my other \"update overflow\" mail, and\nI don't think it qualifies as a pinning here!\n\n> This architecture doesn't suffer from 2*self_delay, and each transition\n> aside from Slow/Settle/SX.y has no relative timelock so that relative\n> timelock is all that matters. It does introduce a watchtower cycle, so\nit's\n> not longer a one-shot architecture, or even k-shot exactly, it ends up\n> looking like vanilla eltoo for that single path.\n\nHere I think my understanding is aligned, the watchtower cycle ends up\nlooking more like the update phase of vanilla eltoo.\n\nAntoine\n\nLe jeu. 8 d\u00e9c. 2022 \u00e0 15:28, Greg Sanders <gsanders87 at gmail.com> a \u00e9crit :\n\n> Antoine,\n>\n> > While the 2*to_self_delay sounds the maximum time delay in the state\n> publication scenario where the cheating counterparty publishes a old state\n> then the honest counterparty publishes the latest one, there could be the\n> case where the cheating counterparty broadcast chain of old states, up to\n> mempool's `limitancestorcount`. However, this chain of eltoo transactions\n> could be replaced by the honest party paying a higher-feerate (assuming\n> something like nversion=3). I think there might still be an attack\n> triggerable under certain economic conditions, where the attacker overbids\n> with the higher-feerate transaction until the HTLC cltv expires. If this\n> attack is plausible, it could be even opportun if you're batching against\n> multiple channels, where the victims are not able to coordinate response.\n>\n> Feel free to assume that we've worked around mempool pinning for all of\n> these discussions, otherwise we're pretty hosed regardless. I'm implicitly\n> assuming V3+ephemeral anchors, which disallows batched bumps, for example.\n> You'll need to give some room for \"slippage\", but I think\n> shared_delay/2*shared_delay is going to end up dominating UX in any\n> non-layered scheme.\n>\n> > I wonder if the introduction of watchtower specific transactions doesn't\n> break the 2*to_self_delay assumption\n>\n> This architecture doesn't suffer from 2*self_delay, and each transition\n> aside from Slow/Settle/SX.y has no relative timelock so that relative\n> timelock is all that matters. It does introduce a watchtower cycle, so it's\n> not longer a one-shot architecture, or even k-shot exactly, it ends up\n> looking like vanilla eltoo for that single path.\n>\n> Cheers,\n> Greg\n>\n> On Thu, Dec 8, 2022 at 2:14 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi AJ,\n>>\n>> The eltoo irc channel is ##eltoo on Libera chat.\n>>\n>> >  - 2022-10-21, eltoo/chia:\n>> https://twitter.com/bramcohen/status/1583122833932099585\n>>\n>> On the eltoo/chia variant, from my (quick) understanding, the main\n>> innovation aimed for is the limitation of the publication of eltoo states\n>> more than once by a counterparty, by introducing a cryptographic puzzle,\n>> where the witness can be produced once and only once ? I would say you\n>> might need the inheritance of the updated scriptpubkey across the chain of\n>> eltoo states, with a TLUV-like mechanism.\n>>\n>> > The basic idea is \"if it's a two party channel with just Alice and Bob,\n>> > then if Alice starts a unilateral close, then she's already had her say,\n>> > so it's only Bob's opinion that matters from now on, and he should be\n>> > able to act immediately\", and once it's only Bob's opinion that matters,\n>> > you can simplify a bunch of things.\n>>\n>> From my understanding, assuming Eltoo paper terminology, Alice can\n>> publish an update K transaction, and then after Bob can publish an update\n>> transaction K<N or Alice can publish the settlement transaction N, or Bob\n>> can publish an update transaction N. The main advantage of this\n>> construction I can see is a strict bound on the shared_delay encumbered in\n>> the on-chain publication of the channel ?\n>>\n>> > fast forwards: we might want to allow our channel partner\n>> > to immediately rely on a new state we propose without needing a\n>> > round-trip delay -- this potentially makes forwarding payments much\n>> > faster (though with some risk of locking the funds up, if you do a\n>> > fast forward to someone who's gone offline)\n>>\n>> IIRC, there has already been a \"fast-forward\" protocol upgrade proposal\n>> based on update-turn in the LN-penalty paradigm [0]. I think reducing the\n>> latency of HTLC propagation across payment paths would constitute a UX\n>> improvement, especially a link-level update mechanism upgrade deployment\n>> might be incentivized by routing algorithms starting to penalize routing\n>> hops HTLC relay latency. What is unclear is the additional risk of locking\n>> the funds up. If you don't receive acknowledgement the fast forward state\n>> has been received, you should still be able to exit with the state N-1 ?\n>> However, the fast-forward trade-off might sound acceptable, with time you\n>> might expect reliable routing hops in the core of the graph, and flappy\n>> spokes at the edge.\n>>\n>> > doubled delays: once we publish the latest state we can, we want to\n>> > be able to claim the funds immediately after to_self_delay expires;\n>> > however if our counterparty has signatures for a newer state than we\n>> > do (which will happen if it was fast forwarded), they could post that\n>> > state shortly before to_self_delay expires, potentially increasing\n>> > the total delay to 2*to_self_delay.\n>>\n>> While the 2*to_self_delay sounds the maximum time delay in the state\n>> publication scenario where the cheating counterparty publishes a old state\n>> then the honest counterparty publishes the latest one, there could be the\n>> case where the cheating counterparty broadcast chain of old states, up to\n>> mempool's `limitancestorcount`. However, this chain of eltoo transactions\n>> could be replaced by the honest party paying a higher-feerate (assuming\n>> something like nversion=3). I think there might still be an attack\n>> triggerable under certain economic conditions, where the attacker overbids\n>> with the higher-feerate transaction until the HTLC cltv expires. If this\n>> attack is plausible, it could be even opportun if you're batching against\n>> multiple channels, where the victims are not able to coordinate response.\n>>\n>> > penalties: when you do a unilateral close, attempting to cheat comes\n>> > with no cost to you and a possible benefit if you succeed, but\n>> > potentially does cost your channel partner (either in forcing them\n>> > to spend on-chain fees to update to the correct state, or in the risk\n>> > of loss if their node malfunctions occassionally) -- a penalty could\n>> > reduce this incentive to cheat\n>>\n>> I think there has been a proposal in the past to enable penalties on top\n>> of symmetric states by leveraging asymmetric witnesses [1]. Further, I\n>> wonder if there is a game-theory interest for penalty-on-top-eltoo, it\n>> could be an incentive against laziness, where a dysfunctional trusted\n>> watchtower broadcasts an old state. On the qualification of the game-theory\n>> soundness, I think one would have to run the empirical case study: select\n>> channel counterparties randomly (no out-of-band assumptions), one set with\n>> eltoo+penalty and the other with vanilla eltoo, observe the broadcast of\n>> revoked states over some period.\n>>\n>> > trustless watchtowers: we may want to consider the possibility of a\n>> > watchtower holding onto obsolete states and colluding with an\n>> > attacker to attempt to cheat us\n>>\n>> In terms of pinning and other mempool games, I think honest participant\n>> own states leveraged by a colluding watchtower might increase the attack\n>> surface, especially post-anchor with the SIGHASH_SINGLE malleability on\n>> second-stage HTLC transactions.\n>>\n>> > (I think for initial eltoo experimentation it doesn't make sense to try\n>> to\n>> > deal with all (or perhaps any) of those constraints; simple and working\n>> > is better than complex and theoretical. But having them written down so\n>> > the ideas can be thought about and looked up later still seems useful)\n>>\n>> I share the belief -- \"simple and working\" enable shorter iteration\n>> cycles and hopefully fasten the protocol design learning curve. Beyond, I\n>> think it's also realistic in face of the state of the LN ecosystem,\n>> especially on the watchtower issue. AFAICT, there is no even multi trusted\n>> watchtower design covering the full execution of the protocol (i.e\n>> including HTLC-preimage/ HTLC-timeout claim), and such implementation is\n>> far from simple, as from now on you LN's chain backend might have\n>> asynchronicity issue to solve between your on-chain monitoring state\n>> machine (at least speaking in knowledge of the LDK-architecture).\n>>\n>> > * WA.n, WB.n : watchtower update to state n\n>> >   - this is for an untrusted watchtower to correct attempted cheating\n>> >     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n>> >     (or UA.k/WB.k) respectively, provided k < n.\n>>\n>> I wonder if the introduction of watchtower specific transactions doesn't\n>> break the 2*to_self_delay assumption (iiuc it's a design goal of current\n>> protocol) and what is the design rationale. Beyond that, there is a concern\n>> with watchtower-specific transactions, it might leak your towers topology\n>> (i.e the number of them and the distribution in the p2p network) to an\n>> adversary.\n>>\n>> > * SA.n, SB.n : slowly claim funds according to state n\n>> >   - this is for Alice to claim her funds if Bob is completely offline\n>> >     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n>> >     timelock of to_self_delay.\n>>\n>> If I'm following correctly the description, this is logically equivalent\n>> to the sweep of a `to_local`/`to_remote` output on a commitment transaction\n>> though instead the waiting delay is eltoo shared_delay. There is no\n>> to_self_delay, at the punishment seems only to happen on the update-level,\n>> or maybe one should be also able to punish slow fund exit, and another\n>> relative locktime should exist on the S* transactions.\n>>\n>> > * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n>> >\n>> >     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n>>\n>> Could the punishment transactions R* be also delegated to watchtowers,\n>> assuming they have been pre-signed to lockdown the exit scriptpubkeys ?\n>>\n>> > In order to allow fast-forwards, when Alice proposes a new state,\n>> > she needs to send her partial signatures to allow Bob to unilaterally\n>> > accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n>> > also needs to be able to claim the funds if Bob proposes the new state\n>> > and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n>> > achieved with an adaptor signature approach (spelt out a bit more fully\n>> > in the gist) or a CTV-like approach, provided that UB.n reveals the\n>> > state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n>> >\n>> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n>> ).\n>>\n>> If you would like to have fast forward of chain of transactions, I wonder\n>> if there could be also the \"sig-in-the-script\" trick, where UB.n\n>> scriptpubkey (or one of its tapscripts) contains the signature for CB.n,\n>> SB.n, RB.n. Though you might have an issue of re-generating the\n>> witnessscript in case of state loss.\n>>\n>> > * how to add fees -- the U/W transactions are 1-in/1-out transactions\n>> >   that can't be trivially CPFPed by the proposer and need to have\n>> >   fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n>> >   ephemeral output and package relay might be workable); the C/S/R\n>> >   transactions are 1-in/many-out transactions, but have balance outputs\n>> >   that can be immediately spent to pay for fees via CPFP if package\n>> >   relay is available.\n>>\n>> Assuming something like nversion=3, the SINGLE/ANYONCANPAY could be a\n>> viable fee-bumping mechanism, as ancestor-based pinning should be less of a\n>> concern. Ephemeral anchor output could be a more efficient direction, if\n>> the output value can be cooperatively inflated from the channel value,\n>> rather than relying on external fee-bumping reserves. I think even more\n>> efficient fee-bumping primitives can be introduced later.\n>>\n>> > * how to pay watchtowers -- when a watchtower broadcasts a W\n>> >   transaction, it needs to add fees, and it's not clear (to me) how it\n>> >   could fairly and reliably ensure it's compensated for those costs,\n>> >   particularly if multiple W transactions are broadcast for a single\n>> >   unilateral close attempt, due to one or more watchtowers colluding\n>> >   with an attacker, or simply having out of date information.\n>>\n>> I wonder if paying a watchtower, or getting paid as a watchtower isn't  a\n>> \"counterparty risk\" similar to what is happening with jamming due to\n>> non-covered HTLC forward risk. The watchtower has the risk of not being\n>> paid a posteriori and the user has the risk of the tower not acting. There\n>> is even a trade-off between tower costs and safety, as the more towers you\n>> have, more robust if your Lightning channel (in theory, as you also have a\n>> duplication of the key material).\n>>\n>> > * lack of layered transactions -- while this prevents you having to\n>> >   wait longer than to_self_delay before you can claim channel funds,\n>> >   it still means that any htlc that is going to timeout sooner than that\n>> >   may not be claimable on-chain, meaning you need to set\n>> >   cltv_expiry_delta >= to_self_delay.\n>>\n>> From a security perspective, offsetting the cltv_expiry_delta to a value\n>> superior to to_self_delay can be considered as an improvement, especially\n>> if it gradually does it network-wide. On the other hand, if routing\n>> algorithms start to penalize long-cltv-delta payment paths as the timevalue\n>> of liquidity is priced in routing fees, this design rationale might not be\n>> aligned with long-term LN network incentives (as of today even more\n>> loosely-defined than miner incentives).\n>>\n>> > * extending to multiparty channels -- penalising is hard if there's\n>> >   more than two parties, fast forwards are probably impossible since\n>> >   you need multiple round-trips to coordinate signatures anyway, and if\n>> >   you're doing channels-within-channels to reduce your n-party channel\n>> >   to an easier to update 2-party channel you're probably forced to have\n>> >   to_self_delay for each layer of channels. Also, just figuring out how\n>> >   to coordinate multiparty state updates and even keeping everyone in\n>> >   a multiparty channel online consistently to generate new signatures\n>> >   seems potentially hard?\n>>\n>> I don't know if penalising has been a solved issue for mulit-party, at\n>> least in a trustless fashion in the same way we have with 2-party\n>> LN-penalty (you could devise weird scheme based on timelock, taproot tree\n>> and threshold signatures incentivizing towards the convergence of a\n>> \"consensus\" punishment, still...) Figuring out coordinating multi-party\n>> states updates sounds workable with modern consensus algorithms (e.g Raft),\n>> though still conserving the fast forward effect is a high bar, it might be\n>> better deferred to an uplifted layer of 2-of-2 LN channels. The only reason\n>> you might have payments at the multi-party level (with the signature of the\n>> N-of-N participants requested) only for privacy or liquidity allocation\n>> reason. Though effectively, it sounds like your multiparty\n>> channel coordination mechanism should encompass party eviction or\n>> partitioning the offline parties. One or two orders of magnitude of\n>> complexity beyond the 2-party eltoo channel case, I think.\n>>\n>> Antoine\n>>\n>> [0] https://github.com/lightning/bolts/pull/867\n>> [1] https://github.com/LLFourn/witness-asymmetric-channel\n>>\n>> Le mer. 7 d\u00e9c. 2022 \u00e0 00:36, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n>>\n>>> Hi all,\n>>>\n>>> On the eltoo irc channel we discussed optimising eltoo for the 2-party\n>>> scenario; figured it was probably worth repeating that here.\n>>>\n>>> This is similar to:\n>>>\n>>>  - 2018-07-18, simplified eltoo:\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-July/001363.html\n>>>  - 2021-09-17, IID 2Stage,\n>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019470.html\n>>>  - 2022-09-29, Daric: https://eprint.iacr.org/2022/1295\n>>>  - 2022-10-21, eltoo/chia:\n>>> https://twitter.com/bramcohen/status/1583122833932099585\n>>>\n>>> The basic idea is \"if it's a two party channel with just Alice and Bob,\n>>> then if Alice starts a unilateral close, then she's already had her say,\n>>> so it's only Bob's opinion that matters from now on, and he should be\n>>> able to act immediately\", and once it's only Bob's opinion that matters,\n>>> you can simplify a bunch of things.\n>>>\n>>> A \"gist\" for this idea is\n>>> https://gist.github.com/ajtowns/53e0f735f4d5c06a681429d937200aa5 (it\n>>> goes into a little more detail in places, though doesn't cover trustless\n>>> watchtowers at all).\n>>>\n>>>\n>>>\n>>> In particular, there are a few practical constraints that we might like\n>>> to consider for 2-party channels with eltoo:\n>>>\n>>>  - fast forwards: we might want to allow our channel partner\n>>>    to immediately rely on a new state we propose without needing a\n>>>    round-trip delay -- this potentially makes forwarding payments much\n>>>    faster (though with some risk of locking the funds up, if you do a\n>>>    fast forward to someone who's gone offline)\n>>>\n>>>  - doubled delays: once we publish the latest state we can, we want to\n>>>    be able to claim the funds immediately after to_self_delay expires;\n>>>    however if our counterparty has signatures for a newer state than we\n>>>    do (which will happen if it was fast forwarded), they could post that\n>>>    state shortly before to_self_delay expires, potentially increasing\n>>>    the total delay to 2*to_self_delay.\n>>>\n>>>  - penalties: when you do a unilateral close, attempting to cheat comes\n>>>    with no cost to you and a possible benefit if you succeed, but\n>>>    potentially does cost your channel partner (either in forcing them\n>>>    to spend on-chain fees to update to the correct state, or in the risk\n>>>    of loss if their node malfunctions occassionally) -- a penalty could\n>>>    reduce this incentive to cheat\n>>>\n>>>  - trustless watchtowers: we may want to consider the possibility of a\n>>>    watchtower holding onto obsolete states and colluding with an\n>>>    attacker to attempt to cheat us\n>>>\n>>> What follows is a rough approach for dealing with all those issues for\n>>> two-party channels. It's spelled out in a little more detail in the gist.\n>>>\n>>> (I think for initial eltoo experimentation it doesn't make sense to try\n>>> to\n>>> deal with all (or perhaps any) of those constraints; simple and working\n>>> is better than complex and theoretical. But having them written down so\n>>> the ideas can be thought about and looked up later still seems useful)\n>>>\n>>> In more detail: unilateral closes are handled by each channel participant\n>>> maintaining five transactions, which we'll call:\n>>>\n>>>  * UA.n, UB.n : unilaterally propose closing at state n\n>>>    - this is for Alice or Bob to spend the funding tx for a unilater\n>>>      close to state n. Spends the funding transaction.\n>>>\n>>>  * WA.n, WB.n : watchtower update to state n\n>>>    - this is for an untrusted watchtower to correct attempted cheating\n>>>      by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n>>>      (or UA.k/WB.k) respectively, provided k < n.\n>>>\n>>>  * CA.n, CB.n : cooperatively claim funds according to state n\n>>>    - this is for Alice to confirm Bob's unilateral close (or vice-versa).\n>>>      Spends UB.k, WA.k (or UA.k/WB.k respectively), provided k <= n\n>>>\n>>>  * SA.n, SB.n : slowly claim funds according to state n\n>>>    - this is for Alice to claim her funds if Bob is completely offline\n>>>      (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n>>>      timelock of to_self_delay.\n>>>\n>>>  * RA.n, RB.n : claim funds with penalty after unilateral close to\n>>>    revoked state\n>>>    - this is for Alice to update the state if Bob attempted to cheat\n>>>      (or vice-versa). Spends UB.k or WA.k (or UA.k/WB.k respectively)\n>>>      conditional on k < n - 1; outputs are adjusted to transfer a fixed\n>>>      penalty of penalty_msat from Bob's balance to Alice's (or\n>>> vice-versa)\n>>>\n>>> Each of these \"transactions\" requires a pre-signed signature; however\n>>> the actual transaction/txid will vary in cases where a transaction has\n>>> the possibility of spending different inputs (eg \"Spends UB.k or WA.k\").\n>>> In particular UA.n/UB.n can be constructed with known txids and non-APO\n>>> signatures but WA.n/WB.n/CA.n/CB.n/SA.n/SB.n/RA.n/RB.n all require\n>>> APO signatures.\n>>>\n>>> They're named such that Alice can immediately broadcast all the *A.n\n>>> transactions (provided a tx that it can spend has been broadcast) and\n>>> Bob can likewise immediately broadcast all the *B.n transactions.\n>>>\n>>> Scenarios where Alice decides to unilaterally close the channel might\n>>> look like:\n>>>\n>>>  * if Alice/Bob can't communicate directly, but both are online:\n>>>\n>>>      F -> UA.n -> CB.n -> money\n>>>\n>>>    (balances and htlcs claimed, no delay)\n>>>\n>>>  * if Bob has gone offline entirely:\n>>>\n>>>      F -> UA.n -> (to_self_delay) -> SA.n -> money\n>>>\n>>>  * Alice cheats, Bob punishes:\n>>>\n>>>      F -> UA.k -> RB.n -> money[Alice pays Bob penalty]\n>>>\n>>>  * Bob is offline, Alice cheats, but Bob has a watchtower:\n>>>\n>>>      F -> UA.k -> WB.n -> (to_self_delay) -> SA.n -> money\n>>>\n>>>  * Alice and Bob's watchtower collude, but Bob's not offline:\n>>>\n>>>      F -> UA.k1 -> WB.k2 -> RB.n -> money[Alice pays Bob penalty]\n>>>\n>>>  * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n>>>\n>>>      F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n>>>\n>>> For Alice to successfully cheat, she needs Bob to be offline for at least\n>>> to_self_delay, and for all Bob's watchtowers to either also be offline,\n>>> or colluding.\n>>>\n>>> This can be simplified somewhat, if you don't care about all the\n>>> features:\n>>>\n>>>  * If you don't care about trustless watchtowers you can drop WA.n/WB.n\n>>>    (and simplify SA.n/SB.n to not require an APO signature)\n>>>\n>>>  * If you don't care about penalties you can set penalty_msat to 0 and\n>>>    allow RA.n/RB.n to spend k<=n. In this case, you can either drop\n>>>    CA.n/CB.n entirely, or you can have CA.n/CB.n only be used for\n>>> directly\n>>>    spending of UB.n/UA.n and thus not require APO signatures\n>>>\n>>> In order to allow fast-forwards, when Alice proposes a new state,\n>>> she needs to send her partial signatures to allow Bob to unilaterally\n>>> accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n>>> also needs to be able to claim the funds if Bob proposes the new state\n>>> and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n>>> achieved with an adaptor signature approach (spelt out a bit more fully\n>>> in the gist) or a CTV-like approach, provided that UB.n reveals the\n>>> state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n>>>\n>>> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n>>> ).\n>>>\n>>> Note that in this scenario Alice doesn't provide WB.n to Bob\n>>> immediately. This is okay, as if Alice proposes UA.(n-1) (her most\n>>> recent state), Bob can still immediately claim via CA.n. If Bob did have\n>>> WB.n; then if Alice proposed UA.(n-1) Bob could wait for an initial\n>>> to_self_delay period and broadcast WB.n, forcing Alice to wait for an\n>>> additional to_self_delay before being able to claim her funds via SA.n.\n>>>\n>>> Note also that this is why RA.n/RB.n require \"k < n - 1\" -- otherwise\n>>> Alice would only be able to broadcast UA.(n-1) and Bob would immediately\n>>> be able to penalise by broadcasting RB.n.\n>>>\n>>> Note that if you're using a watchtower and wish to punish your\n>>> counterparty if it attempts to cheat, you should only pass WA.(n-2)\n>>> to your watchtowers, not WA.(n-1) or WA.n.\n>>>\n>>>\n>>>\n>>> This doesn't address any potential issues from:\n>>>\n>>>  * how to add fees -- the U/W transactions are 1-in/1-out transactions\n>>>    that can't be trivially CPFPed by the proposer and need to have\n>>>    fees added (either SINGLE/ANYONECANPAY signatures or having a 0-sat\n>>>    ephemeral output and package relay might be workable); the C/S/R\n>>>    transactions are 1-in/many-out transactions, but have balance outputs\n>>>    that can be immediately spent to pay for fees via CPFP if package\n>>>    relay is available.\n>>>\n>>>  * how to pay watchtowers -- when a watchtower broadcasts a W\n>>>    transaction, it needs to add fees, and it's not clear (to me) how it\n>>>    could fairly and reliably ensure it's compensated for those costs,\n>>>    particularly if multiple W transactions are broadcast for a single\n>>>    unilateral close attempt, due to one or more watchtowers colluding\n>>>    with an attacker, or simply having out of date information.\n>>>\n>>>  * lack of layered transactions -- while this prevents you having to\n>>>    wait longer than to_self_delay before you can claim channel funds,\n>>>    it still means that any htlc that is going to timeout sooner than that\n>>>    may not be claimable on-chain, meaning you need to set\n>>>    cltv_expiry_delta >= to_self_delay.\n>>>\n>>>  * extending to multiparty channels -- penalising is hard if there's\n>>>    more than two parties, fast forwards are probably impossible since\n>>>    you need multiple round-trips to coordinate signatures anyway, and if\n>>>    you're doing channels-within-channels to reduce your n-party channel\n>>>    to an easier to update 2-party channel you're probably forced to have\n>>>    to_self_delay for each layer of channels. Also, just figuring out how\n>>>    to coordinate multiparty state updates and even keeping everyone in\n>>>    a multiparty channel online consistently to generate new signatures\n>>>    seems potentially hard?\n>>>\n>>> Cheers,\n>>> aj\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221212/a2aadcd6/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-12-09T06:55:47",
                "message_text_only": "On Thu, Dec 08, 2022 at 02:14:06PM -0500, Antoine Riard wrote:\n> >  - 2022-10-21, eltoo/chia:\n> https://twitter.com/bramcohen/status/1583122833932099585\n> On the eltoo/chia variant, from my (quick) understanding, the main\n> innovation aimed for is \n\nI'd say the main innovation aimed for is just doing something like\nlightning over the top of chia (rather than bitcoin, liquid, ethereum\netc), and making it simple enough to be easily implemented.\n\n> the limitation of the publication of eltoo states\n> more than once by a counterparty, by introducing a cryptographic puzzle,\n> where the witness can be produced once and only once ? I would say you\n> might need the inheritance of the updated scriptpubkey across the chain of\n> eltoo states, with a TLUV-like mechanism.\n\nChia uses different terminology to bitcoin; \"puzzle\" is just what we call\n\"scriptPubKey\" in bitcoin, more or less. Since its scripting capabilities\nare pretty powerful, you can rig up a TLUV/OP_EVICT like mechanism, but\nfor a two-party setup, in practice I think that mostly just means you\ncan encode the logic directly as script, and when updating the state you\nthen only need to exchange CHECKSIGFROMSTACK-like signatures along the\nlines of \"state N implies outputs of A,B,C,... -- Alice\", rather than\nsigning multiple transactions.\n\n> > The basic idea is \"if it's a two party channel with just Alice and Bob,\n> > then if Alice starts a unilateral close, then she's already had her say,\n> > so it's only Bob's opinion that matters from now on, and he should be\n> > able to act immediately\", and once it's only Bob's opinion that matters,\n> > you can simplify a bunch of things.\n> From my understanding, assuming Eltoo paper terminology, Alice can publish\n> an update K transaction, and then after Bob can publish an update\n> transaction K<N or Alice can publish the settlement transaction N, or Bob\n> can publish an update transaction N. The main advantage of this\n> construction I can see is a strict bound on the shared_delay encumbered in\n> the on-chain publication of the channel ?\n\nIf you have fully symmetric transactions, then you could have the\nsituation where Alice broadcasts update K, then attacks Bob and when\nhe attempts to post update N, she instead does a pinning attack by\nbroadcasting update K+1 (spending update K), which then forces Bob to\ngenerate a new version update N, which she then blocks with update K+2,\netc. An attack like that is presumably pretty difficult to pull off in\npractice, but it makes it pretty hard to reason about many of the limits.\n\nA simple advantage to breaking the symmetry is that if A does a unilateral\nclose, then B can immediately confirm that closure releasing all funds\nfor both parties. Without breaking the symmetry, you can't distinguish\nthat case from B attempting to confirm his own unilateral close, which\nwould allow B to cheat.\n\n> > fast forwards: we might want to allow our channel partner\n> > to immediately rely on a new state we propose without needing a\n> > round-trip delay -- this potentially makes forwarding payments much\n> > faster (though with some risk of locking the funds up, if you do a\n> > fast forward to someone who's gone offline)\n> \n> IIRC, there has already been a \"fast-forward\" protocol upgrade proposal\n> based on update-turn in the LN-penalty paradigm [0]. I think reducing the\n> latency of HTLC propagation across payment paths would constitute a UX\n> improvement, especially a link-level update mechanism upgrade deployment\n> might be incentivized by routing algorithms starting to penalize routing\n> hops HTLC relay latency. What is unclear is the additional risk of locking\n> the funds up. If you don't receive acknowledgement the fast forward state\n> has been received, you should still be able to exit with the state N-1 ?\n\nYes, you can unilaterally close the channel with state N-1; but even\nthen they might respond by bumping to state N anyway. If that happens,\nthen the funds can remain locked up until the timeout, as you can no\nlonger time the htlc out off-chain.\n\nStill, if it's one hung per htlc for the channel's entire lifetime\n(because you close it \"immediately\" when it happens), that's probably\nnot going to cause problems frequently...\n\n> > doubled delays: once we publish the latest state we can, we want to\n> > be able to claim the funds immediately after to_self_delay expires;\n> > however if our counterparty has signatures for a newer state than we\n> > do (which will happen if it was fast forwarded), they could post that\n> > state shortly before to_self_delay expires, potentially increasing\n> > the total delay to 2*to_self_delay.\n> \n> While the 2*to_self_delay sounds the maximum time delay in the state\n> publication scenario where the cheating counterparty publishes a old state\n> then the honest counterparty publishes the latest one, there could be the\n> case where the cheating counterparty broadcast chain of old states, up to\n> mempool's `limitancestorcount`. However, this chain of eltoo transactions\n> could be replaced by the honest party paying a higher-feerate (assuming\n> something like nversion=3).\n\nWith the asymmetric transactions proposed here, you'd need to have your\nwatchtowers collude with the attacker for this to happen.\n\nI think you could prevent chains from building up in the mempool by\nrequiring a relative timelock of perhaps 2 or 3 blocks for a WA.n/WB.n\ntx to be valid (giving you time to post RA.n/RB.n in the meantime).\n\n> > * WA.n, WB.n : watchtower update to state n\n> >   - this is for an untrusted watchtower to correct attempted cheating\n> >     by Bob on behalf of Alice (or vice-versa). Spends UB.k or WA.k\n> >     (or UA.k/WB.k) respectively, provided k < n.\n> I wonder if the introduction of watchtower specific transactions doesn't\n> break the 2*to_self_delay assumption\n\nThe to_self_delay applies to whoever initiated the unilateral close,\nand provided they actually posted the most recent state, no watchtower\ntx is a valid spend. ie, if Alice is honest and n is the latest state,\nthen the only possible spends of UA.n are SA.n (after a delay) or CB.n,\nand as soon as either of those are on chain, she gets access to her funds.\nNo version of WB.k or RB.k (or WA.k, CA.k, RA.k) are valid if k<=n and\nUA.n is confirmed.\n\nIf Alice is dishonest, and posts a very old state (n-x), then Bob could\npost up to x watchtower txs (WB.(n-x+1) .. WB.n) causing Alice to be\nunable to access her funds for up to (x+1)*to_self_delay blocks. But\nthat's just a reason for her to not be dishonest in the first place.\n\n> (iiuc it's a design goal of current\n> protocol) and what is the design rationale. Beyond that, there is a concern\n> with watchtower-specific transactions, it might leak your towers topology\n> (i.e the number of them and the distribution in the p2p network) to an\n> adversary.\n\nIf you have a watchtower and it takes action, I don't think you can\nexpect to retain privacy over the fact that you have a watchtower,\nand how effective it is against an attacker with extensive monitoring\nof the p2p network...\n\n> > * SA.n, SB.n : slowly claim funds according to state n\n> >   - this is for Alice to claim her funds if Bob is completely offline\n> >     (or vice-versa). Spends UA.n, UB.n, WA.n or WB.n with relative\n> >     timelock of to_self_delay.\n> \n> If I'm following correctly the description, this is logically equivalent to\n> the sweep of a `to_local`/`to_remote` output on a commitment transaction\n> though instead the waiting delay is eltoo shared_delay. There is no\n> to_self_delay, at the punishment seems only to happen on the update-level,\n> or maybe one should be also able to punish slow fund exit, and another\n> relative locktime should exist on the S* transactions.\n\nI'm just using \"to_self_delay\" as the X in \"if you attempt to cheat,\nI'll definitely notice and take action within X blocks\". If you post\nUA.n then post SA.n after X blocks (due to SA.n's relative time lock)\nthen you've already proven you didn't cheat, because that was enough\ntime for B to notice and take action.\n\n> > * Alice and Bob's watchtower collude, but Bob has many watchtowers:\n> >     F -> UA.k1 -> WB.k2 -> WB.n -> (to_self_delay) -> SA.n -> money\n> Could the punishment transactions R* be also delegated to watchtowers,\n> assuming they have been pre-signed to lockdown the exit scriptpubkeys ?\n\nNo -- the RB.n transactions immediately release A's funds after applying\nthe penalty, so if the watchtower colludes with A and has an old RB.y\ntransaction, Alice can steal funds by posting UA.x and RB.y, provided that\nher balance now is sufficiently less than her balance then (ie bal.n <\nbal.y - penalty).\n\nIn this model, Bob shouldn't be signing RB.n or CB.n txs until Alice\nhas already started a unilateral close and posted UA.n/UA.k.\n\n> > In order to allow fast-forwards, when Alice proposes a new state,\n> > she needs to send her partial signatures to allow Bob to unilaterally\n> > accept the new state, ie sigs for: UB.n, CB.n, SB.n, RB.n. But she\n> > also needs to be able to claim the funds if Bob proposes the new state\n> > and broadcasts UB.n, she needs to be able broadcast CA.n. This can be\n> > achieved with an adaptor signature approach (spelt out a bit more fully\n> > in the gist) or a CTV-like approach, provided that UB.n reveals the\n> > state needed to calculate the the CTV commitment (see \"EXPR_SETTLE\" in\n> >\n> https://github.com/instagibbs/bolts/blob/29fe6d36cbad4101d5ec76c2b19c83c1494ac2fc/XX-eltoo-transactions.md\n> ).\n> \n> If you would like to have fast forward of chain of transactions, I wonder\n> if there could be also the \"sig-in-the-script\" trick, where UB.n\n> scriptpubkey (or one of its tapscripts) contains the signature for CB.n,\n> SB.n, RB.n. Though you might have an issue of re-generating the\n> witnessscript in case of state loss.\n\nBroadcasting UB.n will only reveal signatures by B; so that would only\npotentially help with CA.n or RA.n; and if UB.n is on-chain, then RA.n\nisn't valid (since it would require \"n < n\"). \n\nThe EXPR_SETTLE stuff in the github link describes how to do the trick\nvia a CTV-ish approach (including an APO signature in a tapscript in the\nscriptPubKey of UA.n here; and including data in the annex so that you\ncan recalculate thinks if an old UA.n is broadcast after you've\nforgotten n's state details).\n\n> > * how to pay watchtowers -- when a watchtower broadcasts a W\n> >   transaction, it needs to add fees, and it's not clear (to me) how it\n> >   could fairly and reliably ensure it's compensated for those costs,\n> >   particularly if multiple W transactions are broadcast for a single\n> >   unilateral close attempt, due to one or more watchtowers colluding\n> >   with an attacker, or simply having out of date information.\n> I wonder if paying a watchtower, or getting paid as a watchtower isn't  a\n> \"counterparty risk\" similar to what is happening with jamming due to\n> non-covered HTLC forward risk.\n\nActually, perhaps you could \"yo dawg\" it: if you give the watchtower a\npre-signed transaction WA.n:\n\n    input 1: UA.k/WA.k (ANYPREVOUTANYSCRIPT, SINGLE)\n    input 2: my funds (SINGLE, ALL)\n\n    output 1: WA.n\n    output 2: new lightning channel between me and watchtower\n    output 3: ephemeral OP_TRUE output\n\nthen you could have the \"new lightning channel\" be setup with an initial\ncapacity of \"my funds\", and off-chain update the state of that channel so\nthat the watchtower's balance is how much you're willing to contribute in\nfees if the watchtower does its job. If you set things up so that you're\nalways able to claim a penalty via WA.n->RA.n if the watchtower acts,\nthen you can give up to that penalty to the watchtower and still end up\nmaking a profit.\n\nDoesn't generalise to redundant untrusted watchtowers though, but\npresumably nothing does. (You could use the same utxo across multiple\nwatchtowers, but a rogue watchtower could just post an old WA.k tx and\nclaim your funds, preventing some honest watchtower from helping)\n\n(Yo dawg, I heard you liked closing lightning channels, so we put a\nlightning channel in your watchtower, so you can close a channel while\nyou're closing a channel. Alternatively: \"when god closes one channel,\nhe opens another\")\n\nCheers,\naj"
            }
        ],
        "thread_summary": {
            "title": "Two-party eltoo w/ punishment",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Antoine Riard",
                "Greg Sanders"
            ],
            "messages_count": 5,
            "total_messages_chars_count": 97729
        }
    },
    {
        "title": "[Lightning-dev] Jamming mitigation call",
        "thread_messages": [
            {
                "author": "Clara Shikhelman",
                "date": "2022-12-08T16:07:55",
                "message_text_only": "Hi all,\n\nThe agenda for next week's meeting (Monday the 12th, 7 pm UTC) is the\nfollowing:\n\n1. Which parameters should be considered in reputation-based solutions?\n2. Circuitbreaker [1]\n3. Onion relay network [2] and its potential uses.\n\nThe link to the call:  https://meet.jit.si/UnjammingLN\n\nSee you there,\nClara\n\n[1]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003781.html\n[2]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003780.html\n\nOn Sun, Nov 27, 2022 at 9:48 PM Clara Shikhelman <clara.shikhelman at gmail.com>\nwrote:\n\n> Hi all,\n>\n> In light of recent conversations ([1],[2]), the agenda for the call\n> tomorrow (Monday the 28th, 7 pm UTC) is roughly the following:\n>\n> 1. Overview of solutions under discussion\n> 2. Reputation (local/tokens)\n> 3. Fees\n>\n> This is the link to the call: https://meet.jit.si/UnjammingLN\n>\n> See you there,\n> Clara\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003754.html\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/5fc41c64/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-09T03:30:51",
                "message_text_only": "Hi Clara,\n\nThanks for rolling the ball forward.\n\nOn the agenda, a few more thoughts.\n\n> 1. Which parameters should be considered in reputation-based solutions?\n\nI think before thinking about the parameters of reputation-based solutions,\nwe should discuss the security goal we're aiming to achieve with any\npotential jamming solutions. Browsing the solution space some have aimed to\nincrease the opportunity cost for the attacker (e.g liquidity slots), some\nto reduce the jamming intensity (e.g circuit breakers), some inflicting a\non-chain fee damage cost back to the adversary (e.g stake certificates),\nsome to achieve economic hedge of the routing hops (e.g unconditional\nfees, reputation credentials). As of today, I would say a security goal\ndesigned in the term of a monetary strategy could be more acceptable to the\nrouting hops node operators. Beyond that, I believe there is capturing this\ndesign goal in a \"measurable\" notion, such as the unjamming lightning\npaper's breakeven point, and see how we can enrich this \"measurable\" notion.\n\n> 2. Circuitbreaker [1]\n\nWhile reviewing the circuitbreaker last week, I started to wonder if there\nwasn't another \"hidden\" issue while solving channel jamming, namely\ncongestion control of the HTLC flows. A node operator is not only\ninterested that any liquidity unit allocated for a HTLC forward is paid\nback with routing fees, but also in case of more forward demand than\nliquidity offer, ready to process it (potentially by deferring and sending\nbackpressure messages to the HTLC sender). I don't know, though I think\nthat can be an interesting point to discuss.\n\n> 3. Onion relay network [2] and its potential uses.\n\nOnion relay network rate-limits have been discussed earlier this year, with\na probabilistic backpressure scheme proposed. If the onion relay traffic\nstarts to have economically-weighable traffic (offers, credentials tokens,\netc), there could be a risk of onion-jamming. For the bootstrap of the\nonion relay network, I believe this could be solved by leveraging more the\nchannel-network topology for the design of a solution. We could re-use the\nevaluation framework from the unjamming lightning paper, I guess.\n\nIn the meeting, I think it could be very valuable if we have reliable\ntranscripts and if we start to maintain a community repository, where we\ncan pin the issues, problems and ideas.\n\nOn the frequency of the meeting, note some Lightning developers raised the\nconcern that biweekly might be too much:\nhttps://gnusha.org/lightning-dev/2022-11-23.log (once a month could work\nwell too, if  we have a sound agenda).\n\nBest,\nAntoine\n\nLe jeu. 8 d\u00e9c. 2022 \u00e0 11:08, Clara Shikhelman <clara.shikhelman at gmail.com>\na \u00e9crit :\n\n> Hi all,\n>\n> The agenda for next week's meeting (Monday the 12th, 7 pm UTC) is the\n> following:\n>\n> 1. Which parameters should be considered in reputation-based solutions?\n> 2. Circuitbreaker [1]\n> 3. Onion relay network [2] and its potential uses.\n>\n> The link to the call:  https://meet.jit.si/UnjammingLN\n>\n> See you there,\n> Clara\n>\n> [1]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003781.html\n> [2]\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003780.html\n>\n> On Sun, Nov 27, 2022 at 9:48 PM Clara Shikhelman <\n> clara.shikhelman at gmail.com> wrote:\n>\n>> Hi all,\n>>\n>> In light of recent conversations ([1],[2]), the agenda for the call\n>> tomorrow (Monday the 28th, 7 pm UTC) is roughly the following:\n>>\n>> 1. Overview of solutions under discussion\n>> 2. Reputation (local/tokens)\n>> 3. Fees\n>>\n>> This is the link to the call: https://meet.jit.si/UnjammingLN\n>>\n>> See you there,\n>> Clara\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n>> [2]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003754.html\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/e56d9ec4/attachment.html>"
            },
            {
                "author": "Clara Shikhelman",
                "date": "2022-12-09T03:51:31",
                "message_text_only": "Hi Antoine,\n\nThanks for your input.\n\nThe first item is there because we agreed to start where we left off at the\nend of the last meeting.\n\nAbout your comments on the other items \u2013 I think they are very interesting,\nbut you should probably write them in the relevant thread. Let's keep this\nfor meeting housekeeping.\n\nI agree about a repository, will do this soon.\n\nAs for the frequency, the next one will be in a month because of the\nholidays. I like the biweekly because things stay fresh. Of course, there\nis no need for everyone to attend, we'll start publishing a summary for\nthose who can't.\n\nIf you would like to write a transcript, it would be very useful and much\nappreciated.\n\nBest,\nClara\n\n\nOn Thu, Dec 8, 2022 at 10:31 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi Clara,\n>\n> Thanks for rolling the ball forward.\n>\n> On the agenda, a few more thoughts.\n>\n> > 1. Which parameters should be considered in reputation-based solutions?\n>\n> I think before thinking about the parameters of reputation-based\n> solutions, we should discuss the security goal we're aiming to achieve with\n> any potential jamming solutions. Browsing the solution space some have\n> aimed to increase the opportunity cost for the attacker (e.g liquidity\n> slots), some to reduce the jamming intensity (e.g circuit breakers), some\n> inflicting a on-chain fee damage cost back to the adversary (e.g stake\n> certificates), some to achieve economic hedge of the routing hops (e.g\n> unconditional\n> fees, reputation credentials). As of today, I would say a security goal\n> designed in the term of a monetary strategy could be more acceptable to the\n> routing hops node operators. Beyond that, I believe there is capturing this\n> design goal in a \"measurable\" notion, such as the unjamming lightning\n> paper's breakeven point, and see how we can enrich this \"measurable\" notion.\n>\n> > 2. Circuitbreaker [1]\n>\n> While reviewing the circuitbreaker last week, I started to wonder if there\n> wasn't another \"hidden\" issue while solving channel jamming, namely\n> congestion control of the HTLC flows. A node operator is not only\n> interested that any liquidity unit allocated for a HTLC forward is paid\n> back with routing fees, but also in case of more forward demand than\n> liquidity offer, ready to process it (potentially by deferring and sending\n> backpressure messages to the HTLC sender). I don't know, though I think\n> that can be an interesting point to discuss.\n>\n> > 3. Onion relay network [2] and its potential uses.\n>\n> Onion relay network rate-limits have been discussed earlier this year,\n> with a probabilistic backpressure scheme proposed. If the onion relay\n> traffic starts to have economically-weighable traffic (offers, credentials\n> tokens, etc), there could be a risk of onion-jamming. For the bootstrap of\n> the onion relay network, I believe this could be solved by leveraging more\n> the channel-network topology for the design of a solution. We could re-use\n> the evaluation framework from the unjamming lightning paper, I guess.\n>\n> In the meeting, I think it could be very valuable if we have reliable\n> transcripts and if we start to maintain a community repository, where we\n> can pin the issues, problems and ideas.\n>\n> On the frequency of the meeting, note some Lightning developers raised the\n> concern that biweekly might be too much:\n> https://gnusha.org/lightning-dev/2022-11-23.log (once a month could work\n> well too, if  we have a sound agenda).\n>\n> Best,\n> Antoine\n>\n> Le jeu. 8 d\u00e9c. 2022 \u00e0 11:08, Clara Shikhelman <clara.shikhelman at gmail.com>\n> a \u00e9crit :\n>\n>> Hi all,\n>>\n>> The agenda for next week's meeting (Monday the 12th, 7 pm UTC) is the\n>> following:\n>>\n>> 1. Which parameters should be considered in reputation-based solutions?\n>> 2. Circuitbreaker [1]\n>> 3. Onion relay network [2] and its potential uses.\n>>\n>> The link to the call:  https://meet.jit.si/UnjammingLN\n>>\n>> See you there,\n>> Clara\n>>\n>> [1]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003781.html\n>> [2]\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003780.html\n>>\n>> On Sun, Nov 27, 2022 at 9:48 PM Clara Shikhelman <\n>> clara.shikhelman at gmail.com> wrote:\n>>\n>>> Hi all,\n>>>\n>>> In light of recent conversations ([1],[2]), the agenda for the call\n>>> tomorrow (Monday the 28th, 7 pm UTC) is roughly the following:\n>>>\n>>> 1. Overview of solutions under discussion\n>>> 2. Reputation (local/tokens)\n>>> 3. Fees\n>>>\n>>> This is the link to the call: https://meet.jit.si/UnjammingLN\n>>>\n>>> See you there,\n>>> Clara\n>>>\n>>> [1]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n>>> [2]\n>>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003754.html\n>>> _______________________________________________\n>>> Lightning-dev mailing list\n>>> Lightning-dev at lists.linuxfoundation.org\n>>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/52e3595c/attachment-0001.html>"
            },
            {
                "author": "Loki Verloren",
                "date": "2022-12-09T11:39:08",
                "message_text_only": "Hi,\n\nI am quite busy and focused on developing the Indranet lighting monetised onion relay network project, but I dropped my 2c in the hat relating to this, I just wanted to make a comment regarding related spam mitigation strategies which also form the basis of my project.\n\nWhen nodes in the network will not process data in a message without being paid, the cost of spamming useless data rises dramatically. The asymmetries that can exist between generating data and processing it lead to vulnerabilities, not just DoS of network but attacking memory and processing capacity of nodes.\n\nMight I suggest that if the idea of charging for services existed, and a scheme for accounting the consumption of pre-paid service were to exist, similar to the one I am devising for Indra, it would have the same benefit also for Lightning network in general: potential to earn a strongly guaranteed margin of profit, and that leading to the eventual growth of the network as it isn't a loss-leader investment. Wherever the economics favor attackers, making such services paid only or paid plus a dribble of free service, like the Bitcoin mempool, attackers will look elsewhere for easy prey.\n\nI will be keeping an eye on how security protocols develop with LN and hope to be able cross-pollinate where things intersect. I do think that onion routing is a loss-leader unless it has anonymous payments in it, and anonymous payments themselves are a utility for LN. \n\n\n- l0k1\n\n> Subject: Re: [Lightning-dev] Jamming mitigation call\n> Message-ID:\n> CALZpt+GsNhZcv1u6_hjgt=1WpGE0nE5ygqHN3EUhjHTO9T=Y7w at mail.gmail.com\n> \n\n> Content-Type: text/plain; charset=\"utf-8\"\n> \n\n> Hi Clara,\n> \n\n> Thanks for rolling the ball forward.\n> \n\n> On the agenda, a few more thoughts.\n> \n\n> > 1. Which parameters should be considered in reputation-based solutions?\n> \n\n> \n\n> I think before thinking about the parameters of reputation-based solutions,\n> we should discuss the security goal we're aiming to achieve with any\n> potential jamming solutions. Browsing the solution space some have aimed to\n> increase the opportunity cost for the attacker (e.g liquidity slots), some\n> to reduce the jamming intensity (e.g circuit breakers), some inflicting a\n> on-chain fee damage cost back to the adversary (e.g stake certificates),\n> some to achieve economic hedge of the routing hops (e.g unconditional\n> fees, reputation credentials). As of today, I would say a security goal\n> designed in the term of a monetary strategy could be more acceptable to the\n> routing hops node operators. Beyond that, I believe there is capturing this\n> design goal in a \"measurable\" notion, such as the unjamming lightning\n> paper's breakeven point, and see how we can enrich this \"measurable\" notion.\n> \n\n> > 2. Circuitbreaker [1]\n> \n\n> \n\n> While reviewing the circuitbreaker last week, I started to wonder if there\n> wasn't another \"hidden\" issue while solving channel jamming, namely\n> congestion control of the HTLC flows. A node operator is not only\n> interested that any liquidity unit allocated for a HTLC forward is paid\n> back with routing fees, but also in case of more forward demand than\n> liquidity offer, ready to process it (potentially by deferring and sending\n> backpressure messages to the HTLC sender). I don't know, though I think\n> that can be an interesting point to discuss.\n> \n\n> > 3. Onion relay network [2] and its potential uses.\n> \n\n> \n\n> Onion relay network rate-limits have been discussed earlier this year, with\n> a probabilistic backpressure scheme proposed. If the onion relay traffic\n> starts to have economically-weighable traffic (offers, credentials tokens,\n> etc), there could be a risk of onion-jamming. For the bootstrap of the\n> onion relay network, I believe this could be solved by leveraging more the\n> channel-network topology for the design of a solution. We could re-use the\n> evaluation framework from the unjamming lightning paper, I guess.\n> \n\n> In the meeting, I think it could be very valuable if we have reliable\n> transcripts and if we start to maintain a community repository, where we\n> can pin the issues, problems and ideas.\n> \n\n> On the frequency of the meeting, note some Lightning developers raised the\n> concern that biweekly might be too much:\n> https://gnusha.org/lightning-dev/2022-11-23.log (once a month could work\n> well too, if we have a sound agenda).\n> \n\n> Best,\n> Antoine\n> \n\n> Le jeu. 8 d?c. 2022 ? 11:08, Clara Shikhelman clara.shikhelman at gmail.com\n> \n\n> a ?crit :\n> \n\n> > Hi all,\n> > \n\n> > The agenda for next week's meeting (Monday the 12th, 7 pm UTC) is the\n> > following:\n> > \n\n> > 1. Which parameters should be considered in reputation-based solutions?\n> > 2. Circuitbreaker [1]\n> > 3. Onion relay network [2] and its potential uses.\n> > \n\n> > The link to the call: https://meet.jit.si/UnjammingLN\n> > \n\n> > See you there,\n> > Clara\n> > \n\n> > [1]\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003781.html\n> > [2]\n> > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003780.html\n> > \n\n> > On Sun, Nov 27, 2022 at 9:48 PM Clara Shikhelman <\n> > clara.shikhelman at gmail.com> wrote:\n> > \n\n> > > Hi all,\n> > > \n\n> > > In light of recent conversations ([1],[2]), the agenda for the call\n> > > tomorrow (Monday the 28th, 7 pm UTC) is roughly the following:\n> > > \n\n> > > 1. Overview of solutions under discussion\n> > > 2. Reputation (local/tokens)\n> > > 3. Fees\n> > > \n\n> > > This is the link to the call: https://meet.jit.si/UnjammingLN\n> > > \n\n> > > See you there,\n> > > Clara\n> > > \n\n> > > [1]\n> > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n> > > [2]\n> > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003754.html\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > \n\n> > _______________________________________________\n> > Lightning-dev mailing list\n> > Lightning-dev at lists.linuxfoundation.org\n> > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/e56d9ec4/attachment-0001.html\n> \n\n> \n\n> ------------------------------\n> \n\n> Message: 2\n> Date: Thu, 8 Dec 2022 22:51:31 -0500\n> From: Clara Shikhelman clara.shikhelman at gmail.com\n> \n\n> To: Antoine Riard antoine.riard at gmail.com\n> \n\n> Cc: lightning-dev lightning-dev at lists.linuxfoundation.org\n> \n\n> Subject: Re: [Lightning-dev] Jamming mitigation call\n> Message-ID:\n> CACtNmG6BQ_assXd5SyvZz7VGycystnVugM4JN=m06roySKe1LA at mail.gmail.com\n> \n\n> Content-Type: text/plain; charset=\"utf-8\"\n> \n\n> Hi Antoine,\n> \n\n> Thanks for your input.\n> \n\n> The first item is there because we agreed to start where we left off at the\n> end of the last meeting.\n> \n\n> About your comments on the other items ? I think they are very interesting,\n> but you should probably write them in the relevant thread. Let's keep this\n> for meeting housekeeping.\n> \n\n> I agree about a repository, will do this soon.\n> \n\n> As for the frequency, the next one will be in a month because of the\n> holidays. I like the biweekly because things stay fresh. Of course, there\n> is no need for everyone to attend, we'll start publishing a summary for\n> those who can't.\n> \n\n> If you would like to write a transcript, it would be very useful and much\n> appreciated.\n> \n\n> Best,\n> Clara\n> \n\n> \n\n> On Thu, Dec 8, 2022 at 10:31 PM Antoine Riard antoine.riard at gmail.com\n> \n\n> wrote:\n> \n\n> > Hi Clara,\n> > \n\n> > Thanks for rolling the ball forward.\n> > \n\n> > On the agenda, a few more thoughts.\n> > \n\n> > > 1. Which parameters should be considered in reputation-based solutions?\n> > \n\n> > I think before thinking about the parameters of reputation-based\n> > solutions, we should discuss the security goal we're aiming to achieve with\n> > any potential jamming solutions. Browsing the solution space some have\n> > aimed to increase the opportunity cost for the attacker (e.g liquidity\n> > slots), some to reduce the jamming intensity (e.g circuit breakers), some\n> > inflicting a on-chain fee damage cost back to the adversary (e.g stake\n> > certificates), some to achieve economic hedge of the routing hops (e.g\n> > unconditional\n> > fees, reputation credentials). As of today, I would say a security goal\n> > designed in the term of a monetary strategy could be more acceptable to the\n> > routing hops node operators. Beyond that, I believe there is capturing this\n> > design goal in a \"measurable\" notion, such as the unjamming lightning\n> > paper's breakeven point, and see how we can enrich this \"measurable\" notion.\n> > \n\n> > > 2. Circuitbreaker [1]\n> > \n\n> > While reviewing the circuitbreaker last week, I started to wonder if there\n> > wasn't another \"hidden\" issue while solving channel jamming, namely\n> > congestion control of the HTLC flows. A node operator is not only\n> > interested that any liquidity unit allocated for a HTLC forward is paid\n> > back with routing fees, but also in case of more forward demand than\n> > liquidity offer, ready to process it (potentially by deferring and sending\n> > backpressure messages to the HTLC sender). I don't know, though I think\n> > that can be an interesting point to discuss.\n> > \n\n> > > 3. Onion relay network [2] and its potential uses.\n> > \n\n> > Onion relay network rate-limits have been discussed earlier this year,\n> > with a probabilistic backpressure scheme proposed. If the onion relay\n> > traffic starts to have economically-weighable traffic (offers, credentials\n> > tokens, etc), there could be a risk of onion-jamming. For the bootstrap of\n> > the onion relay network, I believe this could be solved by leveraging more\n> > the channel-network topology for the design of a solution. We could re-use\n> > the evaluation framework from the unjamming lightning paper, I guess.\n> > \n\n> > In the meeting, I think it could be very valuable if we have reliable\n> > transcripts and if we start to maintain a community repository, where we\n> > can pin the issues, problems and ideas.\n> > \n\n> > On the frequency of the meeting, note some Lightning developers raised the\n> > concern that biweekly might be too much:\n> > https://gnusha.org/lightning-dev/2022-11-23.log (once a month could work\n> > well too, if we have a sound agenda).\n> > \n\n> > Best,\n> > Antoine\n> > \n\n> > Le jeu. 8 d?c. 2022 ? 11:08, Clara Shikhelman clara.shikhelman at gmail.com\n> > a ?crit :\n> > \n\n> > > Hi all,\n> > > \n\n> > > The agenda for next week's meeting (Monday the 12th, 7 pm UTC) is the\n> > > following:\n> > > \n\n> > > 1. Which parameters should be considered in reputation-based solutions?\n> > > 2. Circuitbreaker [1]\n> > > 3. Onion relay network [2] and its potential uses.\n> > > \n\n> > > The link to the call: https://meet.jit.si/UnjammingLN\n> > > \n\n> > > See you there,\n> > > Clara\n> > > \n\n> > > [1]\n> > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003781.html\n> > > [2]\n> > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-December/003780.html\n> > > \n\n> > > On Sun, Nov 27, 2022 at 9:48 PM Clara Shikhelman <\n> > > clara.shikhelman at gmail.com> wrote:\n> > > \n\n> > > > Hi all,\n> > > > \n\n> > > > In light of recent conversations ([1],[2]), the agenda for the call\n> > > > tomorrow (Monday the 28th, 7 pm UTC) is roughly the following:\n> > > > \n\n> > > > 1. Overview of solutions under discussion\n> > > > 2. Reputation (local/tokens)\n> > > > 3. Fees\n> > > > \n\n> > > > This is the link to the call: https://meet.jit.si/UnjammingLN\n> > > > \n\n> > > > See you there,\n> > > > Clara\n> > > > \n\n> > > > [1]\n> > > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003740.html\n> > > > [2]\n> > > > https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-November/003754.html\n> > > > _______________________________________________\n> > > > Lightning-dev mailing list\n> > > > Lightning-dev at lists.linuxfoundation.org\n> > > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> > > \n\n> > > _______________________________________________\n> > > Lightning-dev mailing list\n> > > Lightning-dev at lists.linuxfoundation.org\n> > > https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n\n> -------------- next part --------------\n> An HTML attachment was scrubbed...\n> URL: http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221208/52e3595c/attachment.html\n> \n\n> \n\n> ------------------------------\n> \n\n> Subject: Digest Footer\n> \n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n> \n\n> \n\n> ------------------------------\n> \n\n> End of Lightning-dev Digest, Vol 88, Issue 12\n> *********************************************\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: publickey - stalker.loki at protonmail.ch - 0x96FE6FEA.asc\nType: application/pgp-keys\nSize: 1775 bytes\nDesc: not available\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221209/c8590258/attachment-0001.bin>\n-------------- next part --------------\nA non-text attachment was scrubbed...\nName: signature.asc\nType: application/pgp-signature\nSize: 509 bytes\nDesc: OpenPGP digital signature\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221209/c8590258/attachment-0001.sig>"
            }
        ],
        "thread_summary": {
            "title": "Jamming mitigation call",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Antoine Riard",
                "Loki Verloren",
                "Clara Shikhelman"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 24882
        }
    },
    {
        "title": "[Lightning-dev] \"Updates Overflow\" Attacks against Two-Party Eltoo ?",
        "thread_messages": [
            {
                "author": "Antoine Riard",
                "date": "2022-12-13T01:38:43",
                "message_text_only": "Hi list,\n\nThe following post describes a potential attack vector against eltoo-based\nLightning channels, from my understanding also including the recent\ntwo-party eltoo w/ punishment construction. While I think this concern has\nbeen known for a while among devs, and I believe it's mitigable by adopting\nan adequate fee-bumping strategy, I still wonder how exactly it affects\neltoo-based constructions.\n\nAFAICT, the eltoo 2-stage proposal relies on a serie of pre-signed update\ntransactions, of which in the optimistic case only one of them confirms.\nThere is a script-spend path, where an update transaction N can spend an\nupdate transaction K, assuming K<N and an aggregated musig for the\nchecksigverify.\n\nThe attack purpose is to delay the confirmation of the final settlement\ntransaction S, to double-spend a HTLC forwarded by a routing hop. I.e you\nhave Ned the routing hop receiving the HTLC from Mallory upstream and\nsending the HTLC to Malicia downstream. Thanks to the cltv_expiry_delta,\nthe HTLC forward should be safe as Ned can timeout the HTLC on the\nNed-Malicia link before it is timed-out by Mallory on the Mallory-Ned link.\nIn case of timeout failure, Malicia can claim the HTLC forward with the\ncorresponding preimage, at the same block height than Mallory timeout the\nHTLC, effectively double-spending Ned.\n\nThe cltv_expiry_delta requested by Ned is equal to N=144.\n\nThe attack scenario works in the following way: Malicia updates the Eltoo\nchannel N time, getting the possession of N update transactions. At block\nA, she breaks the channel and confirms the update transaction 0 by\nattaching a feerate equal to or superior to top mempool block space + 1\nsat. At each new block, she iterates by confirming the next update\ntransaction, i.e update transaction 1 at block A+1, update transaction\ntransaction 2 at block A+2, update transaction 3 at block A+3, ...\n\n>From Ned's viewpoint, there is limited rationality of the network mempools,\nas such each punishment transaction R, as it's confirmation could have been\ndelay due to \"honest\" slow propagation on the network is likely to be\npre-signed with top mempool block space feerate, but not more to save on\nfees. Therefore, transaction RN.0 should fail to punish update transaction\n0 as it's double-spent by update transaction 1, transaction RN.1 should\nfail to punish update transaction 1 as it's double-spent by update\ntransaction 2, transaction RN.2 should fail to punish update transaction 2\nas it's double-spent by update transaction 3...\n\nWhile there is a RBF-race, I think this can be easily won by Malicia by\nmass-connecting on the transaction-relay network and ignoring the Core\ntransaction-relay delay timers (here for privacy purposes iirc).\n\nIf it holds, I think the attack is economically opportun as long as the sum\nof the chain of update transactions weight multiplied by the spent feerate\nis inferior to the sum of HTLC values stolen (upper bounded to\n`max_htlc_value_in_flight_msat`, not `funding_satoshis`). The attack could\nbe more sound in periods of low-fee, as the number of HTLC exploitable is\nhigher.\n\nA mitigation could be for a fee-bumping strategy to adopt a scorched\napproach when the HTLC-timeout is approaching, and there is a corresponding\nincoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\nincoming HTLC expiry), probably 100% of the HTLC value should be burnt in\nupdate transaction fees.\n\nI think some implementations in the LN-penalty are already doing \"upward\"\nfee-bumping frequency, while I believe it reduces the attack surface, I\nstill think there is an exploitable window for \"update overflow\" attack.\nE.g in LDK justice transactions are bumped by 25% every block according to\na height timer schedule [0].\n\nAssuming the attack holds, and scorched approach are adopted by default to\nmitigate this concern, there is a second-order concern, we might open\nLightning channels to miner-harvesting attacks, where the confirmation of\nthe update transactions are deferred to kick-out the scorched earth\nreaction of the fee-bumping engine. In my opinion, this would be still an\nimprovement, as we're moving a (plausible) security risk triggerable by a\nLightning counterparty to (hypothetical) one triggerable by a wide\ncoalition of miners.\n\nThere is another caveat, it sounds if the update transaction can be\nmalleable (i.e SIGHASH_SINGLE|ANYONECANPAY), update transactions across\nLightning channels could be aggregated by the attacker, changing the\neconomy there in a way defavorable to the victims. I.e the attacker can\nselect the targeted channels, but the victim cannot coordinate with each\nother to respond with a collective fee-bumping.\n\nIs the understanding of the two-party eltoo construction correct, and this\n\"update overflow\" attack is sound and economically opportun ? If it holds,\nI still wonder if we have variants playing with mempool descendant limits.\nIn all cases, it sounds to me the implications are more in the way\nfee-bumping is implemented by Lightning softwares rather than directly on\neltoo-based constructions, I don't see an immediate way to address it by\nthe construction itself.\n\nMistakes and confusions are my own.\n\nAntoine\n\n[0]\nhttps://github.com/lightningdevkit/rust-lightning/blob/5e14c24a11f610ab8c402f788ec5bd637e9e24af/lightning/src/chain/onchaintx.rs#L505\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221212/d9abd7ad/attachment.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-12-13T03:51:40",
                "message_text_only": "On Mon, Dec 12, 2022 at 08:38:43PM -0500, Antoine Riard wrote:\n> The attack purpose is to delay the confirmation of the final settlement\n> transaction S, to double-spend a HTLC forwarded by a routing hop.\n> The cltv_expiry_delta requested by Ned is equal to N=144.\n\nI believe what you're suggesting here is:\n\n  Mallory has two channels with Bob, M1 and M2. Both have a to_self_delay\n  of 144 blocks. In that case cltv_expiry_delay should include some slack,\n  I'm going to assume it's 154 blocks in total.\n\n  Mallory forwards a large payment, M1->Bob->M2.\n\n  Mallory claims the funds on M2 just prior to the timeout, but\n  goes offline on M1.\n\n  Bob chose the timeout for M2 via cltv_expiry_delay, so now has 154\n  blocks before the CLTV on the M1->Bob payment expires.\n\nIn this scenario, under the two-party eltoo scheme, Bob should:\n\n  1) immediately broadcast the most recent UB.n state for M1/Bob,\n     aiming for this to be confirmed within 5 blocks\n\n  2) wait 144 blocks for the relative timelock to expire\n\n  3) broadcast SB.n to finalise the funds, and immediately claim the\n     large HTLC. providing this confirms within 5 blocks, it will confirm\n     before the HTLC timelock expires, and Mallory will have been unable\n     to claim the funds.\n\nThe only transactions Mallory could broadcast are:\n\n  prior to (1): UA.k (k <= n) -- However this allows Bob to immediately\n  broadcast one of either CA.n or RA.n, and will then have ~150 blocks\n  to claim the HTLC before its timeout\n\n  during (2): CA.n -- Again, this allows Bob to claim the HTLC\n  immediately, prior to its timeout\n\nThe only delaying attack with repeated transactions comes if Bob\nbroadcasts an old state UB.k (k < n), in which case Mallory can broadcast\n(n-k) WA.i watchtower transactions prior to finalising the state. However\nif Bob *only* has old state, Mallory can simply broadcast WA.n, at which\npoint Bob can do nothing, as (by assumption) he doesn't have access\nto current state and thus doesn't have SB.n to broadcast it.\n\n> The attack scenario works in the following way: Malicia updates the Eltoo\n> channel N time, getting the possession of N update transactions. At block\n> A, she breaks the channel and confirms the update transaction 0 by\n> attaching a feerate equal to or superior to top mempool block space + 1\n> sat. At each new block, she iterates by confirming the next update\n> transaction, i.e update transaction 1 at block A+1, update transaction\n> transaction 2 at block A+2, update transaction 3 at block A+3, ...\n\nI think traditional eltoo envisages being able to spend update transaction\n1 immediately, without having to wait for the next block.  This might\nnot be compatible with the version 3 relay rules that are being thought\nabout, though, and presumably would hit ancestor limits.\n\nI think a simple way to avoid that problem would be for eltoo nodes\nto have a priority tx relay network -- if they see a channel close to\nstate N, always replace any txs closing to an earlier state K<N, and\nalways quickly relay that close to all other peers. There's no reason\nto assume the bad guys have the best access to the network when we can\nwrite code so that the honest participants have it instead.\n\n> From Ned's viewpoint, there is limited rationality of the network mempools,\n> as such each punishment transaction R, as it's confirmation could have been\n> delay due to \"honest\" slow propagation on the network is likely to be\n> pre-signed with top mempool block space feerate, but not more to save on\n> fees. Therefore, transaction RN.0 should fail to punish update transaction\n> 0 as it's double-spent by update transaction 1, transaction RN.1 should\n> fail to punish update transaction 1 as it's double-spent by update\n> transaction 2, transaction RN.2 should fail to punish update transaction 2\n> as it's double-spent by update transaction 3...\n\nIn the two-party scheme, the only transaction Mallory can broadcast\nafter sending UA.k and having it confirmed on chain is SA.k, and that\nonly after a 144 block relative timelock. UA.(k+1) etc only spend the\nfunding output, but that has already been spent by UA.k.\n\nCheers,\naj"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-14T01:22:55",
                "message_text_only": "Hi AJ,\n\nI believe we're in sync on the attack description.\n\n>  prior to (1): UA.k (k <= n) -- However this allows Bob to immediately\n>  broadcast one of either CA.n or RA.n, and will then have ~150 blocks\n>  to claim the HTLC before its timeout\n\n>From my understanding, with two party eltoo w/punihsment, UA.k has a\ntapscript path with \"1 CHECKSIGVERIFY k<n CLTV\", where the internal pubkey\nsubstituted is \"musig(A,B)/1. Mallory should receive Bob's signature for\nUA.k, though also UA.k+1, UA.k+2, UAk+3, until k=n.\n\nOr is this a tapscript only existing for the dual-funding case ? I think\nthis a bit unclear from the gist construction, how Mallory is restrained to\nuse the tapscript path on UA.k, with UA.k+1 as she should be in possession\nof Bob's signature for this state.\n\n> I think traditional eltoo envisages being able to spend update transaction\n> 1 immediately, without having to wait for the next block.  This might\n> not be compatible with the version 3 relay rules that are being thought\n> about, though, and presumably would hit ancestor limits.\n\nWhile update transaction 1 could spend update transaction 0 immediately,\nthere is no reliable knowledge by U*.1 transaction broadcaster of the state\nof the network mempools. I believe the update transactions themselves could\nbe used to partition network mempools in multiple subsets (at least this is\nachievable under LN-penalty with using old revoked states).\n\n> I think a simple way to avoid that problem would be for eltoo nodes\n> to have a priority tx relay network -- if they see a channel close to\n> state N, always replace any txs closing to an earlier state K<N, and\n> always quickly relay that close to all other peers. There's no reason\n> to assume the bad guys have the best access to the network when we can\n> write code so that the honest participants have it instead.\n\nWhile I think this solution of eltoo nodes quickly replacing any state K\nprevious to the latest state N, there is no guarantee the latest state K\ndoesn't offer a higher feerate than state N, making it more attractive to\nthe miners.\n\nOne other solution could be a p2p extension allowing an update transaction\nN to be \"blindly\" rebinded on any update transaction K, with K < N, by\npointing to the channel funding output, and a per-counterparty ancestor\nlimit enforced as a policy rule (otherwise the malicious counterparty could\nstill buy all the ancestor limits).\n\nA more sophisticated solution could be to \"trim\" the counterparty ability\nto confirm multiple update transactions with some TLUV mechanism.\n\n> In the two-party scheme, the only transaction Mallory can broadcast\n> after sending UA.k and having it confirmed on chain is SA.k, and that\n> only after a 144 block relative timelock. UA.(k+1) etc only spend the\n> funding output, but that has already been spent by UA.k.\n\nSee above question on the existence of a tapscript 1 path in update\ntransaction, and by which transaction type it could/should be spent. I\nthink the crux of the attack's soundness (or not) against two parties eltoo\nw/ punishment relies here. AFAICT, if there is an unbounded spending path\ncycle introduced for one of the counterparties, you're exposed to \"eltoo\nstates overflow\".\n\nBest,\nAntoine\n\nLe lun. 12 d\u00e9c. 2022 \u00e0 22:51, Anthony Towns <aj at erisian.com.au> a \u00e9crit :\n\n> On Mon, Dec 12, 2022 at 08:38:43PM -0500, Antoine Riard wrote:\n> > The attack purpose is to delay the confirmation of the final settlement\n> > transaction S, to double-spend a HTLC forwarded by a routing hop.\n> > The cltv_expiry_delta requested by Ned is equal to N=144.\n>\n> I believe what you're suggesting here is:\n>\n>   Mallory has two channels with Bob, M1 and M2. Both have a to_self_delay\n>   of 144 blocks. In that case cltv_expiry_delay should include some slack,\n>   I'm going to assume it's 154 blocks in total.\n>\n>   Mallory forwards a large payment, M1->Bob->M2.\n>\n>   Mallory claims the funds on M2 just prior to the timeout, but\n>   goes offline on M1.\n>\n>   Bob chose the timeout for M2 via cltv_expiry_delay, so now has 154\n>   blocks before the CLTV on the M1->Bob payment expires.\n>\n> In this scenario, under the two-party eltoo scheme, Bob should:\n>\n>   1) immediately broadcast the most recent UB.n state for M1/Bob,\n>      aiming for this to be confirmed within 5 blocks\n>\n>   2) wait 144 blocks for the relative timelock to expire\n>\n>   3) broadcast SB.n to finalise the funds, and immediately claim the\n>      large HTLC. providing this confirms within 5 blocks, it will confirm\n>      before the HTLC timelock expires, and Mallory will have been unable\n>      to claim the funds.\n>\n> The only transactions Mallory could broadcast are:\n>\n>   prior to (1): UA.k (k <= n) -- However this allows Bob to immediately\n>   broadcast one of either CA.n or RA.n, and will then have ~150 blocks\n>   to claim the HTLC before its timeout\n>\n>   during (2): CA.n -- Again, this allows Bob to claim the HTLC\n>   immediately, prior to its timeout\n>\n> The only delaying attack with repeated transactions comes if Bob\n> broadcasts an old state UB.k (k < n), in which case Mallory can broadcast\n> (n-k) WA.i watchtower transactions prior to finalising the state. However\n> if Bob *only* has old state, Mallory can simply broadcast WA.n, at which\n> point Bob can do nothing, as (by assumption) he doesn't have access\n> to current state and thus doesn't have SB.n to broadcast it.\n>\n> > The attack scenario works in the following way: Malicia updates the Eltoo\n> > channel N time, getting the possession of N update transactions. At block\n> > A, she breaks the channel and confirms the update transaction 0 by\n> > attaching a feerate equal to or superior to top mempool block space + 1\n> > sat. At each new block, she iterates by confirming the next update\n> > transaction, i.e update transaction 1 at block A+1, update transaction\n> > transaction 2 at block A+2, update transaction 3 at block A+3, ...\n>\n> I think traditional eltoo envisages being able to spend update transaction\n> 1 immediately, without having to wait for the next block.  This might\n> not be compatible with the version 3 relay rules that are being thought\n> about, though, and presumably would hit ancestor limits.\n>\n> I think a simple way to avoid that problem would be for eltoo nodes\n> to have a priority tx relay network -- if they see a channel close to\n> state N, always replace any txs closing to an earlier state K<N, and\n> always quickly relay that close to all other peers. There's no reason\n> to assume the bad guys have the best access to the network when we can\n> write code so that the honest participants have it instead.\n>\n> > From Ned's viewpoint, there is limited rationality of the network\n> mempools,\n> > as such each punishment transaction R, as it's confirmation could have\n> been\n> > delay due to \"honest\" slow propagation on the network is likely to be\n> > pre-signed with top mempool block space feerate, but not more to save on\n> > fees. Therefore, transaction RN.0 should fail to punish update\n> transaction\n> > 0 as it's double-spent by update transaction 1, transaction RN.1 should\n> > fail to punish update transaction 1 as it's double-spent by update\n> > transaction 2, transaction RN.2 should fail to punish update transaction\n> 2\n> > as it's double-spent by update transaction 3...\n>\n> In the two-party scheme, the only transaction Mallory can broadcast\n> after sending UA.k and having it confirmed on chain is SA.k, and that\n> only after a 144 block relative timelock. UA.(k+1) etc only spend the\n> funding output, but that has already been spent by UA.k.\n>\n> Cheers,\n> aj\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221213/caed9efb/attachment-0001.html>"
            },
            {
                "author": "Anthony Towns",
                "date": "2022-12-14T05:57:06",
                "message_text_only": "On Tue, Dec 13, 2022 at 08:22:55PM -0500, Antoine Riard wrote:\n> >  prior to (1): UA.k (k <= n) -- However this allows Bob to immediately\n> >  broadcast one of either CA.n or RA.n, and will then have ~150 blocks\n> >  to claim the HTLC before its timeout\n> From my understanding, with two party eltoo w/punihsment, UA.k has a\n> tapscript path with \"1 CHECKSIGVERIFY k<n CLTV\", where the internal pubkey\n> substituted is \"musig(A,B)/1. Mallory should receive Bob's signature for\n> UA.k, though also UA.k+1, UA.k+2, UAk+3, until k=n.\n\nYes, Mallory can be assumed to be able to generate signatures for UA.0\nthrough UA.n. They all spend the funding transaction (only) though,\nso she can only choose one of them, which I called UA.k above.\n\nMore particular, I'm imagining scriptPubKeys something like:\n\n  F: taproot(AB)\n\n  UA.n: taproot(AB/1, \"IF CODESEP <n> CLTV DROP ENDIF OP_1 CHECKSIG\")\n  WB.n: taproot(AB/1, \"IF CODESEP <n> CLTV DROP ENDIF OP_1 CHECKSIG\")\n\n  UB.n: taproot(AB/2, \"IF CODESEP <n> CLTV DROP ENDIF OP_1 CHECKSIG\")\n  WA.n: taproot(AB/2, \"IF CODESEP <n> CLTV DROP ENDIF OP_1 CHECKSIG\")\n\nwhere AB=musig(A,B) and AB/1 and AB/2 are unhardened HD subkeys of AB.\n(The outputs of SA/RA/CA and SB/RB/CB are the balances and active HTLCs)\n\nThen I think the following setup works to allow each transaction to only\nspend from the transactions that it's supposed to:\n\n  UA.n have ALL or SINGLE|ANYONECANPAY signatures spending F with key\n    AB.\n\n  CA.n/WA.n have ANYPREVOUTANYSCRIPT signatures with codesep_pos=2\n    against AB/2, with locktime set to n\n\n  RA.n has an ANYPREVOUTANYSCRIPT signature with codesep_pos=2\n    against AB/2, with locktime set to n-1\n\n  SA.n has an ANYPREVOUT signature with codesep_pos=FFFFFFFF\n    against AB/1, with nSequence enforcing to_self_delay\n\nB's signatures are similar, swapping AB/2 and AB/1.\n\n(In order to do the fast forward stuff via scriptless scripts, you also\nneed F to have an \"A CHECKSIGVERIFY B CHECKSIG\" tapscript path as well,\nand there's probably other things I've glossed over)\n\n> Or is this a tapscript only existing for the dual-funding case ? I think\n> this a bit unclear from the gist construction, how Mallory is restrained to\n> use the tapscript path on UA.k, with UA.k+1 as she should be in possession\n> of Bob's signature for this state.\n\nYou lock Mallory into using a particular signature with a particular\nscript template by only using the key for that signature within that\nscript template, and you lock them into using a particular path through\nthat script via use of OP_CODESEPARATOR.\n\n> While update transaction 1 could spend update transaction 0 immediately,\n> there is no reliable knowledge by U*.1 transaction broadcaster of the state\n> of the network mempools.\n\nThat doesn't need to be true; we can easily have lightning nodes\ngossip mempool state for channel closes by pattern matching on the\nclose transaction, including offering \"catchup\" info for nodes that\nwere offline, even if that isn't something we do for regular mempool\ntransactions.\n\nI don't really think getting into the weeds on that now is very productive\nthough; it's still an open question whether we can get eltoo working in\na laboratory environment, let alone in the wild.\n\n> While I think this solution of eltoo nodes quickly replacing any state K\n> previous to the latest state N, there is no guarantee the latest state K\n> doesn't offer a higher feerate than state N, making it more attractive to\n> the miners.\n\nI think there's really two situations here: one is where miners are\njust running friendly mempool software that tries to do right by the\nnetwork, in which case \"always update to the newest state, even if the\nfee rate goes down\" is probably workable; the other is where miners want\nto profit maximise on every single block and will run MEV software; in\nwhich case all we need is for the final state to be relayed -- provided\nits at a reasonable feerate, the MEV miner will include it on top of the\nhigh-fee paying chain of earlier states, even if that would mean it has\n\"too many\" in-mempool descendants.\n\nCheers,\naj"
            },
            {
                "author": "Greg Sanders",
                "date": "2022-12-13T14:47:32",
                "message_text_only": "Hi Antoine,\n\nNothing you say here(about vanilla eltoo) sounds absurd.\n\n> Therefore, transaction RN.0 should fail to punish update transaction 0 as\nit's double-spent by update transaction 1, transaction RN.1 should fail to\npunish update transaction 1 as it's double-spent by update transaction 2,\ntransaction RN.2 should fail to punish update transaction 2 as it's\ndouble-spent by update transaction 3...\n\n>While there is a RBF-race, I think this can be easily won by Malicia by\nmass-connecting on the transaction-relay network and ignoring the Core\ntransaction-relay delay timers (here for privacy purposes iirc).\n\nRight, there are some network-level games that can be played, however\nhonest participants can be given a leg up through as AJ notes, alternative\nrelays, or even a \"rebinder\" widget which means only the single highest fee\nbidding copy of the final update transaction has to make it to the miners'\nmempool. So if the honest party bids X% of the HTLC value in fees, the\nattacker will be paying more than that every single block,\nconstantly racing, until it loses either a mempool race or the latest bid.\n\nI'm starting simple and assuming we don't need all this machinery, and hope\nthe risk of counterparty either losing the race a single time, or being\noutbid a single time is enough to dissuade an attack at all.\n\n> A mitigation could be for a fee-bumping strategy to adopt a scorched\napproach when the HTLC-timeout is approaching, and there is a corresponding\nincoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\nincoming HTLC expiry), probably 100% of the HTLC value should be burnt in\nupdate transaction fees.\n\nI kind of always thought that's how HTLCs would have worked in theory and\npractice eventually. As the clock runs down you're willing to spend more to\ntake less of the full value.\n\n> Assuming the attack holds, and scorched approach are adopted by default\nto mitigate this concern, there is a second-order concern, we might open\nLightning channels to miner-harvesting attacks, where the confirmation of\nthe update transactions are deferred to kick-out the scorched earth\nreaction of the fee-bumping engine. In my opinion, this would be still an\nimprovement, as we're moving a (plausible) security risk triggerable by a\nLightning counterparty to (hypothetical) one triggerable by a wide\ncoalition of miners.\n\nAs I said before, I think this is already the case. We're assuming\nliveliness of blockchain for these contracts, if a unilateral close gets\ntargeted by a large fraction of miners, I don't think eltoo is the risk,\nit's the HTLC constract that's the risk.\n\n> There is another caveat, it sounds if the update transaction can be\nmalleable (i.e SIGHASH_SINGLE|ANYONECANPAY), update transactions across\nLightning channels could be aggregated by the attacker, changing the\neconomy there in a way defavorable to the victims. I.e the attacker can\nselect the targeted channels, but the victim cannot coordinate with each\nother to respond with a collective fee-bumping.\n\nIn my current eltoo design, I'm assuming *by policy* APO (V3?) transactions\ncan only have one input, and each transaction is only allowed a single\nephemeral anchor which is attached but not committed to by the\nSIGHASH_SINGLE|APOAS signature. This results in a 1-input-2-output\ntransaction that isn't malleable. If and when we figure out how to un-pin\nthese kinds of transactions, this policy can be relaxed, and we can get the\nbenefits of aggregated transactions.\n\nCheers,\nGreg\n\nOn Mon, Dec 12, 2022 at 8:39 PM Antoine Riard <antoine.riard at gmail.com>\nwrote:\n\n> Hi list,\n>\n> The following post describes a potential attack vector against eltoo-based\n> Lightning channels, from my understanding also including the recent\n> two-party eltoo w/ punishment construction. While I think this concern has\n> been known for a while among devs, and I believe it's mitigable by adopting\n> an adequate fee-bumping strategy, I still wonder how exactly it affects\n> eltoo-based constructions.\n>\n> AFAICT, the eltoo 2-stage proposal relies on a serie of pre-signed update\n> transactions, of which in the optimistic case only one of them confirms.\n> There is a script-spend path, where an update transaction N can spend an\n> update transaction K, assuming K<N and an aggregated musig for the\n> checksigverify.\n>\n> The attack purpose is to delay the confirmation of the final settlement\n> transaction S, to double-spend a HTLC forwarded by a routing hop. I.e you\n> have Ned the routing hop receiving the HTLC from Mallory upstream and\n> sending the HTLC to Malicia downstream. Thanks to the cltv_expiry_delta,\n> the HTLC forward should be safe as Ned can timeout the HTLC on the\n> Ned-Malicia link before it is timed-out by Mallory on the Mallory-Ned link.\n> In case of timeout failure, Malicia can claim the HTLC forward with the\n> corresponding preimage, at the same block height than Mallory timeout the\n> HTLC, effectively double-spending Ned.\n>\n> The cltv_expiry_delta requested by Ned is equal to N=144.\n>\n> The attack scenario works in the following way: Malicia updates the Eltoo\n> channel N time, getting the possession of N update transactions. At block\n> A, she breaks the channel and confirms the update transaction 0 by\n> attaching a feerate equal to or superior to top mempool block space + 1\n> sat. At each new block, she iterates by confirming the next update\n> transaction, i.e update transaction 1 at block A+1, update transaction\n> transaction 2 at block A+2, update transaction 3 at block A+3, ...\n>\n> From Ned's viewpoint, there is limited rationality of the network\n> mempools, as such each punishment transaction R, as it's confirmation could\n> have been delay due to \"honest\" slow propagation on the network is likely\n> to be pre-signed with top mempool block space feerate, but not more to save\n> on fees. Therefore, transaction RN.0 should fail to punish update\n> transaction 0 as it's double-spent by update transaction 1, transaction\n> RN.1 should fail to punish update transaction 1 as it's double-spent by\n> update transaction 2, transaction RN.2 should fail to punish update\n> transaction 2 as it's double-spent by update transaction 3...\n>\n> While there is a RBF-race, I think this can be easily won by Malicia by\n> mass-connecting on the transaction-relay network and ignoring the Core\n> transaction-relay delay timers (here for privacy purposes iirc).\n>\n> If it holds, I think the attack is economically opportun as long as the\n> sum of the chain of update transactions weight multiplied by the spent\n> feerate is inferior to the sum of HTLC values stolen (upper bounded to\n> `max_htlc_value_in_flight_msat`, not `funding_satoshis`). The attack could\n> be more sound in periods of low-fee, as the number of HTLC exploitable is\n> higher.\n>\n> A mitigation could be for a fee-bumping strategy to adopt a scorched\n> approach when the HTLC-timeout is approaching, and there is a corresponding\n> incoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\n> incoming HTLC expiry), probably 100% of the HTLC value should be burnt in\n> update transaction fees.\n>\n> I think some implementations in the LN-penalty are already doing \"upward\"\n> fee-bumping frequency, while I believe it reduces the attack surface, I\n> still think there is an exploitable window for \"update overflow\" attack.\n> E.g in LDK justice transactions are bumped by 25% every block according to\n> a height timer schedule [0].\n>\n> Assuming the attack holds, and scorched approach are adopted by default to\n> mitigate this concern, there is a second-order concern, we might open\n> Lightning channels to miner-harvesting attacks, where the confirmation of\n> the update transactions are deferred to kick-out the scorched earth\n> reaction of the fee-bumping engine. In my opinion, this would be still an\n> improvement, as we're moving a (plausible) security risk triggerable by a\n> Lightning counterparty to (hypothetical) one triggerable by a wide\n> coalition of miners.\n>\n> There is another caveat, it sounds if the update transaction can be\n> malleable (i.e SIGHASH_SINGLE|ANYONECANPAY), update transactions across\n> Lightning channels could be aggregated by the attacker, changing the\n> economy there in a way defavorable to the victims. I.e the attacker can\n> select the targeted channels, but the victim cannot coordinate with each\n> other to respond with a collective fee-bumping.\n>\n> Is the understanding of the two-party eltoo construction correct, and this\n> \"update overflow\" attack is sound and economically opportun ? If it holds,\n> I still wonder if we have variants playing with mempool descendant limits.\n> In all cases, it sounds to me the implications are more in the way\n> fee-bumping is implemented by Lightning softwares rather than directly on\n> eltoo-based constructions, I don't see an immediate way to address it by\n> the construction itself.\n>\n> Mistakes and confusions are my own.\n>\n> Antoine\n>\n> [0]\n> https://github.com/lightningdevkit/rust-lightning/blob/5e14c24a11f610ab8c402f788ec5bd637e9e24af/lightning/src/chain/onchaintx.rs#L505\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221213/45a189de/attachment.html>"
            },
            {
                "author": "Antoine Riard",
                "date": "2022-12-14T01:41:47",
                "message_text_only": "Hi Greg,\n\n> Right, there are some network-level games that can be played, however\n> honest participants can be given a leg up through as AJ notes, alternative\n> relays, or even a \"rebinder\" widget which means only the single highest\nfee\n> bidding copy of the final update transaction has to make it to the miners'\n> mempool. So if the honest party bids X% of the HTLC value in fees, the\n> attacker will be paying more than that every single block,\n> constantly racing, until it loses either a mempool race or the latest bid.\n\nYes, I think you could have a p2p extension enabling \"blind\" rebinding on a\nchain of update transactions by pointing to the known channel funding\noutput. However, the attacker might still pay the mempool feerate (assuming\nnversion=3), and win any round of the race. As noted in the description,\nthe attack opportunity relies on some economic bounds, like the HTLC value,\nthe CLTV expiry delta and the mempool backlog.\n\n> A mitigation could be for a fee-bumping strategy to adopt a scorched\napproach when the HTLC-timeout is approaching, and there is a corresponding\nincoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\nincoming HTLC expiry), probably 100% of the HTLC value should be burnt in\nupdate transaction fees.\n\n> I kind of always thought that's how HTLCs would have worked in theory and\n> practice eventually. As the clock runs down you're willing to spend more\nto\n> take less of the full value.\n\nOne of the biggest unknown from a fee-bumping strategy design is the\nfee-bump delta you should attach in function of your prediction of mempool\nbacklogs. To the best of my knowledge, this is not how current generations\nof fee-estimators are working.\n\n> As I said before, I think this is already the case. We're assuming\n> liveliness of blockchain for these contracts, if a unilateral close gets\n> targeted by a large fraction of miners, I don't think eltoo is the risk,\n> it's the HTLC constract that's the risk.\n\nYes, here it's just under LN-penalty. I think the rational fee-bumping\nstrategy is to target top mempool feerate backlog (assuming nversion=3), as\nduring the HTLC CLTV delay, there is no competition from the counterparty.\nSo I agree the HTLC contract is the risk itself, though the dimensions of\nthe miners bribery attacks might be changed under eltoo.\n\n> In my current eltoo design, I'm assuming *by policy* APO (V3?)\ntransactions\n> can only have one input, and each transaction is only allowed a single\n> ephemeral anchor which is attached but not committed to by the\n> SIGHASH_SINGLE|APOAS signature. This results in a 1-input-2-output\n> transaction that isn't malleable. If and when we figure out how to un-pin\n> these kinds of transactions, this policy can be relaxed, and we can get\nthe\n> benefits of aggregated transactions.\n\nI think this is the most conservative design for now, to restrain\nmalleability of transactions to the minimum, as aggregation transactions\ncan be played out by honest channel participants by an adversary.\n\nBest,\nAntoine\n\nLe mar. 13 d\u00e9c. 2022 \u00e0 09:47, Greg Sanders <gsanders87 at gmail.com> a \u00e9crit :\n\n> Hi Antoine,\n>\n> Nothing you say here(about vanilla eltoo) sounds absurd.\n>\n> > Therefore, transaction RN.0 should fail to punish update transaction 0\n> as it's double-spent by update transaction 1, transaction RN.1 should fail\n> to punish update transaction 1 as it's double-spent by update transaction\n> 2, transaction RN.2 should fail to punish update transaction 2 as it's\n> double-spent by update transaction 3...\n>\n> >While there is a RBF-race, I think this can be easily won by Malicia by\n> mass-connecting on the transaction-relay network and ignoring the Core\n> transaction-relay delay timers (here for privacy purposes iirc).\n>\n> Right, there are some network-level games that can be played, however\n> honest participants can be given a leg up through as AJ notes, alternative\n> relays, or even a \"rebinder\" widget which means only the single highest fee\n> bidding copy of the final update transaction has to make it to the miners'\n> mempool. So if the honest party bids X% of the HTLC value in fees, the\n> attacker will be paying more than that every single block,\n> constantly racing, until it loses either a mempool race or the latest bid.\n>\n> I'm starting simple and assuming we don't need all this machinery, and\n> hope the risk of counterparty either losing the race a single time, or\n> being outbid a single time is enough to dissuade an attack at all.\n>\n> > A mitigation could be for a fee-bumping strategy to adopt a scorched\n> approach when the HTLC-timeout is approaching, and there is a corresponding\n> incoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\n> incoming HTLC expiry), probably 100% of the HTLC value should be burnt in\n> update transaction fees.\n>\n> I kind of always thought that's how HTLCs would have worked in theory and\n> practice eventually. As the clock runs down you're willing to spend more to\n> take less of the full value.\n>\n> > Assuming the attack holds, and scorched approach are adopted by default\n> to mitigate this concern, there is a second-order concern, we might open\n> Lightning channels to miner-harvesting attacks, where the confirmation of\n> the update transactions are deferred to kick-out the scorched earth\n> reaction of the fee-bumping engine. In my opinion, this would be still an\n> improvement, as we're moving a (plausible) security risk triggerable by a\n> Lightning counterparty to (hypothetical) one triggerable by a wide\n> coalition of miners.\n>\n> As I said before, I think this is already the case. We're assuming\n> liveliness of blockchain for these contracts, if a unilateral close gets\n> targeted by a large fraction of miners, I don't think eltoo is the risk,\n> it's the HTLC constract that's the risk.\n>\n> > There is another caveat, it sounds if the update transaction can be\n> malleable (i.e SIGHASH_SINGLE|ANYONECANPAY), update transactions across\n> Lightning channels could be aggregated by the attacker, changing the\n> economy there in a way defavorable to the victims. I.e the attacker can\n> select the targeted channels, but the victim cannot coordinate with each\n> other to respond with a collective fee-bumping.\n>\n> In my current eltoo design, I'm assuming *by policy* APO (V3?)\n> transactions can only have one input, and each transaction is only allowed\n> a single ephemeral anchor which is attached but not committed to by the\n> SIGHASH_SINGLE|APOAS signature. This results in a 1-input-2-output\n> transaction that isn't malleable. If and when we figure out how to un-pin\n> these kinds of transactions, this policy can be relaxed, and we can get the\n> benefits of aggregated transactions.\n>\n> Cheers,\n> Greg\n>\n> On Mon, Dec 12, 2022 at 8:39 PM Antoine Riard <antoine.riard at gmail.com>\n> wrote:\n>\n>> Hi list,\n>>\n>> The following post describes a potential attack vector against\n>> eltoo-based Lightning channels, from my understanding also including the\n>> recent two-party eltoo w/ punishment construction. While I think this\n>> concern has been known for a while among devs, and I believe it's mitigable\n>> by adopting an adequate fee-bumping strategy, I still wonder how exactly it\n>> affects eltoo-based constructions.\n>>\n>> AFAICT, the eltoo 2-stage proposal relies on a serie of pre-signed update\n>> transactions, of which in the optimistic case only one of them confirms.\n>> There is a script-spend path, where an update transaction N can spend an\n>> update transaction K, assuming K<N and an aggregated musig for the\n>> checksigverify.\n>>\n>> The attack purpose is to delay the confirmation of the final settlement\n>> transaction S, to double-spend a HTLC forwarded by a routing hop. I.e you\n>> have Ned the routing hop receiving the HTLC from Mallory upstream and\n>> sending the HTLC to Malicia downstream. Thanks to the cltv_expiry_delta,\n>> the HTLC forward should be safe as Ned can timeout the HTLC on the\n>> Ned-Malicia link before it is timed-out by Mallory on the Mallory-Ned link.\n>> In case of timeout failure, Malicia can claim the HTLC forward with the\n>> corresponding preimage, at the same block height than Mallory timeout the\n>> HTLC, effectively double-spending Ned.\n>>\n>> The cltv_expiry_delta requested by Ned is equal to N=144.\n>>\n>> The attack scenario works in the following way: Malicia updates the Eltoo\n>> channel N time, getting the possession of N update transactions. At block\n>> A, she breaks the channel and confirms the update transaction 0 by\n>> attaching a feerate equal to or superior to top mempool block space + 1\n>> sat. At each new block, she iterates by confirming the next update\n>> transaction, i.e update transaction 1 at block A+1, update transaction\n>> transaction 2 at block A+2, update transaction 3 at block A+3, ...\n>>\n>> From Ned's viewpoint, there is limited rationality of the network\n>> mempools, as such each punishment transaction R, as it's confirmation could\n>> have been delay due to \"honest\" slow propagation on the network is likely\n>> to be pre-signed with top mempool block space feerate, but not more to save\n>> on fees. Therefore, transaction RN.0 should fail to punish update\n>> transaction 0 as it's double-spent by update transaction 1, transaction\n>> RN.1 should fail to punish update transaction 1 as it's double-spent by\n>> update transaction 2, transaction RN.2 should fail to punish update\n>> transaction 2 as it's double-spent by update transaction 3...\n>>\n>> While there is a RBF-race, I think this can be easily won by Malicia by\n>> mass-connecting on the transaction-relay network and ignoring the Core\n>> transaction-relay delay timers (here for privacy purposes iirc).\n>>\n>> If it holds, I think the attack is economically opportun as long as the\n>> sum of the chain of update transactions weight multiplied by the spent\n>> feerate is inferior to the sum of HTLC values stolen (upper bounded to\n>> `max_htlc_value_in_flight_msat`, not `funding_satoshis`). The attack could\n>> be more sound in periods of low-fee, as the number of HTLC exploitable is\n>> higher.\n>>\n>> A mitigation could be for a fee-bumping strategy to adopt a scorched\n>> approach when the HTLC-timeout is approaching, and there is a corresponding\n>> incoming HTLC. When the HTLC-timeout is near expiration (e.g X blocks from\n>> incoming HTLC expiry), probably 100% of the HTLC value should be burnt in\n>> update transaction fees.\n>>\n>> I think some implementations in the LN-penalty are already doing \"upward\"\n>> fee-bumping frequency, while I believe it reduces the attack surface, I\n>> still think there is an exploitable window for \"update overflow\" attack.\n>> E.g in LDK justice transactions are bumped by 25% every block according to\n>> a height timer schedule [0].\n>>\n>> Assuming the attack holds, and scorched approach are adopted by default\n>> to mitigate this concern, there is a second-order concern, we might open\n>> Lightning channels to miner-harvesting attacks, where the confirmation of\n>> the update transactions are deferred to kick-out the scorched earth\n>> reaction of the fee-bumping engine. In my opinion, this would be still an\n>> improvement, as we're moving a (plausible) security risk triggerable by a\n>> Lightning counterparty to (hypothetical) one triggerable by a wide\n>> coalition of miners.\n>>\n>> There is another caveat, it sounds if the update transaction can be\n>> malleable (i.e SIGHASH_SINGLE|ANYONECANPAY), update transactions across\n>> Lightning channels could be aggregated by the attacker, changing the\n>> economy there in a way defavorable to the victims. I.e the attacker can\n>> select the targeted channels, but the victim cannot coordinate with each\n>> other to respond with a collective fee-bumping.\n>>\n>> Is the understanding of the two-party eltoo construction correct, and\n>> this \"update overflow\" attack is sound and economically opportun ? If it\n>> holds, I still wonder if we have variants playing with mempool descendant\n>> limits. In all cases, it sounds to me the implications are more in the way\n>> fee-bumping is implemented by Lightning softwares rather than directly on\n>> eltoo-based constructions, I don't see an immediate way to address it by\n>> the construction itself.\n>>\n>> Mistakes and confusions are my own.\n>>\n>> Antoine\n>>\n>> [0]\n>> https://github.com/lightningdevkit/rust-lightning/blob/5e14c24a11f610ab8c402f788ec5bd637e9e24af/lightning/src/chain/onchaintx.rs#L505\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221213/0dc36ccc/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "\"Updates Overflow\" Attacks against Two-Party Eltoo ?",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Anthony Towns",
                "Antoine Riard",
                "Greg Sanders"
            ],
            "messages_count": 6,
            "total_messages_chars_count": 43693
        }
    },
    {
        "title": "[Lightning-dev] Unclear HTLC scenario",
        "thread_messages": [
            {
                "author": "Benjamin Weintraub",
                "date": "2022-12-13T14:51:17",
                "message_text_only": "Hi list,\n\n\nI have a question about how update_fail_htlcs are handled. Consider this scenario: a node, potentially adversarial, forwards an HTLC along a channel that does not have the funds to support a payment of that size. How does the recipient of the HTLC respond?\n\n\nI see this line in BOLT #2:\n\n\u201cuntil the corresponding HTLC is irrevocably committed in both sides' commitment transactions: MUST NOT send an update_fulfill_htlc, update_fail_htlc, or update_fail_malformed_htlc\"\n\n\nBut this seems confusing to me in the context of the scenario I suggested. Is it saying that even though the channel cannot support the payment, the nodes still need to commit to it?\n\n\nI assume that this interpretation is not correct, but then when is it okay for a node to send an update_fail_htlc? Immediately upon receiving an invalid transaction?\n\n\nAny insight you could provide would be great.\n\n\nThanks in advance,\n\nBen\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221213/056c715c/attachment-0001.html>"
            },
            {
                "author": "SomberNight",
                "date": "2022-12-13T15:53:51",
                "message_text_only": "Hi Ben,\n\nThis is handled earlier than update_fail_htlc: when the recipient sees the update_add_htlc, some sanity checks will fail and it won't commit it to the commitment tx.\n\nSee here:\nhttps://github.com/lightning/bolts/blame/a0bbe47b0278b4f152dbaa4f5fab2562413a217c/02-peer-protocol.md#L1036\n\n> 1. type: 128 (`update_add_htlc`)\n> [...]\n> A receiving node:\n> [...]\n>   - receiving an `amount_msat` that the sending node cannot afford at the current `feerate_per_kw` (while maintaining its channel reserve and any `to_local_anchor` and `to_remote_anchor` costs):\n>    - SHOULD send a `warning` and close the connection, or send an\n      `error` and fail the channel.\n\nIf the recipient decides to simply close the transport connection, the update_add_htlc message is forgotten (due to the rules of how channel_reestablish works), and the channel is back to a usable state.\n\nghost43\n\n------- Original Message -------\nOn Tuesday, December 13th, 2022 at 2:51 PM, Benjamin Weintraub via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n\n> Hi list,\n> \n> \n> \n> I have a question about how update_fail_htlcs are handled. Consider this scenario: a node, potentially adversarial, forwards an HTLC along a channel that does not have the funds to support a payment of that size. How does the recipient of the HTLC respond?\n> \n> \n> \n> I see this line in BOLT #2:\n> \n> \u201cuntil the corresponding HTLC is irrevocably committed in both sides' commitment transactions: MUST NOT send an\u00a0`update_fulfill_htlc`,\u00a0`update_fail_htlc`, or\u00a0`update_fail_malformed_htlc`\"\n> \n> \n> \n> But this seems confusing to me in the context of the scenario I suggested. Is it saying that even though the channel cannot support the payment, the nodes still need to commit to it?\n> \n> \n> \n> I assume that this interpretation is not correct, but then when is it okay for a node to send an update_fail_htlc? Immediately upon receiving an invalid transaction?\n> \n> \n> \n> Any insight you could provide would be great.\n> \n> \n> \n> Thanks in advance,\n> \n> Ben"
            },
            {
                "author": "Benjamin Weintraub",
                "date": "2022-12-13T20:36:02",
                "message_text_only": "Very helpful, thank you for the quick reply!\n\nBen\n________________________________\nFrom: SomberNight <somber.night at protonmail.com>\nSent: Tuesday, December 13, 2022 10:53\nTo: Benjamin Weintraub <weintraub.b at northeastern.edu>\nCc: Lightning-dev at lists.linuxfoundation.org <lightning-dev at lists.linuxfoundation.org>\nSubject: Re: [Lightning-dev] Unclear HTLC scenario\n\nHi Ben,\n\nThis is handled earlier than update_fail_htlc: when the recipient sees the update_add_htlc, some sanity checks will fail and it won't commit it to the commitment tx.\n\nSee here:\nhttps://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Flightning%2Fbolts%2Fblame%2Fa0bbe47b0278b4f152dbaa4f5fab2562413a217c%2F02-peer-protocol.md%23L1036&data=05%7C01%7Cweintraub.b%40northeastern.edu%7C5e9d13700f58406b671208dadd223e31%7Ca8eec281aaa34daeac9b9a398b9215e7%7C0%7C0%7C638065437441102846%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=6GUyG4x9dxZnhGZpIJY6SQBmA%2FH4%2Bcw8kkD3aQaNZ%2Bk%3D&reserved=0\n\n> 1. type: 128 (`update_add_htlc`)\n> [...]\n> A receiving node:\n> [...]\n>   - receiving an `amount_msat` that the sending node cannot afford at the current `feerate_per_kw` (while maintaining its channel reserve and any `to_local_anchor` and `to_remote_anchor` costs):\n>    - SHOULD send a `warning` and close the connection, or send an\n      `error` and fail the channel.\n\nIf the recipient decides to simply close the transport connection, the update_add_htlc message is forgotten (due to the rules of how channel_reestablish works), and the channel is back to a usable state.\n\nghost43\n\n------- Original Message -------\nOn Tuesday, December 13th, 2022 at 2:51 PM, Benjamin Weintraub via Lightning-dev <lightning-dev at lists.linuxfoundation.org> wrote:\n\n\n> Hi list,\n>\n>\n>\n> I have a question about how update_fail_htlcs are handled. Consider this scenario: a node, potentially adversarial, forwards an HTLC along a channel that does not have the funds to support a payment of that size. How does the recipient of the HTLC respond?\n>\n>\n>\n> I see this line in BOLT #2:\n>\n> \u201cuntil the corresponding HTLC is irrevocably committed in both sides' commitment transactions: MUST NOT send an `update_fulfill_htlc`, `update_fail_htlc`, or `update_fail_malformed_htlc`\"\n>\n>\n>\n> But this seems confusing to me in the context of the scenario I suggested. Is it saying that even though the channel cannot support the payment, the nodes still need to commit to it?\n>\n>\n>\n> I assume that this interpretation is not correct, but then when is it okay for a node to send an update_fail_htlc? Immediately upon receiving an invalid transaction?\n>\n>\n>\n> Any insight you could provide would be great.\n>\n>\n>\n> Thanks in advance,\n>\n> Ben\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20221213/aba37c8b/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Unclear HTLC scenario",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Benjamin Weintraub",
                "SomberNight"
            ],
            "messages_count": 3,
            "total_messages_chars_count": 6083
        }
    }
]