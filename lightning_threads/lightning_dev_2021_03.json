[
    {
        "title": "[Lightning-dev] Rescuing funding mistakes",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-03-11T00:24:32",
                "message_text_only": "TL;DR: We had a user promise the wrong txid for a funding tx[1].  This of\ncourse requires remote cooperation to get their funds back.  This lead\nme to a temporary solution, but Christian suggested a more wideranging\none.\n\nThe problem\n-----------\nWith single-sided[2] funding, the opener gives the txid and outnum of\nthe funding tx.  It gets the signature for the first (noop) commitment\ntx, and then broadcasts the funding tx.  If it screwed up, because they\nRBF the funding tx, or other subtle problems, they cannot access their\nfunds.  After some time, the remote node will give up and forget the\nchannel.\n\nThe hack\n--------\nI have added feature 104/105 as OPT_SHUTDOWN_WRONG_FUNDING, and added a\nTLV stream to the shutdown message, with 100 `wrong_funding` providing\nan alternate funding txid and outnum.[3]\n\nIf the recipient supports it (config setting is called\n'experimental-shutdown-wrong-funding'), they make sure the channel is\nunused (next commitment and next revocation numbers both 1), and that\nthe sender was the opener[4].  They then use these values as the input\nfor the shutdown negotiation, and continue like normal.\n\nThis is great, as it doesn't require interaction for the rescue.\n\nLimitations\n-----------\nThe peer will forget the channel 2016 blocks after proposal (we don't\nactually delete it from the db, but it would require some fishing as we\ndon't load it into memory).  So you have to figure out what went wrong\nand fix it in a timely manner.\n\nWe are considering a stub state for old channels to allow some limited\ninteraction with such dead channels, but it's not implemented for now.\nWe want this for reestablish rexmit anyway.\n\nThis also doesn't help the case of \"I accidentally all my funds to the\nchannel 2of2 address\"[5], since we don't allow variation of the amount, and\nwe only allow a single shutdown flow.\n\nImprovements\n------------\nChristian has been thinking in parallel, and suggested we send a\nsignature for the last tx in the reestablish message.  That would allow\nthem to recreate the last valid transaction themselves if they wanted\nto, but wouldn't help this case.\n\nOr more, we could sign anything they ask for dead channels (in our case,\n100 deep, all txs completely resolved, or 2016 later with no funding\nseen).\n\nMore radically, I suggested we could actually give them our private key\nin this case, which would allow late post-hoc rescue of any strangeness\nthey did.  Christian and I checked: we use hardened derivation and so\nit's fairly harmless.\n\nThis last possibility would allow nice tooling around this rescue\nfeature, but revealing a secret key is not something I would do lightly.[6]\n\nThoughts?\n\nThanks!\nRusty.\n\n[1] We have a fundchannel_start / fundchannel_complete API, but the\n    latter takes *TXID* rather than a whole PSBT.  Calculating the txid is\n    non-trivial (P2SH-wrapped inputs!), and of course this presents\n    a giant footgun, as users simply use the TXID of the global tx\n    and it *sometimes* works.  API is changing before release![7]\n[2] Dual-funding avoids this entire problem by co-constructing the\n    funding tx, rather than presenting the txid/outnum as a fait\n    accompli.  Even if one side doesn't contribute, they calculate\n    the funding txid themselves.\n[3] https://github.com/ElementsProject/lightning/pull/4421\n[4] We disable `wrong_funding` for dual-opened-negotiated channels too.\n[5] t-bast said someone did this.  I think I died a little inside.\n[6] `option_boating_accident_as_a_service`?\n[7] For the love of God, GO ALL IN ON PSBT and don't do hybrid APIs like\n    this.  Rusty is dumb.  Don't be like Rusty."
            }
        ],
        "thread_summary": {
            "title": "Rescuing funding mistakes",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3605
        }
    },
    {
        "title": "[Lightning-dev] Funding Timeout Recovery proposal",
        "thread_messages": [
            {
                "author": "Christian Decker",
                "date": "2021-03-15T14:30:03",
                "message_text_only": "Hi All,\n\nI just finished writing a (very) rough draft of the Funding Timeout\nRecovery proposal (a.k.a. \"So long, and thanks for all the sigs\"). You\ncan find the full proposal here [1].\n\nThe proposal details how the fundee can assist the funder quickly\nrecover a botched funding. This is an alternative to using the\npre-signed commitment transaction, which likely overestimates the\nfeerate, and also locks the funder's funds with a timeout since it is a\nunilateral close.\n\nThe trick is to have the fundee sign a blank check with the\nfunding_privkey, used to setup the 2-of-2, and using `sighash_none` to\nmake the signature independent from the outputs. The funder can then use\nthat signature to create a close transaction however she wants,\nincluding adjustable feerates, and any desired outputs.\n\nIn addition it also includes a recovery mechanism for malleated funding\ntransactions, which can happen from time to time, if there are\nnon-segwit inputs, or if the funding transaction is edited externally to\nthe lightning node prior to broadcasting it. This extension is however\noptional.\n\nThere are a couple of open questions at the bottom, and I would be very\ninterested in everyone's opinion on the safety. I think we're ok due to\nthe funding_privkey = channel mapping, but I'm open to further analysis.\n\nSince this is rather short-notice for today's spec meeting I'll probably\nadd it to the agenda for next time instead, to give everybody time to\nfamiliarize themselves with the proposal, before delving into details\n:-)\n\nCheers,\nChristian\n\n[1] https://github.com/lightningnetwork/lightning-rfc/pull/854"
            }
        ],
        "thread_summary": {
            "title": "Funding Timeout Recovery proposal",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Christian Decker"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 1604
        }
    },
    {
        "title": "[Lightning-dev] Single Round Trustless Schnorr-based PTLC Idea + Offline LN Payment Demo",
        "thread_messages": [
            {
                "author": "Matheus Degiovani",
                "date": "2021-03-16T14:19:47",
                "message_text_only": "Hello List! \n\nI've been working on a Proof-of-Work, Schnorr-based PTLC demo for Decred's LN and stumbled upon an interesting hack that may be of interest, as another point in design space for a full blown PTLC impl.\n\nAs it happens, this hack was in fact so simple to implement that I was able to also code up an interesting PTLC-backed construct (what I'm calling a Multi-Redeemer Transaction Tree - MRTTREE) and a demo for offline lightning payments over it.\n\nQuick details following below. I have a (crappy) video of the concepts and demo here (demo starts at around the 15 min mark): https://www.youtube.com/watch?v=m1sQGHUKU7I\n\n# Single Round, Trustless Schnorr-based PTLCs\n\nBy \"single round\" I mean it doesn't require additional comms rounds to irrevocably commit to a PTLC (the current `update_add_htlc()` -> `commit_signed()` -> `revoke_and_ack()` protocol is preserved).\n\nFor the following, assume a {H,P}TLC being added from Alice -> Bob (i.e. Alice is offering, Bob is accepting; Alice has the Sender{H,P}TLC output script and Bob has the Receiver{H,P}TLC script).\n\nRecall that Schnorr-based PTLCs are constructed by way of adaptor signatures: a party that knows the adaptor sig can extract the secret scalar that corresponds to some public point after seeing the full signature (potentially on-chain). The secret scalar is encoded as an additive component of the full Schnorr sig (i.e., `s = (u+t) + ex` where `t` is the target secret nonce and `u` is the random nonce). \n\nAlso recall that in the standard protocol to commit a channel to an HTLC, the `commit_signed()` msg sends the signatures to the _other_ party's commitment tx.\n\nThe most naive way to switch from HTLC to a PTLC is to have the {Sender,Receiver}PTLCScript commit to a Schnorr sig instead of a hash preimage.\n\nThis is easy to do, however it's not trustless for Alice.\n\nRecall that the point of the preimage redeeming branch in the SenderHTLCScript is so that Alice can figure out the preimage if Bob redeems her commitment tx onchain (so that if she's forwarding the HTLC she can redeem her upstream accepted HTLC).\n\nThat's not safe in a naive PTLC setting because the secret scalar contained in the full Schnorr sig for Alice's commitment tx (i.e. the receiver-redeeming branch of SenderPTLCScript) is under control of Bob (because `r=(u+t)` i.e. the standard nonce of a Schnorr sig).\n\nAnd thus ordinarily, even if Bob sent a valid adaptor sig to Alice during the `commit_signed()` msg, he could freely modify the sig once Alice's tx actually hits onchain (thus denying Alice the ability to find out the secret scalar).\n\nMy first imaginable solution to _that_ would be to have the receiver-redeem, scalar-revealing branch of the SenderPTLCScript require a signature from Alice as well. However, this breaks the current LN protocol, in that Bob would require a signature from Alice to redeem from her commitment _before_ sending his `commit_signed()` msg.\n\nSo you'd need an additional comms round before `commit_signed` for both parties to agree on the layout of the commitment tx and for Alice to send Bob the required sigs.\n\n(doing this in the revoke_and_ack msg isn't safe for Bob because in the timeframe between his sending of `commit_signed()` and receiving Alice's `revoke_and_ack()` he wouldn't be able to redeem from Alice's commitment by presenting the secret scalar)\n\nThus, my hack: riffing off ZmnSCPxj's OP_CAT trick[1] for single-show signatures, we modify the secret-scalar-redeeming branch of the SenderPTLCScript to commit to a specific R point by encoding it **directly in the script**, then having Bob present _only_ the s scalar of the `(R, s)` fully valid Schnorr sig in the Signature Script of the redeeming tx, using OP_CAT to join both for consumption by the opcode that checks for Schnorr txs (OP_CHECKSIGALT in decred's case, not sure what will do that in bitcoin's taproot).\n\nIn short, that specific branch SenderPTLCScript looks like this (for decred): \n\n  <ptlc R point> OP_SWAP OP_CAT <ptlc key> 2 OP_CHECKSIGALTVERIFY\n  \nThus, Bob is committed to a specific `r = (u+t)`, Alice has verified, upon receiving the corresponding adaptor sig `(R, s')` that in fact `R = U+T` (T is the original target payment point Alice provided in the `update_add_ptlc()`) and that s' is a valid adaptor sig for that combination.\n\nObviously, there are all sorts of footguns in doing this, specifically related with proper nonce selection so that Bob doesn't inadvertently reveal one of his private keys but can still redeem in the future even after a software restart. So it needs some serious cryptographic look to make sure it's safe in the cryptographic sense.\n\nBut it seems safe to me in the game-theoretical sense: at every step in the channel update protocol Bob can redeem from Alice's commitment and Alice can find out the secret scalar if Bob does so.\n\nThis is implementable with very few changes in the codebase, and makes PTLCs interoperable with standard HTLCs; you can have both in your channel at the same time, only small changes in the wire msgs are needed, no new comm rounds, etc.\n\nThe greatest downside I can see so far is that it makes local commitment txs ungeneratable before you've received the adaptor sigs in the `commit_signed()` msg.\n\nThat is, Alice can't generate her local commitment tx before Bob sends the R he wants to commit to by way of his adaptor sig (sent in his `commit_signed()` when he wants to lock in a PTLC) because that particular R appears as part of the SenderPTLCScript.\n\nI don't _think_ this is a major downside, since Alice's commitment is useless (to Alice) before she receives Bob's signatures, but I'd be interested to hear otherwise.\n\nAnd just to make it more explicit: this is implementing PTLCs _without_ any additional changes to the currently used HTLC scripts (modulo swapping the preimage challenge): in particular, it's _not_ aggregating/MuSig'ing the signatures into a single one, not making using of taproot/tapscript capabilities to further improve things, _not_ adding a per-hop tweak, etc.\n\n# MRTREEs\n\nThis is long enough as it is and my intention was to share this hack as another interesting idea for PTLCs.\n\nBut since that was actually easy to code up as a PoC, I went ahead and did that and also built a PTLC-backed MRTTREE server with an offline lightning donation/payment system.\n\nA single-sentence summary of MRTTREE is:\n\nSubmarine swaps meets channel factories to build an off-chain binary tree of transactions, such that an user that redeems a \"leaf\" amount of the tree reveals one of the keys needed to redeem the upper branches of the tree.\n\nA more extensive description:\n\nThis construction is created by a set of Users (with off-chain funds) interacting with a Provider (with unemcumbered on-chain funds) to create a tree of transactions such that each leaf output is redeemable by [MuSig_1(User,Provider) or MuSig_2(User,Provider)+Timelock]. The second redeem path is the pre-signed one. Upper branches of the tree are redeemable by a similar script, except we include the keys from every child (i.e. for the immediate parent of a leaf, the non-timelocked key is MuSig_1(UserLeft,UserRight,ProviderLeft,ProviderRight) and so on).\n\nA user can exit the MRTREE by \"selling back\" his User key to the provider (via a PTLC payment) such that the provider can then rewrite (recursively) the upward branches with the user key. In the limit where every user cooperates, the provider rewrites into a single output, with minimal on-chain footprint.\n\nI have a specific use case in mind for this, and I've written more about this construction at [2] (but note that was written before I was aware of PTLCs so it uses a different method to achieve the goal of allowing the upward tree rewrite).\n\n# Offline Lightning Payments\n\nSo, assuming the existence of a MRTTREE service, where LN users can \"buy into shares\" of a utxo (with a long initial timelock, in the months+ range) but still preserving their individual exit rights and the non-custodialness property, we can build a cute system for offline LN donations/payments:\n\nAn LN user joins a MRTREE with a well-known, public provider, creating multiple leafs of some set amount (pretty much, any amount higher than dust). The user can then go offline (from LN). It can even change/close its channels and whatnot. \n\nWhen the user wishes to make a donation to some third party, it can send the tuple (provider,tree_id,leaf_private_key) to that third party via any async method (chat, e-mail, twitter DM, whatever), which then contacts the provider and redeems the funds on behalf of the user.\n\nThe donation case is illustrative because if the recipient never redeems the leaf (before the tree timelock), the user can still redeem it back and thus not have the funds go to the void (or to an unrelated third party).\n\nThere are probably bunch of other interesting use cases for this construct.\n\nMy PTLC Proof of Concept is here:\n\nhttps://github.com/decred/dcrlnd/compare/v0.3.1...matheusd:ptlc-poc\n\nSample MRTREE client and server:\n\nhttps://github.com/matheusd/mrttree\n\nGUI demo of offline LN payments:\n\nhttps://www.youtube.com/watch?v=m1sQGHUKU7I&t=915s\n\n\n# References\n\n[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002388.html\n\n[2] https://matheusd.com/post/ln-split-tickets-01-mrttree/"
            }
        ],
        "thread_summary": {
            "title": "Single Round Trustless Schnorr-based PTLC Idea + Offline LN Payment Demo",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Matheus Degiovani"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 9317
        }
    },
    {
        "title": "[Lightning-dev] Towards more reliable payment path finding via probabilistic modeling the uncertainty of channel balance",
        "thread_messages": [
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2021-03-17T12:50:26",
                "message_text_only": "Dear fellow Lightning Network developers,\n\nI am very pleased to share with you some research progress [0] with respect\nto achieving better payment path finding and a better reliability of the\npayment process.\n\nTL;DR summary: In payment (multi)path finding use the (multi)paths with the\nhighest success probability instead of the shortest or cheapest ones.\n(multi)path success probability is the product of channel success\nprobabilities. Given current data crawled on the Network the channel\nsuccess probability grows with the capacity of the channel and with smaller\namounts that are to be sent (which is both intuitively obvious).\n(Multi)path success probability thus declines exponentially the more\nuncertain channels are included.\n\nI understand that the actual payment path finding is not part of the spec\nbut I think my results should be relevant to the list since:\n\na) The payment pathfinding is currently based on trial and error approach\nwhich has consequences that have not been studied well in the context of\nthe Lightning Network\nb) All implementations will use some heuristics in order to achieve\npathfinding.\nc) Quick path finding is a crucial for a good user experience.\nd) The uncertainty of payment paths is frequently quoted as a major\ncriticism of the Lightning Network (c.f. [1]) and I believe the methodology\nof this paper can be used to address this.\n\nThe main breakthrough is that  a very simple model that puts the\nuncertainty of channel balances at its heart. We belief the uncertainty of\nchannel balance values is the main reason why some payments take several\nattempts and thus take more time.  With the help of probability theory we\nare able to define the channel success and failure probabilities and\nsimilarly (multi)path success and failure probabilities. Other Failure\nreasons could also be included to the probability distributions.\n\nWith the help of crawling small samples of the network we observe that the\nprobability distributions of the channel balances can be estimated well\nwith a uniform distribution (which was a little bit surprising) but leads\nto surprisingly easy formulas.  We are able to quantify the uncertainty in\nthe channels and use negative Bernoulli trials to compute the expected\nnumber of attempts that are necessary to deliver a payment of a particular\namount from one node to another participant of the network. This can be\nused to abort the trial and error path finding if the probability becomes\nto low (expected number of attempts too high)\n\nWe can mathematically show what people already knew (and draw conclusions\nlike the mentioned ones from it):\n\na) smaller amounts have higher success probabilities\nb) the success probability declines exponentially with the number of\nuncertain channels in a (multi)path.\nc) depending on the payment pair, amount and splitting strategy it can be\ndecided into how many parts a payment should be split to achieve the\nhighest success probability.\nd) In particular for small amounts splitting almost never makes sense.\n\nWe demonstrate that sorting paths by their descending success probability\nduring the trial and error payment process (instead of currently used\nheuristics like fees or route length) and updating the probabilities from\ncurrent failures decreases the number of average attempts and produces a\nmuch faster delivery of payments.\n\nAdditionally we looked what happened if BOLT14 [2] was implemented or nodes\notherwise would pro-actively rebalance their channels according to previous\nresearch [3] and realized that the observed prior distribution changes from\nuniform to normal. This is great as small payments become even more likely\n(as one would intuitively assume and as previously showed) Our results show\nthat probabilisitic path finding on a rebalanced network works even better\n(as in fewer failed attempts) which is yet another hint why BOLT14 might be\na good idea. However as mentioned the results can be implemented even\nwithout BOLT14 or without other protocol changes by any implementation.\n\nOne consequence from the paper that is not discussed heavily within the\npaper that I find pretty interesting is that if implementations follow the\nrecommendation to use a probabilistic approach they will tend to route\npayments along high capacity channels. While the fee based routing can\neasily be gamed by dumping fees it is much harder to provide more\nliquidity. And if done this would actually provide a service to the\nnetwork. This means that nodes which provide a lot of liquidity and thus\nutility might be able to charge higher fees (as long as they are small\nenough so that users are willing to pay them) which would probably allow\nthe emergence of a real routing fee market.\n\nOne note on the question of MPP: In the last couple weeks I have been\ncollaborating with Christian Decker. I belief (by using the methodology\nfrom this paper) to also have a definite solution to the question of:\n\nHow to split a payment into k parts and how many funds to allocate to each\npath to increase the (multi)path success probability.\n\nWhile this is is not addressed in the attached paper as we still need to\nrun evaluations I can already share that an equal sized split as used in\nthe paper (and by some implementations) is not preferable as one can easily\nsee from this example:\nImagine one is to deliver 100 satoshi and has to paths with 1 uncertain\nchannel on each path. The first of capacity 101 and  the second of 51.\nObviously trying to send 100 satoshi along the 101 capacity channel is bad.\nSimilarly splitting 50/50 and sending 50 Satoshi along the 51 satoshi\ncapacity channel is also bad. Thus a split that allocates for example 67\nSatoshi to the 101 capacity and 33 to the 51 satoshi channel seems way more\nreasonable. Actually 75/25 would probably be the best solution for such a\nsetting. And no it is only random coincident that a binary splitter would\nhave arrived at that split eventually (after potential miss trials)\nThere is way more math theory of how to actually solve the optimization\nproblem in the general case and how to find a split and paths that\nmaximizes the probability of the attempts. I cannot share these results yet\nbut I am pretty confident that there will be updates on that end very soon.\n\nwith kind regards Rene\n\n[0]: https://arxiv.org/abs/2103.08576 Security and Privacy of Lightning\nNetwork Payments with Uncertain Channel Balances\n[1]:\nhttps://www.whatbitcoindid.com/podcast/peter-rizuns-lightning-critique-fud-or-fair\n[2]: https://github.com/lightningnetwork/lightning-rfc/pull/780\n[3]:\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002406.html\n\n-- \nhttps://www.rene-pickhardt.de\n\nSkype: rene.pickhardt\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210317/793a07dd/attachment.html>"
            },
            {
                "author": "Elias Rohrer",
                "date": "2021-03-18T08:27:35",
                "message_text_only": "Dear Ren\u00e9,\n\nthank you for the great work!\n\nOne quick question regarding the consequence you mentioned: it seems \nplausible that manipulating the path choices would become harder, if the \nability of doing so was correlated with the capacity locked in the \nnetwork. However, if paths were only chosen regarding the probability of \npayment success (and neglecting accruing fees), couldn't high-capacity \nnodes in absence of competition simply raise their fee levels \nindefinitely, since they would be chosen regardless? Do you have any \nideas how to protect against this?\n\nI imagine that some kind of 'mixed' strategy could be reasonable, in \nwhich certain paths are pre-filtered based on the probability of payment \nsuccess, and then the final path is selected along the lines of the \ncurrently deployed fee rate/CLTV risk assessment?\n\nKind Regards,\n\nElias\n\nOn 17 Mar 2021, at 13:50, Ren\u00e9 Pickhardt via Lightning-dev wrote:\n\n> Dear fellow Lightning Network developers,\n>\n> I am very pleased to share with you some research progress [0] with \n> respect\n> to achieving better payment path finding and a better reliability of \n> the\n> payment process.\n>\n> TL;DR summary: In payment (multi)path finding use the (multi)paths \n> with the\n> highest success probability instead of the shortest or cheapest ones.\n> (multi)path success probability is the product of channel success\n> probabilities. Given current data crawled on the Network the channel\n> success probability grows with the capacity of the channel and with \n> smaller\n> amounts that are to be sent (which is both intuitively obvious).\n> (Multi)path success probability thus declines exponentially the more\n> uncertain channels are included.\n>\n> I understand that the actual payment path finding is not part of the \n> spec\n> but I think my results should be relevant to the list since:\n>\n> a) The payment pathfinding is currently based on trial and error \n> approach\n> which has consequences that have not been studied well in the context \n> of\n> the Lightning Network\n> b) All implementations will use some heuristics in order to achieve\n> pathfinding.\n> c) Quick path finding is a crucial for a good user experience.\n> d) The uncertainty of payment paths is frequently quoted as a major\n> criticism of the Lightning Network (c.f. [1]) and I believe the \n> methodology\n> of this paper can be used to address this.\n>\n> The main breakthrough is that  a very simple model that puts the\n> uncertainty of channel balances at its heart. We belief the \n> uncertainty of\n> channel balance values is the main reason why some payments take \n> several\n> attempts and thus take more time.  With the help of probability theory \n> we\n> are able to define the channel success and failure probabilities and\n> similarly (multi)path success and failure probabilities. Other Failure\n> reasons could also be included to the probability distributions.\n>\n> With the help of crawling small samples of the network we observe that \n> the\n> probability distributions of the channel balances can be estimated \n> well\n> with a uniform distribution (which was a little bit surprising) but \n> leads\n> to surprisingly easy formulas.  We are able to quantify the \n> uncertainty in\n> the channels and use negative Bernoulli trials to compute the expected\n> number of attempts that are necessary to deliver a payment of a \n> particular\n> amount from one node to another participant of the network. This can \n> be\n> used to abort the trial and error path finding if the probability \n> becomes\n> to low (expected number of attempts too high)\n>\n> We can mathematically show what people already knew (and draw \n> conclusions\n> like the mentioned ones from it):\n>\n> a) smaller amounts have higher success probabilities\n> b) the success probability declines exponentially with the number of\n> uncertain channels in a (multi)path.\n> c) depending on the payment pair, amount and splitting strategy it can \n> be\n> decided into how many parts a payment should be split to achieve the\n> highest success probability.\n> d) In particular for small amounts splitting almost never makes sense.\n>\n> We demonstrate that sorting paths by their descending success \n> probability\n> during the trial and error payment process (instead of currently used\n> heuristics like fees or route length) and updating the probabilities \n> from\n> current failures decreases the number of average attempts and produces \n> a\n> much faster delivery of payments.\n>\n> Additionally we looked what happened if BOLT14 [2] was implemented or \n> nodes\n> otherwise would pro-actively rebalance their channels according to \n> previous\n> research [3] and realized that the observed prior distribution changes \n> from\n> uniform to normal. This is great as small payments become even more \n> likely\n> (as one would intuitively assume and as previously showed) Our results \n> show\n> that probabilisitic path finding on a rebalanced network works even \n> better\n> (as in fewer failed attempts) which is yet another hint why BOLT14 \n> might be\n> a good idea. However as mentioned the results can be implemented even\n> without BOLT14 or without other protocol changes by any \n> implementation.\n>\n> One consequence from the paper that is not discussed heavily within \n> the\n> paper that I find pretty interesting is that if implementations follow \n> the\n> recommendation to use a probabilistic approach they will tend to route\n> payments along high capacity channels. While the fee based routing can\n> easily be gamed by dumping fees it is much harder to provide more\n> liquidity. And if done this would actually provide a service to the\n> network. This means that nodes which provide a lot of liquidity and \n> thus\n> utility might be able to charge higher fees (as long as they are small\n> enough so that users are willing to pay them) which would probably \n> allow\n> the emergence of a real routing fee market.\n>\n> One note on the question of MPP: In the last couple weeks I have been\n> collaborating with Christian Decker. I belief (by using the \n> methodology\n> from this paper) to also have a definite solution to the question of:\n>\n> How to split a payment into k parts and how many funds to allocate to \n> each\n> path to increase the (multi)path success probability.\n>\n> While this is is not addressed in the attached paper as we still need \n> to\n> run evaluations I can already share that an equal sized split as used \n> in\n> the paper (and by some implementations) is not preferable as one can \n> easily\n> see from this example:\n> Imagine one is to deliver 100 satoshi and has to paths with 1 \n> uncertain\n> channel on each path. The first of capacity 101 and  the second of 51.\n> Obviously trying to send 100 satoshi along the 101 capacity channel is \n> bad.\n> Similarly splitting 50/50 and sending 50 Satoshi along the 51 satoshi\n> capacity channel is also bad. Thus a split that allocates for example \n> 67\n> Satoshi to the 101 capacity and 33 to the 51 satoshi channel seems way \n> more\n> reasonable. Actually 75/25 would probably be the best solution for \n> such a\n> setting. And no it is only random coincident that a binary splitter \n> would\n> have arrived at that split eventually (after potential miss trials)\n> There is way more math theory of how to actually solve the \n> optimization\n> problem in the general case and how to find a split and paths that\n> maximizes the probability of the attempts. I cannot share these \n> results yet\n> but I am pretty confident that there will be updates on that end very \n> soon.\n>\n> with kind regards Rene\n>\n> [0]: https://arxiv.org/abs/2103.08576 Security and Privacy of \n> Lightning\n> Network Payments with Uncertain Channel Balances\n> [1]:\n> https://www.whatbitcoindid.com/podcast/peter-rizuns-lightning-critique-fud-or-fair\n> [2]: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> [3]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002406.html\n>\n> -- \n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n\n\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210318/e55f0d5d/attachment-0001.html>"
            },
            {
                "author": "Ren\u00e9 Pickhardt",
                "date": "2021-03-18T09:12:07",
                "message_text_only": "Dear Elias,\n\nThanks for your kind words!\n\nIn the paper we suggest clients sort paths by probability but skip the ones\nthat charge fees that are too high for a user, which could be defined in a\nuser setting. I should have repeated that when I expressed that implicitly\nwith this sentence in my mail:\n\n\"This means that nodes which provide a lot of liquidity and thus utility\nmight be able to charge higher fees (as long as they are small enough so\nthat users are willing to pay them)\"\n\nI think that is very similar to your suggestion and of course one could\ninclude not only fees but other criteria while filtering.\n\nIn general I think it is reasonable to be aware of the most likely path as\nthe inverse probability is the number of expected attempts. This if due to\nfailures and updating the knowledge and channel probabilities the remaining\npath probabilities drop below a certain (configurable) value one might want\nto stop trying or consider a more expensive path.\n\nSo if for example a user was to say I am willing to pay up to 0.5% of the\namount in routing fees but after a few attempts the likeliest path has only\na 0.01% chance a client could say something like: \"it is very unlikely to\ndeliver the payment but if you pay 0.7% fees there is a chance (want to\ntry?)\" Of course at some point onchain / opening a new channel might be\ncheaper which would contribute to the potential emerging fee market.\n\nInstead of filtering paths by fees one could also weight the probabilities\nwith the fees. An easy (but maybe not optimal) approach for that would be\nto multiply the log probabilities (which have to be low for high success)\nwith the fees. That being said I think the main important result is that we\nshould always be aware of (multi)path probabilities during the trial and\nerror phase especially in order to make splitting decisions and to\ndetermine when to stop trying\n\nBest Rene\n\nElias Rohrer <lnml at tnull.de> schrieb am Do., 18. M\u00e4rz 2021, 09:34:\n\n> Dear Ren\u00e9,\n>\n> thank you for the great work!\n>\n> One quick question regarding the consequence you mentioned: it seems\n> plausible that manipulating the path choices would become harder, if the\n> ability of doing so was correlated with the capacity locked in the network.\n> However, if paths were only chosen regarding the probability of payment\n> success (and neglecting accruing fees), couldn't high-capacity nodes in\n> absence of competition simply raise their fee levels indefinitely, since\n> they would be chosen regardless? Do you have any ideas how to protect\n> against this?\n>\n> I imagine that some kind of 'mixed' strategy could be reasonable, in which\n> certain paths are pre-filtered based on the probability of payment success,\n> and then the final path is selected along the lines of the currently\n> deployed fee rate/CLTV risk assessment?\n>\n> Kind Regards,\n>\n> Elias\n>\n> On 17 Mar 2021, at 13:50, Ren\u00e9 Pickhardt via Lightning-dev wrote:\n>\n> Dear fellow Lightning Network developers,\n>\n> I am very pleased to share with you some research progress [0] with\n> respect to achieving better payment path finding and a better reliability\n> of the payment process.\n>\n> TL;DR summary: In payment (multi)path finding use the (multi)paths with\n> the highest success probability instead of the shortest or cheapest ones.\n> (multi)path success probability is the product of channel success\n> probabilities. Given current data crawled on the Network the channel\n> success probability grows with the capacity of the channel and with smaller\n> amounts that are to be sent (which is both intuitively obvious).\n> (Multi)path success probability thus declines exponentially the more\n> uncertain channels are included.\n>\n> I understand that the actual payment path finding is not part of the spec\n> but I think my results should be relevant to the list since:\n>\n> a) The payment pathfinding is currently based on trial and error approach\n> which has consequences that have not been studied well in the context of\n> the Lightning Network\n> b) All implementations will use some heuristics in order to achieve\n> pathfinding.\n> c) Quick path finding is a crucial for a good user experience.\n> d) The uncertainty of payment paths is frequently quoted as a major\n> criticism of the Lightning Network (c.f. [1]) and I believe the methodology\n> of this paper can be used to address this.\n>\n> The main breakthrough is that  a very simple model that puts the\n> uncertainty of channel balances at its heart. We belief the uncertainty of\n> channel balance values is the main reason why some payments take several\n> attempts and thus take more time.  With the help of probability theory we\n> are able to define the channel success and failure probabilities and\n> similarly (multi)path success and failure probabilities. Other Failure\n> reasons could also be included to the probability distributions.\n>\n> With the help of crawling small samples of the network we observe that the\n> probability distributions of the channel balances can be estimated well\n> with a uniform distribution (which was a little bit surprising) but leads\n> to surprisingly easy formulas.  We are able to quantify the uncertainty in\n> the channels and use negative Bernoulli trials to compute the expected\n> number of attempts that are necessary to deliver a payment of a particular\n> amount from one node to another participant of the network. This can be\n> used to abort the trial and error path finding if the probability becomes\n> to low (expected number of attempts too high)\n>\n> We can mathematically show what people already knew (and draw conclusions\n> like the mentioned ones from it):\n>\n> a) smaller amounts have higher success probabilities\n> b) the success probability declines exponentially with the number of\n> uncertain channels in a (multi)path.\n> c) depending on the payment pair, amount and splitting strategy it can be\n> decided into how many parts a payment should be split to achieve the\n> highest success probability.\n> d) In particular for small amounts splitting almost never makes sense.\n>\n> We demonstrate that sorting paths by their descending success probability\n> during the trial and error payment process (instead of currently used\n> heuristics like fees or route length) and updating the probabilities from\n> current failures decreases the number of average attempts and produces a\n> much faster delivery of payments.\n>\n> Additionally we looked what happened if BOLT14 [2] was implemented or\n> nodes otherwise would pro-actively rebalance their channels according to\n> previous research [3] and realized that the observed prior distribution\n> changes from uniform to normal. This is great as small payments become even\n> more likely (as one would intuitively assume and as previously showed) Our\n> results show that probabilisitic path finding on a rebalanced network works\n> even better (as in fewer failed attempts) which is yet another hint why\n> BOLT14 might be a good idea. However as mentioned the results can be\n> implemented even without BOLT14 or without other protocol changes by any\n> implementation.\n>\n> One consequence from the paper that is not discussed heavily within the\n> paper that I find pretty interesting is that if implementations follow the\n> recommendation to use a probabilistic approach they will tend to route\n> payments along high capacity channels. While the fee based routing can\n> easily be gamed by dumping fees it is much harder to provide more\n> liquidity. And if done this would actually provide a service to the\n> network. This means that nodes which provide a lot of liquidity and thus\n> utility might be able to charge higher fees (as long as they are small\n> enough so that users are willing to pay them) which would probably allow\n> the emergence of a real routing fee market.\n>\n> One note on the question of MPP: In the last couple weeks I have been\n> collaborating with Christian Decker. I belief (by using the methodology\n> from this paper) to also have a definite solution to the question of:\n>\n> How to split a payment into k parts and how many funds to allocate to each\n> path to increase the (multi)path success probability.\n>\n> While this is is not addressed in the attached paper as we still need to\n> run evaluations I can already share that an equal sized split as used in\n> the paper (and by some implementations) is not preferable as one can easily\n> see from this example:\n> Imagine one is to deliver 100 satoshi and has to paths with 1 uncertain\n> channel on each path. The first of capacity 101 and  the second of 51.\n> Obviously trying to send 100 satoshi along the 101 capacity channel is bad.\n> Similarly splitting 50/50 and sending 50 Satoshi along the 51 satoshi\n> capacity channel is also bad. Thus a split that allocates for example 67\n> Satoshi to the 101 capacity and 33 to the 51 satoshi channel seems way more\n> reasonable. Actually 75/25 would probably be the best solution for such a\n> setting. And no it is only random coincident that a binary splitter would\n> have arrived at that split eventually (after potential miss trials)\n> There is way more math theory of how to actually solve the optimization\n> problem in the general case and how to find a split and paths that\n> maximizes the probability of the attempts. I cannot share these results yet\n> but I am pretty confident that there will be updates on that end very soon.\n>\n> with kind regards Rene\n>\n> [0]: https://arxiv.org/abs/2103.08576 Security and Privacy of Lightning\n> Network Payments with Uncertain Channel Balances\n> [1]:\n> https://www.whatbitcoindid.com/podcast/peter-rizuns-lightning-critique-fud-or-fair\n> [2]: https://github.com/lightningnetwork/lightning-rfc/pull/780\n> [3]:\n> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002406.html\n>\n> --\n> https://www.rene-pickhardt.de\n>\n> Skype: rene.pickhardt\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n> _______________________________________________\n> Lightning-dev mailing list\n> Lightning-dev at lists.linuxfoundation.org\n> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210318/8089a750/attachment.html>"
            },
            {
                "author": "Elias Rohrer",
                "date": "2021-03-18T09:36:23",
                "message_text_only": "Dear Ren\u00e9,\n\nah, it seems I overlooked that sentence. Thanks for clearing this up. I \nagree, filtering based on probability and then weighing based on cost is \nprobably very similar to doing it vice versa.\n\nKind Regards,\n\nElias\n\nOn 18 Mar 2021, at 10:12, Ren\u00e9 Pickhardt wrote:\n\n> Dear Elias,\n>\n> Thanks for your kind words!\n>\n> In the paper we suggest clients sort paths by probability but skip the \n> ones\n> that charge fees that are too high for a user, which could be defined \n> in a\n> user setting. I should have repeated that when I expressed that \n> implicitly\n> with this sentence in my mail:\n>\n> \"This means that nodes which provide a lot of liquidity and thus \n> utility\n> might be able to charge higher fees (as long as they are small enough \n> so\n> that users are willing to pay them)\"\n>\n> I think that is very similar to your suggestion and of course one \n> could\n> include not only fees but other criteria while filtering.\n>\n> In general I think it is reasonable to be aware of the most likely \n> path as\n> the inverse probability is the number of expected attempts. This if \n> due to\n> failures and updating the knowledge and channel probabilities the \n> remaining\n> path probabilities drop below a certain (configurable) value one might \n> want\n> to stop trying or consider a more expensive path.\n>\n> So if for example a user was to say I am willing to pay up to 0.5% of \n> the\n> amount in routing fees but after a few attempts the likeliest path has \n> only\n> a 0.01% chance a client could say something like: \"it is very unlikely \n> to\n> deliver the payment but if you pay 0.7% fees there is a chance (want \n> to\n> try?)\" Of course at some point onchain / opening a new channel might \n> be\n> cheaper which would contribute to the potential emerging fee market.\n>\n> Instead of filtering paths by fees one could also weight the \n> probabilities\n> with the fees. An easy (but maybe not optimal) approach for that would \n> be\n> to multiply the log probabilities (which have to be low for high \n> success)\n> with the fees. That being said I think the main important result is \n> that we\n> should always be aware of (multi)path probabilities during the trial \n> and\n> error phase especially in order to make splitting decisions and to\n> determine when to stop trying\n>\n> Best Rene\n>\n> Elias Rohrer <lnml at tnull.de> schrieb am Do., 18. M\u00e4rz 2021, 09:34:\n>\n>> Dear Ren\u00e9,\n>>\n>> thank you for the great work!\n>>\n>> One quick question regarding the consequence you mentioned: it seems\n>> plausible that manipulating the path choices would become harder, if \n>> the\n>> ability of doing so was correlated with the capacity locked in the \n>> network.\n>> However, if paths were only chosen regarding the probability of \n>> payment\n>> success (and neglecting accruing fees), couldn't high-capacity nodes \n>> in\n>> absence of competition simply raise their fee levels indefinitely, \n>> since\n>> they would be chosen regardless? Do you have any ideas how to protect\n>> against this?\n>>\n>> I imagine that some kind of 'mixed' strategy could be reasonable, in \n>> which\n>> certain paths are pre-filtered based on the probability of payment \n>> success,\n>> and then the final path is selected along the lines of the currently\n>> deployed fee rate/CLTV risk assessment?\n>>\n>> Kind Regards,\n>>\n>> Elias\n>>\n>> On 17 Mar 2021, at 13:50, Ren\u00e9 Pickhardt via Lightning-dev wrote:\n>>\n>> Dear fellow Lightning Network developers,\n>>\n>> I am very pleased to share with you some research progress [0] with\n>> respect to achieving better payment path finding and a better \n>> reliability\n>> of the payment process.\n>>\n>> TL;DR summary: In payment (multi)path finding use the (multi)paths \n>> with\n>> the highest success probability instead of the shortest or cheapest \n>> ones.\n>> (multi)path success probability is the product of channel success\n>> probabilities. Given current data crawled on the Network the channel\n>> success probability grows with the capacity of the channel and with \n>> smaller\n>> amounts that are to be sent (which is both intuitively obvious).\n>> (Multi)path success probability thus declines exponentially the more\n>> uncertain channels are included.\n>>\n>> I understand that the actual payment path finding is not part of the \n>> spec\n>> but I think my results should be relevant to the list since:\n>>\n>> a) The payment pathfinding is currently based on trial and error \n>> approach\n>> which has consequences that have not been studied well in the context \n>> of\n>> the Lightning Network\n>> b) All implementations will use some heuristics in order to achieve\n>> pathfinding.\n>> c) Quick path finding is a crucial for a good user experience.\n>> d) The uncertainty of payment paths is frequently quoted as a major\n>> criticism of the Lightning Network (c.f. [1]) and I believe the \n>> methodology\n>> of this paper can be used to address this.\n>>\n>> The main breakthrough is that  a very simple model that puts the\n>> uncertainty of channel balances at its heart. We belief the \n>> uncertainty of\n>> channel balance values is the main reason why some payments take \n>> several\n>> attempts and thus take more time.  With the help of probability \n>> theory we\n>> are able to define the channel success and failure probabilities and\n>> similarly (multi)path success and failure probabilities. Other \n>> Failure\n>> reasons could also be included to the probability distributions.\n>>\n>> With the help of crawling small samples of the network we observe \n>> that the\n>> probability distributions of the channel balances can be estimated \n>> well\n>> with a uniform distribution (which was a little bit surprising) but \n>> leads\n>> to surprisingly easy formulas.  We are able to quantify the \n>> uncertainty in\n>> the channels and use negative Bernoulli trials to compute the \n>> expected\n>> number of attempts that are necessary to deliver a payment of a \n>> particular\n>> amount from one node to another participant of the network. This can \n>> be\n>> used to abort the trial and error path finding if the probability \n>> becomes\n>> to low (expected number of attempts too high)\n>>\n>> We can mathematically show what people already knew (and draw \n>> conclusions\n>> like the mentioned ones from it):\n>>\n>> a) smaller amounts have higher success probabilities\n>> b) the success probability declines exponentially with the number of\n>> uncertain channels in a (multi)path.\n>> c) depending on the payment pair, amount and splitting strategy it \n>> can be\n>> decided into how many parts a payment should be split to achieve the\n>> highest success probability.\n>> d) In particular for small amounts splitting almost never makes \n>> sense.\n>>\n>> We demonstrate that sorting paths by their descending success \n>> probability\n>> during the trial and error payment process (instead of currently used\n>> heuristics like fees or route length) and updating the probabilities \n>> from\n>> current failures decreases the number of average attempts and \n>> produces a\n>> much faster delivery of payments.\n>>\n>> Additionally we looked what happened if BOLT14 [2] was implemented or\n>> nodes otherwise would pro-actively rebalance their channels according \n>> to\n>> previous research [3] and realized that the observed prior \n>> distribution\n>> changes from uniform to normal. This is great as small payments \n>> become even\n>> more likely (as one would intuitively assume and as previously \n>> showed) Our\n>> results show that probabilisitic path finding on a rebalanced network \n>> works\n>> even better (as in fewer failed attempts) which is yet another hint \n>> why\n>> BOLT14 might be a good idea. However as mentioned the results can be\n>> implemented even without BOLT14 or without other protocol changes by \n>> any\n>> implementation.\n>>\n>> One consequence from the paper that is not discussed heavily within \n>> the\n>> paper that I find pretty interesting is that if implementations \n>> follow the\n>> recommendation to use a probabilistic approach they will tend to \n>> route\n>> payments along high capacity channels. While the fee based routing \n>> can\n>> easily be gamed by dumping fees it is much harder to provide more\n>> liquidity. And if done this would actually provide a service to the\n>> network. This means that nodes which provide a lot of liquidity and \n>> thus\n>> utility might be able to charge higher fees (as long as they are \n>> small\n>> enough so that users are willing to pay them) which would probably \n>> allow\n>> the emergence of a real routing fee market.\n>>\n>> One note on the question of MPP: In the last couple weeks I have been\n>> collaborating with Christian Decker. I belief (by using the \n>> methodology\n>> from this paper) to also have a definite solution to the question of:\n>>\n>> How to split a payment into k parts and how many funds to allocate to \n>> each\n>> path to increase the (multi)path success probability.\n>>\n>> While this is is not addressed in the attached paper as we still need \n>> to\n>> run evaluations I can already share that an equal sized split as used \n>> in\n>> the paper (and by some implementations) is not preferable as one can \n>> easily\n>> see from this example:\n>> Imagine one is to deliver 100 satoshi and has to paths with 1 \n>> uncertain\n>> channel on each path. The first of capacity 101 and  the second of \n>> 51.\n>> Obviously trying to send 100 satoshi along the 101 capacity channel \n>> is bad.\n>> Similarly splitting 50/50 and sending 50 Satoshi along the 51 satoshi\n>> capacity channel is also bad. Thus a split that allocates for example \n>> 67\n>> Satoshi to the 101 capacity and 33 to the 51 satoshi channel seems \n>> way more\n>> reasonable. Actually 75/25 would probably be the best solution for \n>> such a\n>> setting. And no it is only random coincident that a binary splitter \n>> would\n>> have arrived at that split eventually (after potential miss trials)\n>> There is way more math theory of how to actually solve the \n>> optimization\n>> problem in the general case and how to find a split and paths that\n>> maximizes the probability of the attempts. I cannot share these \n>> results yet\n>> but I am pretty confident that there will be updates on that end very \n>> soon.\n>>\n>> with kind regards Rene\n>>\n>> [0]: https://arxiv.org/abs/2103.08576 Security and Privacy of \n>> Lightning\n>> Network Payments with Uncertain Channel Balances\n>> [1]:\n>> https://www.whatbitcoindid.com/podcast/peter-rizuns-lightning-critique-fud-or-fair\n>> [2]: https://github.com/lightningnetwork/lightning-rfc/pull/780\n>> [3]:\n>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-December/002406.html\n>>\n>> --\n>> https://www.rene-pickhardt.de\n>>\n>> Skype: rene.pickhardt\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n>> _______________________________________________\n>> Lightning-dev mailing list\n>> Lightning-dev at lists.linuxfoundation.org\n>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev\n>>\n\n\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210318/c071a113/attachment-0001.html>"
            }
        ],
        "thread_summary": {
            "title": "Towards more reliable payment path finding via probabilistic modeling the uncertainty of channel balance",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Ren\u00e9 Pickhardt",
                "Elias Rohrer"
            ],
            "messages_count": 4,
            "total_messages_chars_count": 36816
        }
    },
    {
        "title": "[Lightning-dev] Analysis and Probing of Parallel Channels",
        "thread_messages": [
            {
                "author": "Sergei Tikhomirov",
                "date": "2021-03-28T15:56:46",
                "message_text_only": "Hi list,\n\nWe're pleased to share our novel work on channel balance probing.\n\nWe account for the first time for parallel channels in the context of\nprobing, measure the efficiency of a probing attack in a simulator, propose\nand evaluate various countermeasures, and discuss the trade-offs they\nintroduce.\n\nFor details, see the blog post:\n\nhttps://s-tikhomirov.github.io/lightning-probing/\n\nand the paper:\n\nhttps://eprint.iacr.org/2021/384\n\nChannel probing has been explored previously [1,2,3]. In its simplest form,\nprobing works as follows. An attacker sends payments with random hashes\n(aka probes), which fail either due to insufficient balance, or to\nincorrect hash. The attacker then learns the target channel balance with\narbitrary precision by doing binary search over possible balances.\n\nThe LN allows a pair of nodes to share multiple (parallel) channels. The LN\nuses non-strict forwarding: the sequence of nodes is fixed by the sender,\nbut routing nodes are free to use any of their channels to the next node.\nNon-strict forwarding hinders probing, as the attacker doesn't always know\nwhich channel the probes actually go through.\n\nIn this paper, we precisely model parallel channels from the prober's point\nof view. In particular, we use a notion of a hop - a pair of nodes sharing\none or multiple channels - and separate channel-level balance bounds from\nhop-level bounds. For example: if a probe passed through a target\nmulti-channel hop, the attacker learns a new lower bound for the hop as a\nwhole (i.e., _one_ of the channels can forward this amount, but it is\nunclear which one). In contrast, if a probe failed at a target hop, the\nattacker learns a new upper bound on _all_ channel balances in this hop\n(i.e., _none_ of the channels can forward this amount). Besides this core\nintuition, our model accounts for channel directions (whether forwarding is\nallowed).\n\nWe discuss multiple countermeasures, such as deliberately failing payments,\nspoofing errors, and introducing delays. While our simulations demonstrate\ntheir effectiveness, we stress that such measures could harm user\nexperience and be not economically sustainable.\n\nWe use an information-theoretical uncertainty metric to measure the\nprober's effectiveness. We simulate network delays based on real-world\nmeasurements and prior work. We then track how quickly the attacker yields\nbalance information depending on what countermeasures routing nodes apply.\n\nWe hope that this work helps advance the discussion in the LN community\nabout the optimal ways to address the trade-offs between privacy, security,\nand efficiency.\n\n\nKind regards,\n\nAlex, Gleb, and Sergei\n\n[1] Herrera-Joancomarti\u0301 et al. On the Difficulty of Hiding the Balance of\nLightning Network Channels. https://eprint.iacr.org/2019/328\n[2] Kappos et al. An Empirical Analysis of Privacy in the Lightning\nNetwork. https://arxiv.org/abs/2003.12470\n[3] Tikhomirov et al. Probing Channel Balances in the Lightning Network.\nhttps://arxiv.org/abs/2004.00333\n-------------- next part --------------\nAn HTML attachment was scrubbed...\nURL: <http://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20210328/851bb90d/attachment.html>"
            }
        ],
        "thread_summary": {
            "title": "Analysis and Probing of Parallel Channels",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Sergei Tikhomirov"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 3178
        }
    },
    {
        "title": "[Lightning-dev] c-lightning release v0.10.0: Neutralizing Fee Therapy",
        "thread_messages": [
            {
                "author": "Rusty Russell",
                "date": "2021-03-31T20:23:53",
                "message_text_only": "We're pleased to announce the 0.10.0 release of c-lightning, named by @jsarenik.\n\n        https://github.com/ElementsProject/lightning/releases/tag/v0.10.0\n\nThis is a major release, consolidating a number of features, fixes and\nexperimental extensions.\n\nHighlights for Users\n\n* pay has been refined and much improved across various less-common scenarios.\n* listpeers shows the current feerate and unilateral close fee.\n* listforwards can now filter by channel status, and in our out channel.\n* fundpsbt and utxopsbt have a new excess_as_change parameter if you\n  don't want to add it yourself.\n* connect returns the address we actually connected to (and direction\n  tells you if they actually connected to us instead).\n* fundchannel_complete takes a PSBT, removing a common cause of tragic\n  opening failures: txprepare and withdraw now provide a PSBT for convenience too.\n* In regtest mode, we don't care that bitcoind doesn't give any fee\n  estimates, but use the minimum.\n\nHighlights for the Network\n\n* We now send warning messages if an error condition is possibly\n  recoverable, rather than closing the channel and sending error.\n* We now implement sync_complete for gossip_range queries as per latest\n  spec, with backwards compatibility for older nodes.\n* `experimental-dual-fund` config option enables the draft dual funding\n  option for compatible nodes, which includes RBF upgrades for opening\n  transactions.\n\nHighlights for Developers\n\n* All hooks are now registerable by multiple plugins at once.\n* `experimental-shutdown-wrong-funding` allows remote nodes to close\n  incorrectly opened channels using the new wrong_funding option to\n  close.\n\nMore details can be found in the changelog.\n\nThanks to everyone for their contributions and bug reports; please keep them coming.\n\nSince 0.9.3, we've had 339 commits from 14 different authors over 69 days.\n\nA special thanks goes to the 3 first time contributors:\n\n    Matthias Debernardini\n    Luke Childs\n    Alexey Zagarin\n\nCheers,\nRusty, Lisa, Christian, ZmnSCPxj"
            }
        ],
        "thread_summary": {
            "title": "c-lightning release v0.10.0: Neutralizing Fee Therapy",
            "categories": [
                "Lightning-dev"
            ],
            "authors": [
                "Rusty Russell"
            ],
            "messages_count": 1,
            "total_messages_chars_count": 2023
        }
    }
]